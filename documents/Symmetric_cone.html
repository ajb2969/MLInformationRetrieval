<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1782">Symmetric cone</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Symmetric cone</h1>
<hr>In [[mathematics]], '''symmetric cones''', sometimes called '''domains of positivity''', are open convex self-dual cones in Euclidean space which have a transitive group of symmetries, i.e. invertible operators that take the co
<p>ne onto itself. By the <a href="Koecher–Vinberg_theorem" title="wikilink">Koecher–Vinberg theorem</a> these correspond to the cone of squares in finite-dimensional <a href="Jordan_algebra#Formally_real_Jordan_algebras" title="wikilink">real Euclidean Jordan algebras</a>, originally studied and classified by . The <a href="tube_domain" title="wikilink">tube domain</a> associated with a symmetric cone is a noncompact <a href="Hermitian_symmetric_space" title="wikilink">Hermitian symmetric space</a> of <strong>tube type</strong>. All the algebraic and geometric structures associated with the symmetric space can be expressed naturally in terms of the Jordan algebra. The other irreducible Hermitian symmetric spaces of noncompact type correspond to <a href="Siegel_domain" title="wikilink">Siegel domains</a> of the second kind. These can be described in terms of more complicated structures called <a href="Jordan_triple_system" title="wikilink">Jordan triple systems</a>, which generalize Jordan algebras without identity.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="definitions">Definitions</h2>

<p>A <a href="convex_cone" title="wikilink">convex cone</a> <em>C</em> in a finite-dimensional real <a href="inner_product_space" title="wikilink">inner product space</a> <em>V</em> is a convex set invariant under multiplication by positive scalars. It spans the subspace <em>C</em> – <em>C</em> and the largest subspace it contains is <em>C</em> ∩ (−<em>C</em>). It spans the whole space if and only if it contains a basis. Since the <a href="convex_hull" title="wikilink">convex hull</a> of the basis is a polytope with non-empty interior, this happens if and only if <em>C</em> has non-empty interior. The interior in this case is also a convex cone. Moreover an open convex cone coincides with the interior of its closure, since any interior point in the closure must lie in the interior of some polytope in the original cone. A convex cone is said to be <em>proper</em> if its closure, also a cone, contains no subspaces.</p>

<p>Let <em>C</em> be an open convex cone. Its <strong>dual</strong> is defined as</p>

<p>

<math display="block" id="Symmetric_cone:0">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>C</mi>
     <mo>*</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>X</mi>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo>,</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>></mo>
      <mrow>
       <mpadded width="+3.4pt">
        <mn>0</mn>
       </mpadded>
       <mpadded width="+3.4pt">
        <mi>for</mi>
       </mpadded>
       <mi>Y</mi>
      </mrow>
      <mo>∈</mo>
      <mover accent="true">
       <mi>C</mi>
       <mo>¯</mo>
      </mover>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>C</ci>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>X</ci>
     <apply>
      <and></and>
      <apply>
       <gt></gt>
       <interval closure="open">
        <ci>X</ci>
        <ci>Y</ci>
       </interval>
       <apply>
        <times></times>
        <cn type="integer">0</cn>
        <ci>for</ci>
        <ci>Y</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <share href="#.cmml">
       </share>
       <apply>
        <ci>normal-¯</ci>
        <ci>C</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{C^{*}=\{X:(X,Y)>0\,\,\mathrm{for}\,\,Y\in\overline{C}\}.}
  </annotation>
 </semantics>
</math>

</p>

<p>It is also an open convex cone and <em>C</em>** = <em>C</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> An open convex cone <em>C</em> is said to be <strong>self-dual</strong> if <em>C</em>* = <em>C</em>. It is necessarily proper, since it does not contain 0, so cannot contain both <em>X</em> and −<em>X</em>.</p>

<p>The <strong>automorphism group</strong> of an open convex cone is defined by</p>

<p>

<math display="block" id="Symmetric_cone:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>Aut</mi>
     </mpadded>
     <mi>C</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>g</mi>
      <mo>∈</mo>
      <mrow>
       <mi>GL</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>V</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mi>g</mi>
       <mi>C</mi>
      </mrow>
      <mo>=</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Aut</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>g</ci>
      <apply>
       <times></times>
       <ci>GL</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>C</ci>
      </apply>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\mathrm{Aut}\,C=\{g\in\mathrm{GL}(V)|gC=C\}.}
  </annotation>
 </semantics>
</math>

</p>

<p>Clearly <em>g</em> lies in Aut <em>C</em> if and only if <em>g</em> takes the closure of <em>C</em> onto itself. So Aut <em>C</em> is a closed subgroup of GL(<em>V</em>) and hence a <a href="Lie_group" title="wikilink">Lie group</a>. Moreover Aut <em>C</em>* = (Aut <em>C</em>)*, where <em>g</em>* is the adjoint of <em>g</em>. <em>C</em> is said to be <strong>homogeneous</strong> if Aut <em>C</em> acts transitively on <em>C</em>.</p>

<p>The open convex cone <em>C</em> is called a <strong>symmetric cone</strong> if it is self-dual and homogeneous.</p>
<h2 id="group-theoretic-properties">Group theoretic properties</h2>
<ul>
<li>If <em>C</em> is a symmetric cone, then Aut <em>C</em> is closed under taking adjoints.</li>
<li>The identity component Aut<sub>0</sub> <em>C</em> acts transitively on <em>C</em>.</li>
<li>The stabilizers of points are <a href="maximal_compact_subgroup" title="wikilink">maximal compact subgroups</a>, all conjugate, and exhaust the maximal compact subgroups of Aut <em>C</em>.</li>
<li>In Aut<sub>0</sub> <em>C</em> the stabilizers of points are <a href="maximal_compact_subgroup" title="wikilink">maximal compact subgroups</a>, all conjugate, and exhaust the maximal compact subgroups of Aut<sub>0</sub> <em>C</em>.</li>
<li>The maximal compact subgroups of Aut<sub>0</sub> <em>C</em> are connected.</li>
<li>The component group of Aut <em>C</em> is isomorphic to the component group of a maximal compact subgroup and therefore finite.</li>
<li>Aut <em>C</em> ∩ O(V) and Aut<sub>0</sub> <em>C</em> ∩ O(V) are maximal compact subgroups in Aut <em>C</em> and Aut<sub>0</sub> <em>C</em>.</li>
<li><em>C</em> is naturally a <a href="Riemannian_symmetric_space" title="wikilink">Riemannian symmetric space</a> isomorphic to <em>G</em> / <em>K</em> where <em>G</em> = Aut<sub>0</sub> <em>C</em>. The Cartan involution is defined by σ(<em>g</em>)=(<em>g</em>*)<sup>−1</sup>, so that <em>K</em> = <em>G</em> ∩ O(V).</li>
</ul>
<h2 id="spectral-decomposition-in-a-euclidean-jordan-algebra">Spectral decomposition in a Euclidean Jordan algebra</h2>

<p>    In their classic paper,  studied and completely classified a class of finite-dimensional Jordan algebras, that are now called either <strong>Euclidean Jordan algebras</strong> or <strong>formally real Jordan algebras</strong>.</p>
<h3 id="definition">Definition</h3>

<p>Let <em>E</em> be a finite-dimensional real vector space with a symmetric bilinear product operation</p>

<p>

<math display="block" id="Symmetric_cone:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>E</mi>
      <mo>×</mo>
      <mi>E</mi>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mi>E</mi>
      <mo rspace="7.6pt">,</mo>
      <mi>a</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>b</mi>
     <mo>↦</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>b</mi>
      <mi>a</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>E</ci>
     </apply>
     <list>
      <ci>E</ci>
      <ci>a</ci>
     </list>
    </apply>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <ci>b</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{E\times E\rightarrow E,\,\,\,a,b\mapsto ab=ba,}
  </annotation>
 </semantics>
</math>

</p>

<p>with an identity element 1 such that <em>a</em>1 = <em>a</em> for <em>a</em> in <em>A</em> and a real inner product (<em>a</em>,<em>b</em>) for which the multiplication operators <em>L</em>(<em>a</em>) defined by <em>L</em>(<em>a</em>)<em>b</em> = <em>ab</em> on <em>E</em> are self-adjoint and satisfy the Jordan relation</p>

<p>

<math display="block" id="Symmetric_cone:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>a</ci>
     <ci>L</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>L</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{L(a)L(a^{2})=L(a^{2})L(a).}
  </annotation>
 </semantics>
</math>

</p>

<p>As will turn out below, the condition on adjoints can be replaced by the equivalent condition that the trace form Tr <em>L</em>(<em>ab</em>) defines an inner product. The trace form has the advantage of being manifestly invariant under automorphisms of the Jordan algebra, which is thus a closed subgroup of O(<em>E</em>) and thus a compact Lie group. In practical examples, however, it is often easier to produce an inner product for which the <em>L</em>(<em>a</em>) are self-adjoint than verify directly positive-definiteness of the trace form. (The equivalent original condition of Jordan, von Neumann and Wigner was that if a sum of squares of elements vanishes then each of those elements has to vanish.<ref>For a proof of equivalence see:</ref></p>
<ul>
<li>

<p>, Theorem 12</p></li>
<li>

<p>)</p></li>
</ul>
<h3 id="power-associativity">Power associativity</h3>

<p>From the Jordan condition it follows that the Jordan algebra is <a href="Power_associativity" title="wikilink"><strong>power associative</strong></a>, i.e. the Jordan subalgebra generated by any single element <em>a</em> in <em>E</em> is actually an associative commutative algebra. Thus, defining <em>a</em><sup><em>n</em></sup> inductively by <em>a</em><sup><em>n</em></sup> = <em>a</em> (<em>a</em><sup><em>n</em>−1</sup>), the following associativity relation holds:</p>

<p>

<math display="block" id="Symmetric_cone:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>a</mi>
      <mi>m</mi>
     </msup>
     <msup>
      <mi>a</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>a</mi>
     <mrow>
      <mi>m</mi>
      <mo>+</mo>
      <mi>n</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <apply>
      <plus></plus>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{a^{m}a^{n}=a^{m+n},}
  </annotation>
 </semantics>
</math>

</p>

<p>so the subalgebra can be identified with <strong>R</strong>[<em>a</em>], polynomials in <em>a</em>. In fact <a href="Polarization_of_an_algebraic_form" title="wikilink">polarizing</a> of the Jordan relation—replacing <em>a</em> by <em>a</em> + <em>tb</em> and taking the coefficient of <em>t</em>—yields</p>

<p>

<math display="block" id="Symmetric_cone:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>a</mi>
        <mn>2</mn>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>a</mi>
         <mn>2</mn>
        </msup>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>L</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
      <ci>L</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>L</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>L</ci>
      <ci>a</ci>
      <ci>L</ci>
      <ci>b</ci>
      <ci>L</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{2L(ab)L(a)+L(a^{2})L(b)=2L(a)L(b)L(a)+L(a^{2}b).}
  </annotation>
 </semantics>
</math>

</p>

<p>This identity implies that <em>L</em>(<em>a</em><sup><em>m</em></sup>) is a polynomial in <em>L</em>(<em>a</em>) and <em>L</em>(<em>a</em><sup>2</sup>) for all <em>m</em>. In fact, assuming the result for lower exponents than <em>m</em>,</p>

<p>

<math display="block" id="Symmetric_cone:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>a</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>a</mi>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>a</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>a</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>a</mi>
      <mi>m</mi>
     </msup>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>a</mi>
     <mrow>
      <mi>m</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>L</ci>
      <ci>a</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>a</ci>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <plus></plus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{a^{2}a^{m-1}=a^{m-1}(a^{2})=L(a^{m-1})L(a)a=L(a)L(a^{m-1})a=L(a)%
a^{m}=a^{m+1}.}
  </annotation>
 </semantics>
</math>

</p>

<p>Setting <em>b</em> = <em>a</em><sup><em>m</em> – 1</sup> in the polarized Jordan identity gives:</p>

<p>

<math display="block" id="Symmetric_cone:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mrow>
        <mi>m</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>a</mi>
         <mi>m</mi>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>a</mi>
         <mn>2</mn>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>a</mi>
         <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>L</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>a</mi>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <plus></plus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>L</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>m</ci>
       </apply>
       <ci>L</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>L</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{L(a^{m+1})=2L(a^{m})L(a)+L(a^{2})L(a^{m-1})-2L(a)^{2}L(a^{m-1}),}
  </annotation>
 </semantics>
</math>

</p>

<p>a <a href="recurrence_relation" title="wikilink">recurrence relation</a> showing inductively that <em>L</em>(<em>a</em><sup><em>m</em> + 1</sup>) is a polynomial in <em>L</em>(<em>a</em>) and <em>L</em>(<em>a</em><sup>2</sup>).</p>

<p>Consequently if power-associativity holds when the first exponent is ≤ <em>m</em>, then it also holds for <em>m</em>+1 since</p>

<p>

<math display="block" id="Symmetric_cone:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mrow>
        <mi>m</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>a</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>a</mi>
         <mi>m</mi>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mi>a</mi>
        <mi>n</mi>
       </msup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>a</mi>
         <mn>2</mn>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>a</mi>
         <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mi>a</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>L</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>a</mi>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>a</mi>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>a</mi>
     <mrow>
      <mi>m</mi>
      <mo>+</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <plus></plus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>L</ci>
        <ci>a</ci>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <apply>
          <minus></minus>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>L</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>L</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <plus></plus>
       <ci>m</ci>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{L(a^{m+1})a^{n}=2L(a)L(a^{m})a^{n}+L(a^{2})L(a^{m-1})a^{n}-2L(a)%
^{2}L(a^{m-1})a^{n}=a^{m+n+1}.}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="idempotents-and-rank">Idempotents and rank</h3>

<p>An element <em>e</em> in <em>E</em> is called an <a class="uri" href="idempotent" title="wikilink">idempotent</a> if <em>e</em><sup>2</sup> = <em>e</em>. Two idempotents are said to be orthogonal if <em>ef</em> = 0. This is equivalent to orthogonality with respect to the inner product, since (<em>ef</em>,<em>ef</em>) = (<em>e</em>,<em>f</em>). In this case <em>g</em> = <em>e</em> + <em>f</em> is also an idempotent. An idempotent <em>g</em> is called <em>primitive</em> or <em>minimal</em> if it cannot be written as a sum of non-zero orthogonal idempotents. If <em>e</em><sub>1</sub>, ..., <em>e</em><sub><em>m</em></sub> are pairwise orthogonal idempotents then their sum is also an idempotent and the algebra they generate consists of all linear combinations of the <em>e</em><sub><em>i</em></sub>. It is an associative algebra. If <em>e</em> is an idempotent, then 1 − <em>e</em> is an orthogonal idempotent. An orthogonal set of idempotents with sum 1 is said to be a <em>complete set</em> or a <em>partition of 1</em>. If each idempotent in the set is minimal it is called a <em>Jordan frame</em>. Since the number of elements in any orthogonal set of idempotents is bounded by dim <em>E</em>, Jordan frames exist. The maximal number of elements in a Jordan frame is called the <strong>rank</strong> <em>r</em> of <em>E</em>.</p>
<h3 id="spectral-decomposition">Spectral decomposition</h3>

<p>The spectral theorem states that any element <em>a</em> can be uniquely written as</p>

<p>

<math display="block" id="Symmetric_cone:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>e</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <sum></sum>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{a=\sum\lambda_{i}e_{i},}
  </annotation>
 </semantics>
</math>

</p>

<p>where the idempotents <em>e</em><sub><em>i</em></sub>'s are a partition of 1 and the λ<sub><em>i</em></sub>, the <em>eigenvalues</em> of <em>a</em>, are real and distinct. In fact let <em>E</em><sub>0</sub> = <strong>R</strong>[a] and let <em>T</em> be the restriction of <em>L</em>(<em>a</em>) to <em>E</em><sub>0</sub>. <em>T</em> is self-adjoint and has 1 as a cyclic vector. So the <a class="uri" href="commutant" title="wikilink">commutant</a> of <em>T</em> consists of polynomials in <em>T</em> (or <em>a</em>). By the <a href="spectral_theorem" title="wikilink">spectral theorem</a> for self-adjoint operators,</p>

<p>

<math display="block" id="Symmetric_cone:10">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <msub>
      <mi>λ</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>P</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <sum></sum>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{T=\sum\lambda_{i}P_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>where the <em>P</em><sub><em>i</em></sub> are orthogonal projections on <em>E</em><sub>0</sub> with sum <em>I</em> and the λ<sub><em>i</em></sub>'s are the distinct real eigenvalues of <em>T</em>. Since the <em>P</em><sub><em>i</em></sub>'s commute with <em>T</em> and are self-adjoint, they are given by multiplication elements <em>e</em><sub><em>i</em></sub> of <strong>R</strong>[a] and thus form a partition of 1. Uniqueness follows because if <em>f</em><sub><em>i</em></sub> is a partition of 1 and <em>a</em> = ∑ μ<sub><em>i</em></sub> <em>f</em><sub><em>i</em></sub>, then with <em>p</em>(<em>t</em>)=∏ (<em>t</em> - μ<sub><em>j</em></sub>) and <em>p</em><sub><em>i</em></sub> = <em>p</em>/(<em>t</em> − μ<sub><em>i</em></sub>), <em>f</em><sub><em>i</em></sub> = <em>p</em><sub><em>i</em></sub>(<em>a</em>)/<em>p</em><sub><em>i</em></sub>(μ<sub><em>i</em></sub>). So the <em>f</em><sub><em>i</em></sub>'s are polynomials in <em>a</em> and uniqueness follows from uniqueness of the spectral decomposition of <em>T</em>.</p>

<p>The spectral theorem implies that the rank is independent of the Jordan frame. For a Jordan frame with <em>k</em> minimal idempotents can be used to construct an element <em>a</em> with <em>k</em> distinct eigenvalues. As above the minimal polynomial <em>p</em> of <em>a</em> has degree <em>k</em> and <strong>R</strong>[<em>a</em>] has dimension <em>k</em>. Its dimension is also the largest <em>k</em> such that <em>F</em><sub><em>k</em></sub>(<em>a</em>) ≠ 0 where <em>F</em><sub><em>k</em></sub>(<em>a</em>) is the determinant of a <a href="Gram_matrix" title="wikilink">Gram matrix</a>:</p>

<p>

<math display="block" id="Symmetric_cone:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">det</mo>
      <mrow>
       <mrow>
        <mn>0</mn>
        <mo>≤</mo>
        <mi>m</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>n</mi>
        <mo><</mo>
        <mi>k</mi>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mi>m</mi>
      </msup>
      <mo>,</mo>
      <msup>
       <mi>a</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>k</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <determinant></determinant>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <leq></leq>
        <cn type="integer">0</cn>
        <ci>m</ci>
       </apply>
       <apply>
        <lt></lt>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{F_{k}(a)=\det_{0\leq m,n<k}(a^{m},a^{n}).}
  </annotation>
 </semantics>
</math>

</p>

<p>So the rank <em>r</em> is the largest integer <em>k</em> for which <em>F</em><sub><em>k</em></sub> is not identically zero on <em>E</em>. In this case, as a non-vanishing polynomial, <em>F</em><sub><em>r</em></sub> is non-zero on an open dense subset of <em>E</em>. the <em>regular elements</em>. Any other <em>a</em> is a limit of regular elements <em>a</em><sup>(<em>n</em>)</sup>. Since the operator norm of <em>L</em>(<em>x</em>) gives an equivalent norm on <em>E</em>, a standard compactness argument shows that, passing to a subsequence if necessary, the spectral idempotents of the <em>a</em><sup>(<em>n</em>)</sup> and their corresponding eigenvalues are convergent. The limit of Jordan frames is a Jordan frame, since a limit of non-zero idempotents yields a non-zero idempotent by continuity of the operator norm. It follows that every Jordan frame is made up of <em>r</em> minimal idempotents.</p>

<p>If <em>e</em> and <em>f</em> are orthogonal idempotents, the spectral theorem shows that <em>e</em> and <em>f</em> are polynomials in <em>a</em> = <em>e</em> − <em>f</em>, so that <em>L</em>(<em>e</em>) and <em>L</em>(<em>f</em>) commute. This can be seen directly from the polarized Jordan identity which implies <em>L</em>(<em>e</em>)<em>L</em>(<em>f</em>) = 2 <em>L</em>(<em>e</em>)<em>L</em>(<em>f</em>)<em>L</em>(<em>e</em>). Commutativity follows by taking adjoints.</p>
<h3 id="spectral-decomposition-for-an-idempotent">Spectral decomposition for an idempotent</h3>

<p>If <em>e</em> is a non-zero idempotent then the eigenvalues of <em>L</em>(<em>e</em>) can only be 0, 1/2 and 1, since taking <em>a</em> = <em>b</em> = <em>e</em> in the polarized Jordan identity yields</p>

<p>

<math display="block" id="Symmetric_cone:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>L</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>e</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>3</mn>
      </msup>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>3</mn>
      <mi>L</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>e</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>e</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>L</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>L</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{2L(e)^{3}-3L(e)^{2}+L(e)=0.}
  </annotation>
 </semantics>
</math>

</p>

<p>In particular the operator norm of <em>L</em>(<em>e</em>) is 1 and its trace is strictly positive.</p>

<p>There is a corresponding orthogonal eigenspace decomposition of <em>E</em></p>

<p>

<math display="block" id="Symmetric_cone:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>E</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>e</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊕</mo>
     <mrow>
      <msub>
       <mi>E</mi>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>e</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊕</mo>
     <mrow>
      <msub>
       <mi>E</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>e</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>e</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>e</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{E=E_{0}(e)\oplus E_{1/2}(e)\oplus E_{1}(e),}
  </annotation>
 </semantics>
</math>

</p>

<p>where, for <em>a</em> in <em>E</em>, <em>E</em><sub>λ</sub>(<em>a</em>) denotes the λ-eigenspace of <em>L</em>(<em>a</em>). In this decomposition <em>E</em><sub>1</sub>(<em>e</em>) and <em>E</em><sub>0</sub>(<em>e</em>) are Jordan algebras with identity elements <em>e</em> and 1 − <em>e</em>. Their sum <em>E</em><sub>1</sub>(<em>e</em>) ⊕ <em>E</em><sub>0</sub>(<em>e</em>) is a direct sum of Jordan algebras in that any product between them is zero. It is the <em>centralizer subalgebra</em> of <em>e</em> and consists of all <em>a</em> such that <em>L</em>(<em>a</em>) commutes with <em>L</em>(<em>e</em>). The subspace <em>E</em><sub>1/2</sub>(<em>e</em>) is a module for the centralizer of <em>e</em>, the <em>centralizer module</em>, and the product of any two elements in it lies in the centralizer subalgebra. On the other hand if</p>

<p>

<math display="block" id="Symmetric_cone:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mn>8</mn>
       <mi>L</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>e</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mn>8</mn>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>e</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi>I</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">8</cn>
       <ci>L</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">8</cn>
       <ci>L</ci>
       <ci>e</ci>
      </apply>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{U=8L(e)^{2}-8L(e)+I,}
  </annotation>
 </semantics>
</math>

</p>

<p>then <em>U</em> is self-adjoint equal to 1 on the centralizer algebra and −1 on the centralizer module. So <em>U</em><sup>2</sup> = <em>I</em> and the properties above show that</p>

<p>

<math display="block" id="Symmetric_cone:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\sigma(x)=Ux}
  </annotation>
 </semantics>
</math>

</p>

<p>defines an involutive Jordan algebra automorphism σ of <em>E</em>.</p>
<dl>
<dd><small>In fact the Jordan algebra and module properties follow by replacing <em>a</em> and <em>b</em> in the polarized Jordan identity by <em>e</em> and <em>a</em>. If <em>ea</em> = 0, this gives <em>L</em>(<em>e</em>)<em>L</em>(<em>a</em>) = 2<em>L</em>(<em>e</em>)<em>L</em>(<em>a</em>)<em>L</em>(<em>e</em>). Taking adjoints it follows that <em>L</em>(<em>a</em>) commutes with <em>L</em>(<em>e</em>). Similarly if (1 − <em>e</em>)<em>a</em> = 0, <em>L</em>(<em>a</em>) commutes with <em>I</em> − <em>L</em>(<em>e</em>) and hence <em>L</em>(<em>e</em>). This implies the Jordan algebra and module properties. To check that a product of elements in the module lies in the algebra, it is enough to check this for squares: but if <em>L</em>(<em>e</em>)<em>a</em> = ½ <em>a</em>, then <em>ea</em> = ½ <em>a</em>, so <em>L</em>(<em>a</em>)<sup>2</sup> + <em>L</em>(<em>a</em><sup>2</sup>)<em>L</em>(<em>e</em>) = 2<em>L</em>(<em>a</em>)<em>L</em>(<em>e</em>)<em>L</em>(<em>a</em>) + <em>L</em>(<em>a</em><sup>2</sup><em>e</em>). Taking adjoints it follows that <em>L</em>(<em>a</em><sup>2</sup>) commutes with <em>L</em>(<em>e</em>), which implies the property for squares.</small>
</dd>
</dl>
<h3 id="trace-form">Trace form</h3>

<p>The trace form is defined by</p>

<p>

<math display="block" id="Symmetric_cone:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>Tr</mi>
     </mpadded>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>τ</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>Tr</ci>
     <ci>L</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\tau(a,b)=\mathrm{Tr}\,L(ab).}
  </annotation>
 </semantics>
</math>

</p>

<p>It is an inner product since, for non-zero <em>a</em> = ∑ λ<sub><em>i</em></sub> <em>e</em><sub><em>i</em></sub>,</p>

<p>

<math display="block" id="Symmetric_cone:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <msubsup>
      <mi>λ</mi>
      <mi>i</mi>
      <mn>2</mn>
     </msubsup>
     <mpadded width="+1.7pt">
      <mi>Tr</mi>
     </mpadded>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>e</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>τ</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>a</ci>
      </interval>
     </apply>
     <apply>
      <sum></sum>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>Tr</ci>
       <ci>L</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\tau(a,a)=\sum\lambda_{i}^{2}\mathrm{Tr}\,L(e_{i})>0.}
  </annotation>
 </semantics>
</math>

</p>

<p>The polarized Jordan identity can be polarized again by replacing <em>a</em> by <em>a</em> + <em>tc</em> and taking the coefficient of <em>t</em>. A further anyisymmetrization in <em>a</em> and <em>c</em> yields:</p>

<p>

<math display="block" id="Symmetric_cone:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>b</mi>
          <mi>c</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>a</mi>
          <mi>b</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>c</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>c</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
    <interval closure="closed">
     <interval closure="closed">
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>b</ci>
      </apply>
     </interval>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>c</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{L(a(bc)-(ab)c)=[[L(a),L(b)],L(c)].}
  </annotation>
 </semantics>
</math>

</p>

<p>Applying the trace to both sides</p>

<p>

<math display="block" id="Symmetric_cone:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mrow>
       <mi>b</mi>
       <mi>c</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>b</mi>
       <mi>a</mi>
      </mrow>
      <mo>,</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>τ</ci>
     <interval closure="open">
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>c</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>τ</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>a</ci>
      </apply>
      <ci>c</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\tau(a,bc)=\tau(ba,c),}
  </annotation>
 </semantics>
</math>

</p>

<p>so that <em>L</em>(<em>b</em>) is self-adjoint for the trace form.</p>
<h2 id="simple-euclidean-jordan-algebras">Simple Euclidean Jordan algebras</h2>

<p> The classification of simple Euclidean Jordan algebras was accomplished by , with details of the one exceptional algebra provided in the article immediately following theirs by . Using the <a href="Peirce_decomposition" title="wikilink">Peirce decomposition</a>, they reduced the problem to an algebraic problem involving <a href="Hurwitz's_theorem_(composition_algebras)" title="wikilink">multiplicative quadratic forms</a> already solved by <a href="Adolf_Hurwitz" title="wikilink">Hurwitz</a>. The presentation here, following , using <a href="composition_algebra" title="wikilink">composition algebras</a> or <strong>Euclidean Hurwitz algebras,</strong> is a shorter version of the original derivation.</p>
<h3 id="central-decomposition">Central decomposition</h3>

<p>If <em>E</em> is a Euclidean Jordan algebra an <strong>ideal</strong> <em>F</em> in <em>E</em> is a linear subspace closed under multiplication by elements of <em>E</em>, i.e. <em>F</em> is invariant under the operators <em>L</em>(<em>a</em>) for <em>a</em> in <em>E</em>. If <em>P</em> is the orthogonal projection onto <em>F</em> it commutes with the operators <em>L</em>(<em>a</em>), In particular <em>F</em><sup>⊥</sup> = (<em>I</em> − <em>P</em>)<em>E</em> is also an ideal and <em>E</em> = <em>F</em> ⊕ <em>F</em><sup>⊥</sup>. Furthermore, if <em>e</em> = <em>P</em>(1), then <em>P</em> = <em>L</em>(<em>e</em>). In fact for <em>a</em> in <em>E</em></p>

<p>

<math display="block" id="Symmetric_cone:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mi>a</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>a</mi>
     <mi>e</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>a</ci>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{ea=ae=L(a)P(1)=P(L(a)1)=P(a),}
  </annotation>
 </semantics>
</math>

</p>

<p>so that <em>ea</em> = <em>a</em> for <em>a</em> in <em>F</em> and 0 for <em>a</em> in <em>F</em><sup>⊥</sup>. In particular <em>e</em> and 1 − <em>e</em> are orthogonal idempotents with <em>L</em>(<em>e</em>) = <em>P</em> and <em>L</em>(1 − <em>e</em>) = <em>I</em> − <em>P</em>. <em>e</em> and 1 − <em>e</em> are the identities in the Euclidean Jordan algebras <em>F</em> and <em>F</em><sup>⊥</sup>. The idempotent <em>e</em> is <em>central</em> in <em>E</em>, where the <strong>center</strong> of <em>E</em> is defined to be the set of all <em>z</em> such that <em>L</em>(<em>z</em>) commutes with <em>L</em>(<em>a</em>) for all <em>a</em>. It forms a commutative associative subalgebra.</p>

<p>Continuing in this way <em>E</em> can be written as a direct sum of minimal ideals</p>

<p>

<math display="block" id="Symmetric_cone:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mo>=</mo>
    <mrow>
     <mo>⊕</mo>
     <msub>
      <mi>E</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{E=\oplus E_{i}.}
  </annotation>
 </semantics>
</math>

</p>

<p>If <em>P</em><sub><em>i</em></sub> is the projection onto <em>E</em><sub><em>i</em></sub> and <em>e</em><sub><em>i</em></sub> = <em>P</em><sub><em>i</em></sub>(1) then <em>P</em><sub><em>i</em></sub> = <em>L</em>(<em>e</em><sub><em>i</em></sub>). The <em>e</em><sub><em>i</em></sub>'s are orthogonal with sum 1 and are the identities in <em>E</em><sub><em>i</em></sub>. Minimality forces <em>E</em><sub><em>i</em></sub> to be <strong>simple</strong>, i.e. to have no non-trivial ideals. For since <em>L</em>(<em>e</em><sub><em>i</em></sub>) commutes with all <em>L</em>(<em>a</em>)'s, any ideal <em>F</em> ⊂ <em>E</em><sub><em>i</em></sub> would be invariant under <em>E</em> since <em>F</em> = <em>e</em><sub><em>i</em></sub><em>F</em>. Such a decomposition into a direct sum of simple Euclidean algebras is unique. If <em>E</em> = ⊕ <em>F</em><sub><em>j</em></sub> is another decomposition, then <em>F</em><sub><em>j</em></sub>=⊕ e<sub><em>i</em></sub><em>F</em><sub><em>j</em></sub>. By minimality only one of the terms here is non-zero so equals <em>F</em><sub><em>j</em></sub>. By minimality the corresponding <em>E</em><sub><em>i</em></sub> equals <em>F</em><sub><em>j</em></sub>, proving uniqueness.</p>

<p>In this way the classification of Euclidean Jordan algebras is reduced to that of simple ones. For a simple algebra <em>E</em> all inner products for which the operators <em>L</em>(<em>a</em>) are self adjoint are proportional. Indeed any other product has the form (<em>Ta</em>, <em>b</em>) for some positive self-adjoint operator commuting with the <em>L</em>(<em>a</em>)'s. Any non-zero eigenspace of <em>T</em> is an ideal in <em>A</em> and therefore by simplicity <em>T</em> must act on the whole of <em>E</em> as a positive scalar.</p>
<h3 id="list-of-all-simple-euclidean-jordan-algebras">List of all simple Euclidean Jordan algebras</h3>
<ul>
<li>Let <em>H</em><sub><em>n</em></sub>(<strong>R</strong>) be the space of real symmetric <em>n</em> by <em>n</em> matrices with inner product (<em>a</em>,<em>b</em>) = Tr <em>ab</em> and Jordan product <em>a</em> ∘ <em>b</em> = ½(<em>ab</em> + <em>ba</em>). Then <em>H</em><sub><em>n</em></sub>(<strong>R</strong>) is a simple Euclidean Jordan algebra of rank <em>n</em> for <em>n</em> ≥ 3.</li>
</ul>
<ul>
<li>Let <em>H</em><sub><em>n</em></sub>(<strong>C</strong>) be the space of complex self-adjoint <em>n</em> by <em>n</em> matrices with inner product (<em>a</em>,<em>b</em>) = Re Tr <em>ab</em>* and Jordan product <em>a</em> ∘ <em>b</em> = ½(<em>ab</em> + <em>ba</em>). Then <em>H</em><sub><em>n</em></sub>(<strong>C</strong>) is a simple Euclidean Jordan algebra of rank <em>n</em> ≥ 3.</li>
</ul>
<ul>
<li>Let <em>H</em><sub><em>n</em></sub>(<strong>H</strong>) be the space of self-adjoint <em>n</em> by <em>n</em> matrices with entries in the <a href="quaternion" title="wikilink">quaternions</a>, inner product (<em>a</em>,<em>b</em>) = Re Tr <em>ab</em>* and Jordan product <em>a</em> ∘ <em>b</em> = ½(<em>ab</em> + <em>ba</em>). Then <em>H</em><sub><em>n</em></sub>(<strong>H</strong>) is a simple Euclidean Jordan algebra of rank <em>n</em> ≥ 3.</li>
</ul>
<ul>
<li>Let <em>V</em> be a finite dimensional real inner product space and set <em>E</em> = <em>V</em> ⊕ <strong>R</strong> with inner product (<em>u</em>⊕λ,<em>v</em>⊕μ) =(<em>u</em>,<em>v</em>) + λμ and product (u⊕λ)∘(v⊕μ)=( μ<em>u</em> + λ<em>v</em>) ⊕ [(<em>u</em>,<em>v</em>) + λμ]. This is a Euclidean Jordan algebra of rank 2.</li>
</ul>
<ul>
<li>The above examples in fact give all the simple Euclidean Jordan algebras, except for one exceptional case <em>H</em><sub>3</sub>(<strong>O</strong>), the self-adjoint matrices over the <a href="octonion" title="wikilink">octonions</a> or <a href="Cayley_number" title="wikilink">Cayley numbers</a>, another rank 3 simple Euclidean Jordan algebra of dimension 27 (see below).</li>
</ul>
<h3 id="peirce-decomposition">Peirce decomposition</h3>

<p>Let <em>E</em> be a simple Euclidean Jordan algebra with inner product given by the trace form τ(<em>a</em>)= Tr <em>L</em>(<em>a</em>). The proof that <em>E</em> has the above form rests on constructing an analogue of matrix units for a Jordan frame in <em>E</em>. The following properties of idempotents hold in <em>E</em>.</p>
<ul>
<li>An idempotent <em>e</em> is minimal in <em>E</em> if and only if <em>E</em><sub>1</sub>(<em>e</em>) has dimension one (so equals <strong>R</strong><em>e</em>). Moreover <em>E</em><sub>1/2</sub>(<em>e</em>) ≠ (0). In fact the spectral projections of any element of <em>E</em><sub>1</sub>(<em>e</em>) lie in <em>E</em> so if non-zero must equal <em>e</em>. If the 1/2 eigenspace vanished then <em>E</em><sub>1</sub>(<em>e</em>) = <strong>R</strong><em>e</em> would be an ideal.</li>
</ul>
<ul>
<li>If <em>e</em> and <em>f</em> are non-orthogonal minimal idempotents, then there is a period 2 automorphism σ of <em>E</em> such that σ<em>e</em>=<em>f</em>, so that <em>e</em> and <em>f</em> have the same trace.</li>
</ul>
<ul>
<li>If <em>e</em> and <em>f</em> are orthogonal minimal idempotents then <em>E</em><sub>1/2</sub>(<em>e</em>) ∩ <em>E</em><sub>1/2</sub>(<em>f</em>) ≠ (0). Moreover there is a period 2 automorphism σ of <em>E</em> such that σ<em>e</em>=<em>f</em>, so that <em>e</em> and <em>f</em> have the same trace, and for any <em>a</em> in this intersection, <em>a</em><sup>2</sup> = ½ τ(<em>e</em>) |<em>a</em>|<sup>2</sup> (<em>e</em> + <em>f</em>).</li>
</ul>
<ul>
<li>All minimal idempotents in <em>E</em> are in the same orbit of the automorphism group so have the same trace τ<sub>0</sub>.</li>
</ul>
<ul>
<li>If <em>e</em>, <em>f</em>, <em>g</em> are three minimal orthogonal idempotents, then for <em>a</em> in <em>E</em><sub>1/2</sub>(<em>e</em>) ∩ <em>E</em><sub>1/2</sub>(<em>f</em>) and <em>b</em> in <em>E</em><sub>1/2</sub>(<em>f</em>) ∩ <em>E</em><sub>1/2</sub>(<em>g</em>), <em>L</em>(<em>a</em>)<sup>2</sup> <em>b</em> = ⅛ τ<sub>0</sub> |<em>a</em>|<sup>2</sup> <em>b</em> and |<em>ab</em>|<sup>2</sup> = ⅛ τ<sub>0</sub> |<em>a</em>|<sup>2</sup>|<em>b</em>|<sup>2</sup>. Moreover <em>E</em><sub>1/2</sub>(<em>e</em>) ∩ <em>E</em><sub>1/2</sub>(<em>f</em>) ∩ <em>E</em><sub>1/2</sub>(<em>g</em>) = (0).</li>
</ul>
<ul>
<li>If <em>e</em><sub><em>1</em></sub>, ..., <em>e</em><sub><em>r</em></sub> and <em>f</em><sub><em>1</em></sub>, ..., <em>f</em><sub><em>r</em></sub> are Jordan frames in <em>E</em>, then there is an automorphism α such that α<em>e</em><sub><em>i</em></sub> = <em>f</em><sub><em>i</em></sub>.</li>
</ul>
<ul>
<li>If (<em>e</em><sub><em>i</em></sub>) is a Jordan frame and <em>E</em><sub><em>ii</em></sub> = <em>E</em><sub>1</sub>(<em>e</em><sub><em>i</em></sub>) and <em>E</em><sub><em>ij</em></sub> = <em>E</em><sub>1/2</sub>(<em>e</em><sub><em>i</em></sub>) ∩ <em>E</em><sub>1/2</sub>(<em>e</em><sub><em>j</em></sub>), then <em>E</em> is the orthogonal direct sum the <em>E</em><sub><em>ii</em></sub>'s and <em>E</em><sub><em>ij</em></sub>'s. Since <em>E</em> is simple, the <em>E</em><sub><em>ii</em></sub>'s are one-dimensional and the subspaces <em>E</em><sub><em>ij</em></sub> are all non-zero for <em>i</em> ≠ <em>j</em>.</li>
</ul>
<ul>
<li>If <em>a</em> = ∑ α<sub><em>i</em></sub> <em>e</em><sub><em>i</em></sub> for some Jordan frame (<em>e</em><sub><em>i</em></sub>), then <em>L</em>(<em>a</em>) acts as α<sub><em>i</em></sub> on <em>E</em><sub><em>ii</em></sub> and (α<sub><em>i</em></sub> + α<sub><em>i</em></sub>)/2 on <em>E</em><sub><em>ij</em></sub>.</li>
</ul>
<h3 id="reduction-to-euclidean-hurwitz-algebras">Reduction to Euclidean Hurwitz algebras</h3>

<p>Let <em>E</em> be a simple Euclidean Jordan algebra. From the properties of the Peirce decomposition it follows that:</p>
<ul>
<li>If <em>E</em> has rank 2, then it has the form <em>V</em> ⊕ <strong>R</strong> for some inner product space <em>V</em> with Jordan product as described above.</li>
</ul>
<ul>
<li>If <em>E</em> has rank <em>r</em> &gt; 2, then there is an non-associative unital algebra <em>A</em>, associative if <em>r</em> &gt; 3, equipped with an inner product satisfying (ab,ab)= (a,a)(b,b) and such that <em>E</em> = <em>H</em><sub><em>r</em></sub>(<em>A</em>). (Conjugation in <em>A</em> is defined by <em>a</em>* = −a + 2(a,1)1.)</li>
</ul>

<p>Such an algebra <em>A</em> is called a <strong>Euclidean Hurwitz algebra</strong>. In <em>A</em> if λ(<em>a</em>)<em>b</em> = <em>ab</em> and ρ(<em>a</em>)<em>b</em> = <em>ba</em>, then:</p>
<ul>
<li>the involution is an antiautomorphism, i.e. 

<math display="inline" id="Symmetric_cone:22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mi mathvariant="normal"></mi>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
   <mo>=</mo>
   <mi>b</mi>
   <mo>*</mo>
   <mi>a</mi>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown"></csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <times></times>
    <eq></eq>
    <csymbol cd="unknown">b</csymbol>
    <times></times>
    <csymbol cd="unknown">a</csymbol>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a b)*=b*a*
  </annotation>
 </semantics>
</math>

</li>
<li><mtpl></mtpl></li>
<li>

<math display="inline" id="Symmetric_cone:23">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>*</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>λ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ(a*)=λ(a)*
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Symmetric_cone:24">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>*</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">ρ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">ρ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ρ(a*)=ρ(a)*
  </annotation>
 </semantics>
</math>

, so that the involution on the algebra corresponds to taking <a href="adjoint_operator" title="wikilink">adjoints</a></li>
<li>

<math display="inline" id="Symmetric_cone:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi mathvariant="normal"></mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mi mathvariant="normal"></mi>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>e</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>normal-</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>e</ci>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>normal-</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Re(a b)=Re(b a)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Symmetric_cone:26">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mi>e</mi>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mi>x</mi>
    <mo>*</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi mathvariant="normal"></mi>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <csymbol cd="unknown">x</csymbol>
     <times></times>
     <ci>normal-)</ci>
    </cerror>
    <divide></divide>
    <cn type="integer">2</cn>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown"></csymbol>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rex=(x+x*)/2=(x, 1)1
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Symmetric_cone:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi mathvariant="normal"></mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mi>e</mi>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mi mathvariant="normal"></mi>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>e</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>normal-</ci>
      <ci>b</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>e</ci>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>normal-</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Re(a b)c=Rea(b c)
  </annotation>
 </semantics>
</math>

</li>
<li><mtpl></mtpl>, <mtpl></mtpl>, so that 

<math display="inline" id="Symmetric_cone:28">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is an <a href="alternating_algebra" title="wikilink">alternating algebra</a></li>
</ul>

<p>By <a href="Hurwitz's_theorem_(normed_division_algebras)" title="wikilink">Hurwitz's theorem</a> <em>A</em> must be isomorphic to <strong>R</strong>, <strong>C</strong>, <strong>H</strong> or <strong>O</strong>. The first three are associative division algebras. The octonions do not form an associative algebra, so <em>H</em><sub><em>r</em></sub>(<strong>O</strong>) can only give a Jordan algebra for <em>r</em> = 3. Because <em>A</em> is associative when <em>A</em> = <strong>R</strong>, <strong>C</strong> or <strong>H</strong>, it is immediate that <em>H</em><sub><em>r</em></sub>(<em>A</em>) is a Jordan algebra for <em>r</em> ≥ 3. A separate argument, given originally by , is required to show that <em>H</em><sub>3</sub>(<strong>O</strong>) with Jordan product <em>a</em>∘<em>b</em> = ½(<em>ab</em> + <em>ba</em>) satisfies the Jordan identity [<em>L</em>(<em>a</em>),<em>L</em>(<em>a</em><sup>2</sup>)] = 0. There is a later more direct proof using the <a href="Freudenthal_diagonalization_theorem" title="wikilink">Freudenthal diagonalization theorem</a> due to : he proved that given any matrix in the algebra <em>H</em><sub><em>r</em></sub>(<strong>A</strong>) there is an algebra automorphism carrying the matrix onto a diagonal matrix with real entries; it is then straightforward to check that [<em>L</em>(<em>a</em>),<em>L</em>(<em>b</em>)] = 0 for real diagonal matrices.<ref>See:</ref></p>
<ul>
<li></li>
<li></li>
<li></li>
<li>

<p></p></li>
</ul>
<h3 id="exceptional-and-special-euclidean-jordan-algebras">Exceptional and special Euclidean Jordan algebras</h3>

<p>The <strong>exceptional</strong> Euclidean Jordan algebra <em>E</em>= <em>H</em><sub>3</sub>(<strong>O</strong>) is called the <a href="Albert_algebra" title="wikilink">Albert algebra</a>. The Cohn–Shirshov theorem implies that it cannot be generated by two elements (and the identity). This can be seen directly. For by Freudenthal's diagonalization theorem one element <em>X</em> can be taken to be a diagonal matrix with real entries and the other <em>Y</em> to be orthogonal to the Jordan subalgebra generated by <em>X</em>. If all the diagonal entries of <em>X</em> are distinct, the Jordan subalgebra generated by <em>X</em> and <em>Y</em> is generated by the diagonal matrices and three elements</p>

<p>

<math display="block" id="Symmetric_cone:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Y</mi>
      <mn>1</mn>
     </msub>
     <mo>=</mo>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>y</mi>
          <mn>1</mn>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <msubsup>
          <mi>y</mi>
          <mn>1</mn>
          <mo>*</mo>
         </msubsup>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo rspace="7.6pt">,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>Y</mi>
       <mn>2</mn>
      </msub>
      <mo>=</mo>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <msubsup>
           <mi>y</mi>
           <mn>2</mn>
           <mo>*</mo>
          </msubsup>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>y</mi>
           <mn>2</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo rspace="7.6pt">,</mo>
     <mrow>
      <msub>
       <mi>Y</mi>
       <mn>3</mn>
      </msub>
      <mo>=</mo>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>y</mi>
           <mn>3</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msubsup>
           <mi>y</mi>
           <mn>3</mn>
           <mo>*</mo>
          </msubsup>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <cn type="integer">1</cn>
     </apply>
     <matrix>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">1</cn>
        </apply>
        <times></times>
       </apply>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <cn type="integer">2</cn>
      </apply>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">2</cn>
         </apply>
         <times></times>
        </apply>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <cn type="integer">3</cn>
      </apply>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">3</cn>
        </apply>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">3</cn>
         </apply>
         <times></times>
        </apply>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Y_{1}=\begin{pmatrix}0&0&0\\
0&0&y_{1}\\
0&y_{1}^{*}&0\end{pmatrix},\,\,\,Y_{2}=\begin{pmatrix}0&0&y_{2}^{*}\\
0&0&0\\
y_{2}&0&0\end{pmatrix},\,\,\,Y_{3}=\begin{pmatrix}0&y_{3}&0\\
y_{3}^{*}&0&0\\
0&0&0\end{pmatrix}.}
  </annotation>
 </semantics>
</math>

</p>

<p>It is straightforward to verify that the real linear span of the diagonal matrices, these matrices and similar matrices with real entries form a unital Jordan subalgebra. If the diagonal entries of <em>X</em> are not distinct, <em>X</em> can be taken to be the primitive idempotent <em>e</em><sub>1</sub> with diagonal entries 1, 0 and 0. The analysis in  then shows that the unital Jordan subalgebra generated by <em>X</em> and <em>Y</em> is proper. Indeed if, if 1 − <em>e</em><sub>1</sub> is the sum of two primitive idempotents in the subalgebra, then, after applying an automorphism of <em>E</em> if necessary, the subalgebra will be generated by the diagonal matrices and a matrix orthogonal to the diagonal matrices. By the previous argument it will be proper. If 1 - <em>e</em><sub>1</sub> is a primitive idempotent, the subalgebra must be proper, by the properties of the rank in <em>E</em>.</p>

<p>A Euclidean algebra is said to be <em>special</em> if its central decomposition contains no copies of the Albert algebra. Since the Albert algebra cannot be generated by two elements, it follows that a Euclidean Jordan algebra generated by two elements is special. This is the <strong><a href="Shirshov–Cohn_theorem" title="wikilink">Shirshov–Cohn theorem</a></strong> for Euclidean Jordan algebras.<ref>See:</ref></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p></p></li>
</ul>

<p>The classification shows that each non-exceptional simple Euclidean Jordan algebra is a subalgebra of some <em>H</em><sub><em>n</em></sub>(<strong>R</strong>). The same is therefore true of any special algebra.</p>

<p>On the other hand, as  showed, the Albert algebra <em>H</em><sub>3</sub>(<strong>O</strong>) cannot be realized as a subalgebra of <em>H</em><sub><em>n</em></sub>(<strong>R</strong>) for any <em>n</em>.<ref>See:</ref></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p></p>

<p>Indeed let π is a real-linear map of <em>E</em> = <em>H</em><sub>3</sub>(<strong>O</strong>) into the self-adjoint operators on <em>V</em> = <strong>R</strong><sup><em>n</em></sup> with π(<em>ab</em>) = ½(π(<em>a</em>)π(<em>b</em>) + π(<em>b</em>)π(<em>a</em>)) and π(1) = <em>I</em>. If <em>e</em><sub>1</sub>, <em>e</em><sub>2</sub>, <em>e</em><sub>3</sub> are the diagonal minimal idempotents then <em>P</em><sub><em>i</em></sub> = π(<em>e</em><sub><em>i</em></sub> are mutually orthogonal projections on <em>V</em> onto orthogonal subspaces <em>V</em><sub><em>i</em></sub>. If <em>i</em> ≠ <em>j</em>, the elements <em>e</em><sub><em>ij</em></sub> of <em>E</em> with 1 in the (<em>i</em>,<em>j</em>) and (<em>j</em>,<em>i</em>) entries and 0 elsewhere satisfy <em>e</em><sub><em>ij</em></sub><sup>2</sup> = <em>e</em><sub><em>i</em></sub> + <em>e</em><sub><em>j</em></sub>. Moreover <em>e</em><sub><em>ij</em></sub><em>e</em><sub><em>jk</em></sub> = ½ <em>e</em><sub><em>ik</em></sub> if <em>i</em>, <em>j</em> and <em>k</em> are distinct. The operators <em>T</em><sub><em>ij</em></sub> are zero on <em>V</em><sub><em>k</em></sub> (<em>k</em> ≠ <em>i</em>, <em>j</em>) and restrict to involutions on <em>V</em><sub><em>i</em></sub> ⊕ <em>V</em><sub><em>j</em></sub> interchanging <em>V</em><sub><em>i</em></sub> and <em>V</em><sub><em>j</em></sub>. Letting <em>P</em><sub><em>ij</em></sub> = <em>P</em><sub><em>i</em></sub> <em>T</em><sub><em>ij</em></sub> <em>P</em><sub><em>j</em></sub> and setting <em>P</em><sub><em>ii</em></sub> = <em>P</em><sub><em>i</em></sub>, the (<em>P</em><sub><em>ij</em></sub>) form a system of <a href="matrix_unit" title="wikilink">matrix units</a> on <em>V</em>, i.e. <em>P</em><sub><em>ij</em></sub>* = <em>P</em><sub><em>ji</em></sub>, ∑ <em>P</em><sub><em>ii</em></sub> = <em>I</em> and <em>P</em><sub><em>ij</em></sub><em>P</em><sub><em>km</em></sub> = δ<sub><em>jk</em></sub> <em>P</em><sub><em>im</em></sub>. Let <em>E</em><sub><em>i</em></sub> and <em>E</em><sub><em>ij</em></sub> be the subspaces of the Peirce decomposition of <em>E</em>. For <em>x</em> in <strong>O</strong>, set π<sub><em>ij</em></sub> = <em>P</em><sub><em>ij</em></sub> π(x<em>e</em><sub><em>ij</em></sub>), regarded as an operator on <em>V</em><sub><em>i</em></sub>. This does not depend on <em>j</em> and for <em>x</em>, <em>y</em> in <strong>O</strong></p>

<p>

<math display="block" id="Symmetric_cone:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>π</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mi>y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>π</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>π</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="7.6pt">,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>π</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mi>I</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\pi_{ij}(xy)=\pi_{ij}(x)\pi_{ij}(y),\,\,\,\pi_{ij}(1)=I.}
  </annotation>
 </semantics>
</math>

</p>

<p>Since every <em>x</em> in <strong>O</strong> has a right inverse <em>y</em> with <em>xy</em> = 1, the map π<sub><em>ij</em></sub> is injective. On the other hand it is an algebra homomorphism from the nonassociative algebra <strong>O</strong> into the associative algebra End <em>V</em><sub><em>i</em></sub>, a contradiction.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="positive-cone-in-a-euclidean-jordan-algebra">Positive cone in a Euclidean Jordan algebra</h2>
<figure><b>(Figure)</b>
<figcaption><a href="Max_Koecher" title="wikilink">Max Koecher</a> pioneered the use of Jordan algebras in studying symmetric spaces</figcaption>
</figure>
<h3 id="definition-1">Definition</h3>

<p>When (<em>e</em><sub><em>i</em></sub>) is a partition of 1 in a Euclidean Jordan algebra <em>E</em>, the self-adjoint operators L(<em>e</em><sub><em>i</em></sub>) commute and there is a decomposition into simultaneous eigenspaces. If <em>a</em> = ∑ λ<sub><em>i</em></sub> <em>e</em><sub><em>i</em></sub> the eigenvalues of <em>L</em>(<em>a</em>) have the form ∑ ε<sub><em>i</em></sub> λ<sub><em>i</em></sub> is 0, 1/2 or 1. The <em>e</em><sub><em>i</em></sub> themselves give the eigenvalues λ<sub><em>i</em></sub>. In particular an element <em>a</em> has non-negative spectrum if and only if <em>L</em>(<em>a</em>) has non-negative spectrum. Moreover <em>a</em> has positive spectrum if and only if <em>L</em>(<em>a</em>) has positive spectrum. For if <em>a</em> has positive spectrum, <em>a</em> - ε1 has non-negative spectrum for some ε &gt; 0.</p>

<p>The <strong>positive cone</strong> <em>C</em> in <em>E</em> is defined to be the set of elements <em>a</em> such that <em>a</em> has positive spectrum. This condition is equivalent to the operator <em>L</em>(<em>a</em>) being a <a href="positive_operator" title="wikilink">positive</a> self-adjoint operator on <em>E</em>.</p>
<ul>
<li><em>C</em> is a convex cone in <em>E</em> because positivity of a self-adjoint operator <em>T</em>— the property that its eigenvalues be strictly positive—is equivalent to (<em>Tv</em>,<em>v</em>) &gt; 0 for all <em>v</em> ≠ 0.</li>
</ul>
<ul>
<li><em>C</em> is an open because the positive matrices are open in the self-adjoint matrices and <em>L</em> is a continuous map: in fact, if the lowest eigenvalue of <em>T</em> is ε &gt;0, then <em>T</em> + <em>S</em> is positive whenever ||<em>S</em>|| &lt; ε.</li>
</ul>
<ul>
<li>The closure of <em>C</em> consists of all <em>a</em> such that <em>L</em>(<em>a</em>) is non-negative or equivalently <em>a</em> has non-negative spectrum. From the elementary properties of convex cones, <em>C</em> is the interior of its closure and is a proper cone. The elements in the closure of <em>C</em> are precisely the square of elements in <em>E</em>.</li>
</ul>
<ul>
<li><em>C</em> is self-dual. In fact the elements of the closure of <em>C</em> are just set of all squares <em>x</em><sup>2</sup> in <em>E</em>, the dual cone is given by all <em>a</em> such that (<em>a</em>,<em>x</em><sup>2</sup>) &gt; 0. On the other hand (<em>a</em>,<em>x</em><sup>2</sup>) = (<em>L</em>(<em>a</em>)<em>x</em>,<em>x</em>), so this is equivalent to the positivity of <em>L</em>(<em>a</em>).<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
</ul>
<h3 id="quadratic-representation">Quadratic representation</h3>

<p>To show that the positive cone <em>C</em> is homogeneous, i.e. has a transitive group of automorphisms, a generalization of the quadratic action of self-adjoint matrices on themselves given by <em>X</em> ↦ <em>YXY</em> has to be defined. If <em>Y</em> is invertible and self-adjoint, this map is invertible and carries positive operators onto positive operators.</p>

<p>For <em>a</em> in <em>E</em>, define an endomorphism of <em>E</em>, called the <strong><a href="quadratic_representation" title="wikilink">quadratic representation</a></strong>, by<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>

<math display="block" id="Symmetric_cone:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>L</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>a</mi>
        <mn>2</mn>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Q(a)=2L(a)^{2}-L(a^{2}).}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that for self-adjoint matrices <em>L</em>(<em>X</em>)<em>Y</em> = ½(<em>XY</em> + <em>YX</em>), so that <em>Q</em>(<em>X</em>)<em>Y</em> = <em>XYX</em>.</p>

<p>An element <em>a</em> in <em>E</em> is called <em>invertible</em> if it is invertible in <strong>R</strong>[<em>a</em>]. If <em>b</em> denotes the inverse, then the spectral decomposition of <em>a</em> shows that <em>L</em>(<em>a</em>) and <em>L</em>(<em>b</em>) commute.</p>

<p>In fact <em>a</em> is invertible if and only if <em>Q</em>(<em>a</em>) is invertible. In that case</p>

<p>{{-}} Indeed if <em>Q</em>(<em>a</em>) is invertible it carries <strong>R</strong>[<em>a</em>] onto itself. On the other hand <em>Q</em>(<em>a</em>)1 = <em>a</em><sup>2</sup>, so</p>

<p>

<math display="block" id="Symmetric_cone:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Q</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mi>Q</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Q</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msup>
     <mi>a</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>Q</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>a</ci>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>a</ci>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{(Q(a)^{-1}a)a=aQ(a)^{-1}a=L(a)Q(a)^{-1}a=Q(a)^{-1}a^{2}=1.}
  </annotation>
 </semantics>
</math>

</p>

<p>Taking <em>b</em> = <em>a</em><sup>−1</sup> in the polarized Jordan identity, yields</p>

<p>

<math display="block" id="Symmetric_cone:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>a</ci>
     <ci>L</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Q(a)L(a^{-1})=L(a).}
  </annotation>
 </semantics>
</math>

</p>

<p>Replacing <em>a</em> by its inverse, the relation follows if <em>L</em>(<em>a</em>) and <em>L</em>(<em>a</em><sup>−1</sup>) are invertible. If not it holds for <em>a</em> + ε1 with ε arbitrarily small and hence also in the limit.</p>

<p>{{-}} These identities are easy to prove in a finite-dimensional (Euclidean) Jordan algebra (see below) or in a <a href="special_Jordan_algebra" title="wikilink">special Jordan algebra</a>, i.e. the Jordan algebra defined by a unital associative algebra.<ref> See:</ref></p>
<ul>
<li></li>
<li>

<p> They are valid in any Jordan algebra. This was conjectured by <a href="Nathan_Jacobson" title="wikilink">Jacobson</a> and proved in : <a href="Ian_G._Macdonald" title="wikilink">Macdonald</a> showed that if a polynomial identity in three variables, linear in the third, is valid in any special Jordan algebra, then it holds in all Jordan algebras.<ref>See:</ref></p></li>
<li></li>
<li></li>
</ul>

<p></p>

<p>In fact for <em>c</em> in <em>A</em> and <em>F</em>(<em>a</em>) a function on <em>A</em> with values in End <em>A</em>, let <em>D</em><sub><em>c</em></sub><em>F</em>(<em>a</em>) be the derivative at <em>t</em> = 0 of <em>F</em>(<em>a</em> + <em>tc</em>). Then</p>

<p>

<math display="block" id="Symmetric_cone:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>D</mi>
      <mi>c</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Q</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mi>a</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mrow>
            <mi>L</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>a</mi>
             <mo stretchy="false">)</mo>
            </mrow>
            <mi>L</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>c</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>+</mo>
           <mrow>
            <mi>L</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>c</mi>
             <mo stretchy="false">)</mo>
            </mrow>
            <mi>L</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>a</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo>-</mo>
          <mrow>
           <mi>L</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>a</mi>
             <mi>c</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <msup>
         <mi>a</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>D</mi>
       <mi>c</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>a</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>c</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>D</mi>
       <mi>c</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>a</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>c</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>c</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Q</ci>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <minus></minus>
          <apply>
           <plus></plus>
           <apply>
            <times></times>
            <ci>L</ci>
            <ci>a</ci>
            <ci>L</ci>
            <ci>c</ci>
           </apply>
           <apply>
            <times></times>
            <ci>L</ci>
            <ci>c</ci>
            <ci>L</ci>
            <ci>a</ci>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>L</ci>
           <apply>
            <times></times>
            <ci>a</ci>
            <ci>c</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>a</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>Q</ci>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <ci>c</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>c</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Q</ci>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <ci>c</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{c=D_{c}(Q(a)a^{-1})=2[(L(a)L(c)+L(c)L(a)-L(ac))a^{-1}]+Q(a)D_{c}%
(a^{-1})=2c+Q(a)D_{c}(a^{-1}).}
  </annotation>
 </semantics>
</math>

</p>

<p>The expression in square brackets simplifies to <em>c</em> because <em>L</em>(<em>a</em>) commutes with <em>L</em>(<em>a</em><sup>−1</sup>).</p>

<p>Thus</p>

<p>{{-}} Applying <em>D</em><sub><em>c</em></sub> to <em>L</em>(<em>a</em><sup>−1</sup>)<em>Q</em>(<em>a</em>) = <em>L</em>(<em>a</em>) and acting on <em>b</em> = <em>c</em><sup>−1</sup> yields</p>

<p>

<math display="block" id="Symmetric_cone:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>a</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>b</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{(Q(a)b)(Q(a^{-1})b^{-1})=1.}
  </annotation>
 </semantics>
</math>

</p>

<p>On the other hand <em>L</em>(<em>Q</em>(<em>a</em>)<em>b</em>) is invertible on an open dense set where <em>Q</em>(<em>a</em>)<em>b</em> must also be invertible with</p>

<p>

<math display="block" id="Symmetric_cone:36">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Q</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>b</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{(Q(a)b)^{-1}=Q(a^{-1})b^{-1}.}
  </annotation>
 </semantics>
</math>

</p>

<p>Taking the derivative <em>D</em><sub><em>c</em></sub> in the variable <em>b</em> in the expression above gives</p>

<p>

<math display="block" id="Symmetric_cone:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>Q</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>Q</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>b</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>c</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>Q</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>Q</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>c</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>Q</ci>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>Q</ci>
      <ci>a</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{-Q(Q(a)b)^{-1}Q(a)c=-Q(a)^{-1}Q(b)^{-1}c.}
  </annotation>
 </semantics>
</math>

</p>

<p>This yields the fundamental identity for a dense set of invertible elements, so it follows in general by continuity. The fundamental identity implies that <em>c</em> = <em>Q</em>(<em>a</em>)<em>b</em> is invertible if <em>a</em> and <em>b</em> are invertible and gives a formula for the inverse of <em>Q</em>(<em>c</em>). Applying it to <em>c</em> gives the inverse identity in full generality.</p>

<p>Finally it can be verified immediately from the definitions that, if <em>u</em> = 1 − 2<em>e</em> for some idempotent <em>e</em>, then <em>Q</em>(<em>u</em>) is the period 2 automorphism constructed above for the centralizer algebra and module of <em>e</em>.</p>
<h3 id="homogeneity-of-positive-cone">Homogeneity of positive cone</h3>

<p>{{-}} The proof of this relies on elementary continuity properties of eigenvalues of self-adjoint operators.<ref>See:</ref></p>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p></p>

<p>Let <em>T</em>(<em>t</em>) (α ≤ <em>t</em> ≤ β) be a continuous family of self-adjoint operators on <em>E</em> with <em>T</em>(α) positive and <em>T</em>(β) having a negative eiegenvalue. Set <em>S</em>(<em>t</em>)= –<em>T</em>(<em>t</em>) + <em>M</em> with <em>M</em> &gt; 0 chosen so large that <em>S</em>(<em>t</em>) is positive for all <em>t</em>. The operator norm ||<em>S</em>(<em>t</em>)|| is continuous. It is less than <em>M</em> for <em>t</em> = α and greater than <em>M</em> for <em>t</em> = β. So for some α 2). This is a positive operator since <em>x</em>(<em>t</em>)<sup>2</sup> lies in <em>C</em>. Let <em>T</em>(<em>t</em>) = <em>Q</em>(<em>x</em>(<em>t</em>)), an invertible self-adjoint operator by the invertibility of <em>x</em>(<em>t</em>). On the other hand <em>T</em>(<em>t</em>) = 2<em>X</em>(<em>t</em>)<sup>2</sup> - <em>Y</em>(<em>t</em>). So (<em>T</em>(<em>s</em>)<em>w</em>,<em>w</em>) 2) = <em>Q</em>(<em>a</em>)<sup>2</sup> is positive. By the eigenvalue argument, <em>T</em>(<em>t</em>) has eigenvalue 0 for some <em>t</em> with 0 −1). Since <em>Q</em>(<em>a</em>)1 = <em>a</em><sup>2</sup>, there is thus a transitive group of symmetries:</p>

<p>{{-}}</p>
<h2 id="euclidean-jordan-algebra-of-a-symmetric-cone">Euclidean Jordan algebra of a symmetric cone</h2>
<h3 id="construction">Construction</h3>

<p>Let <em>C</em> be a symmetric cone in the Euclidean space <em>E</em>. As above, Aut <em>C</em> denotes the closed subgroup of GL(<em>E</em>) taking <em>C</em> (or equivalently its closure) onto itself. Let <em>G</em> = Aut<sub>0</sub> <em>C</em> be its identity component. <em>K</em> = <em>G</em> ∩ O(<em>E</em>). It is a maximal compact subgroup of <em>G</em> and the stabilizer of a point <em>e</em> in <em>C</em>. It is connected. The group <em>G</em> is invariant under taking adjoints. Let σ<em>g</em> =(<em>g</em>*)<sup>−1</sup>, period 2 automorphism. Thus <em>K</em> is the fixed point subgroup of σ. Let 

<math display="inline" id="Symmetric_cone:38">
 <semantics>
  <mi>𝔤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}
  </annotation>
 </semantics>
</math>

 be the Lie algebra of <em>G</em>. Thus σ induces an involution of 

<math display="inline" id="Symmetric_cone:39">
 <semantics>
  <mi>𝔤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}
  </annotation>
 </semantics>
</math>

 and hence a ±1 eigenspace decomposition</p>

<p>

<math display="block" id="Symmetric_cone:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝔤</mi>
    <mo>=</mo>
    <mrow>
     <mi>𝔨</mi>
     <mo>⊕</mo>
     <mi>𝔭</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝔤</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>𝔨</ci>
     <ci>𝔭</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\mathfrak{g}=\mathfrak{k}\oplus\mathfrak{p},}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Symmetric_cone:41">
 <semantics>
  <mi>𝔨</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{k}
  </annotation>
 </semantics>
</math>

, the +1 eigenspace, is the Lie algebra of <em>K</em> and 

<math display="inline" id="Symmetric_cone:42">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>


 is the −1 eigenspace. Thus 

<math display="inline" id="Symmetric_cone:43">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

⋅<em>e</em> is an affine subspace of dimension dim 

<math display="inline" id="Symmetric_cone:44">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

. Since <em>C</em> = <em>G</em>/<em>K</em> is an open subspace of <em>E</em>, it follows that dim <em>E</em> = dim 

<math display="inline" id="Symmetric_cone:45">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

 and hence 

<math display="inline" id="Symmetric_cone:46">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

⋅<em>e</em> = <em>E</em>. For <em>a</em> in <em>E</em> let <em>L</em>(<em>a</em>) be the unique element of 

<math display="inline" id="Symmetric_cone:47">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>


 such that <em>L</em>(<em>a</em>)<em>e</em> = <em>a</em>. Define <em>a</em> ∘ <em>b</em> = <em>L</em>(<em>a</em>)<em>b</em>. Then <em>E</em> with its Euclidean structure and this bilinear product is a Euclidean Jordan algebra with identity 1 = <em>e</em>. The convex cone coincides <em>C</em> with the positive cone of <em>E</em>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Since the elements of 

<math display="inline" id="Symmetric_cone:48">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

 are self-adjoint, <em>L</em>(<em>a</em>)* = <em>L</em>(<em>a</em>). The product is commutative since [

<math display="inline" id="Symmetric_cone:49">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Symmetric_cone:50">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

] ⊆ 

<math display="inline" id="Symmetric_cone:51">
 <semantics>
  <mi>𝔨</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{k}
  </annotation>
 </semantics>
</math>

 annihilates <em>e</em>, so that <em>ab</em> = <em>L</em>(<em>a</em>)<em>L</em>(<em>b</em>)<em>e</em> = <em>L</em>(<em>b</em>)<em>L</em>(<em>a</em>)<em>e</em> = <em>ba</em>. It remains to check the Jordan identity [<em>L</em>(<em>a</em>),<em>L</em>(<em>a</em><sup>2</sup>)] = 0.</p>

<p>The <a class="uri" href="associator" title="wikilink">associator</a> is given by [<em>a</em>,<em>b</em>,<em>c</em>] = [<em>L</em>(<em>a</em>),<em>L</em>(<em>c</em>)]<em>b</em>. Since [<em>L</em>(<em>a</em>),<em>L</em>(<em>c</em>)] lies in 

<math display="inline" id="Symmetric_cone:52">
 <semantics>
  <mi>𝔨</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{k}
  </annotation>
 </semantics>
</math>


 it follows that <a class="uri" href="''L''(''a''),''L''(''c'')" title="wikilink">''L''(''a''),''L''(''c'')</a>,<em>L</em>(<em>b</em>)] = <em>L</em>([<em>a</em>,<em>b</em>,<em>c</em>]). Making both sides act on <em>c</em> yields</p>

<p>

<math display="block" id="Symmetric_cone:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo>,</mo>
     <msup>
      <mi>b</mi>
      <mn>2</mn>
     </msup>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo>,</mo>
      <mi>c</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi>b</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>c</ci>
    </list>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <list>
      <ci>a</ci>
      <ci>b</ci>
      <ci>c</ci>
     </list>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{[a,b^{2},c]=2[a,b,c]b.}
  </annotation>
 </semantics>
</math>

</p>

<p>On the other hand</p>

<p>

<math display="block" id="Symmetric_cone:54">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msup>
      <mi>b</mi>
      <mn>2</mn>
     </msup>
     <mo>,</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>b</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>b</mi>
        <mi>a</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>b</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>b</mi>
         <mn>2</mn>
        </msup>
        <mi>a</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>b</mi>
      <mn>2</mn>
     </msup>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo>,</mo>
      <mi>c</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <interval closure="open">
      <list>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>a</ci>
       <ci>b</ci>
      </list>
      <ci>c</ci>
     </interval>
     <interval closure="open">
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>b</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <ci>b</ci>
         <ci>a</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>b</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>b</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
      <ci>c</ci>
     </interval>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
       <list>
        <ci>a</ci>
        <ci>b</ci>
        <ci>c</ci>
       </list>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{([b^{2},a,b],c)=(b^{2}(ba)-b(b^{2}a),c)=-(b^{2},[a,b,c])}
  </annotation>
 </semantics>
</math>

</p>

<p>and likewise</p>

<p>

<math display="block" id="Symmetric_cone:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <msup>
       <mi>b</mi>
       <mn>2</mn>
      </msup>
      <mo>,</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>a</mi>
      <mo>,</mo>
      <msup>
       <mi>b</mi>
       <mn>2</mn>
      </msup>
      <mo>,</mo>
      <mi>c</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>a</ci>
      <ci>b</ci>
     </list>
     <ci>c</ci>
    </interval>
    <interval closure="open">
     <ci>b</ci>
     <list>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>c</ci>
     </list>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{([b^{2},a,b],c)=(b,[a,b^{2},c]).}
  </annotation>
 </semantics>
</math>

</p>

<p>Combining these expressions gives</p>

<p>

<math display="block" id="Symmetric_cone:56">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <msup>
       <mi>b</mi>
       <mn>2</mn>
      </msup>
      <mo>,</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>a</ci>
      <ci>b</ci>
     </list>
     <ci>c</ci>
    </interval>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{([b^{2},a,b],c)=0,}
  </annotation>
 </semantics>
</math>

</p>

<p>which implies the Jordan identity.</p>

<p>Finally the positive cone of <em>E</em> coincides with <em>C</em>. This depends on the fact that in any Euclidean Jordan algebra <em>E</em></p>

<p>

<math display="block" id="Symmetric_cone:57">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>e</mi>
       <mi>a</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mn>2</mn>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>L</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Q(e^{a})=e^{2L(a)}.}
  </annotation>
 </semantics>
</math>

</p>

<p>In fact <em>Q</em>(<em>e</em><sup><em>a</em></sup>) is a positive operator, <em>Q</em>(<em>e</em><sup><em>ta</em></sup>) is a one-parameter group of positive operators: this follows by continuity for rational <em>t</em>, where it is a consequence of the behaviour of powers So it has the form exp <em>tX</em> for some self-adjoint operator <em>X</em>. Taking the derivative at 0 gives <em>X</em> = 2<em>L</em>(<em>a</em>).</p>

<p>Hence the positive cone is given by all elements</p>

<p>

<math display="block" id="Symmetric_cone:58">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>e</mi>
     <mrow>
      <mn>2</mn>
      <mi>a</mi>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>e</mi>
       <mi>a</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>1</mn>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>e</mi>
      <mrow>
       <mn>2</mn>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <mn>1</mn>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>e</mi>
      <mi>X</mi>
     </msup>
     <mo>⋅</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <ci>a</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>L</ci>
        <ci>a</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <ci>X</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{e^{2a}=Q(e^{a})1=e^{2L(a)}1=e^{X}\cdot 1,}
  </annotation>
 </semantics>
</math>

</p>

<p>with <em>X</em> in 

<math display="inline" id="Symmetric_cone:59">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

. Thus the positive cone of <em>E</em> lies inside <em>C</em>. Since both are self-dual, they must coincide.</p>
<h3 id="automorphism-groups-and-trace-form">Automorphism groups and trace form</h3>

<p>Let <em>C</em> be the positive cone in a simple Euclidean Jordan algebra <em>E</em>. Aut <em>C</em> is the closed subgroup of GL(<em>E</em>) taking <em>C</em> (or its closure) onto itself. Let <em>G</em> = Aut<sub>0</sub> <em>C</em> be the identity component of Aut <em>C</em> and let <em>K</em> be the closed subgroup of <em>G</em> fixing 1. From the group theoretic properties of cones, <em>K</em> is a connected compact subgroup of <em>G</em> and equals the identity component of the compact Lie group Aut <em>E</em>. Let 

<math display="inline" id="Symmetric_cone:60">
 <semantics>
  <mi>𝔤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Symmetric_cone:61">
 <semantics>
  <mi>𝔨</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{k}
  </annotation>
 </semantics>
</math>

 be the Lie algebras of <em>G</em> and <em>K</em>. <em>G</em> is closed under taking adjoints and <em>K</em> is the fixed point subgroup of the period 2 automorphism σ(<em>g</em>) = (<em>g</em>*)<sup>−1</sup>. Thus <em>K</em> = <em>G</em> ∩ SO(<em>E</em>). Let 

<math display="inline" id="Symmetric_cone:62">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>


 be the −1 eigenspace of σ.</p>
<ul>
<li>

<math display="inline" id="Symmetric_cone:63">
 <semantics>
  <mi>𝔨</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{k}
  </annotation>
 </semantics>
</math>

 consists of derivations of <em>E</em> that are skew-adjoint for the inner product defined by the trace form.</li>
<li><a class="uri" href="''L''(''a''),''L''(''c'')" title="wikilink">''L''(''a''),''L''(''c'')</a>,<em>L</em>(<em>b</em>)] = <em>L</em>([<em>a</em>,<em>b</em>,<em>c</em>]).</li>
<li>If <em>a</em> and <em>b</em> are in <em>E</em>, then <em>D</em> = [<em>L</em>(<em>a</em>),<em>L</em>(<em>b</em>)] is a derivation of <em>E</em>, so lies in 

<math display="inline" id="Symmetric_cone:64">
 <semantics>
  <mi>𝔨</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{k}
  </annotation>
 </semantics>
</math>

. These derivations span 

<math display="inline" id="Symmetric_cone:65">
 <semantics>
  <mi>𝔨</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔨</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{k}
  </annotation>
 </semantics>
</math>

.</li>
<li>If <em>a</em> is in <em>C</em>, then <em>Q</em>(<em>a</em>) lies in <em>G</em>.</li>
<li><em>C</em> is the connected component of the open set of invertible elements of <em>E</em> containing 1. It consists of exponentials of elements of <em>E</em> and the exponential map gives a diffeomorphism of <em>E</em> onto <em>C</em>.</li>
<li>The map <em>a</em> ↦ <em>L</em>(<em>a</em>) gives an isomorphism of <em>E</em> onto 

<math display="inline" id="Symmetric_cone:66">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

 and <em>e</em><sup><em>L</em>(<em>a</em>)</sup> = <em>Q</em>(<em>e</em><sup><em>a</em>/2</sup>). This space of such exponentials coincides with <em>P</em> the positive self-adjoint elements in <em>G</em>.</li>
<li>For <em>g</em> in <em>G</em> and <em>a</em> in <em>E</em>, <em>Q</em>(<em>g</em>(<em>a</em>)) = <em>g</em> <em>Q</em>(<em>a</em>) <em>g</em>*.</li>
</ul>
<h3 id="cartan-decomposition">Cartan decomposition</h3>
<ul>
<li><em>G</em> = <em>P</em> ⋅ <em>K</em> = <em>K</em> ⋅ <em>P</em> and the decomposition <em>g</em> = <em>pk</em> corresponds to the <a href="polar_decomposition" title="wikilink">polar decomposition</a> in GL(<em>E</em>).</li>
<li>If (<em>e</em><sub><em>i</em></sub>) is a Jordan frame in <em>E</em>, then the subspace 

<math display="inline" id="Symmetric_cone:67">
 <semantics>
  <mi>𝔞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{a}
  </annotation>
 </semantics>
</math>


 of 

<math display="inline" id="Symmetric_cone:68">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

 spanned by <em>L</em>(<em>e</em><sub><em>i</em></sub>) is maximal Abelian in 

<math display="inline" id="Symmetric_cone:69">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

. <em>A</em> = exp 

<math display="inline" id="Symmetric_cone:70">
 <semantics>
  <mi>𝔞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{a}
  </annotation>
 </semantics>
</math>

 is the Abelian subgroup of operators <em>Q</em>(<em>a</em>) where <em>a</em> = Σ λ<sub><em>i</em></sub> <em>e</em><sub><em>i</em></sub> with λ<sub><em>i</em></sub> &gt; 0. <em>A</em> is closed in <em>P</em> and hence <em>G</em>. If <em>b</em> =Σ μ<sub><em>i</em></sub> <em>e</em><sub><em>i</em></sub> with μ<sub><em>i</em></sub> &gt; 0, then <em>Q</em>(<em>ab</em>)=<em>Q</em>(<em>a</em>)<em>Q</em>(<em>b</em>).</li>
<li>

<math display="inline" id="Symmetric_cone:71">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

 and <em>P</em> are the union of the <em>K</em> translates of 

<math display="inline" id="Symmetric_cone:72">
 <semantics>
  <mi>𝔞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{a}
  </annotation>
 </semantics>
</math>


 and <em>A</em>.</li>
</ul>
<h3 id="iwasawa-decomposition-for-cone">Iwasawa decomposition for cone</h3>

<p>If <em>E</em> has Peirce decomposition relative to the Jordan frame (<em>e</em><sub><em>i</em></sub>)</p>

<p>

<math display="block" id="Symmetric_cone:73">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
      <mrow>
       <mi>i</mi>
       <mo>≤</mo>
       <mi>j</mi>
      </mrow>
     </munder>
     <msub>
      <mi>E</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <leq></leq>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{E=\bigoplus_{i\leq j}E_{ij},}
  </annotation>
 </semantics>
</math>

</p>

<p>then 

<math display="inline" id="Symmetric_cone:74">
 <semantics>
  <mi>𝔞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{a}
  </annotation>
 </semantics>
</math>

 is diagonalized by this decomposition with <em>L</em>(<em>a</em>) acting as (α<sub><em>i</em></sub> + α<sub><em>j</em></sub>)/2 on <em>E</em><sub><em>ij</em></sub>, where <em>a</em> = ∑ α<sub><em>i</em></sub> <em>e</em><sub><em>i</em></sub>.</p>

<p>Define the closed subgroup <em>S</em> of <em>G</em> by</p>

<p>

<math display="block" id="Symmetric_cone:75">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>g</mi>
      <mo>∈</mo>
      <mi>G</mi>
     </mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mi>g</mi>
       <msub>
        <mi>E</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
      </mrow>
      <mo>⊆</mo>
      <mrow>
       <munder>
        <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>p</mi>
          <mo>,</mo>
          <mi>q</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>≥</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo>,</mo>
          <mi>j</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </munder>
       <msub>
        <mi>E</mi>
        <mrow>
         <mi>p</mi>
         <mi>q</mi>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>g</ci>
      <ci>G</ci>
     </apply>
     <apply>
      <subset></subset>
      <apply>
       <times></times>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">direct-sum</csymbol>
        <apply>
         <geq></geq>
         <interval closure="open">
          <ci>p</ci>
          <ci>q</ci>
         </interval>
         <interval closure="open">
          <ci>i</ci>
          <ci>j</ci>
         </interval>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>q</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{S=\{g\in G|gE_{ij}\subseteq\bigoplus_{(p,q)\geq(i,j)}E_{pq}\},}
  </annotation>
 </semantics>
</math>

</p>

<p>where the ordering on pairs <em>p</em> ≤ <em>q</em> is <a href="lexicographic_order" title="wikilink">lexicographic</a>. <em>S</em> contains the group <em>A</em>, since it acts as scalars on <em>E</em><sub><em>ij</em></sub>. If <em>N</em> is the closed subgroup of <em>S</em> such that <em>nx</em> = <em>x</em> modulo ⊕<sub>(<em>p</em>,<em>q</em>) &gt; (<em>i</em>,<em>j</em>)</sub> <em>E</em><sub><em>pq</em></sub>, then <em>S</em> = <em>AN</em> = <em>NA</em>, a <a href="semidirect_product" title="wikilink">semidirect product</a> with <em>A</em> normalizing <em>N</em>. Moreover <em>G</em> has the following <a href="Iwasawa_decomposition" title="wikilink">Iwasawa decomposition</a>:</p>

<p>

<math display="block" id="Symmetric_cone:76">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>=</mo>
    <mrow>
     <mi>K</mi>
     <mi>A</mi>
     <mi>N</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>A</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{G=KAN.}
  </annotation>
 </semantics>
</math>

</p>

<p>For <em>i</em> ≠ <em>j</em> let</p>

<p>

<math display="block" id="Symmetric_cone:77">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝔤</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>X</mi>
      <mo>∈</mo>
      <mi>𝔤</mi>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mi>X</mi>
        <mo stretchy="false">]</mo>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>α</mi>
           <mi>i</mi>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>α</mi>
           <mi>j</mi>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>X</mi>
       </mrow>
      </mrow>
      <mo rspace="7.6pt">,</mo>
      <mrow>
       <mrow>
        <mpadded width="+5.1pt">
         <mi>for</mi>
        </mpadded>
        <mi>a</mi>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <msub>
          <mi>α</mi>
          <mi>i</mi>
         </msub>
         <msub>
          <mi>e</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔤</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>X</ci>
      <ci>𝔤</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <interval closure="closed">
        <apply>
         <times></times>
         <ci>L</ci>
         <ci>a</ci>
        </apply>
        <ci>X</ci>
       </interval>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>X</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>for</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <sum></sum>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\mathfrak{g}_{ij}=\{X\in\mathfrak{g}:[L(a),X]={1\over 2}(\alpha_%
{i}-\alpha_{j})X,\,\,\,\mathrm{for}\,\,\,a=\sum\alpha_{i}e_{i}\}.}
  </annotation>
 </semantics>
</math>

</p>

<p>Then the Lie algebra of <em>N</em> is</p>

<p>

<math display="block" id="Symmetric_cone:78">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="closed">
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </interval>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{[L(a),L(a^{2})]=0}
  </annotation>
 </semantics>
</math>

 onto <em>N</em>, with polynomial inverse given by the logarithm.</p>
<h2 id="complexification-of-a-euclidean-jordan-algebra">Complexification of a Euclidean Jordan algebra</h2>
<h3 id="definition-of-complexification">Definition of complexification</h3>

<p>Let <em>E</em> be a Euclidean Jordan algebra. The complexification <em>E</em><sub><strong>C</strong></sub> = <em>E</em> ⊕ <em>iE</em> has a natural conjugation operation (<em>a</em> + <em>ib</em>)* = <em>a</em> − <em>ib</em> and a natural complex inner product and norm. The Jordan product on <em>E</em> extends bilinearly to <em>E</em><sub><strong>C</strong></sub>, so that (<em>a</em> + <em>ib</em>)(<em>c</em> + <em>id</em>) = (<em>ac</em> − <em>bd</em>) + <em>i</em>(<em>ad</em> + <em>bc</em>). If multiplication is defined by <em>L</em>(<em>a</em>)<em>b</em> = <em>ab</em> then the Jordan axiom</p>

<p>

<math display="block" id="Symmetric_cone:79">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="7.6pt">,</mo>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>a</mi>
     <mi>m</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>Q</mi>
   <mpadded width="+3.4pt">
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>m</mi>
    </msup>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>≥</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">Q</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>m</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <geq></geq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Q(Q(a)b)=Q(a)Q(b)Q(a),\,\,\,Q(a^{m})=Q(a)^{m}\,\,(m\geq 0).}
  </annotation>
 </semantics>
</math>

</p>

<p>still holds by analytic continuation. Indeed the identity above holds when <em>a</em> is replaced by <em>a</em> + <em>tb</em> for <em>t</em> real; and since the left side is then a polynomial with values in End <em>E</em><sub><strong>C</strong></sub> vanishing for real <em>t</em>, it vanishes also <em>t</em> complex. Analytic continuation also shows that all for the formulas involving power-associativity for a single element <em>a</em> in <em>E</em>, including recursion formulas for <em>L</em>(<em>a</em><sup><em>m</em></sup>), also hold in <em>E</em><sub><strong>C</strong></sub>. Since for <em>b</em> in <em>E</em>, <em>L</em>(<em>b</em>) is still self-adjoint on <em>E</em><sub><strong>C</strong></sub>, the adjoint relation <em>L</em>(<em>a</em>*) = <em>L</em>(<em>a</em>)* holds for <em>a</em> in <em>E</em><sub><strong>C</strong></sub>. Similarly the symmetric bilinear form β(<em>a</em>,<em>b</em>) = (<em>a</em>,<em>b</em>*) satisfies β(<em>ab</em>,<em>c</em>) = β(<em>b</em>,<em>ac</em>). If the inner product comes from the trace form, then β(<em>a</em>,<em>b</em>) = Tr <em>L</em>(<em>ab</em>).</p>

<p>For <em>a</em> in <em>E</em><sub><strong>C</strong></sub>, the quadratic representation is defined as before by <em>Q</em>(<em>a</em>)=2<em>L</em>(<em>a</em>)<sup>2</sup> − <em>L</em>(<em>a</em><sup>2</sup>). By analytic continuation the fundamental identity still holds:</p>

<p>

<math display="block" id="Symmetric_cone:80">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>Q</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>a</mi>
     </mrow>
     <mo>=</mo>
     <msup>
      <mi>a</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo rspace="7.6pt">,</mo>
    <mrow>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>a</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>Q</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Q(a)^{-1}a=a^{-1},\,\,\,Q(a^{-1})=Q(a)^{-1}.}
  </annotation>
 </semantics>
</math>

</p>

<p>An element <em>a</em> in <em>E</em> is called <em>invertible</em> if it is invertible in <strong>C</strong>[<em>a</em>]. Power associativity shows that <em>L</em>(<em>a</em>) and <em>L</em>(<em>a</em><sup>−1</sup>) commute. Moreover <em>a</em><sup>−1</sup> is invertible with inverse <em>a</em>.</p>

<p>As in <em>E</em>, <em>a</em> is invertible if and only if <em>Q</em>(<em>a</em>) is invertible. In that case</p>

<p>

<math display="block" id="Symmetric_cone:81">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Q</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>a</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>a</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>a</mi>
     <mi>Q</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>a</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Q</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>a</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mi>a</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>Q</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>a</ci>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>a</ci>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{(Q(a)^{-1}a)a=aQ(a)^{-1}a=L(a)Q(a)^{-1}a=Q(a)^{-1}a^{2}=1,}
  </annotation>
 </semantics>
</math>

</p>

<p>Indeed as for <em>E</em>, if <em>Q</em>(<em>a</em>) is invertible it carries <strong>C</strong>[<em>a</em>] onto itself, while <em>Q</em>(<em>a</em>)1 = <em>a</em><sup>2</sup>, so</p>

<p>

<math display="block" id="Symmetric_cone:82">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Q</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>b</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{(Q(a)b)^{-1}=Q(a^{-1})b^{-1}.}
  </annotation>
 </semantics>
</math>

</p>

<p>so <em>a</em> is invertible. Conversely if <em>a</em> is invertible, taking <em>b</em> = <em>a</em><sup>−2</sup> in the fundamental identity shows that <em>Q</em>(<em>a</em>) is invertible. Replacing <em>a</em> by <em>a</em><sup>−1</sup> and <em>b</em> by <em>a</em> then shows that its inverse is <em>Q</em>(<em>a</em><sup>−1</sup>). Finally if <em>a</em> and <em>b</em> are invertible then so is <em>c</em> = <em>Q</em>(<em>a</em>)<em>b</em> and it satisfies the inverse identity:</p>

<p>

<math display="block" id="Symmetric_cone:83">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>c</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>c</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>Q</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>b</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mi>b</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{c^{-1}=Q(c)^{-1}c=Q(a)^{-1}Q(b)^{-1}b=Q(a)^{-1}b^{-1}.}
  </annotation>
 </semantics>
</math>

</p>

<p>Invertibility of <em>c</em> follows from the fundamental formula which gives <em>Q</em>(<em>c</em>) = <em>Q</em>(<em>a</em>)<em>Q</em>(<em>b</em>)<em>Q</em>(<em>a</em>). Hence</p>

<p>

<math display="block" id="Symmetric_cone:84">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>e</mi>
      <mi>a</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mn>2</mn>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>L</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Q(e^{a})=e^{2L(a)}}
  </annotation>
 </semantics>
</math>

</p>

<p>The formula</p>

<p>

<math display="block" id="Symmetric_cone:85">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>g</mi>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>g</mi>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>g</mi>
      <mi>t</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>Q</ci>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Q(ga)=gQ(a)g^{t}.}
  </annotation>
 </semantics>
</math>

</p>

<p>also follows by analytic continuation.</p>
<h3 id="complexification-of-automorphism-group">Complexification of automorphism group</h3>

<p>Aut <em>E</em><sub><strong>C</strong></sub> is the <a href="complexification_(Lie_group)" title="wikilink">complexification</a> of the compact Lie group Aut <em>E</em> in GL(<em>E</em><sub><strong>C</strong></sub>). This follows because the Lie algebras of Aut <em>E</em><sub><strong>C</strong></sub> and Aut <em>E</em> consist of derivations of the complex and real Jordan algebras <em>E</em><sub><strong>C</strong></sub> and <em>E</em>. Under the isomorphism identifying End <em>E</em><sub><strong>C</strong></sub> with the complexification of End <em>E</em>, the complex derivations is identified with the complexification of the real derivations.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="structure-groups">Structure groups</h3>

<p>The Jordan operator <em>L</em>(<em>a</em>) are symmetric with respect to the trace form, so that <em>L</em>(<em>a</em>)<sup><em>t</em></sup> = <em>L</em>(<em>a</em>) for <em>a</em> in <em>E</em><sub><strong>C</strong></sub>. The automorphism groups of <em>E</em> and <em>E</em><sub><strong>C</strong></sub> consist of invertible real and complex linear operators <em>g</em> such that <em>L</em>(<em>ga</em>) = <em>gL</em>(<em>a</em>)<em>g</em><sup>−1</sup> and <em>g1</em> = 1. Aut <em>E</em><sub><strong>C</strong></sub> is the complexification of Aut <em>E</em>. Since an automorphism <em>g</em> preserves the trace form, <em>g</em><sup>−1</sup> = <em>g</em><sup><em>t</em></sup>.</p>

<p>The <strong>structure groups</strong> of <em>E</em> and <em>E</em><sub><strong>C</strong></sub> consist of invertible real and complex linear operators <em>g</em> such that</p>

<p>

<math display="inline" id="Symmetric_cone:86">
 <semantics>
  <mrow>
   <mi>𝔨</mi>
   <mo>⊕</mo>
   <mi>𝔭</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <ci>𝔨</ci>
    <ci>𝔭</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{k}\oplus\mathfrak{p}
  </annotation>
 </semantics>
</math>

</p>

<p>They form groups Γ(<em>E</em>) and Γ(<em>E</em><sub><strong>C</strong></sub>) with Γ(<em>E</em>) ⊂ Γ(<em>E</em><sub><strong>C</strong></sub>).</p>
<ul>
<li>The structure group is closed under taking transposes <em>g</em> ↦ <em>g</em><sup><em>t</em></sup> and adjoints <em>g</em> ↦ <em>g</em>*.</li>
<li>The structure group contains the automorphism group. The automorphism group can be identified with the stabilizer of 1 in the structure group.</li>
<li>If <em>a</em> is invertible, <em>Q</em>(<em>a</em>) lies in the structure group.</li>
<li>If <em>g</em> is in the structure group and <em>a</em> is invertible, <em>ga</em> is also invertible with (<em>ga</em>)<sup>−1</sup> = (<em>g</em><sup><em>t</em></sup>)<sup>−1</sup><em>a</em><sup>−1</sup>.</li>
<li>If <em>E</em> is simple, Γ(<em>E</em>) = Aut <em>C</em> × {±1}, Γ(<em>E</em>) ∩ O(<em>E</em>) = Aut <em>E</em> × {±1} and the identity component of Γ(<em>E</em>) acts transitively on <em>C</em>.</li>
<li>Γ(<em>E</em><sub><strong>C</strong></sub>) is the complexification of Γ(<em>E</em>), which has Lie algebra 

<math display="inline" id="Symmetric_cone:87">
 <semantics>
  <mrow>
   <mi>𝔨</mi>
   <mo>⊕</mo>
   <mrow>
    <mi>i</mi>
    <mi>𝔭</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <ci>𝔨</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>𝔭</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{k}\oplus i\mathfrak{p}
  </annotation>
 </semantics>
</math>


.</li>
<li>The structure group Γ(<em>E</em><sub><strong>C</strong></sub>) acts transitively on the set of invertible elements in <em>E</em><sub><strong>C</strong></sub>.</li>
<li>Every <em>g</em> in Γ(<em>E</em><sub><strong>C</strong></sub>) has the form <em>g</em> = <em>h</em> <em>Q</em>(<em>a</em>) with <em>h</em> an automorphism and <em>a</em> invertible.</li>
</ul>

<p>The <strong>unitary structure group</strong> Γ<sub><em>u</em></sub>(<em>E</em><sub><strong>C</strong></sub>) is the subgroup of Γ(<em>E</em><sub><strong>C</strong></sub>) consisting of unitary operators, so that Γ<sub><em>u</em></sub>(<em>E</em><sub><strong>C</strong></sub>) = Γ(<em>E</em><sub><strong>C</strong></sub>) ∩ U(<em>E</em><sub><strong>C</strong></sub>).</p>
<ul>
<li>The stabilizer of 1 in Γ<sub><em>u</em></sub>(<em>E</em><sub><strong>C</strong></sub>) is Aut <em>E</em>.</li>
<li>Every <em>g</em> in Γ<sub><em>u</em></sub>(<em>E</em><sub><strong>C</strong></sub>) has the form <em>g</em> = <em>h</em> <em>Q</em>(<em>u</em>) with <em>h</em> in Aut <em>E</em> and <em>u</em> invertible in <em>E</em><sub><strong>C</strong></sub> with <em>u</em>* = <em>u</em><sup>−1</sup>.</li>
<li>Γ(<em>E</em><sub><strong>C</strong></sub>) is the complexification of Γ<sub><em>u</em></sub>(<em>E</em><sub><strong>C</strong></sub>), which has Lie algebra 

<math display="block" id="Symmetric_cone:88">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∥</mo>
      <msup>
       <mi>a</mi>
       <mo>*</mo>
      </msup>
      <mo>∥</mo>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo>∥</mo>
      <mi>a</mi>
      <mo>∥</mo>
     </mrow>
    </mrow>
    <mo rspace="7.6pt">,</mo>
    <mrow>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>a</mi>
       <mo>,</mo>
       <msup>
        <mi>a</mi>
        <mo>*</mo>
       </msup>
       <mo>,</mo>
       <mi>a</mi>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mo>=</mo>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mi>a</mi>
       <mo>∥</mo>
      </mrow>
      <mn>3</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <set>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <times></times>
       </apply>
       <ci>a</ci>
      </set>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>a</ci>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\|a^{*}\|=\|a\|,\,\,\,\|\{a,a^{*},a\}\|=\|a\|^{3}.}
  </annotation>
 </semantics>
</math>

.</li>
<li>The set <em>S</em> of invertible elements <em>u</em> such that <em>u</em>* = <em>u</em><sup>−1</sup> can be characterized equivalently either as those <em>u</em> for which <em>L</em>(<em>u</em>) is a normal operator with <em>uu</em>* = 1 or as those <em>u</em> of the form exp <em>ia</em> for some <em>a</em> in <em>E</em>. In particular <em>S</em> is connected.</li>
<li>The identity component of Γ<sub><em>u</em></sub>(<em>E</em><sub><strong>C</strong></sub>) acts transitively on <em>S</em></li>
<li><em>g</em> in GL(<em>E</em><sub><strong>C</strong></sub>) is in the unitary structure group if and only if <em>gS</em> = <em>S</em></li>
<li>Given a Jordan frame (<em>e</em><sub><em>i</em></sub>) and <em>v</em> in <em>E</em><sub><strong>C</strong></sub>, there is an operator <em>u</em> in the identity component of Γ<sub><em>u</em></sub>(<em>E</em><sub><strong>C</strong></sub>) such that <em>uv</em> = ∑ α<sub><em>i</em></sub> <em>e</em><sub><em>i</em></sub> with α<sub><em>i</em></sub> ≥ 0. If <em>v</em> is invertible, then α<sub><em>i</em></sub> &gt; 0.</li>
</ul>

<p>Given a frame <mtpl></mtpl> in a Euclidean Jordan algebra <em>E</em>, the <a href="restricted_Weyl_group" title="wikilink">restricted Weyl group</a> can be identified with the group of operators on <mtpl></mtpl> arising from elements in the identity component of Γ<sub><em>u</em></sub>(<em>E</em><sub><strong>C</strong></sub>) that leave <mtpl></mtpl> invariant.</p>
<h3 id="spectral-norm">Spectral norm</h3>

<p>Let <em>E</em> be a Euclidean Jordan algebra with the inner product given by the trace form. Let (<em>e</em><sub><em>i</em></sub>) be a fixed Jordan frame in <em>E</em>. For given <em>a</em> in <em>E</em><sub><strong>C</strong></sub> choose <em>u</em> in Γ<sub><em>u</em></sub>(<em>E</em><sub><strong>C</strong></sub>) such that <em>ua</em> = ∑ α<sub><em>i</em></sub> <em>e</em><sub><em>i</em></sub> with α<sub><em>i</em></sub> ≥ 0. Then the <strong>spectral norm</strong> ||<em>a</em>|| = max α<sub><em>i</em></sub> is independent of all choices. It is a norm on <em>E</em><sub><strong>C</strong></sub> with</p>

<p>

<math display="block" id="Symmetric_cone:89">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <mo>∥</mo>
      <mi>a</mi>
      <mo>∥</mo>
     </mrow>
     <mo>⋅</mo>
     <mrow>
      <mo>∥</mo>
      <mi>b</mi>
      <mo>∥</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\|ab\|\leq\|a\|\cdot\|b\|.}
  </annotation>
 </semantics>
</math>

</p>

<p>In addition ||<em>a</em>||<sup>2</sup> is given by the <a href="operator_norm" title="wikilink">operator norm</a> of <em>Q</em>(<em>a</em>) on the inner product space <em>E</em><sub><strong>C</strong></sub>. The fundamental identity for the quadratic representation implies that ||<em>Q</em>(<em>a</em>)<em>b</em>|| ≤ ||<em>a</em>||<sup>2</sup>||<em>b</em>||. The spectral norm of an element <em>a</em> is defined in terms of <strong>C</strong>[<em>a</em>] so depends only on <em>a</em> and not the particular Euclidean Jordan algebra in which it is calculated.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>The compact set <em>S</em> is the set of <a href="extreme_point" title="wikilink">extreme points</a> of the closed unit ball ||<em>x</em>|| ≤ 1. Each <em>u</em> in <em>S</em> has norm one. Moreover if <em>u</em> = <em>e</em><sup><em>ia</em></sup> and <em>v</em> = <em>e</em><sup><em>ib</em></sup>, then ||<em>uv</em>|| ≤ 1. Indeed by the Cohn–Shirshov theorem the unital Jordan subalgebra of <em>E</em> generated by <em>a</em> and <em>b</em> is special. The inequality is easy to establish in non-exceptional simple Euclidean Jordan algebras, since each such Jordan algebra and its complexification can be realized as a subalgebra of some H<sub><em>n</em></sub>(<strong>R</strong>) and its complexification <em>H</em><sub><em>n</em></sub>(<strong>C</strong>) ⊂ <em>M</em><sub><em>n</em></sub>(<strong>C</strong>). The spectral norm in <em>H</em><sub><em>n</em></sub>(<strong>C</strong>) is the usual operator norm. In that case, for unitary matrices <em>U</em> and <em>V</em> in <em>M</em><sub><em>n</em></sub>(<strong>C</strong>), clearly ||½(<em>UV</em> + <em>VU</em>)|| ≤ 1. The inequality therefore follows in any special Euclidean Jordan algebra and hence in general.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>On the other hand, by the <a href="Krein–Milman_theorem" title="wikilink">Krein–Milman theorem</a>, the closed unit ball is the (closed) <a href="convex_span" title="wikilink">convex span</a> of <em>S</em>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> It follows that ||<em>L</em>(<em>u</em>)|| = 1, in the operator norm corresponding to either the inner product norm or spectral norm. Hence ||<em>L</em>(<em>a</em>)|| ≤ ||<em>a</em>|| for all <em>a</em>, so that the spectral norm satisfies</p>

<p>

<math display="block" id="Symmetric_cone:90">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mi>a</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>a</mi>
     <mi>e</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>a</ci>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{ea=ae=L(a)P(1)=P(L(a)1)=P(a),}
  </annotation>
 </semantics>
</math>

</p>

<p>It follows that <em>E</em><sub><strong>C</strong></sub> is a <a href="Jordan_operator_algebra#JB*_algebras" title="wikilink"><strong>Jordan C* algebra</strong></a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="complex-simple-jordan-algebras">Complex simple Jordan algebras</h3>

<p>The complexification of a simple Euclidean Jordan algebra is a simple complex Jordan algebra which is also <strong>separable</strong>, i.e. its trace form is non-degenerate. Conversely, using the existence of a <a href="complexification_(Lie_group)" title="wikilink">real form</a> of the Lie algebra of the structure group, it can be shown that every complex separable simple Jordan algebra is the complexification of a simple Euclidean Jordan algebra.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>To verify that the complexification of a simple Euclidean Jordan algebra <em>E</em> has no ideals, note that if <em>F</em> is an ideal in <em>E</em><sup><strong>C</strong></sup> then so too is <em>F</em><sup>⊥</sup>, the orthogonal complement for the trace norm. As in the real case, <em>J</em> = <em>F</em><sup>⊥</sup> ∩ <em>F</em> must equal (0). For the associativity property of the trace form shows that <em>F</em><sup>⊥</sup> is an ideal and that <em>ab</em> = 0 if <em>a</em> and <em>b</em> lie in <em>J</em>. Hence <em>J</em> is an ideal. But if <em>z</em> is in <em>J</em>, <em>L</em>(<em>z</em>) takes <em>E</em><sub><strong>C</strong></sub> into <em>J</em> and <em>J</em> into (0). Hence Tr <em>L</em>(<em>z</em>) = 0. Since <em>J</em> is an ideal and the trace form degenerate, this forces <em>z</em> = 0. It follows that <em>E</em><sub><strong>C</strong></sub> = <em>F</em> ⊕ <em>F</em><sup>⊥</sup>. If <em>P</em> is the corresponding projection onto <em>F</em>, it commutes with the operators <em>L</em>(<em>a</em>) and <em>F</em><sup>⊥</sup> = (<em>I</em> − <em>P</em>)<em>E</em><sub><strong>C</strong></sub>. is also an ideal and <em>E</em> = <em>F</em> ⊕ <em>F</em><sup>⊥</sup>. Furthermore, if <em>e</em> = <em>P</em>(1), then <em>P</em> = <em>L</em>(<em>e</em>). In fact for <em>a</em> in <em>E</em></p>

<p>

<math display="inline" id="Symmetric_cone:91">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mo>+</mo>
    <mrow>
     <mi>i</mi>
     <mi>C</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <plus></plus>
     <ci>E</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=E+iC
  </annotation>
 </semantics>
</math>

</p>

<p>so that <em>ea</em> = <em>a</em> for <em>a</em> in <em>F</em> and 0 for <em>a</em> in <em>F</em><sup>⊥</sup>. In particular <em>e</em> and 1 − <em>e</em> are orthogonal <em>central</em> idempotents with <em>L</em>(<em>e</em>) = <em>P</em> and <em>L</em>(1 − <em>e</em>) = <em>I</em> − <em>P</em>.</p>

<p>So simplicity follows from the fact that the center of <em>E</em><sub><strong>C</strong></sub> is the complexification of the center of <em>E</em>.</p>
<h2 id="symmetry-groups-of-bounded-domain-and-tube-domain">Symmetry groups of bounded domain and tube domain</h2>

<p>According to the "elementary approach" to bounded symmetric space of Koecher,<ref>See:</ref></p>
<ul>
<li></li>
<li></li>
</ul>

<p> Hermitian symmetric spaces of noncompact type can be realized in the complexification of a Euclidean Jordan algebra <em>E</em> as either the open unit ball for the spectral norm, a bounded domain, or as the open tube domain 

<math display="inline" id="Symmetric_cone:92">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>U</ci>
    <interval closure="open">
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SU(1,1)
  </annotation>
 </semantics>
</math>


, where <em>C</em> is the positive open cone in <em>E</em>. In the simplest case where <em>E</em> = <strong>R</strong>, the complexification of <em>E</em> is just <strong>C</strong>, the bounded domain corresponds to the open unit disk and the tube domain to the upper half plane. Both these spaces have transitive groups of bihomolorphisms given by Möbius transformations, corresponding to matrices in 

<math display="inline" id="Symmetric_cone:93">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>𝐑</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>𝐑</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,\mathbf{R})
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Symmetric_cone:94">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>𝐂</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>𝐂</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,\mathbf{C})
  </annotation>
 </semantics>
</math>

. They both lie in the Riemann sphere }, the standard one-point compactification of <strong>C</strong>. Moreover the symmetry groups are all particular cases of Möbius transformations corresponding to matrices in 

<math display="inline" id="Symmetric_cone:95">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>U</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SU(2)
  </annotation>
 </semantics>
</math>

. This complex Lie group and its maximal compact subgroup 

<math display="inline" id="Symmetric_cone:96">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 act transitively on the Riemann sphere. The groups are also algebraic. They have distinguished generating subgroups and have an explicit description in terms of generators and relations. Moreover the Cayley transform gives an explicit Möbius transformation from the open disk onto the upper half plane. All these features generalize to arbitrary Euclidean Jordan algebras.<ref>See:</ref></p>
<ul>
<li></li>
<li>

<p> The compactification and complex Lie group are described in the next section and correspond to the dual Hermitian symmetric space of compact type. In this section only the symmetries of and between the bounded domain and tube domain are described.</p></li>
</ul>

<p>Jordan frames provide one of the main Jordan algebraic techniques to describe the symmetry groups. Each Jordan frame gives rise to a product of copies of <strong>R</strong> and <strong>C</strong>. The symmetry groups of the corresponding open domains and the compactification—polydisks and polyspheres—can be deduced from the case of the unit disk, the upper halfplane and Riemann sphere. All these symmetries extend to the larger Jordan algebra and its compactification. The analysis can also be reduced to this case because all points in the complex algebra (or its compactification) lie in an image of the polydisk (or polysphere) under the unitary structure group.</p>
<h3 id="definitions-1">Definitions</h3>

<p>Let 

<math display="inline" id="Symmetric_cone:97">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 be a Euclidean Jordan algebra with complexification <mtpl></mtpl>.</p>

<p>The unit ball or disk <em>D</em> in 

<math display="inline" id="Symmetric_cone:98">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is just the convex bounded open set of elements 

<math display="inline" id="Symmetric_cone:99">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mo>+</mo>
    <mrow>
     <mi>i</mi>
     <mi>C</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <plus></plus>
     <ci>E</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=E+iC
  </annotation>
 </semantics>
</math>

 such the ||<em>a</em>|| $A$ is the unbounded convex open set 

<math display="inline" id="Symmetric_cone:100">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

, where <em>C</em> is the open positive cone in 

<math display="block" id="Symmetric_cone:101">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>α</mi>
       </mtd>
       <mtd columnalign="center">
        <mi>β</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>γ</mi>
       </mtd>
       <mtd columnalign="center">
        <mi>δ</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>g</ci>
    <matrix>
     <matrixrow>
      <ci>α</ci>
      <ci>β</ci>
     </matrixrow>
     <matrixrow>
      <ci>γ</ci>
      <ci>δ</ci>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{g=\begin{pmatrix}\alpha&\beta\\
\gamma&\delta\end{pmatrix},}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="möbius-transformations">Möbius transformations</h3>

<p>The group SL(2,<strong>C</strong>) acts by <a href="Möbius_transformation" title="wikilink">Möbius transformations</a> on the <a href="Riemann_sphere" title="wikilink">Riemann sphere</a> <strong>C</strong> ∪ {∞}, the <a href="one-point_compactification" title="wikilink">one-point compactification</a> of <strong>C</strong>. If <em>g</em> in SL(2,<strong>C</strong>) is given by the matrix</p>

<p>

<math display="block" id="Symmetric_cone:102">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>α</mi>
        <mi>z</mi>
       </mrow>
       <mo>+</mo>
       <mi>β</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>γ</mi>
         <mi>z</mi>
        </mrow>
        <mo>+</mo>
        <mi>δ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>z</ci>
      </apply>
      <ci>β</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>γ</ci>
        <ci>z</ci>
       </apply>
       <ci>δ</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{g(z)=(\alpha z+\beta)(\gamma z+\delta)^{-1}.}
  </annotation>
 </semantics>
</math>

</p>

<p>then</p>

<p>

<math display="block" id="Symmetric_cone:103">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{J=\begin{pmatrix}0&1\\
-1&0\end{pmatrix}.}
  </annotation>
 </semantics>
</math>

</p>

<p>Similarly the group SL(2,<strong>R</strong>) acts by Möbius transformations on the circle <strong>R</strong> ∪ {∞}, the one-point compactification of <strong>R</strong>.</p>

<p>Let <em>k</em> = <strong>R</strong> or <strong>C</strong>. Then SL(2,<em>k</em>) is generated by the three subgroups of lower and upper unitriangular matrices, <strong>L</strong> and <strong>U</strong>', and the diagonal matrices <strong>D</strong>. It is also generated by the lower (or upper) unitriangular matrices, the diagonal matrices and the matrix</p>

<p>

<math display="block" id="Symmetric_cone:104">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{J=\begin{pmatrix}1&0\\
-1&1\end{pmatrix}\begin{pmatrix}1&1\\
0&1\end{pmatrix}\begin{pmatrix}1&0\\
-1&1\end{pmatrix}.}
  </annotation>
 </semantics>
</math>

</p>

<p>The matrix <em>J</em> corresponds to the Möbius transformation <mtpl></mtpl> and can be written</p>

<p>

<math display="block" id="Symmetric_cone:105">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐒𝐋</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo>,</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>𝐁</mi>
     <mo>∪</mo>
     <mrow>
      <mi>𝐁</mi>
      <mo>⋅</mo>
      <mi>J</mi>
      <mo>⋅</mo>
      <mi>𝐁</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐒𝐋</ci>
     <interval closure="open">
      <cn type="integer">2</cn>
      <ci>k</ci>
     </interval>
    </apply>
    <apply>
     <union></union>
     <ci>𝐁</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>𝐁</ci>
      <ci>J</ci>
      <ci>𝐁</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\mathbf{SL}(2,k)=\mathbf{B}\cup\mathbf{B}\cdot J\cdot\mathbf{B},}
  </annotation>
 </semantics>
</math>

</p>

<p>The Möbius transformations fixing ∞ are just the upper triangular matrices <strong>B</strong> = <strong>UD</strong> = <strong>DU</strong>. If <em>g</em> does not fix ∞, it sends ∞ to a finite point <em>a</em>. But then <em>g</em> can be composed with an upper unitriangular matrix to send <em>a</em> to 0 and then with <em>J</em> to send 0 to infinity. This argument gives the one of the simplest examples of the <a href="Bruhat_decomposition" title="wikilink">Bruhat decomposition</a>:</p>

<p>

<math display="inline" id="Symmetric_cone:106">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,k)
  </annotation>
 </semantics>
</math>

</p>

<p>the double coset decomposition of 

<math display="block" id="Symmetric_cone:107">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐒𝐋</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo>,</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>𝐁</mi>
     <mo>∪</mo>
     <mrow>
      <mi>𝐁</mi>
      <mo>⋅</mo>
      <mi>J</mi>
      <mo>⋅</mo>
      <mi>𝐔</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐒𝐋</ci>
     <interval closure="open">
      <cn type="integer">2</cn>
      <ci>k</ci>
     </interval>
    </apply>
    <apply>
     <union></union>
     <ci>𝐁</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>𝐁</ci>
      <ci>J</ci>
      <ci>𝐔</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\mathbf{SL}(2,k)=\mathbf{B}\cup\mathbf{B}\cdot J\cdot\mathbf{U},}
  </annotation>
 </semantics>
</math>

. In fact the union is disjoint and can be written more precisely as</p>

<p>

<math display="block" id="Symmetric_cone:108">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>β</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mi>β</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>β</ci>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <ci>β</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{T(\beta)=\begin{pmatrix}1&\beta\\
0&1\end{pmatrix}.}
  </annotation>
 </semantics>
</math>

</p>

<p>where the product occurring in the second term is direct.</p>

<p>Now let</p>

<p>

<math display="block" id="Symmetric_cone:109">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>α</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msup>
         <mi>α</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>J</mi>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>α</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>J</mi>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>J</mi>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>α</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <matrix>
     <matrixrow>
      <ci>α</ci>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
    <apply>
     <times></times>
     <ci>J</ci>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>J</ci>
     <ci>T</ci>
     <ci>α</ci>
     <ci>J</ci>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\begin{pmatrix}\alpha&0\\
0&\alpha^{-1}\end{pmatrix}=JT(\alpha^{-1})JT(\alpha)JT(\alpha^{-1}).}
  </annotation>
 </semantics>
</math>

</p>

<p>Then</p>

<p>

<math display="inline" id="Symmetric_cone:110">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,k)
  </annotation>
 </semantics>
</math>

</p>

<p>It follows 

<math display="inline" id="Symmetric_cone:111">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>β</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(β)
  </annotation>
 </semantics>
</math>

 is generated by the group of operators 

<math display="inline" id="Symmetric_cone:112">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mi mathvariant="normal">↦</mi>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>β</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>β</ci>
    <ci>normal-↦</ci>
    <ci>T</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   β↦T(β)
  </annotation>
 </semantics>
</math>

 and <em>J</em> subject to the following relations:</p>
<ul>
<li>

<math display="inline" id="Symmetric_cone:113">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">−</mi>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>J</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>normal-−</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>J</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(−1)=J
  </annotation>
 </semantics>
</math>

 is an additive homomorphism</li>
<li><mtpl></mtpl> is a multiplicative homomorphism</li>
<li>

<math display="inline" id="Symmetric_cone:114">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(α)
  </annotation>
 </semantics>
</math>

</li>
<li><mtpl></mtpl></li>
<li><mtpl></mtpl></li>
</ul>

<p>The last relation follows from the definition of 

<math display="inline" id="Symmetric_cone:115">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,k)
  </annotation>
 </semantics>
</math>

. The generator and relations above is fact gives a presentation of 

<math display="inline" id="Symmetric_cone:116">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>β</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(β)
  </annotation>
 </semantics>
</math>

. Indeed consider the free group Φ generated by <em>J</em> and 

<math display="inline" id="Symmetric_cone:117">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">≥</mi>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-≥</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m≥0
  </annotation>
 </semantics>
</math>

 with <em>J</em> of order 4 and its square central. This consists of all products <mtpl></mtpl> for 

<math display="inline" id="Symmetric_cone:118">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,k)
  </annotation>
 </semantics>
</math>

. There is a natural homomorphism of Φ onto 

<math display="inline" id="Symmetric_cone:119">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,k)
  </annotation>
 </semantics>
</math>

. Its kernel contain the normal subgroup Δ generated by the relations above. So there is a natural homomorphism of Φ/Δ onto 

<math display="inline" id="Symmetric_cone:120">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>/</mo>
   <mi mathvariant="normal">Δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>normal-Φ</ci>
    <ci>normal-Δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Φ/Δ
  </annotation>
 </semantics>
</math>

. To show that it is injective it suffices to show that the Bruhat decomposition also holds in 

<math display="inline" id="Symmetric_cone:121">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(α)
  </annotation>
 </semantics>
</math>

. It is enough to prove the first version, since the more precise version follows from the commutation relations between <em>J</em> and 

<math display="inline" id="Symmetric_cone:122">
 <semantics>
  <mrow>
   <mi>𝐁</mi>
   <mi mathvariant="normal">∪</mi>
   <mi>𝐁</mi>
   <mi>J</mi>
   <mi>𝐁</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐁</ci>
    <ci>normal-∪</ci>
    <ci>𝐁</ci>
    <ci>J</ci>
    <ci>𝐁</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}∪\mathbf{B}J\mathbf{B}
  </annotation>
 </semantics>
</math>

. The set 

<math display="inline" id="Symmetric_cone:123">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>β</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(β)
  </annotation>
 </semantics>
</math>

 is invariant under inversion, contains operators 

<math display="inline" id="Symmetric_cone:124">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(α)
  </annotation>
 </semantics>
</math>

 and <em>J</em>, so it is enough to show it is invariant under multiplication. By construction it is invariant under multiplication by <strong>B</strong>. It is invariant under multiplication by <em>J</em> because of the defining equation for 

<math display="inline" id="Symmetric_cone:125">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,k)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>In particular the center of 

<math display="inline" id="Symmetric_cone:126">
 <semantics>
  <mrow>
   <mi mathvariant="normal">±</mi>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-±</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ±I
  </annotation>
 </semantics>
</math>

 consists of the scalar matrices 

<math display="inline" id="Symmetric_cone:127">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,k)
  </annotation>
 </semantics>
</math>

 and it is the only non-trivial normal subgroup of 

<math display="inline" id="Symmetric_cone:128">
 <semantics>
  <mi>𝐊</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐊</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{K}
  </annotation>
 </semantics>
</math>

, so that } is <a href="simple_group" title="wikilink">simple</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> In fact if 

<math display="inline" id="Symmetric_cone:129">
 <semantics>
  <mi>𝐁</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐁</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}
  </annotation>
 </semantics>
</math>

 is a normal subgroup, then the Bruhat decomposition implies that 

<math display="inline" id="Symmetric_cone:130">
 <semantics>
  <mi>𝐊</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐊</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{K}
  </annotation>
 </semantics>
</math>

 is a maximal subgroup, so that either 

<math display="inline" id="Symmetric_cone:131">
 <semantics>
  <mi>𝐁</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐁</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}
  </annotation>
 </semantics>
</math>

 is contained in 

<math display="inline" id="Symmetric_cone:132">
 <semantics>
  <mrow>
   <mi>𝐊𝐁</mi>
   <mo>=</mo>
   <mrow>
    <mi>S</mi>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐊𝐁</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>L</ci>
     <interval closure="open">
      <cn type="integer">2</cn>
      <ci>k</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{KB}=SL(2,k)
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Symmetric_cone:133">
 <semantics>
  <mi>𝐊</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐊</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{K}
  </annotation>
 </semantics>
</math>

. In the first case 

<math display="inline" id="Symmetric_cone:134">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,k)
  </annotation>
 </semantics>
</math>

 fixes one point and hence every point of }, so lies in the center. In the second case, the <a href="commutator_subgroup" title="wikilink">commutator subgroup</a> of 

<math display="inline" id="Symmetric_cone:135">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=kb
  </annotation>
 </semantics>
</math>

 is the whole group, since it the group is generated by lower and upper unitriangular matrices and the fourth relation shows that all such matrices are commutators since <mtpl></mtpl>. Writing 

<math display="inline" id="Symmetric_cone:136">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Symmetric_cone:137">
 <semantics>
  <mi>𝐊</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐊</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{K}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Symmetric_cone:138">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Symmetric_cone:139">
 <semantics>
  <mi>𝐁</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐁</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Symmetric_cone:140">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

, it follows that <mtpl></mtpl>. Since 

<math display="inline" id="Symmetric_cone:141">
 <semantics>
  <mi>𝐋</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐋</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{L}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Symmetric_cone:142">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>𝐊𝐔</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>L</ci>
     <interval closure="open">
      <cn type="integer">2</cn>
      <ci>k</ci>
     </interval>
    </apply>
    <ci>𝐊𝐔</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,k)=\mathbf{KU}
  </annotation>
 </semantics>
</math>

 generate the whole group, 

<math display="inline" id="Symmetric_cone:143">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>S</mi>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>2</mn>
        <mo>,</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <mi>𝐊</mi>
     </mrow>
     <mi mathvariant="normal">≅</mi>
     <mi>𝐔</mi>
    </mrow>
    <mo>/</mo>
    <mi>𝐔</mi>
   </mrow>
   <mi mathvariant="normal">∩</mi>
   <mi>𝐊</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>L</ci>
        <interval closure="open">
         <cn type="integer">2</cn>
         <ci>k</ci>
        </interval>
       </apply>
       <ci>𝐊</ci>
      </apply>
      <ci>normal-≅</ci>
      <ci>𝐔</ci>
     </apply>
     <ci>𝐔</ci>
    </apply>
    <ci>normal-∩</ci>
    <ci>𝐊</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,k)/\mathbf{K}≅\mathbf{U}/\mathbf{U}∩\mathbf{K}
  </annotation>
 </semantics>
</math>

. But then 

<math display="inline" id="Symmetric_cone:144">
 <semantics>
  <mrow>
   <mi>𝐊</mi>
   <mo>=</mo>
   <mrow>
    <mi>S</mi>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐊</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>L</ci>
     <interval closure="open">
      <cn type="integer">2</cn>
      <ci>k</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{K}=SL(2,k)
  </annotation>
 </semantics>
</math>

. The right hand side here is Abelian while the left hand side is its own commutator subgroup. Hence this must be the trivial group and 

<math display="inline" id="Symmetric_cone:145">
 <semantics>
  <mrow>
   <mi>𝐂</mi>
   <mi>a</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐂</ci>
    <ci>a</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}aa
  </annotation>
 </semantics>
</math>

.</p>

<p>Given an element <em>a</em> in the complex Jordan algebra <mtpl></mtpl>, the unital Jordan subalgebra 

<math display="inline" id="Symmetric_cone:146">
 <semantics>
  <mrow>
   <mi>𝐂</mi>
   <mi>a</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐂</ci>
    <ci>a</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}aa
  </annotation>
 </semantics>
</math>

 is associative and commutative. Multiplication by <em>a</em> defines an operator on 

<math display="inline" id="Symmetric_cone:147">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(t)
  </annotation>
 </semantics>
</math>

 which has a spectrum, namely its set of complex eigenvalues. If 

<math display="inline" id="Symmetric_cone:148">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(a)
  </annotation>
 </semantics>
</math>

 is a complex polynomial, then 

<math display="inline" id="Symmetric_cone:149">
 <semantics>
  <mrow>
   <mi>𝐂</mi>
   <mi>a</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐂</ci>
    <ci>a</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}aa
  </annotation>
 </semantics>
</math>

 is defined in 

<math display="inline" id="Symmetric_cone:150">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. It is invertible in 

<math display="inline" id="Symmetric_cone:151">
 <semantics>
  <mrow>
   <mi>𝐂</mi>
   <mi>a</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐂</ci>
    <ci>a</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}aa
  </annotation>
 </semantics>
</math>

 if and only if it is invertible in 

<math display="inline" id="Symmetric_cone:152">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, which happen precisely when 

<math display="inline" id="Symmetric_cone:153">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 does not vanish on the spectrum of 

<math display="inline" id="Symmetric_cone:154">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

. This permits <a href="rational_function" title="wikilink">rational functions</a> of 

<math display="inline" id="Symmetric_cone:155">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 to be defined whenever the function is defined on the spectrum of 

<math display="inline" id="Symmetric_cone:156">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Symmetric_cone:157">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Symmetric_cone:158">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 are rational functions with 

<math display="inline" id="Symmetric_cone:159">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi mathvariant="normal">∘</mi>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>normal-∘</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F∘G
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Symmetric_cone:160">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 defined on 

<math display="inline" id="Symmetric_cone:161">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Symmetric_cone:162">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(a)
  </annotation>
 </semantics>
</math>

 is defined on 

<math display="inline" id="Symmetric_cone:163">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>G</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>F</mi>
      <mi mathvariant="normal">∘</mi>
      <mi>G</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>normal-∘</ci>
      <ci>G</ci>
     </apply>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(G(a))=(F∘G)(a)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Symmetric_cone:164">
 <semantics>
  <mrow>
   <mi>𝐂</mi>
   <mi>a</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐂</ci>
    <ci>a</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}aa
  </annotation>
 </semantics>
</math>

. This applies in particular to complex Möbius transformations which can be defined by <mtpl></mtpl>. They leave 

<math display="inline" id="Symmetric_cone:165">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 invariant and, when defined, the group composition law holds. (In the next section complex Möbius transformations will be defined on the compactification of 

<math display="inline" id="Symmetric_cone:166">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

.)<ref>See:</ref></p>
<ul>
<li></li>
<li>

<p></p></li>
</ul>

<p>Given a primitive idempotent 

<math display="inline" id="Symmetric_cone:167">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 in 

<math display="block" id="Symmetric_cone:168">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>E</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>e</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊕</mo>
      <mrow>
       <msub>
        <mi>E</mi>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>e</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊕</mo>
      <mrow>
       <msub>
        <mi>E</mi>
        <mn>0</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>e</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="9.3pt">,</mo>
    <mrow>
     <mi>A</mi>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>A</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>e</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊕</mo>
      <mrow>
       <msub>
        <mi>A</mi>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>e</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊕</mo>
      <mrow>
       <msub>
        <mi>A</mi>
        <mn>0</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>e</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>e</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>e</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>e</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>A</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>e</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>e</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>e</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{E=E_{1}(e)\oplus E_{1/2}(e)\oplus E_{0}(e),\,\,\,\,A=A_{1}(e)%
\oplus A_{1/2}(e)\oplus A_{0}(e).}
  </annotation>
 </semantics>
</math>

 with Peirce decomposition</p>

<p>

<math display="inline" id="Symmetric_cone:169">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>𝐂</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>𝐂</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,\mathbf{C})
  </annotation>
 </semantics>
</math>

</p>

<p>the action of 

<math display="block" id="Symmetric_cone:170">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>z</mi>
        <mi>e</mi>
       </mrow>
       <mo>⊕</mo>
       <msub>
        <mi>x</mi>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </msub>
       <mo>⊕</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mfrac>
        <mrow>
         <mrow>
          <mi>α</mi>
          <mi>z</mi>
         </mrow>
         <mo>+</mo>
         <mi>β</mi>
        </mrow>
        <mrow>
         <mrow>
          <mi>γ</mi>
          <mi>z</mi>
         </mrow>
         <mo>+</mo>
         <mi>δ</mi>
        </mrow>
       </mfrac>
       <mo>⋅</mo>
       <mi>e</mi>
      </mrow>
      <mo>⊕</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mi>γ</mi>
           <mi>z</mi>
          </mrow>
          <mo>+</mo>
          <mi>δ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <msub>
        <mi>x</mi>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </msub>
      </mrow>
      <mo>⊕</mo>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mi>γ</mi>
          <mi>z</mi>
         </mrow>
         <mo>+</mo>
         <mi>δ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msub>
       <mi>P</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msubsup>
        <mi>x</mi>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
        <mn>2</mn>
       </msubsup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <ci>z</ci>
       <ci>e</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>α</ci>
          <ci>z</ci>
         </apply>
         <ci>β</ci>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>γ</ci>
          <ci>z</ci>
         </apply>
         <ci>δ</ci>
        </apply>
       </apply>
       <ci>e</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>γ</ci>
          <ci>z</ci>
         </apply>
         <ci>δ</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>γ</ci>
         <ci>z</ci>
        </apply>
        <ci>δ</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{g(ze\oplus x_{1/2}\oplus x_{0})={\alpha z+\beta\over\gamma z+%
\delta}\cdot e\oplus(\gamma z+\delta)^{-1}x_{1/2}\oplus x_{0}-(\gamma z+\delta%
)^{-1}P_{0}(x_{1/2}^{2}).}
  </annotation>
 </semantics>
</math>

 by Möbius transformations on <mtpl></mtpl> can be extended to an action on <em>A</em> so that the action leaves invariant the components <mtpl></mtpl> and in particular acts trivially on <mtpl></mtpl>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> If <mtpl></mtpl> is the projection onto <mtpl></mtpl>, the action is given be the formula</p>

<p>

<math display="inline" id="Symmetric_cone:171">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>𝐂</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>𝐂</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,\mathbf{C})
  </annotation>
 </semantics>
</math>

</p>

<p>For a Jordan frame of primitive idempotents <mtpl></mtpl>, the actions of 

<math display="inline" id="Symmetric_cone:172">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi>𝐂</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>L</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <ci>𝐂</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SL(2,\mathbf{C})
  </annotation>
 </semantics>
</math>

 associated with different <mtpl></mtpl> commute, thus giving an action of <mtpl></mtpl>. The diagonal copy of 

<math display="inline" id="Symmetric_cone:173">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 gives again the action by Möbius transformations on 

<math display="block" id="Symmetric_cone:174">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>i</mi>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mi>z</mi>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>z</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mi>i</mi>
    </mrow>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mn>2</mn>
      <mi>i</mi>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>z</mi>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <ci>z</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>i</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>i</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{C(z)=i{1+z\over 1-z}=-i+{2i\over 1-z}}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="cayley-transform">Cayley transform</h3>

<p>The Möbius transformation defined by</p>

<p>

<math display="block" id="Symmetric_cone:175">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mi>w</mi>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
     <mrow>
      <mi>w</mi>
      <mo>+</mo>
      <mi>i</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mn>2</mn>
       <mi>i</mi>
      </mrow>
      <mrow>
       <mi>w</mi>
       <mo>+</mo>
       <mi>i</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>w</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>i</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{P(w)={w-i\over w+i}=1-{2i\over w+i}.}
  </annotation>
 </semantics>
</math>

</p>

<p>is called the <a href="Cayley_transform" title="wikilink">Cayley transform</a>. Its inverse is given by</p>

<p>

<math display="inline" id="Symmetric_cone:176">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi mathvariant="normal">↦</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>normal-↦</ci>
    <ci>P</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T↦P(T)
  </annotation>
 </semantics>
</math>

</p>

<p>The inverse Cayley transform carries the real line onto the circle with the point 1 omitted. It carries the upper halfplane onto the unit disk and the lower halfplane onto the complement of the closed unit disk. In <a href="operator_theory" title="wikilink">operator theory</a> the mapping 

<math display="inline" id="Symmetric_cone:177">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 takes self-adjoint operators <em>T</em> onto unitary operators <em>U</em> not containing 1 in their spectrum. For matrices this follows because unitary and self-adjoint matrices can be diagonalized and their eigenvalues lie on the unit circle or real line. In this finite-dimensional setting the Cayley transform and its inverse establish a bijection between the matrices of operator norm less than one and operators with imaginary part a positive operator. This is the special case for <mtpl></mtpl> of the Jordan algebraic result, explained below, which asserts that the Cayley transform and its inverse establish a bijection between the bounded domain 

<math display="inline" id="Symmetric_cone:178">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and the tube domain 

<math display="inline" id="Symmetric_cone:179">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</p>

<p>In the case of matrices, the bijection follows from resolvant formulas.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> In fact if the imaginary part of 

<math display="inline" id="Symmetric_cone:180">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>+</mo>
   <mrow>
    <mi>i</mi>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T+iI
  </annotation>
 </semantics>
</math>

 is positive, then 

<math display="block" id="Symmetric_cone:181">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>T</mi>
         <mo>+</mo>
         <mrow>
          <mi>i</mi>
          <mi>I</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>x</mi>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>T</mi>
          <mo>-</mo>
          <mrow>
           <mi>i</mi>
           <mi>I</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>x</mi>
       </mrow>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mn>4</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>Im</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>T</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>x</mi>
       </mrow>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <apply>
        <plus></plus>
        <ci>T</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>I</ci>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>I</ci>
         </apply>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>Im</ci>
        <ci>T</ci>
        <ci>x</ci>
       </apply>
       <ci>x</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\|(T+iI)x\|^{2}=\|(T-iI)x\|^{2}+4(\mathrm{Im}(T)x,x).}
  </annotation>
 </semantics>
</math>

 is invertible since</p>

<p>

<math display="inline" id="Symmetric_cone:182">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mo>+</mo>
      <mrow>
       <mi>i</mi>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>T</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=(T+iI)x
  </annotation>
 </semantics>
</math>

</p>

<p>In particular, setting 

<math display="block" id="Symmetric_cone:183">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mi>y</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>T</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>y</mi>
       </mrow>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mn>4</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>Im</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>T</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>x</mi>
       </mrow>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>y</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>T</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>Im</ci>
        <ci>T</ci>
        <ci>x</ci>
       </apply>
       <ci>x</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\|y\|^{2}=\|P(T)y\|^{2}+4(\mathrm{Im}(T)x,x).}
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Symmetric_cone:184">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mo>-</mo>
    <mrow>
     <mi>P</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>T</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>*</mo>
     </msup>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>4</mn>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>T</mi>
        <mo>*</mo>
       </msup>
       <mo>-</mo>
       <mrow>
        <mi>i</mi>
        <mi>I</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>Im</mi>
      </mpadded>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mo>+</mo>
       <mrow>
        <mi>i</mi>
        <mi>I</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>I</ci>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <times></times>
      </apply>
      <ci>P</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <times></times>
       </apply>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>Im</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{I-P(T)^{*}P(T)=4(T^{*}-iI)^{-1}[\mathrm{Im}\,T](T+iI)^{-1}}
  </annotation>
 </semantics>
</math>

</p>

<p>Equivalently</p>

<p>

<math display="block" id="Symmetric_cone:185">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <msup>
       <mi>u</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>C</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>C</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>u</mi>
         <mo>*</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>u</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mn>4</mn>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>u</mi>
       <mo>*</mo>
      </msup>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <times></times>
      </apply>
     </apply>
     <ci>Q</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>u</ci>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>u</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <ci>Q</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>u</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <ci>B</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>u</ci>
        <times></times>
       </apply>
       <ci>u</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Q(1-u^{*})Q(C(u)+C(u^{*}))Q(1-u)=-4B(u^{*},u)}
  </annotation>
 </semantics>
</math>

</p>

<p>is a positive operator, so that ||<em>P</em>(<em>T</em>)|| \displaystyle{\mathrm{Im}\,C(U)=(2i)^{-1}[C(U)-C(U)^*] = (1-U^*)^{-1}[I -U^*U](I-U)^{-1}.}</p>

<p>Since the Cayley transform and its inverse commute with the transpose, they also establish a bijection for symmetric matrices. This corresponds to the Jordan algebra of symmetric complex matrices, the complexification of <mtpl></mtpl>.</p>

<p>In <mtpl></mtpl> the above resolvant identities take the following form:<ref>See:</ref></p>
<ul>
<li></li>
<li>

<p></p></li>
</ul>

<p>

<math display="block" id="Symmetric_cone:186">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>4</mn>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>Im</mi>
       </mpadded>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>a</mi>
        <mo>*</mo>
       </msup>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>P</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>a</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>*</mo>
       </msup>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mo>+</mo>
       <mi>i</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <ci>Q</ci>
     <apply>
      <times></times>
      <ci>Im</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <times></times>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>B</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <times></times>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>a</ci>
      </apply>
     </interval>
     <ci>Q</ci>
     <apply>
      <plus></plus>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{4Q(\mathrm{Im}\,a)=Q(a^{*}-i)B(P(a)^{*},P(a))Q(a+i),}
  </annotation>
 </semantics>
</math>

</p>

<p>and equivalently</p>

<p>

<math display="inline" id="Symmetric_cone:187">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(x,y)
  </annotation>
 </semantics>
</math>

</p>

<p>where the Bergman operator 

<math display="inline" id="Symmetric_cone:188">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mi mathvariant="normal">−</mi>
     <mn>2</mn>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>normal-−</ci>
      <cn type="integer">2</cn>
      <ci>R</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>x</ci>
      <ci>Q</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(x,y)=I−2R(x,y)+Q(x)Q(y)
  </annotation>
 </semantics>
</math>

 is defined by 

<math display="inline" id="Symmetric_cone:189">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mi>y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <list>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>L</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x,y)=LL(x),L(y)+L(xy)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Symmetric_cone:190">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mi mathvariant="normal">−</mi>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">1</cn>
    <ci>normal-−</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1−u
  </annotation>
 </semantics>
</math>

. The inverses here are well defined. In fact in one direction 

<math display="inline" id="Symmetric_cone:191">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is invertible for ||<em>u</em>|| $ B ( u *, u )$ (see below). In the other direction if the imaginary part of 

<math display="inline" id="Symmetric_cone:192">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Symmetric_cone:193">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(a)
  </annotation>
 </semantics>
</math>

 then the imaginary part of 

<math display="inline" id="Symmetric_cone:194">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is positive definite so that 

<math display="inline" id="Symmetric_cone:195">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>+</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a+i
  </annotation>
 </semantics>
</math>

 is invertible. This argument can be applied to 

<math display="inline" id="Symmetric_cone:196">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

, so it also invertible.</p>

<p>To establish the correspondence, it is enough to check it when 

<math display="inline" id="Symmetric_cone:197">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is simple. In that case it follows from the connectivity of 

<math display="inline" id="Symmetric_cone:198">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Symmetric_cone:199">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x)
  </annotation>
 </semantics>
</math>

 and because:</p>

<p>{{-}}</p>

<p>The first criterion follows from the fact that the eigenvalues of 

<math display="inline" id="Symmetric_cone:200">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 are exactly <mtpl></mtpl> if the eigenvalues of 

<math display="inline" id="Symmetric_cone:201">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 are <mtpl></mtpl>. So the <mtpl></mtpl> are either all positive or all negative. The second criterion follows from the fact that if <mtpl></mtpl> with <mtpl></mtpl> and <em>u</em> in <mtpl></mtpl>, then <mtpl></mtpl> has eigenvalues <mtpl></mtpl>. So the <mtpl></mtpl> are either all less than one or all greater than one.</p>

<p>The resolvant identity is a consequence of the following identity for 

<math display="inline" id="Symmetric_cone:202">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 and 

<math display="block" id="Symmetric_cone:203">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>a</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo>+</mo>
       <msup>
        <mi>b</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mo>+</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>a</ci>
     <ci>Q</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>Q</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <plus></plus>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Q(a)Q(a^{-1}+b^{-1})Q(b)=Q(a+b).}
  </annotation>
 </semantics>
</math>

 invertible</p>

<p>

<math display="block" id="Symmetric_cone:204">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>a</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <msup>
      <mi>b</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>b</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>Q</ci>
      <ci>a</ci>
      <ci>Q</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>b</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>Q</ci>
      <interval closure="open">
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </interval>
      <ci>Q</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{R(a,b)=2Q(a)Q(a^{-1},b)=2Q(a,b^{-1})Q(b)}
  </annotation>
 </semantics>
</math>

</p>

<p>In fact in this case the <a href="Quadratic_Jordan_algebra#Linear_Jordan_algebra_defined_by_a_quadratic_Jordan_algebra" title="wikilink">relations for a quadratic Jordan algebra</a> imply</p>

<p>

<math display="block" id="Symmetric_cone:205">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>a</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo>-</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>b</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo>-</mo>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>B</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>b</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>a</ci>
      <ci>Q</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>a</ci>
      </apply>
      <ci>Q</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{B(a,b)=Q(a)Q(a^{-1}-b)=Q(b^{-1}-a)Q(b).}
  </annotation>
 </semantics>
</math>

</p>

<p>so that</p>

<p>

<math display="inline" id="Symmetric_cone:206">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

</p>

<p>The equality of the last two terms implies the identity, replacing 

<math display="inline" id="Symmetric_cone:207">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">−</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-−</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=1−x
  </annotation>
 </semantics>
</math>

 by <mtpl></mtpl>.</p>

<p>Now set 

<math display="inline" id="Symmetric_cone:208">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">−</mi>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-−</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=1−y
  </annotation>
 </semantics>
</math>

 and 

<math display="block" id="Symmetric_cone:209">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>C</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>C</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mn>4</mn>
      <mi>B</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>x</ci>
     </apply>
     <ci>Q</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <ci>Q</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <ci>B</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Q(1-x)Q(C(x)+C(y))Q(1-y)=-4B(x,y).}
  </annotation>
 </semantics>
</math>

. The resolvant identity is a special case of the more following more general identity:</p>

<p>

<math display="block" id="Symmetric_cone:210">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>i</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <msup>
         <mi>a</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mo>-</mo>
        <msup>
         <mi>b</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>i</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{C(x)+C(y)=-2i(1-a^{-1}-b^{-1}),}
  </annotation>
 </semantics>
</math>

</p>

<p>In fact</p>

<p>

<math display="block" id="Symmetric_cone:211">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msup>
        <mi>a</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo>-</mo>
       <msup>
        <mi>b</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>a</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>a</ci>
     <ci>Q</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>Q</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>a</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>b</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Q(a)Q(1-a^{-1}-b^{-1})Q(b)=B(1-a,1-b).}
  </annotation>
 </semantics>
</math>

</p>

<p>so the identity is equivalent to</p>

<p>

<math display="inline" id="Symmetric_cone:212">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>+</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">−</mi>
    <mn>2</mn>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">−</mi>
    <mn>2</mn>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>a</ci>
     <ci>Q</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <plus></plus>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>normal-−</ci>
     <cn type="integer">2</cn>
     <ci>L</ci>
     <ci>a</ci>
     <ci>Q</ci>
     <ci>b</ci>
     <ci>normal-−</ci>
     <cn type="integer">2</cn>
     <ci>Q</ci>
     <ci>a</ci>
     <ci>L</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(a)Q(b)+Q(a+b)−2L(a)Q(b)−2Q(a)L(b)
  </annotation>
 </semantics>
</math>

</p>

<p>Using the identity above together with <mtpl></mtpl>, the left hand side equals 

<math display="inline" id="Symmetric_cone:213">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mn>2</mn>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">−</mi>
    <mn>2</mn>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">−</mi>
    <mn>2</mn>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">−</mi>
    <mn>2</mn>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>L</ci>
     <ci>a</ci>
     <ci>L</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>L</ci>
     <ci>b</ci>
     <ci>L</ci>
     <ci>a</ci>
     <ci>normal-−</ci>
     <cn type="integer">2</cn>
     <ci>L</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>normal-−</ci>
     <cn type="integer">2</cn>
     <ci>L</ci>
     <ci>a</ci>
     <ci>Q</ci>
     <ci>b</ci>
     <ci>normal-−</ci>
     <cn type="integer">2</cn>
     <ci>Q</ci>
     <ci>a</ci>
     <ci>L</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>a</ci>
     <ci>Q</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2L(a)L(b)+2L(b)L(a)−2L(ab)−2L(a)Q(b)−2Q(a)L(b)+Q(a)Q(b)+Q(a)+Q(b)
  </annotation>
 </semantics>
</math>

. The right hand side equals 

<math display="inline" id="Symmetric_cone:214">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">½</mi>
    <mi>Q</mi>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>+</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">−</mi>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">−</mi>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">−</mi>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-½</ci>
     <ci>Q</ci>
     <ci>Q</ci>
     <apply>
      <plus></plus>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>normal-−</ci>
     <ci>Q</ci>
     <ci>a</ci>
     <ci>normal-−</ci>
     <ci>Q</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>a</ci>
      <ci>L</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>b</ci>
      <ci>L</ci>
      <ci>a</ci>
      <ci>normal-−</ci>
      <ci>L</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ½QQ(a+b)−Q(a)−Q(b)=L(a)L(b)+L(b)L(a)−L(ab)
  </annotation>
 </semantics>
</math>

. These are equal because of the formula 

<math display="inline" id="Symmetric_cone:215">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="automorphism-group-of-bounded-domain">Automorphism group of bounded domain</h3>

<p>{{-}} If 

<math display="inline" id="Symmetric_cone:216">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 lies in the bounded domain 

<math display="inline" id="Symmetric_cone:217">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a−1
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Symmetric_cone:218">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is invertible. Since 

<math display="inline" id="Symmetric_cone:219">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi mathvariant="normal">−</mi>
   <mi>λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>normal-−</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a−λ
  </annotation>
 </semantics>
</math>

 is invariant under multiplication by scalars of modulus ≤ 1, it follows that 

<math display="inline" id="Symmetric_cone:220">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi mathvariant="normal">−</mi>
   <mi>λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>normal-−</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a−λ
  </annotation>
 </semantics>
</math>

 is invertible for |λ| ≥ 1. Hence for ||<em>a</em>|| ≤ 1, 

<math display="inline" id="Symmetric_cone:221">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ga
  </annotation>
 </semantics>
</math>

 is invertible for |λ| &gt; 1. It follows that the Möbius transformation 

<math display="inline" id="Symmetric_cone:222">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is defined for ||<em>a</em>|| ≤ 1 and 

<math display="inline" id="Symmetric_cone:223">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>U</ci>
    <interval closure="open">
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SU(1,1)
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Symmetric_cone:224">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. Where defined it is injective. It is holomorphic on 

<math display="inline" id="Symmetric_cone:225">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

. By the <a href="maximum_modulus_principle" title="wikilink">maximum modulus principle</a>, to show that 

<math display="inline" id="Symmetric_cone:226">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 maps 

<math display="inline" id="Symmetric_cone:227">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 onto 

<math display="inline" id="Symmetric_cone:228">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 it suffices to show it maps 

<math display="inline" id="Symmetric_cone:229">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 onto itself. For in that case 

<math display="inline" id="Symmetric_cone:230">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 and its inverse preserve 

<math display="inline" id="Symmetric_cone:231">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 so must be surjective. If <mtpl></mtpl> with <mtpl></mtpl> in 

<math display="inline" id="Symmetric_cone:232">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   gu
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Symmetric_cone:233">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   gu
  </annotation>
 </semantics>
</math>

 lies in <mtpl></mtpl>. This is a commutative associative algebra and the spectral norm is the supremum norm. Since <mtpl></mtpl> with |ς<sub><em>i</em></sub>| = 1, it follows that <mtpl></mtpl> where |<em>g</em>(ς<sub><em>i</em></sub>)| = 1. So 

<math display="inline" id="Symmetric_cone:234">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 lies in 

<math display="inline" id="Symmetric_cone:235">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>U</ci>
    <interval closure="open">
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SU(1,1)
  </annotation>
 </semantics>
</math>

. <mtpl></mtpl> {{-}} This is a direct consequence of the definition of the spectral norm. <mtpl></mtpl> {{-}} This is already known for the Möbius transformations, i.e. the diagonal in <mtpl></mtpl>. It follows for diagonal matrices in a fixed component in <mtpl></mtpl> because they correspond to transformations in the unitary structure group. Conjugating by a Möbius transformation is equivalent to conjugation by a matrix in that component. Since the only non-trivial normal subgroup of 

<math display="inline" id="Symmetric_cone:236">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is its center, every matrix in a fixed component carries 

<math display="inline" id="Symmetric_cone:237">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 onto itself.  {{-}} Given an element in 

<math display="inline" id="Symmetric_cone:238">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 an transformation in the identity component of the unitary structure group carries it in an element in <mtpl></mtpl> with supremum norm less than 1. An transformation in <mtpl></mtpl> the carries it onto zero. Thus there is a transitive group of biholomorphic transformations of 

<math display="inline" id="Symmetric_cone:239">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mi mathvariant="normal">↦</mi>
   <mi mathvariant="normal">−</mi>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>z</ci>
    <ci>normal-↦</ci>
    <ci>normal-−</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z↦−z
  </annotation>
 </semantics>
</math>

. The symmetry 

<math display="inline" id="Symmetric_cone:240">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a biholomorphic Möbius transformation fixing only 0.  {{-}} If 

<math display="inline" id="Symmetric_cone:241">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is a biholomorphic self-mapping of 

<math display="inline" id="Symmetric_cone:242">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(0)=0
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Symmetric_cone:243">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 and derivative 

<math display="inline" id="Symmetric_cone:244">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 at 0, then 

<math display="inline" id="Symmetric_cone:245">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 must be the identity.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> If not, 

<math display="inline" id="Symmetric_cone:246">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 has Taylor series expansion <mtpl></mtpl> with <mtpl></mtpl> homogeneous of degree 

<math display="inline" id="Symmetric_cone:247">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

and <mtpl></mtpl>. But then <mtpl></mtpl>. Let 

<math display="inline" id="Symmetric_cone:248">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A*
  </annotation>
 </semantics>
</math>

 be a functional in 

<math display="inline" id="Symmetric_cone:249">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 of norm one. Then for fixed 

<math display="inline" id="Symmetric_cone:250">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Symmetric_cone:251">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, the holomorphic functions of a complex variable 

<math display="inline" id="Symmetric_cone:252">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 given by <mtpl></mtpl> must have modulus less than 1 for |<em>w</em>|  must be uniformly bounded independent of 

<math display="inline" id="Symmetric_cone:253">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

, which is not possible if <mtpl></mtpl>.</p>

<p>If 

<math display="inline" id="Symmetric_cone:254">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is a biholomorphic mapping of 

<math display="inline" id="Symmetric_cone:255">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 onto itself just fixing 0 then if <mtpl></mtpl>, the mapping <mtpl></mtpl> fixes 0 and has derivative 

<math display="inline" id="Symmetric_cone:256">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 there. It is therefore the identity map. So <mtpl></mtpl> for any α. This implies <em>g</em> is a linear mapping. Since it maps 

<math display="inline" id="Symmetric_cone:257">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 onto itself it maps the closure onto itself. In particular it must map the Shilov boundary 

<math display="inline" id="Symmetric_cone:258">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 onto itself. This forces 

<math display="inline" id="Symmetric_cone:259">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 to be in the unitary structure group.</p>

<p><mtpl></mtpl> {{-}} The orbit of 0 under <em>A</em><sub><em>D</em></sub> is the set of all points <mtpl></mtpl> with <mtpl></mtpl>. The orbit of these points under the unitary structure group is the whole of 

<math display="inline" id="Symmetric_cone:260">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">×</mi>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>U</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(n)×U(n)
  </annotation>
 </semantics>
</math>

. The Cartan decomposition follows because <mtpl></mtpl> is the stabilizer of 0 in <mtpl></mtpl>.</p>

<p><mtpl></mtpl> {{-}}</p>

<p>In fact the only point fixed by (the identity component of) <em>K</em><sub><em>D</em></sub> in <em>D</em> is 0. Uniqueness implies that the <a href="Center_(geometry)" title="wikilink">center</a> of <em>G</em><sub><em>D</em></sub> must fix 0. It follows that the center of <em>G</em><sub><em>D</em></sub> lies in <em>K</em><sub><em>D</em></sub>. The center of <em>K</em><sub><em>D</em></sub> is isomorphic to the circle group: a rotation through θ corresponds to multiplication by <em>e</em><sup><em>i</em>θ</sup> on <em>D</em> so lies in }. Since this group has trivial center, the center of <em>G</em><sub><em>D</em></sub> is trivial.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> <mtpl></mtpl> {{-}} In fact any larger compact subgroup would intersect <em>A</em><sub><em>D</em></sub> non-trivially and it has no non-trivial compact subgroups.</p>

<p>Note that <em>G</em><sub><em>D</em></sub> is a Lie group (see below), so that the above three statements hold with <em>G</em><sub><em>D</em></sub> and <em>K</em><sub><em>D</em></sub> replaced by their identity components, i.e. the subgroups generated by their one-parameter cubgroups. Uniqueness of the maximal compact subgroup up to conjugacy follows from <a href="maximal_compact_subgroup#Proof_of_uniqueness_for_semisimple_groups" title="wikilink">a general argument</a> or can be deduced for classical domains directly using <a href="Sylvester's_law_of_inertia" title="wikilink">Sylvester's law of inertia</a> following .<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> For the example of Hermitian matrices over <strong>C</strong>, this reduces to proving that 

<math display="inline" id="Symmetric_cone:261">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <interval closure="open">
     <ci>n</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(n,n)
  </annotation>
 </semantics>
</math>

 is up to conjugacy the unique maximal compact subgroup in 

<math display="inline" id="Symmetric_cone:262">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">×</mi>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>U</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(n)×U(n)
  </annotation>
 </semantics>
</math>

. In fact if <mtpl></mtpl>, then 

<math display="inline" id="Symmetric_cone:263">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <interval closure="open">
     <ci>n</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(n,n)
  </annotation>
 </semantics>
</math>

 is the subgroup of 

<math display="inline" id="Symmetric_cone:264">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 preserving <em>W</em>. The restriction of the hermitian form given by the inner product on 

<math display="inline" id="Symmetric_cone:265">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 minus the inner product on <mtpl></mtpl>. On the other hand if 

<math display="inline" id="Symmetric_cone:266">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <interval closure="open">
     <ci>n</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(n,n)
  </annotation>
 </semantics>
</math>

 is a compact subgroup of 

<math display="inline" id="Symmetric_cone:267">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

, there is a 

<math display="inline" id="Symmetric_cone:268">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

-invariant inner product on <mtpl></mtpl> obtained by averaging any inner product with respect to Haar measure on 

<math display="inline" id="Symmetric_cone:269">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. The Hermitian form corresponds to an orthogonal decomposition into two subspaces of dimension 

<math display="inline" id="Symmetric_cone:270">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 both invariant under 

<math display="inline" id="Symmetric_cone:271">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 with the form positive definite on one and negative definite on the other. By Sylvester's law of inertia, given two subspaces of dimension 

<math display="inline" id="Symmetric_cone:272">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <interval closure="open">
     <ci>n</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(n,n)
  </annotation>
 </semantics>
</math>

 on which the Hermitian form is positive definite, one is carried onto the other by an element of 

<math display="inline" id="Symmetric_cone:273">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

. Hence there is an element 

<math display="inline" id="Symmetric_cone:274">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <interval closure="open">
     <ci>n</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(n,n)
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Symmetric_cone:275">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   gW
  </annotation>
 </semantics>
</math>

 such that the positive definite subspace is given by 

<math display="inline" id="Symmetric_cone:276">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

. So <mtpl></mtpl> leaves 

<math display="block" id="Symmetric_cone:277">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>G</mi>
     <mi>T</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>T</mi>
     </msub>
     <msub>
      <mi>A</mi>
      <mi>T</mi>
     </msub>
     <msub>
      <mi>K</mi>
      <mi>T</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{G_{T}=K_{T}A_{T}K_{T}.}
  </annotation>
 </semantics>
</math>

 invariant and <mtpl></mtpl>.</p>

<p>A similar argument. with <a href="quaternion" title="wikilink">quaternions</a> replacing the complex numbers, shows uniquess for the symplectic group, which corresponds to Hermitian matrices over <strong>R</strong>. This can also been see more directly by using <a href="Complex_manifold" title="wikilink">complex structures</a>. A complex structure is an invertible operator <em>J</em> with <em>J</em><sup>2</sup> = −<em>I</em>. preserving the symplectic form <em>B</em> and such that −<em>B</em>(<em>Jx</em>,<em>y</em>) is a real inner product. The symplectic group acts transitively on complex structures by conjugation. Moreover the subgroup commuting with <em>J</em> is naturally identified with the unitary group for the corresponding complex inner product space. Uniqueness follows by showing that any compact subgroup <em>K</em> commutes with some complex structure <em>J</em>. In fact, averaging over Haar measure, there is a <em>K</em>-invariant inner product on the underlying space. The symplectic form yields an invertible skew-adjoint operator <em>T</em> commuting with <em>K</em>. The operator <em>S</em> = −<em>T</em><sup>2</sup> is positive, so has a unique positive square root, which commutes with <em>K</em>. So <em>J</em> = <em>S</em><sup>−1/2</sup><em>T</em>, the phase of <em>T</em>, has square −<em>I</em> and commutes with <em>K</em>.</p>
<h3 id="automorphism-group-of-tube-domain">Automorphism group of tube domain</h3>

<p>There is an <a href="Cartan_decomposition" title="wikilink">Cartan decomposition</a> for <em>G</em><sub><em>T</em></sub> corresponding to the action on the tube <em>T</em> = <em>E</em> + <em>iC</em>:</p>

<p>

<math display="inline" id="Symmetric_cone:278">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li><em>K</em><sub><em>T</em></sub> is the stabilizer of <em>i</em> in <em>iC</em> ⊂ <em>T</em>, so a maximal compact subgroup of <em>G</em><sub><em>T</em></sub>. Under the Cayley transform, <em>K</em><sub><em>T</em></sub> corresponds to <em>K</em><sub><em>D</em></sub>, the stabilizer of 0 in the bounded symmetric domain, where it acts linearly. Since <em>G</em><sub><em>T</em></sub> is semisimple, every <a href="Maximal_compact_subgroup#Proof_of_uniqueness_for_semisimple_groups" title="wikilink">maximal compact subgroup</a> is conjugate to <em>K</em><sub><em>T</em></sub>.</li>
<li>The center of <em>G</em><sub><em>T</em></sub> or <em>G</em><sub><em>D</em></sub> is trivial. In fact the only point fixed by <em>K</em><sub><em>D</em></sub> in <em>D</em> is 0. Uniqueness implies that the <a href="Center_(geometry)" title="wikilink">center</a> of <em>G</em><sub><em>D</em></sub> must fix 0. It follows that the center of <em>G</em><sub><em>D</em></sub> lies in <em>K</em><sub><em>D</em></sub> and hence that the center of <em>G</em><sub><em>T</em></sub> lies in <em>K</em><sub><em>T</em></sub>. The center of <em>K</em><sub><em>D</em></sub> is isomorphic to the circle group: a rotation through θ corresponds to multiplication by <em>e</em><sup><em>i</em>θ</sup> on <em>D</em>. In Cayley transform it corresponds to the <a href="Möbius_transformation" title="wikilink">Möbius transformation</a> <em>z</em> ↦ (<em>cz</em> + <em>s</em>)(−<em>sz</em> + <em>c</em>)<sup>−1</sup> where <em>c</em> = cos θ/2 and <em>s</em> = sin θ/2. (In particular, when θ = π, this gives the symmetry <em>j</em>(<em>z</em>) = −<em>z</em><sup>−1</sup>.) In fact all Möbius transformations <em>z</em> ↦ (α<em>z</em> + β)(−γ<em>z</em> + δ)<sup>−1</sup> with αδ − βγ = 1 lie in <em>G</em><sub><em>T</em></sub>. Since PSL(2,<strong>R</strong>) has trivial center, the center of <em>G</em><sub><em>T</em></sub> is trivial.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
<li><em>A</em><sub><em>T</em></sub> is given by the linear operators <em>Q</em>(<em>a</em>) with <em>a</em> = ∑ α<sub><em>i</em></sub> <em>e</em><sub><em>i</em></sub> with α<sub><em>i</em></sub> &gt; 0.</li>
</ul>

<p>In fact the Cartan decomposition for <mtpl></mtpl> follows from the decomposition for <mtpl></mtpl>. Given 

<math display="inline" id="Symmetric_cone:279">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Symmetric_cone:280">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

, there is an element 

<math display="inline" id="Symmetric_cone:281">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 in <mtpl></mtpl>, the identity component of <mtpl></mtpl>, such that <mtpl></mtpl> with <mtpl></mtpl>. Since ||<em>z</em>|| . Taking the Cayley transform of <em>z</em>, it follows that every 

<math display="inline" id="Symmetric_cone:282">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Symmetric_cone:283">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 can be written <mtpl></mtpl>, with 

<math display="inline" id="Symmetric_cone:284">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 the Cayley transform and 

<math display="inline" id="Symmetric_cone:285">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 in <mtpl></mtpl>. Since <mtpl></mtpl> with <mtpl></mtpl>, the point 

<math display="inline" id="Symmetric_cone:286">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=ka(i)
  </annotation>
 </semantics>
</math>

 is of the form 

<math display="inline" id="Symmetric_cone:287">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Symmetric_cone:288">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 in 

<math display="block" id="Symmetric_cone:289">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>G</mi>
     <mi>T</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>T</mi>
     </msub>
     <msub>
      <mi>A</mi>
      <mi>T</mi>
     </msub>
     <msub>
      <mi>N</mi>
      <mi>T</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{G_{T}=K_{T}A_{T}N_{T}.}
  </annotation>
 </semantics>
</math>

. Hence <mtpl></mtpl>.</p>
<h3 id="graded-lie-algebras">3-graded Lie algebras</h3>
<h3 id="iwasawa-decomposition">Iwasawa decomposition</h3>

<p>There is an <a href="Iwasawa_decomposition" title="wikilink">Iwasawa decomposition</a> for <em>G</em><sub><em>T</em></sub> corresponding to the action on the tube <em>T</em> = <em>E</em> + <em>iC</em>:<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>

<math display="inline" id="Symmetric_cone:290">
 <semantics>
  <msub>
   <mi>𝔤</mi>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔤</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}_{T}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li><em>K</em><sub><em>T</em></sub> is the stabilizer of <em>i</em> in <em>iC</em> ⊂ <em>T</em>.</li>
<li><em>A</em><sub><em>T</em></sub> is given by the linear operators <em>Q</em>(<em>a</em>) where <em>a</em> = ∑ α<sub><em>i</em></sub> <em>e</em><sub><em>i</em></sub> with α<sub><em>i</em></sub> &gt; 0.</li>
<li><em>N</em><sub><em>T</em></sub> is a lower unitriangular group on <em>E</em><sub><strong>C</strong></sub>. It is the semidirect product of the unipotent triangular group <em>N</em> appearing in the Iwasawa decomposition of <em>G</em> (the symmetry group of <em>C</em>) and <em>N</em><sub>0</sub> = <em>E</em>, group of translations <em>x</em> ↦ <em>x</em> + <em>b</em>.</li>
</ul>

<p>The group <em>S</em> = <em>AN</em> acts on <em>E</em> linearly and conjugation on <em>N</em><sub>0</sub> reproduces this action. Since the group <em>S</em> acts simply transitively on <em>C</em>, it follows that <em>AN</em><sub><em>T</em></sub>=<em>S</em>⋅<em>N</em><sub>0</sub> acts simply transitively on <em>T</em> = <em>E</em> + <em>iC</em>. Let <em>H</em><sub><em>T</em></sub> be the group of <a href="biholomorphism" title="wikilink">biholomorphisms</a> of the tube <em>T</em>. The Cayley transform shows that is isomorphic to the group <em>H</em><sub><em>D</em></sub> of biholomorphisms of the bounded domain <em>D</em>. Since <em>AN</em><sub><em>T</em></sub> acts simply transitively on the tube <em>T</em> while <em>K</em><sub><em>T</em></sub> fixes <em>ic</em>, they have trivial intersection.</p>

<p>Given <em>g</em> in <em>H</em><sub><em>T</em></sub>, take <em>s</em> in <em>AN</em><sub><em>T</em></sub> such that <em>g</em><sup>−1</sup>(<em>i</em>)=<em>s</em><sup>−1</sup>(<em>i</em>). then <em>gs</em><sup>−1</sup> fixes <em>i</em> and therefore lies in <em>K</em><sub><em>T</em></sub>. Hence <em>H</em><sub><em>T</em></sub> = <em>K</em><sub><em>T</em></sub> ⋅<em>A</em>⋅<em>N</em><sub><em>T</em></sub>. So the product is a group.</p>
<h3 id="lie-group-structure">Lie group structure</h3>

<p>By a result of <a href="Henri_Cartan" title="wikilink">Henri Cartan</a>, <em>H</em><sub><em>D</em></sub> is a Lie group. Cartan's original proof is presented in . It can also be deduced from the fact the <em>D</em> is complete for the <a href="Bergman_metric" title="wikilink">Bergman metric</a>, for which the isometries form a Lie group; by <a href="Montel's_theorem" title="wikilink">Montel's theorem</a>, the group of biholomorphisms is a closed subgroup.<ref>See:</ref></p>
<ul>
<li></li>
<li></li>
<li></li>
<li>

<p></p></li>
</ul>

<p>That <em>H</em><sub><em>T</em></sub> is a Lie group can be seen directly in this case. In fact there is a finite-dimensional 3-graded Lie algebra 

<math display="inline" id="Symmetric_cone:291">
 <semantics>
  <msub>
   <mi>𝔤</mi>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔤</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}_{T}
  </annotation>
 </semantics>
</math>

 of vector fields with an involution σ. The Killing form is negative definite on the +1 eigenspace of σ and positive definite on the −1 eigenspace. As a group <em>H</em><sub><em>T</em></sub> normalizes 

<math display="inline" id="Symmetric_cone:292">
 <semantics>
  <msub>
   <mi>𝔤</mi>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔤</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}_{T}
  </annotation>
 </semantics>
</math>

 since the two subgroups <em>K</em><sub><em>T</em></sub> and <em>AN</em><sub><em>T</em></sub> do. The +1 eigenspace corresponds to the Lie algebra of <em>K</em><sub><em>T</em></sub>. Similarly the Lie algebras of the linear group <em>AN</em> and the affine group <em>N</em><sub>0</sub> lie in 

<math display="inline" id="Symmetric_cone:293">
 <semantics>
  <msub>
   <mi>𝔤</mi>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔤</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}_{T}
  </annotation>
 </semantics>
</math>

. Since the group <em>G</em><sub><em>T</em></sub> has trivial center, the map into GL(

<math display="inline" id="Symmetric_cone:294">
 <semantics>
  <msub>
   <mi>𝔤</mi>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔤</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}_{T}
  </annotation>
 </semantics>
</math>

) is injective. Since <em>K</em><sub><em>T</em></sub> is compact, its image in GL(

<math display="inline" id="Symmetric_cone:295">
 <semantics>
  <msub>
   <mi>𝔤</mi>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔤</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}_{T}
  </annotation>
 </semantics>
</math>

) is compact. Since the Lie algebra 

<math display="block" id="Symmetric_cone:296">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>b</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>a</mi>
          <mi>b</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <plus></plus>
      <interval closure="closed">
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>b</ci>
       </apply>
      </interval>
      <apply>
       <times></times>
       <ci>L</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{L(a,b)=2([L(a),L(b)]+L(ab)).}
  </annotation>
 </semantics>
</math>

 is compatible with that of <em>AN</em><sub><em>T</em></sub>, the image of <em>AN</em><sub><em>T</em></sub> is closed. Hence the image of the product is closed, since the image of <em>K</em><sub><em>T</em></sub> is compact. Since it is a closed subgroup, it follows that <em>H</em><sub><em>T</em></sub> is a Lie group.</p>
<h2 id="generalizations">Generalizations</h2>

<p>Euclidean Jordan algebras can be used to construct Hermitian symmetric spaces of tube type. The remaining Hermitian symmetric spaces are Siegel domains of the second kind. They can be constructed using Euclidean <a href="Jordan_triple_system" title="wikilink">Jordan triple systems</a>, a generalization of Euclidean Jordan algebras. In fact for a Euclidean Jordan algebra <em>E</em> let</p>

<p>

<math display="block" id="Symmetric_cone:297">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>*</mo>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo>,</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="7.6pt">,</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>c</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>a</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <interval closure="open">
        <ci>a</ci>
        <ci>b</ci>
       </interval>
       <times></times>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <interval closure="open">
       <ci>b</ci>
       <ci>a</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>b</ci>
      </interval>
      <ci>c</ci>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <interval closure="open">
       <ci>c</ci>
       <ci>b</ci>
      </interval>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{L(a,b)^{*}=L(b,a)},\,\,\,L(a,b)c=L(c,b)a
  </annotation>
 </semantics>
</math>

</p>

<p>Then <em>L</em>(<em>a</em>,<em>b</em>) gives a bilinear map into End <em>E</em> such that</p>

<p>

<math display="block" id="Symmetric_cone:298">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo>,</mo>
       <mi>d</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>a</mi>
         <mo>,</mo>
         <mi>b</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>c</mi>
       </mrow>
       <mo>,</mo>
       <mi>d</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo>,</mo>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>b</mi>
         <mo>,</mo>
         <mi>a</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>d</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="closed">
     <apply>
      <times></times>
      <ci>L</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>b</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <interval closure="open">
       <ci>c</ci>
       <ci>d</ci>
      </interval>
     </apply>
    </interval>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>L</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>L</ci>
        <interval closure="open">
         <ci>a</ci>
         <ci>b</ci>
        </interval>
        <ci>c</ci>
       </apply>
       <ci>d</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <interval closure="open">
       <ci>c</ci>
       <apply>
        <times></times>
        <ci>L</ci>
        <interval closure="open">
         <ci>b</ci>
         <ci>a</ci>
        </interval>
        <ci>d</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{[L(a,b),L(c,d)]=L(L(a,b)c,d)-L(c,L(b,a)d).}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Symmetric_cone:299">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝔤</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝔤</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>⊕</mo>
     <msub>
      <mi>𝔤</mi>
      <mn>0</mn>
     </msub>
     <mo>⊕</mo>
     <msub>
      <mi>𝔤</mi>
      <mn>1</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝔤</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔤</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔤</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔤</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\mathfrak{g}=\mathfrak{g}_{-1}\oplus\mathfrak{g}_{0}\oplus%
\mathfrak{g}_{1},}
  </annotation>
 </semantics>
</math>

</p>

<p>Any such bilinear system is called a <strong>Euclidean Jordan triple system</strong>. By definition the operators <em>L</em>(<em>a</em>,<em>b</em>) form a Lie subalgebra of End <em>E</em>.</p>

<p>The <a href="Kantor–Koecher–Tits_construction" title="wikilink">Kantor–Koecher–Tits construction</a> gives a one-one correspondence between Jordan triple systems and 3-graded Lie algebras</p>

<p>

<math display="block" id="Symmetric_cone:300">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>𝔤</mi>
     <mi>p</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>𝔤</mi>
     <mi>q</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>⊆</mo>
   <msub>
    <mi>𝔤</mi>
    <mrow>
     <mi>p</mi>
     <mo>+</mo>
     <mi>q</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <interval closure="closed">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔤</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔤</ci>
      <ci>q</ci>
     </apply>
    </interval>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔤</ci>
     <apply>
      <plus></plus>
      <ci>p</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{[\mathfrak{g}_{p},\mathfrak{g}_{q}]\subseteq\mathfrak{g}_{p+q}}
  </annotation>
 </semantics>
</math>

</p>

<p>satisfying</p>

<p>

<math display="block" id="Symmetric_cone:301">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>ad</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>ad</ci>
     <interval closure="closed">
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>b</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{L(a,b)=\mathrm{ad}\,[a,\sigma(b)]}
  </annotation>
 </semantics>
</math>

</p>

<p>and equipped with an involutive automorphism σ reversing the grading. In this case</p>

<p>

<math display="inline" id="Symmetric_cone:302">
 <semantics>
  <msub>
   <mi>𝔤</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔤</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}_{-1}
  </annotation>
 </semantics>
</math>

</p>

<p>defines a Jordan triple system on 

<math display="inline" id="Symmetric_cone:303">
 <semantics>
  <msub>
   <mi>𝔤</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔤</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}_{0}
  </annotation>
 </semantics>
</math>

. In the case of Euclidean Jordan algebras or triple systems the Kantor–Koecher–Tits construction can be identified with the Lie algebra of the Lie group of all homomorphic automorphisms of the corresponding <a href="bounded_symmetric_domain" title="wikilink">bounded symmetric domain</a>. The Lie algebra is constructed by taking 

<math display="inline" id="Symmetric_cone:304">
 <semantics>
  <mi>𝔥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{h}
  </annotation>
 </semantics>
</math>

 to be the Lie subalgebra 

<math display="inline" id="Symmetric_cone:305">
 <semantics>
  <msub>
   <mi>𝔤</mi>
   <mrow>
    <mo>±</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔤</ci>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}_{\pm 1}
  </annotation>
 </semantics>
</math>

 of End <em>E</em> generated by the L(<em>a</em>,<em>b</em>) and 

<math display="block" id="Symmetric_cone:306">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>T</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>T</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>T</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>a</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>T</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>T</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>T</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>a</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>b</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>b</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msubsup>
       <mi>T</mi>
       <mn>2</mn>
       <mo>*</mo>
      </msubsup>
      <msub>
       <mi>b</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msubsup>
       <mi>T</mi>
       <mn>1</mn>
       <mo>*</mo>
      </msubsup>
      <msub>
       <mi>b</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="closed">
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
     </vector>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </vector>
    </interval>
    <vector>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <interval closure="closed">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
       </interval>
       <apply>
        <times></times>
        <ci>L</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <cn type="integer">2</cn>
         </apply>
        </interval>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{[(a_{1},T_{1},b_{1}),(a_{2},T_{2},b_{2})]=(T_{1}a_{2}-T_{2}a_{1}%
,[T_{1},T_{2}]+L(a_{1},b_{2})-L(a_{2},b_{1}),T_{2}^{*}b_{1}-T_{1}^{*}b_{2})}
  </annotation>
 </semantics>
</math>

 to be copies of <em>E</em>. The Lie bracket is given by</p>

<p>

<math display="block" id="Symmetric_cone:307">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>T</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <msup>
       <mi>T</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mo>,</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <vector>
      <ci>a</ci>
      <ci>T</ci>
      <ci>b</ci>
     </vector>
    </apply>
    <vector>
     <ci>b</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <times></times>
      </apply>
     </apply>
     <ci>a</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\sigma(a,T,b)=(b,-T^{*},a).}
  </annotation>
 </semantics>
</math>

</p>

<p>and the involution by</p>

<p>

<math display="block" id="Symmetric_cone:308">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>T</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>b</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>T</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>b</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>b</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>b</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>a</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>β</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>T</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>T</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </vector>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </vector>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
     <apply>
      <times></times>
      <ci>β</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{B((a_{1},T_{1},b_{1}),(a_{2},T_{2},b_{2}))=(a_{1},b_{2})+(b_{1},%
a_{2})+\beta(T_{1},T_{2}),}
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="Killing_form" title="wikilink">Killing form</a> is given by</p>

<p>

<math display="block" id="Symmetric_cone:309">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>β</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo>,</mo>
        <mi>b</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo>,</mo>
        <mi>d</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>c</mi>
     </mrow>
     <mo>,</mo>
     <mi>d</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo>,</mo>
       <mi>d</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>a</mi>
     </mrow>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>β</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>L</ci>
        <interval closure="open">
         <ci>a</ci>
         <ci>b</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>L</ci>
        <interval closure="open">
         <ci>c</ci>
         <ci>d</ci>
        </interval>
       </apply>
      </interval>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <ci>a</ci>
        <ci>b</ci>
       </interval>
       <ci>c</ci>
      </apply>
      <ci>d</ci>
     </interval>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <ci>c</ci>
        <ci>d</ci>
       </interval>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\beta(L(a,b),L(c,d))=(L(a,b)c,d)=(L(c,d)a,b).}
  </annotation>
 </semantics>
</math>

</p>

<p>where β(<em>T</em><sub>1</sub>,<em>T</em><sub>2</sub>) is the symmetric bilinear form defined by</p>

<p>

<math display="inline" id="Symmetric_cone:310">
 <semantics>
  <mi>𝔤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}
  </annotation>
 </semantics>
</math>

</p>

<p>These formulas, originally derived for Jordan algebras, work equally well for Jordan triple systems.<ref>See:</ref></p>
<ul>
<li></li>
<li></li>
<li></li>
<li>

<p></p></li>
</ul>

<p>The account in  develops the theory of <a href="bounded_symmetric_domain" title="wikilink">bounded symmetric domains</a> starting from the standpoint of 3-graded Lie algebras. For a given finite-dimensional vector space <em>E</em>, Koecher considers finite-dimensional Lie algebras 

<math display="inline" id="Symmetric_cone:311">
 <semantics>
  <msub>
   <mi>𝔤</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔤</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}_{-1}
  </annotation>
 </semantics>
</math>

 of vector fields on <em>E</em> with polynomial coefficients of degree ≤ 2. 

<math display="inline" id="Symmetric_cone:312">
 <semantics>
  <msub>
   <mi>𝔤</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔤</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}_{0}
  </annotation>
 </semantics>
</math>

 consists of the constant vector fields ∂<sub><em>i</em></sub> and 

<math display="inline" id="Symmetric_cone:313">
 <semantics>
  <msub>
   <mi>𝔤</mi>
   <mrow>
    <mo>±</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔤</ci>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}_{\pm 1}
  </annotation>
 </semantics>
</math>

 must contain the <a href="Euler_operator" title="wikilink">Euler operator</a> <em>H</em> = ∑ <em>x</em><sub><em>i</em></sub>⋅∂<sub><em>i</em></sub> as a central element. Requiring the existence of an involution σ leads directly to a Jordan triple structure on <em>V</em> as above. As for all Jordan triple structures, fixing <em>c</em> in <em>E</em>, the operators <em>L</em><sub><em>c</em></sub>(<em>a</em>) = <em>L</em>(<em>a</em>,<em>c</em>) give <em>E</em> a Jordan algebra structure, determined by <em>e</em>. The operators <em>L</em>(<em>a</em>,<em>b</em>) themselves come from a Jordan algebra structure as above if and only if there are additional operators <em>E</em><sub>±</sub> in 

<math display="inline" id="Symmetric_cone:314">
 <semantics>
  <mrow>
   <mi>𝔰</mi>
   <msub>
    <mi>𝔩</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝔰</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔩</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{sl}_{2}
  </annotation>
 </semantics>
</math>

 so that <em>H</em>, <em>E</em><sub>±</sub> give a copy of 

<math display="block" id="Symmetric_cone:315">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <cn type="integer">0</cn>
     </apply>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
     <ci>c</ci>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{L_{0}(a,b)c=L(a,b)c}
  </annotation>
 </semantics>
</math>

. The corresponding Weyl group element implements the involution σ. This case corresponds to that of Euclidean Jordan algebras.</p>

<p>The remaining cases are constructed uniformly by Koecher using involutions of simple Euclidean Jordan algebras.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> Let <em>E</em> be a simple Euclidean Jordan algebra and τ a Jordan algebra automorphism of <em>E</em> of period 2. Thus <em>E</em> = <em>E</em><sub>+1</sub> ⊕ <em>E</em><sub>−1</sub> has an eigenspace decomposition for τ with <em>E</em><sub>+1</sub> a Jordan subalgebra and <em>E</em><sub>−1</sub> a module. Moreover a product of two elements in <em>E</em><sub>−1</sub> lies in <em>E</em><sub>+1</sub>. For <em>a</em>, <em>b</em>, <em>c</em> in <em>E</em><sub>−1</sub>, set</p>

<p><span class="LaTeX">$$\displaystyle{L_0(a,b)c=L(a,b)c}$$</span></p>

<p>and (<em>a</em>,<em>b</em>)= Tr <em>L</em>(<em>ab</em>). Then <em>F</em> = <em>E</em><sub>−1</sub> is a simple Euclidean Jordan triple system, obtained by restricting the triple system on <em>E</em> to <em>F</em>. Koecher exhibits explicit involutions of simple Euclidean Jordan algebras directly (see below). These Jordan triple systems correspond to irreducible Hermitian symmetric spaces given by Siegel domains of the second kind. In Cartan's listing, their compact duals are SU(<em>p</em> + <em>q</em>)/S(U(<em>p</em>) × U(<em>q</em>)) with <em>p</em> ≠ <em>q</em> (AIII), SO(2<em>n</em>)/U(<em>n</em>) with <em>n</em> odd (DIII) and E<sub>6</sub>/SO(10) × U(1) (EIII).</p>

<p><strong>Examples</strong></p>
<ul>
<li><em>F</em> is the space of <em>p</em> by <em>q</em> matrices over <strong>R</strong> with <em>p</em> ≠ <em>q</em>. In this case <em>L</em>(<em>a</em>,<em>b</em>)<em>c</em>= <em>ab</em><sup><em>t</em></sup><em>c</em> + <em>cb</em><sup><em>t</em></sup><em>a</em> with inner product (<em>a</em>,<em>b</em>) = Tr <em>ab</em><sup><em>t</em></sup>. This is Koecher's construction for the involution on <em>E</em> = <em>H</em><sub><em>p</em> + <em>q</em></sub>(<strong>R</strong>) given by conjugating by the diagonal matrix with <em>p</em> digonal entries equal to 1 and <em>q</em> to −1.</li>
<li><em>F</em> is the space of real skew-symmetric <em>m</em> by <em>m</em> matrices. In this case <em>L</em>(<em>a</em>,<em>b</em>)<em>c</em> = <em>abc</em> + <em>cba</em> with inner product (<em>a</em>,<em>b</em>) = −Tr <em>ab</em>. After removing a factor of √(-1), this is Koecher's construction applied to complex conjugation on <em>E</em> = <em>H</em><sub><em>n</em></sub>(<strong>C</strong>).</li>
<li><em>F</em> is the direct sum of two copies of the Cayley numbers, regarded as 1 by 2 matrices. This triple system is obtained by Koecher's construction for the canonical involution defined by any minimal idempotent in <em>E</em> = <em>H</em><sub>3</sub>(<strong>O</strong>).</li>
</ul>

<p>The classification of Euclidean Jordan triple systems has been achieved by generalizing the methods of Jordan, von Neumann and Wigner, but the proofs are more involved.<ref>See:</ref></p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p> Prior differential geometric methods of , invoking a 3-graded Lie algebra, and of ,  lead to a more rapid classification.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>(reprint of 1951 article)</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li><mtpl></mtpl></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>, originally lecture notes from a course given in the <a href="University_of_Göttingen" title="wikilink">University of Göttingen</a> in 1962</p></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Convex_geometry" title="wikilink">Category:Convex geometry</a> <a href="Category:Non-associative_algebras" title="wikilink">Category:Non-associative algebras</a> <a href="Category:Lie_algebras" title="wikilink">Category:Lie algebras</a> <a href="Category:Lie_groups" title="wikilink">Category:Lie groups</a> <a href="Category:Several_complex_variables" title="wikilink">Category:Several complex variables</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">This article uses as its main sources ,  and , adopting the terminology and some simplifications from the latter.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">See  and . By finite-dimensionality, every point in the convex span of <em>S</em> is the convex combination of <em>n</em> + 1 points, where <em>n</em> = 2 dim <em>E</em>. So the convex span of <em>S</em> is already compact and equals the closed unit ball.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19">Note that the elementary argument in  cited in  is incomplete.<a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
</ol>
</section>
</hr></body>
</html>
