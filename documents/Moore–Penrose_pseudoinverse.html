<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="113">Moore–Penrose pseudoinverse</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Moore–Penrose pseudoinverse</h1>
<hr>In [[mathematics]], and in particular [[linear algebra]], a '''pseudoinverse''' {{math|''A''<sup>+</sup>}} of a  [[matrix (mathematics)|matrix]] {{math|''A''}} is a [[Generalized inverse|generalization]] of the [[inverse matrix]].<ref name="IG2003">{{cite book | last=Ben-Israel | first = Adi |author2=[[Thomas N.E. Greville]]  | title=Generalized Inverses | isbn=0-387-00293-6 | publisher=[[Springer Science+Business Media|Springer-Verlag]] | year=2003}}</ref>  The most widely known type of matrix pseudoinverse is the '''Moore–Penrose pseudoinverse''', which was independently described by [[E. H. Moore]]<ref name="Moore1920">{{cite journal | last=Moore | first=E. H. | authorlink=E. H. Moore | title=On the reciprocal of the general algebraic matrix | journal=[[Bulletin of the American Mathematical Society]] | volume=26 |issue=9| pages=394–395 | year=1920 | url =http://projecteuclid.org/euclid.bams/1183425340 | doi = 10.1090/S0002-9

<p>904-1920-03322-7 }} in 1920, <a href="Arne_Bjerhammar" title="wikilink">Arne Bjerhammar</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in 1951 and <a href="Roger_Penrose" title="wikilink">Roger Penrose</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> in 1955. Earlier, <a href="Erik_Ivar_Fredholm" title="wikilink">Fredholm</a> had introduced the concept of a pseudoinverse of <a href="integral_operator" title="wikilink">integral operators</a> in 1903. When referring to a matrix, the term pseudoinverse, without further specification, is often used to indicate the Moore–Penrose pseudoinverse. The term <a href="generalized_inverse" title="wikilink">generalized inverse</a> is sometimes used as a synonym for pseudoinverse.</p>

<p>A common use of the Moore–Penrose pseudoinverse (hereafter, just pseudoinverse) is to compute a 'best fit' (<a href="Ordinary_least_squares" title="wikilink">least squares</a>) solution to a <a href="system_of_linear_equations" title="wikilink">system of linear equations</a> that lacks a unique solution (see below under <a href="#Applications" title="wikilink">§ Applications</a>). Another use is to find the minimum (<a href="Euclidean_norm" title="wikilink">Euclidean</a>) norm solution to a system of linear equations with multiple solutions. The pseudoinverse facilitates the statement and proof of results in linear algebra.</p>

<p>The pseudoinverse is defined and unique for all matrices whose entries are <a href="Real_number" title="wikilink">real</a> or <a href="Complex_number" title="wikilink">complex</a> numbers. It can be computed using the <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a>.</p>
<h2 id="notation">Notation</h2>

<p>In the following discussion, the following conventions are adopted.</p>
<ul>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:0">
<semantics>
<mi>K</mi>
<annotation-xml encoding="MathML-Content">
<ci>K</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   K
  </annotation>
</semantics>
</math>

 will denote one of the <a href="field_(mathematics)" title="wikilink">fields</a> of real or complex numbers, denoted 

<math display="inline" id="Moore–Penrose_pseudoinverse:1">
<semantics>
<mrow>
<mi>ℝ</mi>
<mo rspace="4.2pt">,</mo>
<mi>ℂ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>ℝ</ci>
<ci>ℂ</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{R},\,\mathbb{C}
  </annotation>
</semantics>
</math>

, respectively. The vector space of 

<math display="inline" id="Moore–Penrose_pseudoinverse:2">
<semantics>
<mrow>
<mi>m</mi>
<mo>×</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>m</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   m\times n
  </annotation>
</semantics>
</math>

 matrices over 

<math display="inline" id="Moore–Penrose_pseudoinverse:3">
<semantics>
<mi>K</mi>
<annotation-xml encoding="MathML-Content">
<ci>K</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   K
  </annotation>
</semantics>
</math>


 is denoted by 

<math display="inline" id="Moore–Penrose_pseudoinverse:4">
<semantics>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>n</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>m</ci>
<ci>n</ci>
<ci>K</ci>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{M}(m,n;K)
  </annotation>
</semantics>
</math>

.</li>
<li>For 

<math display="inline" id="Moore–Penrose_pseudoinverse:5">
<semantics>
<mrow>
<mi>A</mi>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>n</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>A</ci>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>m</ci>
<ci>n</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\in\mathrm{M}(m,n;K)
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Moore–Penrose_pseudoinverse:6">
<semantics>
<msup>
<mi>A</mi>
<mi mathvariant="normal">T</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<ci>normal-T</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{\mathrm{T}}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Moore–Penrose_pseudoinverse:7">
<semantics>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}
  </annotation>
</semantics>
</math>

 denote the transpose and Hermitian transpose (also called <a href="conjugate_transpose" title="wikilink">conjugate transpose</a>) respectively. If 

<math display="inline" id="Moore–Penrose_pseudoinverse:8">
<semantics>
<mrow>
<mi>K</mi>
<mo>=</mo>
<mi>ℝ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>K</ci>
<ci>ℝ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K=\mathbb{R}
  </annotation>
</semantics>
</math>


, then 

<math display="inline" id="Moore–Penrose_pseudoinverse:9">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mo>=</mo>
<msup>
<mi>A</mi>
<mi mathvariant="normal">T</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<ci>normal-T</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}=A^{\mathrm{T}}
  </annotation>
</semantics>
</math>

.</li>
<li>For 

<math display="inline" id="Moore–Penrose_pseudoinverse:10">
<semantics>
<mrow>
<mi>A</mi>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>n</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>A</ci>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>m</ci>
<ci>n</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\in\mathrm{M}(m,n;K)
  </annotation>
</semantics>
</math>

, then 

<math display="inline" id="Moore–Penrose_pseudoinverse:11">
<semantics>
<mrow>
<mo>im</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>A</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>im</ci>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{im}(A)
  </annotation>
</semantics>
</math>

 denotes the <a href="column_space" title="wikilink">range</a> (image) of 

<math display="inline" id="Moore–Penrose_pseudoinverse:12">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 (the space spanned by the column vectors of 

<math display="inline" id="Moore–Penrose_pseudoinverse:13">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>


) and 

<math display="inline" id="Moore–Penrose_pseudoinverse:14">
<semantics>
<mrow>
<mo>ker</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>A</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>ker</ci>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{ker}(A)
  </annotation>
</semantics>
</math>

 denotes the <a href="Kernel_(linear_algebra)" title="wikilink">kernel</a> (null space) of 

<math display="inline" id="Moore–Penrose_pseudoinverse:15">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

.</li>
<li>Finally, for any positive integer 

<math display="inline" id="Moore–Penrose_pseudoinverse:16">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Moore–Penrose_pseudoinverse:17">
<semantics>
<mrow>
<msub>
<mi>I</mi>
<mi>n</mi>
</msub>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>,</mo>
<mi>n</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>n</ci>
</apply>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>n</ci>
<ci>n</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   I_{n}\in\mathrm{M}(n,n;K)
  </annotation>
</semantics>
</math>

 denotes the 

<math display="inline" id="Moore–Penrose_pseudoinverse:18">
<semantics>
<mrow>
<mi>n</mi>
<mo>×</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>n</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n\times n
  </annotation>
</semantics>
</math>
<a href="identity_matrix" title="wikilink">identity matrix</a>.</li>
</ul>
<h2 id="definition">Definition</h2>

<p>For 

<math display="inline" id="Moore–Penrose_pseudoinverse:19">
<semantics>
<mrow>
<mi>A</mi>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>n</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>A</ci>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>m</ci>
<ci>n</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\in\mathrm{M}(m,n;K)
  </annotation>
</semantics>
</math>

, a pseudoinverse of 

<math display="inline" id="Moore–Penrose_pseudoinverse:20">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 is defined as a matrix 

<math display="inline" id="Moore–Penrose_pseudoinverse:21">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>,</mo>
<mi>m</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>n</ci>
<ci>m</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}\in\mathrm{M}(n,m;K)
  </annotation>
</semantics>
</math>

 satisfying all of the following four criteria:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<ol>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:22">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>A</mi>
</mrow>
<mo>=</mo>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>A</ci>
</apply>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   AA^{+}A=A\,\!
  </annotation>
</semantics>
</math>

       (<mtpl></mtpl> need not be the general identity matrix, but it maps all column vectors of 

<math display="inline" id="Moore–Penrose_pseudoinverse:23">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>


 to themselves);</li>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:24">
<semantics>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
<mo>=</mo>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}AA^{+}=A^{+}\,\!
  </annotation>
</semantics>
</math>

       (<mtpl></mtpl> is a <a href="weak_inverse" title="wikilink">weak inverse</a> for the multiplicative <a class="uri" href="semigroup" title="wikilink">semigroup</a>);</li>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:25">
<semantics>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>*</mo>
</msup>
<mo>=</mo>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
<times></times>
</apply>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (AA^{+})^{*}=AA^{+}\,\!
  </annotation>
</semantics>
</math>

       (<mtpl></mtpl> is <a href="Hermitian_matrix" title="wikilink">Hermitian</a>); and</li>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:26">
<semantics>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>*</mo>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>A</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>A</ci>
</apply>
<times></times>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>A</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (A^{+}A)^{*}=A^{+}A\,\!
  </annotation>
</semantics>
</math>

       (<mtpl></mtpl> is also Hermitian).</li>
</ol>

<p>
<math display="inline" id="Moore–Penrose_pseudoinverse:27">
<semantics>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}
  </annotation>
</semantics>
</math>

 exists for any matrix, 

<math display="inline" id="Moore–Penrose_pseudoinverse:28">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>


, but when the latter has full <a href="rank_(linear_algebra)" title="wikilink">rank</a>, 

<math display="inline" id="Moore–Penrose_pseudoinverse:29">
<semantics>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}
  </annotation>
</semantics>
</math>

 can be expressed as a simple algebraic formula.</p>

<p>In particular, when 

<math display="inline" id="Moore–Penrose_pseudoinverse:30">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 has <em>full column rank</em> (and thus matrix 

<math display="inline" id="Moore–Penrose_pseudoinverse:31">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}A
  </annotation>
</semantics>
</math>

 is invertible), 

<math display="inline" id="Moore–Penrose_pseudoinverse:32">
<semantics>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}
  </annotation>
</semantics>
</math>

 can be computed as:</p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:33">
<semantics>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mpadded width="+1.7pt">
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mpadded>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=(A^{*}A)^{-1}A^{*}\,.
  </annotation>
</semantics>
</math>
</p>

<p>This particular pseudoinverse constitutes a <em>left inverse</em>, since, in this case, 

<math display="inline" id="Moore–Penrose_pseudoinverse:34">
<semantics>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>A</mi>
</mrow>
<mo>=</mo>
<mi>I</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>A</ci>
</apply>
<ci>I</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}A=I
  </annotation>
</semantics>
</math>

.</p>

<p>When 

<math display="inline" id="Moore–Penrose_pseudoinverse:35">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 has <em>full row rank</em> (matrix 

<math display="inline" id="Moore–Penrose_pseudoinverse:36">
<semantics>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   AA^{*}
  </annotation>
</semantics>
</math>

 is invertible), 

<math display="inline" id="Moore–Penrose_pseudoinverse:37">
<semantics>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}
  </annotation>
</semantics>
</math>

 can be computed as:</p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:38">
<semantics>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mpadded>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=A^{*}(AA^{*})^{-1}\,.
  </annotation>
</semantics>
</math>
</p>

<p>This is a <em>right inverse</em>, as 

<math display="inline" id="Moore–Penrose_pseudoinverse:39">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
<mo>=</mo>
<mi>I</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
<ci>I</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   AA^{+}=I
  </annotation>
</semantics>
</math>

.</p>
<h2 id="properties">Properties</h2>

<p>Proofs for some of these facts may be found on a separate page <a href="Proofs_involving_the_Moore–Penrose_pseudoinverse" title="wikilink">here</a>.</p>
<h3 id="existence-and-uniqueness">Existence and uniqueness</h3>
<ul>
<li>The pseudoinverse exists and is unique: for any matrix 

<math display="inline" id="Moore–Penrose_pseudoinverse:40">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

, there is precisely one matrix 

<math display="inline" id="Moore–Penrose_pseudoinverse:41">
<semantics>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}\,\!
  </annotation>
</semantics>
</math>

, that satisfies the four properties of the definition.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ul>

<p>A matrix satisfying the first condition of the definition is known as a <a href="generalized_inverse" title="wikilink">generalized inverse</a>. If the matrix also satisfies the second definition, it is called a <a href="generalized_inverse#Types_of_generalized_inverses" title="wikilink"> generalized <em>reflexive</em> inverse</a>. Generalized inverses always exist but are not in general unique. Uniqueness is a consequence of the last two conditions.</p>
<h3 id="basic-properties">Basic properties</h3>
<ul>
<li>If 

<math display="inline" id="Moore–Penrose_pseudoinverse:42">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

 has real entries, then so does 

<math display="inline" id="Moore–Penrose_pseudoinverse:43">
<semantics>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}\,\!
  </annotation>
</semantics>
</math>


.</li>
<li>If 

<math display="inline" id="Moore–Penrose_pseudoinverse:44">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

 is <a href="invertible_matrix" title="wikilink">invertible</a>, its pseudoinverse is its inverse. That is

<math display="block" id="Moore–Penrose_pseudoinverse:45">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<msup>
<mi>A</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=A^{-1}\,\!
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
<li>The pseudoinverse of a <a href="zero_matrix" title="wikilink">zero matrix</a> is its transpose.</li>
<li>The pseudoinverse of the pseudoinverse is the original matrix

<math display="block" id="Moore–Penrose_pseudoinverse:46">
<semantics>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
</msup>
<mo>=</mo>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<plus></plus>
</apply>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (A^{+})^{+}=A\,\!
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
<li>Pseudoinversion commutes with transposition, conjugation, and taking the conjugate transpose:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Moore–Penrose_pseudoinverse:47">
<semantics>
<mrow>
<mrow>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>A</mi>
<mi mathvariant="normal">T</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
</msup>
<mo>=</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">T</mi>
</msup>
</mrow>
<mo rspace="9.1pt">,</mo>
<mrow>
<mrow>
<msup>
<mrow>
<mo rspace="4.2pt" stretchy="false">(</mo>
<mpadded width="+1.7pt">
<mover accent="true">
<mi>A</mi>
<mo>¯</mo>
</mover>
</mpadded>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
</msup>
<mo>=</mo>
<mover accent="true">
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>¯</mo>
</mover>
</mrow>
<mo rspace="9.1pt">,</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
</msup>
<mo>=</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mo>*</mo>
</msup>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<ci>normal-T</ci>
</apply>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>normal-T</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-¯</ci>
<ci>A</ci>
</apply>
<plus></plus>
</apply>
<apply>
<ci>normal-¯</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<times></times>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (A^{\mathrm{T}})^{+}=(A^{+})^{\mathrm{T}},~{}~{}(\,\overline{A}\,)^{+}=%
\overline{A^{+}},~{}~{}(A^{*})^{+}=(A^{+})^{*}.\,\!
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>The pseudoinverse of a scalar multiple of 

<math display="inline" id="Moore–Penrose_pseudoinverse:48">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>


 is the reciprocal multiple of <mtpl></mtpl>:</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Moore–Penrose_pseudoinverse:49">
<semantics>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>α</mi>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mi>α</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<ci>α</ci>
<ci>A</ci>
</apply>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>α</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\alpha A)^{+}=\alpha^{-1}A^{+}\,\!
  </annotation>
</semantics>
</math>

 for 

<math display="inline" id="Moore–Penrose_pseudoinverse:50">
<semantics>
<mrow>
<mi>α</mi>
<mo>≠</mo>
<mn>0.</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<neq></neq>
<ci>α</ci>
<cn type="float">0.</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha\neq 0.
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<h4 id="identities">Identities</h4>

<p>The following identities can be used to cancel certain subexpressions or expand expressions involving pseudoinverses. Proofs for these properties can be found in the <a href="Proofs_involving_the_Moore–Penrose_pseudoinverse" title="wikilink">proofs subpage</a>.</p>
<dl>
<dd><dl>
<dd><math>\begin{array}{lclll}
</math></dd>
</dl>
</dd>
</dl>

<p>A^+ &amp;=&amp; A^+ &amp; A^{+*} &amp; A^*\\ A^+ &amp;=&amp; A^* &amp; A^{+*} &amp; A^+\\ A &amp;=&amp; A^{+*}&amp; A^* &amp; A \\ A &amp;=&amp; A &amp; A^* &amp; A^{+*}\\ A^* &amp;=&amp; A^* &amp; A &amp; A^+\\ A^* &amp;=&amp; A^+ &amp; A &amp; A^*\\ \end{array}</p>
<h3 id="reduction-to-hermitian-case">Reduction to Hermitian case</h3>

<p>The computation of the pseudoinverse is reducible to its construction in the Hermitian case. This is possible through the equivalences:</p>
<ul>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:51">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
</msup>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=(A^{*}A)^{+}A^{*}\,\!
  </annotation>
</semantics>
</math>
</li>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:52">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
<plus></plus>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=A^{*}(AA^{*})^{+}\,\!
  </annotation>
</semantics>
</math>
</li>
</ul>

<p>as 

<math display="inline" id="Moore–Penrose_pseudoinverse:53">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}A
  </annotation>
</semantics>
</math>


 and 

<math display="inline" id="Moore–Penrose_pseudoinverse:54">
<semantics>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   AA^{*}
  </annotation>
</semantics>
</math>

 are obviously Hermitian.</p>
<h3 id="products">Products</h3>

<p>If 

<math display="inline" id="Moore–Penrose_pseudoinverse:55">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>n</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo rspace="5.8pt">,</mo>
<mrow>
<mi>B</mi>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>,</mo>
<mi>p</mi>
<mo>;</mo>
<mi>K</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<in></in>
<ci>A</ci>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>m</ci>
<ci>n</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
<apply>
<in></in>
<ci>B</ci>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>n</ci>
<ci>p</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\in\mathrm{M}(m,n;K),~{}B\in\mathrm{M}(n,p;K)\,
  </annotation>
</semantics>
</math>

 and either,</p>
<ul>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:56">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

 has orthonormal columns (i.e., 

<math display="inline" id="Moore–Penrose_pseudoinverse:57">
<semantics>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<mo>=</mo>
<mpadded width="+1.7pt">
<msub>
<mi>I</mi>
<mi>n</mi>
</msub>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}A=I_{n}\,
  </annotation>
</semantics>
</math>

) or,</li>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:58">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B\,\!
  </annotation>
</semantics>
</math>


 has orthonormal rows (i.e., 

<math display="inline" id="Moore–Penrose_pseudoinverse:59">
<semantics>
<mrow>
<mrow>
<mi>B</mi>
<msup>
<mi>B</mi>
<mo>*</mo>
</msup>
</mrow>
<mo>=</mo>
<mpadded width="+1.7pt">
<msub>
<mi>I</mi>
<mi>n</mi>
</msub>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>B</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>B</ci>
<times></times>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   BB^{*}=I_{n}\,
  </annotation>
</semantics>
</math>

) or,</li>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:60">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

 has all columns linearly independent (full column rank) and 

<math display="inline" id="Moore–Penrose_pseudoinverse:61">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B\,\!
  </annotation>
</semantics>
</math>

 has all rows linearly independent (full row rank) or,</li>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:62">
<semantics>
<mrow>
<mi>B</mi>
<mo>=</mo>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>B</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   B=A^{*}\,\!
  </annotation>
</semantics>
</math>

 (i.e., 

<math display="inline" id="Moore–Penrose_pseudoinverse:63">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B
  </annotation>
</semantics>
</math>


 is the conjugate transpose of 

<math display="inline" id="Moore–Penrose_pseudoinverse:64">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

),</li>
</ul>

<p>then</p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:65">
<semantics>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>A</mi>
<mi>B</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
</msup>
<mo>≡</mo>
<mrow>
<msup>
<mi>B</mi>
<mo>+</mo>
</msup>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<ci>A</ci>
<ci>B</ci>
</apply>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>B</ci>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (AB)^{+}\equiv B^{+}A^{+}\,\!
  </annotation>
</semantics>
</math>

.</p>

<p>The last property yields the equivalences:</p>

<p>
<math display="inline" id="Moore–Penrose_pseudoinverse:66">
<semantics>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \displaystyle(AA^{*})^{+}
  </annotation>
</semantics>
</math>
</p>
<h3 id="projectors">Projectors</h3>

<p>
<math display="inline" id="Moore–Penrose_pseudoinverse:67">
<semantics>
<mrow>
<mi>P</mi>
<mo>=</mo>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>P</ci>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P=AA^{+}\,\!
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Moore–Penrose_pseudoinverse:68">
<semantics>
<mrow>
<mi>Q</mi>
<mo>=</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>A</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>Q</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>A</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q=A^{+}A\,\!
  </annotation>
</semantics>
</math>

 are <a href="projection_(linear_algebra)" title="wikilink">orthogonal projection operators</a> – that is, they are Hermitian (

<math display="inline" id="Moore–Penrose_pseudoinverse:69">
<semantics>
<mrow>
<mi>P</mi>
<mo>=</mo>
<msup>
<mi>P</mi>
<mo>*</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>P</ci>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P=P^{*}\,\!
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Moore–Penrose_pseudoinverse:70">
<semantics>
<mrow>
<mi>Q</mi>
<mo>=</mo>
<msup>
<mi>Q</mi>
<mo>*</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Q</ci>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q=Q^{*}\,\!
  </annotation>
</semantics>
</math>

) and idempotent (

<math display="inline" id="Moore–Penrose_pseudoinverse:71">
<semantics>
<mrow>
<msup>
<mi>P</mi>
<mn>2</mn>
</msup>
<mo>=</mo>
<mi>P</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>P</ci>
<cn type="integer">2</cn>
</apply>
<ci>P</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P^{2}=P\,\!
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Moore–Penrose_pseudoinverse:72">
<semantics>
<mrow>
<msup>
<mi>Q</mi>
<mn>2</mn>
</msup>
<mo>=</mo>
<mi>Q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Q</ci>
<cn type="integer">2</cn>
</apply>
<ci>Q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q^{2}=Q\,\!
  </annotation>
</semantics>
</math>

). The following hold:</p>
<ul>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:73">
<semantics>
<mrow>
<mrow>
<mi>P</mi>
<mi>A</mi>
</mrow>
<mo>=</mo>
<mi>A</mi>
<mo>=</mo>
<mrow>
<mi>A</mi>
<mi>Q</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>P</ci>
<ci>A</ci>
</apply>
<ci>A</ci>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>A</ci>
<ci>Q</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   PA=A=AQ\,\!
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Moore–Penrose_pseudoinverse:74">
<semantics>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>P</mi>
</mrow>
<mo>=</mo>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<mi>Q</mi>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>P</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}P=A^{+}=QA^{+}\,\!
  </annotation>
</semantics>
</math>
</li>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:75">
<semantics>
<mi>P</mi>
<annotation-xml encoding="MathML-Content">
<ci>P</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   P\,\!
  </annotation>
</semantics>
</math>

 is the <a href="orthogonal_projector" title="wikilink">orthogonal projector</a> onto the <a href="range_(mathematics)" title="wikilink">range</a> of 

<math display="inline" id="Moore–Penrose_pseudoinverse:76">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

 (which equals the <a href="orthogonal_complement" title="wikilink">orthogonal complement</a> of the kernel of 

<math display="inline" id="Moore–Penrose_pseudoinverse:77">
<semantics>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}\,\!
  </annotation>
</semantics>
</math>

).</li>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:78">
<semantics>
<mi>Q</mi>
<annotation-xml encoding="MathML-Content">
<ci>Q</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q\,\!
  </annotation>
</semantics>
</math>

 is the orthogonal projector onto the <a href="range_(mathematics)" title="wikilink">range</a> of 

<math display="inline" id="Moore–Penrose_pseudoinverse:79">
<semantics>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}\,\!
  </annotation>
</semantics>
</math>

 (which equals the <a href="orthogonal_complement" title="wikilink">orthogonal complement</a> of the kernel of 

<math display="inline" id="Moore–Penrose_pseudoinverse:80">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

).</li>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:81">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>I</mi>
<mo>-</mo>
<mi>P</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>I</ci>
<ci>P</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (I-P)\,\!
  </annotation>
</semantics>
</math>

 is the orthogonal projector onto the kernel of 

<math display="inline" id="Moore–Penrose_pseudoinverse:82">
<semantics>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}\,\!
  </annotation>
</semantics>
</math>

.</li>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:83">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>I</mi>
<mo>-</mo>
<mi>Q</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>I</ci>
<ci>Q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (I-Q)\,\!
  </annotation>
</semantics>
</math>

 is the orthogonal projector onto the kernel of 

<math display="inline" id="Moore–Penrose_pseudoinverse:84">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></li>
</ul>
<h3 id="geometric-construction">Geometric construction</h3>

<p>If we view the matrix as a linear map 

<math display="inline" id="Moore–Penrose_pseudoinverse:85">
<semantics>
<mrow>
<mi>A</mi>
<mo>:</mo>
<mrow>
<msup>
<mi>K</mi>
<mi>n</mi>
</msup>
<mo>→</mo>
<msup>
<mi>K</mi>
<mi>m</mi>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>A</ci>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<ci>m</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A:K^{n}\to K^{m}
  </annotation>
</semantics>
</math>

 over a field 

<math display="inline" id="Moore–Penrose_pseudoinverse:86">
<semantics>
<mi>K</mi>
<annotation-xml encoding="MathML-Content">
<ci>K</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   K
  </annotation>
</semantics>
</math>

 then 

<math display="inline" id="Moore–Penrose_pseudoinverse:87">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>:</mo>
<mrow>
<msup>
<mi>K</mi>
<mi>m</mi>
</msup>
<mo>→</mo>
<msup>
<mi>K</mi>
<mi>n</mi>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<ci>m</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}:K^{m}\to K^{n}
  </annotation>
</semantics>
</math>

 can be decomposed as follows. We write 

<math display="inline" id="Moore–Penrose_pseudoinverse:88">
<semantics>
<mo>⊕</mo>
<annotation-xml encoding="MathML-Content">
<csymbol cd="latexml">direct-sum</csymbol>
</annotation-xml>
<annotation encoding="application/x-tex">
   \oplus
  </annotation>
</semantics>
</math>

 for the <a href="Direct_sum_of_modules" title="wikilink">direct sum</a>, 

<math display="inline" id="Moore–Penrose_pseudoinverse:89">
<semantics>
<mo>⟂</mo>
<annotation-xml encoding="MathML-Content">
<csymbol cd="latexml">perpendicular-to</csymbol>
</annotation-xml>
<annotation encoding="application/x-tex">
   \perp
  </annotation>
</semantics>
</math>

 for the <a href="orthogonal_complement" title="wikilink">orthogonal complement</a>, 

<math display="inline" id="Moore–Penrose_pseudoinverse:90">
<semantics>
<mo>ker</mo>
<annotation-xml encoding="MathML-Content">
<ci>ker</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{ker}
  </annotation>
</semantics>
</math>

 for the <a href="Kernel_(linear_algebra)" title="wikilink">kernel</a> of a map, and 

<math display="inline" id="Moore–Penrose_pseudoinverse:91">
<semantics>
<mo>ran</mo>
<annotation-xml encoding="MathML-Content">
<ci>ran</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{ran}
  </annotation>
</semantics>
</math>

 for the <a href="Image_(mathematics)" title="wikilink">image</a> of a map. Notice that 

<math display="inline" id="Moore–Penrose_pseudoinverse:92">
<semantics>
<mrow>
<msup>
<mi>K</mi>
<mi>n</mi>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>ker</mo>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⟂</mo>
</msup>
<mo>⊕</mo>
<mrow>
<mo>ker</mo>
<mi>A</mi>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>ker</ci>
<ci>A</ci>
</apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
<apply>
<ci>ker</ci>
<ci>A</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K^{n}=(\operatorname{ker}A)^{\perp}\oplus\operatorname{ker}A
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Moore–Penrose_pseudoinverse:93">
<semantics>
<mrow>
<msup>
<mi>K</mi>
<mi>m</mi>
</msup>
<mo>=</mo>
<mrow>
<mrow>
<mo>ran</mo>
<mi>A</mi>
</mrow>
<mo>⊕</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>ran</mo>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⟂</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<ci>m</ci>
</apply>
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<ci>ran</ci>
<ci>A</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>ran</ci>
<ci>A</ci>
</apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K^{m}=\operatorname{ran}A\oplus(\operatorname{ran}A)^{\perp}
  </annotation>
</semantics>
</math>

. The restriction 

<math display="inline" id="Moore–Penrose_pseudoinverse:94">
<semantics>
<mrow>
<mi>A</mi>
<mo>:</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>ker</mo>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⟂</mo>
</msup>
<mo>→</mo>
<mrow>
<mo>ran</mo>
<mi>A</mi>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>A</ci>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>ker</ci>
<ci>A</ci>
</apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
<apply>
<ci>ran</ci>
<ci>A</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A:(\operatorname{ker}A)^{\perp}\to\operatorname{ran}A
  </annotation>
</semantics>
</math>

 is then an isomorphism. These imply that 

<math display="inline" id="Moore–Penrose_pseudoinverse:95">
<semantics>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}
  </annotation>
</semantics>
</math>

 is defined on 

<math display="inline" id="Moore–Penrose_pseudoinverse:96">
<semantics>
<mrow>
<mo>ran</mo>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>ran</ci>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{ran}A
  </annotation>
</semantics>
</math>

 to be the inverse of this isomorphism, and on 

<math display="inline" id="Moore–Penrose_pseudoinverse:97">
<semantics>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>ran</mo>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⟂</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>ran</ci>
<ci>A</ci>
</apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\operatorname{ran}A)^{\perp}
  </annotation>
</semantics>
</math>

 to be zero.</p>

<p>In other words: To find 

<math display="inline" id="Moore–Penrose_pseudoinverse:98">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>b</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}b
  </annotation>
</semantics>
</math>

 for given 

<math display="inline" id="Moore–Penrose_pseudoinverse:99">
<semantics>
<mi>b</mi>
<annotation-xml encoding="MathML-Content">
<ci>b</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   b
  </annotation>
</semantics>
</math>

 in <mtpl></mtpl>, first project 

<math display="inline" id="Moore–Penrose_pseudoinverse:100">
<semantics>
<mi>b</mi>
<annotation-xml encoding="MathML-Content">
<ci>b</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   b
  </annotation>
</semantics>
</math>

 orthogonally onto the range of 

<math display="inline" id="Moore–Penrose_pseudoinverse:101">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

, finding a point 

<math display="inline" id="Moore–Penrose_pseudoinverse:102">
<semantics>
<mrow>
<mi>p</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>p</ci>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p(b)
  </annotation>
</semantics>
</math>

 in the range. Then form , i.e. find those vectors in <mtpl></mtpl> that 

<math display="inline" id="Moore–Penrose_pseudoinverse:103">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 sends to 

<math display="inline" id="Moore–Penrose_pseudoinverse:104">
<semantics>
<mrow>
<mi>p</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>p</ci>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p(b)
  </annotation>
</semantics>
</math>

. This will be an affine subspace of <mtpl></mtpl> parallel to the kernel of 

<math display="inline" id="Moore–Penrose_pseudoinverse:105">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

. The element of this subspace that has the smallest length (i.e. is closest to the origin) is the answer 

<math display="inline" id="Moore–Penrose_pseudoinverse:106">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>b</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}b
  </annotation>
</semantics>
</math>

 we are looking for. It can be found by taking an arbitrary member of  and projecting it orthogonally onto the orthogonal complement of the kernel of 

<math display="inline" id="Moore–Penrose_pseudoinverse:107">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

.</p>

<p>This description is closely related to the <a href="Moore–Penrose_pseudoinverse#Minimum_norm_solution_to_a_linear_system" title="wikilink">Minimum norm solution to a linear system</a>.</p>
<h3 id="subspaces">Subspaces</h3>

<p>
<math display="inline" id="Moore–Penrose_pseudoinverse:108">
<semantics>
<mrow>
<mo>ker</mo>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>ker</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \displaystyle\operatorname{ker}(A^{+})
  </annotation>
</semantics>
</math>
</p>
<h3 id="limit-relations">Limit relations</h3>
<ul>
<li>The pseudoinverse are limits:</li>
</ul>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:109">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>δ</mi>
<mo>↘</mo>
<mn>0</mn>
</mrow>
</munder>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>δ</mi>
<mi>I</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>δ</mi>
<mo>↘</mo>
<mn>0</mn>
</mrow>
</munder>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<mo>+</mo>
<mrow>
<mi>δ</mi>
<mi>I</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-↘</ci>
<ci>δ</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<times></times>
<ci>δ</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-↘</ci>
<ci>δ</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
<apply>
<times></times>
<ci>δ</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=\lim_{\delta\searrow 0}(A^{*}A+\delta I)^{-1}A^{*}=\lim_{\delta\searrow 0%
}A^{*}(AA^{*}+\delta I)^{-1}
  </annotation>
</semantics>
</math>
</p>
<dl>
<dd>(see <a href="Tikhonov_regularization" title="wikilink">Tikhonov regularization</a>). These limits exist even if 

<math display="inline" id="Moore–Penrose_pseudoinverse:110">
<semantics>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (AA^{*})^{-1}\,\!
  </annotation>
</semantics>
</math>

 or 

<math display="inline" id="Moore–Penrose_pseudoinverse:111">
<semantics>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (A^{*}A)^{-1}\,\!
  </annotation>
</semantics>
</math>

 do not exist.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a>
</dd>
</dl>
<h3 id="continuity">Continuity</h3>
<ul>
<li>In contrast to ordinary matrix inversion, the process of taking pseudoinverses is not <a href="continuous_function" title="wikilink">continuous</a>: if the sequence 

<math display="inline" id="Moore–Penrose_pseudoinverse:112">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>A</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (A_{n})
  </annotation>
</semantics>
</math>

 converges to the matrix 

<math display="inline" id="Moore–Penrose_pseudoinverse:113">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 (in the <a href="matrix_norm" title="wikilink">maximum norm or Frobenius norm</a>, say), then <mtpl></mtpl> need not converge to <mtpl></mtpl>. However, if all the matrices have the same rank, <mtpl></mtpl> will converge to <mtpl></mtpl>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
</ul>
<h3 id="derivative">Derivative</h3>

<p>The derivative of a real valued pseudoinverse matrix which has constant rank at a point 

<math display="inline" id="Moore–Penrose_pseudoinverse:114">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 may be calculated in terms of the derivative of the original matrix:<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:115">
<semantics>
<mrow>
<mrow>
<mfrac>
<mi mathvariant="normal">d</mi>
<mrow>
<mi mathvariant="normal">d</mi>
<mi>x</mi>
</mrow>
</mfrac>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo>-</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mrow>
<mo>(</mo>
<mrow>
<mfrac>
<mi mathvariant="normal">d</mi>
<mrow>
<mi mathvariant="normal">d</mi>
<mi>x</mi>
</mrow>
</mfrac>
<mi>A</mi>
</mrow>
<mo>)</mo>
</mrow>
<mpadded width="+3.3pt">
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mpadded>
</mrow>
</mrow>
<mo rspace="5.8pt">+</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<msup>
<mi>A</mi>
<mrow>
<mo>+</mo>
<mtext>T</mtext>
</mrow>
</msup>
<mrow>
<mo>(</mo>
<mrow>
<mfrac>
<mi mathvariant="normal">d</mi>
<mrow>
<mi mathvariant="normal">d</mi>
<mi>x</mi>
</mrow>
</mfrac>
<msup>
<mi>A</mi>
<mtext>T</mtext>
</msup>
</mrow>
<mo>)</mo>
</mrow>
<mrow>
<mo>(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
</mrow>
<mo rspace="5.8pt">)</mo>
</mrow>
</mrow>
<mo rspace="5.8pt">+</mo>
<mrow>
<mrow>
<mo>(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>A</mi>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mrow>
<mo>(</mo>
<mrow>
<mfrac>
<mtext>d</mtext>
<mrow>
<mtext>d</mtext>
<mi>x</mi>
</mrow>
</mfrac>
<msup>
<mi>A</mi>
<mtext>T</mtext>
</msup>
</mrow>
<mo>)</mo>
</mrow>
<msup>
<mi>A</mi>
<mrow>
<mo>+</mo>
<mtext>T</mtext>
</mrow>
</msup>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<divide></divide>
<ci>normal-d</ci>
<apply>
<times></times>
<ci>normal-d</ci>
<ci>x</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>x</ci>
</apply>
<apply>
<plus></plus>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<ci>normal-d</ci>
<apply>
<times></times>
<ci>normal-d</ci>
<ci>x</ci>
</apply>
</apply>
<ci>A</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<apply>
<plus></plus>
<mtext>T</mtext>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<ci>normal-d</ci>
<apply>
<times></times>
<ci>normal-d</ci>
<ci>x</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<mtext>T</mtext>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>A</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<mtext>d</mtext>
<apply>
<times></times>
<mtext>d</mtext>
<ci>x</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<mtext>T</mtext>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<apply>
<plus></plus>
<mtext>T</mtext>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{\mathrm{d}}{\mathrm{d}x}A^{+}(x)=-A^{+}\left(\frac{\mathrm{d}}{\mathrm{d%
}x}A\right)A^{+}~{}+~{}A^{+}A^{+\text{T}}\left(\frac{\mathrm{d}}{\mathrm{d}x}A%
^{\text{T}}\right)\left(1-AA^{+}\right)~{}+~{}\left(1-A^{+}A\right)\left(\frac%
{\text{d}}{\text{d}x}A^{\text{T}}\right)A^{+\text{T}}A^{+}
  </annotation>
</semantics>
</math>
</p>
<h2 id="special-cases">Special cases</h2>
<h3 id="scalars">Scalars</h3>

<p>It is also possible to define a pseudoinverse for scalars and vectors. This amounts to treating these as matrices. The pseudoinverse of a scalar 

<math display="inline" id="Moore–Penrose_pseudoinverse:116">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 is zero if 

<math display="inline" id="Moore–Penrose_pseudoinverse:117">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 is zero and the reciprocal of 

<math display="inline" id="Moore–Penrose_pseudoinverse:118">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 otherwise:</p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:119">
<semantics>
<mrow>
<msup>
<mi>x</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<mo>{</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mrow>
<mn>0</mn>
<mo>,</mo>
</mrow>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mrow>
<mtext>if</mtext>
<mi>x</mi>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mo>;</mo>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<msup>
<mi>x</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>,</mo>
</mrow>
</mtd>
<mtd columnalign="center">
<mrow>
<mtext>otherwise</mtext>
<mo>.</mo>
</mrow>
</mtd>
</mtr>
</mtable>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<plus></plus>
</apply>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-{</ci>
<matrix>
<matrixrow>
<cn type="integer">0</cn>
<apply>
<eq></eq>
<apply>
<times></times>
<mtext>if</mtext>
<ci>x</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</matrixrow>
<matrixrow>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<mtext>otherwise</mtext>
</matrixrow>
</matrix>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   x^{+}=\left\{\begin{matrix}0,&amp;\mbox{if }x=0;\\
x^{-1},&amp;\mbox{otherwise}.\end{matrix}\right.
  </annotation>
</semantics>
</math>
</p>
<h3 id="vectors">Vectors</h3>

<p>The pseudoinverse of the null (all zero) vector is the transposed null vector. The pseudoinverse of a non-null vector is the conjugate transposed vector divided by its squared magnitude:</p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:120">
<semantics>
<mrow>
<msup>
<mi>x</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<mo>{</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mrow>
<msup>
<mn>0</mn>
<mi mathvariant="normal">T</mi>
</msup>
<mo>,</mo>
</mrow>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mrow>
<mtext>if</mtext>
<mi>x</mi>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mo>;</mo>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mstyle displaystyle="false">
<mfrac>
<msup>
<mi>x</mi>
<mo>*</mo>
</msup>
<mrow>
<msup>
<mi>x</mi>
<mo>*</mo>
</msup>
<mi>x</mi>
</mrow>
</mfrac>
</mstyle>
<mo>,</mo>
</mrow>
</mtd>
<mtd columnalign="center">
<mrow>
<mtext>otherwise</mtext>
<mo>.</mo>
</mrow>
</mtd>
</mtr>
</mtable>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<plus></plus>
</apply>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-{</ci>
<matrix>
<matrixrow>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">0</cn>
<ci>normal-T</ci>
</apply>
<apply>
<eq></eq>
<apply>
<times></times>
<mtext>if</mtext>
<ci>x</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</matrixrow>
<matrixrow>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<times></times>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<times></times>
</apply>
<ci>x</ci>
</apply>
</apply>
<mtext>otherwise</mtext>
</matrixrow>
</matrix>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   x^{+}=\left\{\begin{matrix}0^{\mathrm{T}},&amp;\mbox{if }x=0;\\
{x^{*}\over x^{*}x},&amp;\mbox{otherwise}.\end{matrix}\right.
  </annotation>
</semantics>
</math>
</p>
<h3 id="linearly-independent-columns">Linearly independent columns</h3>

<p>If the <strong>columns</strong> of 

<math display="inline" id="Moore–Penrose_pseudoinverse:121">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

 are <a href="linear_independence" title="wikilink">linearly independent</a> (so that 

<math display="inline" id="Moore–Penrose_pseudoinverse:122">
<semantics>
<mrow>
<mi>m</mi>
<mo>≥</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<geq></geq>
<ci>m</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   m\geq n
  </annotation>
</semantics>
</math>

), then 

<math display="inline" id="Moore–Penrose_pseudoinverse:123">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}A\,\!
  </annotation>
</semantics>
</math>

 is invertible. In this case, an explicit formula is:<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:124">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=(A^{*}A)^{-1}A^{*}\,\!
  </annotation>
</semantics>
</math>

. It follows that 

<math display="inline" id="Moore–Penrose_pseudoinverse:125">
<semantics>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}\,\!
  </annotation>
</semantics>
</math>

 is then a left inverse of 

<math display="inline" id="Moore–Penrose_pseudoinverse:126">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

:   

<math display="inline" id="Moore–Penrose_pseudoinverse:127">
<semantics>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>A</mi>
</mrow>
<mo>=</mo>
<msub>
<mi>I</mi>
<mi>n</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>A</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}A=I_{n}\,\!
  </annotation>
</semantics>
</math>

.</p>
<h3 id="linearly-independent-rows">Linearly independent rows</h3>

<p>If the <strong>rows</strong> of 

<math display="inline" id="Moore–Penrose_pseudoinverse:128">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

 are linearly independent (so that 

<math display="inline" id="Moore–Penrose_pseudoinverse:129">
<semantics>
<mrow>
<mi>m</mi>
<mo>≤</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<ci>m</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   m\leq n
  </annotation>
</semantics>
</math>

), then 

<math display="inline" id="Moore–Penrose_pseudoinverse:130">
<semantics>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   AA^{*}
  </annotation>
</semantics>
</math>

 is invertible. In this case, an explicit formula is:</p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:131">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=A^{*}(AA^{*})^{-1}\,\!
  </annotation>
</semantics>
</math>

. It follows that 

<math display="inline" id="Moore–Penrose_pseudoinverse:132">
<semantics>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}\,\!
  </annotation>
</semantics>
</math>

 is a right inverse of 

<math display="inline" id="Moore–Penrose_pseudoinverse:133">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

:   

<math display="inline" id="Moore–Penrose_pseudoinverse:134">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
<mo>=</mo>
<msub>
<mi>I</mi>
<mi>m</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>m</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   AA^{+}=I_{m}\,\!
  </annotation>
</semantics>
</math>

.</p>
<h3 id="orthonormal-columns-or-rows">Orthonormal columns or rows</h3>

<p>This is a special case of either full column rank or full row rank (treated above). If 

<math display="inline" id="Moore–Penrose_pseudoinverse:135">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

 has orthonormal columns (

<math display="inline" id="Moore–Penrose_pseudoinverse:136">
<semantics>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<mo>=</mo>
<msub>
<mi>I</mi>
<mi>n</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}A=I_{n}\,\!
  </annotation>
</semantics>
</math>

) or orthonormal rows (

<math display="inline" id="Moore–Penrose_pseudoinverse:137">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<mo>=</mo>
<msub>
<mi>I</mi>
<mi>m</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>m</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   AA^{*}=I_{m}\,\!
  </annotation>
</semantics>
</math>

), then 

<math display="inline" id="Moore–Penrose_pseudoinverse:138">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=A^{*}\,\!
  </annotation>
</semantics>
</math>

.</p>
<h3 id="circulant-matrices">Circulant matrices</h3>

<p>For a <a href="circulant_matrix" title="wikilink">circulant matrix</a>
<math display="inline" id="Moore–Penrose_pseudoinverse:139">
<semantics>
<mi>C</mi>
<annotation-xml encoding="MathML-Content">
<ci>C</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   C\,\!
  </annotation>
</semantics>
</math>

, the singular value decomposition is given by the <a href="Fourier_transform" title="wikilink">Fourier transform</a>, that is the singular values are the Fourier coefficients. Let 

<math display="inline" id="Moore–Penrose_pseudoinverse:140">
<semantics>
<mi class="ltx_font_mathcaligraphic">ℱ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℱ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
</semantics>
</math>

 be the <a href="DFT_matrix" title="wikilink">Discrete Fourier Transform (DFT) matrix</a>, then<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>
<math display="inline" id="Moore–Penrose_pseudoinverse:141">
<semantics>
<mi>C</mi>
<annotation-xml encoding="MathML-Content">
<ci>C</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \displaystyle C
  </annotation>
</semantics>
</math>
</p>
<h2 id="construction">Construction</h2>
<h3 id="rank-decomposition">Rank decomposition</h3>

<p>Let 

<math display="inline" id="Moore–Penrose_pseudoinverse:142">
<semantics>
<mrow>
<mi>r</mi>
<mo>≤</mo>
<mrow>
<mi>min</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<ci>r</ci>
<apply>
<min></min>
<ci>m</ci>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r\leq\min(m,n)
  </annotation>
</semantics>
</math>

 denote the <a href="rank_(matrix_theory)" title="wikilink">rank</a> of 

<math display="inline" id="Moore–Penrose_pseudoinverse:143">
<semantics>
<mrow>
<mi>A</mi>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>n</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>A</ci>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>m</ci>
<ci>n</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\in\mathrm{M}(m,n;K)\,\!
  </annotation>
</semantics>
</math>

. Then 

<math display="inline" id="Moore–Penrose_pseudoinverse:144">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

 can be <a href="rank_factorization" title="wikilink">(rank) decomposed</a> as 

<math display="inline" id="Moore–Penrose_pseudoinverse:145">
<semantics>
<mrow>
<mi>A</mi>
<mo>=</mo>
<mrow>
<mi>B</mi>
<mi>C</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>A</ci>
<apply>
<times></times>
<ci>B</ci>
<ci>C</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A=BC\,\!
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Moore–Penrose_pseudoinverse:146">
<semantics>
<mrow>
<mi>B</mi>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>r</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>B</ci>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>m</ci>
<ci>r</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   B\in\mathrm{M}(m,r;K)\,\!
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Moore–Penrose_pseudoinverse:147">
<semantics>
<mrow>
<mi>C</mi>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>r</mi>
<mo>,</mo>
<mi>n</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>C</ci>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>r</ci>
<ci>n</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C\in\mathrm{M}(r,n;K)\,\!
  </annotation>
</semantics>
</math>

 are of rank 

<math display="inline" id="Moore–Penrose_pseudoinverse:148">
<semantics>
<mi>r</mi>
<annotation-xml encoding="MathML-Content">
<ci>r</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   r
  </annotation>
</semantics>
</math>

. Then 

<math display="inline" id="Moore–Penrose_pseudoinverse:149">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mi>C</mi>
<mo>+</mo>
</msup>
<msup>
<mi>B</mi>
<mo>+</mo>
</msup>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi>C</mi>
<mo>*</mo>
</msup>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>C</mi>
<msup>
<mi>C</mi>
<mo>*</mo>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>B</mi>
<mo>*</mo>
</msup>
<mi>B</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<msup>
<mi>B</mi>
<mo>*</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>C</ci>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>B</ci>
<plus></plus>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>C</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<ci>C</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>C</ci>
<times></times>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>B</ci>
<times></times>
</apply>
<ci>B</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>B</ci>
<times></times>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=C^{+}B^{+}=C^{*}(CC^{*})^{-1}(B^{*}B)^{-1}B^{*}\,\!
  </annotation>
</semantics>
</math>

.</p>
<h3 id="the-qr-method">The QR method</h3>

<p>For 

<math display="inline" id="Moore–Penrose_pseudoinverse:150">
<semantics>
<mrow>
<mi>K</mi>
<mo>=</mo>
<mi>ℝ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>K</ci>
<ci>ℝ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K=\mathbb{R}\,\!
  </annotation>
</semantics>
</math>

 or 

<math display="inline" id="Moore–Penrose_pseudoinverse:151">
<semantics>
<mrow>
<mi>K</mi>
<mo>=</mo>
<mi>ℂ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>K</ci>
<ci>ℂ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K=\mathbb{C}\,\!
  </annotation>
</semantics>
</math>

 computing the product 

<math display="inline" id="Moore–Penrose_pseudoinverse:152">
<semantics>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   AA^{*}
  </annotation>
</semantics>
</math>

 or 

<math display="inline" id="Moore–Penrose_pseudoinverse:153">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}A
  </annotation>
</semantics>
</math>

 and their inverses explicitly is often a source of numerical rounding errors and computational cost in practice. An alternative approach using the <a href="QR_decomposition" title="wikilink">QR decomposition</a> of 

<math display="inline" id="Moore–Penrose_pseudoinverse:154">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

 may be used instead.</p>

<p>Considering the case when 

<math display="inline" id="Moore–Penrose_pseudoinverse:155">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\,\!
  </annotation>
</semantics>
</math>

 is of full column rank, so that 

<math display="inline" id="Moore–Penrose_pseudoinverse:156">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=(A^{*}A)^{-1}A^{*}\,\!
  </annotation>
</semantics>
</math>

. Then the <a href="Cholesky_decomposition" title="wikilink">Cholesky decomposition</a>
<math display="inline" id="Moore–Penrose_pseudoinverse:157">
<semantics>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi>R</mi>
<mo>*</mo>
</msup>
<mi>R</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>R</ci>
<times></times>
</apply>
<ci>R</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}A=R^{*}R\,\!
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Moore–Penrose_pseudoinverse:158">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R\,\!
  </annotation>
</semantics>
</math>

 is an <a href="upper_triangular_matrix" title="wikilink">upper triangular matrix</a>, may be used. Multiplication by the inverse is then done easily by solving a system with multiple right-hand sides,</p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:159">
<semantics>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<mo>⇔</mo>
</mrow>
</mrow>
<mrow>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mo>⇔</mo>
</mrow>
</mrow>
<mrow>
<mrow>
<msup>
<mi>R</mi>
<mo>*</mo>
</msup>
<mi>R</mi>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
</mrow>
<mo>=</mo>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<list>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
<ci>normal-⇔</ci>
</list>
</apply>
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
<list>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>normal-⇔</ci>
</list>
</apply>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>R</ci>
<times></times>
</apply>
<ci>R</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=(A^{*}A)^{-1}A^{*}\quad\Leftrightarrow\quad(A^{*}A)A^{+}=A^{*}\quad%
\Leftrightarrow\quad R^{*}RA^{+}=A^{*}
  </annotation>
</semantics>
</math>

 which may be solved by <a href="forward_substitution" title="wikilink">forward substitution</a> followed by <a href="back_substitution" title="wikilink">back substitution</a>.</p>

<p>The Cholesky decomposition may be computed without forming 

<math display="inline" id="Moore–Penrose_pseudoinverse:160">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}A\,\!
  </annotation>
</semantics>
</math>

 explicitly, by alternatively using the <a href="QR_decomposition" title="wikilink">QR decomposition</a> of 

<math display="inline" id="Moore–Penrose_pseudoinverse:161">
<semantics>
<mrow>
<mi>A</mi>
<mo>=</mo>
<mrow>
<mi>Q</mi>
<mi>R</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>A</ci>
<apply>
<times></times>
<ci>Q</ci>
<ci>R</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A=QR\,\!
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Moore–Penrose_pseudoinverse:162">
<semantics>
<mpadded width="+1.7pt">
<mi>Q</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>Q</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q\,\,\!
  </annotation>
</semantics>
</math>

 has orthonormal columns, 

<math display="inline" id="Moore–Penrose_pseudoinverse:163">
<semantics>
<mrow>
<mrow>
<msup>
<mi>Q</mi>
<mo>*</mo>
</msup>
<mi>Q</mi>
</mrow>
<mo>=</mo>
<mi>I</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Q</ci>
<times></times>
</apply>
<ci>Q</ci>
</apply>
<ci>I</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q^{*}Q=I
  </annotation>
</semantics>
</math>

, and 

<math display="inline" id="Moore–Penrose_pseudoinverse:164">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R\,\!
  </annotation>
</semantics>
</math>

 is upper triangular. Then</p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:165">
<semantics>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mpadded width="+1.7pt">
<mi>A</mi>
</mpadded>
</mrow>
<mo rspace="4.2pt">=</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>Q</mi>
<mi>R</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>*</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>Q</mi>
<mi>R</mi>
</mrow>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
<mo rspace="4.2pt">=</mo>
<mrow>
<msup>
<mi>R</mi>
<mo>*</mo>
</msup>
<msup>
<mi>Q</mi>
<mo>*</mo>
</msup>
<mi>Q</mi>
<mpadded width="+1.7pt">
<mi>R</mi>
</mpadded>
</mrow>
<mo rspace="4.2pt">=</mo>
<mrow>
<msup>
<mi>R</mi>
<mo>*</mo>
</msup>
<mi>R</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<ci>Q</ci>
<ci>R</ci>
</apply>
<times></times>
</apply>
<apply>
<times></times>
<ci>Q</ci>
<ci>R</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>R</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Q</ci>
<times></times>
</apply>
<ci>Q</ci>
<ci>R</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>R</ci>
<times></times>
</apply>
<ci>R</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}A\,=\,(QR)^{*}(QR)\,=\,R^{*}Q^{*}QR\,=\,R^{*}R
  </annotation>
</semantics>
</math>

, so 

<math display="inline" id="Moore–Penrose_pseudoinverse:166">
<semantics>
<mi>R</mi>
<annotation-xml encoding="MathML-Content">
<ci>R</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   R
  </annotation>
</semantics>
</math>

 is the Cholesky factor of 

<math display="inline" id="Moore–Penrose_pseudoinverse:167">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}A
  </annotation>
</semantics>
</math>

.</p>

<p>The case of full row rank is treated similarly by using the formula 

<math display="inline" id="Moore–Penrose_pseudoinverse:168">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=A^{*}(AA^{*})^{-1}\,\!
  </annotation>
</semantics>
</math>

 and using a similar argument, swapping the roles of 

<math display="inline" id="Moore–Penrose_pseudoinverse:169">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Moore–Penrose_pseudoinverse:170">
<semantics>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}
  </annotation>
</semantics>
</math>

.</p>
<h3 id="singular-value-decomposition-svd">Singular value decomposition (SVD)</h3>

<p>A computationally simple and accurate way to compute the pseudo inverse is by using the <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> If 

<math display="inline" id="Moore–Penrose_pseudoinverse:171">
<semantics>
<mrow>
<mi>A</mi>
<mo>=</mo>
<mrow>
<mi>U</mi>
<mi mathvariant="normal">Σ</mi>
<msup>
<mi>V</mi>
<mo>*</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>A</ci>
<apply>
<times></times>
<ci>U</ci>
<ci>normal-Σ</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>V</ci>
<times></times>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A=U\Sigma V^{*}
  </annotation>
</semantics>
</math>

 is the singular value decomposition of 

<math display="inline" id="Moore–Penrose_pseudoinverse:172">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

, then 

<math display="inline" id="Moore–Penrose_pseudoinverse:173">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mrow>
<mi>V</mi>
<msup>
<mi mathvariant="normal">Σ</mi>
<mo>+</mo>
</msup>
<msup>
<mi>U</mi>
<mo>*</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<ci>V</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Σ</ci>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>U</ci>
<times></times>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{+}=V\Sigma^{+}U^{*}
  </annotation>
</semantics>
</math>

. For a <a href="rectangular_diagonal_matrix" title="wikilink">rectangular diagonal matrix</a> such as 

<math display="inline" id="Moore–Penrose_pseudoinverse:174">
<semantics>
<mi mathvariant="normal">Σ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Σ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Sigma
  </annotation>
</semantics>
</math>

, we get the pseudo inverse by taking the reciprocal of each non-zero element on the diagonal, leaving the zeros in place, and then transposing the matrix. In numerical computation, only elements larger than some small tolerance are taken to be nonzero, and the others are replaced by zeros. For example, in the <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>, <a href="GNU_Octave" title="wikilink">GNU Octave</a>, or <a class="uri" href="NumPy" title="wikilink">NumPy</a> function <code>pinv</code>, the tolerance is taken to be 

<math display="inline" id="Moore–Penrose_pseudoinverse:175">
<semantics>
<mrow>
<mi>t</mi>
<mo>=</mo>
<mrow>
<mi>ε</mi>
<mi mathvariant="normal">⋅</mi>
<mi>m</mi>
<mi>a</mi>
<mi>x</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">⋅</mi>
<mi>m</mi>
<mi>a</mi>
<mi>x</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Σ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>t</ci>
<apply>
<times></times>
<ci>ε</ci>
<ci>normal-⋅</ci>
<ci>m</ci>
<ci>a</ci>
<ci>x</ci>
<interval closure="open">
<ci>m</ci>
<ci>n</ci>
</interval>
<ci>normal-⋅</ci>
<ci>m</ci>
<ci>a</ci>
<ci>x</ci>
<ci>normal-Σ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   t=ε⋅max(m,n)⋅max(Σ)
  </annotation>
</semantics>
</math>

, where ε is the <a href="machine_epsilon" title="wikilink">machine epsilon</a>.</p>

<p>The computational cost of this method is dominated by the cost of computing the SVD, which is several times higher than matrix–matrix multiplication, even if a state-of-the art implementation (such as that of <a class="uri" href="LAPACK" title="wikilink">LAPACK</a>) is used.</p>

<p>The above procedure shows why taking the pseudo inverse is not a continuous operation: if the original matrix 

<math display="inline" id="Moore–Penrose_pseudoinverse:176">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 has a singular value 0 (a diagonal entry of the matrix 

<math display="inline" id="Moore–Penrose_pseudoinverse:177">
<semantics>
<mi mathvariant="normal">Σ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Σ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Sigma
  </annotation>
</semantics>
</math>

 above), then modifying 

<math display="inline" id="Moore–Penrose_pseudoinverse:178">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 slightly may turn this zero into a tiny positive number, thereby affecting the pseudo inverse dramatically as we now have to take the reciprocal of a tiny number.</p>
<h3 id="block-matrices">Block matrices</h3>

<p><a href="Block_matrix_pseudoinverse" title="wikilink">Optimized approaches</a> exist for calculating the pseudoinverse of block structured matrices.</p>
<h3 id="the-iterative-method-of-ben-israel-and-cohen">The iterative method of Ben-Israel and Cohen</h3>

<p>Another method for computing the pseudoinverse uses the recursion</p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:179">
<semantics>
<mrow>
<mrow>
<msub>
<mi>A</mi>
<mrow>
<mi>i</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mrow>
<mn>2</mn>
<msub>
<mi>A</mi>
<mi>i</mi>
</msub>
</mrow>
<mo>-</mo>
<mrow>
<msub>
<mi>A</mi>
<mi>i</mi>
</msub>
<mi>A</mi>
<msub>
<mi>A</mi>
<mi>i</mi>
</msub>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<apply>
<plus></plus>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<ci>i</ci>
</apply>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A_{i+1}=2A_{i}-A_{i}AA_{i},\,
  </annotation>
</semantics>
</math>

 which is sometimes referred to as hyper-power sequence. This recursion produces a sequence converging quadratically to the pseudoinverse of 

<math display="inline" id="Moore–Penrose_pseudoinverse:180">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 if it is started with an appropriate 

<math display="inline" id="Moore–Penrose_pseudoinverse:181">
<semantics>
<msub>
<mi>A</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A_{0}
  </annotation>
</semantics>
</math>

 satisfying 

<math display="inline" id="Moore–Penrose_pseudoinverse:182">
<semantics>
<mrow>
<mrow>
<msub>
<mi>A</mi>
<mn>0</mn>
</msub>
<mi>A</mi>
</mrow>
<mo>=</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>A</mi>
<mn>0</mn>
</msub>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>*</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<cn type="integer">0</cn>
</apply>
<ci>A</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<cn type="integer">0</cn>
</apply>
<ci>A</ci>
</apply>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A_{0}A=(A_{0}A)^{*}
  </annotation>
</semantics>
</math>

. The choice 

<math display="inline" id="Moore–Penrose_pseudoinverse:183">
<semantics>
<mrow>
<msub>
<mi>A</mi>
<mn>0</mn>
</msub>
<mo>=</mo>
<mrow>
<mi>α</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<times></times>
<ci>α</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A_{0}=\alpha A^{*}
  </annotation>
</semantics>
</math>

 (where 

<math display="inline" id="Moore–Penrose_pseudoinverse:184">
<semantics>
<mrow>
<mn>0</mn>
<mo>&lt;</mo>
<mi>α</mi>
<mo>&lt;</mo>
<mrow>
<mrow>
<mn>2</mn>
<mo>/</mo>
<msubsup>
<mi>σ</mi>
<mn>1</mn>
<mn>2</mn>
</msubsup>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>A</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<lt></lt>
<cn type="integer">0</cn>
<ci>α</ci>
</apply>
<apply>
<lt></lt>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>σ</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>A</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   0&lt;\alpha&lt;2/\sigma^{2}_{1}(A)
  </annotation>
</semantics>
</math>

, with 

<math display="inline" id="Moore–Penrose_pseudoinverse:185">
<semantics>
<mrow>
<msub>
<mi>σ</mi>
<mn>1</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>A</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>σ</ci>
<cn type="integer">1</cn>
</apply>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sigma_{1}(A)
  </annotation>
</semantics>
</math>

 denoting the largest singular value of 

<math display="inline" id="Moore–Penrose_pseudoinverse:186">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

) <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> has been argued not to be competitive to the method using the SVD mentioned above, because even for moderately ill-conditioned matrices it takes a long time before 

<math display="inline" id="Moore–Penrose_pseudoinverse:187">
<semantics>
<msub>
<mi>A</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A_{i}
  </annotation>
</semantics>
</math>

 enters the region of quadratic convergence.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> However, if started with 

<math display="inline" id="Moore–Penrose_pseudoinverse:188">
<semantics>
<msub>
<mi>A</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A_{0}
  </annotation>
</semantics>
</math>

 already close to the Moore–Penrose pseudoinverse and 

<math display="inline" id="Moore–Penrose_pseudoinverse:189">
<semantics>
<mrow>
<mrow>
<msub>
<mi>A</mi>
<mn>0</mn>
</msub>
<mi>A</mi>
</mrow>
<mo>=</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>A</mi>
<mn>0</mn>
</msub>
<mi>A</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>*</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<cn type="integer">0</cn>
</apply>
<ci>A</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<cn type="integer">0</cn>
</apply>
<ci>A</ci>
</apply>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A_{0}A=(A_{0}A)^{*}
  </annotation>
</semantics>
</math>

, for example 

<math display="inline" id="Moore–Penrose_pseudoinverse:190">
<semantics>
<mrow>
<msub>
<mi>A</mi>
<mn>0</mn>
</msub>
<mo>:=</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>δ</mi>
<mi>I</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">assign</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
<apply>
<times></times>
<ci>δ</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A_{0}:=(A^{*}A+\delta I)^{-1}A^{*}
  </annotation>
</semantics>
</math>

, convergence is fast (quadratic).</p>
<h3 id="updating-the-pseudoinverse">Updating the pseudoinverse</h3>

<p>For the cases where 

<math display="inline" id="Moore–Penrose_pseudoinverse:191">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 has full row or column rank, and the inverse of the correlation matrix (

<math display="inline" id="Moore–Penrose_pseudoinverse:192">
<semantics>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   AA^{*}
  </annotation>
</semantics>
</math>

 for 

<math display="inline" id="Moore–Penrose_pseudoinverse:193">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 with full row rank or 

<math display="inline" id="Moore–Penrose_pseudoinverse:194">
<semantics>
<mrow>
<msup>
<mi>A</mi>
<mo>*</mo>
</msup>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<times></times>
</apply>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A^{*}A
  </annotation>
</semantics>
</math>

 for full column rank) is already known, the pseudoinverse for matrices related to 

<math display="inline" id="Moore–Penrose_pseudoinverse:195">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 can be computed by applying the <a href="Sherman–Morrison–Woodbury_formula" title="wikilink">Sherman–Morrison–Woodbury formula</a> to update the inverse of the correlation matrix, which may need less work. In particular, if the related matrix differs from the original one by only a changed, added or deleted row or column, incremental algorithms<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> exist that exploit the relationship.</p>

<p>Similarly, it is possible to update the Cholesky factor when a row or column is added, without creating the inverse of the correlation matrix explicitly. However, updating the pseudoinverse in the general rank-deficient case is much more complicated.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h3 id="software-libraries">Software libraries</h3>

<p>The package <a class="uri" href="NumPy" title="wikilink">NumPy</a> provides a pseudoinverse calculation through its functions <code>matrix.I</code> and <code>linalg.pinv</code>; its <code>pinv</code> uses the SVD-based algorithm. <a class="uri" href="SciPy" title="wikilink">SciPy</a> adds a function <code>scipy.linalg.pinv</code> that uses a least-squares solver. High quality implementations of SVD, QR, and back substitution are available in <a href="Singular_value_decomposition#Implementations" title="wikilink">standard libraries</a>, such as <a class="uri" href="LAPACK" title="wikilink">LAPACK</a>. Writing one's own implementation of SVD is a major programming project that requires a significant <a href="Floating_point#Accuracy_problems" title="wikilink">numerical expertise</a>. In special circumstances, such as <a href="parallel_computing" title="wikilink">parallel computing</a> or <a href="embedded_computing" title="wikilink">embedded computing</a>, however, alternative implementations by QR or even the use of an explicit inverse might be preferable, and custom implementations may be unavoidable.</p>
<h2 id="applications">Applications</h2>
<h3 id="linear-least-squares">Linear least-squares</h3>

<p>The pseudoinverse provides a <a href="linear_least_squares_(mathematics)" title="wikilink">least squares</a> solution to a <a href="system_of_linear_equations" title="wikilink">system of linear equations</a>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> For 

<math display="inline" id="Moore–Penrose_pseudoinverse:196">
<semantics>
<mrow>
<mi>A</mi>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>n</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>A</ci>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>m</ci>
<ci>n</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\in\mathrm{M}(m,n;K)\,\!
  </annotation>
</semantics>
</math>

, given a system of linear equations</p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:197">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>A</mi>
<mi>x</mi>
</mrow>
<mo>=</mo>
<mi>b</mi>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>A</ci>
<ci>x</ci>
</apply>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Ax=b,\,
  </annotation>
</semantics>
</math>
</p>

<p>in general, a vector 

<math display="inline" id="Moore–Penrose_pseudoinverse:198">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 that solves the system may not exist, or if one does exist, it may not be unique. The pseudoinverse solves the "least-squares" problem as follows:</p>
<ul>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:199">
<semantics>
<mrow>
<mrow>
<mo>∀</mo>
<mi>x</mi>
</mrow>
<mo>∈</mo>
<msup>
<mi>K</mi>
<mi>n</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>x</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>K</ci>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall x\in K^{n}\,\!
  </annotation>
</semantics>
</math>

, we have 

<math display="inline" id="Moore–Penrose_pseudoinverse:200">
<semantics>
<mrow>
<msub>
<mrow>
<mo>∥</mo>
<mrow>
<mrow>
<mi>A</mi>
<mi>x</mi>
</mrow>
<mo>-</mo>
<mi>b</mi>
</mrow>
<mo>∥</mo>
</mrow>
<mn>2</mn>
</msub>
<mo>≥</mo>
<msub>
<mrow>
<mo>∥</mo>
<mrow>
<mrow>
<mi>A</mi>
<mi>z</mi>
</mrow>
<mo>-</mo>
<mi>b</mi>
</mrow>
<mo>∥</mo>
</mrow>
<mn>2</mn>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<geq></geq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>A</ci>
<ci>x</ci>
</apply>
<ci>b</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>A</ci>
<ci>z</ci>
</apply>
<ci>b</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \|Ax-b\|_{2}\geq\|Az-b\|_{2}
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Moore–Penrose_pseudoinverse:201">
<semantics>
<mrow>
<mi>z</mi>
<mo>=</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>b</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>z</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>b</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z=A^{+}b
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Moore–Penrose_pseudoinverse:202">
<semantics>
<mrow>
<mo>∥</mo>
<mo>⋅</mo>
<msub>
<mo>∥</mo>
<mn>2</mn>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="latexml">parallel-to</csymbol>
<ci>normal-⋅</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">parallel-to</csymbol>
<cn type="integer">2</cn>
</apply>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \|\cdot\|_{2}
  </annotation>
</semantics>
</math>

 denotes the <a href="Euclidean_norm" title="wikilink">Euclidean norm</a>. This weak inequality holds with equality if and only if 

<math display="inline" id="Moore–Penrose_pseudoinverse:203">
<semantics>
<mrow>
<mi>x</mi>
<mo>=</mo>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>b</mi>
</mrow>
<mo>+</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>I</mi>
<mo>-</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>A</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>w</mi>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>x</ci>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>b</ci>
</apply>
<apply>
<times></times>
<apply>
<minus></minus>
<ci>I</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>A</ci>
</apply>
</apply>
<ci>w</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x=A^{+}b+(I-A^{+}A)w
  </annotation>
</semantics>
</math>

 for any vector <em>w</em>; this provides an infinitude of minimizing solutions unless <em>A</em> has full column rank, in which case 

<math display="inline" id="Moore–Penrose_pseudoinverse:204">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>I</mi>
<mo>-</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>A</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>I</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>A</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (I-A^{+}A)
  </annotation>
</semantics>
</math>

 is a zero matrix.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a>The solution with minimum Euclidean norm is 

<math display="inline" id="Moore–Penrose_pseudoinverse:205">
<semantics>
<mrow>
<mi>z</mi>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<ci>z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   z.
  </annotation>
</semantics>
</math>
<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></li>
</ul>

<p>This result is easily extended to systems with multiple right-hand sides, when the Euclidean norm is replaced by the Frobenius norm. Let 

<math display="inline" id="Moore–Penrose_pseudoinverse:206">
<semantics>
<mrow>
<mi>B</mi>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>p</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>B</ci>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>m</ci>
<ci>p</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   B\in\mathrm{M}(m,p;K)
  </annotation>
</semantics>
</math>

.</p>
<ul>
<li>
<math display="inline" id="Moore–Penrose_pseudoinverse:207">
<semantics>
<mrow>
<mrow>
<mo>∀</mo>
<mi>X</mi>
</mrow>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>,</mo>
<mi>p</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>X</ci>
</apply>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>n</ci>
<ci>p</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall X\in\mathrm{M}(n,p;K)\,\!
  </annotation>
</semantics>
</math>

, we have 

<math display="inline" id="Moore–Penrose_pseudoinverse:208">
<semantics>
<mrow>
<msub>
<mrow>
<mo>∥</mo>
<mrow>
<mrow>
<mi>A</mi>
<mi>X</mi>
</mrow>
<mo>-</mo>
<mi>B</mi>
</mrow>
<mo>∥</mo>
</mrow>
<mi mathvariant="normal">F</mi>
</msub>
<mo>≥</mo>
<msub>
<mrow>
<mo>∥</mo>
<mrow>
<mrow>
<mi>A</mi>
<mi>Z</mi>
</mrow>
<mo>-</mo>
<mi>B</mi>
</mrow>
<mo>∥</mo>
</mrow>
<mi mathvariant="normal">F</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<geq></geq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>A</ci>
<ci>X</ci>
</apply>
<ci>B</ci>
</apply>
</apply>
<ci>normal-F</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>A</ci>
<ci>Z</ci>
</apply>
<ci>B</ci>
</apply>
</apply>
<ci>normal-F</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \|AX-B\|_{\mathrm{F}}\geq\|AZ-B\|_{\mathrm{F}}
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Moore–Penrose_pseudoinverse:209">
<semantics>
<mrow>
<mi>Z</mi>
<mo>=</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>B</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>Z</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>B</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Z=A^{+}B
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Moore–Penrose_pseudoinverse:210">
<semantics>
<mrow>
<mo>∥</mo>
<mo>⋅</mo>
<msub>
<mo>∥</mo>
<mi mathvariant="normal">F</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="latexml">parallel-to</csymbol>
<ci>normal-⋅</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">parallel-to</csymbol>
<ci>normal-F</ci>
</apply>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \|\cdot\|_{\mathrm{F}}
  </annotation>
</semantics>
</math>

 denotes the <a href="Frobenius_norm" title="wikilink">Frobenius norm</a>.</li>
</ul>
<h3 id="obtaining-all-solutions-of-a-linear-system">Obtaining all solutions of a linear system</h3>

<p>If the linear system</p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:211">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<mi>x</mi>
</mrow>
<mo>=</mo>
<mpadded width="+1.7pt">
<mi>b</mi>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>A</ci>
<ci>x</ci>
</apply>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Ax=b\,
  </annotation>
</semantics>
</math>
</p>

<p>has any solutions, they are all given by<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:212">
<semantics>
<mrow>
<mi>x</mi>
<mo>=</mo>
<mrow>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>b</mi>
</mrow>
<mo>+</mo>
<mrow>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>I</mi>
<mo>-</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>A</mi>
</mrow>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mi>w</mi>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>x</ci>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>b</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<minus></minus>
<ci>I</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>A</ci>
</apply>
</apply>
</apply>
<ci>w</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x=A^{+}b+[I-A^{+}A]w
  </annotation>
</semantics>
</math>
</p>

<p>for arbitrary vector <em>w</em>. Solution(s) exist if and only if 

<math display="inline" id="Moore–Penrose_pseudoinverse:213">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>b</mi>
</mrow>
<mo>=</mo>
<mi>b</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>b</ci>
</apply>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   AA^{+}b=b
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> If the latter holds, then the solution is unique if and only if <em>A</em> has full column rank, in which case 

<math display="inline" id="Moore–Penrose_pseudoinverse:214">
<semantics>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>I</mi>
<mo>-</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>A</mi>
</mrow>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<minus></minus>
<ci>I</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>A</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   [I-A^{+}A]
  </annotation>
</semantics>
</math>

 is a zero matrix. If solutions exist but <em>A</em> does not have full column rank, then we have an <a href="indeterminate_system" title="wikilink">indeterminate system</a>, all of whose infinitude of solutions are given by this last equation. This solution is deeply connected to the <a href="Udwadia–Kalaba_equation" title="wikilink">Udwadia–Kalaba equation</a> of <a href="classical_mechanics" title="wikilink">classical mechanics</a> to forces of constraint that do not obey <a href="D'Alembert's_principle" title="wikilink">D'Alembert's principle</a>.</p>
<h3 id="minimum-norm-solution-to-a-linear-system">Minimum norm solution to a linear system</h3>

<p>For linear systems 

<math display="inline" id="Moore–Penrose_pseudoinverse:215">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>A</mi>
<mi>x</mi>
</mrow>
<mo>=</mo>
<mi>b</mi>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>A</ci>
<ci>x</ci>
</apply>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Ax=b,\,
  </annotation>
</semantics>
</math>

 with non-unique solutions (such as under-determined systems), the pseudoinverse may be used to construct the solution of minimum <a href="Euclidean_norm" title="wikilink">Euclidean norm</a>
<math display="inline" id="Moore–Penrose_pseudoinverse:216">
<semantics>
<msub>
<mrow>
<mo>∥</mo>
<mi>x</mi>
<mo>∥</mo>
</mrow>
<mn>2</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<ci>x</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \|x\|_{2}
  </annotation>
</semantics>
</math>

 among all solutions.</p>
<ul>
<li>If 

<math display="inline" id="Moore–Penrose_pseudoinverse:217">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<mi>x</mi>
</mrow>
<mo>=</mo>
<mpadded width="+1.7pt">
<mi>b</mi>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>A</ci>
<ci>x</ci>
</apply>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Ax=b\,
  </annotation>
</semantics>
</math>

 is satisfiable, the vector 

<math display="inline" id="Moore–Penrose_pseudoinverse:218">
<semantics>
<mrow>
<mi>z</mi>
<mo>=</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>b</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>z</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>b</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z=A^{+}b
  </annotation>
</semantics>
</math>

 is a solution, and satisfies 

<math display="inline" id="Moore–Penrose_pseudoinverse:219">
<semantics>
<mrow>
<msub>
<mrow>
<mo>∥</mo>
<mi>z</mi>
<mo>∥</mo>
</mrow>
<mn>2</mn>
</msub>
<mo>≤</mo>
<msub>
<mrow>
<mo>∥</mo>
<mi>x</mi>
<mo>∥</mo>
</mrow>
<mn>2</mn>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<ci>z</ci>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<ci>x</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \|z\|_{2}\leq\|x\|_{2}
  </annotation>
</semantics>
</math>

 for all solutions.</li>
</ul>

<p>This result is easily extended to systems with multiple right-hand sides, when the Euclidean norm is replaced by the Frobenius norm. Let 

<math display="inline" id="Moore–Penrose_pseudoinverse:220">
<semantics>
<mrow>
<mi>B</mi>
<mo>∈</mo>
<mrow>
<mi mathvariant="normal">M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>,</mo>
<mi>p</mi>
<mo>;</mo>
<mi>K</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>B</ci>
<apply>
<times></times>
<ci>normal-M</ci>
<vector>
<ci>m</ci>
<ci>p</ci>
<ci>K</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   B\in\mathrm{M}(m,p;K)\,\!
  </annotation>
</semantics>
</math>

.</p>
<ul>
<li>If 

<math display="inline" id="Moore–Penrose_pseudoinverse:221">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<mi>X</mi>
</mrow>
<mo>=</mo>
<mpadded width="+1.7pt">
<mi>B</mi>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>A</ci>
<ci>X</ci>
</apply>
<ci>B</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   AX=B\,
  </annotation>
</semantics>
</math>

 is satisfiable, the matrix 

<math display="inline" id="Moore–Penrose_pseudoinverse:222">
<semantics>
<mrow>
<mi>Z</mi>
<mo>=</mo>
<mrow>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mi>B</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>Z</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
<ci>B</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Z=A^{+}B
  </annotation>
</semantics>
</math>

 is a solution, and satisfies 

<math display="inline" id="Moore–Penrose_pseudoinverse:223">
<semantics>
<mrow>
<msub>
<mrow>
<mo>∥</mo>
<mi>Z</mi>
<mo>∥</mo>
</mrow>
<mi mathvariant="normal">F</mi>
</msub>
<mo>≤</mo>
<msub>
<mrow>
<mo>∥</mo>
<mi>X</mi>
<mo>∥</mo>
</mrow>
<mi mathvariant="normal">F</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<ci>Z</ci>
</apply>
<ci>normal-F</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<ci>X</ci>
</apply>
<ci>normal-F</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \|Z\|_{\mathrm{F}}\leq\|X\|_{\mathrm{F}}
  </annotation>
</semantics>
</math>

 for all solutions.</li>
</ul>
<h3 id="condition-number">Condition number</h3>

<p>Using the pseudoinverse and a <a href="matrix_norm" title="wikilink">matrix norm</a>, one can define a <a href="condition_number" title="wikilink">condition number</a> for any matrix:</p>

<p>
<math display="block" id="Moore–Penrose_pseudoinverse:224">
<semantics>
<mrow>
<mrow>
<mrow>
<mtext>cond</mtext>
<mrow>
<mo stretchy="false">(</mo>
<mi>A</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo>∥</mo>
<mi>A</mi>
<mo>∥</mo>
</mrow>
<mrow>
<mo>∥</mo>
<msup>
<mi>A</mi>
<mo>+</mo>
</msup>
<mo>∥</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<mtext>cond</mtext>
<ci>A</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="latexml">norm</csymbol>
<ci>A</ci>
</apply>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<plus></plus>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mbox{cond}(A)=\|A\|\|A^{+}\|.
  </annotation>
</semantics>
</math>

 A large condition number implies that the problem of finding least-squares solutions to the corresponding system of linear equations is ill-conditioned in the sense that small errors in the entries of 

<math display="inline" id="Moore–Penrose_pseudoinverse:225">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 can lead to huge errors in the entries of the solution.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h2 id="generalizations">Generalizations</h2>

<p>In order to solve more general least-squares problems, one can define Moore–Penrose pseudoinverses for all continuous linear operators <mtpl></mtpl> between two <a href="Hilbert_space" title="wikilink">Hilbert spaces</a> <mtpl></mtpl> and <mtpl></mtpl>, using the same four conditions as in our definition above. It turns out that not every continuous linear operator has a continuous linear pseudoinverse in this sense.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> Those that do are precisely the ones whose range is <a href="closed_set" title="wikilink">closed</a> in <mtpl></mtpl>.</p>

<p>In <a href="abstract_algebra" title="wikilink">abstract algebra</a>, a Moore–Penrose pseudoinverse may be defined on a <a href="*-regular_semigroup" title="wikilink">*-regular semigroup</a>. This abstract definition coincides with the one in linear algebra.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Proofs_involving_the_Moore–Penrose_pseudoinverse" title="wikilink">Proofs involving the Moore–Penrose pseudoinverse</a></li>
<li><a href="Drazin_inverse" title="wikilink">Drazin inverse</a></li>
<li><a href="Hat_matrix" title="wikilink">Hat matrix</a></li>
<li><a href="Inverse_element" title="wikilink">Inverse element</a></li>
<li><a href="Linear_least_squares_(mathematics)" title="wikilink">Linear least squares (mathematics)</a></li>
<li><a class="uri" href="Pseudo-determinant" title="wikilink">Pseudo-determinant</a></li>
<li><a href="Von_Neumann_regular_ring" title="wikilink">Von Neumann regular ring</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://people.revoledu.com/kardi/tutorial/LinearAlgebra/MatrixGeneralizedInverse.html">Interactive program &amp; tutorial of Moore–Penrose Pseudoinverse</a></li>
<li></li>
<li></li>
<li></li>
<li><a href="http://arxiv.org/abs/1110.6882">The Moore–Penrose Pseudoinverse. A Tutorial Review of the Theory</a></li>
<li><a href="http://engineerjs.com/doc/ejs/engine/linalg-1/_pinv.html">Online Moore-Penrose Inverse calculator</a></li>
</ul>

<p>"</p>

<p><a href="Category:Matrix_theory" title="wikilink">Category:Matrix theory</a> <a href="Category:Singular_value_decomposition" title="wikilink">Category:Singular value decomposition</a> <a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a class="uri" href="http://mathoverflow.net/questions/25778/analytical-formula-for-numerical-derivative-of-the-matrix-pseudo-inverse">http://mathoverflow.net/questions/25778/analytical-formula-for-numerical-derivative-of-the-matrix-pseudo-inverse</a><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"><a href="http://www.uwlax.edu/faculty/will/svd/systems/index.html">Linear Systems &amp; Pseudo-Inverse</a><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="http://benisrael.net/COHEN-BI-ITER-GI.pdf">pdf</a><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21">, Mohammad Emtiyaz, "Updating Inverse of a Matrix When a Column is Added/Removed"<a href="http://www.cs.ubc.ca/~emtiyaz/Writings/OneColInv.pdf">1</a><a href="#fnref21">↩</a></li>
<li id="fn22">Meyer, Carl D., Jr. Generalized inverses and ranks of block matrices. SIAM J. Appl. Math. 25 (1973), 597–602<a href="#fnref22">↩</a></li>
<li id="fn23">Meyer, Carl D., Jr. Generalized inversion of modified matrices. SIAM J. Appl. Math. 24 (1973), 315–323<a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25">Planitz, M., "Inconsistent systems of linear equations", <em>Mathematical Gazette</em> 63, October 1979, 181–185.<a href="#fnref25">↩</a></li>
<li id="fn26"></li>
<li id="fn27">James, M., "The generalised inverse", <em>Mathematical Gazette</em> 62, June 1978, 109–114.<a href="#fnref27">↩</a></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30">Roland Hagen, Steffen Roch, Bernd Silbermann. <em>C*-algebras and Numerical Analysis</em>, CRC Press, 2001. Section 2.1.2.<a href="#fnref30">↩</a></li>
</ol>
</section>
</ref></hr></body>
</html>
