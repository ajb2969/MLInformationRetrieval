<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1795">Jenkins–Traub algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Jenkins–Traub algorithm</h1>
<hr/>

<p>The <strong>Jenkins–Traub algorithm for polynomial zeros</strong> is a fast globally convergent iterative method published in 1970 by <a href="Michael_A._Jenkins" title="wikilink">Michael A. Jenkins</a> and <a href="Joseph_F._Traub" title="wikilink">Joseph F. Traub</a>. They gave two variants, one for general polynomials with complex coefficients, commonly known as the "CPOLY" algorithm, and a more complicated variant for the special case of polynomials with real coefficients, commonly known as the "RPOLY" algorithm. The latter is "practically a standard in black-box polynomial root-finders".<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>This article describes the complex variant. Given a polynomial <em>P</em>,</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <msup>
       <mi>z</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <mo>≠</mo>
     <mn>0</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <neq></neq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(z)=\sum_{i=0}^{n}a_{i}z^{n-i},\quad a_{0}=1,\quad a_{n}\neq 0
  </annotation>
 </semantics>
</math>

</p>

<p>with complex coefficients it computes approximations to the <em>n</em> zeros 

<math display="inline" id="Jenkins–Traub_algorithm:1">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>α</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>α</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1},\alpha_{2},\dots,\alpha_{n}
  </annotation>
 </semantics>
</math>

 of <em>P</em>(<em>z</em>), one at a time in roughly increasing order of magnitude. After each root is computed, its linear factor is removed from the polynomial. Using this <em>deflation</em> guarantees that each root is computed only once and that all roots are found.</p>

<p>The real variant follows the same pattern, but computes two roots at a time, either two real roots or a pair of conjugate complex roots. By avoiding complex arithmetic, the real variant can be faster (by a factor of 4) than the complex variant. The Jenkins–Traub algorithm has stimulated considerable research on theory and software for methods of this type.</p>
<h2 id="overview">Overview</h2>

<p>The Jenkins–Traub algorithm calculates all of the roots of a <a class="uri" href="polynomial" title="wikilink">polynomial</a> with complex coefficients. The algorithm starts by checking the polynomial for the occurrence of very large or very small roots. If necessary, the coefficients are rescaled by a rescaling of the variable. In the algorithm proper, roots are found one by one and generally in increasing size. After each root is found, the polynomial is deflated by dividing off the corresponding linear factor. Indeed, the factorization of the polynomial into the linear factor and the remaining deflated polynomial is already a result of the root-finding procedure. The root-finding procedure has three stages that correspond to different variants of the <a href="inverse_power_iteration" title="wikilink">inverse power iteration</a>. See Jenkins and <a href="Joseph_F_Traub" title="wikilink">Traub</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> A description can also be found in Ralston and <a href="Philip_Rabinowitz_(mathematician)" title="wikilink"> Rabinowitz</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> p. 383. The algorithm is similar in spirit to the two-stage algorithm studied by Traub.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="root-finding-procedure">Root-finding procedure</h3>

<p>Starting with the current polynomial <em>P</em>(<em>X</em>) of degree <em>n</em>, the smallest root of <em>P(x)</em> is computed. To that end, a sequence of so-called <em>H</em> polynomials is constructed. These polynomials are all of degree <em>n</em> − 1 and are supposed to converge to the factor of <em>P</em>(<em>X</em>) containing all the remaining roots. The sequence of <em>H</em> polynomials occurs in two variants, an unnormalized variant that allows easy theoretical insights and a normalized variant of 

<math display="inline" id="Jenkins–Traub_algorithm:2">
 <semantics>
  <mover accent="true">
   <mi>H</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{H}
  </annotation>
 </semantics>
</math>

 polynomials that keeps the coefficients in a numerically sensible range.</p>

<p>The construction of the <em>H</em> polynomials 

<math display="inline" id="Jenkins–Traub_algorithm:3">
 <semantics>
  <msub>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msup>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mrow>
    <mi>λ</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>λ</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <eq></eq>
     <ci>λ</ci>
     <list>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(H^{(\lambda)}(z)\right)_{\lambda=0,1,2,\dots}
  </annotation>
 </semantics>
</math>

 depends on a sequence of complex numbers 

<math display="inline" id="Jenkins–Traub_algorithm:4">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>s</mi>
     <mi>λ</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>λ</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>λ</ci>
    </apply>
    <apply>
     <eq></eq>
     <ci>λ</ci>
     <list>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s_{\lambda})_{\lambda=0,1,2,\dots}
  </annotation>
 </semantics>
</math>

 called shifts. These shifts themselves depend, at least in the third stage, on the previous <em>H</em> polynomials. The <em>H</em> polynomials are defined as the solution to the implicit recursion</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:5">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>P</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{(0)}(z)=P^{\prime}(z)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Jenkins–Traub_algorithm:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>X</mi>
        <mo>-</mo>
        <msub>
         <mi>s</mi>
         <mi>λ</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>⋅</mo>
      <msup>
       <mi>H</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>λ</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>H</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>λ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mpadded width="+5pt">
      <mrow>
       <mo lspace="8.1pt" stretchy="false">(</mo>
       <mrow>
        <mo>mod</mo>
        <mrow>
         <mi>P</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <minus></minus>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>λ</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <apply>
        <plus></plus>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>λ</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>X</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X-s_{\lambda})\cdot H^{(\lambda+1)}(X)\equiv H^{(\lambda)}(X)\;\;(\mathop{{%
\rm mod}}P(X))\ .
  </annotation>
 </semantics>
</math>

 A direct solution to this implicit equation is</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>λ</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>X</mi>
       <mo>-</mo>
       <msub>
        <mi>s</mi>
        <mi>λ</mi>
       </msub>
      </mrow>
     </mfrac>
     <mo>⋅</mo>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>H</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>λ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>X</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mrow>
          <msup>
           <mi>H</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>s</mi>
            <mi>λ</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>s</mi>
            <mi>λ</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>X</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo rspace="4.2pt">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <apply>
       <plus></plus>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>λ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>H</ci>
        <ci>λ</ci>
       </apply>
       <ci>X</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>H</ci>
          <ci>λ</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>λ</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>P</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>λ</ci>
         </apply>
        </apply>
       </apply>
       <ci>P</ci>
       <ci>X</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{(\lambda+1)}(X)=\frac{1}{X-s_{\lambda}}\cdot\left(H^{(\lambda)}(X)-\frac{H^%
{(\lambda)}(s_{\lambda})}{P(s_{\lambda})}P(X)\right)\,,
  </annotation>
 </semantics>
</math>

 where the polynomial division is exact.</p>

<p>Algorithmically, one would use for instance the <a href="Horner_scheme" title="wikilink">Horner scheme</a> or <a href="Ruffini_rule" title="wikilink">Ruffini rule</a> to evaluate the polynomials at 

<math display="inline" id="Jenkins–Traub_algorithm:8">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>λ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\lambda}
  </annotation>
 </semantics>
</math>

 and obtain the quotients at the same time. With the resulting quotients <em>p</em>(<em>X</em>) and <em>h</em>(<em>X</em>) as intermediate results the next <em>H</em> polynomial is obtained as</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:9">
 <semantics>
  <mrow>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="right">
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>X</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>⋅</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>X</mi>
           <mo>-</mo>
           <msub>
            <mi>s</mi>
            <mi>λ</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>P</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>s</mi>
           <mi>λ</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="right">
      <mrow>
       <msup>
        <mi>H</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>λ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mrow>
          <mi>h</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>X</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>⋅</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>X</mi>
           <mo>-</mo>
           <msub>
            <mi>s</mi>
            <mi>λ</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msup>
          <mi>H</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>λ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>s</mi>
           <mi>λ</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
   <mo>}</mo>
   <mo>⟹</mo>
   <mi>H</mi>
   <msup>
    <mi></mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>λ</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo stretchy="false">(</mo>
   <mi>z</mi>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
   <mi>h</mi>
   <mo stretchy="false">(</mo>
   <mi>z</mi>
   <mo stretchy="false">)</mo>
   <mo>-</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>s</mi>
       <mi>λ</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>s</mi>
       <mi>λ</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mi>p</mi>
   <mo stretchy="false">(</mo>
   <mi>z</mi>
   <mo stretchy="false">)</mo>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>X</ci>
      </apply>
      <apply>
       <eq></eq>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>X</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>X</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>s</ci>
           <ci>λ</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>P</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>λ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>H</ci>
        <ci>λ</ci>
       </apply>
       <ci>X</ci>
      </apply>
      <apply>
       <eq></eq>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <times></times>
          <ci>h</ci>
          <ci>X</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>X</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>s</ci>
           <ci>λ</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>H</ci>
          <ci>λ</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>λ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
    <ci>normal-}</ci>
    <implies></implies>
    <csymbol cd="unknown">H</csymbol>
    <apply>
     <apply>
      <plus></plus>
      <ci>λ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-(</ci>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-)</ci>
    <eq></eq>
    <csymbol cd="unknown">h</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-)</ci>
    <minus></minus>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>λ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>λ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-)</ci>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left.\begin{aligned}\displaystyle P(X)&\displaystyle=p(X)\cdot(X-s_{\lambda})%
+P(s_{\lambda})\\
\displaystyle H^{(\lambda)}(X)&\displaystyle=h(X)\cdot(X-s_{\lambda})+H^{(%
\lambda)}(s_{\lambda})\\
\end{aligned}\right\}\implies H^{(\lambda+1)}(z)=h(z)-\frac{H^{(\lambda)}(s_{%
\lambda})}{P(s_{\lambda})}p(z).
  </annotation>
 </semantics>
</math>

 Since the highest degree coefficient is obtained from <em>P(X)</em>, the leading coefficient of 

<math display="inline" id="Jenkins–Traub_algorithm:10">
 <semantics>
  <mrow>
   <msup>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>λ</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <apply>
      <plus></plus>
      <ci>λ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{(\lambda+1)}(X)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Jenkins–Traub_algorithm:11">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>s</mi>
       <mi>λ</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>s</mi>
       <mi>λ</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>λ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>λ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\tfrac{H^{(\lambda)}(s_{\lambda})}{P(s_{\lambda})}
  </annotation>
 </semantics>
</math>

. If this is divided out the normalized <em>H</em> polynomial is</p>

<p>

<math display="inline" id="Jenkins–Traub_algorithm:12">
 <semantics>
  <mrow>
   <msup>
    <mover accent="true">
     <mi>H</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>λ</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>H</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>λ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\bar{H}^{(\lambda+1)}(X)
  </annotation>
 </semantics>
</math>


</p>
<h4 id="stage-one-no-shift-process">Stage one: no-shift process</h4>

<p>For 

<math display="inline" id="Jenkins–Traub_algorithm:13">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>M</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=0,1,\dots,M-1
  </annotation>
 </semantics>
</math>

 set 

<math display="inline" id="Jenkins–Traub_algorithm:14">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>λ</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>λ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\lambda}=0
  </annotation>
 </semantics>
</math>

. Usually <em>M=5</em> is chosen for polynomials of moderate degrees up to <em>n</em> = 50. This stage is not necessary from theoretical considerations alone, but is useful in practice. It emphasizes in the <em>H</em> polynomials the cofactor (of the linear factor) of the smallest root.</p>
<h4 id="stage-two-fixed-shift-process">Stage two: fixed-shift process</h4>

<p>The shift for this stage is determined as some point close to the smallest root of the polynomial. It is quasi-randomly located on the circle with the inner root radius, which in turn is estimated as the positive solution of the equation</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>R</mi>
      <mi>n</mi>
     </msup>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>a</mi>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo rspace="4.2pt" stretchy="false">|</mo>
      </mrow>
      <msup>
       <mi>R</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mo rspace="4.2pt" stretchy="false">|</mo>
      </mrow>
      <mi>R</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo rspace="4.2pt" stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{n}+|a_{n-1}|\,R^{n-1}+\dots+|a_{1}|\,R=|a_{0}|\,.
  </annotation>
 </semantics>
</math>

 Since the left side is a convex function and increases monotonically from zero to infinity, this equation is easy to solve, for instance by <a href="Newton's_method" title="wikilink">Newton's method</a>.</p>

<p>Now choose 

<math display="inline" id="Jenkins–Traub_algorithm:16">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mo>⋅</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>i</mi>
       </mpadded>
       <msub>
        <mi>ϕ</mi>
        <mtext>random</mtext>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>R</ci>
     <apply>
      <exp></exp>
      <apply>
       <times></times>
       <ci>i</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <mtext>random</mtext>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=R\cdot\exp(i\,\phi_{\text{random}})
  </annotation>
 </semantics>
</math>

 on the circle of this radius. The sequence of polynomials 

<math display="inline" id="Jenkins–Traub_algorithm:17">
 <semantics>
  <mrow>
   <msup>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>λ</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <apply>
      <plus></plus>
      <ci>λ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{(\lambda+1)}(z)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Jenkins–Traub_algorithm:18">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <mo>,</mo>
    <mrow>
     <mi>M</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>L</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <list>
     <ci>M</ci>
     <apply>
      <plus></plus>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>L</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=M,M+1,\dots,L-1
  </annotation>
 </semantics>
</math>

, is generated with the fixed shift value 

<math display="inline" id="Jenkins–Traub_algorithm:19">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>λ</mi>
   </msub>
   <mo>=</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>λ</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\lambda}=s
  </annotation>
 </semantics>
</math>

. During this iteration, the current approximation for the root</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:20">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>λ</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mover accent="true">
        <mi>H</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>λ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>λ</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>s</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-¯</ci>
         <ci>H</ci>
        </apply>
        <ci>λ</ci>
       </apply>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{\lambda}=s-\frac{P(s)}{\bar{H}^{(\lambda)}(s)}
  </annotation>
 </semantics>
</math>

 is traced. The second stage is finished successfully if the conditions</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>t</mi>
      <mrow>
       <mi>λ</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>t</mi>
      <mi>λ</mi>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mstyle displaystyle="false">
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mstyle>
    </mpadded>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>t</mi>
      <mi>λ</mi>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <plus></plus>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |t_{\lambda+1}-t_{\lambda}|<\tfrac{1}{2}\,|t_{\lambda}|
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Jenkins–Traub_algorithm:22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>t</mi>
      <mi>λ</mi>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>t</mi>
      <mrow>
       <mi>λ</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </mpadded>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>t</mi>
      <mrow>
       <mi>λ</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>λ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <minus></minus>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <minus></minus>
        <ci>λ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |t_{\lambda}-t_{\lambda-1}|<\tfrac{1}{2}\,|t_{\lambda-1}|
  </annotation>
 </semantics>
</math>

 are simultaneously met. If there was no success after some number of iterations, a different random point on the circle is tried. Typically one uses a number of 9 iterations for polynomials of moderate degree, with a doubling strategy for the case of multiple failures.</p>
<h4 id="stage-three-variable-shift-process">Stage three: variable-shift process</h4>

<p>The 

<math display="inline" id="Jenkins–Traub_algorithm:23">
 <semantics>
  <mrow>
   <msup>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>λ</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <apply>
      <plus></plus>
      <ci>λ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{(\lambda+1)}(X)
  </annotation>
 </semantics>
</math>

 are now generated using the variable shifts 

<math display="inline" id="Jenkins–Traub_algorithm:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>s</mi>
      <mi>λ</mi>
     </msub>
     <mo rspace="12.5pt">,</mo>
     <mi>λ</mi>
    </mrow>
    <mo>=</mo>
    <mi>L</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>λ</ci>
      </apply>
      <ci>λ</ci>
     </list>
     <ci>L</ci>
    </apply>
    <list>
     <apply>
      <plus></plus>
      <ci>L</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\lambda},\quad\lambda=L,L+1,\dots
  </annotation>
 </semantics>
</math>

 which are generated by</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:25">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>L</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mi>L</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mover accent="true">
        <mi>H</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>λ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>s</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-¯</ci>
          <ci>H</ci>
         </apply>
         <ci>λ</ci>
        </apply>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{L}=t_{L}=s-\frac{P(s)}{\bar{H}^{(\lambda)}(s)}
  </annotation>
 </semantics>
</math>

 being the last root estimate of the second stage and</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>s</mi>
      <mrow>
       <mi>λ</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>s</mi>
       <mi>λ</mi>
      </msub>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>s</mi>
          <mi>λ</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msup>
         <mover accent="true">
          <mi>H</mi>
          <mo stretchy="false">¯</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>λ</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>s</mi>
          <mi>λ</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>λ</mi>
     <mo>=</mo>
     <mrow>
      <mi>L</mi>
      <mo>,</mo>
      <mrow>
       <mi>L</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <apply>
       <plus></plus>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>λ</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>P</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <ci>λ</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-¯</ci>
          <ci>H</ci>
         </apply>
         <apply>
          <plus></plus>
          <ci>λ</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <ci>λ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>λ</ci>
     <list>
      <ci>L</ci>
      <apply>
       <plus></plus>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\lambda+1}=s_{\lambda}-\frac{P(s_{\lambda})}{\bar{H}^{(\lambda+1)}(s_{%
\lambda})},\quad\lambda=L,L+1,\dots,
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>where 

<math display="inline" id="Jenkins–Traub_algorithm:27">
 <semantics>
  <mrow>
   <msup>
    <mover accent="true">
     <mi>H</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>λ</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>H</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>λ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{H}^{(\lambda+1)}(z)
  </annotation>
 </semantics>
</math>

 is the normalized <em>H</em> polynomial, that is 

<math display="inline" id="Jenkins–Traub_algorithm:28">
 <semantics>
  <mrow>
   <msup>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <ci>λ</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{(\lambda)}(z)
  </annotation>
 </semantics>
</math>

 divided by its leading coefficient.
</dd>
</dl>

<p>If the step size in stage three does not fall fast enough to zero, then stage two is restarted using a different random point. If this does not succeed after a small number of restarts, the number of steps in stage two is doubled.</p>
<h4 id="convergence">Convergence</h4>

<p>It can be shown that, provided <em>L</em> is chosen sufficiently large, <em>s</em><sub>λ</sub> always converges to a root of <em>P</em>.</p>

<p>The algorithm converges for any distribution of roots, but may fail to find all roots of the polynomial. Furthermore, the convergence is slightly faster than the <a href="Rate_of_convergence" title="wikilink">quadratic convergence</a> of Newton–Raphson iteration, however, it uses at least twice as many operations per step.</p>
<h2 id="what-gives-the-algorithm-its-power">What gives the algorithm its power?</h2>

<p>Compare with the <a href="Newton–Raphson_iteration" title="wikilink">Newton–Raphson iteration</a></p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>z</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>z</mi>
      <mi>i</mi>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>z</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mi>P</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>z</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>P</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{i+1}=z_{i}-\frac{P(z_{i})}{P^{\prime}(z_{i})}.
  </annotation>
 </semantics>
</math>

</p>

<p>The iteration uses the given <em>P</em> and 

<math display="inline" id="Jenkins–Traub_algorithm:30">
 <semantics>
  <msup>
   <mi>P</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle P^{\prime}
  </annotation>
 </semantics>
</math>


. In contrast the third-stage of Jenkins–Traub</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:31">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mrow>
     <mi>λ</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>λ</mi>
    </msub>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>s</mi>
        <mi>λ</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mover accent="true">
        <mi>H</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mrow>
        <mi>λ</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>s</mi>
        <mi>λ</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>λ</mi>
    </msub>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <msup>
       <mi>W</mi>
       <mi>λ</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>s</mi>
        <mi>λ</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>W</mi>
         <mi>λ</mi>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>s</mi>
        <mi>λ</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <apply>
       <plus></plus>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>λ</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>P</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <ci>λ</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-¯</ci>
          <ci>H</ci>
         </apply>
         <apply>
          <plus></plus>
          <ci>λ</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <ci>λ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>λ</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>W</ci>
         <ci>λ</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <ci>λ</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>W</ci>
          <ci>λ</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <ci>λ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\lambda+1}=s_{\lambda}-\frac{P(s_{\lambda})}{\bar{H}^{\lambda+1}(s_{\lambda%
})}=s_{\lambda}-\frac{W^{\lambda}(s_{\lambda})}{(W^{\lambda})^{\prime}(s_{%
\lambda})}
  </annotation>
 </semantics>
</math>

</p>

<p>is precisely a Newton–Raphson iteration performed on certain <a href="rational_functions" title="wikilink">rational functions</a>. More precisely, Newton–Raphson is being performed on a sequence of rational functions</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>W</mi>
      <mi>λ</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mi>H</mi>
       <mi>λ</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>λ</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>λ</ci>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\lambda}(z)=\frac{P(z)}{H^{\lambda}(z)}.
  </annotation>
 </semantics>
</math>

</p>

<p>For 

<math display="inline" id="Jenkins–Traub_algorithm:33">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 sufficiently large,</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:34">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msup>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mi>λ</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>W</mi>
     <mi>λ</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <mi>L</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>H</mi>
      <mi>λ</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>H</ci>
       </apply>
       <ci>λ</ci>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>λ</ci>
     </apply>
     <ci>z</ci>
     <ci>L</ci>
     <ci>C</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{P(z)}{\bar{H}^{\lambda}(z)}=W^{\lambda}(z)\,LC(H^{\lambda})
  </annotation>
 </semantics>
</math>

</p>

<p>is as close as desired to a first degree polynomial</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mo>-</mo>
    <msub>
     <mi>α</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>z</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z-\alpha_{1},\,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Jenkins–Traub_algorithm:36">
 <semantics>
  <msub>
   <mi>α</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}
  </annotation>
 </semantics>
</math>

 is one of the zeros of 

<math display="inline" id="Jenkins–Traub_algorithm:37">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. Even though Stage 3 is precisely a Newton–Raphson iteration, differentiation is not performed.</p>
<h3 id="analysis-of-the-h-polynomials">Analysis of the <em>H</em> polynomials</h3>

<p>Let 

<math display="inline" id="Jenkins–Traub_algorithm:38">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>α</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1},\dots,\alpha_{n}
  </annotation>
 </semantics>
</math>

 be the roots of <em>P</em>(<em>X</em>). The so-called Lagrange factors of <em>P(X)</em> are the cofactors of these roots,</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mi>m</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>α</mi>
         <mi>m</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mi>X</mi>
      <mo>-</mo>
      <msub>
       <mi>α</mi>
       <mi>m</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>m</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>X</ci>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>X</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{m}(X)=\frac{P(X)-P(\alpha_{m})}{X-\alpha_{m}}.
  </annotation>
 </semantics>
</math>

 If all roots are different, then the Lagrange factors form a basis of the space of polynomials of degree at most <em>n</em> − 1. By analysis of the recursion procedure one finds that the <em>H</em> polynomials have the coordinate representation</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>m</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mrow>
         <mo>[</mo>
         <mrow>
          <munderover>
           <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
           <mrow>
            <mi>κ</mi>
            <mo>=</mo>
            <mn>0</mn>
           </mrow>
           <mrow>
            <mi>λ</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </munderover>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>α</mi>
             <mi>m</mi>
            </msub>
            <mo>-</mo>
            <msub>
             <mi>s</mi>
             <mi>κ</mi>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>]</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mpadded>
      <msub>
       <mi>P</mi>
       <mi>m</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>λ</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <csymbol cd="latexml">product</csymbol>
           <apply>
            <eq></eq>
            <ci>κ</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <ci>λ</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>α</ci>
           <ci>m</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>s</ci>
           <ci>κ</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>m</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{(\lambda)}(X)=\sum_{m=1}^{n}\left[\prod_{\kappa=0}^{\lambda-1}(\alpha_{m}-s%
_{\kappa})\right]^{-1}\,P_{m}(X)\ .
  </annotation>
 </semantics>
</math>

 Each Lagrange factor has leading coefficient 1, so that the leading coefficient of the H polynomials is the sum of the coefficients. The normalized H polynomials are thus</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>m</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </msubsup>
      <mrow>
       <mpadded width="+1.7pt">
        <msup>
         <mrow>
          <mo>[</mo>
          <mrow>
           <msubsup>
            <mo largeop="true" symmetric="true">∏</mo>
            <mrow>
             <mi>κ</mi>
             <mo>=</mo>
             <mn>0</mn>
            </mrow>
            <mrow>
             <mi>λ</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
           </msubsup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msub>
              <mi>α</mi>
              <mi>m</mi>
             </msub>
             <mo>-</mo>
             <msub>
              <mi>s</mi>
              <mi>κ</mi>
             </msub>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>]</mo>
         </mrow>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mpadded>
       <msub>
        <mi>P</mi>
        <mi>m</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>m</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </msubsup>
      <msup>
       <mrow>
        <mo>[</mo>
        <mrow>
         <msubsup>
          <mo largeop="true" symmetric="true">∏</mo>
          <mrow>
           <mi>κ</mi>
           <mo>=</mo>
           <mn>0</mn>
          </mrow>
          <mrow>
           <mi>λ</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>α</mi>
            <mi>m</mi>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>s</mi>
            <mi>κ</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>]</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mfrac>
      <mrow>
       <mrow>
        <msub>
         <mi>P</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>X</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>m</mi>
          <mo>=</mo>
          <mn>2</mn>
         </mrow>
         <mi>n</mi>
        </msubsup>
        <mrow>
         <mrow>
          <mo>[</mo>
          <mrow>
           <msubsup>
            <mo largeop="true" symmetric="true">∏</mo>
            <mrow>
             <mi>κ</mi>
             <mo>=</mo>
             <mn>0</mn>
            </mrow>
            <mrow>
             <mi>λ</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
           </msubsup>
           <mfrac>
            <mrow>
             <msub>
              <mi>α</mi>
              <mn>1</mn>
             </msub>
             <mo>-</mo>
             <msub>
              <mi>s</mi>
              <mi>κ</mi>
             </msub>
            </mrow>
            <mrow>
             <msub>
              <mi>α</mi>
              <mi>m</mi>
             </msub>
             <mo>-</mo>
             <msub>
              <mi>s</mi>
              <mi>κ</mi>
             </msub>
            </mrow>
           </mfrac>
          </mrow>
          <mo rspace="4.2pt">]</mo>
         </mrow>
         <msub>
          <mi>P</mi>
          <mi>m</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>m</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </msubsup>
        <mrow>
         <mo>[</mo>
         <mrow>
          <msubsup>
           <mo largeop="true" symmetric="true">∏</mo>
           <mrow>
            <mi>κ</mi>
            <mo>=</mo>
            <mn>0</mn>
           </mrow>
           <mrow>
            <mi>λ</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msubsup>
          <mfrac>
           <mrow>
            <msub>
             <mi>α</mi>
             <mn>1</mn>
            </msub>
            <mo>-</mo>
            <msub>
             <mi>s</mi>
             <mi>κ</mi>
            </msub>
           </mrow>
           <mrow>
            <msub>
             <mi>α</mi>
             <mi>m</mi>
            </msub>
            <mo>-</mo>
            <msub>
             <mi>s</mi>
             <mi>κ</mi>
            </msub>
           </mrow>
          </mfrac>
         </mrow>
         <mo>]</mo>
        </mrow>
       </mrow>
      </mrow>
     </mfrac>
    </mpadded>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>H</ci>
       </apply>
       <ci>λ</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <csymbol cd="latexml">product</csymbol>
             <apply>
              <eq></eq>
              <ci>κ</ci>
              <cn type="integer">0</cn>
             </apply>
            </apply>
            <apply>
             <minus></minus>
             <ci>λ</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>α</ci>
             <ci>m</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>s</ci>
             <ci>κ</ci>
            </apply>
           </apply>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>m</ci>
        </apply>
        <ci>X</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <csymbol cd="latexml">product</csymbol>
            <apply>
             <eq></eq>
             <ci>κ</ci>
             <cn type="integer">0</cn>
            </apply>
           </apply>
           <apply>
            <minus></minus>
            <ci>λ</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>α</ci>
            <ci>m</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>s</ci>
            <ci>κ</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>X</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>m</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <csymbol cd="latexml">product</csymbol>
             <apply>
              <eq></eq>
              <ci>κ</ci>
              <cn type="integer">0</cn>
             </apply>
            </apply>
            <apply>
             <minus></minus>
             <ci>λ</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <apply>
            <divide></divide>
            <apply>
             <minus></minus>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>α</ci>
              <cn type="integer">1</cn>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>s</ci>
              <ci>κ</ci>
             </apply>
            </apply>
            <apply>
             <minus></minus>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>α</ci>
              <ci>m</ci>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>s</ci>
              <ci>κ</ci>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>P</ci>
          <ci>m</ci>
         </apply>
         <ci>X</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>m</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <csymbol cd="latexml">product</csymbol>
            <apply>
             <eq></eq>
             <ci>κ</ci>
             <cn type="integer">0</cn>
            </apply>
           </apply>
           <apply>
            <minus></minus>
            <ci>λ</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <divide></divide>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>α</ci>
             <cn type="integer">1</cn>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>s</ci>
             <ci>κ</ci>
            </apply>
           </apply>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>α</ci>
             <ci>m</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>s</ci>
             <ci>κ</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{H}^{(\lambda)}(X)=\frac{\sum_{m=1}^{n}\left[\prod_{\kappa=0}^{\lambda-1}(%
\alpha_{m}-s_{\kappa})\right]^{-1}\,P_{m}(X)}{\sum_{m=1}^{n}\left[\prod_{%
\kappa=0}^{\lambda-1}(\alpha_{m}-s_{\kappa})\right]^{-1}}=\frac{P_{1}(X)+\sum_%
{m=2}^{n}\left[\prod_{\kappa=0}^{\lambda-1}\frac{\alpha_{1}-s_{\kappa}}{\alpha%
_{m}-s_{\kappa}}\right]\,P_{m}(X)}{1+\sum_{m=1}^{n}\left[\prod_{\kappa=0}^{%
\lambda-1}\frac{\alpha_{1}-s_{\kappa}}{\alpha_{m}-s_{\kappa}}\right]}\ .
  </annotation>
 </semantics>
</math>

</p>
<h3 id="convergence-orders">Convergence orders</h3>

<p>If the condition 

<math display="inline" id="Jenkins–Traub_algorithm:42">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>-</mo>
   <msub>
    <mi>s</mi>
    <mi>κ</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mo><</mo>
   <mi>min</mi>
   <mmultiscripts>
    <mo stretchy="false">|</mo>
    <mprescripts></mprescripts>
    <mrow>
     <mi>m</mi>
     <mo>=</mo>
     <mrow>
      <mn>2</mn>
      <mo>,</mo>
      <mn>3</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </mrow>
    <none></none>
   </mmultiscripts>
   <msub>
    <mi>α</mi>
    <mi>m</mi>
   </msub>
   <mo>-</mo>
   <msub>
    <mi>s</mi>
    <mi>κ</mi>
   </msub>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>κ</ci>
    </apply>
    <ci>normal-|</ci>
    <lt></lt>
    <min></min>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-|</ci>
     <apply>
      <eq></eq>
      <ci>m</ci>
      <list>
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
       <ci>normal-…</ci>
       <ci>n</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>m</ci>
    </apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>κ</ci>
    </apply>
    <ci>normal-|</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\alpha_{1}-s_{\kappa}|<\min{}_{m=2,3,\dots,n}|\alpha_{m}-s_{\kappa}|
  </annotation>
 </semantics>
</math>

 holds for almost all iterates, the normalized H polynomials will converge at least geometrically towards 

<math display="inline" id="Jenkins–Traub_algorithm:43">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}(X)
  </annotation>
 </semantics>
</math>

.</p>

<p>Under the condition that</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:44">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">|</mo>
   <mo><</mo>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>α</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">|</mo>
   <mo>=</mo>
   <mi>min</mi>
   <mmultiscripts>
    <mo stretchy="false">|</mo>
    <mprescripts></mprescripts>
    <mrow>
     <mi>m</mi>
     <mo>=</mo>
     <mrow>
      <mn>2</mn>
      <mo>,</mo>
      <mn>3</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </mrow>
    <none></none>
   </mmultiscripts>
   <msub>
    <mi>α</mi>
    <mi>m</mi>
   </msub>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-|</ci>
    <lt></lt>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-|</ci>
    <eq></eq>
    <min></min>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-|</ci>
     <apply>
      <eq></eq>
      <ci>m</ci>
      <list>
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
       <ci>normal-…</ci>
       <ci>n</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>m</ci>
    </apply>
    <ci>normal-|</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\alpha_{1}|<|\alpha_{2}|=\min{}_{m=2,3,\dots,n}|\alpha_{m}|
  </annotation>
 </semantics>
</math>

 one gets the aymptotic estimates for</p>
<ul>
<li>stage 1:

<p>:<math></math></p></li>
</ul>

<p><code> H^{(\lambda)}(X)</code><br/>
<code> =P_1(X)+O\left(\left|\frac{\alpha_1}{\alpha_2}\right|^\lambda\right).</code></p>

<p></p>
<ul>
<li>for stage 2, if <em>s</em> is close enough to 

<math display="inline" id="Jenkins–Traub_algorithm:45">
 <semantics>
  <msub>
   <mi>α</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}
  </annotation>
 </semantics>
</math>

:

<p>:<math></math></p></li>
</ul>

<p><code> H^{(\lambda)}(X)</code><br/>
<code> =P_1(X)</code><br/>
<code>   +O\left(</code><br/>
<code>     \left|\frac{\alpha_1}{\alpha_2}\right|^M</code><br/>
<code>       \cdot</code><br/>
<code>     \left|\frac{\alpha_1-s}{\alpha_2-s}\right|^{\lambda-M}\right)</code></p>

<p></p>

<p>*:and</p>

<p>*

<math display="block" id="Jenkins–Traub_algorithm:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mover accent="true">
         <mi>H</mi>
         <mo stretchy="false">¯</mo>
        </mover>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>λ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mi mathvariant="normal">…</mi>
        <mo>⋅</mo>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <msub>
           <mi>α</mi>
           <mn>1</mn>
          </msub>
          <mo>-</mo>
          <mi>s</mi>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>s</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-¯</ci>
         <ci>H</ci>
        </apply>
        <ci>λ</ci>
       </apply>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <ci>normal-⋅</ci>
       <ci>normal-…</ci>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s-\frac{P(s)}{\bar{H}^{(\lambda)}(s)}=\alpha_{1}+O\left(\ldots\cdot|\alpha_{1}%
-s|\right).
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>and for stage 3:

<p>:<math></math></p></li>
</ul>

<p><code> H^{(\lambda)}(X)</code><br/>
<code> =P_1(X)</code><br/>
<code>   +O\left(\prod_{\kappa=0}^{\lambda-1}</code><br/>
<code>     \left|\frac{\alpha_1-s_\kappa}{\alpha_2-s_\kappa}\right|</code><br/>
<code>    \right)</code></p>

<p></p>

<p>*:and</p>

<p>*

<math display="block" id="Jenkins–Traub_algorithm:47">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mrow>
     <mi>λ</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>λ</mi>
    </msub>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mover accent="true">
        <mi>H</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>λ</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>s</mi>
        <mi>λ</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>α</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
        <mrow>
         <mi>κ</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mrow>
         <mi>λ</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </munderover>
       <mrow>
        <mrow>
         <mo>|</mo>
         <mfrac>
          <mrow>
           <msub>
            <mi>α</mi>
            <mn>1</mn>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>s</mi>
            <mi>κ</mi>
           </msub>
          </mrow>
          <mrow>
           <msub>
            <mi>α</mi>
            <mn>2</mn>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>s</mi>
            <mi>κ</mi>
           </msub>
          </mrow>
         </mfrac>
         <mo>|</mo>
        </mrow>
        <mo>⋅</mo>
        <mfrac>
         <msup>
          <mrow>
           <mo stretchy="false">|</mo>
           <mrow>
            <msub>
             <mi>α</mi>
             <mn>1</mn>
            </msub>
            <mo>-</mo>
            <msub>
             <mi>s</mi>
             <mi>λ</mi>
            </msub>
           </mrow>
           <mo stretchy="false">|</mo>
          </mrow>
          <mn>2</mn>
         </msup>
         <mrow>
          <mo stretchy="false">|</mo>
          <mrow>
           <msub>
            <mi>α</mi>
            <mn>2</mn>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>s</mi>
            <mi>λ</mi>
           </msub>
          </mrow>
          <mo stretchy="false">|</mo>
         </mrow>
        </mfrac>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <apply>
       <plus></plus>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>λ</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-¯</ci>
          <ci>H</ci>
         </apply>
         <apply>
          <plus></plus>
          <ci>λ</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <ci>λ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>O</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <eq></eq>
           <ci>κ</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <ci>λ</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <abs></abs>
          <apply>
           <divide></divide>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>α</ci>
             <cn type="integer">1</cn>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>s</ci>
             <ci>κ</ci>
            </apply>
           </apply>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>α</ci>
             <cn type="integer">2</cn>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>s</ci>
             <ci>κ</ci>
            </apply>
           </apply>
          </apply>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <abs></abs>
            <apply>
             <minus></minus>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>α</ci>
              <cn type="integer">1</cn>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>s</ci>
              <ci>λ</ci>
             </apply>
            </apply>
           </apply>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <abs></abs>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>α</ci>
             <cn type="integer">2</cn>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>s</ci>
             <ci>λ</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\lambda+1}=s_{\lambda}-\frac{P(s)}{\bar{H}^{(\lambda+1)}(s_{\lambda})}=%
\alpha_{1}+O\left(\prod_{\kappa=0}^{\lambda-1}\left|\frac{\alpha_{1}-s_{\kappa%
}}{\alpha_{2}-s_{\kappa}}\right|\cdot\frac{|\alpha_{1}-s_{\lambda}|^{2}}{|%
\alpha_{2}-s_{\lambda}|}\right)
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>giving rise to a higher than quadratic convergence order of 

<math display="inline" id="Jenkins–Traub_algorithm:48">
 <semantics>
  <mrow>
   <msup>
    <mi>ϕ</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mi>ϕ</mi>
   </mrow>
   <mo>≈</mo>
   <mn>2.61</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>ϕ</ci>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <cn type="float">2.61</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi^{2}=1+\phi\approx 2.61
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Jenkins–Traub_algorithm:49">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <msqrt>
       <mn>5</mn>
      </msqrt>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϕ</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">5</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=\tfrac{1}{2}(1+\sqrt{5})
  </annotation>
 </semantics>
</math>

 is the <a href="golden_ratio" title="wikilink">golden ratio</a>.
</dd>
</dl>
<h3 id="interpretation-as-inverse-power-iteration">Interpretation as inverse power iteration</h3>

<p>All stages of the Jenkins–Traub complex algorithm may be represented as the linear algebra problem of determining the eigenvalues of a special matrix. This matrix is the coordinate representation of a linear map in the <em>n</em>-dimensional space of polynomials of degree <em>n</em> − 1 or less. The principal idea of this map is to interpret the factorization</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>-</mo>
       <msub>
        <mi>α</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>P</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <minus></minus>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)=(X-\alpha_{1})\cdot P_{1}(X)
  </annotation>
 </semantics>
</math>

 with a root 

<math display="inline" id="Jenkins–Traub_algorithm:51">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>∈</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\C</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <mtext>\C</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}\in\C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Jenkins–Traub_algorithm:52">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>X</mi>
      <mo>-</mo>
      <msub>
       <mi>α</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>X</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}(X)=P(X)/(X-\alpha_{1})
  </annotation>
 </semantics>
</math>

 the remaining factor of degree <em>n</em> − 1 as the eigenvector equation for the multiplication with the variable <em>X</em>, followed by remainder computation with divisor <em>P</em>(<em>X</em>),</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>M</mi>
      <mi>X</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>X</mi>
        <mo>⋅</mo>
        <mi>H</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>X</ci>
     </apply>
     <ci>H</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>X</ci>
       <ci>H</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{X}(H)=(X\cdot H(X))\bmod P(X)\,.
  </annotation>
 </semantics>
</math>

 This maps polynomials of degree at most <em>n</em> − 1 to polynomials of degree at most <em>n</em> − 1. The eigenvalues of this map are the roots of <em>P</em>(<em>X</em>), since the eigenvector equation reads</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:54">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>M</mi>
        <mi>X</mi>
       </msub>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mi>α</mi>
         <mo>⋅</mo>
         <mi>i</mi>
        </mrow>
        <mi>d</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>X</mi>
         <mo>-</mo>
         <mi>α</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>⋅</mo>
       <mi>H</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mpadded width="+1.7pt">
      <mi>P</mi>
     </mpadded>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>X</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <ci>α</ci>
         <ci>i</ci>
        </apply>
        <ci>d</ci>
       </apply>
      </apply>
      <ci>H</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <minus></minus>
        <ci>X</ci>
        <ci>α</ci>
       </apply>
       <ci>H</ci>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=(M_{X}-\alpha\cdot id)(H)=((X-\alpha)\cdot H)\bmod P\,,
  </annotation>
 </semantics>
</math>

 which implies that 

<math display="inline" id="Jenkins–Traub_algorithm:55">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>-</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mi>H</mi>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
   <mi>C</mi>
   <mo>⋅</mo>
   <mi>P</mi>
   <mo stretchy="false">(</mo>
   <mi>X</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <minus></minus>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">H</csymbol>
    <ci>normal-)</ci>
    <eq></eq>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">X</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X-\alpha)\cdot H)=C\cdot P(X)
  </annotation>
 </semantics>
</math>

, that is, 

<math display="inline" id="Jenkins–Traub_algorithm:56">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>X</mi>
    <mo>-</mo>
    <mi>α</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>X</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X-\alpha)
  </annotation>
 </semantics>
</math>

 is a linear factor of <em>P</em>(<em>X</em>). In the monomial basis the linear map 

<math display="inline" id="Jenkins–Traub_algorithm:57">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>X</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{X}
  </annotation>
 </semantics>
</math>

 is represented by a <a href="companion_matrix" title="wikilink">companion matrix</a> of the polynomial <em>P</em>, as</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:58">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>M</mi>
      <mi>X</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>m</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>H</mi>
          <mrow>
           <mi>m</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>P</mi>
           <mi>m</mi>
          </msub>
          <msub>
           <mi>H</mi>
           <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mi>X</mi>
        <mi>m</mi>
       </msup>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mn>0</mn>
      </msub>
      <mpadded width="+1.7pt">
       <msub>
        <mi>H</mi>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mpadded>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>X</ci>
     </apply>
     <ci>H</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <apply>
          <minus></minus>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>P</ci>
          <ci>m</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{X}(H)=\sum_{m=1}^{n-1}(H_{m-1}-P_{m}H_{n-1})X^{m}-P_{0}H_{n-1}\,,
  </annotation>
 </semantics>
</math>

 the resulting coefficient matrix is</p>

<p>

<math display="block" id="Jenkins–Traub_algorithm:59">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">…</mi>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <msub>
           <mi>P</mi>
           <mn>0</mn>
          </msub>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">…</mi>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <msub>
           <mi>P</mi>
           <mn>1</mn>
          </msub>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">…</mi>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <msub>
           <mi>P</mi>
           <mn>2</mn>
          </msub>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋮</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋮</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋱</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋮</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋮</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">…</mi>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <msub>
           <mi>P</mi>
           <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mpadded>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
      <ci>normal-⋱</ci>
      <ci>normal-⋮</ci>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\begin{pmatrix}0&0&\dots&0&-P_{0}\\
1&0&\dots&0&-P_{1}\\
0&1&\dots&0&-P_{2}\\
\vdots&\vdots&\ddots&\vdots&\vdots\\
0&0&\dots&1&-P_{n-1}\end{pmatrix}\,.
  </annotation>
 </semantics>
</math>

 To this matrix the <a href="inverse_power_iteration" title="wikilink">inverse power iteration</a> is applied in the three variants of no shift, constant shift and generalized Rayleigh shift in the three stages of the algorithm. It is more efficient to perform the linear algebra operations in polynomial arithmetic and not by matrix operations, however, the properties of the inverse power iteration remain the same.</p>
<h2 id="real-coefficients">Real coefficients</h2>

<p>The Jenkins–Traub algorithm described earlier works for polynomials with complex coefficients. The same authors also created a three-stage algorithm for polynomials with real coefficients. See Jenkins and Traub <a href="http://links.jstor.org/sici?sici=0036-1429%28197012%297%3A4%3C545%3AATAFRP%3E2.0.CO%3B2-J">A Three-Stage Algorithm for Real Polynomials Using Quadratic Iteration</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The algorithm finds either a linear or quadratic factor working completely in real arithmetic. If the complex and real algorithms are applied to the same real polynomial, the real algorithm is about four times as fast. The real algorithm always converges and the rate of convergence is greater than second order.</p>
<h2 id="a-connection-with-the-shifted-qr-algorithm">A connection with the shifted QR algorithm</h2>

<p>There is a surprising connection with the shifted QR algorithm for computing matrix eigenvalues. See Dekker and Traub <a href="http://linkinghub.elsevier.com/retrieve/pii/0024379571900358">The shifted QR algorithm for Hermitian matrices</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Again the shifts may be viewed as Newton-Raphson iteration on a sequence of rational functions converging to a first degree polynomial.</p>
<h2 id="software-and-testing">Software and testing</h2>

<p>The software for the Jenkins–Traub algorithm was published as Jenkins and Traub [<a class="uri" href="http://portal.acm.org/citation.cfm?id=361262&amp;coll">http://portal.acm.org/citation.cfm?id=361262&amp;coll;</a>;=portal&amp;dl;=ACM Algorithm 419: Zeros of a Complex Polynomial].<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The software for the real algorithm was published as Jenkins [<a class="uri" href="http://portal.acm.org/citation.cfm?id=355643&amp;coll">http://portal.acm.org/citation.cfm?id=355643&amp;coll;</a>;=ACM&amp;dl;=ACM Algorithm 493: Zeros of a Real Polynomial].<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>The methods have been extensively tested by many people. As predicted they enjoy faster than quadratic convergence for all distributions of zeros.</p>

<p>However there are polynomials which can cause loss of precision as illustrated by the following example. The polynomial has all its zeros lying on two half-circles of different radii. <a href="James_H._Wilkinson" title="wikilink">Wilkinson</a> recommends that it is desirable for stable deflation that smaller zeros be computed first. The second-stage shifts are chosen so that the zeros on the smaller half circle are found first. After deflation the polynomial with the zeros on the half circle is known to be ill-conditioned if the degree is large; see Wilkinson,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> p. 64. The original polynomial was of degree 60 and suffered severe deflation instability.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://math.fullerton.edu/mathews/n2003/jenkinstraub/JenkinsTraubBib/Links/JenkinsTraubBib_lnk_2.html">Additional Bibliography for the Jenkins–Traub Method</a></li>
<li><a href="http://math.fullerton.edu/mathews/n2003/jenkinstraub/JenkinsTraubBib/Links/JenkinsTraubBib_lnk_1.html">Internet Resources for the Jenkins–Traub Method</a></li>
<li><a href="http://www.hvks.com/Numerical/winsolve.html">A free downloadable Windows application using the Jenkins–Traub Method for polynomials with real and complex coefficients</a></li>
<li><a href="http://www.novanumeric.com/samples.php?CalcName=Roots">Online Calculator</a> Online Polynomial Calculator using the Jenkins Traub procedure</li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Press, W. H., Teukolsky, S. A., Vetterling, W. T. and Flannery, B. P. (2007), Numerical Recipes: The Art of Scientific Computing, 3rd ed., Cambridge University Press, page 470.<a href="#fnref1">↩</a></li>
<li id="fn2">Jenkins, M. A. and Traub, J. F. (1970), <a href="http://www.springerlink.com/content/q6w17w30035r2152/?p=ae17d723839045be82d270b45363625fπ=1">A Three-Stage Variables-Shift Iteration for Polynomial Zeros and Its Relation to Generalized Rayleigh Iteration</a>, Numer. Math. 14, 252–263.<a href="#fnref2">↩</a></li>
<li id="fn3">Ralston, A. and Rabinowitz, P. (1978), A First Course in Numerical Analysis, 2nd ed., McGraw-Hill, New York.<a href="#fnref3">↩</a></li>
<li id="fn4">Traub, J. F. (1966), <a href="http://links.jstor.org/sici?sici=0025-5718(196601)20%3A93%3C113%3AACOGCI%3E2.0.CO%3B2-3">A Class of Globally Convergent Iteration Functions for the Solution of Polynomial Equations</a>, Math. Comp., 20(93), 113–138.<a href="#fnref4">↩</a></li>
<li id="fn5">Jenkins, M. A. and Traub, J. F. (1970), <a href="http://links.jstor.org/sici?sici=0036-1429%28197012%297%3A4%3C545%3AATAFRP%3E2.0.CO%3B2-J">A Three-Stage Algorithm for Real Polynomials Using Quadratic Iteration</a>, SIAM J. Numer. Anal., 7(4), 545–566.<a href="#fnref5">↩</a></li>
<li id="fn6">Dekker, T. J. and Traub, J. F. (1971), <a href="http://linkinghub.elsevier.com/retrieve/pii/0024379571900358">The shifted QR algorithm for Hermitian matrices</a>, Lin. Algebra Appl., 4(2), 137–154.<a href="#fnref6">↩</a></li>
<li id="fn7">Jenkins, M. A. and Traub, J. F. (1972), [<a class="uri" href="http://portal.acm.org/citation.cfm?id=361262&amp;coll">http://portal.acm.org/citation.cfm?id=361262&amp;coll;</a>;=portal&amp;dl;=ACM Algorithm 419: Zeros of a Complex Polynomial], Comm. ACM, 15, 97–99.<a href="#fnref7">↩</a></li>
<li id="fn8">Jenkins, M. A. (1975), [<a class="uri" href="http://portal.acm.org/citation.cfm?id=355643&amp;coll">http://portal.acm.org/citation.cfm?id=355643&amp;coll;</a>;=ACM&amp;dl;=ACM Algorithm 493: Zeros of a Real Polynomial], ACM TOMS, 1, 178–189.<a href="#fnref8">↩</a></li>
<li id="fn9">Wilkinson, J. H. (1963), Rounding Errors in Algebraic Processes, Prentice Hall, Englewood Cliffs, N.J.<a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
