<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="632">Hexagonal sampling</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hexagonal sampling</h1>
<hr/>

<p>A multidimensional signal is a function of M independent variables where 

<math display="inline" id="Hexagonal_sampling:0">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\geq 2
  </annotation>
 </semantics>
</math>

. Real world signals, which are generally continuous time signals, have to be discretized (sampled) in order to ensure that <a href="digital_systems" title="wikilink">digital systems</a> can be used to process the signals. It is during this process of discretization where <a href="sample_(graphics)" title="wikilink">sampling</a> comes into picture. Although there are many ways of obtaining a discrete representation of a continuous time signal, periodic sampling is by far the simplest scheme. Theoretically, sampling can be performed with respect to any set of points. But practically, sampling is carried out with respect to a set of points that have a certain algebraic structure. Such structures are called <a href="lattice_(order)" title="wikilink">lattices</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Mathematically, the process of sampling an N-dimensional signal can be written as:-</p>

<p>

<math display="block" id="Hexagonal_sampling:1">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>t</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>.</mo>
    <mover accent="true">
     <mi>n</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">w</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-.</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(\hat{t})=w(V.\hat{n})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Hexagonal_sampling:2">
 <semantics>
  <mover accent="true">
   <mi>t</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{t}
  </annotation>
 </semantics>
</math>

 is continuous domain M-dimensional vector (M-D) that is being sampled, 

<math display="inline" id="Hexagonal_sampling:3">
 <semantics>
  <mover accent="true">
   <mi>n</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{n}
  </annotation>
 </semantics>
</math>

 is an M-dimensional integer vector corresponding to indices of a sample, and <em>V</em> is an N X N Sampling Matrix.</p>
<h2 id="motivation">Motivation</h2>

<p>Multidimensional sampling provides the opportunity to look at digital methods to process signals. Some of the advantages of processing signals in the digital domain include flexibility via programmable <a href="Digital_signal_processing" title="wikilink">DSP</a> operations, signal storage without the loss of <a class="uri" href="fidelity" title="wikilink">fidelity</a>, opportunity for encryption in communication, lower sensitivity to hardware tolerances. Thus, digital methods are simultaneously both powerful and flexible. In many applications, they act as less expensive alternatives to their analog counterparts. Sometimes, the algorithms implemented using digital hardware are so complex that they have no analog counterparts. Multidimensional digital signal processing deals with processing signals represented as multidimensional arrays such as 2-D sequences or sampled images <a href="http://www.dsp-book.narod.ru/DSPMW/04.PDF">1</a>. Processing these signals in the digital domain permits the use of digital hardware where in signal processing operations are specified by algorithms. As real world signals are continuous time signals, multidimensional sampling plays a crucial role in discretizing the real world signals. The discrete time signals are in turn processed using digital hardware to extract information from the signal.</p>
<h2 id="preliminaries">Preliminaries</h2>
<h3 id="region-of-support">Region of Support</h3>

<p>The region outside of which the samples of the signal take zero values is known as the Region of support (ROS). From the definition, it is clear that the region of support of a signal is not unique.</p>
<h3 id="fourier-transform">Fourier transform</h3>

<p>The <a href="Fourier_transform" title="wikilink">Fourier transform</a> is a tool that allows us to simplify mathematical operations performed on the signal. The transform basically represents any signal as a weighted combination of <a class="uri" href="sinusoids" title="wikilink">sinusoids</a>. The Fourier and the inverse Fourier transform of an M-dimensional signal can be defined as follows:-</p>

<p>

<math display="block" id="Hexagonal_sampling:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi mathvariant="normal">Ω</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="-1.7pt">
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mrow>
       <mo>+</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </msubsup>
    </mpadded>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>a</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>t</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>j</mi>
        <msup>
         <mover accent="true">
          <mi mathvariant="normal">Ω</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mi>T</mi>
        </msup>
        <mi>t</mi>
       </mrow>
      </mrow>
     </msup>
     <mover accent="true">
      <mrow>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <ci>normal-^</ci>
      <ci>normal-Ω</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>j</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>normal-Ω</ci>
          </apply>
          <ci>T</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{a}(\hat{\Omega})=\int_{-\infty}^{+\infty}\!x_{a}({\hat{t}})e^{-j\hat{\Omega%
}^{T}t}\hat{dt}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Hexagonal_sampling:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>t</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>π</mi>
       <mi>M</mi>
      </msup>
     </mrow>
    </mfrac>
    <mrow>
     <mpadded width="-1.7pt">
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
       <mrow>
        <mo>+</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </msubsup>
     </mpadded>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi mathvariant="normal">Ω</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mi>e</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>j</mi>
          <msup>
           <mover accent="true">
            <mi mathvariant="normal">Ω</mi>
            <mo stretchy="false">^</mo>
           </mover>
           <mi>T</mi>
          </msup>
          <mi>t</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
      </mpadded>
      <mi mathvariant="normal">d</mi>
      <mover accent="true">
       <mi mathvariant="normal">Ω</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <ci>normal-^</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>π</ci>
        <ci>M</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <infinity></infinity>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>normal-Ω</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>normal-Ω</ci>
          </apply>
          <ci>T</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>normal-d</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>normal-Ω</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{a}(\hat{t})=\frac{1}{2\pi^{M}}\int_{-\infty}^{+\infty}\!X(\hat{\Omega})e^{(%
j\hat{\Omega}^{T}t)}\,\mathrm{d}\hat{\Omega}
  </annotation>
 </semantics>
</math>

 The cap symbol <strong>^</strong> indicates that the operation is performed on vectors. The Fourier transform of the sampled signal is observed to be a periodic extension of the continuous time Fourier transform of the signal. This is mathematically represented as:-</p>

<p>

<math display="block" id="Hexagonal_sampling:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>d</mi>
       <mi>e</mi>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>V</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mfrac>
    <mrow>
     <mpadded width="-1.7pt">
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>k</mi>
      </munder>
     </mpadded>
     <mrow>
      <msub>
       <mi>X</mi>
       <mi>a</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mover accent="true">
         <mi mathvariant="normal">Ω</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mo>-</mo>
        <mrow>
         <mi>U</mi>
         <mi>k</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>e</ci>
        <ci>t</ci>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <ci>normal-^</ci>
         <ci>normal-Ω</ci>
        </apply>
        <apply>
         <times></times>
         <ci>U</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(\omega)=\frac{1}{|det(V)|}\sum_{k}\!X_{a}(\hat{\Omega}-Uk)
  </annotation>
 </semantics>
</math>

 where <big><strong>ω =ṼΏ</strong></big> and <em>U</em> is the periodicity matrix defined as <big><strong>U=2πṼ</strong></big> (The symbol <strong>~</strong> indicates matrix transpose). Thus sampling in the spatial domain results in <a class="uri" href="periodicity" title="wikilink">periodicity</a> in the Fourier domain.</p>
<h3 id="aliasing">Aliasing</h3>

<p> A <a href="band_limited" title="wikilink">band limited</a> signal may be periodically replicated in many ways. If the replication results in an overlap between replicated regions, the signal suffers from <a class="uri" href="aliasing" title="wikilink">aliasing</a>. Under such conditions, a continuous time signal cannot be perfectly recovered from its samples. Thus in order to ensure perfect recovery of the continuous signal, there must be zero overlap <a href="Multidimensional_sampling" title="wikilink">Multidimensional sampling</a> of the replicated regions in the transformed domain. As in the case of 1-dimensional signals, <a class="uri" href="aliasing" title="wikilink">aliasing</a> can be prevented if the continuous time signal is sampled at an adequate sufficiently high rate.</p>
<h3 id="sampling-density">Sampling density</h3>

<p>It is a measure of the number of samples per unit area. It is defined as:</p>

<p>

<math display="block" id="Hexagonal_sampling:7">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>.</mo>
   <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>d</mi>
       <mi>e</mi>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>V</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>d</mi>
       <mi>e</mi>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>U</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mn>4</mn>
      <msup>
       <mi>π</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <ci>S</ci>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <ci>D</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <ci>d</ci>
         <ci>e</ci>
         <ci>t</ci>
         <ci>V</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <divide></divide>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <ci>d</ci>
         <ci>e</ci>
         <ci>t</ci>
         <ci>U</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>π</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S.D=\frac{1}{|det(V)|}=\frac{|det(U)|}{4\pi^{2}}
  </annotation>
 </semantics>
</math>

. The minimum number of samples per unit area required to completely recover the continuous time signal is termed as optimal sampling density. In applications where memory or processing time are limited, emphasis must be given to minimizing the number of samples required to represent the signal completely.</p>
<h2 id="existing-approaches">Existing Approaches</h2>

<p>For a bandlimited waveform, there are an infinite number the signal can be sampled without producing aliases in the Fourier domain . But only two strategies are commonly used: rectangular sampling and hexagonal sampling.</p>
<h3 id="rectangular-and-hexagonal-sampling">Rectangular and Hexagonal sampling</h3>

<p> In Rectangular sampling, a 2-dimensional signal, for example, is sampled according to the following V matrix:-</p>

<p>

<math display="block" id="Hexagonal_sampling:8">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>r</mi>
     <mi>e</mi>
     <mi>c</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>T</mi>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>T</mi>
        <mn>2</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>e</ci>
      <ci>c</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <times></times>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{rect}=\begin{bmatrix}T1&0\\
0&T2\end{bmatrix}
  </annotation>
 </semantics>
</math>

 where <em>T1</em> and <em>T2</em> are the sampling periods along the horizontal and vertical direction respectively.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p> In hexagonal sampling, the <em>V</em> matrix assumes the following general form:-</p>

<p>

<math display="block" id="Hexagonal_sampling:9">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>h</mi>
     <mi>e</mi>
     <mi>x</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>T</mi>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>T</mi>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>T</mi>
        <mn>2</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>T</mi>
         <mn>2</mn>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>e</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>T</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{hex}=\begin{bmatrix}T1&T1\\
T2&-T2\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The difference in the efficiency of the two schemes is highlighted using a bandlimited signal with a circular region of support of radius R. The circle can be inscribed in a square of length 2R or a regular hexagon of length 

<math display="inline" id="Hexagonal_sampling:10">
 <semantics>
  <mfrac>
   <mrow>
    <mn>2</mn>
    <mi>R</mi>
   </mrow>
   <mrow>
    <msqrt>
     <mo stretchy="false">(</mo>
    </msqrt>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>R</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <apply>
      <root></root>
      <ci>normal-(</ci>
     </apply>
     <cn type="integer">3</cn>
     <ci>normal-)</ci>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{2R}{\sqrt{(}3)}
  </annotation>
 </semantics>
</math>

 . Consequently, the region of support is now transformed into a square and a hexagon respectively. If these regions are periodically replicated in the frequency domain such that there is zero overlap between any two regions, then by periodically replicating the square region of support, we effectively sample the continuous signal on a rectangular lattice. Similarly periodic replication of the hexagonal region of support maps to sampling the continuous signal on a hexagonal lattice.</p>

<p>From U, the periodicity matrix, we can calculate the optimal sampling density for both the rectangular and hexagonal schemes. It is found that in order to completely recover the circularly band-limited signal, the hexagonal sampling scheme requires 13.4% fewer samples than the rectangular sampling scheme. The reduction may appear to be of little significance for a 2-dimensional signal. But as the dimensionality of the signal increases, the efficiency of the hexagonal sampling scheme will become far more evident. For instance, the reduction achieved for an 8-dimensional signal is 93.8%. To highlight the importance of the obtained result <a href="http://www.springerreference.com/docs/html/chapterdbid/318221.html">2</a>, try and visualize an image as a collection of infinite number of samples. The primary entity responsible for vision, i.e. the <a href="photoreceptor_cell" title="wikilink">photoreceptors</a> (rods and cones) are present on the <a class="uri" href="retina" title="wikilink">retina</a> of all mammals.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> These cells are not arranged in rows and columns. By adapting a hexagonal sampling scheme, our eyes are able to process images much more efficiently. The importance of hexagonal sampling lies in the fact that the photoreceptors of the human vision system lie on a hexagonal sampling lattice and, thus, perform hexagonal sampling <a href="http://hyperphysics.phy-astr.gsu.edu/hbase/vision/rodcone.html">3</a>. In fact, it can be shown that the hexagonal sampling scheme is the optimal sampling scheme for a circularly band-limited signal.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="applications">Applications</h2>
<h3 id="aliasing-effects-minimized-by-the-use-of-optimal-sampling-grids">Aliasing effects minimized by the use of optimal sampling grids</h3>

<p>Recent advances in the <a href="Charge-coupled_device" title="wikilink">CCD</a> technology has made hexagonal sampling feasible for real life applications. Historically, because of technology constraints, detector arrays were implemented only on 2-dimensional rectangular sampling lattices with rectangular shape detectors. But the super [CCD] detector introduced by <strong>Fuji</strong> has an octagonal shaped pixel in a hexagonal grid. Theoretically, the performance of the detector was greatly increased by introducing an octagonal pixel. The number of pixels required to represent the sample was reduced and there was significant improvement in the <a href="Signal_to_Noise_Ratio" title="wikilink">Signal to Noise Ratio</a> (SNR) when compared with that of a rectangular pixel.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> But the drawback of using hexagonal pixels is that the associated <a href="Microlens" title="wikilink">fill factor</a> will be less than 82%. An alternative method would be to interpolate hexagonal pixels in such a manner that we ultimately end up with a rectangular grid. The <a href="SPOT_(satellite)" title="wikilink">Spot</a>5 <a class="uri" href="satellite" title="wikilink">satellite</a> incorporates a similar technique where two identical linear CCD’s transmit two <a class="uri" href="quasi" title="wikilink">quasi</a>-identical images that are shifted by half a pixel. On interpolating the two images and processing them, the functioning of a detector with a hexagonal pixel is mimicked.</p>
<h3 id="hexagonal-structure-for-intelligent-vision">Hexagonal structure for Intelligent vision</h3>

<p>One of the major challenges encountered in the field of computer graphics is to represent the real world continuous signal as a discrete set of points on the physical screen. It has been long known that hexagonal sampling grids have several benefits compared to rectangular grids. <strong>Peterson and Middleton</strong> investigated sampling and reconstruction of wave number limited M dimensional functions and came to the conclusion that the optimal sampling lattice, in general, is not hexagonal.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <em>' Russell M. Mersereau</em>' developed hexagonal discrete Fourier transform (<a href="Discrete_Fourier_transform" title="wikilink">DFT</a>) and hexagonal finite extent impulse response filters. He was able to show that for circularly bandlimited signals, hexagonal sampling is more efficient than rectangular sampling.  One of the unique features of a hexagonal sampling grid is that its Fourier transform is still hexagonal. There is also an inverse relationship between the distance between successive rows and columns (assuming the samples are located at the centre of the hexagon). This inverse relationship plays a huge role in minimizing aliasing and maximizing the minimum sampling density. <a href="Quantization_error" title="wikilink">Quantization error</a> is bound to be present when discretizing continuous real world signals. Experiments have been performed to determine which detector configuration will yield the least <a href="quantization_error" title="wikilink">quantization error</a>. Hexagonal spatial sampling was found to yield the least quantization error for a given <a href="Sensor_resolution" title="wikilink">resolution</a> of the <a class="uri" href="sensor" title="wikilink">sensor</a>.</p>

<p><strong>Consistent connectivity of hexagonal grids</strong>: In a hexagonal grid, we can define only a background of 6 neighborhood samples. However in a square grid, we can define a background of 4 or 8 neighborhood samples <a href="http://www.cs.sfu.ca/~torsten/Teaching/Cmpt888/Literature/petersen62.pdf">4</a> (if diagonal connectivity is permitted). Because of the absence of a such a choice in Hexagonal grids, efficient algorithms can be designed. Consistent connectivity is also responsible for better <a href="angular_resolution" title="wikilink">angular resolution</a>. This is why hexagonal lattice is much better at representing curved objects than the rectangular lattice. Despite of these several advantages, hexagonal grids have not been used practically in computer vision to its maximum potential because of the lack of hardware to process, capture and display hexagonal based images. As highlighted earlier with the <a href="SPOT_(satellite)" title="wikilink">Spot</a> 5 <a class="uri" href="satellite" title="wikilink">satellite</a>, one of the methods being looked at to overcome this hardware difficulty is to mimic hexagonal pixels using square pixels.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Computer_graphics" title="wikilink">Category:Computer graphics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Ton Kalker,"On Multidimensional Sampling", Philip Research Laboratories, Eindhoven, Chapter 4, Section 4.2<a href="#fnref1">↩</a></li>
<li id="fn2">Dan E. Dudgeon and Russell M. Mersereau, "Multidimensional Digital Signal Processing", Prentice Hall, 1984, Chapter 1, Pg 43-44,<a href="#fnref2">↩</a></li>
<li id="fn3">D.Phil Jonathan, T. Erichsen and J. Margaret Woodhouse,"Human and Animal Vision", Cardiff School of Optometry and Vision Sciences, Cardiff University, Cardiff, UK<a href="#fnref3">↩</a></li>
<li id="fn4">D. P. Petersen and D. Middleton, "Sampling and Reconstruction of Wave-Number-Limited Functions in N-Dimensional Euclidean Spaces", Information and Control, vol. 5, pp. 279–323, 1962.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
