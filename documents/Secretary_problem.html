<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1867">Secretary problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Secretary problem</h1>
<hr/>

<p>The <strong>secretary problem</strong> is one of many names for a famous problem of the <a href="optimal_stopping" title="wikilink">optimal stopping</a> theory. The problem has been studied extensively in the fields of <a href="applied_probability" title="wikilink">applied probability</a>, <a class="uri" href="statistics" title="wikilink">statistics</a>, and <a href="decision_theory" title="wikilink">decision theory</a>. It is also known as the <strong>marriage problem</strong>, the <strong>sultan's dowry problem</strong>, the <strong>fussy suitor problem</strong>, <strong>the googol game</strong>, and the <strong>best choice problem</strong>.</p>

<p>The basic form of the problem is the following: imagine an administrator willing to hire the best secretary out of 

<math display="inline" id="Secretary_problem:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 rankable applicants for a position. The applicants are interviewed one by one in random order. A decision about each particular applicant is to be made immediately after the interview. Once rejected, an applicant cannot be recalled. During the interview, the administrator can rank the applicant among all applicants interviewed so far, but is unaware of the quality of yet unseen applicants. The question is about the optimal strategy (<a href="stopping_rule" title="wikilink">stopping rule</a>) to maximize the probability of selecting the best applicant. If the decision can be deferred to the end, this can be solved by the simple maximum <a href="selection_algorithm" title="wikilink">selection algorithm</a> of tracking the running maximum (and who achieved it), and selecting the overall maximum at the end. The difficulty is that the decision must be made immediately.</p>

<p>The problem has an elegant solution. The optimal stopping rule prescribes always rejecting the first 

<math display="inline" id="Secretary_problem:1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/e
  </annotation>
 </semantics>
</math>

 applicants after the interview (where <em>e</em> is the <a href="e_(mathematical_constant)" title="wikilink">base of the natural logarithm</a>) and then stopping at the first applicant who is better than every applicant interviewed so far (or continuing to the last applicant if this never occurs). Sometimes this strategy is called the 

<math display="inline" id="Secretary_problem:2">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/e
  </annotation>
 </semantics>
</math>

 stopping rule, because the probability of stopping at the best applicant with this strategy is about 

<math display="inline" id="Secretary_problem:3">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/e
  </annotation>
 </semantics>
</math>


 already for moderate values of 

<math display="inline" id="Secretary_problem:4">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. One reason why the secretary problem has received so much attention is that the optimal policy for the problem (the stopping rule) is simple and selects the single best candidate about 37% of the time, irrespective of whether there are 100 or 100 million applicants. In fact, for any value of 

<math display="inline" id="Secretary_problem:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 the probability of selecting the best candidate when using the optimal policy is at least 

<math display="inline" id="Secretary_problem:6">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/e
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="formulation">Formulation</h2>

<p>Although there are many variations, the basic problem can be stated as follows:</p>
<ol>
<li>There is a single secretarial position to fill.</li>
<li>There are <em>n</em> applicants for the position, and the value of <em>n</em> is known.</li>
<li>The applicants, if seen altogether, can be ranked from best to worst unambiguously.</li>
<li>The applicants are interviewed sequentially in random order, with each order being equally likely.</li>
<li>Immediately after an interview, the interviewed applicant is either accepted or rejected, and the decision is irrevocable.</li>
<li>The decision to accept or reject an applicant can be based only on the relative ranks of the applicants interviewed so far.</li>
<li>The objective of the general solution is to have the highest probability of selecting the best applicant of the whole group. This is the same as maximizing the expected payoff, with payoff defined to be one for the best applicant and zero otherwise.</li>
</ol>

<p>Terminology: A <em>candidate</em> is defined as an applicant who, when interviewed, is better than all the applicants interviewed previously. <em>Skip</em> is used to mean "reject immediately after the interview".</p>

<p>Clearly, since the objective in the problem is to select the single best applicant, only candidates will be considered for acceptance. The "candidate" in this context corresponds to the concept of record in permutation.</p>
<h2 id="deriving-the-optimal-policy">Deriving the optimal policy</h2>

<p>The optimal policy for the problem is a <a href="stopping_rule" title="wikilink">stopping rule</a>. Under it, the interviewer rejects the first <em>r</em> − 1 applicants (let applicant <em>M</em> be the best applicant among these <em>r</em> − 1 applicants), and then selects the first subsequent applicant that is better than applicant <em>M</em>. It can be shown that the optimal strategy lies in this class of strategies. For an arbitrary cutoff <em>r</em>, the probability that the best applicant is selected is</p>

<p>

<math display="inline" id="Secretary_problem:7">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(r)
  </annotation>
 </semantics>
</math>


</p>

<p>This sum is obtained by noting that if applicant <em>i</em> is the best applicant, then it is selected if and only if the best applicant among the first <em>i</em> − 1 applicants is among the first <em>r</em> − 1 applicants that were rejected.</p>

<p>Letting <em>n</em> tend to infinity, writing 

<math display="inline" id="Secretary_problem:8">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 as the limit of <em>r</em>/<em>n</em>, using <em>t</em> for <em>i</em>/<em>n</em> and <em>dt</em> for 1/<em>n</em>, the sum can be approximated by the integral</p>

<p>

<math display="block" id="Secretary_problem:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi>x</mi>
       <mn>1</mn>
      </msubsup>
      <mrow>
       <mpadded width="+1.7pt">
        <mfrac>
         <mn>1</mn>
         <mi>t</mi>
        </mfrac>
       </mpadded>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <ci>x</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>t</ci>
        </apply>
        <ci>d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <log></log>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=x\int_{x}^{1}\frac{1}{t}\,dt=-x\log(x).
  </annotation>
 </semantics>
</math>

</p>

<p>Taking the derivative of <em>P</em>(<em>x</em>) with respect to 

<math display="inline" id="Secretary_problem:10">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, setting it to 0, and solving for <em>x</em>, we find that the optimal <em>x</em> is equal to 1/<em>e</em>. Thus, the optimal cutoff tends to <em>n</em>/<em>e</em> as <em>n</em> increases, and the best applicant is selected with probability 1/<em>e</em>.</p>

<p>For small values of <em>n</em>, the optimal <em>r</em> can also be obtained by standard <a href="dynamic_programming" title="wikilink">dynamic programming</a> methods. The optimal thresholds <em>r</em> and probability of selecting the best alternative <em>P</em> for several values of <em>n</em> are shown in the following table.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Secretary_problem:11">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>1</p></th>
<th style="text-align: left;">
<p>2</p></th>
<th style="text-align: left;">
<p>3</p></th>
<th style="text-align: left;">
<p>4</p></th>
<th style="text-align: left;">
<p>5</p></th>
<th style="text-align: left;">
<p>6</p></th>
<th style="text-align: left;">
<p>7</p></th>
<th style="text-align: left;">
<p>8</p></th>
<th style="text-align: left;">
<p>9</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Secretary_problem:12">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Secretary_problem:13">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>1.000</p></td>
<td style="text-align: left;">
<p>0.500</p></td>
<td style="text-align: left;">
<p>0.500</p></td>
<td style="text-align: left;">
<p>0.458</p></td>
<td style="text-align: left;">
<p>0.433</p></td>
<td style="text-align: left;">
<p>0.428</p></td>
<td style="text-align: left;">
<p>0.414</p></td>
<td style="text-align: left;">
<p>0.410</p></td>
<td style="text-align: left;">
<p>0.406</p></td>
</tr>
</tbody>
</table>

<p>The probability of selecting the best applicant in the classical secretary problem converges toward 

<math display="inline" id="Secretary_problem:14">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>e</mi>
   </mrow>
   <mo>≈</mo>
   <mn>0.368</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>e</ci>
    </apply>
    <cn type="float">0.368</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/e\approx 0.368
  </annotation>
 </semantics>
</math>

 .</p>
<h2 id="alternative-solution">Alternative solution</h2>

<p>This problem and several modifications can be solved (including the proof of optimality) in a straightforward manner by the <a href="Odds_algorithm" title="wikilink">Odds algorithm</a> (2000), which also has other applications. Modifications for the secretary problem that can be solved by this algorithm include random availabilities of applicants, more general hypotheses for applicants to be of interest to the decision maker, group interviews for applicants, as well as <em>certain</em> models for a random number of applicants. None of these modifications is treated in this article.</p>
<h2 id="unknown-number-of-applicants">Unknown number of applicants</h2>

<p>A major drawback for applications of the solution of the classical secretary problem is that the number of applicants 

<math display="inline" id="Secretary_problem:15">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 must be known in advance. One way to overcome this problem is to suppose that the number of applicants is a random variable 

<math display="inline" id="Secretary_problem:16">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 with a known distribution of 

<math display="inline" id="Secretary_problem:17">
 <semantics>
  <mrow>
   <mi>P</mi>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>=</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>k</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mn>2</mn>
      <mo>,</mo>
      <mi mathvariant="normal">⋯</mi>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">N</csymbol>
      <eq></eq>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <list>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
       <ci>normal-⋯</ci>
      </list>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(N=k)_{k=1,2,\cdots}
  </annotation>
 </semantics>
</math>

 (Presman and Sonin, 1972). For this model, the optimal solution is in general much harder, however. Moreover, the optimal success probability is now no longer around 1/<em>e</em>. Indeed, it is intuitive that there should be a price to pay for not knowing the number of applicants. However, in this model the price is high. Depending on the choice of the distribution of 

<math display="inline" id="Secretary_problem:18">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, the optimal win probability is typically much lower than 1/<em>e</em> and may even approach zero. Looking for ways to cope with this new problem led to the following approach and result:</p>
<h2 id="e-law-of-best-choice">1/e-law of best choice</h2>

<p>The essence of the model is based on the idea that real-world problems pose themselves in real time and that it is easier to estimate times in which specific events (arrivals of applicants) should occur more likely (if they do) than to estimate the distribution of the number of specific events which will occur. This idea led to the following approach, the so-called <strong>Unified approach</strong> (1984):</p>

<p><strong>The model</strong>: An applicant must be selected on some time interval 

<math display="inline" id="Secretary_problem:19">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi>T</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <ci>T</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,T]
  </annotation>
 </semantics>
</math>

 from an unknown number 

<math display="inline" id="Secretary_problem:20">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 of rankable applicants. The goal is to maximize the probability of selecting only the best under the hypothesis that all arrival orders of different ranks are equally likely. Suppose that all applicants have independently of each other the same arrival time density 

<math display="inline" id="Secretary_problem:21">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Secretary_problem:22">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi>T</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <ci>T</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,T]
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Secretary_problem:23">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 denote the corresponding arrival time distribution function, that is</p>

<p>

<math display="block" id="Secretary_problem:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi>t</mi>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>s</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>s</ci>
      <ci>d</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(t)=\int_{0}^{t}f(s)ds
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Secretary_problem:25">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>t</mi>
   <mo>≤</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="float">0</cn>
     <ci>t</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,0\leq t\leq T
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>1/e-law</strong>: Let 

<math display="inline" id="Secretary_problem:26">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 be such that 

<math display="inline" id="Secretary_problem:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>e</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>τ</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\tau)=1/e.
  </annotation>
 </semantics>
</math>

 Consider the strategy to wait and observe all applicants up to time 

<math display="inline" id="Secretary_problem:28">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 and then to select, if possible, the first candidate after time 

<math display="inline" id="Secretary_problem:29">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 which is better than all preceding ones. Then this strategy, called <em>1/e-strategy</em>, has the following properties:</p>

<p>The <em>1/e-strategy</em></p>
<dl>
<dd>(i) yields for all 

<math display="inline" id="Secretary_problem:30">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 a success probability of at least 1/e,
</dd>
</dl>
<dl>
<dd>(ii) is the unique strategy guaranteeing this lower success probability bound 1/e, and the bound is optimal,
</dd>
</dl>
<dl>
<dd>(iii) selects, if there is at least one applicant, none at all with probability exactly 1/e.
</dd>
</dl>

<p>When the 1/e-law was discovered in 1984 it came as a surprise. The reason was that a value of about 1/e had been considered before as being out of reach in a model for unknown 

<math display="inline" id="Secretary_problem:31">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, whereas now this value was achieved as a lower bound, and this in a model with arguably weaker hypotheses (see e.g. Math. Reviews 85:m).</p>

<p>This law is sometimes confused with the solution for the secretary problem because of the similar role of the number 1/e. Note however, that in the 1/e-law, this role is stronger and more general. The result is also stronger, since it holds for an <strong>unknown</strong> number of applicants and since the model is more tractable for applications.</p>
<h2 id="the-game-of-googol">The game of googol</h2>

<p>According to , the Secretary problem appeared for the first time in print in <a href="Martin_Gardner" title="wikilink">Martin Gardner</a>'s column of Scientific American in 1960. Here is how Martin Gardner formulated the problem: "Ask someone to take as many slips of paper as he pleases, and on each slip write a different positive number. The numbers may range from small fractions of 1 to a number the size of a <em>googol</em> (1 followed by a hundred 0s) or even larger. These slips are turned face down and shuffled over the top of a table. One at a time you turn the slips face up. The aim is to stop turning when you come to the number that you guess to be the largest of the series. You cannot go back and pick a previously turned slip. If you turn over all the slips, then of course you must pick the last one turned."</p>

<p>In the article "Who solved the Secretary problem?"  pointed out that the Secretary problem remained unsolved as it was stated by M. Gardner, that is as a two-person <a href="zero-sum_game" title="wikilink">zero-sum game</a> with two antagonistic players. In this game Alice, the informed player, writes secretly distinct numbers on 

<math display="inline" id="Secretary_problem:32">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 cards. Bob, the stopping player, observes the actual values and can stop turning cards whenever he wants, winning if the last card turned has the overall maximal number. The difference with the basic Secretary problem is that Bob observes the actual values written on the cards, which he can use in his decision procedures. The numbers on cards are analogous to the numerical qualities of applicants in some versions of the Secretary problem. The joint probability distribution of the numbers is under the control of Alice.</p>

<p>Bob wants to guess the maximal number with the highest possible probability, while Alice's goal is to keep this probability as low as possible. It is not optimal for Alice to sample the numbers independently from some fixed distribution, and she can play better by choosing random numbers in some dependent way. For 

<math display="inline" id="Secretary_problem:33">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=2
  </annotation>
 </semantics>
</math>

 Alice has no minimax strategy, which is closely related to a paradox of T. Cover. But for 

<math display="inline" id="Secretary_problem:34">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>2
  </annotation>
 </semantics>
</math>

 the game has a solution: Alice can choose random numbers (which are dependent random variables) in such a way that Bob cannot play better than using the classical stopping strategy based on the relative ranks ().</p>
<h2 id="heuristic-performance">Heuristic performance</h2>

<p>The remainder of the article deals again with the secretary problem for a known number of applicants.</p>
<figure><b>(Figure)</b>
<figcaption>Expected success probabilities for three heuristics.|300px|right|Expected success probabilities for three heuristics.</figcaption>
</figure>

<p>derived the expected success probabilities for several psychologically plausible heuristics that might be employed in the secretary problem. The heuristics they examined were:</p>
<ul>
<li><strong>The cutoff rule (CR):</strong> Do not accept any of the first <em>y</em> applicants; thereafter, select the first encountered candidate (i.e., an applicant with relative rank 1). This rule has as a special case the optimal policy for the classical secretary problem for which <em>y</em> = <em>r</em>.</li>
<li><strong>Candidate count rule (CCR):</strong> Select the <em>y</em> encountered candidate. Note, that this rule does not necessarily skip any applicants; it only considers how many candidates have been observed, not how deep the decision maker is in the applicant sequence.</li>
<li><strong>Successive non-candidate rule (SNCR):</strong> Select the first encountered candidate after observing <em>y</em> non-candidates (i.e., applicants with relative rank &gt; 1).</li>
</ul>

<p>Note that each heuristic has a single parameter <em>y</em>. The figure (shown on right) displays the expected success probabilities for each heuristic as a function of <em>y</em> for problems with <em>n</em> = 80.</p>
<h2 id="cardinal-payoff-variant">Cardinal payoff variant</h2>

<p>Finding the single best applicant might seem like a rather strict objective. One can imagine that the interviewer would rather hire a higher-valued applicant than a lower-valued one, and not only be concerned with getting the best. That is, the interviewer will derive some value from selecting an applicant that is not necessarily the best, and the derived value increases with the value of the one selected.</p>

<p>To model this problem, suppose that the 

<math display="inline" id="Secretary_problem:35">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 applicants have "true" values that are <a href="random_variable" title="wikilink">random variables</a> <em>X</em> drawn <a class="uri" href="i.i.d." title="wikilink">i.i.d.</a> from a <a href="Uniform_distribution_(continuous)" title="wikilink">uniform distribution</a> on [0, 1]. Similar to the classical problem described above, the interviewer only observes whether each applicant is the best so far (a candidate), must accept or reject each on the spot, and <em>must</em> accept the last one if he/she is reached. (To be clear, the interviewer does not learn the actual relative rank of <em>each</em> applicant. He/she learns only whether the applicant has relative rank 1.) However, in this version the <em>payoff</em> is given by the true value of the selected applicant. For example, if he/she selects an applicant whose true value is 0.8, then he/she will earn 0.8. The interviewer's objective is to maximize the expected value of the selected applicant.</p>

<p>Since the applicant's values are i.i.d. draws from a uniform distribution on [0, 1], the <a href="expected_value" title="wikilink">expected value</a> of the <em>t</em>th applicant given that 

<math display="inline" id="Secretary_problem:36">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo>{</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>t</mi>
     </msub>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <max></max>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}=\max\left\{x_{1},x_{2},\ldots,x_{t}\right\}
  </annotation>
 </semantics>
</math>

 is given by</p>

<p>

<math display="block" id="Secretary_problem:37">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mi>E</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>I</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mi>t</mi>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>t</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>t</ci>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>t</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{t}=E\left(X_{t}|I_{t}=1\right)=\frac{t}{t+1}.
  </annotation>
 </semantics>
</math>

</p>

<p>As in the classical problem, the optimal policy is given by a threshold, which for this problem we will denote by 

<math display="inline" id="Secretary_problem:38">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, at which the interviewer should begin accepting candidates.  showed that <em>c</em> is either 

<math display="inline" id="Secretary_problem:39">
 <semantics>
  <mrow>
   <mo stretchy="false">⌊</mo>
   <msqrt>
    <mi>n</mi>
   </msqrt>
   <mo stretchy="false">⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <floor></floor>
    <apply>
     <root></root>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor\sqrt{n}\rfloor
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Secretary_problem:40">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <msqrt>
    <mi>n</mi>
   </msqrt>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <root></root>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\sqrt{n}\rceil
  </annotation>
 </semantics>
</math>

. (In fact, whichever is closest to 

<math display="inline" id="Secretary_problem:41">
 <semantics>
  <msqrt>
   <mi>n</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n}
  </annotation>
 </semantics>
</math>

.) This follows from the fact that given a problem with 

<math display="inline" id="Secretary_problem:42">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 applicants, the expected payoff for some arbitrary threshold 

<math display="inline" id="Secretary_problem:43">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>c</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>c</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq c\leq n
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Secretary_problem:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>V</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mi>c</mi>
       </mrow>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <mrow>
        <mo>[</mo>
        <mrow>
         <munderover>
          <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
          <mrow>
           <mi>s</mi>
           <mo>=</mo>
           <mi>c</mi>
          </mrow>
          <mrow>
           <mi>t</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </munderover>
         <mrow>
          <mo>(</mo>
          <mfrac>
           <mrow>
            <mi>s</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mi>s</mi>
          </mfrac>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>]</mo>
       </mrow>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mn>1</mn>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </mfrac>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
         <mrow>
          <mi>s</mi>
          <mo>=</mo>
          <mi>c</mi>
         </mrow>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <mrow>
         <mo>(</mo>
         <mfrac>
          <mrow>
           <mi>s</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mi>s</mi>
         </mfrac>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>c</mi>
         <mi>n</mi>
        </mrow>
        <mo>-</mo>
        <msup>
         <mi>c</mi>
         <mn>2</mn>
        </msup>
       </mrow>
       <mo>+</mo>
       <mi>c</mi>
      </mrow>
      <mo>-</mo>
      <mi>n</mi>
     </mrow>
     <mrow>
      <mn>2</mn>
      <mi>c</mi>
      <mi>n</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>n</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>t</ci>
          <ci>c</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <csymbol cd="latexml">product</csymbol>
            <apply>
             <eq></eq>
             <ci>s</ci>
             <ci>c</ci>
            </apply>
           </apply>
           <apply>
            <minus></minus>
            <ci>t</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <divide></divide>
           <apply>
            <minus></minus>
            <ci>s</ci>
            <cn type="integer">1</cn>
           </apply>
           <ci>s</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <csymbol cd="latexml">product</csymbol>
           <apply>
            <eq></eq>
            <ci>s</ci>
            <ci>c</ci>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <minus></minus>
           <ci>s</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>s</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>c</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>c</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>c</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{n}(c)=\sum_{t=c}^{n-1}\left[\prod_{s=c}^{t-1}\left(\frac{s-1}{s}\right)%
\right]\left(\frac{1}{t+1}\right)+\left[\prod_{s=c}^{n-1}\left(\frac{s-1}{s}%
\right)\right]\frac{1}{2}={\frac{2cn-{c}^{2}+c-n}{2cn}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Differentiating 

<math display="inline" id="Secretary_problem:45">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>n</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{n}(c)
  </annotation>
 </semantics>
</math>

 with respect to <em>c</em>, one gets</p>

<p>

<math display="block" id="Secretary_problem:46">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <mi>V</mi>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <mi>c</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mo>-</mo>
       <msup>
        <mi>c</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>+</mo>
      <mi>n</mi>
     </mrow>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>c</mi>
       <mn>2</mn>
      </msup>
      <mi>n</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>V</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>c</ci>
        <cn type="float">2</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <cn type="float">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial V}{\partial c}=\frac{-{c}^{\,2}+n}{2{c}^{\,2}n}.
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Secretary_problem:47">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mo>∂</mo>
      <mn>2</mn>
     </msup>
     <mi>V</mi>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo>∂</mo>
     <msup>
      <mi>c</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <partialdiff></partialdiff>
       <cn type="float">2</cn>
      </apply>
      <ci>V</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <cn type="float">2</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial^{\,2}V/\partial c^{\,2}<0
  </annotation>
 </semantics>
</math>

 for all permissible values of 

<math display="inline" id="Secretary_problem:48">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, we find that 

<math display="inline" id="Secretary_problem:49">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>


 is maximized at 

<math display="inline" id="Secretary_problem:50">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <msqrt>
    <mi>n</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <root></root>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=\sqrt{n}
  </annotation>
 </semantics>
</math>

. Since <em>V</em> is convex in 

<math display="inline" id="Secretary_problem:51">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, the optimal integer-valued threshold must be either 

<math display="inline" id="Secretary_problem:52">
 <semantics>
  <mrow>
   <mo stretchy="false">⌊</mo>
   <msqrt>
    <mi>n</mi>
   </msqrt>
   <mo stretchy="false">⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <floor></floor>
    <apply>
     <root></root>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor\sqrt{n}\rfloor
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Secretary_problem:53">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <msqrt>
    <mi>n</mi>
   </msqrt>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <root></root>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\sqrt{n}\rceil
  </annotation>
 </semantics>
</math>

. Thus, for most values of 

<math display="inline" id="Secretary_problem:54">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 the interviewer will begin accepting applicants sooner in the cardinal payoff version than in the classical version where the objective is to select the single best applicant. Note that this is not an asymptotic result: It holds for all 

<math display="inline" id="Secretary_problem:55">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="other-modifications">Other modifications</h2>

<p>There are at least two variants of the secretary problem that also have simple and elegant solutions.</p>

<p>One variant replaces the desire to pick the best with the desire to pick the second-best. <a href="Robert_J._Vanderbei" title="wikilink">Robert J. Vanderbei</a> calls this the "postdoc" problem arguing that the "best" will go to Harvard. For this problem, the probability of success for an even number of applicants is exactly 

<math display="inline" id="Secretary_problem:56">
 <semantics>
  <mfrac>
   <mrow>
    <mn>0.25</mn>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <cn type="float">0.25</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{0.25n^{2}}{n(n-1)}
  </annotation>
 </semantics>
</math>

. This probability tends to 1/4 as n tends to infinity illustrating the fact that it is easier to pick the best than the second-best.</p>

<p>For a second variant, the number of selections is specified to be greater than one. In other words, the interviewer is not hiring just one secretary but rather is, say, admitting a class of students from an applicant pool. Under the assumption that success is achieved if and only if all the selected candidates are superior to all of the not-selected candidates, it is again a problem that can be solved. It was shown in  that when n is even and the desire is to select exactly half the candidates, the optimal strategy yields a success probability of 

<math display="inline" id="Secretary_problem:57">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{n/2+1}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="experimental-studies">Experimental studies</h2>

<p>Experimental <a href="Experimental_psychology" title="wikilink">psychologists</a> and <a href="experimental_economics" title="wikilink">economists</a> have studied the <a href="Decision_making" title="wikilink">decision behavior</a> of actual people in secretary problem situations.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In large part, this work has shown that people tend to stop searching too soon. This may be explained, at least in part, by the cost of evaluating candidates. In real world settings, this might suggest that people do not search enough whenever they are faced with problems where the decision alternatives are encountered sequentially. For example, when trying to decide at which gas station to stop for gas, people might not search enough before stopping. If true, then they would tend to pay more for gas than they might had they searched longer. The same may be true when people search online for airline tickets. Experimental research on problems such as the secretary problem is sometimes referred to as <a href="behavioral_operations_research" title="wikilink">behavioral operations research</a>.</p>
<h2 id="neural-correlates">Neural correlates</h2>

<p>While there is a substantial body of <a class="uri" href="neuroscience" title="wikilink">neuroscience</a> research on information integration, or the representation of belief, in perceptual decision-making tasks using both animal<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and human subjects,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> there is relatively little known about how the decision to stop gathering information is arrived at.</p>

<p>Researchers have studied the neural bases of solving the secretary problem in healthy volunteers using <a href="functional_MRI" title="wikilink">functional MRI</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> A <a href="Markov_decision_process" title="wikilink">Markov decision process</a> (MDP) was used to quantify the value of continuing to search versus committing to the current option. Decisions to take versus decline an option engaged <a href="parietal_cortex" title="wikilink">parietal</a> and <a href="dorsolateral_prefrontal_cortex" title="wikilink">dorsolateral prefrontal</a> cortices, as well <a href="ventral_striatum" title="wikilink">ventral striatum</a>, <a href="Insular_cortex" title="wikilink">anterior insula</a>, and <a href="anterior_cingulate" title="wikilink">anterior cingulate</a>. Therefore, brain regions previously implicated in evidence integration and <a href="Reward_system" title="wikilink">reward</a> representation encode threshold crossings that trigger decisions to commit to a choice.</p>
<h2 id="history">History</h2>

<p>The secretary problem was apparently introduced in 1949 by <a href="Merrill_M._Flood" title="wikilink">Merrill M. Flood</a>, who called it the fiancée problem in a lecture he gave that year. He referred to it several times during the 1950s, for example in a conference talk at <a href="Purdue_University" title="wikilink">Purdue</a> on 9 May 1958, and it eventually became widely known in the folklore although nothing was published at the time. In 1958 he sent a letter to <a href="Leonard_Gillman" title="wikilink">Leonard Gillman</a>, with copies to a dozen friends including <a href="Samuel_Karlin" title="wikilink">Samuel Karlin</a> and J. Robbins, outlining a proof of the optimum strategy, with an appendix by R. Palermo who proved that all strategies are dominated by a strategy of the form "reject the first <em>p</em> unconditionally, then accept the next candidate who is better". (See Flood (1958).)</p>

<p>The first publication was apparently by <a href="Martin_Gardner" title="wikilink">Martin Gardner</a> in Scientific American, February 1960. He had heard about it from John H. Fox, Jr., and L. Gerald Marnie, who had independently come up with an equivalent problem in 1958; they called it the "game of googol". Fox and Marnie did not know the optimum solution; Gardner asked for advice from <a href="Leo_Moser" title="wikilink">Leo Moser</a>, who (together with J. R. Pounder) provided a correct analysis for publication in the magazine. Soon afterwards, several mathematicians wrote to Gardner to tell him about the equivalent problem they had heard via the grapevine, all of which can most likely be traced to Flood's original work.</p>

<p>The 1/<em>e</em>-law of best choice is due to <a href="F._Thomas_Bruss" title="wikilink">F. Thomas Bruss</a> (1984).</p>

<p>Ferguson (1989) has an extensive bibliography and points out that a similar (but different) problem had been considered by <a href="Arthur_Cayley" title="wikilink">Arthur Cayley</a> in 1875 and even by <a href="Johannes_Kepler" title="wikilink">Johannes Kepler</a> long before that.</p>
<h2 id="combinatorial-generalization">Combinatorial generalization</h2>

<p>The secretary problem gets a combinatorial flavor when there is not only a single job available but multiple different jobs. Again there are 

<math display="inline" id="Secretary_problem:58">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 applicants coming in random order and whenever a candidate arrives she reveals a set of nonnegative numbers. Each value specifying her qualification for one of the jobs. The administrator not only has to decide whether or not to take the applicant, but if so also has to assign her permanently to one of the jobs. The objective is to find an assignment where the sum of qualifications is as big as possible. This problem is identical to finding a maximum-weight matching in an edge-weighted bipartite graph where the 

<math display="inline" id="Secretary_problem:59">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 nodes of one side arrive online in random order.</p>

<p>By a generalization of the classic algorithm for the secretary problem, it is possible to obtain an assignment where the expected sum of qualifications is only a factor of 

<math display="inline" id="Secretary_problem:60">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 less than an optimal (offline) assignment.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Optimal_stopping" title="wikilink">Optimal stopping</a></li>
<li><a href="Odds_algorithm" title="wikilink">Odds algorithm</a></li>
<li><a href="Robbins'_problem" title="wikilink">Robbins' problem</a></li>
<li><a href="Search_theory" title="wikilink">Search theory</a></li>
<li><a class="uri" href="Dating" title="wikilink">Dating</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Hill, T.P. "<a href="http://www.americanscientist.org/issues/feature/2009/2/knowing-when-to-stop/1">Knowing When to Stop</a>". <em>American Scientist</em>, Vol. 97, 126-133 (2009). (For French translation, see <a href="http://www.pourlascience.fr/ewb_pages/f/fiche-article-savoir-quand-s-arreter-22670.php">cover story</a> in the July issue of <em>Pour la Science</em> (2009))</li>
<li></li>
<li></li>
<li>Merrill R. Flood, letter written in 1958, a copy of which can be found in the Martin Gardner papers at Stanford University Archives, series 1, box 5, folder 19.</li>
<li><a href="Martin_Gardner" title="wikilink">Martin Gardner</a>, New Mathematical Diversions from Scientific American. Simon and Schuster, 1966, Chapter 3, Problem 3 [reprints his original column published in February 1960 with additional comments].</li>
<li></li>
<li><em>Framing Our Thoughts: Ecological Rationality as Evolutionary Psychology's Answer to the Frame Problem</em>, Timothy Ketelaar and Peter M. Todd, Chapter 5 of <em>Conceptual Challenges in Evolutionary Psychology</em>, p. 187.</li>
<li></li>
<li></li>
<li><a href="Robert_J._Vanderbei" title="wikilink">Robert J. Vanderbei</a> "<a href="http://www.princeton.edu/~rvdb/tex/PostdocProblem/PostdocProb.pdf">The Postdoc Variant of the Secretary Problem</a>"</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.utilitymill.com/utility/Secretary_Problem_Optimizer">Online Utility to Calculate Optimal r</a></li>
<li>

<p>List of optimal r</p></li>
<li></li>
<li></li>
<li><a href="http://www.math.ucla.edu/~tom/Stopping/Contents.html">Optimal Stopping and Applications book by Thomas S. Ferguson</a></li>
</ul>

<p>"</p>

<p><a href="Category:Decision_theory" title="wikilink">Category:Decision theory</a> <a href="Category:Sequential_methods" title="wikilink">Category:Sequential methods</a> <a href="Category:Optimal_decisions" title="wikilink">Category:Optimal decisions</a> <a href="Category:Named_probability_problems" title="wikilink">Category:Named probability problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Bearden, Murphy, and Rapoport, 2006; Bearden, Rapoport, and Murphy, 2006; Seale and Rapoport, 1997<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
