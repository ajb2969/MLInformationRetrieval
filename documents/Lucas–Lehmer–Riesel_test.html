<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1859">Lucas–Lehmer–Riesel test</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lucas–Lehmer–Riesel test</h1>
<hr/>

<p>In mathematics, the <strong>Lucas–Lehmer–Riesel test</strong> is a <a href="primality_test" title="wikilink">primality test</a> for numbers of the form <em>N</em> = <em>k</em> ⋅ 2<sup><em>n</em></sup> − 1, with 2<sup><em>n</em></sup> &gt; <em>k</em>. The test was developed by <a href="Hans_Riesel" title="wikilink">Hans Riesel</a> and it is based on the <a href="Lucas–Lehmer_primality_test" title="wikilink">Lucas–Lehmer primality test</a>. It is the fastest deterministic algorithm known for numbers of that form. For numbers of the form <em>N</em> = <em>k</em> ⋅ 2<sup><em>n</em></sup> + 1 (<a href="Proth_number" title="wikilink">Proth numbers</a>), either application of <a href="Proth's_theorem" title="wikilink">Proth's theorem</a> (a <a href="Las_Vegas_algorithm" title="wikilink">Las Vegas algorithm</a>) or one of the deterministic proofs described in Brillhart-Lehmer-Selfridge 1975<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> are used.</p>
<h2 id="the-algorithm">The algorithm</h2>

<p>The algorithm is very similar to the Lucas–Lehmer test, but with a variable starting point depending on the value of <em>k</em>.</p>

<p>Define a sequence {<em>u</em><sub><em>i</em></sub>} for all <em>i</em> &gt; 0 by:</p>

<p>

<math display="block" id="Lucas–Lehmer–Riesel_test:0">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>u</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mn>2</mn>
    </msubsup>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mn>2.</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <cn type="float">2.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}=u_{i-1}^{2}-2.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Then <em>N</em> is prime if and only if it divides <em>u</em><sub><em>n</em>−2</sub>.</p>
<h2 id="finding-the-starting-value">Finding the starting value</h2>

<p>The starting value <em>u</em><sub>0</sub> is determined as follows.</p>
<ul>
<li>If <em>k</em> = 1: if <em>n</em> is odd, then we can take <em>u</em><sub>0</sub> = 4. If <em>n</em> ≡ 3 (mod 4), then we can take <em>u</em><sub>0</sub> = 3. Note that if <em>n</em> is prime, these are <a href="Mersenne_numbers" title="wikilink">Mersenne numbers</a>.</li>
<li>If <em>k</em> = 3: if <em>n</em> ≡ 0 or 3 (mod 4), then <em>u</em><sub>0</sub> = 5778.</li>
<li>If <em>k</em> ≡ 1 or 5 (mod 6): if 3 does not divide <em>N</em>, then we take 

<math display="inline" id="Lucas–Lehmer–Riesel_test:1">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mo>+</mo>
       <msqrt>
        <mn>3</mn>
       </msqrt>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>k</mi>
    </msup>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mo>-</mo>
       <msqrt>
        <mn>3</mn>
       </msqrt>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>k</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <cn type="integer">2</cn>
       <apply>
        <root></root>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <apply>
        <root></root>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{0}=(2+\sqrt{3})^{k}+(2-\sqrt{3})^{k}
  </annotation>
 </semantics>
</math>

. See below for how to calculate this using a Lucas(4,1) sequence.</li>
<li>Otherwise, we are in the case where <em>k</em> is a multiple of 3, and it is more difficult to select the right value of <em>u</em><sub>0</sub>.</li>
</ul>

<p>An alternative method for finding the starting value <em>u</em><sub>0</sub> is given in Rödseth 1994.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The selection method is much easier than that used by Riesel for the <em>3</em> divides <em>k</em> case. First find a <em>P</em> value that satisfies the following equalities of <a href="Jacobi_symbol" title="wikilink">Jacobi symbols</a>:</p>

<p>

<math display="block" id="Lucas–Lehmer–Riesel_test:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mi>P</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mi>N</mi>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mtext>and</mtext>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mi>P</mi>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
      <mi>N</mi>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>P</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>N</ci>
     </apply>
     <list>
      <cn type="integer">1</cn>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>P</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\frac{P-2}{N}\right)=1\quad\text{and}\quad\left(\frac{P+2}{N}\right)=-1
  </annotation>
 </semantics>
</math>

.</p>

<p>In practice, only a few <em>P</em> values need be checked before one is found (5, 8, 9, or 11 work in about 85% of trials).</p>

<p>To find the starting value <em>u</em><sub>0</sub> from the <em>P</em> value we can use a Lucas(P,1) sequence, as shown in <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> as well as page 124 of.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The latter explains that when 3 ∤ <em>k</em>, <em>P</em>=4 may be used, hence the earlier search is not necessary. The starting value <em>u</em><sub>0</sub> is then equal to the modular <a href="Lucas_sequence" title="wikilink">Lucas sequence</a> <em>V</em><sub><em>k</em></sub>(<em>P</em>,<em>Q</em>) mod <em>N</em>. This process takes very little time compared to the main test.</p>
<h2 id="how-the-test-works">How the test works</h2>

<p>The Lucas–Lehmer–Riesel test is a particular case of group-order primality testing; we demonstrate that some number is prime by showing that some group has the order that it would have were that number prime, and we do this by finding an element of that group of precisely the right order.</p>

<p>For Lucas-style tests on a number <em>N</em>, we work in the multiplicative group of a quadratic extension of the integers modulo <em>N</em>; if <em>N</em> is prime, the order of this multiplicative group is <em>N</em><sup>2</sup> − 1, it has a subgroup of order <em>N</em> + 1, and we try to find a generator for that subgroup.</p>

<p>We start off by trying to find a non-iterative expression for the 

<math display="inline" id="Lucas–Lehmer–Riesel_test:3">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}
  </annotation>
 </semantics>
</math>

. Following the model of the Lucas–Lehmer test, put 

<math display="inline" id="Lucas–Lehmer–Riesel_test:4">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <msup>
      <mn>2</mn>
      <mi>i</mi>
     </msup>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>a</mi>
     <mrow>
      <mo>-</mo>
      <msup>
       <mn>2</mn>
       <mi>i</mi>
      </msup>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}=a^{2^{i}}+a^{-2^{i}}
  </annotation>
 </semantics>
</math>

, and by induction we have 

<math display="inline" id="Lucas–Lehmer–Riesel_test:5">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>u</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mn>2</mn>
    </msubsup>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}=u_{i-1}^{2}-2
  </annotation>
 </semantics>
</math>

.</p>

<p>So we can consider ourselves as looking at the 2<sup><em>i</em></sup>th term of the sequence 

<math display="inline" id="Lucas–Lehmer–Riesel_test:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mi>i</mi>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>a</mi>
     <mrow>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(i)=a^{i}+a^{-i}
  </annotation>
 </semantics>
</math>

. If <em>a</em> satisfies a quadratic equation, this is a Lucas sequence, and has an expression of the form 

<math display="inline" id="Lucas–Lehmer–Riesel_test:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>β</mi>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>v</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <ci>v</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(i)=\alpha v(i-1)+\beta v(i-2)
  </annotation>
 </semantics>
</math>

. Really, we're looking at the <em>k</em> ⋅ 2<sup><em>i</em></sup>th term of a different sequence, but since decimations (take every <em>k</em>th term starting with the zeroth) of a Lucas sequence are themselves Lucas sequences, we can deal with the factor <em>k</em> by picking a different starting point.</p>
<h2 id="llr-software">LLR software</h2>

<p>LLR is a program that can run the LLR tests. The program was developed by <a href="Jean_Penné" title="wikilink">Jean Penné</a>. <a href="Vincent_Penné" title="wikilink">Vincent Penné</a> has modified the program so that it can obtain tests via the Internet. The software is both used by individual prime searchers and some <a href="distributed_computing" title="wikilink">distributed computing</a> projects including <a href="Riesel_Sieve" title="wikilink">Riesel Sieve</a> and <a class="uri" href="PrimeGrid" title="wikilink">PrimeGrid</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Riesel_number" title="wikilink">Riesel number</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><mtpl></mtpl></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://jpenne.free.fr/index2.html">Download Jean Penné's LLR</a></li>
<li><a href="https://github.com/danaj/Math-Prime-Util-GMP">Math::Prime::Util::GMP</a> - Part of Perl's ntheory module, this has basic implementations of LLR and Proth form testing, as well as some BLS75 proof methods.</li>
</ul>

<p>"</p>

<p><a href="Category:Primality_tests" title="wikilink">Category:Primality tests</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
