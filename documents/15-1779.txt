   Quantized state systems method      Quantized state systems method   The quantized state systems (QSS) methods are a family of numerical integration solvers based on the idea of state quantization, dual to the traditional idea of time discretization. Unlike traditional numerical solution methods , which approach the problem by discretizing time and solving for the next (real-valued) state at each successive time step, QSS methods keep time as a continuous entity and instead quantize the system's state, instead solving for the time at which the state deviates from its quantized value by a quantum .  They can also have many advantages compared to classical algorithms. 1 They inherently allow for modeling discontinuities in the system due to their discrete-event nature and asynchronous nature. They also allow for explicit root-finding and detection of zero-crossing using explicit algorithms, avoiding the need for iteration---a fact which is is especially important in the case of stiff systems, where traditional time-stepping methods require a heavy computational penalty due to the requirement to implicitly solve for the next system state. Finally, QSS methods satisfy remarkable global stability and error bounds, described below, which are not satisfied by classical solution techniques.  By their nature, QSS methods are therefore neatly modeled by the DEVS formalism, a discrete-event  model of computation , in contrast with traditional methods, which form discrete-time models of the continuous-time system. They have therefore been implemented in [PowerDEVS ], a simulation engine for such discrete-event systems.  Theoretical properties  In 2001, Ernesto Kofman proved 2 a remarkable property of the quantized-state system simulation method: namely, that when the technique is used to solve a stable  linear time-invariant (LTI) system , the global error is bounded by a constant that is proportional to the quantum, but (crucially) independent of the duration of the simulation. More specifically, for a stable multidimensional LTI system with the state-transition matrix    A   A   A   and input matrix    B   B   B   , it was shown in [CK06] that the absolute error vector     e  →    (  t  )        normal-→  e   t    \vec{e}(t)   is bounded above by      |   e  →    (  t  )   |  ≤  |  V  |  |  ℜ    (  Λ  )    -  1    Λ  |  |   V   -  1    |  Δ   Q  →   +  |  V  |  |  ℜ    (  Λ  )    -  1     V   -  1    B  |  Δ   u  →      fragments  normal-|   normal-→  e    fragments  normal-(  t  normal-)   normal-|   normal-|  V  normal-|  normal-|    superscript   fragments  normal-(  Λ  normal-)     1    Λ  normal-|  normal-|   superscript  V    1    normal-|  Δ   normal-→  Q    normal-|  V  normal-|  normal-|    superscript   fragments  normal-(  Λ  normal-)     1     superscript  V    1    B  normal-|  Δ   normal-→  u     \left|\vec{e}(t)\right|\leq\left|V\right|\ \left|\Re\left(\Lambda\right)^{-1}%
 \Lambda\right|\ \left|V^{-1}\right|\ \Delta\vec{Q}+\left|V\right|\ \left|\Re%
 \left(\Lambda\right)^{-1}V^{-1}B\right|\ \Delta\vec{u}     where    Δ   Q  →       normal-Δ   normal-→  Q     \Delta\vec{Q}   is the vector of state quanta,    Δ   u  →       normal-Δ   normal-→  u     \Delta\vec{u}   is the vector with quanta adopted in the input signals,     V  Λ   V   -  1     =  A        V  normal-Λ   superscript  V    1     A    V\Lambda V^{-1}=A   is the eigendecomposition or Jordan canonical form of   A   A   A   , and    |  ⋅  |     fragments  normal-|  normal-⋅  normal-|    \left|\,\cdot\,\right|   denotes the element-wise absolute value operator (not to be confused with the determinant or norm ).  It is worth noticing that this spectacular error bound comes at a price: the global error for a stable LTI system is also, in a sense, bounded below by a the quantum itself, at least for the first-order QSS1 method. This is due to the fact that, unless the approximation happens to coincide exactly with the correct value (an event which will almost surely not happen), it will simply continue oscillating around the equilibrium, as the state is always (by definition) guaranteed to change by exactly one quantum outside of the equilibrium. Avoiding this condition would require finding a reliable technique for dynamically lowering the quantum in a manner analogous to adaptive stepsize methods in traditional simulation algorithms.  First-order QSS method – QSS1  Let an initial value problem be specified as follows.          x  ˙    (  t  )    =   f   (   x   (  t  )    ,  t  )     ,    x   (   t  0   )    =   x  0     .     formulae-sequence       normal-˙  x   t     f     x  t   t         x   subscript  t  0     subscript  x  0      \dot{x}(t)=f(x(t),t),\quad x(t_{0})=x_{0}.     The first-order QSS method, known as QSS1, approximates the above system by          x  ˙    (  t  )    =   f   (   q   (  t  )    ,  t  )     ,    q   (   t  0   )    =   x  0     .     formulae-sequence       normal-˙  x   t     f     q  t   t         q   subscript  t  0     subscript  x  0      \dot{x}(t)=f(q(t),t),\quad q(t_{0})=x_{0}.     where   x   x   x   and   q   q   q   are related by a hysteretic quantization function       q   (  t  )    =   {      x   (  t  )        if   |    x   (  t  )    -   q   (   t  -   )     |    ≥   Δ  Q         q   (   t  -   )      otherwise            q  t    cases    x  t       if        x  t     q   superscript  t          normal-Δ  Q      q   superscript  t     otherwise     q(t)=\begin{cases}x(t)&\text{if }\left|x(t)-q(t^{-})\right|\geq\Delta Q\\
 q(t^{-})&\text{otherwise}\end{cases}     where    Δ  Q      normal-Δ  Q    \Delta Q   is called a quantum . Notice that this quantization function is hysteretic because it has memory : not only is its output a function of the current state    x   (  t  )       x  t    x(t)   , but it also depends on its old value,    q   (   t  -   )       q   superscript  t      q(t^{-})   .  This formulation therefore approximates the state by a piecewise constant function,    q   (  t  )       q  t    q(t)   , that updates its value as soon as the state deviates from this approximation by one quantum.  The multidimensional formulation of this system is almost the same as the single-dimensional formulation above: the    k  th     superscript  k  th    k^{\text{th}}   quantized state     q  k    (  t  )        subscript  q  k   t    q_{k}(t)   is a function of its corresponding state,     x  k    (  t  )        subscript  x  k   t    x_{k}(t)   , and the state vector     x  →    (  t  )        normal-→  x   t    \vec{x}(t)   is a function of the entire quantized state vector,     q  →    (  t  )        normal-→  q   t    \vec{q}(t)   :        x  →    (  t  )    =   f   (    q  →    (  t  )    ,  t  )           normal-→  x   t     f      normal-→  q   t   t      \vec{x}(t)=f(\vec{q}(t),t)     High-order QSS methods – QSS2 and QSS3  The second-order QSS method, QSS2, follows the same principle as QSS1, except that it defines    q   (  t  )       q  t    q(t)   as a piecewise linear approximation of the trajectory    x   (  t  )       x  t    x(t)   that updates its trajectory as soon as the two differ from each other by one quantum. The pattern continues for higher-order approximations, which define the quantized state    q   (  t  )       q  t    q(t)   as successively higher-order polynomial approximations of the system's state.  It is important to note that, while in principle a QSS method of arbitrary order can be used to model a continuous-time system, it is seldom desirable to use methods of order higher than four, as the Abel–Ruffini theorem implies that the time of the next quantization,   t   t   t   , cannot (in general) be explicitly solved for algebraically when the polynomial approximation is of degree greater than four, and hence must be approximated iteratively using a root-finding algorithm . In practice, QSS2 or QSS3 proves sufficient for many problems and the use of higher-order methods results in little, if any, additional benefit.  Backward QSS method – BQSS  Linearly implicit QSS method – LIQSS  Software implementation  The QSS Methods can be implemented as a discrete event system and simulated in any DEVS simulator.  QSS methods constitute the main numerical solver for PowerDEVS [BK011 ] software. They have also been implemented in as a stand-alone version.  References   [CK06]    [BK11]   External links   Stand-alone implementation of QSS Methods  PowerDEVS at SourceForge   "  Category:Numerical differential equations     ↩  ↩     