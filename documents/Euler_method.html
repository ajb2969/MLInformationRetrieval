<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1659">Euler method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Euler method</h1>
<hr/>

<p> In <a class="uri" href="mathematics" title="wikilink">mathematics</a> and <a href="computational_science" title="wikilink">computational science</a>, the <strong>Euler method</strong> is a SN-order <a href="numerical_analysis" title="wikilink">numerical</a> procedure for solving <a href="ordinary_differential_equation" title="wikilink">ordinary differential equations</a> (ODEs) with a given <a href="Initial_value_problem" title="wikilink">initial value</a>. It is the most basic <a href="explicit_and_implicit_methods" title="wikilink">explicit method</a> for <a href="numerical_ordinary_differential_equations" title="wikilink">numerical integration of ordinary differential equations</a> and is the simplest <a href="Runge–Kutta_method" title="wikilink">Runge–Kutta method</a>. The Euler method is named after <a href="Leonhard_Euler" title="wikilink">Leonhard Euler</a>, who treated it in his book <em><a href="Institutionum_calculi_integralis" title="wikilink">Institutionum calculi integralis</a></em> (published 1768–70).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The Euler method is a first-order method, which means that the local error (error per step) is proportional to the square of the step size, and the global error (error at a given time) is proportional to the step size. The Euler method often serves as the basis to construct more complex methods.</p>
<h2 id="informal-geometrical-description">Informal geometrical description</h2>

<p>Consider the problem of calculating the shape of an unknown curve which starts at a given point and satisfies a given differential equation. Here, a differential equation can be thought of as a formula by which the <a class="uri" href="slope" title="wikilink">slope</a> of the <a href="tangent_line" title="wikilink">tangent line</a> to the curve can be computed at any point on the curve, once the position of that point has been calculated.</p>

<p>The idea is that while the curve is initially unknown, its starting point, which we denote by 

<math display="inline" id="Euler_method:0">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{0},
  </annotation>
 </semantics>
</math>

 is known (see the picture on top right). Then, from the differential equation, the slope to the curve at 

<math display="inline" id="Euler_method:1">
 <semantics>
  <msub>
   <mi>A</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{0}
  </annotation>
 </semantics>
</math>

 can be computed, and so, the tangent line.</p>

<p>Take a small step along that tangent line up to a point 

<math display="inline" id="Euler_method:2">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1}.
  </annotation>
 </semantics>
</math>

 Along this small step, the slope does not change too much, so 

<math display="inline" id="Euler_method:3">
 <semantics>
  <msub>
   <mi>A</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1}
  </annotation>
 </semantics>
</math>

 will be close to the curve. If we pretend that 

<math display="inline" id="Euler_method:4">
 <semantics>
  <msub>
   <mi>A</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1}
  </annotation>
 </semantics>
</math>

 is still on the curve, the same reasoning as for the point 

<math display="inline" id="Euler_method:5">
 <semantics>
  <msub>
   <mi>A</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{0}
  </annotation>
 </semantics>
</math>

 above can be used. After several steps, a <a href="polygonal_curve" title="wikilink">polygonal curve</a> 

<math display="inline" id="Euler_method:6">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>0</mn>
   </msub>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>A</mi>
    <mn>2</mn>
   </msub>
   <msub>
    <mi>A</mi>
    <mn>3</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-…</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{0}A_{1}A_{2}A_{3}\dots
  </annotation>
 </semantics>
</math>

 is computed. In general, this curve does not diverge too far from the original unknown curve, and the error between the two curves can be made small if the step size is small enough and the interval of computation is finite.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="formulation-of-the-method">Formulation of the method</h2>

<p>Suppose that we want to approximate the solution of the initial value problem</p>

<p>

<math display="block" id="Euler_method:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>y</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="42.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}(t)=f(t,y(t)),\qquad\qquad y(t_{0})=y_{0}.
  </annotation>
 </semantics>
</math>

</p>

<p>Choose a value 

<math display="inline" id="Euler_method:8">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 for the size of every step and set 

<math display="inline" id="Euler_method:9">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <mi>h</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>h</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{n}=t_{0}+nh
  </annotation>
 </semantics>
</math>

. Now, one step of the Euler method from 

<math display="inline" id="Euler_method:10">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{n}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Euler_method:11">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mi>n</mi>
    </msub>
    <mo>+</mo>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{n+1}=t_{n}+h
  </annotation>
 </semantics>
</math>

 is<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Euler_method:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mi>n</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}=y_{n}+hf(t_{n},y_{n}).
  </annotation>
 </semantics>
</math>

</p>

<p>The value of 

<math display="inline" id="Euler_method:13">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n}
  </annotation>
 </semantics>
</math>

 is an approximation of the solution to the ODE at time 

<math display="inline" id="Euler_method:14">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{n}
  </annotation>
 </semantics>
</math>



<math display="block" id="Euler_method:15">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
   <mo>≈</mo>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n}\approx y(t_{n})
  </annotation>
 </semantics>
</math>

. The Euler method is <a href="explicit_and_implicit_methods" title="wikilink">explicit</a>, i.e. the solution 

<math display="inline" id="Euler_method:16">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}
  </annotation>
 </semantics>
</math>

 is an explicit function of 

<math display="inline" id="Euler_method:17">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Euler_method:18">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>i</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\leq n
  </annotation>
 </semantics>
</math>

.</p>

<p>While the Euler method integrates a first-order ODE, any ODE of order <em>N</em> can be represented as a first-order ODE: to treat the equation</p>

<p>

<math display="block" id="Euler_method:19">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>y</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>N</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>N</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <ci>t</ci>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{(N)}(t)=f(t,y(t),y^{\prime}(t),\ldots,y^{(N-1)}(t))
  </annotation>
 </semantics>
</math>

,</p>

<p>we introduce auxiliary variables 

<math display="inline" id="Euler_method:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>z</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>z</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>y</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>z</mi>
       <mi>N</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msup>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>N</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>t</ci>
      </apply>
      <list>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>t</ci>
       </apply>
       <ci>normal-…</ci>
      </list>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>N</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{1}(t)=y(t),z_{2}(t)=y^{\prime}(t),\ldots,z_{N}(t)=y^{(N-1)}(t)
  </annotation>
 </semantics>
</math>

 and obtain the equivalent equation</p>

<p>

<math display="block" id="Euler_method:21">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐳</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msubsup>
         <mi>z</mi>
         <mn>1</mn>
         <mo>′</mo>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msubsup>
         <mi>z</mi>
         <mrow>
          <mi>N</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>′</mo>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msubsup>
         <mi>z</mi>
         <mi>N</mi>
         <mo>′</mo>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msup>
         <mi>y</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msup>
         <mi>y</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>N</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msup>
         <mi>y</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>N</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>z</mi>
         <mn>2</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>z</mi>
         <mi>N</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo>,</mo>
         <mrow>
          <msub>
           <mi>z</mi>
           <mn>1</mn>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <mrow>
          <msub>
           <mi>z</mi>
           <mi>N</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐳</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-′</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <apply>
           <minus></minus>
           <ci>N</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>normal-′</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <ci>N</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <apply>
          <minus></minus>
          <ci>N</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <ci>N</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>N</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>f</ci>
        <vector>
         <ci>t</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>z</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>t</ci>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>z</ci>
           <ci>N</ci>
          </apply>
          <ci>t</ci>
         </apply>
        </vector>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{z}^{\prime}(t)=\begin{pmatrix}z_{1}^{\prime}(t)\\
\vdots\\
z_{N-1}^{\prime}(t)\\
z_{N}^{\prime}(t)\end{pmatrix}=\begin{pmatrix}y^{\prime}(t)\\
\vdots\\
y^{(N-1)}(t)\\
y^{(N)}(t)\end{pmatrix}=\begin{pmatrix}z_{2}(t)\\
\vdots\\
z_{N}(t)\\
f(t,z_{1}(t),\ldots,z_{N}(t))\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>This is a first-order system in the variable 

<math display="inline" id="Euler_method:22">
 <semantics>
  <mrow>
   <mi>𝐳</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐳</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{z}(t)
  </annotation>
 </semantics>
</math>

 and can be handled by Euler's method or, in fact, by any other scheme for first-order systems.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="example">Example</h2>

<p>Given the initial value problem</p>

<p>

<math display="block" id="Euler_method:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>y</mi>
      <mo>′</mo>
     </msup>
     <mo>=</mo>
     <mi>y</mi>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=y,\quad y(0)=1,
  </annotation>
 </semantics>
</math>

</p>

<p>we would like to use the Euler method to approximate 

<math display="inline" id="Euler_method:24">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(4)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>=== Using step size equal to 1 (<em>h</em> = 1) ===</p>

<p> The Euler method is</p>

<p>

<math display="block" id="Euler_method:25">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
   <mo>+</mo>
   <mi>h</mi>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <plus></plus>
    <csymbol cd="unknown">h</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <ci>italic-</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}=y_{n}+hf(t_{n},y_{n}).\qquad\qquad
  </annotation>
 </semantics>
</math>

</p>

<p>so first we must compute 

<math display="inline" id="Euler_method:26">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t_{0},y_{0})
  </annotation>
 </semantics>
</math>

. In this simple differential equation, the function 

<math display="inline" id="Euler_method:27">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is defined by 

<math display="inline" id="Euler_method:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>t</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t,y)=y
  </annotation>
 </semantics>
</math>

. We have</p>

<p>

<math display="block" id="Euler_method:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t_{0},y_{0})=f(0,1)=1.\qquad\qquad
  </annotation>
 </semantics>
</math>

</p>

<p>By doing the above step, we have found the slope of the line that is tangent to the solution curve at the point 

<math display="inline" id="Euler_method:30">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,1)
  </annotation>
 </semantics>
</math>

. Recall that the slope is defined as the change in 

<math display="inline" id="Euler_method:31">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 divided by the change in 

<math display="inline" id="Euler_method:32">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Euler_method:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>y</mi>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>y</ci>
     </apply>
     <ci>normal-Δ</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta y/\Delta t
  </annotation>
 </semantics>
</math>

.</p>

<p>The next step is to multiply the above value by the step size 

<math display="inline" id="Euler_method:34">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, which we take equal to one here:</p>

<p>

<math display="block" id="Euler_method:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>h</mi>
      <mo>⋅</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>⋅</mo>
     <mn>1</mn>
    </mrow>
    <mo>=</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>h</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\cdot f(y_{0})=1\cdot 1=1.\qquad\qquad
  </annotation>
 </semantics>
</math>

</p>

<p>Since the step size is the change in 

<math display="inline" id="Euler_method:36">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, when we multiply the step size and the slope of the tangent, we get a change in 

<math display="inline" id="Euler_method:37">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 value. This value is then added to the initial 

<math display="inline" id="Euler_method:38">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 value to obtain the next value to be used for computations.</p>

<p>

<math display="block" id="Euler_method:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>y</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mn>1</mn>
      <mo>⋅</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>2.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">2.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{0}+hf(y_{0})=y_{1}=1+1\cdot 1=2.\qquad\qquad
  </annotation>
 </semantics>
</math>

</p>

<p>The above steps should be repeated to find 

<math display="inline" id="Euler_method:40">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{2}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Euler_method:41">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{3}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Euler_method:42">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>4</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{4}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Euler_method:43">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y_{2}
  </annotation>
 </semantics>
</math>


</p>

<p>Due to the repetitive nature of this algorithm, it can be helpful to organize computations in a chart form, as seen below, to avoid making errors.</p>
<dl>
<dd>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Euler_method:44">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Euler_method:45">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n}
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Euler_method:46">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{n}
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Euler_method:47">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t_{n},y_{n})
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Euler_method:48">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Euler_method:49">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta y
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Euler_method:50">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>8</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>16</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>The conclusion of this computation is that 

<math display="inline" id="Euler_method:51">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <mn>16</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">4</cn>
    </apply>
    <cn type="integer">16</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{4}=16
  </annotation>
 </semantics>
</math>

. The exact solution of the differential equation is 

<math display="inline" id="Euler_method:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mi>t</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=e^{t}
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="Euler_method:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>4</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mn>4</mn>
   </msup>
   <mo>≈</mo>
   <mn>54.598</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <cn type="float">54.598</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(4)=e^{4}\approx 54.598
  </annotation>
 </semantics>
</math>

. Thus, the approximation of the Euler method is not very good in this case. However, as the figure shows, its behaviour is qualitatively right.</p>
<h3 id="using-other-step-sizes">Using other step sizes</h3>

<p> As suggested in the introduction, the Euler method is more accurate if the step size 

<math display="inline" id="Euler_method:54">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is smaller. The table below shows the result with different step sizes. The top row corresponds to the example in the previous section, and the second row is illustrated in the figure.</p>
<dl>
<dd>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>step size</p></th>
<th style="text-align: left;">
<p>result of Euler's method</p></th>
<th style="text-align: left;">
<p>error</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>16</p></td>
<td style="text-align: left;">
<p>38.598</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0.25</p></td>
<td style="text-align: left;">
<p>35.53</p></td>
<td style="text-align: left;">
<p>19.07</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0.1</p></td>
<td style="text-align: left;">
<p>45.26</p></td>
<td style="text-align: left;">
<p>9.34</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0.05</p></td>
<td style="text-align: left;">
<p>49.56</p></td>
<td style="text-align: left;">
<p>5.04</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0.025</p></td>
<td style="text-align: left;">
<p>51.98</p></td>
<td style="text-align: left;">
<p>2.62</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0.0125</p></td>
<td style="text-align: left;">
<p>53.26</p></td>
<td style="text-align: left;">
<p>1.34</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>The error recorded in the last column of the table is the difference between the exact solution at 

<math display="inline" id="Euler_method:55">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=4
  </annotation>
 </semantics>
</math>

 and the Euler approximation. In the bottom of the table, the step size is half the step size in the previous row, and the error is also approximately half the error in the previous row. This suggests that the error is roughly proportional to the step size, at least for fairly small values of the step size. This is true in general, also for other equations; see the section <a href="#Global_truncation_error" title="wikilink"><em>Global truncation error</em></a> for more details.</p>

<p>Other methods, such as the <a href="midpoint_method" title="wikilink">midpoint method</a> also illustrated in the figures, behave more favourably: the error of the midpoint method is roughly proportional to the <em>square</em> of the step size. For this reason, the Euler method is said to be a first-order method, while the midpoint method is second order.</p>

<p>We can extrapolate from the above table that the step size needed to get an answer that is correct to three decimal places is approximately 0.00001, meaning that we need 400,000 steps. This large number of steps entails a high computational cost. For this reason, people usually employ alternative, higher-order methods such as <a href="Runge–Kutta_method" title="wikilink">Runge–Kutta methods</a> or <a href="linear_multistep_method" title="wikilink">linear multistep methods</a>, especially if a high accuracy is desired.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="derivation">Derivation</h2>

<p>The Euler method can be derived in a number of ways. Firstly, there is the geometrical description mentioned above.</p>

<p>Another possibility is to consider the <a href="Taylor_expansion" title="wikilink">Taylor expansion</a> of the function 

<math display="inline" id="Euler_method:56">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 around 

<math display="inline" id="Euler_method:57">
 <semantics>
  <msub>
   <mi>t</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Euler_method:58">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mi>h</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <msup>
       <mi>y</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <msup>
       <mi>h</mi>
       <mn>2</mn>
      </msup>
      <msup>
       <mi>y</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>h</mi>
        <mn>3</mn>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>′′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t_{0}+h)=y(t_{0})+hy^{\prime}(t_{0})+\frac{1}{2}h^{2}y^{\prime\prime}(t_{0})%
+O(h^{3}).
  </annotation>
 </semantics>
</math>

</p>

<p>The differential equation states that 

<math display="inline" id="Euler_method:59">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>t</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=f(t,y)
  </annotation>
 </semantics>
</math>

. If this is substituted in the Taylor expansion and the quadratic and higher-order terms are ignored, the Euler method arises.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The Taylor expansion is used below to analyze the error committed by the Euler method, and it can be extended to produce <a href="Runge–Kutta_methods" title="wikilink">Runge–Kutta methods</a>.</p>

<p>A closely related derivation is to substitute the forward <a href="finite_difference" title="wikilink">finite difference</a> formula for the derivative,</p>

<p>

<math display="block" id="Euler_method:60">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>t</mi>
         <mn>0</mn>
        </msub>
        <mo>+</mo>
        <mi>h</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mi>h</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>y</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>h</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}(t_{0})\approx\frac{y(t_{0}+h)-y(t_{0})}{h}
  </annotation>
 </semantics>
</math>

</p>

<p>in the differential equation 

<math display="inline" id="Euler_method:61">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>t</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=f(t,y)
  </annotation>
 </semantics>
</math>

. Again, this yields the Euler method.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> A similar computation leads to the <a href="midpoint_rule" title="wikilink">midpoint rule</a> and the <a href="backward_Euler_method" title="wikilink">backward Euler method</a>.</p>

<p>Finally, one can integrate the differential equation from 

<math display="inline" id="Euler_method:62">
 <semantics>
  <msub>
   <mi>t</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Euler_method:63">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mn>0</mn>
   </msub>
   <mo>+</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}+h
  </annotation>
 </semantics>
</math>

 and apply the <a href="fundamental_theorem_of_calculus" title="wikilink">fundamental theorem of calculus</a> to get:</p>

<p>

<math display="block" id="Euler_method:64">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>t</mi>
         <mn>0</mn>
        </msub>
        <mo>+</mo>
        <mi>h</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mi>h</mi>
      </mrow>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">d</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>h</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>h</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>t</ci>
       </apply>
      </interval>
      <ci>normal-d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t_{0}+h)-y(t_{0})=\int_{t_{0}}^{t_{0}+h}f(t,y(t))\,\mathrm{d}t.
  </annotation>
 </semantics>
</math>

</p>

<p>Now approximate the integral by the left-hand <a href="rectangle_method" title="wikilink">rectangle method</a> (with only one rectangle):</p>

<p>

<math display="block" id="Euler_method:65">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mi>h</mi>
      </mrow>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">d</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mi>h</mi>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>t</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>h</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>t</ci>
       </apply>
      </interval>
      <ci>normal-d</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{t_{0}}^{t_{0}+h}f(t,y(t))\,\mathrm{d}t\approx hf(t_{0},y(t_{0})).
  </annotation>
 </semantics>
</math>

</p>

<p>Combining both equations, one finds again the Euler method.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> This line of thought can be continued to arrive at various <a href="linear_multistep_method" title="wikilink">linear multistep methods</a>.</p>
<h2 id="local-truncation-error">Local truncation error</h2>

<p>The <a href="local_truncation_error" title="wikilink">local truncation error</a> of the Euler method is error made in a single step. It is the difference between the numerical solution after one step, 

<math display="inline" id="Euler_method:66">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}
  </annotation>
 </semantics>
</math>

, and the exact solution at time 

<math display="inline" id="Euler_method:67">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{1}=t_{0}+h
  </annotation>
 </semantics>
</math>

. The numerical solution is given by</p>

<p>

<math display="block" id="Euler_method:68">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
   <mo>+</mo>
   <mi>h</mi>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
    <plus></plus>
    <csymbol cd="unknown">h</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <ci></ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}=y_{0}+hf(t_{0},y_{0}).\quad
  </annotation>
 </semantics>
</math>

</p>

<p>For the exact solution, we use the Taylor expansion mentioned in the section <a href="#Derivation" title="wikilink"><em>Derivation</em></a> above:</p>

<p>

<math display="block" id="Euler_method:69">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mi>h</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <msup>
       <mi>y</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <msup>
       <mi>h</mi>
       <mn>2</mn>
      </msup>
      <msup>
       <mi>y</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>h</mi>
        <mn>3</mn>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>′′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t_{0}+h)=y(t_{0})+hy^{\prime}(t_{0})+\frac{1}{2}h^{2}y^{\prime\prime}(t_{0})%
+O(h^{3}).
  </annotation>
 </semantics>
</math>

</p>

<p>The local truncation error (LTE) introduced by the Euler method is given by the difference between these equations:</p>

<p>

<math display="block" id="Euler_method:70">
 <semantics>
  <mrow>
   <mrow>
    <mi>LTE</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>t</mi>
         <mn>0</mn>
        </msub>
        <mo>+</mo>
        <mi>h</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <msup>
       <mi>h</mi>
       <mn>2</mn>
      </msup>
      <msup>
       <mi>y</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>h</mi>
        <mn>3</mn>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>LTE</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>y</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>h</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>′′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>O</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{LTE}=y(t_{0}+h)-y_{1}=\frac{1}{2}h^{2}y^{\prime\prime}(t_{0})+O(h^{3}).
  </annotation>
 </semantics>
</math>

</p>

<p>This result is valid if 

<math display="inline" id="Euler_method:71">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 has a bounded third derivative.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>This shows that for small 

<math display="inline" id="Euler_method:72">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, the local truncation error is approximately proportional to 

<math display="inline" id="Euler_method:73">
 <semantics>
  <msup>
   <mi>h</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{2}
  </annotation>
 </semantics>
</math>

. This makes the Euler method less accurate (for small 

<math display="inline" id="Euler_method:74">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

) than other higher-order techniques such as <a href="Runge-Kutta_method" title="wikilink">Runge-Kutta methods</a> and <a href="linear_multistep_method" title="wikilink">linear multistep methods</a>, for which the local truncation error is proportial to a higher power of the step size.</p>

<p>A slightly different formulation for the local truncation error can be obtained by using the Lagrange form for the remainder term in <a href="Taylor's_theorem" title="wikilink">Taylor's theorem</a>. If 

<math display="inline" id="Euler_method:75">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 has a continuous second derivative, then there exists a 

<math display="inline" id="Euler_method:76">
 <semantics>
  <mrow>
   <mi>ξ</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>t</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mi>h</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ξ</ci>
    <interval closure="closed">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>h</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi\in[t_{0},t_{0}+h]
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Euler_method:77">
 <semantics>
  <mrow>
   <mrow>
    <mi>LTE</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>t</mi>
         <mn>0</mn>
        </msub>
        <mo>+</mo>
        <mi>h</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <msup>
      <mi>h</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>y</mi>
      <mi>′′</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ξ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>LTE</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>y</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>h</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>′′</ci>
      </apply>
      <ci>ξ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{LTE}=y(t_{0}+h)-y_{1}=\frac{1}{2}h^{2}y^{\prime\prime}(\xi).
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>In the above expressions for the error, the second derivative of the unknown exact solution 

<math display="inline" id="Euler_method:78">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 can be replaced by an expression involving the right-hand side of the differential equation. Indeed, it follows from the equation 

<math display="inline" id="Euler_method:79">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>t</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=f(t,y)
  </annotation>
 </semantics>
</math>

 that</p>

<p>

<math display="block" id="Euler_method:80">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>y</mi>
      <mi>′′</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>f</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <mi>t</mi>
       </mrow>
      </mfrac>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>t</mi>
          <mn>0</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>f</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <mi>y</mi>
       </mrow>
      </mfrac>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>t</mi>
          <mn>0</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>t</mi>
          <mn>0</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>′′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>f</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>t</ci>
       </apply>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>f</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>y</ci>
       </apply>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </interval>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime\prime}(t_{0})={\partial f\over\partial t}(t_{0},y(t_{0}))+{\partial f%
\over\partial y}(t_{0},y(t_{0}))\,f(t_{0},y(t_{0})).
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="global-truncation-error">Global truncation error</h2>

<p>The <a href="global_truncation_error" title="wikilink">global truncation error</a> is the error at a fixed time 

<math display="inline" id="Euler_method:81">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, after however many steps the methods needs to take to reach that time from the initial time. The global truncation error is the cumulative effect of the local truncation errors committed in each step.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The number of steps is easily determined to be 

<math display="inline" id="Euler_method:82">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <msub>
      <mi>t</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (t-t_{0})/h
  </annotation>
 </semantics>
</math>

, which is proportional to 

<math display="inline" id="Euler_method:83">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/h
  </annotation>
 </semantics>
</math>

, and the error committed in each step is proportional to 

<math display="inline" id="Euler_method:84">
 <semantics>
  <msup>
   <mi>h</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{2}
  </annotation>
 </semantics>
</math>

 (see the previous section). Thus, it is to be expected that the global truncation error will be proportional to 

<math display="inline" id="Euler_method:85">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>This intuitive reasoning can be made precise. If the solution 

<math display="inline" id="Euler_method:86">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 has a bounded second derivative and 

<math display="inline" id="Euler_method:87">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is <a href="Lipschitz_continuity" title="wikilink">Lipschitz continuous</a> in its second argument, then the global truncation error (GTE) is bounded by</p>

<p>

<math display="block" id="Euler_method:88">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mtext>GTE</mtext>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mi>h</mi>
       <mi>M</mi>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>L</mi>
      </mrow>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>e</mi>
        <mrow>
         <mi>L</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>t</mi>
           <mo>-</mo>
           <msub>
            <mi>t</mi>
            <mn>0</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msup>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <mtext>GTE</mtext>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>M</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>L</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>L</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\text{GTE}|\leq\frac{hM}{2L}(e^{L(t-t_{0})}-1)\qquad\qquad
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Euler_method:89">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is an upper bound on the second derivative of 

<math display="inline" id="Euler_method:90">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 on the given interval and 

<math display="inline" id="Euler_method:91">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is the Lipschitz constant of 

<math display="inline" id="Euler_method:92">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>The precise form of this bound of little practical importance, as in most cases the bound vastly overestimates the actual error committed by the Euler method.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> What is important is that it shows that the global truncation error is (approximately) proportional to 

<math display="inline" id="Euler_method:93">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

. For this reason, the Euler method is said to be first order.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="numerical-stability">Numerical stability</h2>

<p> The Euler method can also be numerically <a href="numerical_stability" title="wikilink">unstable</a>, especially for <a href="stiff_equation" title="wikilink">stiff equations</a>, meaning that the numerical solution grows very large for equations where the exact solution does not. This can be illustrated using the linear equation</p>

<p>

<math display="block" id="Euler_method:94">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mn>2.3</mn>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="float">2.3</cn>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=-2.3y,\qquad y(0)=1.
  </annotation>
 </semantics>
</math>

 The exact solution is 

<math display="inline" id="Euler_method:95">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mn>2.3</mn>
      <mi>t</mi>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="float">2.3</cn>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=e^{-2.3t}
  </annotation>
 </semantics>
</math>

, which decays to zero as 

<math display="inline" id="Euler_method:96">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>t</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\to\infty
  </annotation>
 </semantics>
</math>

. However, if the Euler method is applied to this equation with step size 

<math display="inline" id="Euler_method:97">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=1
  </annotation>
 </semantics>
</math>

, then the numerical solution is qualitatively wrong: it oscillates and grows (see the figure). This is what it means to be unstable. If a smaller step size is used, for instance 

<math display="inline" id="Euler_method:98">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mn>0.7</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <cn type="float">0.7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=0.7
  </annotation>
 </semantics>
</math>

, then the numerical solution does decay to zero.</p>

<p> If the Euler method is applied to the linear equation 

<math display="inline" id="Euler_method:99">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}=ky
  </annotation>
 </semantics>
</math>

, then the numerical solution is unstable if the product 

<math display="inline" id="Euler_method:100">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   hk
  </annotation>
 </semantics>
</math>

 is outside the region</p>

<p>

<math display="block" id="Euler_method:101">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>z</mi>
     <mo>∈</mo>
     <mi>𝐂</mi>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>z</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>≤</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>z</ci>
     <ci>𝐂</ci>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <apply>
       <plus></plus>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{z\in\mathbf{C}\mid|z+1|\leq 1\},
  </annotation>
 </semantics>
</math>

 illustrated on the right. This region is called the (linear) instability region.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> In the example, 

<math display="inline" id="Euler_method:102">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 equals −2.3, so if 

<math display="inline" id="Euler_method:103">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=1
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Euler_method:104">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mi>k</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>2.3</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="float">2.3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   hk=-2.3
  </annotation>
 </semantics>
</math>

 which is outside the stability region, and thus the numerical solution is unstable.</p>

<p>This limitation —along with its slow convergence of error with <em>h</em>— means that the Euler method is not often used, except as a simple example of numerical integration.</p>
<h2 id="rounding-errors">Rounding errors</h2>

<p>The discussion up to now has ignored the consequences of <a href="rounding_error" title="wikilink">rounding error</a>. In step <em>n</em> of the Euler method, the rounding error is roughly of the magnitude ε<em>y</em><sub><em>n</em></sub> where ε is the <a href="machine_epsilon" title="wikilink">machine epsilon</a>. Assuming that the rounding errors are all of approximately the same size, the combined rounding error in <em>N</em> steps is roughly <em>N</em>ε<em>y</em><sub>0</sub> if all errors points in the same direction. Since the number of steps is inversely proportional to the step size <em>h</em>, the total rounding error is proportional to ε / <em>h</em>. In reality, however, it is extremely unlikely that all rounding errors point in the same direction. If instead it is assumed that the rounding errors are independent rounding variables, then the total rounding error is proportional to 

<math display="inline" id="Euler_method:105">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo>/</mo>
   <msqrt>
    <mi>h</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>ε</ci>
    <apply>
     <root></root>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon/\sqrt{h}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Thus, for extremely small values of the step size, the truncation error will be small but the effect of rounding error may be big. Most of the effect of rounding error can be easily avoided if <a href="compensated_summation" title="wikilink">compensated summation</a> is used in the formula for the Euler method.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="modifications-and-extensions">Modifications and extensions</h2>

<p>A simple modification of the Euler method which eliminates the stability problems noted in the previous section is the <a href="backward_Euler_method" title="wikilink">backward Euler method</a>:</p>

<p>

<math display="block" id="Euler_method:106">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}=y_{n}+hf(t_{n+1},y_{n+1}).
  </annotation>
 </semantics>
</math>

 This differs from the (standard, or forward) Euler method in that the function 

<math display="inline" id="Euler_method:107">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is evaluated at the end point of the step, instead of the starting point. The backward Euler method is an <a href="explicit_and_implicit_methods" title="wikilink">implicit method</a>, meaning that the formula for the backward Euler method has 

<math display="inline" id="Euler_method:108">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}
  </annotation>
 </semantics>
</math>

 on both sides, so when applying the backward Euler method we have to solve an equation. This makes the implementation more costly.</p>

<p>Other modifications of the Euler method that help with stability yield the <a href="exponential_Euler_method" title="wikilink">exponential Euler method</a> or the <a href="semi-implicit_Euler_method" title="wikilink">semi-implicit Euler method</a>.</p>

<p>More complicated methods can achieve a higher order (and more accuracy). One possibility is to use more function evaluations. This is illustrated by the <a href="midpoint_method" title="wikilink">midpoint method</a> which is already mentioned in this article:</p>

<p>

<math display="block" id="Euler_method:109">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <mi>f</mi>
      <mrow>
       <mo maxsize="160%" minsize="160%">(</mo>
       <mrow>
        <msub>
         <mi>t</mi>
         <mi>n</mi>
        </msub>
        <mo>+</mo>
        <mrow>
         <mstyle displaystyle="false">
          <mfrac>
           <mn>1</mn>
           <mn>2</mn>
          </mfrac>
         </mstyle>
         <mi>h</mi>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>n</mi>
        </msub>
        <mo>+</mo>
        <mrow>
         <mstyle displaystyle="false">
          <mfrac>
           <mn>1</mn>
           <mn>2</mn>
          </mfrac>
         </mstyle>
         <mi>h</mi>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>t</mi>
           <mi>n</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo maxsize="160%" minsize="160%">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
         <ci>h</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
         <ci>h</ci>
         <ci>f</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>n</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}=y_{n}+hf\Big(t_{n}+\tfrac{1}{2}h,y_{n}+\tfrac{1}{2}hf(t_{n},y_{n})\Big).
  </annotation>
 </semantics>
</math>

 This leads to the family of <a href="Runge–Kutta_methods" title="wikilink">Runge–Kutta methods</a>.</p>

<p>The other possibility is to use more past values, as illustrated by the two-step Adams–Bashforth method:</p>

<p>

<math display="block" id="Euler_method:110">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
      <mo>+</mo>
      <mrow>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>3</mn>
         <mn>2</mn>
        </mfrac>
       </mstyle>
       <mi>h</mi>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>t</mi>
         <mi>n</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>y</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mstyle displaystyle="false">
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
      </mstyle>
      <mi>h</mi>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">3</cn>
        <cn type="integer">2</cn>
       </apply>
       <ci>h</ci>
       <ci>f</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <ci>h</ci>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}=y_{n}+\tfrac{3}{2}hf(t_{n},y_{n})-\tfrac{1}{2}hf(t_{n-1},y_{n-1}).
  </annotation>
 </semantics>
</math>

 This leads to the family of <a href="linear_multistep_method" title="wikilink">linear multistep methods</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Dynamic_errors_of_numerical_methods_of_ODE_discretization" title="wikilink">Dynamic errors of numerical methods of ODE discretization</a></li>
<li><a href="Gradient_descent" title="wikilink">Gradient descent</a> similarly uses finite steps, here to find minima of functions</li>
<li><a href="List_of_Runge-Kutta_methods" title="wikilink">List of Runge-Kutta methods</a></li>
<li><a href="Linear_multistep_method" title="wikilink">Linear multistep method</a></li>
<li><a href="Numerical_integration" title="wikilink">Numerical integration</a> (for calculating definite integrals)</li>
<li><a href="Numerical_methods_for_ordinary_differential_equations" title="wikilink">Numerical methods for ordinary differential equations</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://math.fullerton.edu/mathews/n2003/Euler'sMethodMod.html">Euler's Method for O.D.E.'s</a>, by John H. Matthews, California State University at Fullerton.</li>
<li><a href="http://www.mathstools.com/section/main/runge_kutta_calculator">On line calculator for Euler's method</a> by www.mathstools.com</li>
<li><a href="http://rosettacode.org/wiki/Euler_method">Euler method implementations in different languages</a> by <a href="Rosetta_Code" title="wikilink">Rosetta Code</a></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_differential_equations" title="wikilink">Category:Numerical differential equations</a> <a href="Category:Runge–Kutta_methods" title="wikilink">Category:Runge–Kutta methods</a> <a href="Category:First_order_methods" title="wikilink">Category:First order methods</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">; <a href="#fnref1">↩</a></li>
<li id="fn2">; <a href="#fnref2">↩</a></li>
<li id="fn3">; <a href="#fnref3">↩</a></li>
<li id="fn4">; <a href="#fnref4">↩</a></li>
<li id="fn5">See also <a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">; <a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">; <a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18">; <a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
