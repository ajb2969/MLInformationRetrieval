<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1268">Mean shift</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Mean shift</h1>
<hr/>

<p><strong>Mean shift</strong> is a <a class="uri" href="non-parametric" title="wikilink">non-parametric</a> <a href="feature_space" title="wikilink">feature-space</a> analysis technique for locating the maxima of a <a href="density_function" title="wikilink">density function</a>, a so-called <a href="mode_(statistics)" title="wikilink">mode</a>-seeking algorithm.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Application domains include <a href="cluster_analysis" title="wikilink">cluster analysis</a> in <a href="computer_vision" title="wikilink">computer vision</a> and <a href="image_processing" title="wikilink">image processing</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="history">History</h2>

<p>The mean shift procedure was originally presented in 1975 by Fukunaga and Hostetler.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="overview">Overview</h2>

<p>Mean shift is a procedure for locating the maxima of a density function given discrete data sampled from that function.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It is useful for detecting the <a href="Mode_(statistics)" title="wikilink">modes</a> of this density.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This is an iterative method, and we start with an initial estimate 

<math display="inline" id="Mean_shift:0">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. Let a <a href="Kernel_(statistics)" title="wikilink">kernel function</a> 

<math display="inline" id="Mean_shift:1">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>-</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x_{i}-x)
  </annotation>
 </semantics>
</math>

 be given. This function determines the weight of nearby points for re-estimation of the mean. Typically a <a href="Radial_basis_function_kernel" title="wikilink">Gaussian kernel</a> on the distance to the current estimate is used, 

<math display="inline" id="Mean_shift:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>c</mi>
      <msup>
       <mrow>
        <mo fence="true">||</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo>-</mo>
         <mi>x</mi>
        </mrow>
        <mo fence="true">||</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
          <ci>x</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x_{i}-x)=e^{-c||x_{i}-x||^{2}}
  </annotation>
 </semantics>
</math>

. The weighted mean of the density in the window determined by 

<math display="inline" id="Mean_shift:3">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Mean_shift:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo>∈</mo>
        <mrow>
         <mi>N</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </msub>
     </mstyle>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo>-</mo>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo>∈</mo>
        <mrow>
         <mi>N</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </msub>
     </mstyle>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo>-</mo>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <ci>N</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>K</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <ci>N</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>K</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m(x)=\frac{\sum_{x_{i}\in N(x)}K(x_{i}-x)x_{i}}{\sum_{x_{i}\in N(x)}K(x_{i}-x)}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Mean_shift:5">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(x)
  </annotation>
 </semantics>
</math>

 is the neighborhood of 

<math display="inline" id="Mean_shift:6">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, a set of points for which 

<math display="inline" id="Mean_shift:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x)\neq 0
  </annotation>
 </semantics>
</math>

.</p>

<p>The mean-shift algorithm now sets 

<math display="inline" id="Mean_shift:8">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>←</mo>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leftarrow m(x)
  </annotation>
 </semantics>
</math>


, and repeats the estimation until 

<math display="inline" id="Mean_shift:9">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m(x)
  </annotation>
 </semantics>
</math>

 converges.</p>
<h2 id="details">Details</h2>

<p>Let data be a finite set S embedded in the n-dimensional Euclidean space, X. Let K be a flat kernel that is the characteristic function of the 

<math display="inline" id="Mean_shift:10">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

-ball in X,</p>
<div style="text-align: center;">

<p>

<math display="inline" id="Mean_shift:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mrow>
          <mo>∥</mo>
          <mi>x</mi>
          <mo>∥</mo>
         </mrow>
        </mrow>
        <mo>≤</mo>
        <mi>λ</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mrow>
          <mo>∥</mo>
          <mi>x</mi>
          <mo>∥</mo>
         </mrow>
        </mrow>
        <mo>></mo>
        <mi>λ</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>λ</ci>
     </apply>
     <cn type="integer">0</cn>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x)=\begin{cases}1&\text{if}\ \|x\|\leq\lambda\\
0&\text{if}\ \|x\|>\lambda\\
\end{cases}
  </annotation>
 </semantics>
</math>

</p>
</div>

<p>The difference 

<math display="inline" id="Mean_shift:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m(x)-x
  </annotation>
 </semantics>
</math>

 is called <em>mean shift</em> in Fukunaga and Hostetler.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The repeated movement of data points to the sample means is called the <em>mean shift algorithm</em>. In each iteration of the algorithm, 

<math display="inline" id="Mean_shift:13">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>←</mo>
   <mrow>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\leftarrow m(s)
  </annotation>
 </semantics>
</math>

 is performed for all 

<math display="inline" id="Mean_shift:14">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in S
  </annotation>
 </semantics>
</math>

 simultaneously. The first question, then, is how to estimate the density function given a sparse set of samples. One of the simplest approaches is to just smooth the data, e.g., by convolving it with a fixed kernel of width 

<math display="inline" id="Mean_shift:15">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

,</p>
<div style="text-align: center;">

<p>

<math display="inline" id="Mean_shift:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <msup>
        <mrow>
         <mo>∥</mo>
         <mrow>
          <mi>x</mi>
          <mo>-</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
         </mrow>
         <mo>∥</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <msup>
        <mi>h</mi>
        <mn>2</mn>
       </msup>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>K</ci>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>k</ci>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">norm</csymbol>
          <apply>
           <minus></minus>
           <ci>x</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>h</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\sum_{i}K(x-x_{i})=\sum_{i}k\left(\frac{\|x-x_{i}\|^{2}}{h^{2}}\right)
  </annotation>
 </semantics>
</math>

</p>
</div>

<p>where 

<math display="inline" id="Mean_shift:17">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 are the input samples and 

<math display="inline" id="Mean_shift:18">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(r)
  </annotation>
 </semantics>
</math>

 is the kernel function (or <em>Parzen window</em>). h is the only parameter in the algorithm and is called the bandwidth. This approach is known as <em>kernel density estimation</em> or the Parzen window technique. Once we have computed 

<math display="inline" id="Mean_shift:19">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 from equation above, we can find its local maxima using gradient ascent or some other optimization technique. The problem with this "brute force" approach is that, for higher dimensions, it becomes computationally prohibitive to evaluate 

<math display="inline" id="Mean_shift:20">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 over the complete search space. Instead, mean shift uses a variant of what is known in the optimization literature as <em>multiple restart gradient descent</em>. Starting at some guess for a local maximum, 

<math display="inline" id="Mean_shift:21">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

, which can be a random input data point 

<math display="inline" id="Mean_shift:22">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

, mean shift computes the gradient of the density estimate 

<math display="inline" id="Mean_shift:23">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Mean_shift:24">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

 and takes an uphill step in that direction.</p>
<h2 id="types-of-kernels">Types of kernels</h2>

<p>Kernel definition: Let X be the n-dimensional Euclidean space, 

<math display="inline" id="Mean_shift:25">
 <semantics>
  <msup>
   <mi>R</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{n}
  </annotation>
 </semantics>
</math>

. Denote the ith component of x by 

<math display="inline" id="Mean_shift:26">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

. The norm of x is a non-negative number.

<math display="inline" id="Mean_shift:27">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mi>x</mi>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mi>T</mi>
    </msup>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>x</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>T</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x\|^{2}=x^{T}x
  </annotation>
 </semantics>
</math>

 A function K

<math display="block" id="Mean_shift:28">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>←</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>X</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\leftarrow R
  </annotation>
 </semantics>
</math>

 is said to be a kernel if there exists a profile, 

<math display="inline" id="Mean_shift:29">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">∞</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>→</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>k</ci>
    <apply>
     <ci>normal-→</ci>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <infinity></infinity>
     </interval>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k:[0,\infty]\rightarrow R
  </annotation>
 </semantics>
</math>

 , such that</p>

<p>

<math display="inline" id="Mean_shift:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mi>x</mi>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>x</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x)=k(\|x\|^{2})
  </annotation>
 </semantics>
</math>

 and</p>
<ul>
<li>k is non-negative.</li>
<li>k is nonincreasing

<math display="block" id="Mean_shift:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(a)\geq k(b)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Mean_shift:32">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo><</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a<b
  </annotation>
 </semantics>
</math>

.</li>
<li>k is piecewise continuous and 

<math display="inline" id="Mean_shift:33">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>r</mi>
    </mrow>
   </mrow>
   <mo><</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>r</ci>
      <ci>d</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{0}^{\infty}k(r)\,dr<\infty
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The two frequently used kernels for mean shift are:</p>
<dl>
<dt>Flat kernel</dt>
</dl>
<div style="text-align: center;">

<p>

<math display="inline" id="Mean_shift:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mrow>
          <mo>∥</mo>
          <mi>x</mi>
          <mo>∥</mo>
         </mrow>
        </mrow>
        <mo>≤</mo>
        <mi>λ</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mrow>
          <mo>∥</mo>
          <mi>x</mi>
          <mo>∥</mo>
         </mrow>
        </mrow>
        <mo>></mo>
        <mi>λ</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>λ</ci>
     </apply>
     <cn type="integer">0</cn>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x)=\begin{cases}1&\text{if}\ \|x\|\leq\lambda\\
0&\text{if}\ \|x\|>\lambda\\
\end{cases}
  </annotation>
 </semantics>
</math>

</p>
</div>
<dl>
<dt>Gaussian kernel</dt>
</dl>
<div style="text-align: center;">

<p>

<math display="inline" id="Mean_shift:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>k</mi>
      <mo>,</mo>
      <mi>d</mi>
     </mrow>
    </msub>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mi>x</mi>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <list>
       <ci>k</ci>
       <ci>d</ci>
      </list>
     </apply>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>x</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(x)=c_{k,d}k(\|x\|^{2})
  </annotation>
 </semantics>
</math>

</p>
</div>

<p>where 

<math display="inline" id="Mean_shift:36">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>k</mi>
    <mo>,</mo>
    <mi>d</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <list>
     <ci>k</ci>
     <ci>d</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{k,d}
  </annotation>
 </semantics>
</math>

, the normalization constant, makes G(x) integrate to one and 

<math display="inline" id="Mean_shift:37">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x)
  </annotation>
 </semantics>
</math>

 is called the <em>profile</em> of the kernel. It simplifies calculation in the case of multivariate data. The profile of the Gaussian kernel is

<math display="block" id="Mean_shift:38">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mi>x</mi>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>x</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{-1/2\|x\|^{2}}
  </annotation>
 </semantics>
</math>

 and therefore, the multivariate Gaussian kernel with the standard deviation 

<math display="inline" id="Mean_shift:39">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, will be: 

<math display="inline" id="Mean_shift:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msqrt>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
       </mrow>
      </msqrt>
      <msup>
       <mi>σ</mi>
       <mi>d</mi>
      </msup>
     </mrow>
    </mfrac>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
       <mfrac>
        <msup>
         <mrow>
          <mo>∥</mo>
          <mi>x</mi>
          <mo>∥</mo>
         </mrow>
         <mn>2</mn>
        </msup>
        <msup>
         <mi>σ</mi>
         <mn>2</mn>
        </msup>
       </mfrac>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>σ</ci>
        <ci>d</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="latexml">norm</csymbol>
           <ci>x</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>σ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(x)=\frac{1}{\sqrt{2\pi}\sigma^{d}}e^{-1/2\frac{\|x\|^{2}}{\sigma^{2}}}
  </annotation>
 </semantics>
</math>

 where d is the number of dimensions. It's also worth mentioning that the standard deviation for the Gaussian kernel works as the bandwidth parameter, 

<math display="inline" id="Mean_shift:41">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

</p>
<h2 id="applications">Applications</h2>
<h3 id="clustering">Clustering</h3>

<p>Consider a set of points in two-dimensional space. Assume a circular window centered at C and having radius r as the kernel. Mean shift is a hill climbing algorithm which involves shifting this kernel iteratively to a higher density region until convergence. Every shift is defined by a mean shift vector. The mean shift vector always points toward the direction of the maximum increase in the density. At every iteration the kernel is shifted to the centroid or the mean of the points within it. The method of calculating this mean depends on the choice of the kernel. In this case if a Gaussian kernel is chosen instead of a flat kernel, then every point will first be assigned a weight which will decay exponentially as the distance from the kernel's center increases. At convergence, there will be no direction at which a shift can accommodate more points inside the kernel.</p>
<h3 id="tracking">Tracking</h3>

<p>The mean shift algorithm can be used for visual tracking. The simplest such algorithm would create a confidence map in the new image based on the color histogram of the object in the previous image, and use mean shift to find the peak of a confidence map near the object's old position. The confidence map is a probability density function on the new image, assigning each pixel of the new image a probability, which is the probability of the pixel color occurring in the object in the previous image. A few algorithms, such as <a href="ensemble_tracking" title="wikilink">ensemble tracking</a>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> CAMshift,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> expand on this idea.</p>
<h3 id="smoothing">Smoothing</h3>

<p>Let 

<math display="inline" id="Mean_shift:42">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Mean_shift:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>z</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <mi>i</mi>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>i</ci>
      </apply>
      <ci>i</ci>
     </list>
     <cn type="integer">1</cn>
    </apply>
    <list>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{i},i=1,...,n,
  </annotation>
 </semantics>
</math>

 be the d-dimensional input and filtered image pixels in the joint spatial-range domain. For each pixel,</p>
<ul>
<li>Initialize 

<math display="inline" id="Mean_shift:44">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Mean_shift:45">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <list>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i,1}=x_{i}
  </annotation>
 </semantics>
</math>

</li>
<li>Compute 

<math display="inline" id="Mean_shift:46">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <list>
     <ci>i</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i,j+1}
  </annotation>
 </semantics>
</math>

 according to 

<math display="inline" id="Mean_shift:47">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m(\cdot)
  </annotation>
 </semantics>
</math>

 until convergence, 

<math display="inline" id="Mean_shift:48">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>c</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <list>
      <ci>i</ci>
      <ci>c</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=y_{i,c}
  </annotation>
 </semantics>
</math>

.</li>
<li>Assign 

<math display="inline" id="Mean_shift:49">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>x</mi>
     <mi>i</mi>
     <mi>s</mi>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>y</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>c</mi>
     </mrow>
     <mi>r</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>i</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <list>
        <ci>i</ci>
        <ci>c</ci>
       </list>
      </apply>
      <ci>r</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{i}=(x_{i}^{s},y_{i,c}^{r})
  </annotation>
 </semantics>
</math>

. The superscripts s and r denote the spatial and range components of a vector, respectively. The assignment specifies that the filtered data at the spatial location axis will have the range component of the point of convergence 

<math display="inline" id="Mean_shift:50">
 <semantics>
  <msubsup>
   <mi>y</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>c</mi>
   </mrow>
   <mi>r</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <list>
      <ci>i</ci>
      <ci>c</ci>
     </list>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i,c}^{r}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="strengths">Strengths</h2>
<ol>
<li>Mean shift is an application-independent tool suitable for real data analysis.</li>
<li>Does not assume any predefined shape on data clusters.</li>
<li>It is capable of handling arbitrary feature spaces.</li>
<li>The procedure relies on choice of a single parameter: bandwidth.</li>
<li>The bandwidth/window size 'h' has a physical meaning, unlike <a href="k-means" title="wikilink"><em>k</em>-means</a>.</li>
</ol>
<h2 id="weaknesses">Weaknesses</h2>
<ol>
<li>The selection of a window size is not trivial.</li>
<li>Inappropriate window size can cause modes to be merged, or generate additional “shallow” modes.</li>
<li>Often requires using adaptive window size.</li>
</ol>
<h2 id="mean-shift-and-k-means-clustering">Mean shift and <em>k</em>-means clustering</h2>

<p>The mean shift clustering algorithm has two main drawbacks. First, the algorithm is calculation intensive; it requires in general 

<math display="inline" id="Mean_shift:51">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>k</mi>
     <msup>
      <mi>N</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(kN^{2})
  </annotation>
 </semantics>
</math>

 operations, where N is the number of data points and k is the number of average iteration steps for each data point. Second, the mean shift algorithm relies on sufficient high data density with clear gradient to locate the cluster centers. In particular, the mean shift algorithm often fails to find appropriate clusters for so called data outliers, or those data points located between natural clusters.</p>

<p>The <a href="k-means" title="wikilink"><em>k</em>-means</a> algorithm does not have the above two problems. The <em>k</em>-means algorithm normally requires only 

<math display="inline" id="Mean_shift:52">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>k</mi>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(kN)
  </annotation>
 </semantics>
</math>

 operations, so that the <em>k</em>-means algorithm can be applied to relatively large dataset. However, <em>k</em>-means has two significant limitations. First, the <em>k</em>-means algorithm requires that the number of clusters to be pre-determined. In practise, it is often difficult to specify a priori an appropriate cluster number, resulting in some natural clusters being represented by multiple clusters found by the <em>k</em>-means algorithm. Second, the <em>k</em>-means algorithm is, in general, incapable of identifying non-convex clusters. The second limitation makes the <em>k</em>-means algorithm inadequate for complex non-linear data. These problems can be overcome, by simply combining the two algorithms mean shift and <em>k</em>-means together.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Kernel_density_estimation" title="wikilink">Kernel density estimation</a> (KDE)</li>
<li><a href="Kernel_(statistics)" title="wikilink">Kernel (statistics)</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<h3 id="code-implementations">Code implementations</h3>
<ul>
<li><a href="http://scikit-learn.org/">Scikit-learn library</a> Numpy/Python implementation uses ball tree for efficient neighboring points lookup</li>
<li><a href="http://coewww.rutgers.edu/riul/research/code/EDISON/index.html">EDISON library</a>. C++ implementation of mean-shift-based image segmentation. There is also a <a href="http://www.wisdom.weizmann.ac.il/~bagon/matlab.html#edison">Matlab</a> interface for EDISON.</li>
<li><a href="http://sourceforge.net/projects/opencvlibrary/">OpenCV</a> contains mean-shift implementation via cvMeanShift Method</li>
<li><a href="https://bitbucket.org/NicolayMitropolsky/aiphial">Aiphial</a>. Java-based mean-shift implementation for numeric data clustering and image segmentation</li>
<li><a href="http://mahout.apache.org">Apache Mahout</a>. An map-reduce based implementation of MeanShift clustering written on Apache Hadoop.</li>
<li><a href="http://www.gergltd.com/cse486/project5/">CAMSHIFT project</a>. A MATLAB implementation of CAMSHIFT algorithm.</li>
<li><a href="http://www.orfeo-toolbox.org/doxygen-current/classotb_1_1MeanShiftImageFilter.html">OTB MeanShift</a>. A C++ implementation using the <a href="http://www.orfeo-toolbox.org">Orfeo Toolbox</a>.</li>
<li><a href="http://rsbweb.nih.gov/ij/plugins/mean-shift.html">ImageJ Plug-in</a>. Image filtering using the mean shift filter.</li>
<li><a href="http://code.google.com/p/mean-shift/">Mean-shift google code</a>. A simple implementation of mean-shift as image filtering tool.</li>
</ul>
<h3 id="short-lessons">Short lessons</h3>
<ul>
<li><a href="http://www.youtube.com/watch?v=M8B3RZVqgOo">A lesson</a> from Prof. M. Shah on this topic</li>
</ul>

<p>"</p>

<p><a href="Category:Computer_vision" title="wikilink">Category:Computer vision</a> <a href="Category:Data_clustering_algorithms" title="wikilink">Category:Data clustering algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
