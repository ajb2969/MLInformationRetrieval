<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="33">Temporal logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Temporal logic</h1>
<hr/>

<p>In <a class="uri" href="logic" title="wikilink">logic</a>, <strong>temporal logic</strong> is any system of rules and symbolism for representing, and reasoning about, propositions qualified in terms of <a class="uri" href="time" title="wikilink">time</a>. In a temporal logic we can then express statements like "I am <em>always</em> hungry", "I will <em>eventually</em> be hungry", or "I will be hungry <em>until</em> I eat something". Temporal logic is sometimes also used to refer to <strong>tense logic</strong>, a particular <a href="modal_logic" title="wikilink">modal logic</a>-based system of temporal logic introduced by <a href="Arthur_Prior" title="wikilink">Arthur Prior</a> in the late 1950s, and important results were obtained by <a href="Hans_Kamp" title="wikilink">Hans Kamp</a>. Subsequently it has been developed further by <a href="computer_scientists" title="wikilink">computer scientists</a>, notably <a href="Amir_Pnueli" title="wikilink">Amir Pnueli</a>, and <a href="logician" title="wikilink">logicians</a>.</p>

<p>Temporal logic has found an important application in <a href="formal_verification" title="wikilink">formal verification</a>, where it is used to state requirements of hardware or software systems. For instance, one may wish to say that <em>whenever</em> a request is made, access to a resource is <em>eventually</em> granted, but it is <em>never</em> granted to two requestors simultaneously. Such a statement can conveniently be expressed in a temporal logic.</p>
<h2 id="motivation">Motivation</h2>

<p>Consider the statement: "I am hungry." Though its meaning is constant in time, the truth value of the statement can vary in time. Sometimes the statement is true, and sometimes the statement is false, but the statement is never true and false simultaneously. In a temporal logic, statements can have a truth value which can vary in time. Contrast this with an atemporal logic, which can only discuss statements whose truth value is constant in time. This treatment of truth values over time differentiates temporal logic from <a href="Computational_verb_logic#Temporal_logic" title="wikilink">computational verb logic</a>.</p>

<p>Temporal logic always has the ability to reason about a time line. So-called linear time logics are restricted to this type of reasoning. Branching logics, however, can reason about multiple time lines. This presupposes an environment that may act unpredictably. To continue the example, in a branching logic we may state that "there is a possibility that <em>I</em> will stay hungry forever." We may also state that "there is a possibility that eventually <em>I</em> am no longer hungry." If we do not know whether or not <em>I</em> will ever get fed, these statements are both true some times.</p>
<h2 id="history">History</h2>

<p>Although <a class="uri" href="Aristotle" title="wikilink">Aristotle</a>'s logic is almost entirely concerned with the theory of the <a href="categorical_syllogism" title="wikilink">categorical syllogism</a>, there are passages in his work that are now seen as anticipations of temporal logic, and may imply an early, partially developed form of first-order temporal modal binary logic. Aristotle was particularly concerned with the <a href="problem_of_future_contingents" title="wikilink">problem of future contingents</a>, where he could not accept that the <a href="principle_of_bivalence" title="wikilink">principle of bivalence</a> applies to statements about future events, i.e. that we can presently decide if a statement about a future event is true or false, such as "there will be a sea battle tomorrow".<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>There was little development for millennia, <a href="Charles_Sanders_Peirce" title="wikilink">Charles Sanders Peirce</a> noted in the 19th century:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> </p>

<p><a href="Arthur_Prior" title="wikilink">Arthur Prior</a> was concerned with the philosophical matters of <a href="free_will" title="wikilink">free will</a> and <a class="uri" href="predestination" title="wikilink">predestination</a>. According to his wife, he first considered formalizing temporal logic in 1953. He gave lectures on the topic at the <a href="University_of_Oxford" title="wikilink">University of Oxford</a> in 1955-6, and in 1957 published a book, <em>Time and Modality</em>, in which he introduced a <a href="propositional_logic" title="wikilink">propositional</a> modal logic with two temporal connectives (<a href="modal_operator" title="wikilink">modal operators</a>), F and P, corresponding to "sometime in the future" and "sometime in the past". In this early work, Prior considered time to be linear. In 1958 however, he received a letter from <a href="Saul_Kripke" title="wikilink">Saul Kripke</a>, who pointed out that this assumption is perhaps unwarranted. In a development that foreshadowed a similar one in computer science, Prior took this under advisement, and developed two theories of branching time, which he called "Ockhamist" and "Peircean".<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Between 1958 and 1965 Prior also corresponded with <a href="Charles_Leonard_Hamblin" title="wikilink">Charles Leonard Hamblin</a>, and a number of early developments in the field can be traced to this correspondence, for example <a href="Hamblin_implications" title="wikilink">Hamblin implications</a>. Prior published his most mature work on the topic, the book <em>Past, Present, and Future</em> in 1967. He died two years later.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The binary temporal operators <em>Since</em> and <em>Until</em> were introduced by <a href="Hans_Kamp" title="wikilink">Hans Kamp</a> in his 1968 Ph. D. thesis,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> which also contains an important result relating temporal logic to <a href="first_order_logic" title="wikilink">first order logic</a>â€”a result now known as <a href="Kamp's_theorem" title="wikilink">Kamp's theorem</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Two early contenders in formal verifications were <a href="Linear_Temporal_Logic" title="wikilink">Linear Temporal Logic</a> (a linear time logic by <a href="Amir_Pnueli" title="wikilink">Amir Pnueli</a>) and <a href="Computational_tree_logic" title="wikilink">Computation Tree Logic</a>, a branching time logic by Mordechai Ben-Ari, <a href="Zohar_Manna" title="wikilink">Zohar Manna</a> and <a href="Amir_Pnueli" title="wikilink">Amir Pnueli</a>. An almost equivalent formalism to CTL was suggested around the same time by <a href="Edmund_M._Clarke" title="wikilink">E.M. Clarke</a> and <a href="E._Allen_Emerson" title="wikilink">E.A. Emerson</a>. The fact that the second logic can be decided more efficiently than the first does not reflect on branching and linear logics in general, as has sometimes been argued. Rather, Emerson and Lei show that any linear logic can be extended to a branching logic that can be decided with the same complexity.</p>
<h2 id="temporal-operators">Temporal operators</h2>

<p>Temporal logic has two kinds of operators: <a href="logical_operator" title="wikilink">logical operators</a> and <a href="modal_operator" title="wikilink">modal operators</a> <a href="http://plato.stanford.edu/entries/logic-temporal/">1</a>. Logical operators are usual <a class="uri" href="truth-functional" title="wikilink">truth-functional</a> operators (

<math display="inline" id="Temporal_logic:0">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Â¬</mi>
   <mo>,</mo>
   <mo>,</mo>
   <mi mathvariant="italic">and</mi>
   <mo>,</mo>
   <mo>â†’</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <not></not>
    <ci>normal-,</ci>
    <ci>normal-,</ci>
    <csymbol cd="unknown">and</csymbol>
    <ci>normal-,</ci>
    <ci>normal-â†’</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg,,\and,\rightarrow
  </annotation>
 </semantics>
</math>

). The modal operators used in Linear Temporal Logic and Computation Tree Logic are defined as follows.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Textual</p></th>
<th style="text-align: left;">
<p>Symbolic</p></th>
<th style="text-align: left;">
<p>Definition</p></th>
<th style="text-align: left;">
<p>Explanation</p></th>
<th style="text-align: left;">
<p>Diagram</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Binary_operator" title="wikilink">Binary operators</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:1">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 <strong>U</strong> 

<math display="inline" id="Temporal_logic:2">
 <semantics>
  <mi>Ïˆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ïˆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:3">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>Ï•</mi>
   </mpadded>
   <mpadded width="+3.3pt">
    <mi class="ltx_font_mathcaligraphic">ğ’°</mi>
   </mpadded>
   <mi>Ïˆ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Ï•</ci>
    <ci>ğ’°</ci>
    <ci>Ïˆ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi~{}\mathcal{U}~{}\psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><math>\begin{matrix}(B\,\mathcal{U}\,C)(\phi)= \\ (\exists i:C(\phi_i)\land(\forall j<i:b math=""></i:b></math></p></td>
<td style="text-align: left;">
<p><strong>U</strong>ntil

<math display="block" id="Temporal_logic:4">
 <semantics>
  <mi>Ïˆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ïˆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 holds at the current or a future position, and 

<math display="inline" id="Temporal_logic:5">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 has to hold until that position. At that position 

<math display="inline" id="Temporal_logic:6">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 does not have to hold any more.</p></td>
<td style="text-align: left;">
<p><timeline> ImageSize = width:240 height:94 PlotArea = left:30 bottom:30 top:0 right:20 DateFormat = x.y Period = from:0 till:6 TimeAxis = orientation:horizontal AlignBars = justify ScaleMajor = gridcolor:black increment:1 start:0 ScaleMinor = gridcolor:black increment:1 start:0 PlotData=</timeline></p>

<p><code>bar:pÂ color:redÂ width:10Â align:leftÂ fontsize:S</code><br/>
<code>from:1Â till:3</code><br/>
<code>bar:qÂ color:redÂ width:10Â align:leftÂ fontsize:S</code><br/>
<code>from:3Â till:5</code><br/>
<code>bar:pUqÂ color:redÂ width:10Â align:leftÂ fontsize:S</code><br/>
<code>from:1Â till:5</code></p>

<p></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:7">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 <strong>R</strong> 

<math display="inline" id="Temporal_logic:8">
 <semantics>
  <mi>Ïˆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ïˆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:9">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>Ï•</mi>
   </mpadded>
   <mpadded width="+3.3pt">
    <mi class="ltx_font_mathcaligraphic">â„›</mi>
   </mpadded>
   <mi>Ïˆ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Ï•</ci>
    <ci>â„›</ci>
    <ci>Ïˆ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi~{}\mathcal{R}~{}\psi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><math>\begin{matrix}(B\,\mathcal{R}\,C)(\phi)= \\ (\forall i:C(\phi_i)\lor(\exists j<i:b math=""></i:b></math></p></td>
<td style="text-align: left;">
<p><strong>R</strong>elease

<math display="block" id="Temporal_logic:10">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 releases 

<math display="inline" id="Temporal_logic:11">
 <semantics>
  <mi>Ïˆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ïˆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Temporal_logic:12">
 <semantics>
  <mi>Ïˆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ïˆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 is true until the first position in which 

<math display="inline" id="Temporal_logic:13">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is true (or forever if such a position does not exist).</p></td>
<td style="text-align: left;">
<p><timeline> ImageSize = width:240 height:100 PlotArea = left:30 bottom:30 top:0 right:20 DateFormat = x.y Period = from:0 till:8 TimeAxis = orientation:horizontal AlignBars = justify ScaleMajor = gridcolor:black increment:1 start:0 ScaleMinor = gridcolor:black increment:1 start:0 PlotData=</timeline></p>

<p><code>bar:pÂ color:redÂ width:10Â align:leftÂ fontsize:S</code><br/>
<code>from:2Â till:4</code><br/>
<code>from:6Â till:8</code><br/>
<code>bar:qÂ color:redÂ width:10Â align:leftÂ fontsize:S</code><br/>
<code>from:1Â till:3</code><br/>
<code>from:5Â till:6</code><br/>
<code>from:7Â till:8</code><br/>
<code>bar:pRqÂ color:redÂ width:10Â align:leftÂ fontsize:S</code><br/>
<code>from:1Â till:3</code><br/>
<code>from:7Â till:8</code></p>

<p></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Unary_operator" title="wikilink">Unary operators</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>N</strong> 

<math display="inline" id="Temporal_logic:14">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:15">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>â—‹</mo>
   <mi>Ï•</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â—‹</ci>
    <csymbol cd="latexml">absent</csymbol>
    <ci>Ï•</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigcirc\phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:16">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ğ’©</mi>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>Ï•</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>Ï•</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ğ’©</ci>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Ï•</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Ï•</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}B(\phi_{i})=B(\phi_{i+1})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>N</strong>ext

<math display="block" id="Temporal_logic:17">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 has to hold at the next state. (<strong>X</strong> is used synonymously.)</p></td>
<td style="text-align: left;">
<p><timeline> ImageSize = width:240 height:60 PlotArea = left:30 bottom:30 top:0 right:20 DateFormat = x.y Period = from:0 till:6 TimeAxis = orientation:horizontal AlignBars = justify ScaleMajor = gridcolor:black increment:1 start:0 ScaleMinor = gridcolor:black increment:1 start:0 PlotData=</timeline></p>

<p><code>bar:pÂ color:redÂ width:10Â align:leftÂ fontsize:S</code><br/>
<code>from:2Â till:3</code><br/>
<code>from:5Â till:6</code><br/>
<code>bar:NpÂ color:redÂ width:10Â align:leftÂ fontsize:S</code><br/>
<code>from:1Â till:2</code><br/>
<code>from:4Â till:5</code></p>

<p></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>F</strong> 

<math display="inline" id="Temporal_logic:18">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:19">
 <semantics>
  <mrow>
   <mi mathvariant="normal">â—‡</mi>
   <mi>Ï•</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-â—‡</ci>
    <ci>Ï•</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond\phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:20">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">â„±</mi>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Ï•</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mi>r</mi>
      <mi>u</mi>
      <mpadded width="+1.7pt">
       <mi>e</mi>
      </mpadded>
      <mpadded width="+1.7pt">
       <mi class="ltx_font_mathcaligraphic">ğ’°</mi>
      </mpadded>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Ï•</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>â„±</ci>
     <ci>B</ci>
     <ci>Ï•</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>r</ci>
      <ci>u</ci>
      <ci>e</ci>
      <ci>ğ’°</ci>
      <ci>B</ci>
     </apply>
     <ci>Ï•</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}B(\phi)=(true\,\mathcal{U}\,B)(\phi)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>F</strong>uture

<math display="block" id="Temporal_logic:21">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 eventually has to hold (somewhere on the subsequent path).</p></td>
<td style="text-align: left;">
<p><timeline> ImageSize = width:240 height:60 PlotArea = left:30 bottom:30 top:0 right:20 DateFormat = x.y Period = from:0 till:6 TimeAxis = orientation:horizontal AlignBars = justify ScaleMajor = gridcolor:black increment:1 start:0 ScaleMinor = gridcolor:black increment:1 start:0 PlotData=</timeline></p>

<p><code>bar:pÂ color:redÂ width:10Â align:leftÂ fontsize:S</code><br/>
<code>from:2Â till:3</code><br/>
<code>from:4Â till:5</code><br/>
<code>bar:FpÂ color:redÂ width:10Â align:leftÂ fontsize:S</code><br/>
<code>from:0Â till:5</code></p>

<p></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>G</strong> 

<math display="inline" id="Temporal_logic:22">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:23">
 <semantics>
  <mrow>
   <mi mathvariant="normal">â–¡</mi>
   <mi>Ï•</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-â–¡</ci>
    <ci>Ï•</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box\phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:24">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ğ’¢</mi>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Ï•</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Â¬</mi>
    <mi class="ltx_font_mathcaligraphic">â„±</mi>
    <mi mathvariant="normal">Â¬</mi>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Ï•</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ğ’¢</ci>
     <ci>B</ci>
     <ci>Ï•</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>â„±</ci>
     <not></not>
     <ci>B</ci>
     <ci>Ï•</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}B(\phi)=\neg\mathcal{F}\neg B(\phi)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>G</strong>lobally

<math display="block" id="Temporal_logic:25">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 has to hold on the entire subsequent path.</p></td>
<td style="text-align: left;">
<p><timeline> ImageSize = width:240 height:60 PlotArea = left:30 bottom:30 top:0 right:20 DateFormat = x.y Period = from:0 till:6 TimeAxis = orientation:horizontal AlignBars = justify ScaleMajor = gridcolor:black increment:1 start:0 ScaleMinor = gridcolor:black increment:1 start:0 PlotData=</timeline></p>

<p><code>bar:pÂ color:redÂ width:10Â align:leftÂ fontsize:S</code><br/>
<code>from:1Â till:3</code><br/>
<code>from:4Â till:6</code><br/>
<code>bar:GpÂ color:redÂ width:10Â align:leftÂ fontsize:S</code><br/>
<code>from:4Â till:6</code></p>

<p></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>A</strong> 

<math display="inline" id="Temporal_logic:26">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:27">
 <semantics>
  <mrow>
   <mo>âˆ€</mo>
   <mi>Ï•</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>Ï•</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:28">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi class="ltx_font_mathcaligraphic">ğ’œ</mi>
         <mi>B</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Ïˆ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mi></mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo>âˆ€</mo>
        <mi>Ï•</mi>
       </mrow>
       <mo>:</mo>
       <mrow>
        <msub>
         <mi>Ï•</mi>
         <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mi>Ïˆ</mi>
        <mo>â†’</mo>
        <mrow>
         <mi>B</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>Ï•</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>ğ’œ</ci>
        <ci>B</ci>
       </apply>
       <ci>Ïˆ</ci>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>Ï•</ci>
      </apply>
      <apply>
       <and></and>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Ï•</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>Ïˆ</ci>
       </apply>
       <apply>
        <ci>normal-â†’</ci>
        <share href="#.cmml">
        </share>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>Ï•</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}(\mathcal{A}B)(\psi)=\\
(\forall\phi:\phi_{0}=\psi\to B(\phi))\end{matrix}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>A</strong>ll

<math display="block" id="Temporal_logic:29">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 has to hold on all paths starting from the current state.</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>E</strong> 

<math display="inline" id="Temporal_logic:30">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:31">
 <semantics>
  <mrow>
   <mo>âˆƒ</mo>
   <mi>Ï•</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>Ï•</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists\phi
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Temporal_logic:32">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi class="ltx_font_mathcaligraphic">â„°</mi>
         <mi>B</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Ïˆ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mi></mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo>âˆƒ</mo>
        <mi>Ï•</mi>
       </mrow>
       <mo>:</mo>
       <mrow>
        <msub>
         <mi>Ï•</mi>
         <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mrow>
         <mi>Ïˆ</mi>
         <mo>âˆ§</mo>
         <mrow>
          <mi>B</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>Ï•</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>â„°</ci>
        <ci>B</ci>
       </apply>
       <ci>Ïˆ</ci>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <exists></exists>
       <ci>Ï•</ci>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Ï•</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <and></and>
        <ci>Ïˆ</ci>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>Ï•</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}(\mathcal{E}B)(\psi)=\\
(\exists\phi:\phi_{0}=\psi\land B(\phi))\end{matrix}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><strong>E</strong>xists: there exists at least one path starting from the current state where 

<math display="inline" id="Temporal_logic:33">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 holds.</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>Alternate symbols:</p>
<ul>
<li>operator <strong>R</strong> is sometimes denoted by <strong>V</strong></li>
<li>The operator <strong>W</strong> is the <em>weak until</em> operator

<math display="block" id="Temporal_logic:34">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mi>W</mi>
   <mi>g</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>W</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   fWg
  </annotation>
 </semantics>
</math>

 is equivalent to 

<math display="inline" id="Temporal_logic:35">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mi>U</mi>
   <mi>g</mi>
   <mi>G</mi>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>U</ci>
    <ci>g</ci>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   fUgGf
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Unary operators are <a href="well-formed_formula" title="wikilink">well-formed formulas</a> whenever B(

<math display="inline" id="Temporal_logic:36">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

) is well-formed. Binary operators are well-formed formulas whenever B(

<math display="inline" id="Temporal_logic:37">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

) and C(

<math display="inline" id="Temporal_logic:38">
 <semantics>
  <mi>Ï•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Ï•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

) are well-formed.</p>

<p>In some logics, some operators cannot be expressed. For example, <strong>N</strong> operator cannot be expressed in <a href="Temporal_Logic_of_Actions" title="wikilink">Temporal Logic of Actions</a>.</p>
<h2 id="temporal-logics">Temporal logics</h2>

<p>Temporal logics include</p>
<ul>
<li><a href="Interval_temporal_logic" title="wikilink">Interval temporal logic</a> (ITL)</li>
<li><a href="mu_calculus" title="wikilink">Î¼ calculus</a>. which includes as a subset
<ul>
<li><a href="Hennessy-Milner_logic" title="wikilink">Hennessy-Milner logic</a> (HML)</li>
<li><a class="uri" href="CTL*" title="wikilink">CTL*</a>, which includes as a subset
<ul>
<li><a href="Computational_tree_logic" title="wikilink">Computational tree logic</a> (CTL)</li>
<li><a href="Linear_temporal_logic" title="wikilink">Linear temporal logic</a> (LTL)</li>
<li><a href="Metric_interval_temporal_logic" title="wikilink">Metric interval temporal logic</a> (MITL) <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></li>
<li><a href="Signal_temporal_logic" title="wikilink">Signal temporal logic</a> (STL) <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
</ul></li>
</ul></li>
</ul>

<p>A variation, closely related to temporal or chronological or tense logics, are modal logics based upon "topology", "place", or "spatial position".<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="HPO_formalism" title="wikilink">HPO formalism</a></li>
<li><a href="Kripke_structure" title="wikilink">Kripke structure</a></li>
<li><a href="Automata_theory" title="wikilink">Automata theory</a></li>
<li><a href="Chomsky_grammar" title="wikilink">Chomsky grammar</a></li>
<li><a href="State_transition_system" title="wikilink">State transition system</a></li>
<li><a href="Duration_calculus" title="wikilink">Duration calculus</a> (DC)</li>
<li><a href="Hybrid_logic" title="wikilink">Hybrid logic</a></li>
<li><a href="Temporal_logic_in_finite-state_verification" title="wikilink">Temporal logic in finite-state verification</a></li>
<li><a href="Temporal_logic_of_actions" title="wikilink">Temporal logic of actions</a> (TLA)</li>
<li><a href="List_of_important_publications_in_computer_science#Formal_verification" title="wikilink">Important publications in formal verification</a> (including the use of temporal logic in <a href="formal_verification" title="wikilink">formal verification</a>)</li>
<li><a href="Reo_Coordination_Language" title="wikilink">Reo Coordination Language</a></li>
<li><a href="Modal_logic" title="wikilink">Modal logic</a></li>
<li><a href="Research_Materials:_Max_Planck_Society_Archive" title="wikilink">Research Materials: Max Planck Society Archive</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Mordechai Ben-Ari, Zohar Manna, Amir Pnueli: The Temporal Logic of Branching Time. POPL 1981: 164-176</li>
<li>Amir Pnueli: The Temporal Logic of Programs FOCS 1977: 46-57</li>
<li>Venema, Yde, 2001, "Temporal Logic," in Goble, Lou, ed., <em>The Blackwell Guide to Philosophical Logic</em>. Blackwell.</li>
<li>E. A. Emerson and C. Lei, modalities for model checking: branching time logic strikes back, in <em>Science of Computer Programming</em> 8, p 275-306, 1987.</li>
<li>E.A. Emerson, Temporal and modal logic, <em>Handbook of Theoretical Computer Science</em>, Chapter 16, the MIT Press, 1990</li>
<li>

<p><a href="http://www.cs.rice.edu/~vardi/papers/25mc.ps.gz">preprint</a> Historical perspective on how seemingly disparate ideas came together in computer science and engineering. (The mention of Church in the title of this paper is a reference to a little-known 1957 paper, in which Church proposed a way to perform hardware verification.)</p></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>: "<a href="http://plato.stanford.edu/entries/logic-temporal/">Temporal Logic</a>" -- by Anthony Galton.</li>
<li><a href="http://staff.science.uva.nl/~yde/papers/TempLog.pdf">Temporal Logic</a> by Yde Venema, formal description of syntax and semantics, questions of axiomatization. Treating also Kamp's dyadic temporal operators (since, until)</li>
<li><a href="http://www.doc.ic.ac.uk/~imh/papers/sa.ps.gz">Notes on games in temporal logic</a> by Ian Hodkinson, including a formal description of first-order temporal logic</li>
<li><a href="http://www.inrialpes.fr/vasy/cadp">CADP - provides generic model checkers for various temporal logic</a></li>
<li><a href="http://www.comp.nus.edu.sg/~pat/">PAT</a> is a powerful free model checker, LTL checker, simulator and refinement checker for CSP and its extensions (with shared variable, arrays, wide range of fairness).</li>
</ul>

<p>"</p>

<p><a href="Category:Temporal_logic" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Vardi 2008, p. 153<a href="#fnref1">â†©</a></li>
<li id="fn2">Vardi 2008, p. 154<a href="#fnref2">â†©</a></li>
<li id="fn3"></li>
<li id="fn4"> pp. 176-178, 210<a href="#fnref4">â†©</a></li>
<li id="fn5"><a href="#fnref5">â†©</a></li>
<li id="fn6"><a href="#fnref6">â†©</a></li>
<li id="fn7">Vardi 2008, p. 154<a href="#fnref7">â†©</a></li>
<li id="fn8"><a href="#fnref8">â†©</a></li>
<li id="fn9">O. Maler, D. Nickovic, "Monitoring temporal properties of continuous signals", 2004<a href="#fnref9">â†©</a></li>
<li id="fn10"></li>
<li id="fn11">Nicholas Rescher, James Garson, "Topological Logic" in The Journal of Symbolic Logic, 33(4):537-548, December, 1968<a href="#fnref11">â†©</a></li>
<li id="fn12">Georg Henrik von Wright, "A Modal Logic of Place", in E. Sosa (Editor), pp. 65-73, "The Philosophy of Nicholas Rescher: Discussion and Replies", D. Reidel, Dordrecht, Holland, 1979<a href="#fnref12">â†©</a></li>
</ol>
</section>
</body>
</html>
