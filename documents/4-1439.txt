   Dixon's factorization method      Dixon's factorization method   In number theory , Dixon's factorization method (also Dixon's random squares method 1 or Dixon's algorithm ) is a general-purpose integer factorization  algorithm ; it is the prototypical factor base method, and the only factor base method for which a run-time bound not reliant on conjectures about the smoothness properties of values of a polynomial is known.  The algorithm was designed by John D. Dixon , a mathematician at Carleton University , and was published in 1981. 2  Basic idea  Dixon's method is based on finding a congruence of squares modulo the integer N which we intend to factor. Fermat's factorization algorithm finds such a congruence by selecting random or pseudo-random  x values and hoping that the integer x 2 mod N is a perfect square (in the integers):         x  2   ≡    y  2    (   mod  N   )     ,   x  ≢    ±  y    (   mod  N   )      .     formulae-sequence     superscript  x  2     superscript  y  2     mod  N      not-equivalent-to  x    plus-or-minus  y     mod  N       x^{2}\equiv y^{2}\quad(\hbox{mod }N),\qquad x\not\equiv\pm y\quad(\hbox{mod }N).     For example, if , we notice (by starting at 292, the first number greater than    N      N    \sqrt{N}   and counting up) that is 256, the square of 16. So . Computing the greatest common divisor of  and N using Euclid's algorithm gives us 163, which is a factor of N .  In practice, selecting random x values will take an impractically long time to find a congruence of squares, since there are only    N      N    \sqrt{N}   squares less than N .  Dixon's method replaces the condition "is the square of an integer" with the much weaker one "has only small prime factors"; for example, there are 292 squares smaller than 84923; 662 numbers smaller than 84923 whose prime factors are only 2,3,5 or 7; and 4767 whose prime factors are all less than 30. (Such numbers are called B-smooth with respect to some bound B .)  If we have lots of numbers     a  1   …   a  n        subscript  a  1   normal-…   subscript  a  n     a_{1}\ldots a_{n}   whose squares can be factorized as      a  i  2   mod  N   =    ∏   j  =  1   m    b  j   e   i  j           modulo   superscript   subscript  a  i   2   N     superscript   subscript  product    j  1    m    superscript   subscript  b  j    subscript  e    i  j        a_{i}^{2}\mod N=\prod_{j=1}^{m}b_{j}^{e_{ij}}   for a fixed set     b  1   …   b  m        subscript  b  1   normal-…   subscript  b  m     b_{1}\ldots b_{m}   of small primes, linear algebra modulo 2 on the matrix    e   i  j      subscript  e    i  j     e_{ij}   will give us a subset of the    a  i     subscript  a  i    a_{i}   whose squares combine to a product of small primes to an even power — that is, a subset of the    a  i     subscript  a  i    a_{i}   whose squares multiply to the square of a (hopefully different) number mod N.  Method  Suppose we are trying to factor the composite number N . We choose a bound B , and identify the factor base (which we will call P ), the set of all primes less than or equal to B . Next, we search for positive integers z such that z 2 mod N is B -smooth. We can therefore write, for suitable exponents a k ,       z  2   ≡     ∏    p  i   ∈  P     p  i   a  i        (   mod  N   )         superscript  z  2    annotated    subscript  product     subscript  p  i   P     superscript   subscript  p  i    subscript  a  i      pmod  N      z^{2}\equiv\prod_{p_{i}\in P}p_{i}^{a_{i}}\;\;(\mathop{{\rm mod}}N)     When we have generated enough of these relations (it's generally sufficient that the number of relations be a few more than the size of P ), we can use the methods of linear algebra (for example, Gaussian elimination ) to multiply together these various relations in such a way that the exponents of the primes on the right-hand side are all even:       z  1  2    z  2  2   ⋯   z  k  2   ≡   ∏    p  i   ∈  P      p  i    a   i  ,  1    +   a   i  ,  2    +  ⋯  +   a   i  ,  k        (   mod  N   )    (  where   a   i  ,  1    +   a   i  ,  2    +  ⋯  +   a   i  ,  k    ≡  0   (   mod  2   )   )      fragments   superscript   subscript  z  1   2    superscript   subscript  z  2   2   normal-⋯   superscript   subscript  z  k   2     subscript  product     subscript  p  i   P     superscript   subscript  p  i      subscript  a   i  1     subscript  a   i  2    normal-⋯   subscript  a   i  k       pmod  N     fragments  normal-(  where   subscript  a   i  1      subscript  a   i  2     normal-⋯    subscript  a   i  k     0   pmod  2   normal-)     {z_{1}^{2}z_{2}^{2}\cdots z_{k}^{2}\equiv\prod_{p_{i}\in P}p_{i}^{a_{i,1}+a_{i%
 ,2}+\cdots+a_{i,k}}\ \;\;(\mathop{{\rm mod}}N)\quad(\text{where }a_{i,1}+a_{i,%
 2}+\cdots+a_{i,k}\equiv 0\;\;(\mathop{{\rm mod}}2))}     This gives us a congruence of squares of the form which can be turned into a factorization of N ,  This factorization might turn out to be trivial (i.e. ), which can only happen if  in which case we have to try again with a different combination of relations; but with luck we will get a nontrivial pair of factors of N , and the algorithm will terminate.  Example  We will try to factor N = 84923 using bound B = 7. Our factor base is then P = {2, 3, 5, 7}. We then search randomly for integers between     ⌈   84923   ⌉   =  292          84923    292    \left\lceil\sqrt{84923}\right\rceil=292   and N whose squares are B -smooth . Suppose that two of the numbers we find are 513 and 537:        513  2   mod  84923   =  8400  =    2  4   ⋅  3  ⋅   5  2   ⋅  7          modulo   superscript  513  2   84923   8400        normal-⋅   superscript  2  4   3   superscript  5  2   7      513^{2}\mod 84923=8400=2^{4}\cdot 3\cdot 5^{2}\cdot 7           537  2   mod  84923   =  33600  =    2  6   ⋅  3  ⋅   5  2   ⋅  7          modulo   superscript  537  2   84923   33600        normal-⋅   superscript  2  6   3   superscript  5  2   7      537^{2}\mod 84923=33600=2^{6}\cdot 3\cdot 5^{2}\cdot 7     So         (   513  ⋅  537   )   2   mod  84923   =    2  10   ⋅   3  2   ⋅   5  4   ⋅   7  2         modulo   superscript   normal-⋅  513  537   2   84923    normal-⋅   superscript  2  10    superscript  3  2    superscript  5  4    superscript  7  2      (513\cdot 537)^{2}\mod 84923=2^{10}\cdot 3^{2}\cdot 5^{4}\cdot 7^{2}     Then         (   513  ⋅  537   )   2   mod  84923   =     (  275481  )   2   mod  84923        modulo   superscript   normal-⋅  513  537   2   84923    modulo   superscript  275481  2   84923     \displaystyle{}\qquad(513\cdot 537)^{2}\mod 84923=(275481)^{2}\mod 84923     That is,      20712  2   mod  84923   =     (    2  5   ⋅  3  ⋅   5  2   ⋅  7   )   2   mod  84923   =    16800  2   mod  84923.          modulo   superscript  20712  2   84923    modulo   superscript   normal-⋅   superscript  2  5   3   superscript  5  2   7   2   84923         modulo   superscript  16800  2   84923.      20712^{2}\mod 84923=(2^{5}\cdot 3\cdot 5^{2}\cdot 7)^{2}\mod 84923=16800^{2}%
 \mod 84923.     The resulting factorization is 84923 = gcd(20712 − 16800, 84923) × gcd(20712 + 16800, 84923) = 163 × 521.  Optimizations  The quadratic sieve is an optimization of Dixon's method. It selects values of x close to the square root of N such that x 2 modulo N is small, thereby largely increasing the chance of obtaining a smooth number.  Other ways to optimize Dixon's method include using a better algorithm to solve the matrix equation, taking advantage of the sparsity of the matrix: a number z cannot have more than     log  2   z      subscript   2   z    \log_{2}z   factors, so each row of the matrix is almost all zeros. In practice, the block Lanczos algorithm is often used. Also, the size of the factor base must be chosen carefully: if it is too small, it will be difficult to find numbers that factorize completely over it, and if it is too large, more relations will have to be collected.  A more sophisticated analysis, using the approximation that a number has all its prime factors less than    N   1  /  a      superscript  N    1  a     N^{1/a}   with probability about    a   -  a      superscript  a    a     a^{-a}   (an approximation to the Dickman–de Bruijn function ), indicates that choosing too small a factor base is much worse than too large, and that the ideal factor base size is some power of    exp   (    log   N   log   log  N       )             N      N         \exp\left(\sqrt{\log N\log\log N}\right)   .  The optimal complexity of Dixon's method is      O   (   exp   (   2   2     log   n   log   log  n        )    )       O      2    2         n      n           O\left(\exp\left(2\sqrt{2}\sqrt{\log n\log\log n}\right)\right)   in big-O notation , or       L  n    [   1  /  2   ,   2   2    ]        subscript  L  n      1  2     2    2       L_{n}[1/2,2\sqrt{2}]   in L-notation .  References    "  Category:Integer factorization algorithms     ↩  ↩     