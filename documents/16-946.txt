   Shadow heap      Shadow heap   In computer science , a shadow heap is a mergeable heap  data structure which supports efficient heap merging in the amortized sense. More specifically, shadow heaps make use of the shadow merge algorithm to achieve insertion in O (f( n )) amortized time and deletion in O ((log n log log n )/f( n )) amortized time, for any choice of 1 ≤ f( n ) ≤ log log n . 1  Throughout this article, it is assumed that A and B are binary heaps with | A | ≤ | B |.  Shadow merge  Shadow merge is an algorithm for merging two binary heaps efficiently if these heaps are implemented as arrays . Specifically, the running time of shadow merge on two heaps   A   A   A   and   B   B   B   is    O   (    |  A  |   +   min   {   log    |  B  |    log   log   |  B  |       ,   log    |  A  |    log   |  B  |      }     )       O      A           B         B             A       B          O(|A|+\min\{\log|B|\log\log|B|,\log|A|\log|B|\})   .  Algorithm  We wish to merge the two binary min-heaps   A   A   A   and   B   B   B   . The algorithm is as follows:   Concatenate the array   A   A   A   at the end of the array   B   B   B   to obtain an array   C   C   C   .  Identify the shadow of   A   A   A   in   C   C   C   ; that is, the ancestors of the last    |  A  |      A    |A|   nodes in   C   C   C   which destroy the heap property.  Identify the following two parts of the shadow from   C   C   C   :  The path    P   P   P   : the set of nodes in the shadow for which there are at most 2 at any depth of   C   C   C   ;  The subtree    T   T   T   : the remainder of the shadow.   Extract and sort the smallest    |  P  |      P    |P|   nodes from the shadow into an array   S   S   S   .  Transform   S   S   S   as follows:  If     |  S  |   >   |  C  |         S     C     |S|>|C|   , then starting from the smallest element in the sorted array, sequentially insert each element of   S   S   S   into   C   C   C   , replacing them with   C   C   C   's smallest elements.  If     |  S  |   ≤   |  C  |         S     C     |S|\leq|C|   , then extract and sort the    |  P  |      P    |P|   smallest elements from   C   C   C   , and merge this sorted list with   S   S   S   .   Replace the elements of   S   S   S   into their original positions in   C   C   C   .  Make a heap out of   T   T   T   .   Running time  Again, let   P   P   P   denote the path, and   T   T   T   denote the subtree of the concatenated heap   C   C   C   . The number of nodes in   P   P   P   is at most twice the depth of   C   C   C   , which is    O   (   log   |  B  |    )       O      B      O(\log|B|)   . Moreover, the number of nodes in   T   T   T   at depth   d   d   d   is at most 3/4 the number of nodes at depth    d  +  1      d  1    d+1   , so the subtree has size    O   (   |  A  |   )       O    A     O(|A|)   . Since there are at most 2 nodes at each level on   P   P   P   , then reading the smallest    |  P  |      P    |P|   elements of the shadow into the sorted array   S   S   S   takes    O   (   log   |  B  |    )       O      B      O(\log|B|)   time.  If     |  S  |   >   |  C  |         S     C     |S|>|C|   , then combining   P   P   P   and   C   C   C   as in step 5 above takes time    O   (   log    |  A  |    log   |  B  |      )       O        A       B        O(\log|A|\log|B|)   . Otherwise, the time taken in this step is    O   (    |  A  |   +   log    |  B  |    log   log   |  B  |        )       O      A         B         B          O(|A|+\log|B|\log\log|B|)   . Finally, making a heap of the subtree   T   T   T   takes    O   (   |  A  |   )       O    A     O(|A|)   time. This amounts to a total running time for shadow merging of    O   (    |  A  |   +   min   {   log    |  A  |    log   |  B  |      ,   log    |  B  |    log   log   |  B  |       }     )       O      A           A       B            B         B           O(|A|+\min\{\log|A|\log|B|,\log|B|\log\log|B|\})   .  Structure  A shadow heap   H   H   H   consists of threshold function    f   (  H  )       f  H    f(H)   , and an array for which the usual array-implemented binary heap property is upheld in its first entries, and for which the heap property is not necessarily upheld in the other entries. Thus, the shadow heap is essentially a binary heap   B   B   B   adjacent to an array   A   A   A   . To add an element to the shadow heap, place it in the array   A   A   A   . If the array becomes too large according to the specified threshold, we first build a heap out of   A   A   A   using Floyd's algorithm for heap construction, 2 and then merge this heap with   B   B   B   using shadow merge. Finally, the merging of shadow heaps is simply done through sequential insertion of one heap into the other using the above insertion procedure.  Analysis  We are given a shadow heap    H  =   (  B  ,  A  )       H   B  A     H=(B,A)   , with threshold function     log   |  H  |    ≤   f   (  H  )    ≤   log    |  H  |    log   log   |  H  |                 H      f  H              H         H          \log|H|\leq f(H)\leq\log|H|\log\log|H|   as above. Suppose that the threshold function is such that any change in    |  B  |      B    |B|   induces no larger a change than in    f   (  H  )       f  H    f(H)   . We derive the desired running time bounds for the mergeable heap operations using the potential method for amortized analysis . The potential    Ψ   (  H  )       normal-Ψ  H    \Psi(H)   of the heap is chosen to be:       Ψ   (  H  )    =    |  A  |    (   1  +     min   {   log    |  B  |    log   log   |  B  |       ,   log    |  B  |    log   |  A  |      }    /  f    (  H  )     )          normal-Ψ  H       A     1              B         B             B       A       f   H       \Psi(H)=|A|(1+\min\{\log|B|\log\log|B|,\log|B|\log|A|\}/f(H))     Using this potential, we can obtain the desired amortized running times:  create( H ) : initializes a new empty shadow heap   H   H   H      Here, the potential   Ψ   normal-Ψ   \Psi   is unchanged, so the amortized cost of creation is    O   (  1  )       O  1    O(1)   , the actual cost.   insert( x , H ) : inserts   x   x   x   into the shadow heap   H   H   H      There are two cases:  If the merge is employed, then the drop in the potential function is exactly the actual cost of merging   B   B   B   and   A   A   A   , so the amortized cost is    O   (  1  )       O  1    O(1)   .  If the merge is not done, then the amortized cost is    O   (   1  +     min   {   log    |  B  |    log   log   |  B  |       ,   log    |  B  |    log   |  A  |      }    /  f    (  H  )     )       O    1              B         B             B       A       f   H      O(1+\min\{\log|B|\log\log|B|,\log|B|\log|A|\}/f(H))       By choice of the threshold function, we thus obtain that the amortized cost of insertion is:      O   (    log    |  H  |    log   log    |  H  |   /  f        (  H  )    )       O          H           H   f       H     O(\log|H|\log\log|H|/f(H))      delete_min( H ) : deletes the minimum priority element from   H   H   H      Finding and deleting the minimum takes actual time    O   (    |  A  |   +   log   |  B  |     )       O      A       B       O(|A|+\log|B|)   . Moreover, the potential function can only increase after this deletion if the value of    f   (  H  )       f  H    f(H)   decreases. By choice of   f   f   f   , we have that the amortized cost of this operation is the same as the actual cost.   Related algorithms & data structures  A naive binary heap merging algorithm will merge the two heaps   A   A   A   and   B   B   B   in in time    O   (   |  B  |   )       O    B     O(|B|)   by simply concatenating both heaps and making a heap out of the resulting array using Floyd's algorithm for heap construction. Alternatively, the heaps can simply be merged by sequentially inserting each element of   A   A   A   into   B   B   B   , taking time    O   (    |  A  |    log   |  B  |     )       O      A       B       O(|A|\log|B|)   .  Sack and Strothotte proposed an algorithm for merging the binary heaps in    O   (    |  A  |   +   log    |  A  |    log   |  B  |       )       O      A         A       B         O(|A|+\log|A|\log|B|)   time. 3 Their algorithm is known to be more efficient than the second naive solution described above roughly when     |  A  |   >   log   |  B  |          A       B      |A|>\log|B|   . Shadow merge performs asymptotically better than their algorithm, even in the worst case.  There are several other heaps which support faster merge times. For instance, Fibonacci heaps can be merged in    O   (  1  )       O  1    O(1)   time. Since binary heaps require    Ω   (   |  A  |   )       normal-Ω    A     \Omega(|A|)   time to merge, 4 shadow merge remains efficient.  References        "  Category:Heaps (data structures)     ↩  ↩  . ↩  ↩     