<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="213">Zero Forcing Equalizer</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Zero Forcing Equalizer</h1>
<hr/>

<p><strong>Zero Forcing Equalizer</strong> refers to a form of linear <a href="Equalization_(communications)" title="wikilink">equalization</a> <a class="uri" href="algorithm" title="wikilink">algorithm</a> used in <a href="telecommunications" title="wikilink">communication systems</a> which applies the inverse of the <a href="frequency_response" title="wikilink">frequency response</a> of the channel. This form of equalizer was first proposed by <a href="Robert_Lucky" title="wikilink">Robert Lucky</a>.</p>

<p>The Zero-Forcing Equalizer applies the inverse of the channel frequency response to the received signal, to restore the signal after the channel.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It has many useful applications. For example, it is studied heavily for <a href="IEEE_802.11n" title="wikilink">IEEE 802.11n</a> (MIMO) where knowing the channel allows recovery of the two or more streams which will be received on top of each other on each antenna. The name Zero Forcing corresponds to bringing down the <a href="intersymbol_interference" title="wikilink">intersymbol interference</a> (ISI) to zero in a noise free case. This will be useful when ISI is significant compared to noise.</p>

<p>For a channel with <a href="frequency_response" title="wikilink">frequency response</a> 

<math display="inline" id="Zero_Forcing_Equalizer:0">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(f)
  </annotation>
 </semantics>
</math>

 the zero forcing equalizer 

<math display="inline" id="Zero_Forcing_Equalizer:1">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(f)
  </annotation>
 </semantics>
</math>

 is constructed by 

<math display="inline" id="Zero_Forcing_Equalizer:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>F</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>F</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(f)=1/F(f)
  </annotation>
 </semantics>
</math>

. Thus the combination of channel and equalizer gives a flat frequency response and linear phase 

<math display="inline" id="Zero_Forcing_Equalizer:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>f</ci>
     <ci>C</ci>
     <ci>f</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(f)C(f)=1
  </annotation>
 </semantics>
</math>

.</p>

<p>In reality, zero-forcing equalization does not work in most applications, for the following reasons:</p>
<ol>
<li>Even though the channel impulse response has finite length, the impulse response of the equalizer needs to be infinitely long</li>
<li>At some frequencies the received signal may be weak. To compensate, the magnitude of the zero-forcing filter ("gain") grows very large. As a consequence, any noise added after the channel gets boosted by a large factor and destroys the overall signal-to-noise ratio. Furthermore, the channel may have zeroes in its frequency response that cannot be inverted at all. (Gain * 0 still equals 0).</li>
</ol>

<p>This second item is often the more limiting condition. These problems are addressed in the linear <a href="Minimum_mean-square_error" title="wikilink">MMSE</a> equalizer<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> by making a small modification to the denominator of 

<math display="inline" id="Zero_Forcing_Equalizer:4">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(f)
  </annotation>
 </semantics>
</math>



<math display="block" id="Zero_Forcing_Equalizer:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mi>k</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>f</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(f)=1/(F(f)+k)
  </annotation>
 </semantics>
</math>

, where k is related to the channel response and the signal <a href="Signal-to-noise_ratio" title="wikilink">SNR</a>.</p>
<h2 id="algorithm">Algorithm</h2>

<p>If the channel response (or <a href="transfer_function" title="wikilink">channel transfer function</a>) for a particular channel is H(s) then the input signal is multiplied by the <a href="Multiplicative_inverse" title="wikilink">reciprocal</a> of it. This is intended to remove the effect of channel from the received signal, in particular the <a href="intersymbol_interference" title="wikilink">intersymbol interference</a> (ISI).</p>

<p>The zero-forcing equalizer removes all ISI, and is ideal when the channel is noiseless. However, when the channel is noisy, the zero-forcing equalizer will amplify the noise greatly at frequencies <em>f</em> where the channel response H(j2π<em>f</em>) has a small magnitude (i.e. near zeroes of the channel) in the attempt to invert the channel completely. A more balanced linear equalizer in this case is the <strong><a href="minimum_mean-square_error" title="wikilink">minimum mean-square error</a> equalizer</strong>, which does not usually eliminate ISI completely but instead minimizes the total power of the noise and ISI components in the output.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Filter_theory" title="wikilink">Category:Filter theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
