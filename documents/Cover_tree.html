<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1219">Cover tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cover tree</h1>
<hr/>

<p>The <strong>cover tree</strong> is a type of <a href="data_structure" title="wikilink">data structure</a> in <a href="computer_science" title="wikilink">computer science</a> that is specifically designed to facilitate the speed-up of a <a href="nearest_neighbor_search" title="wikilink">nearest neighbor search</a>. It is a refinement of the Navigating Net data structure, and related to a variety of other data structures developed for indexing intrinsically low-dimensional data.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The tree can be thought of as a hierarchy of levels with the top level containing the root <a href="point_(geometry)" title="wikilink">point</a> and the bottom level containing every point in the metric space. Each level <em>C</em> is associated with an integer value <em>i</em> that decrements by one as the tree is descended. Each level <em>C</em> in the cover tree has three important properties:</p>
<ul>
<li><strong>Nesting:</strong> 

<math display="inline" id="Cover_tree:0">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>i</mi>
   </msub>
   <mo>⊆</mo>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}\subseteq C_{i-1}
  </annotation>
 </semantics>
</math>

</li>
<li><strong>Covering:</strong> For every point 

<math display="inline" id="Cover_tree:1">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∈</mo>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\in C_{i-1}
  </annotation>
 </semantics>
</math>

, there exists a point 

<math display="inline" id="Cover_tree:2">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>∈</mo>
   <msub>
    <mi>C</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>q</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\in C_{i}
  </annotation>
 </semantics>
</math>

 such that the distance from 

<math display="inline" id="Cover_tree:3">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


 to 

<math display="inline" id="Cover_tree:4">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is less than or equal to 

<math display="inline" id="Cover_tree:5">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{i}
  </annotation>
 </semantics>
</math>

 and exactly one such 

<math display="inline" id="Cover_tree:6">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is a parent of 

<math display="inline" id="Cover_tree:7">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

.</li>
<li><strong>Separation:</strong> For all points 

<math display="inline" id="Cover_tree:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>C</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>p</ci>
     <ci>q</ci>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p,q\in C_{i}
  </annotation>
 </semantics>
</math>


, the distance from 

<math display="inline" id="Cover_tree:9">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Cover_tree:10">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is greater than 

<math display="inline" id="Cover_tree:11">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{i}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="complexity">Complexity</h2>
<h3 id="find">Find</h3>

<p>Like other <a href="metric_tree" title="wikilink">metric trees</a> the cover tree allows for nearest neighbor searches in 

<math display="inline" id="Cover_tree:12">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>η</mi>
     <mo>*</mo>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>η</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\eta*\log{n})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Cover_tree:13">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>


 is a constant associated with the dimensionality of the dataset and n is the cardinality. To compare, a basic linear search requires 

<math display="inline" id="Cover_tree:14">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

, which is a much worse dependence on 

<math display="inline" id="Cover_tree:15">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. However, in high-dimensional <a href="metric_space" title="wikilink">metric spaces</a> the 

<math display="inline" id="Cover_tree:16">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>

 constant is non-trivial, which means it cannot be ignored in complexity analysis. Unlike other metric trees, the cover tree has a theoretical bound on its constant that is based on the dataset's <a href="expansivity_constant" title="wikilink">expansion constant</a> or doubling constant (in the case of approximate NN retrieval). The bound on search time is 

<math display="inline" id="Cover_tree:17">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>c</mi>
      <mn>12</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <cn type="integer">12</cn>
     </apply>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(c^{12}\log{n})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Cover_tree:18">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>


 is the expansion constant of the dataset.</p>
<h3 id="insert">Insert</h3>

<p>Although cover trees provide faster searches than the naive approach, this advantage must be weighed with the additional cost of maintaining the data structure. In a naive approach adding a new point to the dataset is trivial because order does not need to be preserved, but in a cover tree it can take 

<math display="inline" id="Cover_tree:19">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>c</mi>
      <mn>6</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <cn type="integer">6</cn>
     </apply>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(c^{6}\log{n})
  </annotation>
 </semantics>
</math>

 time. However, this is an upper-bound, and some techniques have been implemented that seem to improve the performance in practice.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="space">Space</h3>

<p>The cover tree uses implicit representation to keep track of repeated points. Thus, it only requires O(n) space.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Nearest_neighbor_search" title="wikilink">Nearest neighbor search</a></li>
<li><a class="uri" href="kd-tree" title="wikilink">kd-tree</a></li>
</ul>
<h2 id="references">References</h2>
<dl>
<dt>Notes</dt>
</dl>
<dl>
<dt>Bibliography</dt>
</dl>
<ul>
<li>Alina Beygelzimer, Sham Kakade, and John Langford. Cover Trees for Nearest Neighbor. In Proc. International Conference on Machine Learning (ICML), 2006.</li>
<li><a href="http://hunch.net/~jl/projects/cover_tree/cover_tree.html">JL's Cover Tree page</a>. John Langford's page links to papers and code.</li>
<li><a href="https://github.com/DNCrane/Cover-Tree">A C++ Cover Tree implementation on GitHub</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Trees_(data_structures)" title="wikilink">Category:Trees (data structures)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Kenneth Clarkson. Nearest-neighbor searching and metric space dimensions. In G. Shakhnarovich, T. Darrell, and <a href="Piotr_Indyk" title="wikilink">P. Indyk</a>, editors, Nearest-Neighbor Methods for Learning and Vision: Theory and Practice, pages 15--59. MIT Press, 2006.<a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://hunch.net/~jl/projects/cover_tree/cover_tree.html">http://hunch.net/~jl/projects/cover_tree/cover_tree.html</a><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
