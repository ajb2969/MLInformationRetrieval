


Pollard's rho algorithm for logarithms




Pollard's rho algorithm for logarithms

 table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
   



Pollard's rho algorithm for logarithms is an algorithm introduced by John Pollard in 1978 for solving the discrete logarithm problem analogous to Pollard's rho algorithm for solving the Integer factorization problem.
The goal is to compute 
 
 
 
  such that 
 
 
 
 , where 
 
 
 
  belongs to a cyclic group

 
  generated by 
 
 
 
 . The algorithm computes integers 
 
 
 
 , 
 
 
 
 , 
 
 
 
 , and 
 
 
 
  such that 
 
 
 
 . Assuming, for simplicity, that the underlying group is cyclic of order 
 
 
 
 , we can calculate 
 
 
 
  as a solution of the equation 
 
 
 
 .
To find the needed 
 
 
 
 , 
 
 
 
 , 
 
 
 
 , and 
 
 
 
  the algorithm uses Floyd's cycle-finding algorithm to find a cycle in the sequence 
 
 
 
 , where the function 
 
 
 
  is assumed to be random-looking and thus is likely to enter into a loop after approximately 
 
 
 
  steps. One way to define such a function is to use the following rules: Divide 
 
 
 
  into three disjoint subsets of approximately equal size
 
 
 
 , 
 
 
 
 , and 
 
 
 
 . If 
 
 
 
  is in 
 
 
 
  then double both 
 
 
 
  and 
 
 
 
 ; if 
 
 
 
  then increment 
 
 
 
 , if 
 
 
 
  then increment 
 
 
 
 .
Algorithm
Let 
 
 
 
  be a cyclic group of order 
 
 
 
 , and given 
 
 
 
 , and a partition 
 
 
 
 , let 
 
 
 
  be a map



and define maps 
 
 
 
 
  and 
 
 
 
  by





Inputs a a generator of G, b an element of G

Output An integer x such that ax = b, or failure
 
Initialise a0 ← 0
 

b0 ← 0
 
x0 ← 1 ∈ G

i ← 1
 



xi ← f(xi-1), ai ← g(xi-1,ai-1), bi ← h(xi-1,bi-1)
x2i ← f(f(x2i-2)), a2i ← g(f(x2i-2),g(x2i-2,a2i-2)), b2i ← h(f(x2i-2),h(x2i-2,b2i-2))
If xi = x2i then
 
r ← bi - b2i
If r = 0 return failure
x ← r-1(a2i - ai) mod p
return x

If xi ≠ x2i then i ← i+1, and go to step 2.



Example
Consider, for example, the group generated by 2 modulo 
 
 
 
  (the order of the group is 
 
 
 
 , 2 generates the group of units modulo 1019). The algorithm is implemented by the following C++ program:
 #include 
  
  const int n = 1018, N = n + 1;  /* N = 1019 -- prime     */
  const int alpha = 2;            /* generator             */
  const int beta = 5;             /* 2^{10} = 1024 = 5 (N) */
  
  void new_xab( int& x, int& a, int& b ) {
    switch( x%3 ) {
    case 0: x = x*x     % N;  a =  a*2  % n;  b =  b*2  % n;  break;
    case 1: x = x*alpha % N;  a = (a+1) % n;                  break;
    case 2: x = x*beta  % N;                  b = (b+1) % n;  break;
    }
  }
  
  int main(void) {
    int x=1, a=0, b=0;
    int X=x, A=a, B=b;
    for(int i = 1; i < n; ++i ) {
      new_xab( x, a, b );
      new_xab( X, A, B ); new_xab( X, A, B );
      printf( "%3d  %4d %3d %3d  %4d %3d %3d\n", i, x, a, b, X, A, B );
      if( x == X ) break;
    }
    return 0;
  }
 
The results are as follows (edited):
 i     x   a   b     X   A   B
------------------------------
 1     2   1   0    10   1   1
 2    10   1   1   100   2   2
 3    20   2   1  1000   3   3
 4   100   2   2   425   8   6
 5   200   3   2   436  16  14
 6  1000   3   3   284  17  15
 7   981   4   3   986  17  17
 8   425   8   6   194  17  19
..............................
48   224 680 376    86 299 412
49   101 680 377   860 300 413
50   505 680 378   101 300 415
51  1010 681 378  1010 301 416
That is 
 
 
 
  and so 
 
 
 
 , for which 
 
 
 
  is a solution as expected. As 
 
 
 
  is not prime, there is another solution 
 
 
 
 , for which 
 
 
 
  holds.
Complexity
The running time is approximately 
 
 
 
 . If used together with the Pohlig-Hellman algorithm, the running time of the combined algorithm is 
 
 
 
 , where 
 
 
 
  is the largest prime factor of 
 
 
 
 .
References




"
Category:Logarithms Category:Number theoretic algorithms
