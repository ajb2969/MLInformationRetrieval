   Pollard's rho algorithm for logarithms      Pollard's rho algorithm for logarithms  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     Pollard's rho algorithm for logarithms is an algorithm introduced by John Pollard in 1978 for solving the discrete logarithm problem analogous to Pollard's rho algorithm for solving the Integer factorization problem.  The goal is to compute   Œ≥   Œ≥   \gamma   such that     Œ±  Œ≥   =  Œ≤       superscript  Œ±  Œ≥   Œ≤    \alpha^{\gamma}=\beta   , where   Œ≤   Œ≤   \beta   belongs to a cyclic group    G   G   G   generated by   Œ±   Œ±   \alpha   . The algorithm computes integers   a   a   a   ,   b   b   b   ,   A   A   A   , and   B   B   B   such that      Œ±  a    Œ≤  b    =    Œ±  A    Œ≤  B           superscript  Œ±  a    superscript  Œ≤  b       superscript  Œ±  A    superscript  Œ≤  B      \alpha^{a}\beta^{b}=\alpha^{A}\beta^{B}   . Assuming, for simplicity, that the underlying group is cyclic of order   n   n   n   , we can calculate   Œ≥   Œ≥   \gamma   as a solution of the equation      (   B  -  b   )   Œ≥   =    (   a  -  A   )      (   mod  n   )            B  b   Œ≥    annotated    a  A    pmod  n      (B-b)\gamma=(a-A)\;\;(\mathop{{\rm mod}}n)   .  To find the needed   a   a   a   ,   b   b   b   ,   A   A   A   , and   B   B   B   the algorithm uses Floyd's cycle-finding algorithm to find a cycle in the sequence     x  i   =    Œ±   a  i     Œ≤   b  i          subscript  x  i      superscript  Œ±   subscript  a  i     superscript  Œ≤   subscript  b  i       x_{i}=\alpha^{a_{i}}\beta^{b_{i}}   , where the function    f  :    x  i   ‚Ü¶   x   i  +  1        normal-:  f   maps-to   subscript  x  i    subscript  x    i  1       f:x_{i}\mapsto x_{i+1}   is assumed to be random-looking and thus is likely to enter into a loop after approximately      œÄ  n   2           œÄ  n   2     \sqrt{\frac{\pi n}{2}}   steps. One way to define such a function is to use the following rules: Divide   G   G   G   into three disjoint subsets of approximately equal size    S  0     subscript  S  0    S_{0}   ,    S  1     subscript  S  1    S_{1}   , and    S  2     subscript  S  2    S_{2}   . If    x  i     subscript  x  i    x_{i}   is in    S  0     subscript  S  0    S_{0}   then double both   a   a   a   and   b   b   b   ; if     x  i   ‚àà   S  1        subscript  x  i    subscript  S  1     x_{i}\in S_{1}   then increment   a   a   a   , if     x  i   ‚àà   S  2        subscript  x  i    subscript  S  2     x_{i}\in S_{2}   then increment   b   b   b   .  Algorithm  Let   G   G   G   be a cyclic group of order   p   p   p   , and given     Œ±  ,  Œ≤   ‚àà  G       Œ±  Œ≤   G    \alpha,\beta\in G   , and a partition    G  =    S  0   ‚à™   S  1   ‚à™   S  2        G     subscript  S  0    subscript  S  1    subscript  S  2      G=S_{0}\cup S_{1}\cup S_{2}   , let    f  :   G  ‚Üí  G      normal-:  f   normal-‚Üí  G  G     f:G\to G   be a map      f   (  x  )   =   {      Œ≤  x      x  ‚àà   S  0         x  2      x  ‚àà   S  1         Œ±  x      x  ‚àà   S  2           fragments  f   fragments  normal-(  x  normal-)     fragments  normal-{      Œ≤  x     x   subscript  S  0       superscript  x  2     x   subscript  S  1        Œ±  x     x   subscript  S  2         f(x)=\left\{\begin{matrix}\beta x&x\in S_{0}\\
 x^{2}&x\in S_{1}\\
 \alpha x&x\in S_{2}\end{matrix}\right.     and define maps    g  :    G  √ó  ‚Ñ§   ‚Üí  ‚Ñ§      normal-:  g   normal-‚Üí    G  ‚Ñ§   ‚Ñ§     g:G\times\mathbb{Z}\to\mathbb{Z}   and    h  :    G  √ó  ‚Ñ§   ‚Üí  ‚Ñ§      normal-:  h   normal-‚Üí    G  ‚Ñ§   ‚Ñ§     h:G\times\mathbb{Z}\to\mathbb{Z}   by      g   (  x  ,  n  )   =   {     n     x  ‚àà   S  0          2   n    mod  p      x  ‚àà   S  1          n  +   1    mod  p      x  ‚àà   S  2           fragments  g   fragments  normal-(  x  normal-,  n  normal-)     fragments  normal-{    n    x   subscript  S  0       modulo    2  n   p     x   subscript  S  1       modulo    n  1   p     x   subscript  S  2         g(x,n)=\left\{\begin{matrix}n&x\in S_{0}\\
 2n\ (\bmod\ p)&x\in S_{1}\\
 n+1\ (\bmod\ p)&x\in S_{2}\end{matrix}\right.       h   (  x  ,  n  )   =   {       n  +   1    mod  p      x  ‚àà   S  0          2   n    mod  p      x  ‚àà   S  1        n     x  ‚àà   S  2           fragments  h   fragments  normal-(  x  normal-,  n  normal-)     fragments  normal-{     modulo    n  1   p     x   subscript  S  0       modulo    2  n   p     x   subscript  S  1      n    x   subscript  S  2         h(x,n)=\left\{\begin{matrix}n+1\ (\bmod\ p)&x\in S_{0}\\
 2n\ (\bmod\ p)&x\in S_{1}\\
 n&x\in S_{2}\end{matrix}\right.      Inputs  a a generator of G , b an element of G   Output An integer x such that a x = b , or failure  Initialise a 0 ‚Üê 0   b 0 ‚Üê 0  x 0 ‚Üê 1 ‚àà G   i ‚Üê 1     x i ‚Üê f(x i-1 ) , a i ‚Üê g(x i-1 ,a i-1 ) , b i ‚Üê h(x i-1 ,b i-1 )  x 2i ‚Üê f(f(x 2i-2 )) , a 2i ‚Üê g(f(x 2i-2 ),g(x 2i-2 ,a 2i-2 )) , b 2i ‚Üê h(f(x 2i-2 ),h(x 2i-2 ,b 2i-2 ))  If x i = x 2i then  r ‚Üê b i - b 2i  If r = 0 return failure  x ‚Üê r -1 ( a 2i - a i ) mod p  return x   If x i ‚â† x 2i then i ‚Üê i+1 , and go to step 2.     Example  Consider, for example, the group generated by 2 modulo    N  =  1019      N  1019    N=1019   (the order of the group is    n  =  1018      n  1018    n=1018   , 2 generates the group of units modulo 1019). The algorithm is implemented by the following C++ program:   #include  const  int n = 1018 , N = n + 1 ; /* N = 1019 -- prime     */  const  int alpha = 2 ; /* generator             */  const  int beta = 5 ; /* 2^{10} = 1024 = 5 (N) */  void new_xab( int & x, int & a, int & b ) { switch ( x% 3 ) { case  0 : x = x*x     % N;  a =  a* 2 % n;  b =  b* 2 % n; break ; case  1 : x = x*alpha % N;  a = (a +1 ) % n; break ; case  2 : x = x*beta  % N;                  b = (b +1 ) % n; break ;
    }
  } int main( void ) { int x= 1 , a= 0 , b= 0 ; int X=x, A=a, B=b; for ( int i = 1 ; i < n; ++i ) {
      new_xab( x, a, b );
      new_xab( X, A, B ); new_xab( X, A, B );
      printf( " %3d  %4d  %3d  %3d  %4d  %3d  %3d\n " , i, x, a, b, X, A, B ); if ( x == X ) break ;
    } return  0 ;
  }  The results are as follows (edited):  i¬†¬†¬†¬†¬†x¬†¬†¬†a¬†¬†¬†b¬†¬†¬†¬†¬†X¬†¬†¬†A¬†¬†¬†B  ------------------------------  1¬†¬†¬†¬†¬†2¬†¬†¬†1¬†¬†¬†0¬†¬†¬†¬†10¬†¬†¬†1¬†¬†¬†1  2¬†¬†¬†¬†10¬†¬†¬†1¬†¬†¬†1¬†¬†¬†100¬†¬†¬†2¬†¬†¬†2  3¬†¬†¬†¬†20¬†¬†¬†2¬†¬†¬†1¬†¬†1000¬†¬†¬†3¬†¬†¬†3  4¬†¬†¬†100¬†¬†¬†2¬†¬†¬†2¬†¬†¬†425¬†¬†¬†8¬†¬†¬†6  5¬†¬†¬†200¬†¬†¬†3¬†¬†¬†2¬†¬†¬†436¬†¬†16¬†¬†14  6¬†¬†1000¬†¬†¬†3¬†¬†¬†3¬†¬†¬†284¬†¬†17¬†¬†15  7¬†¬†¬†981¬†¬†¬†4¬†¬†¬†3¬†¬†¬†986¬†¬†17¬†¬†17  8¬†¬†¬†425¬†¬†¬†8¬†¬†¬†6¬†¬†¬†194¬†¬†17¬†¬†19  ..............................  48¬†¬†¬†224¬†680¬†376¬†¬†¬†¬†86¬†299¬†412  49¬†¬†¬†101¬†680¬†377¬†¬†¬†860¬†300¬†413  50¬†¬†¬†505¬†680¬†378¬†¬†¬†101¬†300¬†415  51¬†¬†1010¬†681¬†378¬†¬†1010¬†301¬†416  That is      2  681    5  378    =  1010  =     2  301    5  416       (   mod  1019   )             superscript  2  681    superscript  5  378    1010        annotated     superscript  2  301    superscript  5  416     pmod  1019       2^{681}5^{378}=1010=2^{301}5^{416}\;\;(\mathop{{\rm mod}}1019)   and so      (   416  -  378   )   Œ≥   =    681  -  301      (   mod  1018   )            416  378   Œ≥    annotated    681  301    pmod  1018      (416-378)\gamma=681-301\;\;(\mathop{{\rm mod}}1018)   , for which     Œ≥  1   =  10       subscript  Œ≥  1   10    \gamma_{1}=10   is a solution as expected. As    n  =  1018      n  1018    n=1018   is not prime, there is another solution     Œ≥  2   =  519       subscript  Œ≥  2   519    \gamma_{2}=519   , for which     2  519   =  1014  =    -  5      (   mod  1019   )           superscript  2  519   1014        annotated    5    pmod  1019       2^{519}=1014=-5\;\;(\mathop{{\rm mod}}1019)   holds.  Complexity  The running time is approximately    ùí™   (   n   )       ùí™    n     \mathcal{O}(\sqrt{n})   . If used together with the Pohlig-Hellman algorithm , the running time of the combined algorithm is    ùí™   (   p   )       ùí™    p     \mathcal{O}(\sqrt{p})   , where   p   p   p   is the largest prime factor of   n   n   n   .  References      "  Category:Logarithms  Category:Number theoretic algorithms 