<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="264">Longest common substring problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Longest common substring problem</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, the <strong>longest common substring problem</strong> is to find the longest <a href="string_(computer_science)" title="wikilink">string</a> (or strings) that is a <a class="uri" href="substring" title="wikilink">substring</a> (or are substrings) of two or more strings.</p>
<h2 id="example">Example</h2>

<p>The longest common substring of the strings "ABABC", "BABCA" and "ABCBA" is string "ABC" of length 3. Other common substrings are "A", "AB", "B", "BA", "BC" and "C".</p>

<p><code>  ABABC</code><br/>
<code>    |||</code><br/>
<code>   BABCA</code><br/>
<code>    |||</code><br/>
<code>    ABCBA</code></p>
<h2 id="problem-definition">Problem definition</h2>

<p>Given two strings, 

<math display="inline" id="Longest_common_substring_problem:0">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="Longest_common_substring_problem:1">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Longest_common_substring_problem:2">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="Longest_common_substring_problem:3">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, find the longest strings which are substrings of both 

<math display="inline" id="Longest_common_substring_problem:4">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Longest_common_substring_problem:5">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</p>

<p>A generalisation is the <strong>k-common substring problem</strong>. Given the set of strings 

<math display="inline" id="Longest_common_substring_problem:6">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mi>K</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>K</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{S_{1},...,S_{K}\}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Longest_common_substring_problem:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>S</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>n</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S_{i}|=n_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Longest_common_substring_problem:8">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Σ</mi>
    <msub>
     <mi>n</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Σ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma n_{i}=N
  </annotation>
 </semantics>
</math>

. Find for each 

<math display="inline" id="Longest_common_substring_problem:9">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>≤</mo>
   <mi>k</mi>
   <mo>≤</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\leq k\leq K
  </annotation>
 </semantics>
</math>

, the longest strings which occur as substrings of at least 

<math display="inline" id="Longest_common_substring_problem:10">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 strings.</p>
<h2 id="algorithms">Algorithms</h2>

<p>One can find the lengths and starting positions of the longest common substrings of 

<math display="inline" id="Longest_common_substring_problem:11">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Longest_common_substring_problem:12">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Longest_common_substring_problem:13">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n+m)
  </annotation>
 </semantics>
</math>

 with the help of a <a href="generalised_suffix_tree" title="wikilink">generalised suffix tree</a>. Finding them by <a href="dynamic_programming" title="wikilink">dynamic programming</a> costs 

<math display="inline" id="Longest_common_substring_problem:14">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(nm)
  </annotation>
 </semantics>
</math>

. The solutions to the generalised problem take 

<math display="inline" id="Longest_common_substring_problem:15">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <msub>
      <mi>n</mi>
      <mi>K</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>K</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n_{1}+...+n_{K})
  </annotation>
 </semantics>
</math>

 space and 

<math display="inline" id="Longest_common_substring_problem:16">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Θ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n_{1}
  </annotation>
 </semantics>
</math>

·...·

<math display="inline" id="Longest_common_substring_problem:17">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mi>K</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>K</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{K})
  </annotation>
 </semantics>
</math>

 time with <a href="dynamic_programming" title="wikilink">dynamic programming</a> and take 

<math display="inline" id="Longest_common_substring_problem:18">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mo>*</mo>
     <mi>K</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(N*K)
  </annotation>
 </semantics>
</math>

 time with <a href="generalized_suffix_tree" title="wikilink">generalized suffix tree</a>.</p>
<h3 id="suffix-tree">Suffix tree</h3>

<p> The longest common substrings of a set of strings can be found by building a <a href="generalised_suffix_tree" title="wikilink">generalised suffix tree</a> for the strings, and then finding the deepest internal nodes which have leaf nodes from all the strings in the subtree below it. The figure on the right is the suffix tree for the strings "ABAB", "BABA" and "ABBA", padded with unique string terminators, to become "ABAB$0", "BABA$1" and "ABBA$2". The nodes representing "A", "B", "AB" and "BA" all have descendant leaves from all of the strings, numbered 0, 1 and 2.</p>

<p>Building the suffix tree takes 

<math display="inline" id="Longest_common_substring_problem:19">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(N)
  </annotation>
 </semantics>
</math>

 time (if the size of the alphabet is constant). If the tree is traversed from the bottom up with a bit vector telling which strings are seen below each node, the k-common substring problem can be solved in 

<math display="inline" id="Longest_common_substring_problem:20">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mi>K</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(NK)
  </annotation>
 </semantics>
</math>

 time. If the suffix tree is prepared for constant time <a href="lowest_common_ancestor" title="wikilink">lowest common ancestor</a> retrieval, it can be solved in 

<math display="inline" id="Longest_common_substring_problem:21">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(N)
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="dynamic-programming"><a href="Dynamic_programming" title="wikilink">Dynamic programming</a></h3>

<p>First find the longest common <a href="substring#Suffix" title="wikilink">suffix</a> for all pairs of <a href="substring#Prefix" title="wikilink">prefixes</a> of the strings. The longest common suffix is</p>

<p>

<math display="inline" id="Longest_common_substring_problem:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐿𝐶𝑆𝑢𝑓𝑓</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mrow>
       <mn>1..</mn>
       <mi>p</mi>
      </mrow>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>T</mi>
      <mrow>
       <mn>1..</mn>
       <mi>q</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>𝐿𝐶𝑆𝑢𝑓𝑓</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>S</mi>
           <mrow>
            <mrow>
             <mn>1..</mn>
             <mi>p</mi>
            </mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>T</mi>
           <mrow>
            <mrow>
             <mn>1..</mn>
             <mi>q</mi>
            </mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+2.8pt">
          <mi>if</mi>
         </mpadded>
         <mi>S</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>p</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>T</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>q</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>otherwise</mi>
        <mo>.</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐿𝐶𝑆𝑢𝑓𝑓</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <cn type="float">1..</cn>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <times></times>
        <cn type="float">1..</cn>
        <ci>q</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>𝐿𝐶𝑆𝑢𝑓𝑓</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <cn type="float">1..</cn>
           <ci>p</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <cn type="float">1..</cn>
           <ci>q</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </interval>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>if</ci>
       <ci>S</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>q</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <ci>otherwise</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{LCSuff}(S_{1..p},T_{1..q})=\begin{cases}\mathit{LCSuff}(S_{1..p-1},T_{%
1..q-1})+1&\mathrm{if}\;S[p]=T[q]\\
0&\mathrm{otherwise}.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>For the example strings "ABAB" and "BABA":</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>A</p></th>
<th style="text-align: left;">
<p>B</p></th>
<th style="text-align: left;">
<p>A</p></th>
<th style="text-align: left;">
<p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
</tbody>
</table>

<p>The maximal of these longest common suffixes of possible prefixes must be the longest common substrings of <em>S</em> and <em>T</em>. These are shown on diagonals, in red, in the table. For this example, the longest common substrings are "BAB" and "ABA".</p>

<p>

<math display="block" id="Longest_common_substring_problem:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐿𝐶𝑆𝑢𝑏𝑠𝑡𝑟</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mi>max</mi>
      <mrow>
       <mrow>
        <mn>1</mn>
        <mo>≤</mo>
        <mi>i</mi>
        <mo>≤</mo>
        <mi>m</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mn>1</mn>
        <mo>≤</mo>
        <mi>j</mi>
        <mo>≤</mo>
        <mi>n</mi>
       </mrow>
      </mrow>
     </munder>
     <mi>𝐿𝐶𝑆𝑢𝑓𝑓</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mrow>
       <mn>1..</mn>
       <mi>i</mi>
      </mrow>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>T</mi>
      <mrow>
       <mn>1..</mn>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo rspace="5.3pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐿𝐶𝑆𝑢𝑏𝑠𝑡𝑟</ci>
     <interval closure="open">
      <ci>S</ci>
      <ci>T</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <and></and>
         <apply>
          <leq></leq>
          <cn type="integer">1</cn>
          <ci>i</ci>
         </apply>
         <apply>
          <leq></leq>
          <share href="#.cmml">
          </share>
          <ci>m</ci>
         </apply>
        </apply>
        <apply>
         <and></and>
         <apply>
          <leq></leq>
          <cn type="integer">1</cn>
          <ci>j</ci>
         </apply>
         <apply>
          <leq></leq>
          <share href="#.cmml">
          </share>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>𝐿𝐶𝑆𝑢𝑓𝑓</ci>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <cn type="float">1..</cn>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <times></times>
        <cn type="float">1..</cn>
        <ci>j</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{LCSubstr}(S,T)=\max_{1\leq i\leq m,1\leq j\leq n}\mathit{LCSuff}(S_{1.%
.i},T_{1..j})\;
  </annotation>
 </semantics>
</math>

</p>

<p>This can be extended to more than two strings by adding more dimensions to the table.</p>
<h2 id="pseudocode">Pseudocode</h2>

<p>The following pseudocode finds the set of longest common substrings between two strings with dynamic programming:</p>

<p><strong><code>function</code></strong><code> LCSubstr(S[1..m], T[1..n])</code><br/>
<code>    L := </code><strong><code>array</code></strong><code>(1..m, 1..n)</code><br/>
<code>    z := 0</code><br/>
<code>    ret := {}</code><br/>
<code>    </code><strong><code>for</code></strong><code> i := 1..m</code><br/>
<code>        </code><strong><code>for</code></strong><code> j := 1..n</code><br/>
<code>            </code><strong><code>if</code></strong><code> S[i] == T[j]</code><br/>
<code>                </code><strong><code>if</code></strong><code> i == 1 or j == 1</code><br/>
<code>                    L[i,j] := 1</code><br/>
<code>                </code><strong><code>else</code></strong><br/>
<code>                    L[i,j] := L[i-1,j-1] + 1</code><br/>
<code>                </code><strong><code>if</code></strong><code> L[i,j] &gt; z</code><br/>
<code>                    z := L[i,j]</code><br/>
<code>                    ret := {S[i-z+1..i]}</code><br/>
<code>                </code><strong><code>else</code></strong><br/>
<code>                </code><strong><code>if</code></strong><code> L[i,j] == z</code><br/>
<code>                    ret := ret ∪ {S[i-z+1..i]}</code><br/>
<code>            </code><strong><code>else</code></strong><code> </code><br/>
<code>                L[i,j] := 0</code><br/>
<code>    </code><strong><code>return</code></strong><code> ret</code></p>

<p>This algorithm runs in 

<math display="inline" id="Longest_common_substring_problem:24">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nm)
  </annotation>
 </semantics>
</math>


 time. The variable <code>z</code> is used to hold the length of the longest common substring found so far. The set <code>ret</code> is used to hold the set of strings which are of length <code>z</code>. The set <code>ret</code> can be saved efficiently by just storing the index <code>i</code>, which is the last character of the longest common substring (of size z) instead of <code>S[i-z+1..i]</code>. Thus all the longest common substrings would be, for each i in <code>ret</code>, <code>S[(ret[i]-z)..(ret[i])]</code>.</p>

<p>The following tricks can be used to reduce the memory usage of an implementation:</p>
<ul>
<li>Keep only the last and current row of the DP table to save memory (

<math display="inline" id="Longest_common_substring_problem:25">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>min</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <min></min>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\min(m,n))
  </annotation>
 </semantics>
</math>

 instead of 

<math display="inline" id="Longest_common_substring_problem:26">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nm)
  </annotation>
 </semantics>
</math>

)</li>
<li>Store only non-zero values in the rows. This can be done using hash tables instead of arrays. This is useful for large alphabets.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Longest_palindromic_substring" title="wikilink">Longest palindromic substring</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://nist.gov/dads/HTML/longestCommonSubstring.html">Dictionary of Algorithms and Data Structures: longest common substring</a></li>
<li>[<a class="uri" href="http://metacpan.org/module/String">http://metacpan.org/module/String</a>::LCSS_XS Perl/XS implementation of the dynamic programming algorithm]</li>
<li>[<a class="uri" href="http://metacpan.org/module/Tree">http://metacpan.org/module/Tree</a>::Suffix Perl/XS implementation of the suffix tree algorithm]</li>
<li><a href="http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring">Dynamic programming implementations in various languages on wikibooks</a></li>
<li><a href="http://www.emanueleferonato.com/2010/12/01/solving-the-longest-common-substring-problem-with-as3/">working AS3 implementation of the dynamic programming algorithm</a></li>
<li><a href="http://www.geeksforgeeks.org/suffix-tree-application-5-longest-common-substring-2/">Suffix Tree based C implementation of Longest common substring for two strings</a></li>
</ul>

<p>"</p>

<p><a href="Category:Problems_on_strings" title="wikilink">Category:Problems on strings</a> <a href="Category:Dynamic_programming" title="wikilink">Category:Dynamic programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
