<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1552">Occurs check</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Occurs check</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, the <strong>occurs check</strong> is a part of <a href="algorithm" title="wikilink">algorithms</a> for syntactic <a href="unification_(computer_science)" title="wikilink">unification</a>. It causes unification of a <a href="First-order_logic#Terms" title="wikilink">variable</a> <em>V</em> and a structure <em>S</em> to fail if <em>S</em> contains <em>V</em>.</p>
<h2 id="application-in-theorem-proving">Application in theorem proving</h2>

<p>In <a href="theorem_proving" title="wikilink">theorem proving</a>, unification without the occurs check can lead to <a href="soundness" title="wikilink">unsound</a> <a class="uri" href="inference" title="wikilink">inference</a>. For example, the <a class="uri" href="Prolog" title="wikilink">Prolog</a> goal 

<math display="inline" id="Occurs_check:0">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=f(X)
  </annotation>
 </semantics>
</math>

 will succeed, binding <em>X</em> to a cyclic structure which has no counterpart in the <a href="Herbrand_universe" title="wikilink">Herbrand universe</a>. As another example, <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> without occurs-check, a <a href="Resolution_(logic)" title="wikilink">resolution proof</a> can be found for the non-theorem <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> 

<math display="inline" id="Occurs_check:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>∃</mo>
    <mi>y</mi>
    <mo>.</mo>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>y</mi>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>.</mo>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <exists></exists>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x\exists y.p(x,y))\rightarrow(\exists y\forall x.p(x,y))
  </annotation>
 </semantics>
</math>

: the negation of that formula has the <a href="conjunctive_normal_form" title="wikilink">conjunctive normal form</a> 

<math display="inline" id="Occurs_check:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <times></times>
     <ci>p</ci>
     <interval closure="open">
      <ci>X</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>X</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>p</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>Y</ci>
      </apply>
      <ci>Y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X,f(X))\land\lnot p(g(Y),Y)
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Occurs_check:3">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Occurs_check:4">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 denoting the <a href="Skolem_function" title="wikilink">Skolem function</a> for the first and second existential quantifier, respectively; the literals 

<math display="inline" id="Occurs_check:5">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <interval closure="open">
     <ci>X</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>X</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X,f(X))
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Occurs_check:6">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>Y</ci>
     </apply>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(g(Y),Y)
  </annotation>
 </semantics>
</math>

 are unifiable without occurs check, producing the refuting empty clause.</p>

<p><a href="File:Example_for_syntactic_unification_without_occurs_check_leading_to_infinite_tree_svg.svg" title="wikilink">thumb|upright=0.5|Cycle by omitted occurs check</a></p>
<h2 id="prolog-implementation">Prolog implementation</h2>

<p>By default, Prolog implementations usually omit the occurs check for reasons of efficiency, which can lead to circular data structures and looping. By not performing the occurs check, the worst case complexity of unifying a term 

<math display="inline" id="Occurs_check:7">
 <semantics>
  <msub>
   <mi>t</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{1}
  </annotation>
 </semantics>
</math>

 with term 

<math display="inline" id="Occurs_check:8">
 <semantics>
  <msub>
   <mi>t</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{2}
  </annotation>
 </semantics>
</math>

 is reduced from 

<math display="inline" id="Occurs_check:9">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mtext>size</mtext>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mtext>size</mtext>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <mtext>size</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>size</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\text{size}(t_{1})+\text{size}(t_{2}))
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Occurs_check:10">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mtext>min</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mtext>size</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>t</mi>
         <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mtext>size</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>t</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <mtext>min</mtext>
     <interval closure="open">
      <apply>
       <times></times>
       <mtext>size</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <mtext>size</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\text{min}(\text{size}(t_{1}),\text{size}(t_{2})))
  </annotation>
 </semantics>
</math>

; in particular, the frequent case of variable-term unifications, runtime shrinks to 

<math display="inline" id="Occurs_check:11">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

. <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>A naive omission of the occurs check leads to the creation of cyclic structures and may cause unification to loop forever. Modern implementations, based on Colmerauer's Prolog II, <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> use <a href="rational_tree_unification" title="wikilink">rational tree unification</a> to avoid looping. See image for an example run of the unification algorithm given in <a href="Unification_(computer_science)#A_unification_algorithm" title="wikilink">Unification (computer science)#A unification algorithm</a>, trying to solve the goal 

<math display="inline" id="Occurs_check:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mi>o</mi>
    <mi>n</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mi mathvariant="normal">?</mi>
   </mover>
   <mrow>
    <mi>c</mi>
    <mi>o</mi>
    <mi>n</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mrow>
      <mi>c</mi>
      <mi>o</mi>
      <mi>n</mi>
      <mi>s</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mrow>
        <mi>c</mi>
        <mi>o</mi>
        <mi>n</mi>
        <mi>s</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo>,</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>normal-?</ci>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>o</ci>
     <ci>n</ci>
     <ci>s</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>o</ci>
     <ci>n</ci>
     <ci>s</ci>
     <interval closure="open">
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>o</ci>
       <ci>n</ci>
       <ci>s</ci>
       <interval closure="open">
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>c</ci>
         <ci>o</ci>
         <ci>n</ci>
         <ci>s</ci>
         <interval closure="open">
          <cn type="integer">2</cn>
          <ci>y</ci>
         </interval>
        </apply>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   cons(x,y)\stackrel{?}{=}cons(1,cons(x,cons(2,y)))
  </annotation>
 </semantics>
</math>

, however without the <em>occurs check rule</em> (named "check" there); applying rule "eliminate" instead leads to a cyclic graph (i.e. an infinite term) in the last step.</p>

<p>ISO Prolog implementations have the built-in predicate unify_with_occurs_check/2 for sound unification but are free to use unsound or even looping algorithms when unification is invoked otherwise, provided the algorithm works correctly for all cases that are "not subject to occurs-check" (NSTO).<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Implementations offering sound unification for all unifications (optionally, via a runtime flag) are <a class="uri" href="XSB" title="wikilink">XSB</a> and <a class="uri" href="SWI-Prolog" title="wikilink">SWI-Prolog</a>.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Automated_theorem_proving" title="wikilink">Category:Automated theorem proving</a> <a href="Category:Logic_programming" title="wikilink">Category:Logic programming</a> <a href="Category:Programming_constructs" title="wikilink">Category:Programming constructs</a> <a href="Category:Unification_(computer_science)" title="wikilink">Category:Unification (computer science)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">; here: p.143<a href="#fnref1">↩</a></li>
<li id="fn2">Informally, and taking 

<math display="inline" id="Occurs_check:13">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x,y)
  </annotation>
 </semantics>
</math>

 to mean e.g. "<em>x loves y</em>", the formula reads "<em>If everybody loves somebody, then a single person must exist that is loved by everyone.</em>"<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">7.3.4 Normal unification in Prolog of ISO/IEC 13211-1:1995.<a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
