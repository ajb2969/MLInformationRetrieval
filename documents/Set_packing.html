<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1969">Set packing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Set packing</h1>
<hr/>

<p><strong>Set packing</strong> is a classical <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> and <a class="uri" href="combinatorics" title="wikilink">combinatorics</a>, and was one of <a href="Karp's_21_NP-complete_problems" title="wikilink">Karp's 21 NP-complete problems</a>.</p>

<p>Suppose we have a finite set <em>S</em> and a list of subsets of <em>S</em>. Then, the set packing problem asks if some <em>k</em> subsets in the list are pairwise <a href="disjoint_sets" title="wikilink">disjoint</a> (in other words, no two of them share an element).</p>

<p>More formally, given a universe 

<math display="inline" id="Set_packing:0">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’°</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’°</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

 and a family 

<math display="inline" id="Set_packing:1">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’®</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 of subsets of 

<math display="inline" id="Set_packing:2">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’°</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’°</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

, a <em>packing</em> is a subfamily 

<math display="inline" id="Set_packing:3">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ğ’</mi>
   <mo>âŠ†</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>ğ’</ci>
    <ci>ğ’®</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}\subseteq\mathcal{S}
  </annotation>
 </semantics>
</math>

 of sets such that all sets in 

<math display="inline" id="Set_packing:4">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 are pairwise disjoint, and the size of the packing is 

<math display="inline" id="Set_packing:5">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>ğ’</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathcal{C}|
  </annotation>
 </semantics>
</math>

. In the set packing <a href="decision_problem" title="wikilink">decision problem</a>, the input is a pair 

<math display="inline" id="Set_packing:6">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’°</mi>
   <mo>,</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>ğ’°</ci>
    <ci>ğ’®</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{U},\mathcal{S})
  </annotation>
 </semantics>
</math>

 and an integer 

<math display="inline" id="Set_packing:7">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

; the question is whether there is a set packing of size 

<math display="inline" id="Set_packing:8">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 or more. In the set packing <a href="optimization_problem" title="wikilink">optimization problem</a>, the input is a pair 

<math display="inline" id="Set_packing:9">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’°</mi>
   <mo>,</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>ğ’°</ci>
    <ci>ğ’®</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{U},\mathcal{S})
  </annotation>
 </semantics>
</math>

, and the task is to find a set packing that uses the most sets.</p>

<p>The problem is clearly in <a href="NP_(complexity)" title="wikilink">NP</a> since, given <em>k</em> subsets, we can easily verify that they are pairwise disjoint in <a href="P_(complexity)" title="wikilink">polynomial time</a>.</p>

<p>The <a href="optimization_problem" title="wikilink">optimization version</a> of the problem, <strong>maximum set packing</strong>, asks for the maximum number of pairwise disjoint sets in the list. It is a maximization problem that can be formulated naturally as an <a href="integer_linear_program" title="wikilink">integer linear program</a>, belongs to the class of <a href="packing_problem" title="wikilink">packing problems</a>, and its <a href="dual_linear_program" title="wikilink">dual linear program</a> is the <a href="set_cover_problem" title="wikilink">set cover problem</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> </p>
<h2 id="integer-linear-program-formulation">Integer linear program formulation</h2>

<p>The maximum set packing problem can be formulated as the following <a href="integer_linear_program" title="wikilink">integer linear program</a>.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>maximize</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Set_packing:10">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">âˆ‘</mo>
    <mrow>
     <mi>S</mi>
     <mo>âˆˆ</mo>
     <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
    </mrow>
   </msub>
   <msub>
    <mi>x</mi>
    <mi>S</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>S</ci>
      <ci>ğ’®</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{S\in\mathcal{S}}x_{S}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>(maximize the total number of subsets)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>subject to</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Set_packing:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">âˆ‘</mo>
     <mrow>
      <mi>S</mi>
      <mo>:</mo>
      <mrow>
       <mi>e</mi>
       <mo>âˆˆ</mo>
       <mi>S</mi>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>S</mi>
    </msub>
   </mrow>
   <mo>â©½</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <ci>normal-:</ci>
       <ci>S</ci>
       <apply>
        <in></in>
        <ci>e</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{S\colon e\in S}x_{S}\leqslant 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>for all 

<math display="inline" id="Set_packing:12">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>âˆˆ</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’°</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>e</ci>
    <ci>ğ’°</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\in\mathcal{U}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>(selected sets have to be pairwise disjoint)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Set_packing:13">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>S</mi>
   </msub>
   <mo>âˆˆ</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>S</ci>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{S}\in\{0,1\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>for all 

<math display="inline" id="Set_packing:14">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>âˆˆ</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>S</ci>
    <ci>ğ’®</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\in\mathcal{S}
  </annotation>
 </semantics>
</math>

.</p></td>
<td style="text-align: left;">
<p>(every set is either in the set packing or not)</p></td>
</tr>
</tbody>
</table>
<h2 id="examples">Examples</h2>

<p>As a simple example, suppose your kitchen contains a collection of different food ingredients (

<math display="inline" id="Set_packing:15">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’°</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’°</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

), and you have a cook-book with a collection of recipes ( 

<math display="inline" id="Set_packing:16">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’®</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

). Each recipe requires a subset of the food ingredients. You want to prepare the largest possible collection of recipes from the cook-book. You are actually looking for a set-packing (

<math display="inline" id="Set_packing:17">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

) on (

<math display="inline" id="Set_packing:18">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ğ’°</mi>
   <mo>,</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>ğ’°</ci>
    <ci>ğ’®</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U},\mathcal{S}
  </annotation>
 </semantics>
</math>

) - a collection of recipes whose sets of ingredients are pairwise disjoint.</p>

<p>As another example, suppose you're at a convention of foreign ambassadors, each of which speaks English and also various other languages. You want to make an announcement to a group of them, but because you don't trust them, you don't want them to be able to speak among themselves without you being able to understand them. To ensure this, you will choose a group such that no two ambassadors speak the same language, other than English. On the other hand you also want to give your announcement to as many ambassadors as possible. In this case, the elements of the set are languages other than English, and the subsets are the sets of languages spoken by a particular ambassador. If two sets are disjoint, those two ambassadors share no languages other than English. A maximum set packing will choose the largest possible number of ambassadors under the desired constraint. Although this problem is hard to solve in general, in this example a good heuristic is to choose ambassadors who only speak unusual languages first, so that not too many others are disqualified.</p>
<h2 id="weighted-version">Weighted version</h2>

<p>There is a weighted version of the set packing problem in which each subset is assigned a real weight and it is this weight we wish to maximize

<math display="block" id="Set_packing:19">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
    <mrow>
     <mi>S</mi>
     <mo>âˆˆ</mo>
     <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
    </mrow>
   </munder>
   <mrow>
    <mrow>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>â‹…</mo>
    <msub>
     <mi>x</mi>
     <mi>S</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>S</ci>
      <ci>ğ’®</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-â‹…</ci>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{S\in\mathcal{S}}w(S)\cdot x_{S}
  </annotation>
 </semantics>
</math>

</p>

<p>In our simple example above, we might weight the recipes according to the number of friends that love the resulting dishes, so that our dinner will please the largest number of friends.</p>

<p>This seems to make the problem harder, but most known results for the unweighted problem apply to the weighted problem as well.</p>
<h2 id="heuristics">Heuristics</h2>

<p>The set packing problem may be hard for some <em>k</em>, but it's not hard to find a <em>k</em> for which it is easy on a particular input. For example, we can use a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a> where we look for the set which intersects the smallest number of other sets, add it to our solution, and remove the sets it intersects. We continually do this until no sets are left, and we have a set packing of some size, although it may not be the maximum set packing. Although no algorithm can always produce results close to the maximum (see next section), on many practical inputs these heuristics do so.</p>
<h2 id="complexity">Complexity</h2>

<p>The set packing problem is not only NP-complete, but its optimization version (general maximum set packing problem) has been proven as difficult to approximate as the <a href="maximum_clique_problem" title="wikilink">maximum clique problem</a>; in particular, it cannot be approximated within any constant factor.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The best known algorithm approximates it within a factor of 

<math display="inline" id="Set_packing:20">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>U</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <apply>
      <abs></abs>
      <ci>U</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{|U|})
  </annotation>
 </semantics>
</math>

. The weighted variant can also be approximated this well.</p>

<p>However, the problem does have a variant which is more tractable: if we assume no subset exceeds <em>k</em>â‰¥3 elements, the answer can be approximated within a factor of <em>k</em>/2 + Îµ for any Îµ &gt; 0; in particular, the problem with 3-element sets can be approximated within about 50%. In another more tractable variant, if no element occurs in more than <em>k</em> of the subsets, the answer can be approximated within a factor of <em>k</em>. This is also true for the weighted version.</p>
<h2 id="equivalent-problems">Equivalent problems</h2>

<p>There is a one-to-one polynomial-time reduction between the <a href="Independent_set_(graph_theory)" title="wikilink">independent set</a> problem and the set packing problem:</p>
<ul>
<li>Given a set packing problem on a collection 

<math display="inline" id="Set_packing:21">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’®</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

, create a graph where for each set 

<math display="inline" id="Set_packing:22">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>âˆˆ</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>S</ci>
    <ci>ğ’®</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\in\mathcal{S}
  </annotation>
 </semantics>
</math>

 there is a vertex 

<math display="inline" id="Set_packing:23">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{S}
  </annotation>
 </semantics>
</math>

, and there is an edge between 

<math display="inline" id="Set_packing:24">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{S}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Set_packing:25">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{T}
  </annotation>
 </semantics>
</math>

 iff 

<math display="inline" id="Set_packing:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>âˆ©</mo>
    <mi>T</mi>
   </mrow>
   <mo>â‰ </mo>
   <mi>Ï•</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <intersect></intersect>
     <ci>S</ci>
     <ci>T</ci>
    </apply>
    <ci>Ï•</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\cap T\neq\phi
  </annotation>
 </semantics>
</math>

. Now every independent set of vertices in the generated graph corresponds to a set packing in 

<math display="inline" id="Set_packing:27">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ğ’®</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’®</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

.</li>
<li>Given an independent vertex set problem on a graph 

<math display="inline" id="Set_packing:28">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(V,E)
  </annotation>
 </semantics>
</math>

, create a collection of sets where for each vertex 

<math display="inline" id="Set_packing:29">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 there is a set 

<math display="inline" id="Set_packing:30">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{v}
  </annotation>
 </semantics>
</math>

 containing all edges adjacent to 

<math display="inline" id="Set_packing:31">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

. Now every set packing in the generated collection corresponds to an independent vertex set in 

<math display="inline" id="Set_packing:32">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(V,E)
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>This is also a bidirectional <a href="PTAS_reduction" title="wikilink">PTAS reduction</a>, and it shows that the two problems are equally difficult to approximate.</p>
<h2 id="special-cases">Special cases</h2>

<p><a href="Matching_(graph_theory)" title="wikilink">Matching</a> and <a href="3-dimensional_matching" title="wikilink">3-dimensional matching</a> are special cases of set packing. A maximum-size matching can be found in polynomial time, but finding a largest 3-dimensional matching or a largest independent set is NP-hard.</p>
<h2 id="other-related-problems">Other related problems</h2>

<p>Set packing is one among a family of problems related to covering or partitioning the elements of a set. One closely related problem is the <a href="set_cover_problem" title="wikilink">set cover problem</a>. Here, we are also given a set <em>S</em> and a list of sets, but the goal is to determine whether we can choose <em>k</em> sets that together contain every element of <em>S</em>. These sets may overlap. The optimization version finds the minimum number of such sets. The maximum set packing need not cover every possible element.</p>

<p>The NP-complete <a href="exact_cover" title="wikilink">exact cover</a> problem, on the other hand, requires every element to be contained in exactly one of the subsets. Finding such an exact cover at all, regardless of size, is an <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem. However, if we create a <a href="singleton_set" title="wikilink">singleton set</a> for each element of <em>S</em> and add these to the list, the resulting problem is about as easy as set packing.</p>

<p>Karp originally showed set packing NP-complete via a reduction from the <a href="clique_problem" title="wikilink">clique problem</a>.</p>

<p>See also: <a href="Packing_in_a_hypergraph" title="wikilink">Packing in a hypergraph</a>.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.nada.kth.se/~viggo/wwwcompendium/node144.html">Maximum Set Packing</a>, Viggo Kann.</li>
<li>"<a href="http://www.nist.gov/dads/HTML/setpacking.html">set packing</a>". <em>Dictionary of Algorithms and Data Structures</em>, editor Paul E. Black, <em>National Institute of Standards and Technology.</em> Note that the definition here is somewhat different.</li>
<li>Steven S. Skiena. "<a href="http://www2.toki.or.id/book/AlgDesignManual/BOOK/BOOK5/NODE202.HTM">Set Packing</a>". <em>The Algorithm Design Manual</em>. Last modified June 2, 1997.</li>
<li>Pierluigi Crescenzi, Viggo Kann, MagnÃºs HalldÃ³rsson, <a href="Marek_Karpinski" title="wikilink">Marek Karpinski</a> and Gerhard Woeginger. "<a href="http://www.nada.kth.se/~viggo/wwwcompendium/node144.html">Maximum Set Packing</a>". <a href="http://www.nada.kth.se/%7Eviggo/wwwcompendium/"><em>A compendium of NP optimization problems</em></a>. Last modified March 20, 2000.</li>
<li>

<p>A3.1: SP3, pg.221.</p></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.sunysb.edu/~algorith/implement/syslo/implement.shtml">1</a>: A Pascal program for solving the problem. From <em>Discrete Optimization Algorithms with Pascal Programs</em> by MacIej M. Syslo, ISBN 0-13-215509-5.</li>
<li><a href="http://www.nlsde.buaa.edu.cn/~kexu/benchmarks/set-benchmarks.htm">Benchmarks with Hidden Optimum Solutions for Set Covering, Set Packing and Winner Determination</a></li>
<li><a href="http://www.phpqa.in/2010/10/solving-packaging-problem-in-php.html">Solving packaging problem in PHP</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Combinatorics" title="wikilink">Category:Combinatorics</a> <a href="Category:NP-complete_problems" title="wikilink">Category:NP-complete problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">â†©</a></li>
<li id="fn2">. See in particular p.Â 21: "Maximum clique (and therefore also maximum independent set and maximum set packing) cannot be approximated to within 

<math display="inline" id="Set_packing:33">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>Ïµ</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>Ïµ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{1-\epsilon})
  </annotation>
 </semantics>
</math>

 unless NP âŠ‚ ZPP."<a href="#fnref2">â†©</a></li>
</ol>
</section>
</body>
</html>
