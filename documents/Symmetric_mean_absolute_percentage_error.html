<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="987">Symmetric mean absolute percentage error</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Symmetric mean absolute percentage error</h1>
<hr/>

<p><strong>Symmetric mean absolute percentage error (SMAPE</strong> or <strong>sMAPE)</strong> is an accuracy measure based on percentage (or relative) errors. It is usually defined as follows:</p>

<p>

<math display="block" id="Symmetric_mean_absolute_percentage_error:0">
 <semantics>
  <mrow>
   <mtext>SMAPE</mtext>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mfrac>
      <mrow>
       <mo>|</mo>
       <mrow>
        <msub>
         <mi>F</mi>
         <mi>t</mi>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>A</mi>
         <mi>t</mi>
        </msub>
       </mrow>
       <mo>|</mo>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <msub>
           <mi>A</mi>
           <mi>t</mi>
          </msub>
          <mo stretchy="false">|</mo>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mo stretchy="false">|</mo>
          <msub>
           <mi>F</mi>
           <mi>t</mi>
          </msub>
          <mo stretchy="false">|</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>SMAPE</mtext>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <abs></abs>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>A</ci>
           <ci>t</ci>
          </apply>
         </apply>
         <apply>
          <abs></abs>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>F</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{SMAPE}=\frac{1}{n}\sum_{t=1}^{n}\frac{\left|F_{t}-A_{t}\right|}{(|A_{t}|%
+|F_{t}|)/2}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>A</em><sub><em>t</em></sub> is the actual value and <em>F</em><sub><em>t</em></sub> is the forecast value.</p>

<p>The <a href="absolute_difference" title="wikilink">absolute difference</a> between <em>A</em><sub><em>t</em></sub> and <em>F</em><sub><em>t</em></sub> is divided by half the sum of absolute values of the actual value <em>A</em><sub><em>t</em></sub> and the forecast value <em>F</em><sub><em>t</em></sub>. The value of this calculation is summed for every fitted point <em>t</em> and divided again by the number of fitted points <em>n</em>.</p>

<p>The earliest reference to similar formula appears to be Armstrong (1985, p. 348) where it is called "adjusted <a class="uri" href="MAPE" title="wikilink">MAPE</a>" and is defined without the absolute values in denominator. It has been later discussed, modified and re-proposed by Flores (1986). The final version above is due to Makridakis (1993).</p>

<p>Armstrong's original definition is as follows:</p>

<p>

<math display="block" id="Symmetric_mean_absolute_percentage_error:1">
 <semantics>
  <mrow>
   <mtext>SMAPE</mtext>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mfrac>
      <mrow>
       <mo>|</mo>
       <mrow>
        <msub>
         <mi>F</mi>
         <mi>t</mi>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>A</mi>
         <mi>t</mi>
        </msub>
       </mrow>
       <mo>|</mo>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>A</mi>
          <mi>t</mi>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>F</mi>
          <mi>t</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>SMAPE</mtext>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <ci>t</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{SMAPE}=\frac{1}{n}\sum_{t=1}^{n}\frac{\left|F_{t}-A_{t}\right|}{(A_{t}+F%
_{t})/2}
  </annotation>
 </semantics>
</math>

</p>

<p>The problem is that it can be negative (if 

<math display="inline" id="Symmetric_mean_absolute_percentage_error:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>t</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>F</mi>
     <mi>t</mi>
    </msub>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{t}+F_{t}<0
  </annotation>
 </semantics>
</math>

) or even infinite (if 

<math display="inline" id="Symmetric_mean_absolute_percentage_error:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>t</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>F</mi>
     <mi>t</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{t}+F_{t}=0
  </annotation>
 </semantics>
</math>

). Therefore the currently accepted version of SMAPE assumes the absolute values in the denominator.</p>

<p>In contrast to the <a href="mean_absolute_percentage_error" title="wikilink">mean absolute percentage error</a>, SMAPE has both a lower bound and an upper bound. Indeed, the formula above provides a result between 0% and 200%. However a percentage error between 0% and 100% is much easier to interpret. That is the reason why the formula below is often used in practice (i.e. no factor 0.5 in denominator):</p>

<p>

<math display="block" id="Symmetric_mean_absolute_percentage_error:4">
 <semantics>
  <mrow>
   <mtext>SMAPE</mtext>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mfrac>
      <mrow>
       <mo>|</mo>
       <mrow>
        <msub>
         <mi>F</mi>
         <mi>t</mi>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>A</mi>
         <mi>t</mi>
        </msub>
       </mrow>
       <mo>|</mo>
      </mrow>
      <mrow>
       <msub>
        <mi>A</mi>
        <mi>t</mi>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>F</mi>
        <mi>t</mi>
       </msub>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>SMAPE</mtext>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{SMAPE}=\frac{1}{n}\sum_{t=1}^{n}\frac{\left|F_{t}-A_{t}\right|}{A_{t}+F_%
{t}}
  </annotation>
 </semantics>
</math>

</p>

<p>One supposed problem with <strong>SMAPE</strong> is that it is not symmetric since over- and under-forecasts are not treated equally. Let's consider the following example by applying the second <strong>SMAPE</strong> formula:</p>
<ul>
<li>Over-forecasting: <em>A</em><sub><em>t</em></sub> = 100 and <em>F</em><sub><em>t</em></sub> = 110 give SMAPE = 4.76%</li>
<li>Under-forecasting: <em>A</em><sub><em>t</em></sub> = 100 and <em>F</em><sub><em>t</em></sub> = 90 give SMAPE = 5.26%.</li>
</ul>

<p>However, one should only expect this type of symmetry for measures which are entirely difference-based and not relative (such as mean squared error and mean absolute deviation).</p>

<p>There is a third version of SMAPE, which allows to measure the direction of the bias in the data by generating a positive and a negative error on line item level. Furthermore it is better protected against outliers and the bias effect mentioned in the previous paragraph than the two other formulas. The formula is:</p>

<p>

<math display="block" id="Symmetric_mean_absolute_percentage_error:5">
 <semantics>
  <mrow>
   <mtext>SMAPE</mtext>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo>|</mo>
      <mrow>
       <msub>
        <mi>F</mi>
        <mi>t</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>A</mi>
        <mi>t</mi>
       </msub>
      </mrow>
      <mo>|</mo>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>A</mi>
        <mi>t</mi>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>F</mi>
        <mi>t</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>SMAPE</mtext>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{SMAPE}=\frac{\sum_{t=1}^{n}\left|F_{t}-A_{t}\right|}{\sum_{t=1}^{n}(A_{t%
}+F_{t})}
  </annotation>
 </semantics>
</math>

</p>

<p>A limitation to SMAPE is that if the actual value or forecast value is 0, the value of error will boom up to the upper-limit of error. (200% for the first formula and 100% for the second formula).</p>

<p>Provided the data are strictly positive, a better measure of relative accuracy can be obtained based on the log of the accuracy ratio: log(<em>F</em><sub><em>t</em></sub> / <em>A</em><sub><em>t</em></sub>) This measure is easier to analyse statistically, and has valuable symmetry and unbiasedness properties. When used in constructing forecasting models the resulting prediction corresponds to the geometric mean (Tofallis, 2015).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Relative_change_and_difference" title="wikilink">Relative change and difference</a></li>
<li><a href="Mean_absolute_error" title="wikilink">Mean absolute error</a></li>
<li><a href="Mean_absolute_percentage_error" title="wikilink">Mean absolute percentage error</a></li>
<li><a href="Mean_squared_error" title="wikilink">Mean squared error</a></li>
<li><a href="Root_mean_squared_error" title="wikilink">Root mean squared error</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="J._Scott_Armstrong" title="wikilink">Armstrong, J. S.</a> (1985) Long-range Forecasting: From Crystal Ball to Computer, 2nd. ed. Wiley. ISBN 978-0-471-82260-8</li>
<li>Flores, B. E. (1986) "A pragmatic view of accuracy measurement in forecasting", Omega (Oxford), 14(2), 93–98. </li>
<li>Tofallis, C (2015) "A Better Measure of Relative Prediction Accuracy for Model Selection and Model Estimation", Journal of the Operational Research Society, 66(8),1352-1362. <a href="http://papers.ssrn.com/sol3/papers.cfm?abstract_id=2635088">archived preprint</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://robjhyndman.com/hyndsight/smape/">Rob J. Hyndman: Errors on Percentage Errors</a></li>
</ul>

<p>"</p>

<p><a href="Category:Statistical_deviation_and_dispersion" title="wikilink">Category:Statistical deviation and dispersion</a></p>
</body>
</html>
