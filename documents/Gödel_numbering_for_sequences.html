<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="49">Gödel numbering for sequences</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Gödel numbering for sequences</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>Gödel numbering for sequences</strong> provides us an effective way to represent each finite sequence of natural numbers as a single natural number. Of course, the <a href="Injective_function" title="wikilink">embedding</a> is surely possible set theoretically, but the emphasis is on the effectiveness of the functions manipulating such representations of sequences: the operations on sequences (accessing individual members, concatenation) can be "implemented" using <a href="total_recursive_function" title="wikilink">total recursive functions</a>, and in fact by <a href="primitive_recursive_function" title="wikilink">primitive recursive functions</a>.</p>

<p>It is usually used to build sequential “<a href="data_type" title="wikilink">data types</a>” in the realm of arithmetic-based formalizations of some fundamental notions of mathematics. It is a specific case of the more general idea of <a href="Gödel_numbering" title="wikilink">Gödel numbering</a>.</p>

<p>E.g. <a href="Mu-recursive_function" title="wikilink">recursive function theory</a> can be regarded as a formalization of notion “<a class="uri" href="algorithm" title="wikilink">algorithm</a>”, and if we regard it as a <a href="programming_language" title="wikilink">programming language</a>, we can mimic arrays, <a href="List_(computing)" title="wikilink">lists</a> by encoding a sequence of natural numbers in a single natural number — to achieve this, we can use various <a href="Number_theory" title="wikilink">number theoretic</a> ideas. Using the <a href="fundamental_theorem_of_arithmetic" title="wikilink">fundamental theorem of arithmetic</a> is a straightforward way, but there are also more economic approaches, e.g. using <a href="pairing_function" title="wikilink">pairing function</a> combined with <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a> in a sophisticated way.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="gödel-numbering">Gödel numbering</h2>

<p>Besides using Gödel numbering to encode unique sequences of symbols into unique natural numbers (i.e. place numbers into <a href="mutually_exclusive" title="wikilink">mutually exclusive</a> or <a href="one-to-one_correspondence" title="wikilink">one-to-one correspondence</a> with the sequences), we can use it to encode whole “architectures” of sophisticated “machines”. For example we can encode <a href="Markov_algorithm" title="wikilink">Markov algorithms</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> or <a href="Turing_machine" title="wikilink">Turing machines</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> into natural numbers and thereby prove that the expressing power of recursive function theory is no less than that of the former machine-like formalizations of algorithms.</p>
<h2 id="accessing-members">Accessing members</h2>

<p>Any such representation of sequences should contain all the information as in the original sequence: most importantly, to access each individual member. However, the length does not have to match directly: even if we want to handle sequences of different length, we can store length data as a surplus member,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> or as the other member of an ordered pair by using a <a href="pairing_function" title="wikilink">pairing function</a>.</p>

<p>Anyway, we expect that there is an effective way for this information retrieval process in form of an appropriate total recursive function.</p>

<p>We want to find a totally recursive function <em>f</em> that satisfies: For all <em>n</em> and for any <em>n</em>-length sequence of natural numbers 

<math display="inline" id="Gödel_numbering_for_sequences:0">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msub>
    <mi>a</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a_{0},\dots a_{n-1}\rangle
  </annotation>
 </semantics>
</math>

, there exists an appropriate natural number <em>a</em>, called the Gödel number of the sequence such that for all <em>i</em> in the range of 0, …, <em>n</em> - 1,</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>i</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a,i)=a_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>There are effective functions which can retrieve each member of the original sequence from a Gödel number of the sequence. Moreover, we can define some of them in a <a href="Constructive_proof" title="wikilink">constructive</a> way, so we can go well beyond mere <a href="Nonconstructive_proof" title="wikilink">proofs of existence</a>.</p>
<h3 id="gödels-β-function-lemma">Gödel's β-function lemma</h3>

<p>By an ingenious use of <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a>, we can define constructively such a recursive function 

<math display="inline" id="Gödel_numbering_for_sequences:2">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 (using simple number-theoretical functions, all of which can be defined in a total recursive way) fulfilling the "<a href="specification" title="wikilink">specifications</a>" given above. Also Gödel defined the 

<math display="inline" id="Gödel_numbering_for_sequences:3">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>


 function using the Chinese remainder theorem in his article written in 1931. This is a <a href="primitive_recursive_function" title="wikilink">primitive recursive function</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Thus, for all <em>n</em> and for any <em>n</em>-length sequence of natural numbers 

<math display="inline" id="Gödel_numbering_for_sequences:4">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msub>
    <mi>a</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a_{0},\dots a_{n-1}\rangle
  </annotation>
 </semantics>
</math>

, there exists an appropriate natural number <em>a</em>, called the Gödel number of the sequence such that<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>β</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>i</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta(a,i)=a_{i}
  </annotation>
 </semantics>
</math>

</p>
<h4 id="using-a-pairing-function">Using a pairing function</h4>

<p>Our specific solution will depend on a pairing function — there are several ways to implement the latter, let us select one. Now, we can <a href="Abstraction" title="wikilink">abstract</a> from the details of the “<a class="uri" href="implementation" title="wikilink">implementation</a>” of the pairing function, we need only to know its “<a href="Interface_(computer_science)" title="wikilink">interface</a>”: let 

<math display="inline" id="Gödel_numbering_for_sequences:6">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

, <em>K</em>, <em>L</em> denote the pairing function and its two <a href="Projection_(mathematics)" title="wikilink">projection</a> functions, respectively, satisying <a class="uri" href="specification" title="wikilink">specification</a></p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo>(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>π</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\left(\pi\left(x,y\right)\right)=x
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo>(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <times></times>
      <ci>π</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\left(\pi\left(x,y\right)\right)=y
  </annotation>
 </semantics>
</math>

 we shall not discuss and formalize the axiom for excluding alien objects here, it is now not so important.</p>
<h4 id="remainder-for-natural-numbers">Remainder for natural numbers</h4>

<p>We shall use another auxiliary function: it will compute the <a href="Remainder#The_remainder_for_natural_numbers" title="wikilink">remainder for natural numbers</a>. Examples:</p>
<ul>
<li>

<math display="inline" id="Gödel_numbering_for_sequences:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>rem</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>5</mn>
     <mo>,</mo>
     <mn>3</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>rem</ci>
     <interval closure="open">
      <cn type="integer">5</cn>
      <cn type="integer">3</cn>
     </interval>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{rem}(5,3)=2
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Gödel_numbering_for_sequences:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>rem</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>7</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>rem</ci>
     <interval closure="open">
      <cn type="integer">7</cn>
      <cn type="integer">2</cn>
     </interval>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{rem}(7,2)=1
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>It can be proven that this function can be "implemented" as a recursive function.</p>
<h4 id="using-the-chinese-remainder-theorem">Using the Chinese remainder theorem</h4>
<h5 id="implementation-of-the-β-function">Implementation of the β function</h5>

<p>Using the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a>, we can prove that implementing 

<math display="inline" id="Gödel_numbering_for_sequences:11">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>rem</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo>(</mo>
       <mi>s</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mi>i</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mo>⋅</mo>
        <mi>L</mi>
       </mrow>
       <mrow>
        <mo>(</mo>
        <mi>s</mi>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>β</ci>
     <interval closure="open">
      <ci>s</ci>
      <ci>i</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>rem</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>K</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>L</ci>
        </apply>
        <ci>s</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta(s,i)=\mathrm{rem}\left(K\left(s\right),\left(i+1\right)\cdot L\left(s%
\right)+1\right)
  </annotation>
 </semantics>
</math>

 will work, according to the specification we expect 

<math display="inline" id="Gödel_numbering_for_sequences:13">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>


 to satisfy. We can use a more concise form by an <a href="abuse_of_notation" title="wikilink">abuse of notation</a> (sort of <a href="pattern_matching" title="wikilink">pattern matching</a>):</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>,</mo>
       <mi>m</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>i</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>rem</mi>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mi>i</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mo>⋅</mo>
       <mi>m</mi>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>β</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>π</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>m</ci>
       </interval>
      </apply>
      <ci>i</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>rem</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>m</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\left(\pi\left(x_{0},m\right),i\right)=\mathrm{rem}\left(x_{0},\left(i+1%
\right)\cdot m+1\right)
  </annotation>
 </semantics>
</math>

 Let us achieve even more readability by more <a href="Modularity_(programming)" title="wikilink">modularity</a> and <a href="Code_reuse" title="wikilink">reuse</a> (as these notions are used in computer science<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a>): defining 

<math display="block" id="Gödel_numbering_for_sequences:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>,</mo>
       <mi>m</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>i</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>rem</mi>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>β</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>π</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>m</ci>
       </interval>
      </apply>
      <ci>i</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>rem</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\left(\pi\left(x_{0},m\right),i\right)=\mathrm{rem}\left(x_{0},m_{i}\right)
  </annotation>
 </semantics>
</math>

, enables us to write</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:16">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}
  </annotation>
 </semantics>
</math>

 We shall use this 

<math display="inline" id="Gödel_numbering_for_sequences:17">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 notation also in the proof.</p>
<h5 id="hand-tuned-assumptions">Hand-tuned assumptions</h5>

<p>For proving the correctness of the above definition of 

<math display="inline" id="Gödel_numbering_for_sequences:18">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{0},\dots a_{n-1}
  </annotation>
 </semantics>
</math>


 function, we shall use (and prove) several auxiliary theorems, lemmas. These have their own assumptions. Now we try to find out these assumptions, calibrating and tuning their strength carefully: they should not be said in an either superfluously sharp, or unsatisfactorily weak form.</p>

<p>Let 

<math display="block" id="Gödel_numbering_for_sequences:19">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>i</mi>
   <mo>∈</mo>
   <mover accent="true">
    <mi>n</mi>
    <mo>¯</mo>
   </mover>
   <mo>∖</mo>
   <mrow>
    <mo>{</mo>
    <mn>0</mn>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mo>(</mo>
    <mi>i</mi>
    <mo>∣</mo>
    <mi>m</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <in></in>
    <apply>
     <ci>normal-¯</ci>
     <ci>n</ci>
    </apply>
    <setdiff></setdiff>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cn type="integer">0</cn>
     <ci>normal-}</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i\in\overline{n}\setminus\left\{0\right\}\left(i\mid m\right)
  </annotation>
 </semantics>
</math>

 be a sequence of natural numbers. Let <em>m</em> be chosen to satisfy</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:20">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>i</mi>
   <mo><</mo>
   <mi>n</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo><</mo>
    <msub>
     <mi>m</mi>
     <mi>i</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <lt></lt>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <lt></lt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i<n\left(a_{i}<m_{i}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:21">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi>m</mi>
      <mo>∧</mo>
      <mi mathvariant="normal">…</mi>
      <mo>∧</mo>
      <mi>n</mi>
     </mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>∣</mo>
   </mrow>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="latexml">delimited-∣∣</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <and></and>
       <ci>m</ci>
       <ci>normal-…</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\mid m\land\dots\land n-1\mid m
  </annotation>
 </semantics>
</math>

 The first assumption is meant as</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:22">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 It is needed to meet an assumption of the Chinese remainder theorem (that of being pairwise <a class="uri" href="coprime" title="wikilink">coprime</a>). In the literature, sometimes this requirement is replaced with a stronger one, e.g. <a href="Constructive_proof" title="wikilink">constructively</a> built with the <a class="uri" href="factorial" title="wikilink">factorial</a> function,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> but the proof uses just as much strength as formulated here.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The second assumption does not concern the Chinese remainder theorem in any way. It will have importance in proving that the specification for 

<math display="inline" id="Gödel_numbering_for_sequences:23">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{x}
  </annotation>
 </semantics>
</math>


 is met eventually. It ensures that an 

<math display="block" id="Gödel_numbering_for_sequences:24">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≡</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msub>
       <mi>m</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\equiv a_{i}\;\;(\mathop{{\rm mod}}m_{i})
  </annotation>
 </semantics>
</math>

 solution of the simultaneous congruence system</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:25">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>rem</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>rem</ci>
     <interval closure="open">
      <apply>
       <ci>normal-~</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}=\mathrm{rem}(\tilde{x},m_{i})
  </annotation>
 </semantics>
</math>

 for each <em>i</em> ranging 0,… , n-1 also satisfies</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:26">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>i</mi>
   <mo><</mo>
   <mpadded width="+2.8pt">
    <mi>n</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo><</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <lt></lt>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <lt></lt>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i<n\;(a_{i}<m)
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> A stronger assumption for <em>m</em> requiring 

<math display="inline" id="Gödel_numbering_for_sequences:27">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}
  </annotation>
 </semantics>
</math>

 automatically satisfies it (if we define the notation 

<math display="block" id="Gödel_numbering_for_sequences:28">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>i</mi>
   <mo>∈</mo>
   <mover accent="true">
    <mi>n</mi>
    <mo>¯</mo>
   </mover>
   <mo>∖</mo>
   <mrow>
    <mo>{</mo>
    <mn>0</mn>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mo>(</mo>
    <mi>i</mi>
    <mo>∣</mo>
    <mi>m</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <in></in>
    <apply>
     <ci>normal-¯</ci>
     <ci>n</ci>
    </apply>
    <setdiff></setdiff>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cn type="integer">0</cn>
     <ci>normal-}</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i\in\overline{n}\setminus\left\{0\right\}\left(i\mid m\right)
  </annotation>
 </semantics>
</math>

 as above).</p>
<h3 id="proof-that-coprimality-assumption-for-chinese-remainder-theorem-is-met">Proof that (coprimality) assumption for Chinese remainder theorem is met</h3>

<p>We shall prove that the (coprimality) assumption for Chinese remainder theorem is met.</p>

<p>As mentioned in section <a href="#Hand-tuned_assumptions" title="wikilink">Hand-tuned assumptions</a>, we prescribed that</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:29">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∣</mo>
   <msub>
    <mi>m</mi>
    <mi>i</mi>
   </msub>
   <mo>-</mo>
   <msub>
    <mi>m</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>i</ci>
    </apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>j</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mid m_{i}-m_{j}
  </annotation>
 </semantics>
</math>

 thus we can use it.</p>

<p>What we want to prove is that we can produce a sequence of pairwise <a class="uri" href="coprime" title="wikilink">coprime</a> numbers in a way that will turn out to correspond to the <a href="#Implementation_of_the_β_function" title="wikilink">Implementation of the β function</a> in a sense.</p>

<p>In details:</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:30">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k}
  </annotation>
 </semantics>
</math>

.</p>

<p>Let us use <a href="reductio_ad_absurdum" title="wikilink">reductio ad absurdum</a>!</p>

<p>Negation of the original statement:</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:31">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mi>i</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>m</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mi>j</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}-m_{j}=(i-j)\cdot m
  </annotation>
 </semantics>
</math>

 allows us to say also</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:32">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∣</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>-</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-∣</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <minus></minus>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mid(i-j)\cdot m
  </annotation>
 </semantics>
</math>

</p>

<p>Substituting the <a href="Definition" title="wikilink">definens</a> of 

<math display="block" id="Gödel_numbering_for_sequences:33">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mi>j</mi>
     </mrow>
     <mo>∨</mo>
     <mi>p</mi>
    </mrow>
    <mo>∣</mo>
   </mrow>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="latexml">delimited-∣∣</csymbol>
     <apply>
      <or></or>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mid i-j\lor p\mid m
  </annotation>
 </semantics>
</math>

-sequence notation, we get 

<math display="block" id="Gödel_numbering_for_sequences:34">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>i</mi>
   <mo>∈</mo>
   <mover accent="true">
    <mi>n</mi>
    <mo>¯</mo>
   </mover>
   <mo>∖</mo>
   <mrow>
    <mo>{</mo>
    <mn>0</mn>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mo>(</mo>
    <mi>i</mi>
    <mo>∣</mo>
    <mi>m</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <in></in>
    <apply>
     <ci>normal-¯</ci>
     <ci>n</ci>
    </apply>
    <setdiff></setdiff>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cn type="integer">0</cn>
     <ci>normal-}</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i\in\overline{n}\setminus\left\{0\right\}\left(i\mid m\right)
  </annotation>
 </semantics>
</math>

, thus (as <a href="Equality_(mathematics)" title="wikilink">equality</a> axioms postulate identity to be a <a href="congruence_relation" title="wikilink">congruence relation</a> <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a>) we get</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:35">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>-</mo>
   <mi>j</mi>
   <mo>∣</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <minus></minus>
    <csymbol cd="unknown">j</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i-j\mid m
  </annotation>
 </semantics>
</math>

 Using that <em>p</em> is a <a href="prime_element" title="wikilink">prime element</a> (note: not the <a href="irreducible_element" title="wikilink">irreducible element</a> property is used!), we get</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:36">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>A</mi>
    <mo>∧</mo>
    <mrow>
     <mo>(</mo>
     <mi>A</mi>
     <mo>→</mo>
     <mi>B</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">B</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(A\land\left(A\rightarrow B\right)\right)\rightarrow B
  </annotation>
 </semantics>
</math>

</p>
<h4 id="resorting-to-the-first-hand-tuned-assumption">Resorting to the first hand-tuned assumption</h4>

<p>Now this is the point in the proof where we must resort to our assumption</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:37">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>-</mo>
   <mi>j</mi>
   <mo>∣</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <minus></minus>
    <csymbol cd="unknown">j</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i-j\mid m
  </annotation>
 </semantics>
</math>

 let us remember, we have planned this assumption calibrated carefully to be as weak as possible, but strong enough to enable us to use it now.</p>

<p>The assumed negation of the original statement (let us remember, we use reductio ad absurdum) contains an appropriate existential statement using indices 

<math display="inline" id="Gödel_numbering_for_sequences:38">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∣</mo>
   <mi>i</mi>
   <mo>-</mo>
   <mi>j</mi>
   <mo>→</mo>
   <mi>p</mi>
   <mo>∣</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">i</csymbol>
    <minus></minus>
    <csymbol cd="unknown">j</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mid i-j\rightarrow p\mid m
  </annotation>
 </semantics>
</math>


, thus the mentioned assumption can be applied, so 

<math display="block" id="Gödel_numbering_for_sequences:39">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∣</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mid m
  </annotation>
 </semantics>
</math>

 holds.</p>
<h4 id="using-an-object-theorem-of-the-propositional-calculus-as-a-lemma">Using an (object) theorem of the propositional calculus as a lemma</h4>

<p>We can prove by several means <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> known in <a href="propositional_calculus" title="wikilink">propositional calculus</a>, that</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:40">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∣</mo>
   <msub>
    <mi>m</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>i</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mid m_{i}
  </annotation>
 </semantics>
</math>

 holds.</p>

<p>Because 

<math display="block" id="Gödel_numbering_for_sequences:41">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∣</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mid m
  </annotation>
 </semantics>
</math>

 entails (by the <a href="Transitive_relation" title="wikilink">transitivity</a> property of the <a href="Divisor" title="wikilink">divisibility</a> relation) that 

<math display="block" id="Gödel_numbering_for_sequences:42">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∣</mo>
   <msub>
    <mi>m</mi>
    <mi>i</mi>
   </msub>
   <mo>-</mo>
   <mrow>
    <mo>(</mo>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo>)</mo>
   </mrow>
   <mo>⋅</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>i</ci>
    </apply>
    <minus></minus>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mid m_{i}-\left(i+1\right)\cdot m
  </annotation>
 </semantics>
</math>

, thus (as equality axioms postulate identity to be a congruence relation <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a>)</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:43">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}
  </annotation>
 </semantics>
</math>


 can be proven.</p>
<h4 id="reaching-the-contradiction">Reaching the contradiction</h4>

<p>The negation of original statement contained</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:44">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mi>i</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mo>⋅</mo>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}-\left(i+1\right)\cdot m=1
  </annotation>
 </semantics>
</math>

 and we have just proved</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:45">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∣</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-∣</ci>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mid 1
  </annotation>
 </semantics>
</math>

 thus also</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:46">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>p</mi>
   </mrow>
   <mo>∈</mo>
   <mi>Prime</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <exists></exists>
     <ci>p</ci>
    </apply>
    <ci>Prime</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists p\in\mathrm{Prime}
  </annotation>
 </semantics>
</math>

 should hold. But, after substituting the <a href="Definition" title="wikilink">definiens</a> for 

<math display="inline" id="Gödel_numbering_for_sequences:47">
 <semantics>
  <mi mathvariant="normal">⋮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdots
  </annotation>
 </semantics>
</math>

, we shall see</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:48">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≡</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msub>
       <mi>m</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\equiv a_{n-1}\;\;(\mathop{{\rm mod}}m_{n-1})
  </annotation>
 </semantics>
</math>


 Thus, summarizing the above three statements, by <a href="Transitive_relation" title="wikilink">transitivity</a> of the <a href="Equality_(mathematics)" title="wikilink">equality</a>, also</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:49">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>i</mi>
   <mo><</mo>
   <mpadded width="+2.8pt">
    <mi>n</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>≡</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msub>
       <mi>m</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <lt></lt>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <equivalent></equivalent>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i<n\;\left(x\equiv a_{i}\;\;(\mathop{{\rm mod}}m_{i})\right)
  </annotation>
 </semantics>
</math>

 should hold. But let us look up the quantification of <em>p</em> in the negation of the original statement: <em>p</em> is <a href="Existential_quantifier" title="wikilink">existentially quantified</a> and restricted to primes 

<math display="inline" id="Gödel_numbering_for_sequences:50">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>i</mi>
   </mrow>
   <mo><</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <mi>n</mi>
    </mpadded>
    <mrow>
     <mo>(</mo>
     <mi mathvariant="normal">…</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i<n\;\left(\dots\right)
  </annotation>
 </semantics>
</math>

</p>

<p>The above statement together with the above quantification of <em>p</em> establish the contradiction we wanted to reach.</p>
<h4 id="end-of-reductio-ad-absurdum">End of reductio ad absurdum</h4>

<p>By reaching contradiction with its negation, we have just proven the original statement:</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:51">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>i</mi>
   </mrow>
   <mo><</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <mi>n</mi>
    </mpadded>
    <mrow>
     <mo>(</mo>
     <mi mathvariant="normal">…</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i<n\;\left(\dots\right)
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="block" id="Gödel_numbering_for_sequences:52">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>i</mi>
   <mo><</mo>
   <mi>n</mi>
   <mo stretchy="false">(</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <lt></lt>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-(</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i<n(
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>

<math display="inline" id="Gödel_numbering_for_sequences:53">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>



</dd>
</dl>

<p>We can write it in a more concise way:</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:54">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>m</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{0},\dots m_{n-1}
  </annotation>
 </semantics>
</math>

</p>

<p>In the followings, many statements will be said, all beginning with 

<math display="inline" id="Gödel_numbering_for_sequences:55">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

. To achieve a more ergonomic treatment, from now on all statements will be regarded in the scope of an 

<math display="block" id="Gödel_numbering_for_sequences:56">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>≡</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msub>
       <mi>m</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}\equiv a_{i}\;\;(\mathop{{\rm mod}}m_{i})
  </annotation>
 </semantics>
</math>

 quantification. Thus

<math display="block" id="Gödel_numbering_for_sequences:57">
 <semantics>
  <mrow>
   <mrow>
    <mi>rem</mi>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>rem</mi>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>rem</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>rem</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{rem}\left(x_{0},m_{i}\right)=\mathrm{rem}\left(a_{i},m_{i}\right)
  </annotation>
 </semantics>
</math>

 begins!</p>

<p>Let us chose a solution 

<math display="inline" id="Gödel_numbering_for_sequences:58">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>i</mi>
   <mo><</mo>
   <mpadded width="+2.8pt">
    <mi>n</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo><</mo>
    <msub>
     <mi>m</mi>
     <mi>i</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <lt></lt>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <lt></lt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i<n\;\left(a_{i}<m_{i}\right)
  </annotation>
 </semantics>
</math>


 for the system of simultaneous congruences. At least one solution must exist, because 

<math display="inline" id="Gödel_numbering_for_sequences:59">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo><</mo>
   <msub>
    <mi>m</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}<m_{i}
  </annotation>
 </semantics>
</math>

 are pairwise comprime (that's what we have been proving so long in the previous sections!), thus we can refer to the Chinese remainder theorem's ensuring solution. Thus, from now on, we can regard 

<math display="block" id="Gödel_numbering_for_sequences:60">
 <semantics>
  <mrow>
   <mrow>
    <mi>rem</mi>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>rem</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{rem}\left(a_{i},m_{i}\right)=a_{i}
  </annotation>
 </semantics>
</math>

 satisfying</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>rem</mi>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>rem</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{rem}\left(x_{0},m_{i}\right)=a_{i}
  </annotation>
 </semantics>
</math>

 it means (by definition of <a href="modular_arithmetic" title="wikilink">modular arithmetic</a>) that</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>,</mo>
       <mi>m</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>i</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>rem</mi>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>β</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>π</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>m</ci>
       </interval>
      </apply>
      <ci>i</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>rem</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\left(\pi\left(x_{0},m\right),i\right)=\mathrm{rem}\left(x_{0},m_{i}\right)
  </annotation>
 </semantics>
</math>

</p>
<h4 id="resorting-to-the-second-hand-tuned-assumption">Resorting to the second hand-tuned assumption</h4>

<p>Again, we must resort to the assumptions whose strength we specifically “tuned” for using in the proof. But now, it is the second assumption (which does not concern the Chinese remainder theorem in any way) that we need: “

<math display="inline" id="Gödel_numbering_for_sequences:63">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>


”. Let us remember: we are now in the scope of a “big” quantification for <em>i</em>, thus we don't repeat its quantification for each statement.</p>

<p>The second hand-tuned assumption 

<math display="inline" id="Gödel_numbering_for_sequences:64">
 <semantics>
  <mrow>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>,</mo>
       <mi>m</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>i</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>β</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>π</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>m</ci>
       </interval>
      </apply>
      <ci>i</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\left(\pi\left(x_{0},m\right),i\right)=a_{i}
  </annotation>
 </semantics>
</math>

 will join in at this point, because it entails that</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:65">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 Now by <a href="Transitive_relation" title="wikilink">transitivity</a> of <a href="Equality_(mathematics)" title="wikilink">equality</a> we get</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:66">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mpadded width="+2.8pt">
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mpadded>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mi>s</mi>
       </mpadded>
       <mrow>
        <mo>∀</mo>
        <mi>i</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <mi>n</mi>
    </mpadded>
    <mi>β</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <ci>s</ci>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </list>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>β</ci>
      <interval closure="open">
       <ci>s</ci>
       <ci>i</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a_{0},\dots,a_{n-1}\;\exists s\;\forall i<n\;\beta(s,i)=a_{i}
  </annotation>
 </semantics>
</math>

</p>
<h4 id="qed">QED</h4>

<p>Our original goal was to prove that the definition</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:67">
 <semantics>
  <mrow>
   <mo>⟨</mo>
   <msub>
    <mi>a</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\langle a_{0},\dots,a_{n-1}\right\rangle
  </annotation>
 </semantics>
</math>

 is good for achieving what we declared in the specification of 

<math display="inline" id="Gödel_numbering_for_sequences:68">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>


: we want 

<math display="block" id="Gödel_numbering_for_sequences:69">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mpadded width="+2.8pt">
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mpadded>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mi>s</mi>
       </mpadded>
       <mrow>
        <mo>∀</mo>
        <mi>i</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <mi>n</mi>
    </mpadded>
    <mi>β</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <ci>s</ci>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </list>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>β</ci>
      <interval closure="open">
       <ci>s</ci>
       <ci>i</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a_{0},\dots,a_{n-1}\;\exists s\;\forall i<n\;\beta(s,i)=a_{i}
  </annotation>
 </semantics>
</math>

 to hold.</p>

<p>That's it, it can be seen now by <a href="Transitive_relation" title="wikilink">transitivity</a> of <a href="Equality_(mathematics)" title="wikilink">equality</a>, looking at the above three equations.</p>

<p>Scope of <em>i</em> ends here.</p>
<h3 id="existence-and-uniqueness">Existence and uniqueness</h3>

<p>We have just proven the correctness of the definition of 

<math display="block" id="Gödel_numbering_for_sequences:70">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℕ</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℕ</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{N}^{n+1}\to\mathbb{N}
  </annotation>
 </semantics>
</math>

: its specification requiring</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:71">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi>s</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mpadded width="+2.8pt">
         <mi>if</mi>
        </mpadded>
        <mo>∀</mo>
        <mi>i</mi>
        <mo><</mo>
        <mpadded width="+2.8pt">
         <mi>n</mi>
        </mpadded>
        <mrow>
         <mo>(</mo>
         <mi>β</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>s</mi>
          <mo>,</mo>
          <mi>i</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>=</mo>
         <msub>
          <mi>a</mi>
          <mi>i</mi>
         </msub>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mpadded width="+2.8pt">
         <mi>if</mi>
        </mpadded>
        <mo>∃</mo>
        <mi>i</mi>
        <mo><</mo>
        <mpadded width="+2.8pt">
         <mi>n</mi>
        </mpadded>
        <mrow>
         <mo>(</mo>
         <mi>β</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>s</mi>
          <mo>,</mo>
          <mi>i</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>≠</mo>
         <msub>
          <mi>a</mi>
          <mi>i</mi>
         </msub>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>s</ci>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">0</cn>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">if</csymbol>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">i</csymbol>
      <lt></lt>
      <csymbol cd="unknown">n</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">β</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">s</csymbol>
        <ci>normal-,</ci>
        <csymbol cd="unknown">i</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cn type="integer">1</cn>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">if</csymbol>
      <exists></exists>
      <csymbol cd="unknown">i</csymbol>
      <lt></lt>
      <csymbol cd="unknown">n</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">β</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">s</csymbol>
        <ci>normal-,</ci>
        <csymbol cd="unknown">i</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <neq></neq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\left(a_{0},\dots,a_{n-1},s\right)=\begin{cases}0&\mathrm{if}\;\forall i<n\;%
\left(\beta(s,i)=a_{i}\right)\\
1&\mathrm{if}\;\exists i<n\;\left(\beta(s,i)\neq a_{i}\right)\end{cases}
  </annotation>
 </semantics>
</math>

 is met. Although proving this was the most important, if we want to establish an encoding scheme for sequences, but we have to fill in some gaps yet. These are related notions similar to <a href="Existential_quantification" title="wikilink">existence</a> and <a href="Uniqueness_quantification" title="wikilink">uniqueness</a> (although on uniqueness, “at most one” should be meant here, and the conjunction of both is delayed as a final result).</p>
<h4 id="uniqueness-of-encoding-achieved-by-minimalization">Uniqueness of encoding, achieved by minimalization</h4>

<p>Because let us remember, our ultimate question is: what number should stand for the encoding of sequence 

<math display="block" id="Gödel_numbering_for_sequences:72">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>s</mi>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
   <mo>↔</mo>
   <mo>∀</mo>
   <mi>i</mi>
   <mo><</mo>
   <mpadded width="+2.8pt">
    <mi>n</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mi>β</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">0</cn>
    <ci>normal-↔</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <lt></lt>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">β</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">i</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\left(a_{0},\dots,a_{n-1},s\right)=0\leftrightarrow\forall i<n\;\left(\beta(s%
,i)=a_{i}\right)
  </annotation>
 </semantics>
</math>

? The specification declares only an existential quantification, not yet a functional connection. We want a <a href="Constructive_proof" title="wikilink">constructive</a> and algorithmic way, even more, a (total) recursive function for the encoding.</p>
<h4 id="totality-because-minimalization-is-restricted-to-special-functions">Totality, because minimalization is restricted to special functions</h4>

<p>This gap can be filled in in a straightforward way: we shall use <a href="Mu_operator" title="wikilink">minimalization</a>, and the totality of the resulting function is ensured by everything we have proven till now (i.e. the correctness of the definition of 

<math display="block" id="Gödel_numbering_for_sequences:73">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>a</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mpadded width="+2.8pt">
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mpadded>
   <mo>∃</mo>
   <mpadded width="+2.8pt">
    <mi>s</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mi>f</mi>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi>s</mi>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <exists></exists>
    <csymbol cd="unknown">s</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-…</ci>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a_{0},\dots,a_{n-1}\;\exists s\;\left(f\left(a_{0},\dots,a_{n-1},s%
\right)=0\right)
  </annotation>
 </semantics>
</math>

 by meeting its specification). In fact, the specification</p>

<p>

<math display="inline" id="Gödel_numbering_for_sequences:74">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 plays a role here of a more general notion (“special function”<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a>). The importance of this notion is that it enables us to split off the (sub)class of (total) recursive functions from the (super)class of partial recursive functions. In brief, the specification says exactly: a function <em>f</em> <ref>E.g. defined by</ref></p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:75">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℕ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℕ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:\mathbb{N}^{n}\to\mathbb{N}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:76">
 <semantics>
  <mrow>
   <mrow>
    <mo>⟨</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>⟩</mo>
   </mrow>
   <mo>⟼</mo>
   <mi>μ</mi>
   <mi>a</mi>
   <mo>.</mo>
   <mrow>
    <mo>[</mo>
    <mo>∀</mo>
    <mi>i</mi>
    <mo><</mo>
    <mpadded width="+2.8pt">
     <mi>n</mi>
    </mpadded>
    <mrow>
     <mo>(</mo>
     <mi>β</mi>
     <mrow>
      <mo>(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>i</mi>
      <mo>)</mo>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo>)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⟩</ci>
    </cerror>
    <ci>normal-⟼</ci>
    <csymbol cd="unknown">μ</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <lt></lt>
     <csymbol cd="unknown">n</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">β</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">i</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\langle a_{0},\dots,a_{n-1}\right\rangle\longmapsto\mu a.\left[\forall i<%
n\;\left(\beta\left(a,i\right)=a_{i}\right)\right]
  </annotation>
 </semantics>
</math>

  satisfying specification</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:77">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℕ</mi>
     <mo>*</mo>
    </msup>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℕ</ci>
      <times></times>
     </apply>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:\mathbb{N}^{*}\to\mathbb{N}
  </annotation>
 </semantics>
</math>

 is a special function, i.e. for each fixed combination of all-but-last arguments, the function <em>f</em> has <a href="root_of_a_function" title="wikilink">root</a> in its last argument:</p>

<p>

<math display="block" id="Gödel_numbering_for_sequences:78">
 <semantics>
  <mrow>
   <mrow>
    <mo>⟨</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo>⟩</mo>
   </mrow>
   <mo>⟼</mo>
   <mi>μ</mi>
   <mi>a</mi>
   <mo>.</mo>
   <mrow>
    <mo>[</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>=</mo>
    <mi>n</mi>
    <mo>∧</mo>
    <mo>∀</mo>
    <mi>i</mi>
    <mo><</mo>
    <mpadded width="+2.8pt">
     <mi>n</mi>
    </mpadded>
    <mrow>
     <mo>(</mo>
     <mi>β</mi>
     <mrow>
      <mo>(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo>)</mo>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo>)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-⟩</ci>
    </cerror>
    <ci>normal-⟼</ci>
    <csymbol cd="unknown">μ</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">n</csymbol>
     <and></and>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <lt></lt>
     <csymbol cd="unknown">n</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">β</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">i</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\langle a_{0},\dots,a_{n-1},a_{n}\right\rangle\longmapsto\mu a.\left[a_{0%
}=n\land\forall i<n\;\left(\beta\left(a,i+1\right)=a_{i}\right)\right]
  </annotation>
 </semantics>
</math>

</p>
<h4 id="the-gödel-numbering-function-g-can-be-chosen-to-be-total-recursive">The Gödel numbering function g can be chosen to be total recursive</h4>

<p>Thus, let us choose the minimal possible number that fits well in the specification of the 

<math display="block" id="Gödel_numbering_for_sequences:79">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≡</mo>
   <mrow>
    <mi>n</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msub>
       <mi>m</mi>
       <mn>0</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>n</ci>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\equiv n\;\;(\mathop{{\rm mod}}m_{0})
  </annotation>
 </semantics>
</math>

 function:<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p><span class="LaTeX">$$g : \mathbb N^n \to \mathbb N$$</span></p>

<p><span class="LaTeX">$$\left\langle a_0,\dots,a_{n-1}\right\rangle \longmapsto \mu a . \left[ \forall i &lt; n \; \left(\beta\left(a,i\right) = a_i\right)\right]$$</span> and it can be proven (using the notions of the previous section ) that <em>g</em> is (total) recursive.</p>
<h3 id="access-of-length">Access of length</h3>

<p>If we use the above scheme for encoding sequences only in contexts where the length of the sequences is fixed, then no problem arises. In other words, we can use them in an <a href="Analogy" title="wikilink">analogous</a> way as arrays are used in programming.</p>

<p>But sometimes we need dynamically stretching sequences, or we need to deal with sequences whose length cannot be <a href="Typeful_programming" title="wikilink">typed</a> in a static way. In other words, we may encode sequences in an analogous way as we use <a href="List_(computing)" title="wikilink">lists</a> in programming.</p>

<p>An example for both cases: if we make the Gödel numbering of a Turing machine, then the each row in matrix of the “program” can be represented with tuples, sequences of fixed length (thus, without storing the length), because the number of the columns is fixed.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> But if we want to reason about configuration-like things (of Turing-machines), and specially, we want to encode the significant part of the tape of a running Turing machine, then we have to represent sequences together with their length. Moreover, we can mimic dynamically stretching sequences by representing sequence concatenation (or at least, augmenting a sequence with one more element) with a [totally] recursive function.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Length can be stored simply as a surplus member:<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p><span class="LaTeX">$$g : \mathbb N^* \to \mathbb N$$</span></p>

<p><span class="LaTeX">$$\left\langle a_0,\dots,a_{n-1}, a_n\right\rangle \longmapsto \mu a . \left[ a_0 = n \land \forall i &lt; n \; \left(\beta\left(a,i+1\right) = a_i\right)\right]$$</span></p>

<p>The corresponding modification of the proof is straightforward, by adding a surplus</p>

<p><span class="LaTeX">$$x \equiv n \pmod{m_0}$$</span> to the system of simultaneous congruences (provided that the surplus member index is chosen to be 0). Also the assumptions etc. have to be modified accordingly.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>

<p>Each chapter is downloadable verbatim on <a href="http://www.renyi.hu/~csirmaz/">author's page</a>.</p></li>
<li>

<p></p></li>
<li></li>
<li></li>
<li>

<p>Translation of <a href="#Smu92" title="wikilink">Smullyan 1992</a>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#Mon76" title="wikilink">Monk 1976</a>: 56–58<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#Csir94" title="wikilink">Csirmaz 1994</a>: 99–100 (see <a href="http://www.renyi.hu/~csirmaz/l10.ps.gz">online</a>)<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#Mon76" title="wikilink">Monk 1976</a>: 72–74<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#Mon76" title="wikilink">Monk 1976</a>: 52–55<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#Smu03" title="wikilink">Smullyan 2003</a>: 56 (= Chpt IV, § 5, note 1)<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#Mon76" title="wikilink">Monk 1976</a>: 58 (= Thm 3.46)<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#Hugh89" title="wikilink">Hughes 1989</a> (see <a href="http://www.math.chalmers.se/~rjmh/Papers/whyfp.html">online</a>)<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"><a href="#Csir94" title="wikilink">Csirmaz 1994</a>: 100 (see <a href="http://www.renyi.hu/~csirmaz/l10.ps.gz">online</a>)<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#Bur98" title="wikilink">Burris 1998</a>: Supplementary Text, <a href="http://www.math.uwaterloo.ca/~snburris/htdocs/scav/fo_arith/fo_arith.html">Arithmetic I</a>, Lemma 4<a href="#fnref12">↩</a></li>
<li id="fn13">see also related notions, e.g. “equals for equals” (<a href="Referential_transparency_(computer_science)" title="wikilink">referential transparency</a>), and another related notion Leibniz's law / <a href="identity_of_indiscernibles" title="wikilink">identity of indiscernibles</a><a href="#fnref13">↩</a></li>
<li id="fn14">either proof theoretic (algebraic steps); or semantic (<a href="truth_table" title="wikilink">truth table</a>, <a href="method_of_analytic_tableaux" title="wikilink">method of analytic tableaux</a>, <a href="Venn_diagram" title="wikilink">Venn diagram</a>, <a href="Karnaugh_map" title="wikilink">Veitch diagram / Karnaugh map</a>)<a href="#fnref14">↩</a></li>
<li id="fn15">see also related notions Referential transparency, and also a dual notion Leibniz's law / <a href="identity_of_indiscernibles" title="wikilink">identity of indiscernibles</a><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#Mon76" title="wikilink">Monk 1976</a>: 45 (= Def 3.1.)<a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18"><a href="#Mon76" title="wikilink">Monk 1976</a>: 53 (= Def 3.20, Lem 3.21)<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#Csir94" title="wikilink">Csirmaz 1994</a>: 101 (=Thm 10.7, Conseq 10.8), see <a href="http://www.renyi.hu/~csirmaz/l10.ps.gz">online</a><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
</ol>
</section>
</body>
</html>
