<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1857">Monadic predicate calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Monadic predicate calculus</h1>
<hr/>

<p>In <a class="uri" href="logic" title="wikilink">logic</a>, the <strong>monadic predicate calculus</strong> (also called <strong>monadic first-order logic</strong>) is the fragment of <a href="first-order_logic" title="wikilink">first-order logic</a> in which all relation symbols in the <a href="signature_(mathematical_logic)" title="wikilink">signature</a> are <a href="monadic_(arity)" title="wikilink">monadic</a> (that is, they take only one argument), and there are no function symbols. All <a href="atomic_formula" title="wikilink">atomic formulas</a> are thus of the form 

<math display="inline" id="Monadic_predicate_calculus:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Monadic_predicate_calculus:1">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is a relation symbol and 

<math display="inline" id="Monadic_predicate_calculus:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is a <a href="Variable_(mathematics)" title="wikilink">variable</a>.</p>

<p>Monadic predicate calculus can be contrasted with polyadic predicate calculus, which allows relation symbols that take two or more arguments.</p>
<h2 id="expressiveness">Expressiveness</h2>

<p>The absence of polyadic relation symbols severely restricts what can be expressed in the monadic predicate calculus. It is so weak that, unlike the full predicate calculus, it is <a href="decidability_(logic)" title="wikilink">decidable</a> - there is a <a href="decision_problem" title="wikilink">decision procedure</a> that determines whether a given formula of monadic predicate calculus is <a href="logical_validity" title="wikilink">logically valid</a> (true for all nonempty <a href="Domain_of_discourse" title="wikilink">domains</a>).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Adding a single binary relation symbol to monadic logic, however, results in an undecidable logic.</p>
<h2 id="relationship-with-term-logic">Relationship with term logic</h2>

<p>The need to go beyond monadic logic was not appreciated until the work on the logic of <a href="Relation_(mathematics)" title="wikilink">relations</a>, by <a href="Augustus_DeMorgan" title="wikilink">Augustus DeMorgan</a> and <a href="Charles_Sanders_Peirce" title="wikilink">Charles Sanders Peirce</a> in the nineteenth century, and by <a class="uri" href="Frege" title="wikilink">Frege</a> in his 1879 <em>Begriffsschrifft</em>. Prior to the work of these three men, <a href="term_logic" title="wikilink">term logic</a> (syllogistic logic) was widely considered adequate for formal deductive reasoning.</p>

<p>Inferences in term logic can all be represented in the monadic predicate calculus. For example the <a class="uri" href="syllogism" title="wikilink">syllogism</a></p>
<dl>
<dd>All dogs are mammals.
</dd>
<dd>No mammal is a bird.
</dd>
<dd>Thus, no dog is a bird.
</dd>
</dl>

<p>can be notated in the language of monadic predicate calculus as</p>

<p>

<math display="block" id="Monadic_predicate_calculus:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⇒</mo>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mpadded width="+1.7pt">
     <mi>y</mi>
    </mpadded>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇒</mo>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mpadded width="+1.7pt">
     <mi>z</mi>
    </mpadded>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">D</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">M</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">M</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">B</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇒</ci>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">z</csymbol>
     <csymbol cd="unknown">D</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">B</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x\,D(x)\Rightarrow M(x))\land\neg(\exists y\,M(y)\land B(y))%
\Rightarrow\neg(\exists z\,D(z)\land B(z))
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Monadic_predicate_calculus:4">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Monadic_predicate_calculus:5">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monadic_predicate_calculus:6">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 denote the predicates of being, respectively, a dog, a mammal, and a bird.</p>

<p>Conversely, monadic predicate calculus is not significantly more expressive than term logic. Each formula in the monadic predicate calculus is <a href="logical_equivalence" title="wikilink">equivalent</a> to a formula in which <a href="Quantifier_(logic)" title="wikilink">quantifiers</a> appear only in closed subformulas of the form</p>

<p>

<math display="block" id="Monadic_predicate_calculus:7">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
     <msub>
      <mi>P</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>∨</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>∨</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <msubsup>
     <mi>P</mi>
     <mn>1</mn>
     <mo>′</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∨</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>∨</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <msubsup>
     <mi>P</mi>
     <mi>m</mi>
     <mo>′</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <ci>normal-′</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <not></not>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>m</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\,P_{1}(x)\lor\cdots\lor P_{n}(x)\lor\neg P^{\prime}_{1}(x)\lor\cdots%
\lor\neg P^{\prime}_{m}(x)
  </annotation>
 </semantics>
</math>

 or</p>

<p>

<math display="block" id="Monadic_predicate_calculus:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>x</mi>
      </mpadded>
      <mi mathvariant="normal">¬</mi>
      <msub>
       <mi>P</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <msub>
      <mi>P</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <msubsup>
      <mi>P</mi>
      <mn>1</mn>
      <mo>′</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <mrow>
     <msubsup>
      <mi>P</mi>
      <mi>m</mi>
      <mo>′</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <not></not>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <ci>normal-′</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>m</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\,\neg P_{1}(x)\land\cdots\land\neg P_{n}(x)\land P^{\prime}_{1}(x)%
\land\cdots\land P^{\prime}_{m}(x),
  </annotation>
 </semantics>
</math>

 These formulas slightly generalize the basic judgements considered in term logic. For example, this form allows statements such as "<em>Every mammal is either a herbivore or a carnivore (or both)</em>", 

<math display="inline" id="Monadic_predicate_calculus:9">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>x</mi>
      </mpadded>
      <mi mathvariant="normal">¬</mi>
      <mi>M</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <not></not>
      <ci>M</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x\,\neg M(x)\lor H(x)\lor C(x))
  </annotation>
 </semantics>
</math>

. Reasoning about such statements can, however, still be handled within the framework of term logic, although not by the 19 classical Aristotelian <a href="syllogism" title="wikilink">syllogisms</a> alone.</p>

<p>Taking <a href="propositional_logic" title="wikilink">propositional logic</a> as given, every formula in the monadic predicate calculus expresses something that can likewise be formulated in term logic. On the other hand, a modern view of the <a href="problem_of_multiple_generality" title="wikilink">problem of multiple generality</a> in traditional logic concludes that quantifiers cannot nest usefully if there are no polyadic predicates to relate the bound variables.</p>
<h2 id="variants">Variants</h2>

<p>The formal system described above is sometimes called the <strong>pure</strong> monadic predicate calculus, where "pure" signifies the absence of function letters. Allowing monadic function letters changes the logic only superficially, whereas admitting even a single binary function letter results in an undecidable logic.</p>

<p>Monadic <a href="second-order_logic" title="wikilink">second-order logic</a> allows predicates of higher <a class="uri" href="arity" title="wikilink">arity</a> in formulas, but restricts second-order quantification to <a class="uri" href="unary" title="wikilink">unary</a> predicates, i.e. the only second-order variables allowed are <a href="subset_variables" title="wikilink">subset variables</a>.</p>
<h2 id="footnotes">Footnotes</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Predicate_logic" title="wikilink">Category:Predicate logic</a> <a href="Category:Logical_calculi" title="wikilink">Category:Logical calculi</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Heinrich_Behmann" title="wikilink">Heinrich Behmann</a>, <em>Beiträge zur Algebra der Logik, insbesondere zum Entscheidungsproblem</em>, in <em>Mathematische Annalen</em> (1922)<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="Leopold_Löwenheim" title="wikilink">Löwenheim</a>, L. (1915) "Über Möglichkeiten im Relativkalkül," <em>Mathematische Annalen</em> 76: 447-470. Translated as "On possibilities in the calculus of relatives" in Jean van Heijenoort, 1967. <em>A Source Book in Mathematical Logic</em>, 1879-1931. Harvard Univ. Press: 228-51.<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
