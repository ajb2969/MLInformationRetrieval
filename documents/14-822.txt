   Top tree      Top tree   A top tree is a data structure based on a binary tree for unrooted dynamic trees that is used mainly for various path-related operations. It allows simple divide-and-conquer algorithms . It has since been augmented to maintain dynamically various properties of a tree such as diameter, center and median.  A top tree   ℜ     \Re   is defined for an underlying tree    𝒯   𝒯   \mathcal{T}   and a set    ∂  T      T    \partial{T}   of at most two vertices called as External Boundary Vertices  (Figure)  An image depicting a top tree built on an underlying tree (black nodes)A tree divided into edge clusters and the complete top-tree for it. Filled nodes in the top-tree are path-clusters, while small circle nodes are leaf-clusters. The big circle node is the root. Capital letters denote clusters, non-capital letters are nodes.   Glossary  Boundary Node  See Boundary Vertex  Boundary Vertex  A vertex in a connected subtree is a Boundary Vertex if it is connected to a vertex outside the subtree by an edge.  External Boundary Vertices  Up to a pair of vertices in the top tree   ℜ     \Re   can be called as External Boundary Vertices, they can be thought of as Boundary Vertices of the cluster which represents the entire top tree.  Cluster  A cluster is a connected subtree with at most two Boundary Vertices . The set of Boundary Vertices of a given cluster   𝒞   𝒞   \mathcal{C}   is denoted as     ∂  C   .      C    \partial{C}.   With each cluster   𝒞   𝒞   \mathcal{C}   the user may associate some meta information     I   (  𝒞  )    ,      I  𝒞    I(\mathcal{C}),   and give methods to maintain it under the various internal operations .  Path Cluster  If    π   (  𝒞  )       π  𝒞    \pi(\mathcal{C})   contains at least one edge then   𝒞   𝒞   \mathcal{C}   is called a Path Cluster .  Point Cluster  See Leaf Cluster  Leaf Cluster  If    π   (  𝒞  )       π  𝒞    \pi(\mathcal{C})   does not contain any edge i.e.   𝒞   𝒞   \mathcal{C}   has only one Boundary Vertex then   𝒞   𝒞   \mathcal{C}   is called a Leaf Cluster .  Edge Cluster  A Cluster containing a single edge is called an Edge Cluster .  Leaf Edge Cluster  A Leaf in the original Cluster is represented by a Cluster with just a single Boundary Vertex and is called a Leaf Edge Cluster .  Path Edge Cluster  Edge Clusters with two Boundary Nodes are called Path Edge Cluster .  Internal Node  A node in   𝒞   𝒞   \mathcal{C}    \     ∂  C      C    \partial{C}   is called an Internal Node of    𝒞  .    𝒞   \mathcal{C}.     Cluster Path  The path between the Boundary Vertices of   𝒞   𝒞   \mathcal{C}   is called the cluster path of   𝒞   𝒞   \mathcal{C}   and it is denoted by     π   (  𝒞  )    .      π  𝒞    \pi(\mathcal{C}).     Mergeable Clusters  Two Clusters   𝒜   𝒜   \mathcal{A}   and   ℬ   ℬ   \mathcal{B}   are Mergeable if    𝒜  ∩  ℬ      𝒜  ℬ    \mathcal{A}\cap\mathcal{B}   is a singleton set (they have exactly one node in common) and    𝒜  ∪  ℬ      𝒜  ℬ    \mathcal{A}\cup\mathcal{B}   is a Cluster.  Introduction  Top trees are used for maintaining a Dynamic forest (set of trees) under link and cut operations.  The basic idea is to maintain a balanced Binary tree    ℜ     \Re   of logarithmic height in the number of nodes in the original tree   𝒯   𝒯   \mathcal{T}   ( i.e. in    𝒪   (   log  n   )       𝒪    n     \mathcal{O}(\log n)   time) ; the top tree essentially represents the recursive subdivision of the original tree   𝒯   𝒯   \mathcal{T}   into clusters ''.  In general the tree   𝒯   𝒯   \mathcal{T}   may have weight on its edges.  There is a one to one correspondence with the edges of the original tree   𝒯   𝒯   \mathcal{T}   and the leaf nodes of the top tree   ℜ     \Re   and each internal node of   ℜ     \Re   represents a cluster that is formed due to the union of the clusters that are its children.  The top tree data structure can be initialized in    𝒪   (  n  )       𝒪  n    \mathcal{O}(n)   time.  Therefore the top tree   ℜ     \Re   over (    𝒯  ,    𝒯   \mathcal{T},       ∂  T      T    \partial{T}   ) is a binary tree such that   The nodes of   ℜ     \Re   are clusters of (    𝒯  ,    𝒯   \mathcal{T},       ∂  T      T    \partial{T}   );  The leaves of   ℜ     \Re   are the edges of    𝒯  ;    𝒯   \mathcal{T};     Sibling clusters are neighbours in the sense that they intersect in a single vertex, and then their parent cluster is their union.  Root of   ℜ     \Re   is the tree   𝒯   𝒯   \mathcal{T}   itself, with a set of at most two External Boundary Vertices.   A tree with a single vertex has an empty top tree, and one with just an edge is just a single node.  These trees are freely augmentable allowing the user a wide variety of flexibility and productivity without going into the details of the internal workings of the data structure, something which is also referred to as the Black Box .  Dynamic Operations  The following three are the user allowable Forest Updates.   Link(v, w): Where   v   v   v   and   w   w   w   are vertices in different trees   𝒯   𝒯   \mathcal{T}    1 and   𝒯   𝒯   \mathcal{T}    2 . It returns a single top tree representing   ℜ     \Re    v    ∪     \cup      ℜ     \Re    w     ∪   (  v  ,  w  )        v  w     \cup{(v,w)}       Cut(v, w) : Removes the edge    (  v  ,  w  )     v  w    {(v,w)}   from a tree   𝒯   𝒯   \mathcal{T}   with top tree    ℜ  ,      \Re,   thereby turning it into two trees   𝒯   𝒯   \mathcal{T}    v and   𝒯   𝒯   \mathcal{T}    w and returning two top trees   ℜ     \Re    v and   ℜ     \Re    w .    Expose(S) : Is called as a subroutine for implementing most of the queries on a top tree.   S   S   S   contains at most 2 vertices. It makes original external vertices to be normal vertices and makes vertices from   S   S   S   the new External Boundary Vertices of the top tree. If   S   S   S   is nonempty it returns the new Root cluster   𝒞   𝒞   \mathcal{C}   with      ∂  C   =  S   .        C   S    \partial{C}=S.    Expose({v,w}) fails if the vertices are from different trees.   Internal Operations  The Forest updates are all carried out by a sequence of at most    𝒪   (   log  n   )       𝒪    n     \mathcal{O}(\log n)   Internal Operations, the sequence of which is computed in further    𝒪   (   log  n   )       𝒪    n     \mathcal{O}(\log n)   time. It may happen that during a tree update, a leaf cluster may change to a path cluster and the converse. Updates to top tree are done exclusively by these internal operations.  The    I   (  𝒞  )       I  𝒞    I(\mathcal{C})   is updated by calling a user defined function associated with each internal operation.   Merge      (  𝒜  ,  ℬ  )   :      normal-:   𝒜  ℬ   absent    (\mathcal{A},\mathcal{B}){:}   Here   𝒜   𝒜   \mathcal{A}   and   ℬ   ℬ   \mathcal{B}   are Mergeable Clusters , it returns   𝒞   𝒞   \mathcal{C}   as the parent cluster of   𝒜   𝒜   \mathcal{A}   and   ℬ   ℬ   \mathcal{B}   and with boundary vertices as the boundary vertices of     𝒜  ∪  ℬ   .      𝒜  ℬ    \mathcal{A}\cup\mathcal{B}.   Computes    I   (  𝒞  )       I  𝒞    I(\mathcal{C})   using    I   (  𝒜  )       I  𝒜    I(\mathcal{A})   and     I   (  ℬ  )    .      I  ℬ    I(\mathcal{B}).       Split      (  𝒞  )   :      normal-:  𝒞  absent    (\mathcal{C}){:}   Here   𝒞   𝒞   \mathcal{C}   is the root cluster     𝒜  ∪  ℬ   .      𝒜  ℬ    \mathcal{A}\cup\mathcal{B}.   It updates    I   (  𝒜  )       I  𝒜    I(\mathcal{A})   and    I   (  ℬ  )       I  ℬ    I(\mathcal{B})   using    I   (  𝒞  )       I  𝒞    I(\mathcal{C})   and than it deletes the cluster   𝒞   𝒞   \mathcal{C}   from   ℜ     \Re   .   Split is usually implemented using Clean     (  𝒞  )    𝒞   (\mathcal{C})   method which calls user method for updates of    I   (  𝒜  )       I  𝒜    I(\mathcal{A})   and    I   (  ℬ  )       I  ℬ    I(\mathcal{B})   using    I   (  𝒞  )       I  𝒞    I(\mathcal{C})   and updates    I   (  𝒞  )       I  𝒞    I(\mathcal{C})   such that it's known there is no pending update needed in its children. Than the   𝒞   𝒞   \mathcal{C}   is discarded without calling user defined functions. Clean is often required for queries without need to Split . If Split does not use Clean subroutine, and Clean is required, its effect could be achieved with overhead by combining Merge and Split .  The next two functions are analogous to the above two and are used for base clusters.   Create     (  v  ,  w  )   :      normal-:   v  w   absent    (v,w){:}    Creates a cluster   𝒞   𝒞   \mathcal{C}   for the edge     (  v  ,  w  )   .     v  w    (v,w).   Sets     ∂  C   =  ∂        C      \partial{C}=\partial        (  v  ,  w  )   .     v  w    (v,w).       I   (  𝒞  )       I  𝒞    I(\mathcal{C})   is computed from scratch.    Eradicate     (  𝒞  )   :      normal-:  𝒞  absent    (\mathcal{C}){:}       𝒞   𝒞   \mathcal{C}   is the edge cluster     (  v  ,  w  )   .     v  w    (v,w).   User defined function is called to process    I   (  𝒞  )       I  𝒞    I(\mathcal{C})   and than the cluster   𝒞   𝒞   \mathcal{C}   is deleted from the top tree.   Non local search  User can define Choose     (  𝒞  )   :      normal-:  𝒞  absent    (\mathcal{C}){:}    operation which for a root (nonleaf) cluster selects one of its child clusters. The top tree blackbox provides Search     (  𝒞  )   :      normal-:  𝒞  absent    (\mathcal{C}){:}    routine, which organizes Choose queries and reorganization of the top tree (using the Internal operations) such that it locates the only edge in intersection of all selected clusters. Sometimes the search should be limited to a path. There is a variant of nonlocal search for such purposes. If there are two external boundary vertices in the root cluster   𝒞   𝒞   \mathcal{C}   , the edge is searched only on the path    π   (  𝒞  )       π  𝒞    \pi(\mathcal{C})   . It is sufficient to do following modification: If only one of root cluster children is path cluster, it is selected by default without calling the Choose operation.  Examples of non local search  Finding i-th edge on longer path from   v   v   v   to   w   w   w   could be done by    𝒞   𝒞   \mathcal{C}   =Expose({v,w}) followed by Search(   𝒞   𝒞   \mathcal{C}   ) with appropriate Choose . To implement the Choose we use global variable representing   v   v   v   and global variable representing    i  .    i   i.   Choose selects the cluster   𝒜   𝒜   \mathcal{A}   with    v  ∈   ∂  A       v    A     v\in\partial{A}   iff length of    π   (  𝒜  )       π  𝒜    \pi(\mathcal{A})   is at least   i   i   i   . To support the operation the length must be maintained in the   I   I   I   .  Similar task could be formulated for graph with edges with nonunit lengths. In that case the distance could address an edge or a vertex between two edges. We could define Choose such that the edge leading to the vertex is returned in the latter case. There could be defined update increasing all edge lengths along a path by a constant. In such scenario these updates are done in constant time just in root cluster. Clean is required to distribute the delayed update to the children. The Clean should be called before the Search is invoked. To maintain length in   I   I   I   would in that case require to maintain unitlength in   I   I   I   as well.  Finding center of tree containing vertex   v   v   v   could be done by finding either bicenter edge or edge with center as one endpoint. The edge could be found by    𝒞   𝒞   \mathcal{C}   =Expose({v}) followed by Search(   𝒞   𝒞   \mathcal{C}   ) with appropriate Choose . The choose selects between children    𝒜  ,    𝒜   \mathcal{A},      ℬ   ℬ   \mathcal{B}   with    a  ∈    ∂  A   ∩   ∂  B        a      A     B      a\in\partial{A}\cap\partial{B}   the child with higher maxdistance    (  a  )    a   (a)   . To support the operation the maximal distance in the cluster subtree from a boundary vertex should be maintained in the   I   I   I   . That requires maintenance of the cluster path length as well.  Interesting Results and Applications  A number of interesting applications originally implemented by other methods have been easily implemented using the top tree's interface. Some of them include   ([SLEATOR AND TARJAN 1983]). We can maintain a dynamic collection of weighted trees in    𝒪   (   log  n   )       𝒪    n     \mathcal{O}(\log n)   time per link and cut, supporting queries about the maximum edge weight between any two vertices in    O   (   log  n   )       O    n     O(\log n)   time.  Proof outline: It involves maintaining at each node the maximum weight (max_wt) on its cluster path, if it is a point cluster then max_wt(   𝒞   𝒞   \mathcal{C}   ) is initialsed as     -  ∞   .         -\infty.   When a cluster is a union of two clusters then it is the maximum value of the two merged clusters. If we have to find the max wt between   v   v   v   and   w   w   w   then we do    𝒞  =       𝒞  absent    \mathcal{C}=   Expose     (  v  ,  w  )   ,     v  w    (v,w),   and report max_wt     (  𝒞  )   .    𝒞   (\mathcal{C}).        ([SLEATOR AND TARJAN 1983]). In the scenario of the above application we can also add a common weight   x   x   x   to all edges on a given path   v   v   v   · · ·   w   w   w   in    𝒪   (   log  n   )       𝒪    n     \mathcal{O}(\log n)   time.  Proof outline: We introduce a weight called extra(   𝒞   𝒞   \mathcal{C}   ) to be added to all the edges in     π   (  𝒞  )    .      π  𝒞    \pi(\mathcal{C}).   Which is maintained appropriately ; split(   𝒞   𝒞   \mathcal{C}   ) requires that, for each path child   𝒜   𝒜   \mathcal{A}   of    𝒞  ,    𝒞   \mathcal{C},   we set max_wt(A) := max_wt(   𝒜   𝒜   \mathcal{A}   ) + extra(   𝒞   𝒞   \mathcal{C}   ) and extra(   𝒜   𝒜   \mathcal{A}   ) := extra(   𝒜   𝒜   \mathcal{A}   ) + extra(   𝒞   𝒞   \mathcal{C}   ). For   𝒞   𝒞   \mathcal{C}   := join(    𝒜  ,    𝒜   \mathcal{A},      ℬ   ℬ   \mathcal{B}   ), we set max_wt(   𝒞   𝒞   \mathcal{C}   ) := max {max_wt(   𝒜   𝒜   \mathcal{A}   ), max_wt(   ℬ   ℬ   \mathcal{B}   )} and extra(   𝒞   𝒞   \mathcal{C}   ) := 0. Finally, to find the maximum weight on the path   v   v   v   · · ·    w  ,    w   w,   we set   𝒞   𝒞   \mathcal{C}   := Expose    (  v  ,  w  )     v  w    (v,w)   and return max_wt(   𝒞   𝒞   \mathcal{C}   ).     ([GOLDBERG ET AL. 1991]). We can ask for the maximum weight in the underlying tree containing a given vertex   v   v   v   in    𝒪   (   log  n   )       𝒪    n     \mathcal{O}(\log n)   time.  Proof outline: This requires maintaining additional information about the maximum weight non cluster path edge in a cluster under the Merge and Split operations.     The distance between two vertices   v   v   v   and   w   w   w   can be found in    𝒪   (   log  n   )       𝒪    n     \mathcal{O}(\log n)   time as length(Expose    (  v  ,  w  )     v  w    (v,w)   ).  Proof outline:We will maintain the length length(   𝒞   𝒞   \mathcal{C}   ) of the cluster path. The length is maintained as the maximum weight except that, if   𝒞   𝒞   \mathcal{C}   is created by a join(Merge), length(   𝒞   𝒞   \mathcal{C}   ) is the sum of lengths stored with its path children.     Queries regarding diameter of a tree and its subsequent maintenance takes    𝒪   (   log  n   )       𝒪    n     \mathcal{O}(\log n)   time.    The Center and Median can me maintained under Link(Merge) and Cut(Split) operations and queried by non local search in    𝒪   (   log  n   )       𝒪    n     \mathcal{O}(\log n)   time.    The graph could be maintained allowing to update the edge set and ask queries on edge 2-connectivity. Amortized complexity of updates is    O   (    log  4   n   )       O    superscript   4   n     O(\log^{4}n)   . Queries could be implemented even faster. The algorithm is not trivial,    I   (  𝒞  )       I  𝒞    I(\mathcal{C})   uses    Θ   (    log  2   n   )       normal-Θ    superscript   2   n     \Theta(\log^{2}n)   space ([HOLM, LICHTENBERG, THORUP 2000]).    The graph could be maintained allowing to update the edge set and ask queries on vertex 2-connectivity. Amortized complexity of updates is    O   (    log  5   n   )       O    superscript   5   n     O(\log^{5}n)   . Queries could be implemented even faster. The algorithm is not trivial,    I   (  𝒞  )       I  𝒞    I(\mathcal{C})   uses    Θ   (    log  2   n   )       normal-Θ    superscript   2   n     \Theta(\log^{2}n)   space ([HOLM, LICHTENBERG, THORUP 2001]).    Top trees can be used to compress trees in a way that is never much worse than DAG compression, but may be exponentially better. 1   Implementation  Top trees have been implemented in a variety of ways, some of them include implementation using a Multilevel Partition (Top-trees and dynamic graph algorithms Jacob Holm and Kristian de Lichtenberg. Technical Report), and even by using Sleator-Tarjan s-t trees (typically with amortized time bounds), Frederickson's Topology Trees (with worst case time bounds) (Alstrup et al. Maintaining Information in Fully Dynamic Trees with Top Trees).  Amortized implementations are more simple, and with small multiplicative factors in time complexity. On the contrary the worst case implementations allow speeding up queries by switching off unneeded info updates during the query (implemented by persistence techniques). After the query is answered the original state of the top tree is used and the query version is discarded.  Using Multilevel Partitioning  Any partitioning of clusters of a tree   𝒯   𝒯   \mathcal{T}   can be represented by a Cluster Partition Tree CPT     (  𝒯  )   ,    𝒯   (\mathcal{T}),   by replacing each cluster in the tree   𝒯   𝒯   \mathcal{T}   by an edge. If we use a strategy P for partitioning   𝒯   𝒯   \mathcal{T}   then the CPT would be CPT P     𝒯  .    𝒯   \mathcal{T}.   This is done recursively till only one edge remains.  We would notice that all the nodes of the corresponding top tree   ℜ     \Re   are uniquely mapped into the edges of this multilevel partition. There may be some edges in the multilevel partition that do not correspond to any node in the top tree, these are the edges which represent only a single child in the level below it, i.e. a simple cluster. Only the edges that correspond to composite clusters correspond to nodes in the top tree    ℜ  .      \Re.     A partitioning strategy is important while we partition the Tree   𝒯   𝒯   \mathcal{T}   into clusters. Only a careful strategy ensures that we end up in an    𝒪   (   log  n   )       𝒪    n     \mathcal{O}(\log n)   height Multilevel Partition ( and therefore the top tree).   The number of edges in subsequent levels should decrease by a constant factor.  If a lower level is changed by an update then we should be able to update the one immediately above it using at most a constant number of insertions and deletions.   The above partitioning strategy ensures the maintenance of the top tree in    𝒪   (   log  n   )       𝒪    n     \mathcal{O}(\log n)   time.  References   Stephen Alstrup, Jacob Holm, Kristian De Lichtenberg, and Mikkel Thorup , Maintaining information in fully dynamic trees with top trees , ACM Transactions on Algorithms (TALG), Vol. 1 (2005), 243–264,  Stephen Alstrup, Jacob Holm, Kristian De Lichtenberg, and Mikkel Thorup , Poly-logarithmic deterministic dynamic algorithms for connectivity, minimum spanning tree, 2-edge, and biconnectivity , Journal of the ACM (JACM), Vol. 48 Issue 4(July 2001), 723–760,  Donald Knuth . The Art of Computer Programming: Fundamental Algorithms , Third Edition. Addison-Wesley, 1997. ISBN 0-201-89683-4 . Section 2.3: Trees, pp. 308–423.  Thomas H. Cormen , Charles E. Leiserson , Ronald L. Rivest , and Clifford Stein . Introduction to Algorithms , Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7 . Section 10.4: Representing rooted trees, pp. 214–217. Chapters 12–14 (Binary Search Trees, Red-Black Trees, Augmenting Data Structures), pp. 253–320.   External links   Maintaining Information in Fully Dynamic Trees with Top Trees. Alstrup et al  [ http://portal.acm.org/citation.cfm?id=1070547&dl; ;=&coll;=&CFID;=15151515&CFTOKEN;=6184618 Self-Adjusting Top Trees. Tarjan and Werneck, Proc. 16th SoDA, 2005]   "  Category:Binary trees     Tree Compression with Top Trees. BILLE, GOERTZ, LANDAU, WEIMANN 2013 arXiv:1304.5702 [cs.DS] ↩     