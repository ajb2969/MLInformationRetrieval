<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="679">Computer stereo vision</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Computer stereo vision</h1>
<hr/>

<p><strong>Computer stereo vision</strong> is the extraction of 3D information from digital images, such as obtained by a <a href="CCD_camera" title="wikilink">CCD camera</a>. By comparing information about a scene from two vantage points, 3D information can be extracted by examination of the relative positions of objects in the two panels. This is similar to the biological process <a class="uri" href="Stereopsis" title="wikilink">Stereopsis</a>.</p>
<h2 id="outline">Outline</h2>

<p>In traditional stereo vision, two cameras, displaced horizontally from one another are used to obtain two differing views on a scene, in a manner similar to human <a href="binocular_vision" title="wikilink">binocular vision</a>. By comparing these two images, the relative depth information can be obtained, in the form of disparities, which are inversely proportional to the differences in distance to the objects.</p>

<p>To compare the images, the two views must be superimposed in a stereoscopic device, the image from the right camera being shown to the observer's right eye and from the left one to the left eye.</p>

<p>In real camera systems however, several pre-processing steps are required.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<ol>
<li>The image must first be removed of distortions, such as <a href="barrel_distortion" title="wikilink">barrel distortion</a> to ensure that the observed image is purely projectional.</li>
<li>The image must be projected back to a common plane to allow comparison of the image pairs, known as <a href="image_rectification" title="wikilink">image rectification</a>.</li>
<li>An information measure which compares the two images is minimized. This gives the best estimate of the position of features in the two images, and creates a <a href="Binocular_disparity" title="wikilink">disparity map</a>.</li>
<li>Optionally, the disparity as observed by the common projection, is converted back to the <a href="height_map" title="wikilink">height map</a> by inversion. Utilising the correct proportionality constant, the height map can be calibrated to provide exact distances.</li>
</ol>
<h2 id="active-stereo-vision">Active stereo vision</h2>

<p>The active stereo vision is a form of stereo vision which actively employs a light such as a laser or a <a href="structured_light" title="wikilink">structured light</a> to simplify the stereo matching problem. The opposed term is passive stereo vision.</p>
<h3 id="conventional-structured-light-vision-slv">Conventional structured-light vision (SLV)</h3>

<p>The conventional structured-light vision (SLV) employs a structured light or laser, and finds projector-camera correspondences.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="conventional-active-stereo-vision-asv">Conventional active stereo vision (ASV)</h3>

<p>The conventional active stereo vision (ASV) employs a structured light or laser, however, the stereo matching is performed only for camera-camera correspondences, in the same way as the passive stereo vision.</p>
<h3 id="structured-light-stereo-sls">Structured-light stereo (SLS)<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></h3>

<p>There is a hybrid technique, which utilizes both camera-camera and projector-camera correspondences.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="applications">Applications</h2>

<p>3D stereo displays finds many applications in entertainment, information transfer and <a href="automation" title="wikilink">automated</a> systems. Stereo vision is highly important in fields such as <a class="uri" href="robotics" title="wikilink">robotics</a>, to extract information about the relative position of 3D objects in the vicinity of autonomous systems. Other applications for robotics include object recognition, where depth information allows for the system to separate occluding image components, such as one chair in front of another, which the robot may otherwise not be able to distinguish as a separate object by any other criteria.</p>

<p>Scientific applications for digital stereo vision include the extraction of information from <a href="aerial_survey" title="wikilink">aerial surveys</a>, for calculation of contour maps or even geometry extraction for 3D building mapping, or calculation of 3D <a href="heliography" title="wikilink">heliographical</a> information such as obtained by the NASA <a class="uri" href="STEREO" title="wikilink">STEREO</a> project.</p>
<h2 id="detailed-definition">Detailed definition</h2>
<figure><b>(Figure)</b>
<figcaption>Diagram describing relationship of image displacement to depth with stereoscopic images, assuming flat co-planar images.</figcaption>
</figure>

<p>A pixel records color at a position. The position is identified by position in the grid of pixels (x, y) and depth to the pixel <em>z.</em></p>

<p>Stereoscopic vision gives two images of the same scene, from different positions. In the diagram on the right light from the point <em>A</em> is transmitted through the entry points of a pinhole cameras at <em>B</em> and <em>D</em>, onto image screens at <em>E</em> and <em>H</em>.</p>

<p>In the attached diagram the distance between the centers of the two camera lens is <em>BD = BC + CD</em>. The triangles are similar,</p>
<ul>
<li><em>ACB</em> and <em>BFE</em></li>
<li><em>ACD</em> and <em>DGH</em></li>
</ul>

<p>
<math display="inline" id="Computer_stereo_vision:0">
<semantics>
<mtable>
<mtr>
<mtd columnalign="right">
<mrow>
<mtext>Therefore displacement</mtext>
<mi>d</mi>
</mrow>
</mtd>
<mtd columnalign="left">
<mrow>
<mi></mi>
<mo>=</mo>
<mrow>
<mrow>
<mi>E</mi>
<mi>F</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>G</mi>
<mi>H</mi>
</mrow>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd></mtd>
<mtd columnalign="left">
<mrow>
<mi></mi>
<mo>=</mo>
<mrow>
<mi>B</mi>
<mi>F</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mstyle displaystyle="true">
<mfrac>
<mrow>
<mi>E</mi>
<mi>F</mi>
</mrow>
<mrow>
<mi>B</mi>
<mi>F</mi>
</mrow>
</mfrac>
</mstyle>
<mo>+</mo>
<mstyle displaystyle="true">
<mfrac>
<mrow>
<mi>G</mi>
<mi>H</mi>
</mrow>
<mrow>
<mi>B</mi>
<mi>F</mi>
</mrow>
</mfrac>
</mstyle>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd></mtd>
<mtd columnalign="left">
<mrow>
<mi></mi>
<mo>=</mo>
<mrow>
<mi>B</mi>
<mi>F</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mstyle displaystyle="true">
<mfrac>
<mrow>
<mi>E</mi>
<mi>F</mi>
</mrow>
<mrow>
<mi>B</mi>
<mi>F</mi>
</mrow>
</mfrac>
</mstyle>
<mo>+</mo>
<mstyle displaystyle="true">
<mfrac>
<mrow>
<mi>G</mi>
<mi>H</mi>
</mrow>
<mrow>
<mi>D</mi>
<mi>G</mi>
</mrow>
</mfrac>
</mstyle>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd></mtd>
<mtd columnalign="left">
<mrow>
<mi></mi>
<mo>=</mo>
<mrow>
<mi>B</mi>
<mi>F</mi>
<mrow>
<mo stretchy="false">(</mo>
<mstyle displaystyle="true">
<mfrac>
<mrow>
<mrow>
<mi>B</mi>
<mi>C</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>C</mi>
<mi>D</mi>
</mrow>
</mrow>
<mrow>
<mi>A</mi>
<mi>C</mi>
</mrow>
</mfrac>
</mstyle>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd></mtd>
<mtd columnalign="left">
<mrow>
<mi></mi>
<mo>=</mo>
<mrow>
<mi>B</mi>
<mi>F</mi>
<mstyle displaystyle="true">
<mfrac>
<mrow>
<mi>B</mi>
<mi>D</mi>
</mrow>
<mrow>
<mi>A</mi>
<mi>C</mi>
</mrow>
</mfrac>
</mstyle>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd></mtd>
<mtd columnalign="left">
<mrow>
<mi></mi>
<mo>=</mo>
<mrow>
<mstyle displaystyle="true">
<mfrac>
<mi>k</mi>
<mi>z</mi>
</mfrac>
</mstyle>
<mtext>, where</mtext>
</mrow>
</mrow>
</mtd>
</mtr>
</mtable>
<annotation-xml encoding="MathML-Content">
<matrix>
<matrixrow>
<apply>
<times></times>
<mtext>Therefore displacement</mtext>
<ci>d</ci>
</apply>
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>E</ci>
<ci>F</ci>
</apply>
<apply>
<times></times>
<ci>G</ci>
<ci>H</ci>
</apply>
</apply>
</apply>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">missing-subexpression</csymbol>
</cerror>
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<apply>
<times></times>
<ci>B</ci>
<ci>F</ci>
<apply>
<plus></plus>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>E</ci>
<ci>F</ci>
</apply>
<apply>
<times></times>
<ci>B</ci>
<ci>F</ci>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>G</ci>
<ci>H</ci>
</apply>
<apply>
<times></times>
<ci>B</ci>
<ci>F</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">missing-subexpression</csymbol>
</cerror>
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<apply>
<times></times>
<ci>B</ci>
<ci>F</ci>
<apply>
<plus></plus>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>E</ci>
<ci>F</ci>
</apply>
<apply>
<times></times>
<ci>B</ci>
<ci>F</ci>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>G</ci>
<ci>H</ci>
</apply>
<apply>
<times></times>
<ci>D</ci>
<ci>G</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">missing-subexpression</csymbol>
</cerror>
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<apply>
<times></times>
<ci>B</ci>
<ci>F</ci>
<apply>
<divide></divide>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>B</ci>
<ci>C</ci>
</apply>
<apply>
<times></times>
<ci>C</ci>
<ci>D</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>A</ci>
<ci>C</ci>
</apply>
</apply>
</apply>
</apply>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">missing-subexpression</csymbol>
</cerror>
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<apply>
<times></times>
<ci>B</ci>
<ci>F</ci>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>B</ci>
<ci>D</ci>
</apply>
<apply>
<times></times>
<ci>A</ci>
<ci>C</ci>
</apply>
</apply>
</apply>
</apply>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">missing-subexpression</csymbol>
</cerror>
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<apply>
<times></times>
<apply>
<divide></divide>
<ci>k</ci>
<ci>z</ci>
</apply>
<mtext>, where</mtext>
</apply>
</apply>
</matrixrow>
</matrix>
</annotation-xml>
<annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle\text{Therefore displacement }d&amp;\displaystyle=EF+%
GH\\
&amp;\displaystyle=BF(\frac{EF}{BF}+\frac{GH}{BF})\\
&amp;\displaystyle=BF(\frac{EF}{BF}+\frac{GH}{DG})\\
&amp;\displaystyle=BF(\frac{BC+CD}{AC})\\
&amp;\displaystyle=BF\frac{BD}{AC}\\
&amp;\displaystyle=\frac{k}{z}\text{, where}\\
\end{aligned}
  </annotation>
</semantics>
</math>
</p>
<ul>
<li><em>k = BD BF</em></li>
<li><em>z = AC</em> is the distance from the camera plane to the object.</li>
</ul>

<p>So assuming the cameras are level, and image planes are flat on the same plane, the displacement in the y axis between the same pixel in the two images is,</p>

<p>
<math display="block" id="Computer_stereo_vision:1">
<semantics>
<mrow>
<mi>d</mi>
<mo>=</mo>
<mfrac>
<mi>k</mi>
<mi>z</mi>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>d</ci>
<apply>
<divide></divide>
<ci>k</ci>
<ci>z</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   d=\frac{k}{z}
  </annotation>
</semantics>
</math>
</p>

<p>Where <em>k</em> is the distance between the two cameras times the distance from the lens to the image.</p>

<p>The depth component in the two images are 

<math display="inline" id="Computer_stereo_vision:2">
<semantics>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z_{1}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Computer_stereo_vision:3">
<semantics>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z_{2}
  </annotation>
</semantics>
</math>

, given by,</p>

<p>
<math display="block" id="Computer_stereo_vision:4">
<semantics>
<mrow>
<mrow>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>min</mi>
<mrow>
<mo>{</mo>
<mrow>
<mi>v</mi>
<mo>:</mo>
<mrow>
<mi>v</mi>
<mo>=</mo>
<mrow>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mrow>
<mi>y</mi>
<mo>-</mo>
<mfrac>
<mi>k</mi>
<mrow>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>}</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
<apply>
<min></min>
<apply>
<ci>normal-:</ci>
<ci>v</ci>
<apply>
<eq></eq>
<ci>v</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<interval closure="open">
<ci>x</ci>
<apply>
<minus></minus>
<ci>y</ci>
<apply>
<divide></divide>
<ci>k</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
</apply>
</apply>
</interval>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z_{2}(x,y)=\min\left\{v:v=z_{1}(x,y-\frac{k}{z_{1}(x,y)})\right\}
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Computer_stereo_vision:5">
<semantics>
<mrow>
<mrow>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>min</mi>
<mrow>
<mo>{</mo>
<mrow>
<mi>v</mi>
<mo>:</mo>
<mrow>
<mi>v</mi>
<mo>=</mo>
<mrow>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mrow>
<mi>y</mi>
<mo>+</mo>
<mfrac>
<mi>k</mi>
<mrow>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>}</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
<apply>
<min></min>
<apply>
<ci>normal-:</ci>
<ci>v</ci>
<apply>
<eq></eq>
<ci>v</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
<interval closure="open">
<ci>x</ci>
<apply>
<plus></plus>
<ci>y</ci>
<apply>
<divide></divide>
<ci>k</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
</apply>
</apply>
</interval>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z_{1}(x,y)=\min\left\{v:v=z_{2}(x,y+\frac{k}{z_{2}(x,y)})\right\}
  </annotation>
</semantics>
</math>
</p>

<p>These formulas allow for the <a href="hidden_surface_determination" title="wikilink">occlusion</a> of <a class="uri" href="voxels" title="wikilink">voxels</a>, seen in one image on the surface of the object, by closer voxels seen in the other image, on the surface of the object.</p>
<h3 id="image-rectification">Image Rectification</h3>

<p>Where the image planes are not co-planar <a href="image_rectification" title="wikilink">image rectification</a> is required to adjust the images as if they were co-planar. This may be achieved by a linear transformation.</p>

<p>The images may also need rectification to make each image equivalent to the image taken from a pinhole camera projecting to a flat plane.</p>
<h3 id="least-squares-information-measure">Least squares information measure</h3>

<p>The normal distribution is</p>

<p>
<math display="block" id="Computer_stereo_vision:6">
<semantics>
<mrow>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>μ</mi>
<mo>,</mo>
<mi>σ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mrow>
<mi>σ</mi>
<msqrt>
<mrow>
<mn>2</mn>
<mi>π</mi>
</mrow>
</msqrt>
</mrow>
</mfrac>
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>-</mo>
<mi>μ</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<mn>2</mn>
<msup>
<mi>σ</mi>
<mn>2</mn>
</msup>
</mrow>
</mfrac>
</mrow>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>P</ci>
<vector>
<ci>x</ci>
<ci>μ</ci>
<ci>σ</ci>
</vector>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<times></times>
<ci>σ</ci>
<apply>
<root></root>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>x</ci>
<ci>μ</ci>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>σ</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(x,\mu,\sigma)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^{2}}{2\sigma^{2}}}
  </annotation>
</semantics>
</math>
</p>

<p>Probability is related to information content described by <a href="Minimum_message_length" title="wikilink">message length</a> <em>L</em>,</p>

<p>
<math display="block" id="Computer_stereo_vision:7">
<semantics>
<mrow>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<msup>
<mn>2</mn>
<mrow>
<mo>-</mo>
<mrow>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>P</ci>
<ci>x</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>L</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(x)=2^{-L(x)}
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Computer_stereo_vision:8">
<semantics>
<mrow>
<mrow>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mrow>
<mrow>
<msub>
<mi>log</mi>
<mn>2</mn>
</msub>
<mi>P</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>L</ci>
<ci>x</ci>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<log></log>
<cn type="integer">2</cn>
</apply>
<ci>P</ci>
</apply>
<ci>x</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L(x)=-\log_{2}{P(x)}
  </annotation>
</semantics>
</math>
</p>

<p>so,</p>

<p>
<math display="block" id="Computer_stereo_vision:9">
<semantics>
<mrow>
<mrow>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>μ</mi>
<mo>,</mo>
<mi>σ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<msub>
<mi>log</mi>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>σ</mi>
<msqrt>
<mrow>
<mn>2</mn>
<mi>π</mi>
</mrow>
</msqrt>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>-</mo>
<mi>μ</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<mn>2</mn>
<msup>
<mi>σ</mi>
<mn>2</mn>
</msup>
</mrow>
</mfrac>
<mrow>
<msub>
<mi>log</mi>
<mn>2</mn>
</msub>
<mi>e</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>L</ci>
<vector>
<ci>x</ci>
<ci>μ</ci>
<ci>σ</ci>
</vector>
</apply>
<apply>
<plus></plus>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<log></log>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<ci>σ</ci>
<apply>
<root></root>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>x</ci>
<ci>μ</ci>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>σ</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<log></log>
<cn type="integer">2</cn>
</apply>
<ci>e</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L(x,\mu,\sigma)=\log_{2}(\sigma\sqrt{2\pi})+\frac{(x-\mu)^{2}}{2\sigma^{2}}%
\log_{2}e
  </annotation>
</semantics>
</math>
</p>

<p>For the purposes of comparing stereoscopic images, only the relative message length matters. Based on this, the information measure <em>I</em>, called the Sum of Squares of Differences (SSD) is,</p>

<p>
<math display="block" id="Computer_stereo_vision:10">
<semantics>
<mrow>
<mrow>
<mi>I</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>μ</mi>
<mo>,</mo>
<mi>σ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>-</mo>
<mi>μ</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
<msup>
<mi>σ</mi>
<mn>2</mn>
</msup>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>I</ci>
<vector>
<ci>x</ci>
<ci>μ</ci>
<ci>σ</ci>
</vector>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>x</ci>
<ci>μ</ci>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>σ</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   I(x,\mu,\sigma)=\frac{(x-\mu)^{2}}{\sigma^{2}}
  </annotation>
</semantics>
</math>
</p>

<p>where,</p>

<p>
<math display="block" id="Computer_stereo_vision:11">
<semantics>
<mrow>
<mrow>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>μ</mi>
<mo>,</mo>
<mi>σ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<msub>
<mi>log</mi>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>σ</mi>
<msqrt>
<mrow>
<mn>2</mn>
<mi>π</mi>
</mrow>
</msqrt>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mi>I</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>μ</mi>
<mo>,</mo>
<mi>σ</mi>
<mo stretchy="false">)</mo>
</mrow>
<mfrac>
<mrow>
<msub>
<mi>log</mi>
<mn>2</mn>
</msub>
<mi>e</mi>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>L</ci>
<vector>
<ci>x</ci>
<ci>μ</ci>
<ci>σ</ci>
</vector>
</apply>
<apply>
<plus></plus>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<log></log>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<ci>σ</ci>
<apply>
<root></root>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>I</ci>
<vector>
<ci>x</ci>
<ci>μ</ci>
<ci>σ</ci>
</vector>
<apply>
<divide></divide>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<log></log>
<cn type="integer">2</cn>
</apply>
<ci>e</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L(x,\mu,\sigma)=\log_{2}(\sigma\sqrt{2\pi})+I(x,\mu,\sigma)\frac{\log_{2}e}{2}
  </annotation>
</semantics>
</math>
</p>
<h3 id="other-measures-of-information-content">Other measures of information content</h3>

<p>Because of the cost in processing time of squaring numbers in SSD, many implementations use Sum of Absolute Difference (SAD) as the basis for computing the information measure. Other methods use normalized cross correlation (NCC).</p>
<h3 id="information-measure-for-stereoscopic-images">Information measure for stereoscopic images</h3>

<p>The <a href="least_squares" title="wikilink">least squares</a> measure may be used to measure the information content of the stereoscopic images ,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> given depths at each point 

<math display="inline" id="Computer_stereo_vision:12">
<semantics>
<mrow>
<mi>z</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>z</ci>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z(x,y)
  </annotation>
</semantics>
</math>

. Firstly the information needed to express one image in terms of the other is derived. This is called 

<math display="inline" id="Computer_stereo_vision:13">
<semantics>
<msub>
<mi>I</mi>
<mi>m</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>m</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   I_{m}
  </annotation>
</semantics>
</math>

.</p>

<p>A <a href="color_difference" title="wikilink">color difference</a> function should be used to fairly measure the difference between colors. The color difference function is written <em>cd</em> in the following. The measure of the information needed to record the color matching between the two images is,</p>

<p>
<math display="block" id="Computer_stereo_vision:14">
<semantics>
<mrow>
<msub>
<mi>I</mi>
<mi>m</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mfrac>
<mn>1</mn>
<msubsup>
<mi>σ</mi>
<mi>m</mi>
<mn>2</mn>
</msubsup>
</mfrac>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
</mrow>
</munder>
<mo>cd</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mo>color</mo>
<mn>1</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo>+</mo>
<mfrac>
<mi>k</mi>
<mrow>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<mo stretchy="false">)</mo>
</mrow>
<mo>,</mo>
<msub>
<mo>color</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>m</ci>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>σ</ci>
<ci>m</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<list>
<ci>x</ci>
<ci>y</ci>
</list>
</apply>
<ci>cd</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>color</ci>
<cn type="integer">1</cn>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">y</csymbol>
<plus></plus>
<apply>
<divide></divide>
<ci>k</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
</apply>
<ci>normal-)</ci>
</cerror>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>color</ci>
<cn type="integer">2</cn>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
<cn type="integer">2</cn>
</apply>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   I_{m}(z_{1},z_{2})=\frac{1}{\sigma_{m}^{2}}\sum_{x,y}\operatorname{cd}(%
\operatorname{color}_{1}(x,y+\frac{k}{z_{1}(x,y)}),\operatorname{color}_{2}(x,%
y))^{2}
  </annotation>
</semantics>
</math>
</p>

<p>An assumption is made about the smoothness of the image. Assume that two pixels are more likely to be the same color, the closer the voxels they represent are. This measure is intended to favor colors that are similar being grouped at the same depth. For example if an object in front occludes an area of sky behind, the measure of smoothness favors the blue pixels all being grouped together at the same depth.</p>

<p>The total measure of smoothness uses the distance between voxels as an estimate of the expected standard deviation of the color difference,</p>

<p>
<math display="block" id="Computer_stereo_vision:15">
<semantics>
<mrow>
<mrow>
<msub>
<mi>I</mi>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mrow>
<mn>2</mn>
<msubsup>
<mi>σ</mi>
<mi>h</mi>
<mn>2</mn>
</msubsup>
</mrow>
</mfrac>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>:</mo>
<mrow>
<mo stretchy="false">{</mo>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
</munder>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>y</mi>
<mn>1</mn>
</msub>
</mrow>
</munder>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<msub>
<mi>y</mi>
<mn>2</mn>
</msub>
</mrow>
</munder>
<mfrac>
<mrow>
<mo>cd</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mo>color</mo>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>y</mi>
<mn>1</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo>,</mo>
<msub>
<mo>color</mo>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<msub>
<mi>y</mi>
<mn>2</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>-</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
<mo>+</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>y</mi>
<mn>1</mn>
</msub>
<mo>-</mo>
<msub>
<mi>y</mi>
<mn>2</mn>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
<mo>+</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<msub>
<mi>z</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>y</mi>
<mn>1</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<msub>
<mi>z</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<msub>
<mi>y</mi>
<mn>2</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
</mfrac>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>s</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</interval>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<times></times>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>σ</ci>
<ci>h</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<ci>normal-:</ci>
<ci>i</ci>
<set>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</set>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">1</cn>
</apply>
</list>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">2</cn>
</apply>
</list>
</apply>
<apply>
<divide></divide>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>cd</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>color</ci>
<ci>i</ci>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-)</ci>
</cerror>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>color</ci>
<ci>i</ci>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-)</ci>
</cerror>
<ci>normal-)</ci>
</cerror>
<cn type="integer">2</cn>
</apply>
</cerror>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>i</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">1</cn>
</apply>
</interval>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>i</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">2</cn>
</apply>
</interval>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   I_{s}(z_{1},z_{2})=\frac{1}{2\sigma_{h}^{2}}\sum_{i:\{1,2\}}\sum_{x_{1},y_{1}}%
\sum_{x_{2},y_{2}}\frac{\operatorname{cd}(\operatorname{color}_{i}(x_{1},y_{1}%
),\operatorname{color}_{i}(x_{2},y_{2}))^{2}}{(x_{1}-x_{2})^{2}+(y_{1}-y_{2})^%
{2}+(z_{i}(x_{1},y_{1})-z_{i}(x_{2},y_{2}))^{2}}
  </annotation>
</semantics>
</math>
</p>

<p>The total information content is then the sum,</p>

<p>
<math display="block" id="Computer_stereo_vision:16">
<semantics>
<mrow>
<mrow>
<msub>
<mi>I</mi>
<mi>t</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<msub>
<mi>I</mi>
<mi>m</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mi>I</mi>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>t</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</interval>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>m</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</interval>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>s</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</interval>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   I_{t}(z_{1},z_{2})=I_{m}(z_{1},z_{2})+I_{s}(z_{1},z_{2})
  </annotation>
</semantics>
</math>
</p>

<p>The z component of each pixel must be chosen to give the minimum value for the information content. This will give the most likely depths at each pixel. The minimum total information measure is,</p>

<p>
<math display="block" id="Computer_stereo_vision:17">
<semantics>
<mrow>
<msub>
<mi>I</mi>
<mo>min</mo>
</msub>
<mo>=</mo>
<mi>min</mi>
<mrow>
<mo stretchy="false">{</mo>
<mi>i</mi>
<mo>:</mo>
<mi>i</mi>
<mo>=</mo>
<msub>
<mi>I</mi>
<mi>t</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>min</ci>
</apply>
<eq></eq>
<min></min>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-{</ci>
<csymbol cd="unknown">i</csymbol>
<ci>normal-:</ci>
<csymbol cd="unknown">i</csymbol>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>t</ci>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-)</ci>
</cerror>
<ci>normal-}</ci>
</cerror>
<ci>normal-}</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   I_{\operatorname{min}}=\min{\{i:i=I_{t}(z_{1},z_{2})\}}\}
  </annotation>
</semantics>
</math>
</p>

<p>The depth functions for the left and right images are the pair,</p>

<p>
<math display="block" id="Computer_stereo_vision:18">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo>∈</mo>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo>:</mo>
<mrow>
<mrow>
<msub>
<mi>I</mi>
<mi>t</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<msub>
<mi>I</mi>
<mo>min</mo>
</msub>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</interval>
<apply>
<csymbol cd="latexml">conditional-set</csymbol>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</interval>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>t</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</interval>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>I</ci>
<ci>min</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (z_{1},z_{2})\in\{(z_{1},z_{2}):I_{t}(z_{1},z_{2})=I_{\operatorname{min}}\}
  </annotation>
</semantics>
</math>
</p>
<h3 id="smoothness">Smoothness</h3>

<p>Smoothness is a measure of how similar colors that are close together are. There is an assumption that objects are more likely to be colored with a small number of colors. So if we detect two pixels with the same color they most likely belong to the same object.</p>

<p>The method described above for evaluating smoothness is based on information theory, and an assumption that the influence of the color of a voxel influencing the color of nearby voxels according to the normal distribution on the distance between points. The model is based on approximate assumptions about the world.</p>

<p>Another method based on prior assumptions of smoothness is auto-correlation.</p>

<p>Smoothness is a property of the world. It is not inherently a property of an image. For example an image constructed of random dots would have no smoothness, and inferences about neighboring points would be useless.</p>

<p>Theoretically smoothness, along with other properties of the world should be learnt. This appears to be what the human vision system does.</p>
<h2 id="methods-of-implementation">Methods of implementation</h2>

<p>The minimization problem is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>. This means a general solution to this problem will take an unthinkably long time to reach a solution. However methods exist for computers based on <a class="uri" href="heuristics" title="wikilink">heuristics</a> that approximate the result in a reasonable amount of time. Also methods exist based on <a href="neural_network" title="wikilink">neural networks</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Efficient implementation of stereoscopic vision is an area of active research.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="3D_scanner" title="wikilink">3D scanner</a></li>
<li><a class="uri" href="Autostereoscopy" title="wikilink">Autostereoscopy</a></li>
<li><a href="Epipolar_geometry" title="wikilink">Epipolar geometry</a></li>
<li><a href="Computer_vision" title="wikilink">Computer vision</a></li>
<li><a href="Stereo_camera" title="wikilink">Stereo camera</a></li>
<li><a href="Stereoscopic_Depth_Rendition" title="wikilink">Stereoscopic Depth Rendition</a></li>
<li><a class="uri" href="Stereopsis" title="wikilink">Stereopsis</a></li>
<li><a class="uri" href="Stereophotogrammetry" title="wikilink">Stereophotogrammetry</a></li>
<li><a href="3D_reconstruction_from_multiple_images" title="wikilink">3D reconstruction from multiple images</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://pages.cs.wisc.edu/~chaol/cs766/">Tutorial on uncalibrated stereo vision</a></li>
<li><a href="http://www.mathworks.com/discovery/stereo-vision.html">Learn about stereo vision with MATLAB</a></li>
<li><a href="http://www2.ece.ohio-state.edu/ion/documents/IEEE_aero.pdf">Stereo Vision and Rover Navigation Software for Planetary Exploration</a></li>
</ul>

<p>"</p>

<p><a href="Category:Applications_of_computer_vision" title="wikilink">Category:Applications of computer vision</a> <a class="uri" href="Category:Vision" title="wikilink">Category:Vision</a> <a class="uri" href="Category:Stereoscopy" title="wikilink">Category:Stereoscopy</a> <a class="uri" href="Category:Stereophotogrammetry" title="wikilink">Category:Stereophotogrammetry</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">C. Je, S. W. Lee, and R.-H. Park. <a href="http://dx.doi.org/10.1007/978-3-540-24670-1_8">High-Contrast Color-Stripe Pattern for Rapid Structured-Light Range Imaging</a>. Computer Vision – ECCV 2004, LNCS 3021, pp. 95–107, Springer-Verlag Berlin Heidelberg, May 10, 2004.<a href="#fnref2">↩</a></li>
<li id="fn3">C. Je, S. W. Lee, and R.-H. Park. <a href="http://dx.doi.org/10.1016/j.optcom.2012.01.025">Colour-Stripe Permutation Pattern for Rapid Structured-Light Range Imaging</a>. Optics Communications, Volume 285, Issue 9, pp. 2320-2331, May 1, 2012.<a href="#fnref3">↩</a></li>
<li id="fn4">W. Jang, C. Je, Y. Seo, and S. W. Lee. <a href="http://dx.doi.org/10.1016/j.optlaseng.2013.05.001">Structured-Light Stereo: Comparative Analysis and Integration of Structured-Light and Active Stereo for Measuring Dynamic Shape</a>. Optics and Lasers in Engineering, Volume 51, Issue 11, pp. 1255-1264, November, 2013.<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
