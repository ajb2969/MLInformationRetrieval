<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="948">De Bruijn sequence</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>De Bruijn sequence</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p> In <a href="combinatorics" title="wikilink">combinatorial</a> <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <em>k</em>-ary <strong>De Bruijn sequence</strong>  of order <em>n</em>, named after the Dutch mathematician <a href="Nicolaas_Govert_de_Bruijn" title="wikilink">Nicolaas Govert de Bruijn</a>, is a <a href="cyclic_sequence" title="wikilink">cyclic sequence</a> of a given <a href="alphabet_(computer_science)" title="wikilink">alphabet</a> <em>A</em> with size <em>k</em> for which every possible <a class="uri" href="subsequence" title="wikilink">subsequence</a> of length <em>n</em> in <em>A</em> appears as a sequence of consecutive characters exactly once.</p>

<p>Each  has length <em>k</em><sup><em>n</em></sup>.</p>

<p>There are 

<math display="inline" id="De_Bruijn_sequence:0">
 <semantics>
  <mstyle displaystyle="true">
   <mfrac>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>k</mi>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
      <mo>)</mo>
     </mrow>
     <msup>
      <mi>k</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </msup>
    <msup>
     <mi>k</mi>
     <mi>n</mi>
    </msup>
   </mfrac>
  </mstyle>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <factorial></factorial>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{\left(k!\right)^{k^{n-1}}}{k^{n}}
  </annotation>
 </semantics>
</math>

 distinct De Bruijn sequences .</p>

<p>According to de Bruijn,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> the existence of De Bruijn sequences for each order together with the above properties were first proved, for the case of alphabets with two elements, by Camille Flye Sainte-Marie in 1894,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> whereas the generalization to larger alphabets is originally due to <a href="Tatyana_Pavlovna_Ehrenfest" title="wikilink">Tanja van Aardenne-Ehrenfest</a> and himself.</p>
<h2 id="history">History</h2>

<p>The earliest known example of a De Bruijn sequence comes from <a href="Sanskrit_prosody" title="wikilink">Sanskrit prosody</a> where, since the work of <a class="uri" href="Pingala" title="wikilink">Pingala</a>, each possible three-syllable pattern of long and short syllables is given a name, such as 'y' for short–long–long and 'm' for long–long–long. To remember these names, the mnemoic <em>yamātārājabhānasalagam</em> is used, in which each three-syllable pattern occurs starting at its name: 'yamātā' has a short–long–long pattern, 'mātārā' has a long–long–long pattern, and so on, until 'salagam' which has a short–short–long pattern because of the final consonant. This mnemonic, equivalent to a De Bruijn sequence on binary 3-tuples, is of unknown antiquity, but is at least as old as <a href="C._P._Brown" title="wikilink">C. P. Brown</a>'s 1869 book on Sanskrit prosody that mentions it and considers it "an ancient line, written by <a class="uri" href="Pāṇini" title="wikilink">Pāṇini</a>".<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>In 1894, A. de Rivière raised the question in an issue of the French problem journal <em><a href="L'Intermédiaire_des_Mathématiciens" title="wikilink">L'Intermédiaire des Mathématiciens</a></em>, of the existence of a circular arrangement of length 

<math display="inline" id="De_Bruijn_sequence:1">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

 which contains all 

<math display="inline" id="De_Bruijn_sequence:2">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

 binary sequences of length 

<math display="inline" id="De_Bruijn_sequence:3">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


. The problem was solved, along with the count 

<math display="inline" id="De_Bruijn_sequence:4">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{2^{n-1}-n}
  </annotation>
 </semantics>
</math>

, by C. Flye Sainte-Marie in the same year.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> This was largely forgotten, and  proved the existence of such cycles for general alphabet size in place of 2, with an algorithm for constructing them. Finally, when in 1944 <a href="Kees_Posthumus" title="wikilink">Kees Posthumus</a> conjectured the count 

<math display="inline" id="De_Bruijn_sequence:5">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{2^{n-1}-n}
  </annotation>
 </semantics>
</math>

 for binary sequences, de Bruijn proved the conjecture in 1946, through which the problem became well-known.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p><a href="Karl_Popper" title="wikilink">Karl Popper</a> independently describes these objects in his <em><a href="The_Logic_of_Scientific_Discovery" title="wikilink">The Logic of Scientific Discovery</a></em> (1934), calling them "shortest random-like sequences".<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="examples">Examples</h2>
<ul>
<li>Taking <em>A</em> = {0, 1}, there are two distinct <em>B</em>(2, 3): 00010111 and 11101000, one being the reverse or negation of the other.</li>
</ul>
<ul>
<li>Two of the 2048 possible <em>B</em>(2, 5) in the same alphabet are 00000100011001010011101011011111 and 00000101001000111110111001101011.</li>
</ul>
<h2 id="construction">Construction</h2>

<p>The De Bruijn sequences can be constructed by taking a <a href="Hamiltonian_path" title="wikilink">Hamiltonian path</a> of an <em>n</em>-dimensional <a href="De_Bruijn_graph" title="wikilink">De Bruijn graph</a> over <em>k</em> symbols (or equivalently, a <a href="Eulerian_cycle" title="wikilink">Eulerian cycle</a> of a (<em>n</em> − 1)-dimensional De Bruijn graph).<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>An alternative construction involves concatenating together, in lexicographic order, all the <a href="Lyndon_word" title="wikilink">Lyndon words</a> whose length divides <em>n</em>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>De Bruijn sequences can also be constructed using <a href="shift_register" title="wikilink">shift registers</a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> or via <a href="finite_field" title="wikilink">finite fields</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="example">Example</h3>
<figure><b>(Figure)</b>
<figcaption>A De Bruijn graph. Every four-digit sequence occurs exactly once if one traverses every edge exactly once and returns to one's starting point (an Eulerian cycle). Every three-digit sequence occurs exactly once if one visits every node exactly once (a Hamiltonian path).</figcaption>
</figure>

<p>Goal: to construct a <em>B</em>(2, 4) De Bruijn sequence of length 2<sup>4</sup> = 16 using Eulerian (<em>n</em> − 1 = 4 − 1 = 3) 3-D De Bruijn graph cycle.</p>

<p>Each edge in this 3-dimensional De Bruijn graph corresponds to a sequence of four digits: the three digits that label the vertex that the edge is leaving followed by the one that labels the edge. If one traverses the edge labeled 1 from 000, one arrives at 001, thereby indicating the presence of the subsequence 0001 in the De Bruijn sequence. To traverse each edge exactly once is to use each of the 16 four-digit sequences exactly once.</p>

<p>For example, suppose we follow the following Eulerian path through these nodes:</p>
<dl>
<dd>000, 000, 001, 011, 111, 111, 110, 101, 011,
</dd>
</dl>
<dl>
<dd><dl>
<dd>110, 100, 001, 010, 101, 010, 100, 000.
</dd>
</dl>
</dd>
</dl>

<p>These are the output sequences of length <em>k</em>:</p>
<dl>
<dd>0 0 0 0
</dd>
<dd>_ 0 0 0 1
</dd>
<dd>_ _ 0 0 1 1
</dd>
</dl>

<p>This corresponds to the following De Bruijn sequence:</p>
<dl>
<dd>0 0 0 0 1 1 1 1 0 1 1 0 0 1 0 1
</dd>
</dl>

<p>The eight vertices appear in the sequence in the following way:</p>

<p><code>      {0  0  0} 0  1  1  1  1  0  1  1  0  0  1  0  1</code><br/>
<code>       0 {0  0  0} 1  1  1  1  0  1  1  0  0  1  0  1</code><br/>
<code>       0  0 {0  0  1} 1  1  1  0  1  1  0  0  1  0  1</code><br/>
<code>       0  0  0 {0  1  1} 1  1  0  1  1  0  0  1  0  1</code><br/>
<code>       0  0  0  0 {1  1  1} 1  0  1  1  0  0  1  0  1</code><br/>
<code>       0  0  0  0  1 {1  1  1} 0  1  1  0  0  1  0  1</code><br/>
<code>       0  0  0  0  1  1 {1  1  0} 1  1  0  0  1  0  1</code><br/>
<code>       0  0  0  0  1  1  1 {1  0  1} 1  0  0  1  0  1</code><br/>
<code>       0  0  0  0  1  1  1  1 {0  1  1} 0  0  1  0  1</code><br/>
<code>       0  0  0  0  1  1  1  1  0 {1  1  0} 0  1  0  1</code><br/>
<code>       0  0  0  0  1  1  1  1  0  1 {1  0  0} 1  0  1</code><br/>
<code>       0  0  0  0  1  1  1  1  0  1  1 {0  0  1} 0  1</code><br/>
<code>       0  0  0  0  1  1  1  1  0  1  1  0 {0  1  0} 1</code><br/>
<code>       0  0  0  0  1  1  1  1  0  1  1  0  0 {1  0  1}</code><br/>
<code>   ... 0} 0  0  0  1  1  1  1  0  1  1  0  0  1 {0  1 ...</code><br/>
<code>   ... 0  0} 0  0  1  1  1  1  0  1  1  0  0  1  0 {1 ...</code></p>

<p>...and then we return to the starting point. Each of the eight 3-digit sequences (corresponding to the eight vertices) appears exactly twice, and each of the sixteen 4-digit sequences (corresponding to the 16 edges) appears exactly once.</p>
<h3 id="algorithm">Algorithm</h3>

<p>The following <a href="Python_(programming_language)" title="wikilink">Python</a> code calculates a De Bruijn sequence, given <em>k</em> and <em>n</em>, based on an algorithm from <a href="Frank_Ruskey" title="wikilink">Frank Ruskey</a>'s <em>Combinatorial Generation</em>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">
<span class="kw">def</span> de_bruijn(k, n):
    <span class="co">"""</span>
<span class="co">    De Bruijn sequence for alphabet k</span>
<span class="co">    and subsequences of length n.</span>
<span class="co">    """</span>
    <span class="cf">try</span>:
        <span class="co"># let's see if k can be cast to an integer;</span>
        <span class="co"># if so, make our alphabet a list</span>
        _ <span class="op">=</span> <span class="bu">int</span>(k)
        alphabet <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">str</span>, <span class="bu">range</span>(k)))

    <span class="cf">except</span> (<span class="pp">ValueError</span>, <span class="pp">TypeError</span>):
        alphabet <span class="op">=</span> k
        k <span class="op">=</span> <span class="bu">len</span>(k)

    a <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> k <span class="op">*</span> n
    sequence <span class="op">=</span> []

    <span class="kw">def</span> db(t, p):
        <span class="cf">if</span> t <span class="op">&gt;</span> n:
            <span class="cf">if</span> n <span class="op">%</span> p <span class="op">==</span> <span class="dv">0</span>:
                sequence.extend(a[<span class="dv">1</span>:p <span class="op">+</span> <span class="dv">1</span>])
        <span class="cf">else</span>:
            a[t] <span class="op">=</span> a[t <span class="op">-</span> p]
            db(t <span class="op">+</span> <span class="dv">1</span>, p)
            <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(a[t <span class="op">-</span> p] <span class="op">+</span> <span class="dv">1</span>, k):
                a[t] <span class="op">=</span> j
                db(t <span class="op">+</span> <span class="dv">1</span>, t)
    db(<span class="dv">1</span>, <span class="dv">1</span>)
    <span class="cf">return</span> <span class="st">""</span>.join(alphabet[i] <span class="cf">for</span> i <span class="op">in</span> sequence)

<span class="bu">print</span>(de_bruijn(<span class="dv">2</span>, <span class="dv">3</span>))
<span class="bu">print</span>(de_bruijn(<span class="st">"abcd"</span>, <span class="dv">2</span>))</code></pre></div>

<p>which prints</p>

<p><code>00010111</code><br/>
<code>aabacadbbcbdccdd</code></p>
<h2 id="uses">Uses</h2>

<p>The sequence can be used to shorten a brute-force attack on a <a href="Personal_Identification_Number" title="wikilink">PIN</a>-like code lock that does not have an "enter" key and accepts the last <em>n</em> digits entered. For example, a <a href="digital_door_lock" title="wikilink">digital door lock</a> with a 4-digit code would have <em>B</em>(10, 4) solutions, with length . Therefore, only at most  (as the solutions are cyclic) presses are needed to open the lock. Trying all codes separately would require  presses.</p>

<p>The symbols of a De Bruijn sequence written around a circular object (such as a wheel of a <a class="uri" href="robot" title="wikilink">robot</a>) can be used to identify its <a class="uri" href="angle" title="wikilink">angle</a> by examining the <em>n</em> consecutive symbols facing a fixed point. <a href="Gray_code" title="wikilink">Gray codes</a> can be used as similar rotary positional encoding mechanisms.</p>

<p>De Bruijn cycles are of general use in neuroscience and psychology experiments that examine the effect of stimulus order upon neural systems,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> and can be specially crafted for use with <a href="functional_magnetic_resonance_imaging" title="wikilink">functional magnetic resonance imaging</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>A De Bruijn sequence can be used to quickly find the index of the <a href="Least_significant_bit" title="wikilink">LSB</a> or <a href="Most_significant_bit" title="wikilink">MSB</a> in a <a href="Word_(data_type)" title="wikilink">word</a> using <a href="bitwise_operation" title="wikilink">bitwise operations</a>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> An example of returning the index of the least significant bit from a 32 bit unsigned integer is given below using <a href="bit_manipulation" title="wikilink">bit manipulation</a>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">int</span> v;   
<span class="dt">int</span> r;           
<span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> MultiplyDeBruijnBitPosition[<span class="dv">32</span>] = 
{
  <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">28</span>, <span class="dv">2</span>, <span class="dv">29</span>, <span class="dv">14</span>, <span class="dv">24</span>, <span class="dv">3</span>, <span class="dv">30</span>, <span class="dv">22</span>, <span class="dv">20</span>, <span class="dv">15</span>, <span class="dv">25</span>, <span class="dv">17</span>, <span class="dv">4</span>, <span class="dv">8</span>, 
  <span class="dv">31</span>, <span class="dv">27</span>, <span class="dv">13</span>, <span class="dv">23</span>, <span class="dv">21</span>, <span class="dv">19</span>, <span class="dv">16</span>, <span class="dv">7</span>, <span class="dv">26</span>, <span class="dv">12</span>, <span class="dv">18</span>, <span class="dv">6</span>, <span class="dv">11</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">9</span>
};
r = MultiplyDeBruijnBitPosition[((<span class="dt">uint32_t</span>)((v &amp; -v) * <span class="bn">0x077CB531U</span>)) &gt;&gt; <span class="dv">27</span>];</code></pre></div>

<p>The index of the LSB in <em>v</em> is stored in <em>r</em> and if <em>v</em> has no set bits the operation returns 0. The constant, 0x077CB531U, in the expression is a De Bruijn sequence.</p>
<h2 id="de-bruijn-torus">De Bruijn torus</h2>

<p>A <a href="De_Bruijn_torus" title="wikilink">De Bruijn torus</a> is a toroidal array with the property that every <em>k</em>-ary <em>m</em>-by-<em>n</em> matrix occurs exactly once. (It is not necessary that the array be expressed toroidally; the array can be mapped into a 2-dimensional array. Because it is toroidal it "wraps around" on all 4 sides.)</p>

<p>Such a pattern can be used for two-dimensional positional encoding in a fashion analogous to that described above for rotary encoding. Position can be determined by examining the <em>m</em>-by-<em>n</em> matrix directly adjacent to the sensor, and calculating its position on the De Bruijn torus.</p>
<h2 id="de-bruijn-decoding">De Bruijn decoding</h2>

<p>Computing the position of a particular unique tuple or matrix in a De Bruijn sequence or torus is known as the De Bruijn Decoding Problem. Efficient  decoding algorithms exists for special, recursively constructed sequences<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> and extend to the two dimensional case.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> De Bruijn decoding is of interest, e.g., in cases where large sequences or tori are used for positional encoding.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="De_Bruijn_graph" title="wikilink">De Bruijn graph</a></li>
<li><a href="De_Bruijn_torus" title="wikilink">De Bruijn torus</a></li>
<li><a href="Normal_number" title="wikilink">Normal number</a></li>
<li><a href="Linear_feedback_shift_register" title="wikilink">Linear feedback shift register</a></li>
<li><a href="n-sequence" title="wikilink"><em>n</em>-sequence</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li><a href="http://chessprogramming.wikispaces.com/De+Bruijn+sequence">De Bruijn sequence</a></li>
<li><a href="http://www.theory.csc.uvic.ca/~cos/">Combinatorial Object Server</a>, includes a De Bruijn sequence generator among many others</li>
<li><a href="http://www.hakank.org/comb/debruijn.cgi">CGI generator</a></li>
<li><a href="http://www.hakank.org/comb/deBruijnApplet.html">Applet generator</a></li>
<li><a href="http://jgeisler0303.github.io/deBruijnDecode/">Javascript generator and decoder</a>. Implementation of J. Tuliani's algorithm.</li>
<li><a href="http://www.stefangeens.com/000435.html">Door code lock</a></li>
<li><a href="http://lcni.uoregon.edu/~dow/Geek_art/Minimal_combinatorics/Minimal_arrays_containing_all_combinations.html">Minimal arrays containing all sub-array combinations of symbols: De Bruijn sequences and tori</a></li>
</ul>

<p>"</p>

<p><a href="Category:Binary_sequences" title="wikilink">Category:Binary sequences</a> <a href="Category:Enumerative_combinatorics" title="wikilink">Category:Enumerative combinatorics</a> <a href="Category:Articles_with_example_Python_code" title="wikilink">Category:Articles with example Python code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="C._P._Brown" title="wikilink">C. P. Brown</a>, 1869, <em>Sanskrit Prosody and Numerical Symbols Explained</em>, <a href="https://archive.org/stream/sanskritprosody00browgoog#page/n44/mode/2up">p. 28</a><a href="#fnref3">↩</a></li>
<li id="fn4">Subhash Kak, 2000, <a href="http://202.41.82.144/rawdataupload/upload/insa/INSA_2/200059d2_123.pdf">Yamātārājabhānasalagāṃ an interesting combinatoric sūtra</a>, Indian Journal of History of Science, 35.2 (2000), 123–127.<a href="#fnref4">↩</a></li>
<li id="fn5">Rachel W. Hall. <a href="http://www.sju.edu/~rhall/mathforpoets.pdf">Math for poets and drummers</a>. <em>Math Horizons</em> <strong>15</strong> (2008) 10–11.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">. Reprinted in Wardhaugh, Benjamin, ed. (2012), <em>A Wealth of Numbers: An Anthology of 500 Years of Popular Mathematics Writing</em>, Princeton Univ. Press, pp. 139–144.<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">.<a href="#fnref11">↩</a></li>
<li id="fn12">According to , the sequence generated in this way was first described (with a different generation method) by , and the connection between it and Lyndon words was observed by .<a href="#fnref12">↩</a></li>
<li id="fn13">.<a href="#fnref13">↩</a></li>
<li id="fn14">. See in particular "the finite field approach", pp. 136–139.<a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16">GK Aguirre, MG Mattar, L Magis-Weinberg. (2011) . <em>NeuroImage</em> 56: 1293–1300<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20">.<a href="#fnref20">↩</a></li>
<li id="fn21">.<a href="#fnref21">↩</a></li>
</ol>
</section>
</body>

