<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="360">Shannon capacity of a graph</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Shannon capacity of a graph</h1>
<hr/>

<p>In <a href="graph_theory" title="wikilink">graph theory</a>, the <strong>Shannon capacity of a graph</strong> is a <a href="graph_invariant" title="wikilink">graph invariant</a> defined from the number of <a href="independent_set_(graph_theory)" title="wikilink">independent sets</a> of <a href="strong_graph_product" title="wikilink">strong graph products</a>. It measures the <a href="Shannon_capacity" title="wikilink">Shannon capacity</a> of a <a href="communications_channel" title="wikilink">communications channel</a> defined from the graph, and is upper bounded by the <a href="Lovász_number" title="wikilink">Lovász number</a>, which can be computed in <a href="polynomial_time" title="wikilink">polynomial time</a>. However, the <a href="Computational_complexity_theory" title="wikilink">computational complexity</a> of the Shannon capacity itself remains unknown.</p>
<h2 id="graph-models-of-communication-channels">Graph models of communication channels</h2>

<p> The Shannon capacity models the amount of information that can be transmitted across a noisy communication channel in which certain signal values can be confused with each other. In this application, the <strong>confusion graph</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> or <strong>confusability graph</strong> describes the pairs of values that can be confused. For instance, suppose that a communications channel has five discrete signal values, any one of which can be transmitted in a single time step. These values may be modeled mathematically as the five numbers 0, 1, 2, 3, or 4 in <a href="modular_arithmetic" title="wikilink">modular arithmetic</a> modulo 5. However, suppose that when a value <em>i</em> is sent across the channel, the value that is received is <em>i</em> + <em>ξ</em> (mod 5) where <em>ξ</em> represents the noise on the channel and may be any real number in the open interval −1 5 of length 5, in which the vertices correspond to the five values that can be transmitted and the edges of the graph represent values that can be confused with each other.</p>

<p>For this example, it is possible to choose two values that can be transmitted in each time step without ambiguity, for instance, the values 1 and 3. These values are far enough apart that they can't be confused with each other: when the recipient receives a value <em>x</em> in the range 0 <em>n</em> different messages. Two is the maximum number of values that the recipient can distinguish from each other: every subset of three or more of the values 0, 1, 2, 3, 4 includes at least one pair that can be confused with each other. Even though the channel has five values that can be sent per time step, effectively only two of them can be used with this coding scheme.</p>

<p>However, more complicated coding schemes allow a greater amount of information to be sent across the same channel, by using codewords of length greater than one. For instance, suppose that in two consecutive steps the sender transmits one of the five <a href="code_word" title="wikilink">code words</a> "11", "23", "35", "54", or "42". (Here, the quotation marks indicate that these words should be interpreted as <a href="string_(computer_science)" title="wikilink">strings</a> of symbols, not as decimal numbers.) Each pair of these code words includes at least one position where its values differ by two or more modulo 5; for instance, "11" and "23" differ by two in their second position, while "23" and "42" differ by two in their first position. Therefore, a recipient of one of these code words will always be able to determine unambiguously which one was sent: no two of these code words can be confused with each other. By using this method, in <em>n</em> steps of communication, the sender can communicate up to 5<sup><em>n</em>/2</sup> messages, significantly more than the 2<sup><em>n</em></sup> that could be transmitted with the simpler one-digit code. The effective number of values that can be transmitted per unit time step is (5<sup><em>n</em>/2</sup>)<sup>1/<em>n</em></sup> = √5. In graph-theoretic terms, this means that the Shannon capacity of the 5-cycle is at least √5. As  showed, this bound is tight: it is not possible to find a more complicated system of code words that allows even more different messages to be sent in the same amount of time, so the Shannon capacity of the 5-cycle is exactly √5.</p>
<h2 id="relation-to-independent-sets">Relation to independent sets</h2>

<p>If a graph <em>G</em> represents a set of symbols and the pairs of symbols that can be confused with each other, then a subset <em>S</em> of symbols avoids all confusable pairs if and only if <em>S</em> is an <a href="independent_set_(graph_theory)" title="wikilink">independent set</a> in the graph, a subset of vertices that does not include both endpoints of any edge. The maximum possible size of a subset of the symbols that can all be distinguished from each other is the <a href="independence_number" title="wikilink">independence number</a> <em>α</em>(<em>G</em>) of the graph, the size of its <a href="maximum_independent_set" title="wikilink">maximum independent set</a>. For instance, <em>α</em>(<em>C</em><sub>5</sub>) = 2: the 5-cycle has independent sets of two vertices, but not larger.</p>

<p>For codewords of longer lengths, one can use independent sets in larger graphs to describe the sets of codewords that can be transmitted without confusion. For instance, for the same example of five symbols whose confusion graph is <em>C</em><sub>5</sub>, there are 25 strings of length two that can be used in a length-2 coding scheme. These strings may be represented by the vertices of a graph with 25 vertices. In this graph, each vertex has eight neighbors, the eight strings that it can be confused with. A subset of length-two strings forms a code with no possible confusion if and only if it corresponds to an independent set of this graph. The set of code words {"11", "23", "35", "54", "42"} forms one of these independent sets, of maximum size.</p>

<p>If <em>G</em> is a graph representing the signals and confusable pairs of a channel, then the graph representing the length-two codewords and their confusable pairs is <em>G</em> ⊠ <em>G</em>, where the symbol "⊠" represents the <a href="strong_product_of_graphs" title="wikilink">strong product of graphs</a>. This is a graph that has a vertex for each pair (<em>u</em>,<em>v</em>) of a vertex in the first argument of the product and a vertex in the second argument of the product. Two distinct pairs (<em>u</em><sub>1</sub>,<em>v</em><sub>1</sub>) and (<em>u</em><sub>2</sub>,<em>v</em><sub>2</sub>) are adjacent in the strong product if and only if <em>u</em><sub>1</sub> and <em>u</em><sub>2</sub> are identical or adjacent, and <em>v</em><sub>1</sub> and <em>v</em><sub>2</sub> are identical or adjacent. More generally, the codewords of length <em>k</em> can be represented by the graph <em>G</em><sub><em>k</em></sub>, the <em>k</em>-fold strong product of <em>G</em> with itself, and the maximum number of codewords of this length that can be transmitted without confusion is given by the independence number <em>α</em>(<em>G</em><sub><em>k</em></sub>). The effective number of signals transmitted per unit time step is the <em>k</em>th root of this number, <em>α</em>(<em>G</em><sub><em>k</em></sub>)<sup>1/<em>k</em></sup>.</p>

<p>Using these concepts, the Shannon capacity may be defined as</p>

<p>
<math display="block" id="Shannon_capacity_of_a_graph:0">
<semantics>
<mrow>
<mrow>
<mrow>
<mi mathvariant="normal">Θ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>G</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo movablelimits="false">sup</mo>
<mi>k</mi>
</munder>
<mroot>
<mrow>
<mi>α</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>G</mi>
<mi>k</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mi>k</mi>
</mroot>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>k</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<mroot>
<mrow>
<mi>α</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>G</mi>
<mi>k</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mi>k</mi>
</mroot>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>normal-Θ</ci>
<ci>G</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">supremum</csymbol>
<ci>k</ci>
</apply>
<apply>
<root></root>
<degree>
<ci>k</ci>
</degree>
<apply>
<times></times>
<ci>α</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>k</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<root></root>
<degree>
<ci>k</ci>
</degree>
<apply>
<times></times>
<ci>α</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>G</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Theta(G)=\sup_{k}\sqrt[k]{\alpha(G_{k})}=\lim_{k\rightarrow\infty}\sqrt[k]{%
\alpha(G_{k})},
  </annotation>
</semantics>
</math>

 the limit (as <em>k</em> becomes arbitrarily large) of the effective number of signals per time step of arbitrarily long confusion-free codes.</p>
<h2 id="computational-complexity">Computational complexity</h2>

<p>The <a href="Computational_complexity_theory" title="wikilink">computational complexity</a> of the Shannon capacity is unknown, and even the value of the Shannon capacity for certain small graphs such as <em>C</em><sub>7</sub> (a <a href="cycle_graph" title="wikilink">cycle graph</a> of seven vertices) remains unknown.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>A natural approach to this problem would be to compute a finite number of powers of the given graph <em>G</em>, find their independence numbers, and infer from these numbers some information about the limiting behavior of the sequence from which the Shannon capacity is defined. However (even ignoring the computational difficulty of computing the independence numbers of these graphs, an <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> problem) the unpredictable behavior of the sequence of independence numbers of powers of <em>G</em> implies that this approach cannot be used to accurately approximate the Shannon capacity.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="upper-bounds">Upper bounds</h2>

<p>In part because the Shannon capacity is difficult to compute, researchers have looked for other graph invariants that are easy to compute and that provide bounds on the Shannon capacity.</p>
<h3 id="lovász-number">Lovász number</h3>

<p>The <a href="Lovász_number" title="wikilink">Lovász number</a> ϑ(<em>G</em>) is a different graph invariant, that can be computed numerically to high accuracy in <a href="polynomial_time" title="wikilink">polynomial time</a> by an algorithm based on the <a href="ellipsoid_method" title="wikilink">ellipsoid method</a>. The Shannon capacity of a graph <em>G</em> is bounded from below by α(<em>G</em>), and from above by ϑ(<em>G</em>).<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In some cases, ϑ(<em>G</em>) and the Shannon capacity coincide; for instance, for the graph of a <a class="uri" href="pentagon" title="wikilink">pentagon</a>, both are equal to 

<math display="inline" id="Shannon_capacity_of_a_graph:1">
<semantics>
<msqrt>
<mn>5</mn>
</msqrt>
<annotation-xml encoding="MathML-Content">
<apply>
<root></root>
<cn type="integer">5</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sqrt{5}
  </annotation>
</semantics>
</math>

. However, there exist other graphs for which the Shannon capacity and the Lovász number differ.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="haemers-bound">Haemers' bound</h3>

<p>Haemers provided another upper bound on the Shannon capacity, which is sometimes better than Lovász bound:<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>
<math display="block" id="Shannon_capacity_of_a_graph:2">
<semantics>
<mrow>
<mrow>
<mrow>
<mi mathvariant="normal">Θ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>G</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≤</mo>
<mrow>
<mi>R</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>G</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mi>min</mi>
<mi>B</mi>
</munder>
<mrow>
<mo>rank</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>B</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<leq></leq>
<apply>
<times></times>
<ci>normal-Θ</ci>
<ci>G</ci>
</apply>
<apply>
<times></times>
<ci>R</ci>
<ci>G</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<min></min>
<ci>B</ci>
</apply>
<apply>
<ci>rank</ci>
<ci>B</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Theta(G)\leq R(G)=\min_{B}\operatorname{rank}(B),
  </annotation>
</semantics>
</math>

 where <em>B</em> is an <em>n</em> × <em>n</em> matrix over some <a href="field_(mathematics)" title="wikilink">field</a>, such that <em>b<sub>ii</sub></em> ≠ 0 and <em>b<sub>ij</sub></em> = 0 if vertices <em>i</em> and <em>j</em> are not adjacent.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Graph_invariants" title="wikilink">Category:Graph invariants</a> <a href="Category:Information_theory" title="wikilink">Category:Information theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">. The definition here corrects a typo in this paper.<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
