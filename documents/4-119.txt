   De Casteljau's algorithm      De Casteljau's algorithm  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     In the mathematical field of numerical analysis , De Casteljau's algorithm is a recursive method to evaluate polynomials in Bernstein form or Bézier curves , named after its inventor Paul de Casteljau . De Casteljau's algorithm can also be used to split a single Bézier curve into two Bézier curves at an arbitrary parameter value.  Although the algorithm is slower for most architectures when compared with the direct approach, it is more numerically stable .  Definition  A Bézier curve B (of degree n , with control points     β  0   ,  …  ,   β  n       subscript  β  0   normal-…   subscript  β  n     \beta_{0},\ldots,\beta_{n}   ) can be written in Bernstein form as follows       B   (  t  )    =    ∑   i  =  0   n     β  i    b   i  ,  n     (  t  )           B  t     superscript   subscript     i  0    n      subscript  β  i    subscript  b   i  n    t      B(t)=\sum_{i=0}^{n}\beta_{i}b_{i,n}(t)   ,  where b is a Bernstein basis polynomial        b   i  ,  n     (  t  )    =    (     n      i     )     (   1  -  t   )    n  -  i     t  i           subscript  b   i  n    t      binomial  n  i    superscript    1  t     n  i     superscript  t  i      b_{i,n}(t)={n\choose i}(1-t)^{n-i}t^{i}   .  The curve at point t 0 can be evaluated with the recurrence relation        β  i   (  0  )    :=    β  i   ,  i   =  0   ,   …  ,  n      formulae-sequence     assign   superscript   subscript  β  i   0      subscript  β  i   ,  i        0     normal-…  n     \beta_{i}^{(0)}:=\beta_{i}\mbox{ , }i=0,\ldots,n           β  i   (  j  )    :=     β  i   (   j  -  1   )     (   1  -   t  0    )    +    β   i  +  1    (   j  -  1   )     t  0   ,  i    =  0   ,    …  ,   n  -   j  ,  j     =  1   ,   …  ,  n      formulae-sequence     assign   superscript   subscript  β  i   j        superscript   subscript  β  i     j  1      1   subscript  t  0        superscript   subscript  β    i  1      j  1     subscript  t  0   ,  i         0       normal-…    n    j  ,  j     1    normal-…  n     \beta_{i}^{(j)}:=\beta_{i}^{(j-1)}(1-t_{0})+\beta_{i+1}^{(j-1)}t_{0}\mbox{ , }%
 i=0,\ldots,n-j\mbox{ , }j=1,\ldots,n     Then, the evaluation of   B   B   B   at point    t  0     subscript  t  0    t_{0}   can be evaluated in   n   n   n   steps of the algorithm. The result    B   (   t  0   )       B   subscript  t  0     B(t_{0})   is given by :        B   (   t  0   )    =   β  0   (  n  )     .        B   subscript  t  0     superscript   subscript  β  0   n     B(t_{0})=\beta_{0}^{(n)}.     Moreover, the Bézier curve   B   B   B   can be split at point    t  0     subscript  t  0    t_{0}   into two curves with respective control points :       β  0   (  0  )    ,   β  0   (  1  )    ,  …  ,   β  0   (  n  )        superscript   subscript  β  0   0    superscript   subscript  β  0   1   normal-…   superscript   subscript  β  0   n     \beta_{0}^{(0)},\beta_{0}^{(1)},\ldots,\beta_{0}^{(n)}          β  0   (  n  )    ,   β  1   (   n  -  1   )    ,  …  ,   β  n   (  0  )        superscript   subscript  β  0   n    superscript   subscript  β  1     n  1    normal-…   superscript   subscript  β  n   0     \beta_{0}^{(n)},\beta_{1}^{(n-1)},\ldots,\beta_{n}^{(0)}     Example implementation  Here is an example implementation of De Casteljau's algorithm in Haskell :  deCasteljau ::  Double  -> [( Double , Double )] -> ( Double , Double )
 deCasteljau t [b] = b
 deCasteljau t coefs = deCasteljau t reduced where reduced = zipWith (lerpP t) coefs (tail coefs)
     lerpP t (x0, y0) (x1, y1) = (lerp t x0 x1, lerp t y0 y1)
     lerp t a b = t * b + ( 1  - t) * a  Notes  When doing the calculation by hand it is useful to write down the coefficients in a triangle scheme as         β  0       =   β  0   (  0  )                         β  0   (  1  )               β  1       =   β  1   (  0  )                           ⋱         ⋮       ⋮        β  0   (  n  )                          β   n  -  1        =   β   n  -  1    (  0  )                         β   n  -  1    (  1  )               β  n       =   β  n   (  0  )                     subscript  β  0     absent   superscript   subscript  β  0   0    absent  absent  absent    absent  absent   superscript   subscript  β  0   1   absent  absent     subscript  β  1     absent   superscript   subscript  β  1   0    absent  absent  absent    absent  absent  absent  normal-⋱  absent    normal-⋮  absent  normal-⋮  absent   superscript   subscript  β  0   n     absent  absent  absent  absent  absent     subscript  β    n  1      absent   superscript   subscript  β    n  1    0    absent  absent  absent    absent  absent   superscript   subscript  β    n  1    1   absent  absent     subscript  β  n     absent   superscript   subscript  β  n   0    absent  absent  absent     \begin{matrix}\beta_{0}&=\beta_{0}^{(0)}&&&\\
 &&\beta_{0}^{(1)}&&\\
 \beta_{1}&=\beta_{1}^{(0)}&&&\\
 &&&\ddots&\\
 \vdots&&\vdots&&\beta_{0}^{(n)}\\
 &&&&\\
 \beta_{n-1}&=\beta_{n-1}^{(0)}&&&\\
 &&\beta_{n-1}^{(1)}&&\\
 \beta_{n}&=\beta_{n}^{(0)}&&&\\
 \end{matrix}     When choosing a point t 0 to evaluate a Bernstein polynomial we can use the two diagonals of the triangle scheme to construct a division of the polynomial        B   (  t  )    =    ∑   i  =  0   n     β  i   (  0  )     b   i  ,  n     (  t  )   ,      t  ∈   [  0  ,  1  ]       formulae-sequence      B  t     superscript   subscript     i  0    n      superscript   subscript  β  i   0    subscript  b   i  n    t  ,       t   0  1      B(t)=\sum_{i=0}^{n}\beta_{i}^{(0)}b_{i,n}(t)\mbox{ , }\qquad t\in[0,1]     into         B  1    (  t  )    =    ∑   i  =  0   n     β  0   (  i  )     b   i  ,  n     (   t   t  0    )   ,      t  ∈   [  0  ,   t  0   ]       formulae-sequence       subscript  B  1   t     superscript   subscript     i  0    n      superscript   subscript  β  0   i    subscript  b   i  n      t   subscript  t  0    ,       t   0   subscript  t  0       B_{1}(t)=\sum_{i=0}^{n}\beta_{0}^{(i)}b_{i,n}\left(\frac{t}{t_{0}}\right)\mbox%
 { , }\qquad t\in[0,t_{0}]     and         B  2    (  t  )    =    ∑   i  =  0   n     β  i   (   n  -  i   )     b   i  ,  n     (    t  -   t  0     1  -   t  0     )   ,      t  ∈   [   t  0   ,  1  ]       formulae-sequence       subscript  B  2   t     superscript   subscript     i  0    n      superscript   subscript  β  i     n  i     subscript  b   i  n        t   subscript  t  0      1   subscript  t  0     ,       t    subscript  t  0   1      B_{2}(t)=\sum_{i=0}^{n}\beta_{i}^{(n-i)}b_{i,n}\left(\frac{t-t_{0}}{1-t_{0}}%
 \right)\mbox{ , }\qquad t\in[t_{0},1]     Example  We want to evaluate the Bernstein polynomial of degree 2 with the Bernstein coefficients       β  0   (  0  )    =   β  0        superscript   subscript  β  0   0    subscript  β  0     \beta_{0}^{(0)}=\beta_{0}          β  1   (  0  )    =   β  1        superscript   subscript  β  1   0    subscript  β  1     \beta_{1}^{(0)}=\beta_{1}          β  2   (  0  )    =   β  2        superscript   subscript  β  2   0    subscript  β  2     \beta_{2}^{(0)}=\beta_{2}   at the point t 0 .  We start the recursion with       β  0   (  1  )    =     β  0   (  0  )     (   1  -   t  0    )    +    β  1   (  0  )     t  0     =     β  0    (   1  -   t  0    )    +    β  1    t  0            superscript   subscript  β  0   1        superscript   subscript  β  0   0     1   subscript  t  0        superscript   subscript  β  1   0    subscript  t  0               subscript  β  0     1   subscript  t  0        subscript  β  1    subscript  t  0        \beta_{0}^{(1)}=\beta_{0}^{(0)}(1-t_{0})+\beta_{1}^{(0)}t_{0}=\beta_{0}(1-t_{0%
 })+\beta_{1}t_{0}          β  1   (  1  )    =     β  1   (  0  )     (   1  -   t  0    )    +    β  2   (  0  )     t  0     =     β  1    (   1  -   t  0    )    +    β  2    t  0            superscript   subscript  β  1   1        superscript   subscript  β  1   0     1   subscript  t  0        superscript   subscript  β  2   0    subscript  t  0               subscript  β  1     1   subscript  t  0        subscript  β  2    subscript  t  0        \beta_{1}^{(1)}=\beta_{1}^{(0)}(1-t_{0})+\beta_{2}^{(0)}t_{0}=\beta_{1}(1-t_{0%
 })+\beta_{2}t_{0}     and with the second iteration the recursion stops with      β  0   (  2  )      superscript   subscript  β  0   2    \displaystyle\beta_{0}^{(2)}     which is the expected Bernstein polynomial of degree 2 .  Bézier curve  When evaluating a Bézier curve of degree n in 3-dimensional space with n +1 control points P i       𝐁   (  t  )    =    ∑   i  =  0   n     𝐏  i    b   i  ,  n     (  t  )   ,  t    ∈   [  0  ,  1  ]           𝐁  t     superscript   subscript     i  0    n      subscript  𝐏  i    subscript  b   i  n    t  ,  t          0  1      \mathbf{B}(t)=\sum_{i=0}^{n}\mathbf{P}_{i}b_{i,n}(t)\mbox{ , }t\in[0,1]     with       𝐏  i   :=   (      x  i        y  i        z  i      )      assign   subscript  𝐏  i      subscript  x  i      subscript  y  i      subscript  z  i       \mathbf{P}_{i}:=\begin{pmatrix}x_{i}\\
 y_{i}\\
 z_{i}\end{pmatrix}   .  we split the Bézier curve into three separate equations        B  1    (  t  )    =    ∑   i  =  0   n     x  i    b   i  ,  n     (  t  )   ,  t    ∈   [  0  ,  1  ]            subscript  B  1   t     superscript   subscript     i  0    n      subscript  x  i    subscript  b   i  n    t  ,  t          0  1      B_{1}(t)=\sum_{i=0}^{n}x_{i}b_{i,n}(t)\mbox{ , }t\in[0,1]           B  2    (  t  )    =    ∑   i  =  0   n     y  i    b   i  ,  n     (  t  )   ,  t    ∈   [  0  ,  1  ]            subscript  B  2   t     superscript   subscript     i  0    n      subscript  y  i    subscript  b   i  n    t  ,  t          0  1      B_{2}(t)=\sum_{i=0}^{n}y_{i}b_{i,n}(t)\mbox{ , }t\in[0,1]           B  3    (  t  )    =    ∑   i  =  0   n     z  i    b   i  ,  n     (  t  )   ,  t    ∈   [  0  ,  1  ]            subscript  B  3   t     superscript   subscript     i  0    n      subscript  z  i    subscript  b   i  n    t  ,  t          0  1      B_{3}(t)=\sum_{i=0}^{n}z_{i}b_{i,n}(t)\mbox{ , }t\in[0,1]     which we evaluate individually using De Casteljau's algorithm.  Geometric interpretation  The geometric interpretation of De Casteljau's algorithm is straightforward.   Consider a Bézier curve with control points     P  0   ,  …  ,   P  n       subscript  P  0   normal-…   subscript  P  n     \scriptstyle P_{0},...,P_{n}   . Connecting the consecutive points we create the control polygon of the curve.  Subdivide now each line segment of this polygon with the ratio    t  :   (   1  -  t   )      normal-:  t    1  t     \scriptstyle t:(1-t)   and connect the points you get. This way you arrive at the new polygon having one fewer segment.  Repeat the process until you arrive at the single point - this is the point of the curve corresponding to the parameter   t   t   \scriptstyle t   .   The following picture shows this process for a cubic Bézier curve:  (Figure)  DeCasteljau1.svg   Note that the intermediate points that were constructed are in fact the control points for two new Bézier curves, both exactly coincident with the old one. This algorithm not only evaluates the curve at   t   t   \scriptstyle t   , but splits the curve into two pieces at   t   t   \scriptstyle t   , and provides the equations of the two sub-curves in Bézier form.  The interpretation given above is valid for a nonrational Bézier curve. To evaluate a rational Bézier curve in    𝐑  n     superscript  𝐑  n    \scriptstyle\mathbf{R}^{n}   , we may project the point into    𝐑   n  +  1      superscript  𝐑    n  1     \scriptstyle\mathbf{R}^{n+1}   ; for example, a curve in three dimensions may have its control points    {   (   x  i   ,   y  i   ,   z  i   )   }       subscript  x  i    subscript  y  i    subscript  z  i      \scriptstyle\{(x_{i},y_{i},z_{i})\}   and weights    {   w  i   }      subscript  w  i     \scriptstyle\{w_{i}\}   projected to the weighted control points    {   (    w  i    x  i    ,    w  i    y  i    ,    w  i    z  i    ,   w  i   )   }         subscript  w  i    subscript  x  i       subscript  w  i    subscript  y  i       subscript  w  i    subscript  z  i     subscript  w  i      \scriptstyle\{(w_{i}x_{i},w_{i}y_{i},w_{i}z_{i},w_{i})\}   . The algorithm then proceeds as usual, interpolating in    𝐑  4     superscript  𝐑  4    \scriptstyle\mathbf{R}^{4}   . The resulting four-dimensional points may be projected back into three-space with a perspective divide .  In general, operations on a rational curve (or surface) are equivalent to operations on a nonrational curve in a projective space . This representation as the "weighted control points" and weights is often convenient when evaluating rational curves.  See also   Bézier curves  De Boor's algorithm  Horner scheme to evaluate polynomials in monomial form  Clenshaw algorithm to evaluate polynomials in Chebyshev form   References   Farin, Gerald & Hansford, Dianne (2000). The Essentials of CAGD . Natic, MA: A K Peters, Ltd. ISBN 1-56881-123-3   External links   Piecewise linear approximation of Bézier curves – description of De Casteljau's algorithm, including a criterion to determine when to stop the recusion  Bezier Curves and Picasso — Description and illustration of De Casteljau's algorithm applied to cubic Bézier curves.   "  Category:Splines  Category:Numerical analysis  