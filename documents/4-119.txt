   De Casteljau's algorithm      De Casteljau's algorithm  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     In the mathematical field of numerical analysis , De Casteljau's algorithm is a recursive method to evaluate polynomials in Bernstein form or B√©zier curves , named after its inventor Paul de Casteljau . De Casteljau's algorithm can also be used to split a single B√©zier curve into two B√©zier curves at an arbitrary parameter value.  Although the algorithm is slower for most architectures when compared with the direct approach, it is more numerically stable .  Definition  A B√©zier curve B (of degree n , with control points     Œ≤  0   ,  ‚Ä¶  ,   Œ≤  n       subscript  Œ≤  0   normal-‚Ä¶   subscript  Œ≤  n     \beta_{0},\ldots,\beta_{n}   ) can be written in Bernstein form as follows       B   (  t  )    =    ‚àë   i  =  0   n     Œ≤  i    b   i  ,  n     (  t  )           B  t     superscript   subscript     i  0    n      subscript  Œ≤  i    subscript  b   i  n    t      B(t)=\sum_{i=0}^{n}\beta_{i}b_{i,n}(t)   ,  where b is a Bernstein basis polynomial        b   i  ,  n     (  t  )    =    (     n      i     )     (   1  -  t   )    n  -  i     t  i           subscript  b   i  n    t      binomial  n  i    superscript    1  t     n  i     superscript  t  i      b_{i,n}(t)={n\choose i}(1-t)^{n-i}t^{i}   .  The curve at point t 0 can be evaluated with the recurrence relation        Œ≤  i   (  0  )    :=    Œ≤  i   ,  i   =  0   ,   ‚Ä¶  ,  n      formulae-sequence     assign   superscript   subscript  Œ≤  i   0      subscript  Œ≤  i   ,  i        0     normal-‚Ä¶  n     \beta_{i}^{(0)}:=\beta_{i}\mbox{ , }i=0,\ldots,n           Œ≤  i   (  j  )    :=     Œ≤  i   (   j  -  1   )     (   1  -   t  0    )    +    Œ≤   i  +  1    (   j  -  1   )     t  0   ,  i    =  0   ,    ‚Ä¶  ,   n  -   j  ,  j     =  1   ,   ‚Ä¶  ,  n      formulae-sequence     assign   superscript   subscript  Œ≤  i   j        superscript   subscript  Œ≤  i     j  1      1   subscript  t  0        superscript   subscript  Œ≤    i  1      j  1     subscript  t  0   ,  i         0       normal-‚Ä¶    n    j  ,  j     1    normal-‚Ä¶  n     \beta_{i}^{(j)}:=\beta_{i}^{(j-1)}(1-t_{0})+\beta_{i+1}^{(j-1)}t_{0}\mbox{ , }%
 i=0,\ldots,n-j\mbox{ , }j=1,\ldots,n     Then, the evaluation of   B   B   B   at point    t  0     subscript  t  0    t_{0}   can be evaluated in   n   n   n   steps of the algorithm. The result    B   (   t  0   )       B   subscript  t  0     B(t_{0})   is given by :        B   (   t  0   )    =   Œ≤  0   (  n  )     .        B   subscript  t  0     superscript   subscript  Œ≤  0   n     B(t_{0})=\beta_{0}^{(n)}.     Moreover, the B√©zier curve   B   B   B   can be split at point    t  0     subscript  t  0    t_{0}   into two curves with respective control points :       Œ≤  0   (  0  )    ,   Œ≤  0   (  1  )    ,  ‚Ä¶  ,   Œ≤  0   (  n  )        superscript   subscript  Œ≤  0   0    superscript   subscript  Œ≤  0   1   normal-‚Ä¶   superscript   subscript  Œ≤  0   n     \beta_{0}^{(0)},\beta_{0}^{(1)},\ldots,\beta_{0}^{(n)}          Œ≤  0   (  n  )    ,   Œ≤  1   (   n  -  1   )    ,  ‚Ä¶  ,   Œ≤  n   (  0  )        superscript   subscript  Œ≤  0   n    superscript   subscript  Œ≤  1     n  1    normal-‚Ä¶   superscript   subscript  Œ≤  n   0     \beta_{0}^{(n)},\beta_{1}^{(n-1)},\ldots,\beta_{n}^{(0)}     Example implementation  Here is an example implementation of De Casteljau's algorithm in Haskell :  deCasteljau ::  Double  -> [( Double , Double )] -> ( Double , Double )
 deCasteljau t [b] = b
 deCasteljau t coefs = deCasteljau t reduced where reduced = zipWith (lerpP t) coefs (tail coefs)
     lerpP t (x0, y0) (x1, y1) = (lerp t x0 x1, lerp t y0 y1)
     lerp t a b = t * b + ( 1  - t) * a  Notes  When doing the calculation by hand it is useful to write down the coefficients in a triangle scheme as         Œ≤  0       =   Œ≤  0   (  0  )                         Œ≤  0   (  1  )               Œ≤  1       =   Œ≤  1   (  0  )                           ‚ã±         ‚ãÆ       ‚ãÆ        Œ≤  0   (  n  )                          Œ≤   n  -  1        =   Œ≤   n  -  1    (  0  )                         Œ≤   n  -  1    (  1  )               Œ≤  n       =   Œ≤  n   (  0  )                     subscript  Œ≤  0     absent   superscript   subscript  Œ≤  0   0    absent  absent  absent    absent  absent   superscript   subscript  Œ≤  0   1   absent  absent     subscript  Œ≤  1     absent   superscript   subscript  Œ≤  1   0    absent  absent  absent    absent  absent  absent  normal-‚ã±  absent    normal-‚ãÆ  absent  normal-‚ãÆ  absent   superscript   subscript  Œ≤  0   n     absent  absent  absent  absent  absent     subscript  Œ≤    n  1      absent   superscript   subscript  Œ≤    n  1    0    absent  absent  absent    absent  absent   superscript   subscript  Œ≤    n  1    1   absent  absent     subscript  Œ≤  n     absent   superscript   subscript  Œ≤  n   0    absent  absent  absent     \begin{matrix}\beta_{0}&=\beta_{0}^{(0)}&&&\\
 &&\beta_{0}^{(1)}&&\\
 \beta_{1}&=\beta_{1}^{(0)}&&&\\
 &&&\ddots&\\
 \vdots&&\vdots&&\beta_{0}^{(n)}\\
 &&&&\\
 \beta_{n-1}&=\beta_{n-1}^{(0)}&&&\\
 &&\beta_{n-1}^{(1)}&&\\
 \beta_{n}&=\beta_{n}^{(0)}&&&\\
 \end{matrix}     When choosing a point t 0 to evaluate a Bernstein polynomial we can use the two diagonals of the triangle scheme to construct a division of the polynomial        B   (  t  )    =    ‚àë   i  =  0   n     Œ≤  i   (  0  )     b   i  ,  n     (  t  )   ,      t  ‚àà   [  0  ,  1  ]       formulae-sequence      B  t     superscript   subscript     i  0    n      superscript   subscript  Œ≤  i   0    subscript  b   i  n    t  ,       t   0  1      B(t)=\sum_{i=0}^{n}\beta_{i}^{(0)}b_{i,n}(t)\mbox{ , }\qquad t\in[0,1]     into         B  1    (  t  )    =    ‚àë   i  =  0   n     Œ≤  0   (  i  )     b   i  ,  n     (   t   t  0    )   ,      t  ‚àà   [  0  ,   t  0   ]       formulae-sequence       subscript  B  1   t     superscript   subscript     i  0    n      superscript   subscript  Œ≤  0   i    subscript  b   i  n      t   subscript  t  0    ,       t   0   subscript  t  0       B_{1}(t)=\sum_{i=0}^{n}\beta_{0}^{(i)}b_{i,n}\left(\frac{t}{t_{0}}\right)\mbox%
 { , }\qquad t\in[0,t_{0}]     and         B  2    (  t  )    =    ‚àë   i  =  0   n     Œ≤  i   (   n  -  i   )     b   i  ,  n     (    t  -   t  0     1  -   t  0     )   ,      t  ‚àà   [   t  0   ,  1  ]       formulae-sequence       subscript  B  2   t     superscript   subscript     i  0    n      superscript   subscript  Œ≤  i     n  i     subscript  b   i  n        t   subscript  t  0      1   subscript  t  0     ,       t    subscript  t  0   1      B_{2}(t)=\sum_{i=0}^{n}\beta_{i}^{(n-i)}b_{i,n}\left(\frac{t-t_{0}}{1-t_{0}}%
 \right)\mbox{ , }\qquad t\in[t_{0},1]     Example  We want to evaluate the Bernstein polynomial of degree 2 with the Bernstein coefficients       Œ≤  0   (  0  )    =   Œ≤  0        superscript   subscript  Œ≤  0   0    subscript  Œ≤  0     \beta_{0}^{(0)}=\beta_{0}          Œ≤  1   (  0  )    =   Œ≤  1        superscript   subscript  Œ≤  1   0    subscript  Œ≤  1     \beta_{1}^{(0)}=\beta_{1}          Œ≤  2   (  0  )    =   Œ≤  2        superscript   subscript  Œ≤  2   0    subscript  Œ≤  2     \beta_{2}^{(0)}=\beta_{2}   at the point t 0 .  We start the recursion with       Œ≤  0   (  1  )    =     Œ≤  0   (  0  )     (   1  -   t  0    )    +    Œ≤  1   (  0  )     t  0     =     Œ≤  0    (   1  -   t  0    )    +    Œ≤  1    t  0            superscript   subscript  Œ≤  0   1        superscript   subscript  Œ≤  0   0     1   subscript  t  0        superscript   subscript  Œ≤  1   0    subscript  t  0               subscript  Œ≤  0     1   subscript  t  0        subscript  Œ≤  1    subscript  t  0        \beta_{0}^{(1)}=\beta_{0}^{(0)}(1-t_{0})+\beta_{1}^{(0)}t_{0}=\beta_{0}(1-t_{0%
 })+\beta_{1}t_{0}          Œ≤  1   (  1  )    =     Œ≤  1   (  0  )     (   1  -   t  0    )    +    Œ≤  2   (  0  )     t  0     =     Œ≤  1    (   1  -   t  0    )    +    Œ≤  2    t  0            superscript   subscript  Œ≤  1   1        superscript   subscript  Œ≤  1   0     1   subscript  t  0        superscript   subscript  Œ≤  2   0    subscript  t  0               subscript  Œ≤  1     1   subscript  t  0        subscript  Œ≤  2    subscript  t  0        \beta_{1}^{(1)}=\beta_{1}^{(0)}(1-t_{0})+\beta_{2}^{(0)}t_{0}=\beta_{1}(1-t_{0%
 })+\beta_{2}t_{0}     and with the second iteration the recursion stops with      Œ≤  0   (  2  )      superscript   subscript  Œ≤  0   2    \displaystyle\beta_{0}^{(2)}     which is the expected Bernstein polynomial of degree 2 .  B√©zier curve  When evaluating a B√©zier curve of degree n in 3-dimensional space with n +1 control points P i       ùêÅ   (  t  )    =    ‚àë   i  =  0   n     ùêè  i    b   i  ,  n     (  t  )   ,  t    ‚àà   [  0  ,  1  ]           ùêÅ  t     superscript   subscript     i  0    n      subscript  ùêè  i    subscript  b   i  n    t  ,  t          0  1      \mathbf{B}(t)=\sum_{i=0}^{n}\mathbf{P}_{i}b_{i,n}(t)\mbox{ , }t\in[0,1]     with       ùêè  i   :=   (      x  i        y  i        z  i      )      assign   subscript  ùêè  i      subscript  x  i      subscript  y  i      subscript  z  i       \mathbf{P}_{i}:=\begin{pmatrix}x_{i}\\
 y_{i}\\
 z_{i}\end{pmatrix}   .  we split the B√©zier curve into three separate equations        B  1    (  t  )    =    ‚àë   i  =  0   n     x  i    b   i  ,  n     (  t  )   ,  t    ‚àà   [  0  ,  1  ]            subscript  B  1   t     superscript   subscript     i  0    n      subscript  x  i    subscript  b   i  n    t  ,  t          0  1      B_{1}(t)=\sum_{i=0}^{n}x_{i}b_{i,n}(t)\mbox{ , }t\in[0,1]           B  2    (  t  )    =    ‚àë   i  =  0   n     y  i    b   i  ,  n     (  t  )   ,  t    ‚àà   [  0  ,  1  ]            subscript  B  2   t     superscript   subscript     i  0    n      subscript  y  i    subscript  b   i  n    t  ,  t          0  1      B_{2}(t)=\sum_{i=0}^{n}y_{i}b_{i,n}(t)\mbox{ , }t\in[0,1]           B  3    (  t  )    =    ‚àë   i  =  0   n     z  i    b   i  ,  n     (  t  )   ,  t    ‚àà   [  0  ,  1  ]            subscript  B  3   t     superscript   subscript     i  0    n      subscript  z  i    subscript  b   i  n    t  ,  t          0  1      B_{3}(t)=\sum_{i=0}^{n}z_{i}b_{i,n}(t)\mbox{ , }t\in[0,1]     which we evaluate individually using De Casteljau's algorithm.  Geometric interpretation  The geometric interpretation of De Casteljau's algorithm is straightforward.   Consider a B√©zier curve with control points     P  0   ,  ‚Ä¶  ,   P  n       subscript  P  0   normal-‚Ä¶   subscript  P  n     \scriptstyle P_{0},...,P_{n}   . Connecting the consecutive points we create the control polygon of the curve.  Subdivide now each line segment of this polygon with the ratio    t  :   (   1  -  t   )      normal-:  t    1  t     \scriptstyle t:(1-t)   and connect the points you get. This way you arrive at the new polygon having one fewer segment.  Repeat the process until you arrive at the single point - this is the point of the curve corresponding to the parameter   t   t   \scriptstyle t   .   The following picture shows this process for a cubic B√©zier curve:  (Figure)  DeCasteljau1.svg   Note that the intermediate points that were constructed are in fact the control points for two new B√©zier curves, both exactly coincident with the old one. This algorithm not only evaluates the curve at   t   t   \scriptstyle t   , but splits the curve into two pieces at   t   t   \scriptstyle t   , and provides the equations of the two sub-curves in B√©zier form.  The interpretation given above is valid for a nonrational B√©zier curve. To evaluate a rational B√©zier curve in    ùêë  n     superscript  ùêë  n    \scriptstyle\mathbf{R}^{n}   , we may project the point into    ùêë   n  +  1      superscript  ùêë    n  1     \scriptstyle\mathbf{R}^{n+1}   ; for example, a curve in three dimensions may have its control points    {   (   x  i   ,   y  i   ,   z  i   )   }       subscript  x  i    subscript  y  i    subscript  z  i      \scriptstyle\{(x_{i},y_{i},z_{i})\}   and weights    {   w  i   }      subscript  w  i     \scriptstyle\{w_{i}\}   projected to the weighted control points    {   (    w  i    x  i    ,    w  i    y  i    ,    w  i    z  i    ,   w  i   )   }         subscript  w  i    subscript  x  i       subscript  w  i    subscript  y  i       subscript  w  i    subscript  z  i     subscript  w  i      \scriptstyle\{(w_{i}x_{i},w_{i}y_{i},w_{i}z_{i},w_{i})\}   . The algorithm then proceeds as usual, interpolating in    ùêë  4     superscript  ùêë  4    \scriptstyle\mathbf{R}^{4}   . The resulting four-dimensional points may be projected back into three-space with a perspective divide .  In general, operations on a rational curve (or surface) are equivalent to operations on a nonrational curve in a projective space . This representation as the "weighted control points" and weights is often convenient when evaluating rational curves.  See also   B√©zier curves  De Boor's algorithm  Horner scheme to evaluate polynomials in monomial form  Clenshaw algorithm to evaluate polynomials in Chebyshev form   References   Farin, Gerald & Hansford, Dianne (2000). The Essentials of CAGD . Natic, MA: A K Peters, Ltd. ISBN 1-56881-123-3   External links   Piecewise linear approximation of B√©zier curves ‚Äì description of De Casteljau's algorithm, including a criterion to determine when to stop the recusion  Bezier Curves and Picasso ‚Äî Description and illustration of De Casteljau's algorithm applied to cubic B√©zier curves.   "  Category:Splines  Category:Numerical analysis  