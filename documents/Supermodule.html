<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1855">Supermodule</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Supermodule</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>supermodule</strong> is a <strong>Z</strong><sub>2</sub>-<a href="graded_module" title="wikilink">graded module</a> over a <a class="uri" href="superring" title="wikilink">superring</a> or <a class="uri" href="superalgebra" title="wikilink">superalgebra</a>. Supermodules arise in <a href="super_linear_algebra" title="wikilink">super linear algebra</a> which is a mathematical framework for studying the concept <a class="uri" href="supersymmetry" title="wikilink">supersymmetry</a> in <a href="theoretical_physics" title="wikilink">theoretical physics</a>.</p>

<p>Supermodules over a <a href="commutative_superalgebra" title="wikilink">commutative superalgebra</a> can be viewed as generalizations of <a href="super_vector_space" title="wikilink">super vector spaces</a> over a (purely even) <a href="field_(mathematics)" title="wikilink">field</a> <em>K</em>. Supermodules often play a more prominent role in super linear algebra than do super vector spaces. These reason is that it is often necessary or useful to extend the field of scalars to include odd variables. In doing so one moves from fields to commutative superalgebras and from vector spaces to modules.</p>
<dl>
<dd><em>In this article, all superalgebras are assumed be <a class="uri" href="associative" title="wikilink">associative</a> and <a href="unital_algebra" title="wikilink">unital</a> unless stated otherwise.</em>
</dd>
</dl>
<h2 id="formal-definition">Formal definition</h2>

<p>Let <em>A</em> be a fixed <a class="uri" href="superalgebra" title="wikilink">superalgebra</a>. A <strong>right supermodule</strong> over <em>A</em> is a <a href="right_module" title="wikilink">right module</a> <em>E</em> over <em>A</em> with a <a href="direct_sum_of_modules" title="wikilink">direct sum</a> decomposition (as an <a href="abelian_group" title="wikilink">abelian group</a>)</p>

<p>

<math display="block" id="Supermodule:0">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>E</mi>
     <mn>0</mn>
    </msub>
    <mo>⊕</mo>
    <msub>
     <mi>E</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=E_{0}\oplus E_{1}
  </annotation>
 </semantics>
</math>

 such that multiplication by elements of <em>A</em> satisfies</p>

<p>

<math display="block" id="Supermodule:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>E</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>A</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>⊆</mo>
   <msub>
    <mi>E</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{i}A_{j}\subseteq E_{i+j}
  </annotation>
 </semantics>
</math>

 for all <em>i</em> and <em>j</em> in <strong>Z</strong><sub>2</sub>. The subgroups <em>E</em><sub><em>i</em></sub> are then right <em>A</em><sub>0</sub>-modules.</p>

<p>The elements of <em>E</em><sub><em>i</em></sub> are said to be <strong>homogeneous</strong>. The <strong>parity</strong> of a homogeneous element <em>x</em>, denoted by |<em>x</em>|, is 0 or 1 according to whether it is in <em>E</em><sub>0</sub> or <em>E</em><sub>1</sub>. Elements of parity 0 are said to be <strong>even</strong> and those of parity 1 to be <strong>odd</strong>. If <em>a</em> is a homogeneous scalar and <em>x</em> is a homogeneous element of <em>E</em> then |<em>x</em>·<em>a</em>| is homogeneous and |<em>x</em>·<em>a</em>| = |<em>x</em>| + |<em>a</em>|.</p>

<p>Likewise, <strong>left supermodules</strong> and <strong>superbimodules</strong> are defined as <a href="left_module" title="wikilink">left modules</a> or <a href="bimodule" title="wikilink">bimodules</a> over <em>A</em> whose scalar multiplications respect the gradings in the obvious manner. If <em>A</em> is <a class="uri" href="supercommutative" title="wikilink">supercommutative</a>, then every left or right supermodule over <em>A</em> may be regarded as a superbimodule by setting</p>

<p>

<math display="block" id="Supermodule:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>⋅</mo>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>a</mi>
        <mo stretchy="false">|</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>x</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>⋅</mo>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <abs></abs>
         <ci>a</ci>
        </apply>
        <apply>
         <abs></abs>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\cdot x=(-1)^{|a||x|}x\cdot a
  </annotation>
 </semantics>
</math>

 for homogeneous elements <em>a</em> ∈ <em>A</em> and <em>x</em> ∈ <em>E</em>, and extending by linearity. If <em>A</em> is purely even this reduces to the ordinary definition.</p>
<h2 id="homomorphisms">Homomorphisms</h2>

<p>A <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> between supermodules is a <a href="module_homomorphism" title="wikilink">module homomorphism</a> that preserves the grading. Let <em>E</em> and <em>F</em> be right supermodules over <em>A</em>. A map</p>

<p>

<math display="block" id="Supermodule:3">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>:</mo>
   <mrow>
    <mi>E</mi>
    <mo>→</mo>
    <mpadded width="+1.7pt">
     <mi>F</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ϕ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>E</ci>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi:E\to F\,
  </annotation>
 </semantics>
</math>

 is a supermodule homomorphism if</p>
<ul>
<li>

<math display="inline" id="Supermodule:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x+y)=\phi(x)+\phi(y)\,
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Supermodule:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>⋅</mo>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⋅</mo>
    <mpadded width="+1.7pt">
     <mi>a</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>x</ci>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <ci>x</ci>
     </apply>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x\cdot a)=\phi(x)\cdot a\,
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Supermodule:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>E</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>F</mi>
     <mi>i</mi>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(E_{i})\subseteq F_{i}\,
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>for all <em>a</em>∈<em>A</em> and all <em>x</em>,<em>y</em>∈<em>E</em>. The set of all module homomorphisms from <em>E</em> to <em>F</em> is denoted by Hom(<em>E</em>, <em>F</em>).</p>

<p>In many cases, it is necessary or convenient to consider a larger class of morphisms between supermodules. Let <em>A</em> be a supercommutative algebra. Then all supermodules over <em>A</em> be regarded as superbimodules in a natural fashion. For supermodules <em>E</em> and <em>F</em>, let <strong>Hom</strong>(<em>E</em>, <em>F</em>) denote the space of all <em>right</em> A-linear maps (i.e. all module homomorphisms from <em>E</em> to <em>F</em> considered as ungraded right <em>A</em>-modules). There is a natural grading on <strong>Hom</strong>(<em>E</em>, <em>F</em>) where the even homomorphisms are those that preserve the grading</p>

<p>

<math display="block" id="Supermodule:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>E</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <msub>
    <mi>F</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(E_{i})\subseteq F_{i}
  </annotation>
 </semantics>
</math>

 and the odd homomorphisms are those that reverse the grading</p>

<p>

<math display="block" id="Supermodule:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>E</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊆</mo>
    <msub>
     <mi>F</mi>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(E_{i})\subseteq F_{1-i}.
  </annotation>
 </semantics>
</math>

 If φ ∈ <strong>Hom</strong>(<em>E</em>, <em>F</em>) and <em>a</em> ∈ <em>A</em> are homogeneous then</p>

<p>

<math display="block" id="Supermodule:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>⋅</mo>
        <mi>a</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <mi>a</mi>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mo>⋅</mo>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mrow>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mrow>
           <mo stretchy="false">|</mo>
           <mi>a</mi>
           <mo stretchy="false">|</mo>
          </mrow>
          <mrow>
           <mo stretchy="false">|</mo>
           <mi>ϕ</mi>
           <mo stretchy="false">|</mo>
          </mrow>
         </mrow>
        </msup>
        <mi>a</mi>
       </mrow>
       <mo>⋅</mo>
       <mi>ϕ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <apply>
       <ci>normal-⋅</ci>
       <ci>x</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <ci>x</ci>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <apply>
       <ci>normal-⋅</ci>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <times></times>
          <apply>
           <abs></abs>
           <ci>a</ci>
          </apply>
          <apply>
           <abs></abs>
           <ci>ϕ</ci>
          </apply>
         </apply>
        </apply>
        <ci>a</ci>
       </apply>
       <ci>ϕ</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x\cdot a)=\phi(x)\cdot a\qquad\phi(a\cdot x)=(-1)^{|a||\phi|}a\cdot\phi(x).
  </annotation>
 </semantics>
</math>

 That is, the even homomorphisms are both right and left linear whereas the odd homomorphism are right linear but left <a class="uri" href="antilinear" title="wikilink">antilinear</a> (with respect to the grading automorphism).</p>

<p>The set <strong>Hom</strong>(<em>E</em>, <em>F</em>) can be given the structure of a bimodule over <em>A</em> by setting</p>

<p>

<math display="inline" id="Supermodule:10">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>a</mi>
     <mo>⋅</mo>
     <mi>ϕ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <ci>a</ci>
     <ci>ϕ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle(a\cdot\phi)(x)
  </annotation>
 </semantics>
</math>


 With the above grading <strong>Hom</strong>(<em>E</em>, <em>F</em>) becomes a supermodule over <em>A</em> whose even part is the set of all ordinary supermodule homomorphisms</p>

<p>

<math display="block" id="Supermodule:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>𝐇𝐨𝐦</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo>,</mo>
      <mi>F</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Hom</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo>,</mo>
      <mi>F</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐇𝐨𝐦</ci>
      <cn type="integer">0</cn>
     </apply>
     <interval closure="open">
      <ci>E</ci>
      <ci>F</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>Hom</ci>
     <interval closure="open">
      <ci>E</ci>
      <ci>F</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Hom}_{0}(E,F)=\mathrm{Hom}(E,F).
  </annotation>
 </semantics>
</math>

 In the language of <a href="category_theory" title="wikilink">category theory</a>, the class of all supermodules over <em>A</em> forms a <a href="category_(mathematics)" title="wikilink">category</a> with supermodule homomorphisms as the morphisms. This category is a <a href="symmetric_monoidal_category" title="wikilink">symmetric</a> <a href="monoidal_closed_category" title="wikilink">monoidal closed category</a> under the super tensor product whose <a href="internal_Hom_functor" title="wikilink">internal Hom functor</a> is given by <strong>Hom</strong>.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Module_theory" title="wikilink">Category:Module theory</a> <a href="Category:Super_linear_algebra" title="wikilink">Category:Super linear algebra</a></p>
</body>
</html>
