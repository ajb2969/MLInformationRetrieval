<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1859">Type safety</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Type safety</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>type safety</strong> is the extent to which a <a href="programming_language" title="wikilink">programming language</a> discourages or prevents <strong>type errors</strong>. A type error is erroneous or undesirable program behaviour caused by a discrepancy between differing <a href="data_type" title="wikilink">data types</a> for the program's constants, variables, and methods (functions), e.g., treating an integer (<strong>int</strong>) as a floating-point number (<strong>float</strong>). Type safety is sometimes alternatively considered to be a property of a computer program rather than the language in which that program is written; that is, some languages have type-safe facilities that can be circumvented by programmers who adopt practices that exhibit poor type safety. The formal <a href="type_theory" title="wikilink">type-theoretic</a> definition of type safety is considerably stronger than what is understood by most programmers.</p>

<p><a href="Type_enforcement" title="wikilink">Type enforcement</a> can be static, catching potential errors at <a href="compile_time" title="wikilink">compile time</a>, or dynamic, associating type information with values at <a href="Run_time_(program_lifecycle_phase)" title="wikilink">run-time</a> and consulting them as needed to detect imminent errors, or a combination of both.</p>

<p>The behaviors classified as type errors by a given programming language are usually those that result from attempts to perform operations on <a href="value_(computer_science)" title="wikilink">values</a> that are not of the appropriate <a href="data_type" title="wikilink">data type</a>. This classification is partly based on opinion; it may imply that any operation not leading to program crashes, security flaws or other obvious failures is legitimate and need not be considered an error, or it may imply that any contravention of the programmer's explicit intent (as communicated via typing annotations) to be erroneous and not "type-safe".</p>

<p>In the context of static (compile-time) type systems, type safety usually involves (among other things) a guarantee that the eventual value of any <a href="expression_(programming)" title="wikilink">expression</a> will be a legitimate member of that expression's static type. The precise requirement is more subtle than this — see, for example, <a class="uri" href="subtype" title="wikilink">subtype</a> and <a href="polymorphism_(computer_science)" title="wikilink">polymorphism</a> for complications.</p>

<p>Type safety is closely linked to <em><a href="memory_safety" title="wikilink">memory safety</a></em>, a restriction on the ability to copy arbitrary bit patterns from one memory location to another. For instance, in an implementation of a language that has some type 

<math display="inline" id="Type_safety:0">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, such that some sequence of bits (of the appropriate length) does not represent a legitimate member of 

<math display="inline" id="Type_safety:1">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, if that language allows data to be copied into a <a href="Variable_(programming)" title="wikilink">variable</a> of type 

<math display="inline" id="Type_safety:2">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, then it is not type-safe because such an operation might assign a non-

<math display="inline" id="Type_safety:3">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 value to that variable. Conversely, if the language is type-unsafe to the extent of allowing an arbitrary integer to be used as a <a href="pointer_(computer_programming)" title="wikilink">pointer</a>, then it is not memory-safe.</p>

<p>Most statically typed languages provide a degree of type safety that is strictly stronger than memory safety, because their type systems enforce the proper use of <a href="abstract_data_type" title="wikilink">abstract data types</a> defined by programmers even when this is not strictly necessary for memory safety or for the prevention of any kind of catastrophic failure.</p>
<h2 id="definitions">Definitions</h2>

<p>Type-safe code accesses only the memory locations it is authorized to access. (For this discussion, type safety specifically refers to memory type safety and should not be confused with type safety in a broader respect.) For example, type-safe code cannot read values from another object's private fields.</p>

<p><a href="Robin_Milner" title="wikilink">Robin Milner</a> provided the following slogan to describe type safety:</p>
<dl>
<dd>Well-typed programs cannot "go wrong".<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>
</dd>
</dl>

<p>The appropriate formalization of this slogan depends on the style of formal semantics used for a particular language. In the context of <a href="denotational_semantics" title="wikilink">denotational semantics</a>, type safety means that the value of an expression that is well-typed, say with type τ, is a <em>bona fide</em> member of the set corresponding to τ.</p>

<p>In 1994, Andrew Wright and <a href="Matthias_Felleisen" title="wikilink">Matthias Felleisen</a> formulated what is now the standard definition and proof technique for type safety in languages defined by <a href="operational_semantics" title="wikilink">operational semantics</a>. Under this approach, type safety is determined by two properties of the semantics of the programming language:</p>
<dl>
<dt>(Type-) preservation or <a href="subject_reduction" title="wikilink">subject reduction</a>: "Well typedness" of programs remains invariant under the transition rules (i.e. evaluation rules or reduction rules) of the language.<br/>
Progress: A well typed program never gets "stuck", i.e., never gets into an undefined state where no further transitions are possible.</dt>
</dl>

<p>These properties do not exist in a vacuum; they are linked to the semantics of the programming language they describe, and there is a large space of varied languages that can fit these criteria, since the notion of "well typed" program is part of the static semantics of the programming language and the notion of "getting stuck" (or "going wrong") is a property of its <a href="dynamic_semantics" title="wikilink">dynamic semantics</a>.</p>

<p>Vijay Saraswat provides the following definition:</p>
<dl>
<dd>"A language is type-safe if the only operations that can be performed on data in the language are those sanctioned by the type of the data." <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>
</dd>
</dl>
<h2 id="relation-to-other-forms-of-safety">Relation to other forms of safety</h2>

<p>Type safety is ultimately aimed at excluding other problems, e.g.:-</p>
<ul>
<li>Prevention of illegal operations. For example, we can identify an expression <code>3 / "Hello, World"</code> as invalid, because the rules of <a class="uri" href="arithmetic" title="wikilink">arithmetic</a> do not specify how to divide an <a class="uri" href="integer" title="wikilink">integer</a> by a <a href="string_(computer_science)" title="wikilink">string</a>.</li>
<li><a href="Memory_safety" title="wikilink">Memory safety</a>
<ul>
<li><a href="Wild_pointer" title="wikilink">Wild pointers</a> can arise when a pointer to one type object is treated as a pointer to another type. For instance, the size of an object depends on the type, so if a pointer is incremented under the wrong credentials, it will end up pointing at some random area of memory.</li>
<li><a href="Buffer_overflow" title="wikilink">Buffer overflow</a> - Out-of bound writes can corrupt the contents of objects already present on the heap. This can occur when a larger object of one type is crudely copied into smaller object of another type.</li>
</ul></li>
<li><a href="Logic_error" title="wikilink">Logic errors</a> originating in the <a class="uri" href="semantics" title="wikilink">semantics</a> of different types. For instance, inches and millimeters may both be stored as integers, but should not be substituted for each other or added. A type system can enforce two different types of integer for them.</li>
</ul>
<h2 id="type-safe-and-type-unsafe-languages">Type-safe and type-unsafe languages</h2>

<p>Type safety is usually a requirement for any <a href="toy_language" title="wikilink">toy language</a> proposed in academic programming language research. Many languages, on the other hand, are too big for human-generated type safety proofs, as they often require checking thousands of cases. Nevertheless, some languages such as <a href="Standard_ML" title="wikilink">Standard ML</a>, which has rigorously defined semantics, have been proved to meet one definition of type safety.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Some other languages such as <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> are <em>believed</em> to meet some definition of type safety, provided certain "escape" features are not used (for example Haskell's <code>unsafePerformIO</code>, used to "escape" from the usual restricted environment in which I/O is possible, circumvents the type system and so can be used to break type safety.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>) <a href="Type_punning" title="wikilink">Type punning</a> is another example of such an "escape" feature. Regardless of the properties of the language definition, certain errors may occur at <a href="Run_time_(program_lifecycle_phase)" title="wikilink">run-time</a> due to bugs in the implementation, or in linked <a href="library_(computer_science)" title="wikilink">libraries</a> written in other languages; such errors could render a given implementation type unsafe in certain circumstances. An early version of Sun's Java Virtual Machine was vulnerable to this sort of problem.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="type-safety-and-strong-typing">Type safety and "strong typing"</h3>

<p>Some people use the term "<a href="strong_typing" title="wikilink">strong typing</a>" to refer to certain aspects of type safety. For example, a language with a statically checked type system may be described as "strongly typed", because it statically disallows conversions between values of incompatible type. Similarly, a language with a dynamically checked type system may also be described as "strongly typed", because a program which tries to convert a value to an incompatible type will fail at runtime.</p>
<h2 id="type-safety-in-object-oriented-languages">Type safety in object oriented languages</h2>

<p>In <a href="object_oriented" title="wikilink">object oriented</a> languages type safety is usually intrinsic in the fact a <a href="type_system" title="wikilink">type system</a> is in place. This is expressed in terms of class definitions.</p>

<p>A <a href="Class_(computer_science)" title="wikilink">class</a> essentially defines the structure of the objects derived from it and an <a href="Api#API_in_object-oriented_languages" title="wikilink">API</a> as a <em>contract</em> for handling these objects. Each time a new object is created it will <em>comply</em> with that contract.</p>

<p>Each function that exchanges objects derived from a specific class, or implementing a specific <a href="Interface_(computer_science)" title="wikilink">interface</a>, will adhere to that contract: hence in that function the operations permitted on that object will be only those defined by the methods of the class the object implements. This will guarantee that the object integrity will be preserved.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Exception to this are object oriented languages that allow dynamic modification of the object structure, or the use of reflection to modify the content of an object to overcome the constraints imposed by the class methods definitions.</p>
<h2 id="type-safety-issues-in-specific-languages">Type safety issues in specific languages</h2>
<h3 id="ada">Ada</h3>

<p><a href="Ada_programming_language" title="wikilink">Ada</a> was designed to be suitable for <a href="embedded_system" title="wikilink">embedded systems</a>, <a href="device_driver" title="wikilink">device drivers</a> and other forms of <a href="system_programming" title="wikilink">system programming</a>, but also to encourage type safe programming. To resolve these conflicting goals, Ada confines type-unsafety to a certain set of special constructs whose names usually begin with the string <code>Unchecked_</code>. Unchecked_Deallocation can be effectively banned from a unit of Ada text by applying <code>pragma Pure</code> to this unit. It is expected that programmers will use <code>Unchecked_</code> constructs very carefully and only when necessary; programs that do not use them are type safe.</p>

<p>The <a href="SPARK_programming_language" title="wikilink">SPARK programming language</a> is a subset of Ada eliminating all its potential ambiguities and insecurities while at the same time adding <a href="design_by_contract" title="wikilink">statically checked contracts</a> to the language features available. SPARK avoids the issues with <a href="dangling_pointer" title="wikilink">dangling pointers</a> by disallowing allocation at run time entirely.</p>

<p>Ada2012 adds <a href="design_by_contract" title="wikilink">statically checked contracts</a> to the language itself (in form of pre-, and post-conditions, as well as type invariants).</p>
<h3 id="c">C</h3>

<p>The <a href="C_(programming_language)" title="wikilink">C programming language</a> is typesafe in limited contexts; for example, a compile-time error is generated when an attempt is made to convert a pointer to one type of structure to a pointer to another type of structure, unless an explicit cast is used. However, a number of very common operations are non-typesafe; for example, the usual way to print an integer is something like <code>printf("%d", 12)</code>, where the <code>%d</code> tells <code>printf</code> at run-time to expect an integer argument. (Something like <code>printf("%s", 12)</code>, which erroneously tells the function to expect a pointer to a character-string, will be accepted by compilers, but will produce undefined results.) This is partially mitigated by some compilers (such as gcc) checking type correspondences between printf arguments and format strings.</p>

<p>In addition, C, like Ada, provides unspecified or undefined explicit conversions; and unlike in Ada, idioms that use these conversions are very common, and have helped to give C a type-unsafe reputation. For example, the standard way to allocate memory on the heap is to invoke a memory allocation function, such as <code>[[malloc]]</code>, with an argument indicating how many bytes are required. The function returns an untyped pointer (type <code>void *</code>), which the calling code must cast to the appropriate pointer type. Older C specifications required an explicit cast to do so, therefore the code <code>(struct foo *) malloc(sizeof(struct foo))</code> became the accepted practice.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> However, this practice is discouraged in ANSI C as it can mask a failure to include the header file in which <code>malloc</code> is defined, resulting in downstream errors on machines where the int and pointer types are of different sizes, such as most common implementations of C for the now-ubiquitous <a href="x86_64" title="wikilink">x86 64</a> architecture.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> A conflict arises in code that is required to compile as C++, since the cast is necessary in that language.</p>
<h3 id="c-1">C++</h3>

<p>Some features of C++ that promote more type-safe code:</p>
<ul>
<li>The <a href="new_(C++)" title="wikilink">new</a> operator returns a pointer of type based on operand, whereas <a class="uri" href="malloc" title="wikilink">malloc</a> returns a void pointer.</li>
<li>C++ code can use virtual functions and <a href="Template_(programming)" title="wikilink">templates</a> to achieve polymorphism without void pointers.</li>
<li><a href="C_macro" title="wikilink">Preprocessor</a> constants (without type) can be rewritten as <a href="Constant_(programming)" title="wikilink">const</a> variables (typed).</li>
<li><a href="C_macro" title="wikilink">Preprocessor</a> macro functions (without type) can be rewritten as <a href="Inline_function" title="wikilink">inline</a> functions (typed). The flexibility of accepting and returning different types can still be obtained by function overloading.</li>
<li>Safer casting operators, such as <a href="dynamic_cast" title="wikilink">dynamic cast</a> that performs run-time type checking.</li>
</ul>
<h3 id="c-2">C#</h3>

<p><a href="C_Sharp_(programming_language)" title="wikilink">C#</a> is type-safe (but not statically type-safe). It has support for untyped pointers, but this must be accessed using the "unsafe" keyword which can be prohibited at the compiler level. It has inherent support for run-time cast validation. Casts can be validated by using the "as" keyword that will return a null reference if the cast is invalid, or by using a C-style cast that will throw an exception if the cast is invalid. See <a href="C_Sharp_Syntax#Conversion_operators" title="wikilink">C Sharp conversion operators</a>.</p>

<p>Undue reliance on the <a href="C_Sharp_syntax#object_class" title="wikilink">object</a> type (from which all other types are derived) runs the risk of defeating the purpose of the C# type system. It is usually better practice to abandon object references in favour of <a href="Generic_programming#Generic_programming_in_.NET" title="wikilink">generics</a>, similar to templates in C++ and <a href="generics_in_Java" title="wikilink">generics in Java</a>.</p>
<h3 id="java">Java</h3>

<p>The <a href="Java_language" title="wikilink">Java language</a> is designed to enforce type safety. Anything in Java <em>happens</em> inside an <a href="Object_(computer_science)" title="wikilink">object</a> and each object is an instance of a <a href="Class_(computer_programming)" title="wikilink">class</a>.</p>

<p>To implement the <em>type safety</em> enforcement, each object, before usage, needs to be <a href="Memory_allocation" title="wikilink">allocated</a>. Java allows usage of <a href="Primitive_data_type" title="wikilink">primitive types</a> but only inside properly allocated objects.</p>

<p>Sometimes a part of the type safety is implemented indirectly: e.g. the class BigDecimal represents a floating point number of arbitrary precision, but handles only numbers that can be expressed with a finite representation. The operation BigDecimal.divide() calculates a new object as the division of two numbers expressed as BigDecimal.</p>

<p>In this case if the division has no finite representation, as when one computes e.g. 1/3=0.33333..., the divide() method can rise an exception if no rounding mode is defined for the operation. Hence the library, rather than the language, guarantees that the object respects the contract implicit in the class definition.</p>
<h3 id="standard-ml">Standard ML</h3>

<p><a href="Standard_ML" title="wikilink">SML</a> has rigorously defined semantics and is known to be type-safe. However, some implementations of SML, including <a href="Standard_ML_of_New_Jersey" title="wikilink">Standard ML of New Jersey</a> (SML/NJ), its syntactic variant <a class="uri" href="Mythryl" title="wikilink">Mythryl</a> and <a class="uri" href="Mlton" title="wikilink">Mlton</a>, provide libraries that offer certain unsafe operations. These facilities are often used in conjunction with those implementations' <a href="foreign_function_interface" title="wikilink">foreign function interfaces</a> to interact with non-ML code (such as C libraries) that may require data laid out in specific ways. Another example is the SML/NJ <a href="read-eval-print_loop" title="wikilink">interactive toplevel</a> itself, which must use unsafe operations to execute ML code entered by the user.</p>
<h3 id="modula-2">Modula-2</h3>

<p>Modula-2 is a strongly typed language with a design philosophy to require any unsafe facilities to be explicitly marked as unsafe. This is achieved by "moving" such facilities into a built-in pseudo-library called SYSTEM from where they must be imported before they can be used. The import thus makes it visible when such facilities are used. Unfortunately, this was not consequently implemented in the original language report and its implementation.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> There still remained unsafe facilities such as the type cast syntax and variant records (inherited from Pascal) that could be used without prior import.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The difficulty in moving these facilities into the SYSTEM pseudo-module was the lack of any identifier for the facility that could then be imported since only identifiers can be imported, but not syntax.</p>
<div class="sourceCode"><pre class="sourceCode modula2"><code class="sourceCode modula2"><span class="kw">IMPORT</span> SYSTEM; <span class="co">(* allows the use of certain unsafe facilities: *)</span>
<span class="kw">VAR</span> word : SYSTEM.WORD; addr : SYSTEM.<span class="dt">ADDRESS</span>;
addr := SYSTEM.<span class="dt">ADR</span>(word);

<span class="co">(* but type cast syntax can be used without such import *)</span>
<span class="kw">VAR</span> i : <span class="dt">INTEGER</span>; n : <span class="dt">CARDINAL</span>;
n := <span class="dt">CARDINAL</span>(i); <span class="co">(* or *)</span> i := <span class="dt">INTEGER</span>(n);</code></pre></div>

<p>The ISO Modula-2 standard corrected this for the type cast facility by changing the type cast syntax into a function called CAST which has to be imported from pseudo-module SYSTEM. However, other unsafe facilities such as variant records remained available without any import from pseudo-module SYSTEM.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<div class="sourceCode"><pre class="sourceCode modula2"><code class="sourceCode modula2"><span class="kw">IMPORT</span> SYSTEM;
<span class="kw">VAR</span> i : <span class="dt">INTEGER</span>; n : <span class="dt">CARDINAL</span>;
i := SYSTEM.CAST(<span class="dt">INTEGER</span>, n); <span class="co">(* Type cast in ISO Modula-2 *)</span></code></pre></div>

<p>A recent revision of the language applied the original design philosophy rigorously. First, pseudo-module SYSTEM was renamed to UNSAFE to make the unsafe nature of facilities imported from there more explicit. Then all remaining unsafe facilities where either removed altogether (for example variant records) or moved to pseudo-module UNSAFE. For facilities where there is no identifier that could be imported, enabling identifiers were introduced. In order to enable such a facility, its corresponding enabling identifier must be imported from pseudo-module UNSAFE. No unsafe facilities remain in the language that do not require import from UNSAFE.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<div class="sourceCode"><pre class="sourceCode modula2"><code class="sourceCode modula2"><span class="kw">IMPORT</span> UNSAFE;
<span class="kw">VAR</span> i : <span class="dt">INTEGER</span>; n : <span class="dt">CARDINAL</span>;
i := UNSAFE.CAST(<span class="dt">INTEGER</span>, n); <span class="co">(* Type cast in Modula-2 Revision 2010 *)</span>

<span class="kw">FROM</span> UNSAFE <span class="kw">IMPORT</span> FFI; <span class="co">(* enabling identifier for foreign function interface facility *)</span>
&lt;*FFI=<span class="st">"C"</span>*&gt; <span class="co">(* pragma for foreign function interface to C *)</span></code></pre></div>
<h3 id="pascal">Pascal</h3>

<p><a href="Pascal_(programming_language)" title="wikilink">Pascal</a> has had a number of type safety requirements, some of which are kept in some compilers. Where a Pascal compiler dictates "strict typing", two variables cannot be assigned to each other unless they are either compatible (such as conversion of integer to real) or assigned to the identical subtype. For example, if you have the following code fragment:</p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal"><span class="kw">type</span>
  TwoTypes = <span class="kw">record</span>
     I: <span class="dt">Integer</span>;
     Q: <span class="dt">Real</span>;
  <span class="kw">end</span>;

  DualTypes = <span class="kw">record</span>
    I: <span class="dt">Integer</span>;
    Q: <span class="dt">Real</span>;
  <span class="kw">end</span>;

<span class="kw">var</span>
  T1, T2:  TwoTypes;
  D1, D2:  DualTypes;</code></pre></div>

<p>Under strict typing, a variable defined as <code>TwoTypes</code> is <em>not compatible</em> with <code>DualTypes</code> (because they are not identical, even though the components of that user defined type are identical) and an assignment of <code> T1 := D2; </code> is illegal. An assignment of <code>T1 := T2; </code> would be legal because the subtypes they are defined to <em>are</em> identical. However, an assignment such as <code>T1.Q := D1.Q;</code> would be legal.</p>
<h3 id="common-lisp">Common Lisp</h3>

<p>In general, <a href="Common_Lisp" title="wikilink">Common Lisp</a> is a type-safe language. A Common Lisp compiler is responsible for inserting dynamic checks for operations whose type safety cannot be proven statically. However, a programmer may indicate that a program should be compiled with a lower level of dynamic type-checking.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> A program compiled in such a mode cannot be considered type-safe.</p>
<h2 id="c-examples">C++ Examples</h2>

<p>The following examples illustrates how C++ cast operators can break type safety when used incorrectly. The first example shows how basic data types can be incorrectly casted:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include <iostream></iostream></span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main () {
    <span class="dt">int</span>   ival = <span class="dv">5</span>;                              <span class="co">// integer value</span>
    <span class="dt">float</span> fval = <span class="kw">reinterpret_cast</span>&lt;<span class="dt">float</span>&amp;&gt;(ival); <span class="co">// reinterpret bit pattern</span>
    cout &lt;&lt; fval &lt;&lt; endl;                        <span class="co">// output integer as float</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}
<!--<span class="dt"-->float</code></pre></div></body>&amp;&gt;

<p>In this example, <code>reinterpret_cast</code> explicitly prevents the compiler from performing a safe conversion from integer to floating-point value.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> When the program runs it will output a garbage floating-point value. The problem could have been avoided by instead writing <code>float fval = ival;</code></p>

<p>The next example shows how object references can be incorrectly downcasted:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include <iostream></iostream></span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">class</span> Parent {
<span class="kw">public</span>:
    <span class="kw">virtual</span> ~Parent() {} <span class="co">// virtual destructor for RTTI</span>
};

<span class="kw">class</span> Child1 : <span class="kw">public</span> Parent {
<span class="kw">public</span>:
    <span class="dt">int</span> a;
};

<span class="kw">class</span> Child2 : <span class="kw">public</span> Parent {
<span class="kw">public</span>:
    <span class="dt">double</span> b;
};

<span class="dt">int</span> main () {
    Child1 c1;
    c1.a = <span class="dv">5</span>;
    Parent &amp; p = c1;                     <span class="co">// upcast always safe</span>
    Child2 &amp; c2 = <span class="kw">static_cast</span><child2&>(p); <span class="co">// invalid downcast</span>
    cout &lt;&lt; c2.b &lt;&lt; endl;          <span class="co">// will output garbage data</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}
</child2&></code></pre></div>

<p>The two child classes have members of different types. When downcasting a parent class pointer to a child class pointer, then the resulting pointer may not point to a valid object of correct type. In the example, this leads to garbage value being printed. The problem could have been avoided by replacing <code>static_cast</code> with <code>dynamic_cast</code> that throws an exception on invalid casts.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Type_theory" title="wikilink">Type theory</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Programming_language_topics" title="wikilink">Category:Programming language topics</a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://www.smlnj.org/sml.html">Standard ML</a>. Smlnj.org. Retrieved on 2013-11-02.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Type safety is hence also a matter of good class definition: public methods that modify the internal state of an object shall preserve the object itegrity<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a class="uri" href="http://en.cppreference.com/w/cpp/language/reinterpret_cast">http://en.cppreference.com/w/cpp/language/reinterpret_cast</a><a href="#fnref14">↩</a></li>
<li id="fn15"><a class="uri" href="http://en.cppreference.com/w/cpp/language/dynamic_cast">http://en.cppreference.com/w/cpp/language/dynamic_cast</a><a href="#fnref15">↩</a></li>
</ol>
</section>


