<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1525">BrownBoost</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>BrownBoost</h1>
<hr/>

<p><strong>BrownBoost</strong> is a <a href="Boosting_(meta-algorithm)" title="wikilink">boosting</a> algorithm that may be robust to noisy datasets. BrownBoost is an adaptive version of the <a href="boost_by_majority" title="wikilink">boost by majority</a> algorithm. As is true for all <a href="boosting_(machine_learning)" title="wikilink">boosting</a> algorithms, BrownBoost is used in conjunction with other <a href="machine_learning" title="wikilink">machine learning</a> methods. BrownBoost was introduced by <a href="Yoav_Freund" title="wikilink">Yoav Freund</a> in 2001.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="motivation">Motivation</h2>

<p><a class="uri" href="AdaBoost" title="wikilink">AdaBoost</a> performs well on a variety of datasets; however, it can be shown that AdaBoost does not perform well on noisy data sets.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This is a result of AdaBoost's focus on examples that are repeatedly misclassified. In contrast, BrownBoost effectively "gives up" on examples that are repeatedly misclassified. The core assumption of BrownBoost is that noisy examples will be repeatedly mislabeled by the weak hypotheses and non-noisy examples will be correctly labeled frequently enough to not be "given up on." Thus only noisy examples will be "given up on," whereas non-noisy examples will contribute to the final classifier. In turn, if the final classifier is learned from the non-noisy examples, the <a href="generalization_error" title="wikilink">generalization error</a> of the final classifier may be much better than if learned from noisy and non-noisy examples.</p>

<p>The user of the algorithm can set the amount of error to be tolerated in the training set. Thus, if the training set is noisy (say 10% of all examples are assumed to be mislabeled), the booster can be told to accept a 10% error rate. Since the noisy examples may be ignored, only the true examples will contribute to the learning process.</p>
<h2 id="algorithm-description">Algorithm Description</h2>

<p>BrownBoost uses a non-convex potential loss function, thus it does not fit into the <a class="uri" href="AnyBoost" title="wikilink">AnyBoost</a> framework. The non-convex optimization provides a method to avoid overfitting noisy data sets. However, in contrast to boosting algorithms that analytically minimize a convex loss function (e.g. <a class="uri" href="AdaBoost" title="wikilink">AdaBoost</a> and <a class="uri" href="LogitBoost" title="wikilink">LogitBoost</a>), BrownBoost solves a system of two equations and two unknowns using standard numerical methods.</p>

<p>The only parameter of BrownBoost (

<math display="inline" id="BrownBoost:0">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 in the algorithm) is the "time" the algorithm runs. The theory of BrownBoost states that each hypothesis takes a variable amount of time (

<math display="inline" id="BrownBoost:1">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 in the algorithm) which is directly related to the weight given to the hypothesis 

<math display="inline" id="BrownBoost:2">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

. The time parameter in BrownBoost is analogous to the number of iterations 

<math display="inline" id="BrownBoost:3">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 in AdaBoost.</p>

<p>A larger value of 

<math display="inline" id="BrownBoost:4">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 means that BrownBoost will treat the data as if it were less noisy and therefore will give up on fewer examples. Conversely, a smaller value of 

<math display="inline" id="BrownBoost:5">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 means that 

<math display="inline" id="BrownBoost:6">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 BrownBoost will treat the data as more noisy and give up on more examples.</p>

<p>During each iteration of the algorithm, a hypothesis is selected with some advantage over random guessing. The weight of this hypothesis 

<math display="inline" id="BrownBoost:7">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 and the "amount of time passed" 

<math display="inline" id="BrownBoost:8">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 during the iteration are simultaneously solved in a system of two non-linear equations ( 1. uncorrelate hypothesis w.r.t example weights and 2. hold the potential constant) with two unknowns (weight of hypothesis 

<math display="inline" id="BrownBoost:9">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 and time passed 

<math display="inline" id="BrownBoost:10">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

). This can be solved by bisection (as implemented in the <a class="uri" href="JBoost" title="wikilink">JBoost</a> software package) or <a href="Newton's_method" title="wikilink">Newton's method</a> (as described in the original paper by Freund). Once these equations are solved, the margins of each example (

<math display="inline" id="BrownBoost:11">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}(x_{j})
  </annotation>
 </semantics>
</math>

 in the algorithm) and the amount of time remaining 

<math display="inline" id="BrownBoost:12">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 are updated appropriately. This process is repeated until there is no time remaining.</p>

<p>The initial potential is defined to be 

<math display="inline" id="BrownBoost:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>m</mi>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </msubsup>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mtext>erf</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <msqrt>
       <mi>c</mi>
      </msqrt>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mtext>erf</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <msqrt>
       <mi>c</mi>
      </msqrt>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>m</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>erf</mtext>
      <apply>
       <root></root>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <mtext>erf</mtext>
      <apply>
       <root></root>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{m}\sum_{j=1}^{m}1-\mbox{erf}(\sqrt{c})=1-\mbox{erf}(\sqrt{c})
  </annotation>
 </semantics>
</math>

. Since a constraint of each iteration is that the potential be held constant, the final potential is 

<math display="inline" id="BrownBoost:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>m</mi>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </msubsup>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mtext>erf</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>r</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>/</mo>
       <msqrt>
        <mi>c</mi>
       </msqrt>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mtext>erf</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <msqrt>
       <mi>c</mi>
      </msqrt>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>m</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>erf</mtext>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <root></root>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <mtext>erf</mtext>
      <apply>
       <root></root>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{m}\sum_{j=1}^{m}1-\mbox{erf}(r_{i}(x_{j})/\sqrt{c})=1-\mbox{erf}(%
\sqrt{c})
  </annotation>
 </semantics>
</math>

. Thus the final error is <em>likely</em> to be near 

<math display="inline" id="BrownBoost:15">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mrow>
    <mtext>erf</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <msqrt>
      <mi>c</mi>
     </msqrt>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <mtext>erf</mtext>
     <apply>
      <root></root>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\mbox{erf}(\sqrt{c})
  </annotation>
 </semantics>
</math>

. However, the final potential function is not the 0-1 loss error function. For the final error to be exactly 

<math display="inline" id="BrownBoost:16">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mrow>
    <mtext>erf</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <msqrt>
      <mi>c</mi>
     </msqrt>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <mtext>erf</mtext>
     <apply>
      <root></root>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\mbox{erf}(\sqrt{c})
  </annotation>
 </semantics>
</math>

, the variance of the loss function must decrease linearly w.r.t. time to form the 0-1 loss function at the end of boosting iterations. This is not yet discussed in the literature and is not in the definition of the algorithm below.</p>

<p>The final classifier is a linear combination of weak hypotheses and is evaluated in the same manner as most other boosting algorithms.</p>
<h2 id="brownboost-learning-algorithm-definition">BrownBoost Learning Algorithm Definition</h2>

<p>Input:</p>
<ul>
<li>

<math display="inline" id="BrownBoost:17">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 training examples 

<math display="inline" id="BrownBoost:18">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>m</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>m</ci>
     </apply>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},y_{1}),\ldots,(x_{m},y_{m})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="BrownBoost:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo>∈</mo>
    <mi>X</mi>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>j</mi>
    </msub>
    <mo>∈</mo>
    <mi>Y</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
      <ci>Y</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <set>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
       </apply>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}\in X,\,y_{j}\in Y=\{-1,+1\}
  </annotation>
 </semantics>
</math>

</li>
<li>The parameter 

<math display="inline" id="BrownBoost:20">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Initialise:</p>
<ul>
<li>

<math display="inline" id="BrownBoost:21">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=c
  </annotation>
 </semantics>
</math>

. The value of 

<math display="inline" id="BrownBoost:22">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is the amount of time remaining in the game)</li>
<li>

<math display="inline" id="BrownBoost:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}(x_{j})=0
  </annotation>
 </semantics>
</math>

   

<math display="inline" id="BrownBoost:24">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall j
  </annotation>
 </semantics>
</math>

. The value of 

<math display="inline" id="BrownBoost:25">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}(x_{j})
  </annotation>
 </semantics>
</math>

 is the margin at iteration 

<math display="inline" id="BrownBoost:26">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 for example 

<math display="inline" id="BrownBoost:27">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>While 

<math display="inline" id="BrownBoost:28">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s>0
  </annotation>
 </semantics>
</math>

:</p>
<ul>
<li>Set the weights of each example

<math display="block" id="BrownBoost:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>W</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <msub>
           <mi>r</mi>
           <mi>i</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>j</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mi>s</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mi>c</mi>
     </mfrac>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <ci>s</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{i}(x_{j})=e^{-\frac{(r_{i}(x_{j})+s)^{2}}{c}}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="BrownBoost:30">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}(x_{j})
  </annotation>
 </semantics>
</math>

 is the margin of example 

<math display="inline" id="BrownBoost:31">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

</li>
<li>Find a classifier 

<math display="inline" id="BrownBoost:32">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <set>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{i}:X\to\{-1,+1\}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="BrownBoost:33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>j</mi>
    </msub>
    <mrow>
     <msub>
      <mi>W</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>h</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j}W_{i}(x_{j})h_{i}(x_{j})y_{j}>0
  </annotation>
 </semantics>
</math>

</li>
<li>Find values 

<math display="inline" id="BrownBoost:34">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>,</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>α</ci>
    <ci>t</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha,t
  </annotation>
 </semantics>
</math>

 that satisfy the equation:<br/>


<math display="inline" id="BrownBoost:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>j</mi>
    </msub>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mfrac>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <mrow>
             <msub>
              <mi>r</mi>
              <mi>i</mi>
             </msub>
             <mrow>
              <mo stretchy="false">(</mo>
              <msub>
               <mi>x</mi>
               <mi>j</mi>
              </msub>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>+</mo>
            <mrow>
             <mi>α</mi>
             <msub>
              <mi>h</mi>
              <mi>i</mi>
             </msub>
             <mrow>
              <mo stretchy="false">(</mo>
              <msub>
               <mi>x</mi>
               <mi>j</mi>
              </msub>
              <mo stretchy="false">)</mo>
             </mrow>
             <msub>
              <mi>y</mi>
              <mi>j</mi>
             </msub>
            </mrow>
            <mo>+</mo>
            <mi>s</mi>
           </mrow>
           <mo>-</mo>
           <mi>t</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
        <mi>c</mi>
       </mfrac>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <apply>
            <plus></plus>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>r</ci>
              <ci>i</ci>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>x</ci>
              <ci>j</ci>
             </apply>
            </apply>
            <apply>
             <times></times>
             <ci>α</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>h</ci>
              <ci>i</ci>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>x</ci>
              <ci>j</ci>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>y</ci>
              <ci>j</ci>
             </apply>
            </apply>
            <ci>s</ci>
           </apply>
           <ci>t</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <ci>c</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j}h_{i}(x_{j})y_{j}e^{-\frac{(r_{i}(x_{j})+\alpha h_{i}(x_{j})y_{j}+s-t)%
^{2}}{c}}=0
  </annotation>
 </semantics>
</math>

.<br/>
(Note this is similar to the condition 

<math display="inline" id="BrownBoost:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>E</mi>
     <msub>
      <mi>W</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mi>h</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>y</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{W_{i+1}}[h_{i}(x_{j})y_{j}]=0
  </annotation>
 </semantics>
</math>

 set forth by Schapire and Singer.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In this setting, we are numerically finding the 

<math display="inline" id="BrownBoost:37">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mi mathvariant="normal">…</mi>
      <mi mathvariant="normal">…</mi>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <divide></divide>
      <ci>normal-…</ci>
      <ci>normal-…</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{i+1}=\exp(\frac{\ldots}{\ldots})
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="BrownBoost:38">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>E</mi>
     <msub>
      <mi>W</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mi>h</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>y</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{W_{i+1}}[h_{i}(x_{j})y_{j}]=0
  </annotation>
 </semantics>
</math>

.)<br/>
 This update is subject to the constraint<br/>


<math display="inline" id="BrownBoost:39">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mrow>
           <msub>
            <mi>r</mi>
            <mi>i</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mi>j</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>+</mo>
          <mrow>
           <mi>α</mi>
           <mi>h</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mi>j</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
           <msub>
            <mi>y</mi>
            <mi>j</mi>
           </msub>
          </mrow>
          <mo>+</mo>
          <mi>s</mi>
         </mrow>
         <mo>-</mo>
         <mi>t</mi>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <msub>
           <mi>r</mi>
           <mi>i</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>j</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mi>s</mi>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <sum></sum>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>α</ci>
          <ci>h</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>j</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <ci>s</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum\left(\Phi\left(r_{i}(x_{j})+\alpha h(x_{j})y_{j}+s-t\right)-\Phi\left(r_{%
i}(x_{j})+s\right)\right)=0
  </annotation>
 </semantics>
</math>

,<br/>
 where 

<math display="inline" id="BrownBoost:40">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mtext>erf</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>/</mo>
       <msqrt>
        <mi>c</mi>
       </msqrt>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <mtext>erf</mtext>
      <apply>
       <divide></divide>
       <ci>z</ci>
       <apply>
        <root></root>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(z)=1-\mbox{erf}(z/\sqrt{c})
  </annotation>
 </semantics>
</math>

 is the potential loss for a point with margin 

<math display="inline" id="BrownBoost:41">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}(x_{j})
  </annotation>
 </semantics>
</math>

</li>
<li>Update the margins for each example

<math display="block" id="BrownBoost:42">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>α</mi>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>h</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i+1}(x_{j})=r_{i}(x_{j})+\alpha h(x_{j})y_{j}
  </annotation>
 </semantics>
</math>

</li>
<li>Update the time remaining

<math display="block" id="BrownBoost:43">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mo>-</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <minus></minus>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=s-t
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Output

<math display="block" id="BrownBoost:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mtext>sign</mtext>
    <mrow>
     <mo>(</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>i</mi>
      </munder>
      <mrow>
       <msub>
        <mi>α</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>h</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>sign</mtext>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(x)=\textrm{sign}\left(\sum_{i}\alpha_{i}h_{i}(x)\right)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="empirical-results">Empirical Results</h2>

<p>In preliminary experimental results with noisy datasets, BrownBoost outperformed <a class="uri" href="AdaBoost" title="wikilink">AdaBoost</a>'s generalization error; however, <a class="uri" href="LogitBoost" title="wikilink">LogitBoost</a> performed as well as BrownBoost.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> An implementation of BrownBoost can be found in the open source software <a class="uri" href="JBoost" title="wikilink">JBoost</a>.</p>
<h2 id="references">References</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Boosting_(machine_learning)" title="wikilink">Boosting</a></li>
<li><a class="uri" href="AdaBoost" title="wikilink">AdaBoost</a></li>
<li><a href="Alternating_decision_tree" title="wikilink">Alternating decision trees</a></li>
<li><a class="uri" href="JBoost" title="wikilink">JBoost</a></li>
</ul>

<p>"</p>

<p><a href="Category:Classification_algorithms" title="wikilink">Category:Classification algorithms</a> <a href="Category:Ensemble_learning" title="wikilink">Category:Ensemble learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Yoav Freund. An adaptive version of the boost by majority algorithm. Machine Learning, 43(3):293--318, June 2001.<a href="#fnref1">↩</a></li>
<li id="fn2">Dietterich, T. G., (2000). An experimental comparison of three methods for constructing ensembles of decision trees: Bagging, boosting, and randomization. Machine Learning, 40 (2) 139-158.<a href="#fnref2">↩</a></li>
<li id="fn3">Robert Schapire and Yoram Singer. Improved Boosting Using Confidence-rated Predictions. Journal of Machine Learning, Vol 37(3), pages 297-336. 1999<a href="#fnref3">↩</a></li>
<li id="fn4">Ross A. McDonald, David J. Hand, Idris A. Eckley. An Empirical Comparison of Three Boosting Algorithms on Real Data Sets with Artificial Class Noise. Multiple Classifier Systems, In Series Lecture Notes in Computer Science, pages 35-44, 2003.<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
