   Goertzel algorithm      Goertzel algorithm   The Goertzel algorithm is a Digital Signal Processing (DSP) technique that provides a means for efficient evaluation of individual terms of the Discrete Fourier Transform (DFT), thus making it useful in certain practical applications, such as recognition of DTMF tones produced by the buttons pushed on a telephone keypad. The algorithm was first described by Gerald Goertzel in 1958. 1  Like the DFT, the Goertzel algorithm analyses one selectable frequency component from a discrete signal . 2 3 4 Unlike direct DFT calculations, the Goertzel algorithm applies a single real-valued coefficient at each iteration, using real-valued arithmetic for real-valued input sequences. For covering a full spectrum, the Goertzel algorithm has a higher order of complexity than Fast Fourier Transform (FFT) algorithms; but for computing a small number of selected frequency components, it is more numerically efficient. The simple structure of the Goertzel algorithm makes it well suited to small processors and embedded applications, though not limited to these.  The Goertzel algorithm can also be used "in reverse" as a sinusoid synthesis function, which requires only 1 multiplication and 1 subtraction per generated sample. 5  The algorithm  The main calculation in the Goertzel algorithm has the form of a digital filter , and for this reason the algorithm is often called a Goertzel filter . The filter operates on an input sequence,    x   (  n  )       x  n    x(n)   , in a cascade of two stages with a parameter,   f   f   f   , giving the frequency to be analysed, normalised to cycles per sample.  The first stage calculates an intermediate sequence,    s   (  n  )       s  n    s(n)   :   (1)     s   (  n  )    =     x   (  n  )    +   2   cos   (   2  π  f   )    s   (   n  -  1   )     -   s   (   n  -  2   )           s  n         x  n     2      2  π  f    s    n  1       s    n  2       s(n)=x(n)+2\cos(2\pi f)s(n-1)-s(n-2)      The second stage applies the following filter to    s   (  n  )       s  n    s(n)   , producing output sequence    y   (  n  )       y  n    y(n)   .   (2)     y   (  n  )    =    s   (  n  )    -    e   -   2  π  i  f     s   (   n  -  1   )           y  n       s  n      superscript  e      2  π  i  f     s    n  1       y(n)=s(n)-e^{-2\pi if}s(n-1)      The first filter stage can be observed to be a second-order IIR filter with a direct form structure. This particular structure has the property that its internal state variables equal the past output values from that stage. Input values    x   (  n  )       x  n    x(n)   for    n  <  0      n  0    n<0   are presumed all equal to 0. To establish the initial filter state so that evaluation can begin at sample    x   (  0  )       x  0    x(0)   , the filter states are assigned initial values     s   (   -  2   )    =   s   (   -  1   )    =  0          s    2      s    1         0     s(-2)=s(-1)=0   . To avoid aliasing hazards , frequency   f   f   f   is often restricted to the range 0 to 1/2 (see Nyquist–Shannon sampling theorem ); using a value outside this range is not meaningless, but is equivalent to using an aliased frequency inside this range, since the exponential function is periodic with a period of 1 cycle per sample in f .  The second stage filter can be observed to be a FIR filter , since its calculations do not use any of its past outputs.  Z transform methods can be applied to study the properties of the filter cascade. The Z transform of the first filter stage given in equation (1) is:   (3)       S   (  z  )     X   (  z  )     =   1    1  -   2   cos   (   2  π  f   )     z   -  1      +   z   -  2      =   1    (   1  -    e   +   2  π  i  f      z   -  1      )    (   1  -    e   -   2  π  i  f      z   -  1      )      .            S  z     X  z      1      1    2      2  π  f     superscript  z    1       superscript  z    2             1      1     superscript  e      2  π  i  f      superscript  z    1        1     superscript  e      2  π  i  f      superscript  z    1           \frac{S(z)}{X(z)}=\frac{1}{1-2\cos(2\pi f)z^{-1}+z^{-2}}=\frac{1}{(1-e^{+2\pi
 if%
 }z^{-1})(1-e^{-2\pi if}z^{-1})}.      The Z transform of the second filter stage given in equation (2) is:   (4)      Y   (  z  )     S   (  z  )     =   1  -    e   -   2  π  i  f      z   -  1              Y  z     S  z      1     superscript  e      2  π  i  f      superscript  z    1        \frac{Y(z)}{S(z)}=1-e^{-2\pi if}z^{-1}      The combined transfer function of the cascade of the two filter stages is then   (5)        S   (  z  )     X   (  z  )       Y   (  z  )     S   (  z  )      =    Y   (  z  )     X   (  z  )     =    (   1  -    e   -   2  π  i  f      z   -  1      )     (   1  -    e   +   2  π  i  f      z   -  1      )    (   1  -    e   -   2  π  i  f      z   -  1      )     =   1   1  -    e   +   2  π  i  f      z   -  1        .              S  z     X  z        Y  z     S  z         Y  z     X  z             1     superscript  e      2  π  i  f      superscript  z    1          1     superscript  e      2  π  i  f      superscript  z    1        1     superscript  e      2  π  i  f      superscript  z    1               1    1     superscript  e      2  π  i  f      superscript  z    1          \frac{S(z)}{X(z)}\frac{Y(z)}{S(z)}=\frac{Y(z)}{X(z)}=\frac{(1-e^{-2\pi if}z^{-%
 1})}{(1-e^{+2\pi if}z^{-1})(1-e^{-2\pi if}z^{-1})}=\frac{1}{1-e^{+2\pi if}z^{-%
 1}}.      This can be transformed back to an equivalent time domain sequence, and the terms unrolled back to the first input term at index    n  =  0      n  0    n=0   .   (6) \begin{align}   y(n) & = x(n) + e^{+2 \pi i f} y(n-1) \\  & = \sum_{k=-\infty}^{n}x(k) e^{+2 \pi i f (n-k)} \\  & = e^{+2 \pi i f n} \sum_{k=0}^{n} x(k) e^{-2 \pi i f k}  \end{align}  It can be observed that the poles of the filter's Z transform are located at    e   +   2  π  i  f       superscript  e      2  π  i  f      e^{+2\pi if}   and    e   -   2  π  i  f       superscript  e      2  π  i  f      e^{-2\pi if}   , on a circle of unit radius centered on the origin of the complex Z transform plane . This property indicates that the filter process is marginally stable and vulnerable 6 to numerical error accumulation when computed using low-precision arithmetic and long input sequences.  DFT computations  For the important case of computing a DFT term, the following special restrictions are applied.   the filtering terminates at index    n  =  N      n  N    n=N   where   N   N   N   is the number of terms in the input sequence of the DFT  the frequencies chosen for the Goertzel analysis are restricted to the special form    (7)    f  =   K  N       f    K  N     f=\frac{K}{N}       the index number   K   K   K   indicating the "frequency bin" of the DFT is selected from the set of index numbers    (8)    K  ϵ   {  0  ,  1  ,  2  ,  …  ,   N  -  1   }       K  ϵ   0  1  2  normal-…    N  1      K\epsilon\{0,1,2,...,N-1\}      Making these substitutions into equation (6), and observing that the term     e   +   2  π  i  K     =  1       superscript  e      2  π  i  K     1    e^{+2\pi iK}=1   , equation (6) then takes the following form.   (9)     y   (  N  )    =    ∑   k  =  0   N    x   (  k  )    e   -   2  π  i    k  K   N              y  N     superscript   subscript     k  0    N     x  k   superscript  e      2  π  i      k  K   N          y(N)=\sum_{k=0}^{N}x(k)e^{-2\pi i\frac{kK}{N}}      We can observe that the right side of equation (9) is extremely similar to the defining formula for DFT term    X   (  K  )       X  K    X(K)   , the DFT term for index number K, but not exactly the same. The summation shown in equation (9) requires N+1 input terms, but only N input terms are available when evaluating a DFT. A simple but inelegant expedient is to extend the input sequence   x   x   x   with one more artificial value     x   (  N  )    =  0        x  N   0    x(N)=0   . 7 We can see from equation (9), the mathematical effect on the final result is the same as removing term    x   (  N  )       x  N    x(N)   from the summation, thus delivering the intended DFT value.  However, there is a more elegant approach that avoids the extra filter pass. From equation (1), we can note that when the extended input term     x   (  N  )    =  0        x  N   0    x(N)=0   is used in the final step,   (10)     s   (  N  )    =    2   cos   (   2  π  f   )    s   (   N  -  1   )    -   s   (   N  -  2   )           s  N       2      2  π  f    s    N  1      s    N  2       s(N)=2\cos(2\pi f)s(N-1)-s(N-2)      Thus, the algorithm can be completed as follows:   terminate the IIR filter after processing input term    x   (   N  -  1   )       x    N  1     x(N-1)     apply equation (10) to construct    s   (  N  )       s  N    s(N)   from the prior outputs    s   (   N  -  1   )       s    N  1     s(N-1)   and    s   (   N  -  2   )       s    N  2     s(N-2)     apply equation (2) with the calculated    s   (  N  )       s  N    s(N)   value, and with    s   (   N  -  1   )       s    N  1     s(N-1)   produced by the final direct calculation of the filter.   The last two mathematical operations are simplified by combining them algebraically.   (11) \begin{align} y(N)\quad & = s(N) - e^{-2 \pi i \frac{K}{N}} s(N-1)\quad \\   & = (2 \cos(2 \pi f) s(N-1) - s(N-2)) - e^{-2 \pi i \frac{K}{N}} s(N-1) \\  & =  e^{2 \pi i \frac{K}{N}} s(N-1) - s(N-2)  \end{align}  Note that stopping the filter updates at term    N  -  1      N  1    N-1   and immediately applying equation (2) rather than equation (11) misses the final filter state updates, yielding a result with incorrect phase. 8  The particular filtering structure chosen for the Goertzel algorithm is the key to its efficient DFT calculations. We can observe that only one output value    y   (  N  )       y  N    y(N)   is used for calculating the DFT, so calculations for all the other output terms are omitted. Since the FIR filter is not calculated, the IIR stage calculations      s   (  0  )    ,   s   (  1  )     ,       s  0     s  1     s(0),s(1),   etc. can be discarded immediately after updating the first stage's internal state.  This seems to leave a paradox: to complete the algorithm, the FIR filter stage must be evaluated once using the final two outputs from the IIR filter stage, while for computational efficiency the IIR filter iteration discards its output values. This is where the properties of the direct-form filter structure are applied. The two internal state variables of the IIR filter provide the last two values of the IIR filter output, which are the terms required to evaluate the FIR filter stage.  Applications  Power spectrum terms  Examining equation (6), a final IIR filter pass to calculate term    s   (  N  )       s  N    s(N)   using a supplemental input value     x   (  N  )    =  0        x  N   0    x(N)=0   applies a complex multiplier of magnitude 1.0 to the previous term    s   (   N  -  1   )       s    N  1     s(N-1)   . Consequently,    s   (  N  )       s  N    s(N)   and    s   (   N  -  1   )       s    N  1     s(N-1)   represent equivalent signal power. It is equally valid to apply equation (11) and calculate the signal power from term    y   (  N  )       y  N    y(N)   , or to apply equation (2) and calculate the signal power from term    y   (   N  -  1   )       y    N  1     y(N-1)   . Both cases lead to the following expression for the signal power represented by DFT term X(K).   (12) \begin{align}   X(K) X'(K) & = y(N)\ y'(N) = y(N-1)\  y'(N-1) \\  & = s(N-1)^2 + s(N-2)^2 - 2 cos(2 \pi \frac{K}{N})\ s(N-1)\ s(N-2)  \end{align}  In the pseudocode below, the variables sprev and sprev2 temporarily store output history from the IIR filter, while x[n] is an indexed element of the array  x which stores the input.  Nterms defined here
 Kterm selected here
 ω = 2 * π * Kterm / Nterms;
 cr = cos(ω);
 ci = sin(ω);
 coeff = 2 * cr;
 
 sprev = 0;
 sprev2 = 0;
 for each index n in range 0 to Nterms-1
   s = x[n] + coeff * sprev - sprev2;
   sprev2 = sprev;
   sprev = s;
 end
 
 power = sprev2*sprev2 + sprev*sprev - coeff*sprev*sprev2 ;  It is possible 9 to organise the computations so that incoming samples are delivered singly to a software object that maintains the filter state between updates, with the final power result accessed after the other processing is done.  Single DFT term with real-valued arithmetic  The case of real-valued input data arises frequently, especially in embedded systems where the input streams result from direct measurements of physical processes. Comparing to the illustration in the previous section, when the input data are real-valued, the filter internal state variables sprev and sprev2 can be observed also to be real-valued, consequently, no complex arithmetic is required in the first IIR stage. Optimizing for real-valued arithmetic typically is as simple as applying appropriate real-valued data types for the variables.  After the calculations using input term    x   (   N  -  1   )       x    N  1     x(N-1)   , and filter iterations are terminated, equation (11) must be applied to evaluate the DFT term. The final calculation uses complex-valued arithmetic, but this can be converted into real-valued arithmetic by separating real and imaginary terms.   (13) \begin{align}   c_r  & = \cos(2 \pi \frac{K}{N}) \\  c_i  & = \sin(2 \pi \frac{K}{N}) \\  y(N) & = c_rs(N-1) - s(N-2) +  i c_is(N-1)  \end{align}  Comparing to the power spectrum application, the only difference is the calculation used to finish.  (Same IIR filter calculations as in the signal power implementation)
 XKreal = sprev * cr - sprev2;
 XKimag = sprev * ci;  Phase detection  This application requires the same evaluation of DFT term    X   (  K  )       X  K    X(K)   , as discussed in the previous section, using a real-valued or complex-valued input stream. Then the signal phase can be evaluated as:   (14)    ϕ  =    tan   -  1      ℑ   (   X   (  K  )    )     ℜ   (   X   (  K  )    )          ϕ    superscript     1          X  K        X  K        \phi=\tan^{-1}\frac{\Im(X(K))}{\Re(X(K))}      taking appropriate precautions for singularities, quadrant, and so forth when computing the inverse tangent function.  Complex signals in real arithmetic  Since complex signals decompose linearly into real and imaginary parts, the Goertzel algorithm can be computed in real arithmetic separately over the sequence of real parts, yielding     y  r    (  n  )        subscript  y  r   n    y_{r}(n)   ; and over the sequence of imaginary parts, yielding     y  i    (  n  )        subscript  y  i   n    y_{i}(n)   . After that, the two complex-valued partial results can be recombined:   (15)     y   (  n  )    =     y  r    (  n  )    +    i    y  i    (  n  )           y  n        subscript  y  r   n     i   subscript  y  i   n      y(n)=y_{r}(n)+i\ y_{i}(n)      Computational complexity   According to computational complexity theory , computing a set of   M   M   M   DFT terms using   M   M   M   applications of the Goertzel algorithm on a data set with   N   N   N   values with a "cost per operation" of   K   K   K   has complexity     O   (   K  N  M   )       O    K  N  M     O(KNM)   .    To compute a single DFT bin    X   (  f  )       X  f    X(f)   for a complex input sequence of length   N   N   N   , the Goertzel algorithm requires    2  N      2  N    2N   multiplications and     4   N      4  N    4\ N   additions/subtractions within the loop, as well as 4 multiplications and 4 final additions/subtractions, for a total of     2  N   +  4        2  N   4    2N+4   multiplications and     4  N   +  4        4  N   4    4N+4   additions/subtractions. This is repeated for each of the   M   M   M   frequencies.    In contrast, using an FFT on a data set with   N   N   N   values has complexity    O   (   K  N   log  N    )       O    K  N    N      O(KN\log N)   .    This is harder to apply directly because it depends on the FFT algorithm used, but a typical  example is a radix-2 FFT, which requires    2    log  2   N       2    subscript   2   N     2\log_{2}N   multiplications and    3    log  2   N       3    subscript   2   N     3\log_{2}N   additions/subtractions per DFT bin, for each of the   N   N   N   bins.   In the complexity order expressions, when the number of calculated terms   M   M   M   is smaller than    log  N      N    \log N   , the advantage of the Goertzel algorithm is clear. But because FFT code is comparatively complex, the "cost per unit of work" factor   K   K   K   is often larger for an FFT, and the practical advantage favours the Goertzel algorithm even for   M   M   M   several times larger than     log  2   N      subscript   2   N    \log_{2}N   .  As a rule-of-thumb for determining whether a radix-2 FFT or a Goertzel algorithm is more efficient, adjust the number of terms N in the data set upward to the nearest exact power of 2, calling this    N  2     subscript  N  2    N_{2}   , and the Goertzel algorithm is likely to be faster if      M  ≤     5   N  2     6  N      log  2    N  2         M        5   subscript  N  2      6  N      subscript   2    subscript  N  2       M\leq\frac{5N_{2}}{6N}\log_{2}N_{2}     FFT implementations and processing platforms have a significant impact on the relative performance. Some FFT implementations 10 perform internal complex-number calculations to generate coefficients on-the-fly, significantly increasing their "cost K per unit of work." FFT and DFT algorithms can use tables of pre-computed coefficient values for better numerical efficiency, but this requires more accesses to coefficient values buffered in external memory, which can lead to increased cache contention that counters some of the numerical advantage.  Both algorithms  gain approximately a factor of 2 efficiency  when using real-valued rather than complex-valued input data. However, these gains are natural for the Goertzel algorithm but will not be achieved for the FFT without using certain algorithm variants  specialised for transforming real-valued data .  See also   Bluestein's FFT algorithm (chirp-Z)  Frequency-Shift Keying (FSK)  Phase-Shift Keying (PSK)   References  Further reading     External links   http://netwerkt.wordpress.com/2011/08/25/goertzel-filter/ C Code implementation of iterative Goertzel algorithm  http://www.embedded.com/design/configurable-systems/4006427/A-DSP-algorithm-for-frequency-analysis ( Java ) A DSP algorithm for frequency analysis - the Chirp-Z Transform (CZT)   "  Category:FFT algorithms  Category:Digital signal processing     ↩  ; also found in DSP Applications with the TMS320 Family, Vol. 1, Texas Instruments, 1989. ↩  ↩  ↩  http://cs-www.cs.yale.edu/c2/images/uploads/AudioProc-TR.pdf ↩  ↩  ↩  ↩  ↩  ↩     