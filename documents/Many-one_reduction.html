<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="357">Many-one reduction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Many-one reduction</h1>
<hr/>

<p>In <a href="computability_theory" title="wikilink">computability theory</a> and <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, a <strong>many-one reduction</strong> is a <a href="reduction_(complexity)" title="wikilink">reduction</a> which converts instances of one <a href="decision_problem" title="wikilink">decision problem</a> into instances of a second decision problem. Reductions are thus used to measure the relative computational difficulty of two problems.</p>

<p>Many-one reductions are a special case and stronger form of <a href="Turing_reduction" title="wikilink">Turing reductions</a>. With many-one reductions the oracle can be invoked only once at the end and the answer cannot be modified.</p>

<p>Many-one reductions were first used by <a href="Emil_Post" title="wikilink">Emil Post</a> in a paper published in 1944.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Later <a href="Norman_Shapiro" title="wikilink">Norman Shapiro</a> used the same concept in 1956 under the name <em>strong reducibility</em>.</p>
<h2 id="definitions">Definitions</h2>
<h3 id="formal-languages">Formal languages</h3>

<p>Suppose <em>A</em> and <em>B</em> are <a href="formal_language" title="wikilink">formal languages</a> over the <a href="Alphabet_(computer_science)" title="wikilink">alphabets</a> Σ and Γ, respectively. A <strong>many-one reduction</strong> from <em>A</em> to <em>B</em> is a <a href="total_computable_function" title="wikilink">total computable function</a> <em>f</em> : Σ<sup>*</sup> → Γ<sup>*</sup> that has the property that each word <em>w</em> is in <em>A</em> if and only if <em>f</em>(<em>w</em>) is in <em>B</em> (that is, 

<math display="inline" id="Many-one_reduction:0">
<semantics>
<mrow>
<mi>A</mi>
<mo>=</mo>
<mrow>
<msup>
<mi>f</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>B</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>A</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>B</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A=f^{-1}(B)
  </annotation>
</semantics>
</math>

).</p>

<p>If such a function <em>f</em> exists, we say that <em>A</em> is <strong>many-one reducible</strong> or <strong>m-reducible</strong> to <em>B</em> and write</p>

<p>
<math display="block" id="Many-one_reduction:1">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<msub>
<mo>≤</mo>
<mi>m</mi>
</msub>
<mi>B</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<leq></leq>
<ci>m</ci>
</apply>
<ci>A</ci>
<ci>B</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\leq_{m}B.
  </annotation>
</semantics>
</math>

 If there is an <a class="uri" href="injective" title="wikilink">injective</a> many-one reduction function then we say <em>A</em> is <strong>1 reducible</strong> or <strong>one-one reducible</strong> to <em>B</em> and write</p>

<p>
<math display="block" id="Many-one_reduction:2">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<msub>
<mo>≤</mo>
<mn>1</mn>
</msub>
<mi>B</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<leq></leq>
<cn type="integer">1</cn>
</apply>
<ci>A</ci>
<ci>B</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\leq_{1}B.
  </annotation>
</semantics>
</math>
</p>
<h3 id="subsets-of-natural-numbers">Subsets of natural numbers</h3>

<p>Given two sets 

<math display="inline" id="Many-one_reduction:3">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<mo>,</mo>
<mi>B</mi>
</mrow>
<mo>⊆</mo>
<mi>ℕ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<list>
<ci>A</ci>
<ci>B</ci>
</list>
<ci>ℕ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A,B\subseteq\mathbb{N}
  </annotation>
</semantics>
</math>

 we say 

<math display="inline" id="Many-one_reduction:4">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 is <strong>many-one reducible</strong> to 

<math display="inline" id="Many-one_reduction:5">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B
  </annotation>
</semantics>
</math>

 and write</p>

<p>
<math display="block" id="Many-one_reduction:6">
<semantics>
<mrow>
<mi>A</mi>
<msub>
<mo>≤</mo>
<mi>m</mi>
</msub>
<mi>B</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<leq></leq>
<ci>m</ci>
</apply>
<ci>A</ci>
<ci>B</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\leq_{m}B
  </annotation>
</semantics>
</math>

 if there exists a <a href="total_computable_function" title="wikilink">total computable function</a>
<math display="inline" id="Many-one_reduction:7">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 with 

<math display="inline" id="Many-one_reduction:8">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<mo>=</mo>
<mrow>
<msup>
<mi>f</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>B</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>A</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>B</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A=f^{-1}(B).
  </annotation>
</semantics>
</math>

 If additionally 

<math display="inline" id="Many-one_reduction:9">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 is <a class="uri" href="injective" title="wikilink">injective</a> we say 

<math display="inline" id="Many-one_reduction:10">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 is <strong>1-reducible</strong> to 

<math display="inline" id="Many-one_reduction:11">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B
  </annotation>
</semantics>
</math>

 and write</p>

<p>
<math display="block" id="Many-one_reduction:12">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<msub>
<mo>≤</mo>
<mn>1</mn>
</msub>
<mi>B</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<leq></leq>
<cn type="integer">1</cn>
</apply>
<ci>A</ci>
<ci>B</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\leq_{1}B.
  </annotation>
</semantics>
</math>
</p>
<h3 id="many-one-equivalence-and-1-equivalence">Many-one equivalence and 1 equivalence</h3>

<p>If 

<math display="inline" id="Many-one_reduction:13">
<semantics>
<mrow>
<mi>A</mi>
<msub>
<mo>≤</mo>
<mi>m</mi>
</msub>
<mrow>
<mpadded width="+1.7pt">
<mi>B</mi>
</mpadded>
<mpadded width="+1.7pt">
<mi>and</mi>
</mpadded>
<mi>B</mi>
</mrow>
<msub>
<mo>≤</mo>
<mi>m</mi>
</msub>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<leq></leq>
<ci>m</ci>
</apply>
<ci>A</ci>
<apply>
<times></times>
<ci>B</ci>
<ci>and</ci>
<ci>B</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<leq></leq>
<ci>m</ci>
</apply>
<share href="#.cmml">
</share>
<ci>A</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\leq_{m}B\,\mathrm{and}\,B\leq_{m}A
  </annotation>
</semantics>
</math>

 we say 

<math display="inline" id="Many-one_reduction:14">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 is <strong>many-one equivalent</strong> or <strong>m-equivalent</strong> to 

<math display="inline" id="Many-one_reduction:15">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B
  </annotation>
</semantics>
</math>

 and write</p>

<p>
<math display="block" id="Many-one_reduction:16">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<msub>
<mo>≡</mo>
<mi>m</mi>
</msub>
<mi>B</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<equivalent></equivalent>
<ci>m</ci>
</apply>
<ci>A</ci>
<ci>B</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\equiv_{m}B.
  </annotation>
</semantics>
</math>
</p>

<p>If 

<math display="inline" id="Many-one_reduction:17">
<semantics>
<mrow>
<mi>A</mi>
<msub>
<mo>≤</mo>
<mn>1</mn>
</msub>
<mrow>
<mpadded width="+1.7pt">
<mi>B</mi>
</mpadded>
<mpadded width="+1.7pt">
<mi>and</mi>
</mpadded>
<mi>B</mi>
</mrow>
<msub>
<mo>≤</mo>
<mn>1</mn>
</msub>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<leq></leq>
<cn type="integer">1</cn>
</apply>
<ci>A</ci>
<apply>
<times></times>
<ci>B</ci>
<ci>and</ci>
<ci>B</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<leq></leq>
<cn type="integer">1</cn>
</apply>
<share href="#.cmml">
</share>
<ci>A</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\leq_{1}B\,\mathrm{and}\,B\leq_{1}A
  </annotation>
</semantics>
</math>

 we say 

<math display="inline" id="Many-one_reduction:18">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 is <strong>1-equivalent</strong> to 

<math display="inline" id="Many-one_reduction:19">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B
  </annotation>
</semantics>
</math>

 and write</p>

<p>
<math display="block" id="Many-one_reduction:20">
<semantics>
<mrow>
<mrow>
<mi>A</mi>
<msub>
<mo>≡</mo>
<mn>1</mn>
</msub>
<mi>B</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<equivalent></equivalent>
<cn type="integer">1</cn>
</apply>
<ci>A</ci>
<ci>B</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\equiv_{1}B.
  </annotation>
</semantics>
</math>
</p>
<h3 id="many-one-completeness-m-completeness">Many-one completeness (m-completeness)</h3>

<p>A set <em>B</em> is called <em>many-one complete</em>, or simply <strong>m-complete</strong>, <a class="uri" href="iff" title="wikilink">iff</a> <em>B</em> is recursively enumerable and every recursively enumerable set <em>A</em> is m-reducible to <em>B</em>.</p>
<h2 id="many-one-reductions-with-resource-limitations">Many-one reductions with resource limitations</h2>

<p>Many-one reductions are often subjected to resource restrictions, for example that the reduction function is computable in polynomial time or logarithmic space; see <a href="polynomial-time_reduction" title="wikilink">polynomial-time reduction</a> and <a href="log-space_reduction" title="wikilink">log-space reduction</a> for details.</p>

<p>Given decision problems <em>A</em> and <em>B</em> and an <a class="uri" href="algorithm" title="wikilink">algorithm</a> <em>N</em> which solves instances of B, we can use a many-one reduction from <em>A</em> to <em>B</em> to solve instances of <em>A</em> in:</p>
<ul>
<li>the time needed for <em>N</em> plus the time needed for the reduction</li>
<li>the maximum of the space needed for <em>N</em> and the space needed for the reduction</li>
</ul>

<p>We say that a class <strong>C</strong> of languages (or a subset of the <a href="power_set" title="wikilink">power set</a> of the natural numbers) is <em>closed under many-one reducibility</em> if there exists no reduction from a language in <strong>C</strong> to a language outside <strong>C</strong>. If a class is closed under many-one reducibility, then many-one reduction can be used to show that a problem is in <strong>C</strong> by reducing a problem in <strong>C</strong> to it. Many-one reductions are valuable because most well-studied complexity classes are closed under some type of many-one reducibility, including <a href="P_(complexity)" title="wikilink">P</a>, <a href="NP_(complexity)" title="wikilink">NP</a>, <a href="L_(complexity)" title="wikilink">L</a>, <a href="NL_(complexity)" title="wikilink">NL</a>, <a class="uri" href="co-NP" title="wikilink">co-NP</a>, <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>, <a class="uri" href="EXP" title="wikilink">EXP</a>, and many others. These classes are not closed under arbitrary many-one reductions, however.</p>
<h2 id="properties">Properties</h2>
<ul>
<li>The <a href="relation_(mathematics)" title="wikilink">relations</a> of many-one reducibility and 1 reducibility are <a href="transitive_relation" title="wikilink">transitive</a> and <a href="reflexive_relation" title="wikilink">reflexive</a> and thus induce a <a class="uri" href="preorder" title="wikilink">preorder</a> on the <a class="uri" href="powerset" title="wikilink">powerset</a> of the natural numbers.</li>
<li>
<math display="inline" id="Many-one_reduction:21">
<semantics>
<mrow>
<mi>A</mi>
<msub>
<mo>≤</mo>
<mi>m</mi>
</msub>
<mi>B</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<leq></leq>
<ci>m</ci>
</apply>
<ci>A</ci>
<ci>B</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\leq_{m}B
  </annotation>
</semantics>
</math>
<a href="if_and_only_if" title="wikilink">if and only if</a>
<math display="inline" id="Many-one_reduction:22">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>ℕ</mi>
<mo>∖</mo>
<mi>A</mi>
</mrow>
<msub>
<mo>≤</mo>
<mi>m</mi>
</msub>
<mrow>
<mi>ℕ</mi>
<mo>∖</mo>
<mi>B</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<leq></leq>
<ci>m</ci>
</apply>
<apply>
<setdiff></setdiff>
<ci>ℕ</ci>
<ci>A</ci>
</apply>
<apply>
<setdiff></setdiff>
<ci>ℕ</ci>
<ci>B</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{N}\setminus A\leq_{m}\mathbb{N}\setminus B.
  </annotation>
</semantics>
</math>
</li>
<li>A set is many-one reducible to the <a href="halting_problem" title="wikilink">halting problem</a> <a href="if_and_only_if" title="wikilink">if and only if</a> it is <a href="recursively_enumerable" title="wikilink">recursively enumerable</a>. This says that with regards to many-one reducibility, the halting problem is the most complicated of all computer programs. Thus the halting problem is many-one complete.</li>
<li>The specialized halting problem for an <em>individual</em> Turing machine <em>T</em> (i.e., the set of inputs for which <em>T</em> eventually halts) is many-one complete iff <em>T</em> is a <a href="universal_Turing_machine" title="wikilink">universal Turing machine</a>. Emil Post showed that there exist recursively enumerable sets that are neither <a href="Decidability_(logic)" title="wikilink">decidable</a> nor m-complete, and hence that <em>there exist <u>non</u>universal Turing machines whose individual halting problems are nevertheless undecidable</em>.</li>
</ul>
<h2 id="references">References</h2>
<h2 id="reading">Reading</h2>
<ul>
<li>E. L. Post, "Recursively enumerable sets of positive integers and their decision problems", <a href="Bulletin_of_the_American_Mathematical_Society" title="wikilink">Bulletin of the American Mathematical Society</a> <strong>50</strong> (1944) 284-316</li>
<li>Norman Shapiro, "Degrees of Computability", <a href="Transactions_of_the_American_Mathematical_Society" title="wikilink">Transactions of the American Mathematical Society</a> <strong>82</strong>, (1956) 281-299</li>
</ul>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">E. L. Post, "Recursively enumerable sets of positive integers and their decision problems", <a href="Bulletin_of_the_American_Mathematical_Society" title="wikilink">Bulletin of the American Mathematical Society</a> <strong>50</strong> (1944) 284-316<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
