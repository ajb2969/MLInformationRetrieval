<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="671">Types of mesh</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Types of mesh</h1>
<hr/>

<p>In computational solutions of <a href="partial_differential_equations" title="wikilink">partial differential equations</a>, meshing is a discrete representation of the geometry that is involved in the problem. Essentially, it partitions space into <em>elements</em> (or <em>cells</em> or <em>zones</em>) over which the equations can be approximated. Zone boundaries can be free to create computationally best shaped zones, or they can be fixed to represent internal or external boundaries within a model.</p>

<p>In addition, meshes also find extensive use in the analysis of geographical and cartographic data.</p>
<h2 id="mesh-quality">Mesh quality</h2>

<p>The mesh quality can be conclusively determined based on the following factors.</p>
<h3 id="rate-of-convergence">Rate of convergence</h3>

<p>The greater the rate of <a href="Convergence_(mathematics)" title="wikilink">convergence</a>, the better the mesh quality. It means that the correct solution has been achieved faster. An inferior mesh quality may leave out certain important phenomena such as the boundary layer that occurs in fluid flow. In this case the solution may not converge or the rate of convergence will be impaired.</p>
<h3 id="solution-accuracy">Solution accuracy</h3>

<p>A better mesh quality provides a more accurate solution. For example, one can refine the mesh at certain areas of the geometry where the gradients are high, thus increasing the fidelity of solutions in the region. Also, this means that if a mesh is not sufficiently refined then the accuracy of the solution is more limited. Thus, mesh quality is dictated by the required accuracy.</p>
<h3 id="cpu-time-required">CPU time required</h3>

<p>CPU time is a necessary yet undesirable factor. For a highly refined mesh, where the number of cells per unit area is maximum, the CPU time required will be relatively large. Time will generally be proportional to the number of elements.</p>
<h2 id="common-cell-shapes">Common cell shapes</h2>
<h3 id="two-dimensional">Two-dimensional</h3>

<p> There are two types of two-dimensional cell shapes that are commonly used. These are the <a class="uri" href="triangle" title="wikilink">triangle</a> and the <a class="uri" href="quadrilateral" title="wikilink">quadrilateral</a>.</p>

<p>Computationally poor elements will have sharp <a href="internal_angle" title="wikilink">internal angles</a> or short edges or both.</p>
<h4 id="triangle">Triangle</h4>

<p>This cell shape consists of 3 sides and is one of the simplest types of mesh. A triangular surface mesh is always quick and easy to create. It is most common in <a href="unstructured_grid" title="wikilink">unstructured grids</a>.</p>
<h4 id="quadrilateral">Quadrilateral</h4>

<p>This cell shape is a basic 4 sided one as shown in the figure. It is most common in structured grids.</p>

<p>Quadrilateral elements are usually excluded from being or becoming concave.</p>
<h3 id="three-dimensional">Three-dimensional</h3>
<figure><b>(Figure)</b>
<figcaption>Basic three-dimensional cell shapes</figcaption>
</figure>

<p>The basic 3-dimensional element are the <a class="uri" href="tetrahedron" title="wikilink">tetrahedron</a>, <a href="quadrilateral_pyramid" title="wikilink">quadrilateral pyramid</a>, <a href="triangular_prism" title="wikilink">triangular prism</a>, and <a class="uri" href="hexahedron" title="wikilink">hexahedron</a>. They all have triangular and quadrilateral faces.</p>

<p>Extruded 2-dimensional models may be represented entirely by prisms and hexahedra as extruded triangles and quadrilaterals.</p>

<p>In general, quadrilateral faces in 3-dimensions may not be perfectly planar. A nonplanar quadrilateral face can be considered a thin tetrahedral volume that is shared by two neighboring elements.</p>
<h4 id="tetrahedron">Tetrahedron</h4>

<p>A <a class="uri" href="tetrahedron" title="wikilink">tetrahedron</a> has 4 vertices, 6 edges, and is bounded by 4 triangular faces. In most cases a tetrahedral volume mesh can be generated automatically.</p>
<h4 id="pyramid">Pyramid</h4>

<p>A quadrilaterally-based <a href="square_pyramid" title="wikilink">pyramid</a> has 5 vertices, 8 edges, bounded by 4 triangular and 1 quadrilateral face. These are effectively used as transition elements between square and triangular faced elements and other in hybrid meshes and grids.</p>
<h4 id="triangular-prism">Triangular prism</h4>

<p>A <a href="triangular_prism" title="wikilink">triangular prism</a> has 6 vertices, 9 edges, bounded by 2 triangular and 3 quadrilateral faces. The advantage with this type of layer is that it resolves boundary layer efficiently.</p>
<h4 id="hexahedron">Hexahedron</h4>

<p>A <a class="uri" href="hexahedron" title="wikilink">hexahedron</a>, a topological <a class="uri" href="cube" title="wikilink">cube</a>, has 8 vertices, 12 edges, bounded by 6 quadrilateral faces. It is also called a <strong>hex</strong> or a <strong>brick</strong>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> For the same cell amount, the accuracy of solutions in hexahedral meshes is the highest.</p>

<p>The pyramid and triangular prism zones can be considered computationally as degenerate hexahedrons, where some edges have been reduced to zero. Other degenate forms of a hexahedron may also be represented.</p>
<h2 id="classification-of-grids">Classification of grids</h2>

<p> </p>
<h3 id="structured-grids">Structured grids</h3>

<p><a href="Structured_grid" title="wikilink">Structured grids</a> are identified by regular connectivity. The possible element choices are quadrilateral in 2D and hexahedra in 3D. This model is highly space efficient, i.e. since the neighborhood relationships are defined by storage arrangement. Some other advantages of structured grid over unstructured are better convergence and higher resolution.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="unstructured-grids">Unstructured grids</h3>

<p>An <a href="unstructured_grid" title="wikilink">unstructured grid</a> is identified by irregular connectivity. It cannot easily be expressed as a two-dimensional or three-dimensional array in computer memory. This allows for any possible element that a solver might be able to use. Compared to structured meshes, this model can be highly space inefficient since it calls for explicit storage of neighborhood relationships. These grids typically employ triangles in 2D and tetrahedra in 3D. <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="hybrid-grids">Hybrid grids</h3>

<p>A hybrid grid contains a mixture of structured portions and unstructured portions. It integrates the structured meshes and the unstructured meshes in an efficient manner. Those parts of the geometry that are regular can have structured grids and those that are complex can have unstructured grids. These grids can be non-conformal which means that grid lines don’t need to match at block boundaries. <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="deciding-the-type-of-mesh">Deciding the type of mesh</h2>

<p> If the accuracy is of the highest concern then hexahedral mesh is the most preferable one. The density of the mesh is required to be sufficiently high in order to capture all the flow features but on the same note, it should not be so high that it captures unnecessary details of the flow, thus burdening the CPU and wasting more time. Whenever a wall is present, the mesh adjacent to the wall is fine enough to resolve the boundary layer flow and generally quad, hex and prism cells are preferred over triangles, tetrahedrons and pyramids. Quad and Hex cells can be stretched where the flow is fully developed and one-dimensional.</p>
<figure><b>(Figure)</b>
<figcaption><code>Depicts</code> <code>the</code> <code>skewness</code> <code>of</code> <code>a</code> <code>quadrilateral</code></figcaption>
</figure>

<p>Based on the skewness, smoothness, and aspect ratio, the suitability of the mesh can be decided. <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="skewness">Skewness</h3>

<p>The skewness of a grid is an apt indicator of the mesh quality and suitability. Large skewness compromises the accuracy of the interpolated regions. There are three methods of determining the skewness of a grid.</p>
<h4 id="based-on-equilateral-volume">Based on equilateral volume</h4>

<p>This method is applicable to triangles and tetrahedral only and is the default method.</p>

<p>

<math display="block" id="Types_of_mesh:0">
 <semantics>
  <mrow>
   <mtext>Skewness</mtext>
   <mo>=</mo>
   <mfrac>
    <mtext>optimal cell size - cell size</mtext>
    <mtext>optimal cell size</mtext>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>Skewness</mtext>
    <apply>
     <divide></divide>
     <mtext>optimal cell size - cell size</mtext>
     <mtext>optimal cell size</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{ Skewness }=\frac{\text{ optimal cell size - cell size }}{\text{optimal %
cell size}}
  </annotation>
 </semantics>
</math>

</p>
<figure><b>(Figure)</b>
<figcaption><code>Smooth</code> <code>and</code> <code>large</code> <code>jump</code> <code>change</code></figcaption>
</figure>
<h4 id="based-on-the-deviation-from-normalized-equilateral-angle">Based on the deviation from normalized equilateral angle</h4>

<p>This method applies to all cell and face shapes and is almost always used for prisms and pyramids</p>

<p>

<math display="block" id="Types_of_mesh:1">
 <semantics>
  <mrow>
   <mtext>Skewness ( for a quad )</mtext>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo>[</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>θ</mi>
        <mrow>
         <mi>m</mi>
         <mi>a</mi>
         <mi>x</mi>
        </mrow>
       </msub>
       <mo>-</mo>
       <mn>90</mn>
      </mrow>
      <mn>90</mn>
     </mfrac>
     <mo>,</mo>
     <mfrac>
      <mrow>
       <mn>90</mn>
       <mo>-</mo>
       <msub>
        <mi>θ</mi>
        <mrow>
         <mi>m</mi>
         <mi>i</mi>
         <mi>n</mi>
        </mrow>
       </msub>
      </mrow>
      <mn>90</mn>
     </mfrac>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>Skewness ( for a quad )</mtext>
    <apply>
     <max></max>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <cn type="integer">90</cn>
      </apply>
      <cn type="integer">90</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <cn type="integer">90</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">90</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{ Skewness ( for a quad ) }=\max{\left[\frac{\theta_{max}-90}{90},\frac{9%
0-\theta_{min}}{90}\right]}
  </annotation>
 </semantics>
</math>

</p>
<h4 id="equiangular-skew">Equiangular skew</h4>

<p>Another common measure of quality is based on equiangular skew.</p>

<p>

<math display="block" id="Types_of_mesh:2">
 <semantics>
  <mrow>
   <mtext>Equiangle Skew</mtext>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo>[</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>θ</mi>
        <mrow>
         <mi>m</mi>
         <mi>a</mi>
         <mi>x</mi>
        </mrow>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>θ</mi>
        <mi>e</mi>
       </msub>
      </mrow>
      <mrow>
       <mn>180</mn>
       <mo>-</mo>
       <msub>
        <mi>θ</mi>
        <mi>e</mi>
       </msub>
      </mrow>
     </mfrac>
     <mo>,</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>θ</mi>
        <mi>e</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>θ</mi>
        <mrow>
         <mi>m</mi>
         <mi>i</mi>
         <mi>n</mi>
        </mrow>
       </msub>
      </mrow>
      <msub>
       <mi>θ</mi>
       <mi>e</mi>
      </msub>
     </mfrac>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>Equiangle Skew</mtext>
    <apply>
     <max></max>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <ci>e</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">180</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <ci>e</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <ci>e</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>e</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{ Equiangle Skew }=\max{\left[\frac{\theta_{max}-\theta_{e}}{180-\theta_{%
e}},\frac{\theta_{e}-\theta_{min}}{\theta_{e}}\right]}
  </annotation>
 </semantics>
</math>

</p>

<p>where:</p>

<p>

<math display="block" id="Types_of_mesh:3">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>θ</mi>
    <mrow>
     <mi>m</mi>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{max}\,
  </annotation>
 </semantics>
</math>

 is the largest angle in a face or cell,</p>

<p>

<math display="block" id="Types_of_mesh:4">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>θ</mi>
    <mrow>
     <mi>m</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{min}\,
  </annotation>
 </semantics>
</math>

 is the smallest angle in a face or cell,</p>

<p>

<math display="block" id="Types_of_mesh:5">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>θ</mi>
    <mi>e</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{e}\,
  </annotation>
 </semantics>
</math>

 is the angle for equi-angular face or cell i.e. 60 for a triangle and 90 for a square.</p>

<p>A skewness' of 0 is the best possible one and a skewness of one is almost never preferred. For Hex and quad cells, skewness should not exceed 0.85 to obtain a fairly accurate solution.  For triangular cells, skewness should not exceed 0.85 and for quadrilateral cells, skewness should not exceed 0.9.</p>
<h3 id="smoothness">Smoothness</h3>

<p>The change in size should also be smooth. There should not be sudden jumps in the size of the cell because this may cause erroneous results at nearby nodes.</p>
<h3 id="aspect-ratio">Aspect ratio</h3>

<p>It is the ratio of longest to the shortest side in a cell. Ideally it should be equal to 1 to ensure best results. For <a class="uri" href="multidimensional" title="wikilink">multidimensional</a> flow, it should be near to one. Also local variations in cell size should be minimal, i.e. adjacent cell sizes should not vary by more than 20%. Having a large <a href="aspect_ratio" title="wikilink">aspect ratio</a> can result in an interpolation error of unacceptable magnitude.</p>
<h2 id="mesh-improvement">Mesh improvement</h2>

<p>In two dimensions, flipping and smoothing are powerful tools for adapting a poor mesh into a good mesh. Flipping involves combining two triangles to form a quadrilateral, then splitting the quadrilateral in the other direction to produce two new triangles. Flipping is used to improve quality measures of a triangle such as skewness. Mesh smoothing enhances element shapes and overall mesh quality by adjusting the location of mesh vertices. In mesh smoothing, core features such as non-zero pattern of the <a href="linear_system" title="wikilink">linear system</a> are preserved as the topology of the mesh remains invariant. <a class="uri" href="Laplacian" title="wikilink">Laplacian</a> smoothing is the most commonly used smoothing technique.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Computational_fluid_dynamics" title="wikilink">Category:Computational fluid dynamics</a> <a href="Category:Mesh_generation" title="wikilink">Category:Mesh generation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.colorado.edu/engineering/CAS/courses.d/AFEM.d/AFEM.Ch11.d/AFEM.Ch11.pdf">Hexahedron elements</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.pointwise.com/theconnector/March-2013/Structured-Grids-in-Pointwise.shtml">1</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
