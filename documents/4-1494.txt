   Algebraic normal form      Algebraic normal form   In Boolean algebra , the algebraic normal form ( ANF ), Zhegalkin normal form , or Reed–Muller expansion is a way of writing logical formulas in one of three subforms:   The entire formula is purely true or false:  1  0   One or more variables are ANDed together into a term. One or more terms are XORed together into ANF. No NOTs are permitted:  a ⊕ b ⊕ ab ⊕ abc   or in standard propositional logic symbols:     a  ⊻  b  ⊻   (   a  ∧  b   )   ⊻   (   a  ∧  b  ∧  c   )      exclusive-or  a  b    a  b     a  b  c     a\veebar b\veebar\left(a\wedge b\right)\veebar\left(a\wedge b\wedge c\right)     The previous subform with a purely true term:  1 ⊕ a ⊕ b ⊕ ab ⊕ abc    Formulas written in ANF are also known as Zhegalkin polynomials () and Positive Polarity (or Parity) Reed–Muller expressions .  Common uses  ANF is a normal form , which means that two equivalent formulas will convert to the same ANF, easily showing whether two formulas are equivalent for automated theorem proving . Unlike other normal forms, it can be represented as a simple list of lists of variable names. Conjunctive and disjunctive normal forms also require recording whether each variable is negated or not. Negation normal form is unsuitable for that purpose, since it doesn't use equality as its equivalence relation: a ∨ ¬a isn't reduced to the same thing as 1, even though they're equal.  Putting a formula into ANF also makes it easy to identify linear functions (used, for example, in linear feedback shift registers ): a linear function is one that is a sum of single literals. Properties of nonlinear feedback shift registers can also be deduced from certain properties of the feedback function in ANF.  Performing operations within algebraic normal form  There are straightforward ways to perform the standard boolean operations on ANF inputs in order to get ANF results.  XOR (logical exclusive disjunction) is performed directly:   () ⊕ ()   ⊕   1 ⊕ 1 ⊕ x ⊕ x ⊕ y  y   NOT (logical negation) is XORing 1: 1       1 ⊕ 1 ⊕ x ⊕ y  x ⊕ y   AND (logical conjunction) is distributed algebraically 2   ( ⊕ )   ⊕   (1 ⊕ x ⊕ y) ⊕ (x ⊕ x ⊕ xy)  1 ⊕ x ⊕ x ⊕ x ⊕ y ⊕ xy  1 ⊕ x ⊕ y ⊕ xy   OR (logical disjunction) uses either 1 ⊕ (1 ⊕ a)(1 ⊕ b) 3 (easier when both operands have purely true terms) or a ⊕ b ⊕ ab 4 (easier otherwise):   () + ()  1 ⊕ (1 ⊕ )(1 ⊕ )  1 ⊕ x(x ⊕ y)  1 ⊕ x ⊕ xy   Converting to algebraic normal form  Each variable in a formula is already in pure ANF, so you only need to perform the formula's boolean operations as shown above to get the entire formula into ANF. For example:   x + (y · ¬z)  x + (y(1 ⊕ z))  x + (y ⊕ yz)  x ⊕ (y ⊕ yz) ⊕ x(y ⊕ yz)  x ⊕ y ⊕ xy ⊕ yz ⊕ xyz   Formal representation  ANF is sometimes described in an equivalent way:             f   (   x  1   ,   x  2   ,  …  ,   x  n   )    =         f    subscript  x  1    subscript  x  2   normal-…   subscript  x  n     absent    f(x_{1},x_{2},\ldots,x_{n})=\!           a  0   ⊕     limit-from   subscript  a  0   direct-sum    a_{0}\oplus\!               a  1    x  1    ⊕    a  2    x  2    ⊕  ⋯  ⊕     a  n    x  n    ⊕      direct-sum     subscript  a  1    subscript  x  1       subscript  a  2    subscript  x  2    normal-⋯   limit-from     subscript  a  n    subscript  x  n    direct-sum     a_{1}x_{1}\oplus a_{2}x_{2}\oplus\cdots\oplus a_{n}x_{n}\oplus\!               a   1  ,  2     x  1    x  2    ⊕  ⋯  ⊕     a    n  -  1   ,  n     x   n  -  1     x  n    ⊕      direct-sum     subscript  a   1  2     subscript  x  1    subscript  x  2    normal-⋯   limit-from     subscript  a     n  1   n     subscript  x    n  1     subscript  x  n    direct-sum     a_{1,2}x_{1}x_{2}\oplus\cdots\oplus a_{n-1,n}x_{n-1}x_{n}\oplus\!             ⋯  ⊕     limit-from  normal-⋯  direct-sum    \cdots\oplus\!              a   1  ,  2  ,  …  ,  n     x  1    x  2   …    x  n         subscript  a   1  2  normal-…  n     subscript  x  1    subscript  x  2   normal-…   subscript  x  n     a_{1,2,\ldots,n}x_{1}x_{2}\ldots x_{n}\!           where      a  0   ,   a  1   ,  …  ,   a   1  ,  2  ,  …  ,  n     ∈    {  0  ,  1  }   *         subscript  a  0    subscript  a  1   normal-…   subscript  a   1  2  normal-…  n      superscript   0  1       a_{0},a_{1},\ldots,a_{1,2,\ldots,n}\in\{0,1\}^{*}   fully describes   f   f   f   .   Recursively deriving multiargument Boolean functions  There are only four functions with one argument:        f   (  x  )    =  0        f  x   0    f(x)=0          f   (  x  )    =  1        f  x   1    f(x)=1          f   (  x  )    =  x        f  x   x    f(x)=x          f   (  x  )    =   1  ⊕  x         f  x    direct-sum  1  x     f(x)=1\oplus x      To represent a function with multiple arguments one can use the following equality:       f   (   x  1   ,   x  2   ,  …  ,   x  n   )    =    g   (   x  2   ,  …  ,   x  n   )    ⊕    x  1   h   (   x  2   ,  …  ,   x  n   )           f    subscript  x  1    subscript  x  2   normal-…   subscript  x  n      direct-sum    g    subscript  x  2   normal-…   subscript  x  n        subscript  x  1   h    subscript  x  2   normal-…   subscript  x  n        f(x_{1},x_{2},\ldots,x_{n})=g(x_{2},\ldots,x_{n})\oplus x_{1}h(x_{2},\ldots,x_%
 {n})   , where  :*     g   (   x  2   ,  …  ,   x  n   )    =   f   (  0  ,   x  2   ,  …  ,   x  n   )          g    subscript  x  2   normal-…   subscript  x  n       f   0   subscript  x  2   normal-…   subscript  x  n       g(x_{2},\ldots,x_{n})=f(0,x_{2},\ldots,x_{n})     :*     h   (   x  2   ,  …  ,   x  n   )    =    f   (  0  ,   x  2   ,  …  ,   x  n   )    ⊕   f   (  1  ,   x  2   ,  …  ,   x  n   )           h    subscript  x  2   normal-…   subscript  x  n      direct-sum    f   0   subscript  x  2   normal-…   subscript  x  n       f   1   subscript  x  2   normal-…   subscript  x  n        h(x_{2},\ldots,x_{n})=f(0,x_{2},\ldots,x_{n})\oplus f(1,x_{2},\ldots,x_{n})     Indeed,   if     x  1   =  0       subscript  x  1   0    x_{1}=0   then      x  1   h   =  0         subscript  x  1   h   0    x_{1}h=0   and so     f   (  0  ,  …  )    =   f   (  0  ,  …  )          f   0  normal-…      f   0  normal-…      f(0,\ldots)=f(0,\ldots)     if     x  1   =  1       subscript  x  1   1    x_{1}=1   then      x  1   h   =  h         subscript  x  1   h   h    x_{1}h=h   and so     f   (  1  ,  …  )    =    f   (  0  ,  …  )    ⊕   f   (  0  ,  …  )    ⊕   f   (  1  ,  …  )           f   1  normal-…     direct-sum    f   0  normal-…      f   0  normal-…      f   1  normal-…       f(1,\ldots)=f(0,\ldots)\oplus f(0,\ldots)\oplus f(1,\ldots)      Since both   g   g   g   and   h   h   h   have fewer arguments than   f   f   f   it follows that using this process recursively we will finish with functions with one variable. For example, let us construct ANF of     f   (  x  ,  y  )    =   x  ∨  y         f   x  y      x  y     f(x,y)=x\lor y   (logical or):        f   (  x  ,  y  )    =    f   (  0  ,  y  )    ⊕   x   (    f   (  0  ,  y  )    ⊕   f   (  1  ,  y  )     )           f   x  y     direct-sum    f   0  y      x   direct-sum    f   0  y      f   1  y         f(x,y)=f(0,y)\oplus x(f(0,y)\oplus f(1,y))     since     f   (  0  ,  y  )    =   0  ∨  y   =  y          f   0  y      0  y        y     f(0,y)=0\lor y=y   and     f   (  1  ,  y  )    =   1  ∨  y   =  1          f   1  y      1  y        1     f(1,y)=1\lor y=1     it follows that     f   (  x  ,  y  )    =   y  ⊕   x   (   y  ⊕  1   )           f   x  y     direct-sum  y    x   direct-sum  y  1       f(x,y)=y\oplus x(y\oplus 1)     by distribution, we get the final ANF     f   (  x  ,  y  )    =   y  ⊕   x  y   ⊕  x   =   x  ⊕  y  ⊕   x  y            f   x  y     direct-sum  y    x  y   x         direct-sum  x  y    x  y       f(x,y)=y\oplus xy\oplus x=x\oplus y\oplus xy      See also   Boolean function  Logical graph  Zhegalkin polynomial  Negation normal form  Conjunctive normal form  Disjunctive normal form   References  ru:Полином Жегалкина "  Category:Boolean algebra  Category:Normal forms (logic)     WolframAlpha NOT-equivalence demonstration: ¬a = 1 ⊕ a ↩  WolframAlpha AND-equivalence demonstration: (a ⊕ b)(c ⊕ d) = ac ⊕ ad ⊕ bc ⊕ bd ↩  From De Morgan's laws ↩  WolframAlpha OR-equivalence demonstration: a + b = a ⊕ b ⊕ ab ↩     