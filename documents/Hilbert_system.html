<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="140">Hilbert system</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hilbert system</h1>
<hr/>
<dl>
<dd>''In <a href="mathematical_physics" title="wikilink">mathematical physics</a>, <em>Hilbert system</em> is an infrequently used term for a physical system described by a <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a>.''
</dd>
</dl>

<p>In <a class="uri" href="logic" title="wikilink">logic</a>, especially <a href="mathematical_logic" title="wikilink">mathematical logic</a>, a <strong>Hilbert system</strong>, sometimes called <strong>Hilbert calculus</strong> or <strong>Hilbert–Ackermann system</strong>, is a type of system of <a href="Deductive_reasoning" title="wikilink">formal deduction</a> attributed to <a href="Gottlob_Frege" title="wikilink">Gottlob Frege</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and <a href="David_Hilbert" title="wikilink">David Hilbert</a>. These <a href="deductive_system" title="wikilink">deductive systems</a> are most often studied for <a href="first-order_logic" title="wikilink">first-order logic</a>, but are of interest for other logics as well.</p>

<p>Most variants of Hilbert systems take a characteristic tack in the way they balance a <a class="uri" href="trade-off" title="wikilink">trade-off</a> between <a href="logical_axiom" title="wikilink">logical axioms</a> and <a href="Rule_of_inference" title="wikilink">rules of inference</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Hilbert systems can be characterised by the choice of a large number of <a href="axiom_schema" title="wikilink">schemes</a> of logical axioms and a small set of <a href="Rule_of_inference" title="wikilink">rules of inference</a>. Systems of <a href="natural_deduction" title="wikilink">natural deduction</a> take the opposite tack, including many deduction rules but very few or no axiom schemes. The most commonly studied Hilbert systems have either just one rule of inference — <a href="modus_ponens" title="wikilink">modus ponens</a>, for <a href="propositional_logic" title="wikilink">propositional logics</a> — or two — with <a href="generalization_(logic)" title="wikilink">generalisation</a>, to handle <a href="predicate_logic" title="wikilink">predicate logics</a>, as well — and several infinite axiom schemes. Hilbert systems for propositional <a href="modal_logic" title="wikilink">modal logics</a>, sometimes called <a href="Hilbert-Lewis_system" title="wikilink">Hilbert-Lewis systems</a>, are generally axiomatised with two additional rules, the <a href="necessitation_rule" title="wikilink">necessitation rule</a> and the <a href="uniform_substitution" title="wikilink">uniform substitution</a> rule.</p>

<p>A characteristic feature of the many variants of Hilbert systems is that the <em>context</em> is not changed in any of their rules of inference, while both <a href="natural_deduction" title="wikilink">natural deduction</a> and <a href="sequent_calculus" title="wikilink">sequent calculus</a> contain some context-changing rules. Thus, if we are interested only in the derivability of <a href="tautology_(logic)" title="wikilink">tautologies</a>, no hypothetical judgments, then we can formalize the Hilbert system in such a way that its rules of inference contain only <a href="Judgment_(mathematical_logic)" title="wikilink">judgments</a> of a rather simple form. The same cannot be done with the other two deductions systems : as context is changed in some of their rules of inferences, they cannot be formalized so that hypothetical judgments could be avoided — not even if we want to use them just for proving derivability of tautologies.</p>
<h2 id="formal-deductions">Formal deductions</h2>
<figure><b>(Figure)</b>
<figcaption>A graphic representation of the deduction system</figcaption>
</figure>

<p>In a Hilbert-style deduction system, a <strong>formal deduction</strong> is a finite sequence of formulas in which each formula is either an axiom or is obtained from previous formulas by a rule of inference. These formal deductions are meant to mirror natural-language proofs, although they are far more detailed.</p>

<p>Suppose 

<math display="inline" id="Hilbert_system:0">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 is a set of formulas, considered as <strong>hypotheses</strong>. For example 

<math display="inline" id="Hilbert_system:1">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 could be a set of axioms for <a href="group_theory" title="wikilink">group theory</a> or <a href="set_theory" title="wikilink">set theory</a>. The notation 

<math display="inline" id="Hilbert_system:2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\phi
  </annotation>
 </semantics>
</math>

 means that there is a deduction that ends with 

<math display="inline" id="Hilbert_system:3">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 using as axioms only <strong>logical axioms</strong> and elements of 

<math display="inline" id="Hilbert_system:4">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

. Thus, informally, 

<math display="inline" id="Hilbert_system:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\phi
  </annotation>
 </semantics>
</math>

 means that 

<math display="inline" id="Hilbert_system:6">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is provable assuming all the formulas in 

<math display="inline" id="Hilbert_system:7">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

.</p>

<p>Hilbert-style deduction systems are characterized by the use of numerous schemes of <strong>logical axioms</strong>. An <a href="axiom_scheme" title="wikilink">axiom scheme</a> is an infinite set of axioms obtained by substituting all formulas of some form into a specific pattern. The set of logical axioms includes not only those axioms generated from this pattern, but also any generalization of one of those axioms. A generalization of a formula is obtained by prefixing zero or more universal quantifiers on the formula; thus</p>

<p>

<math display="block" id="Hilbert_system:8">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mi>P</mi>
    <mi>x</mi>
    <mi>y</mi>
    <mo>→</mo>
    <mi>P</mi>
    <mi>t</mi>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">P</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall y(\forall xPxy\to Pty)
  </annotation>
 </semantics>
</math>

 is a generalization of 

<math display="inline" id="Hilbert_system:9">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mi>P</mi>
     <mi>x</mi>
     <mi>y</mi>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>P</mi>
    <mi>t</mi>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>P</ci>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>t</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall xPxy\to Pty
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="logical-axioms">Logical axioms</h3>

<p>There are several variant axiomatisations of predicate logic, since for any logic there is freedom in choosing axioms and rules that characterise that logic. We describe here a Hilbert system with nine axioms and just the rule modus ponens, which we call the one-rule axiomatisation and which describes classical equational logic. We deal with a minimal language for this logic, where formulas use only the connectives 

<math display="inline" id="Hilbert_system:10">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hilbert_system:11">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 and only the quantifier 

<math display="inline" id="Hilbert_system:12">
 <semantics>
  <mo>∀</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall
  </annotation>
 </semantics>
</math>

. Later we show how the system can be extended to include additional logical connectives, such as 

<math display="inline" id="Hilbert_system:13">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hilbert_system:14">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

, without enlarging the class of deducible formulas.</p>

<p>The first four logical axiom schemes allow (together with modus ponens) for the manipulation of logical connectives.</p>
<dl>
<dd>P1. 

<math display="inline" id="Hilbert_system:15">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ϕ</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\to\phi
  </annotation>
 </semantics>
</math>


</dd>
<dd>P2. 

<math display="inline" id="Hilbert_system:16">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mi>ψ</mi>
    <mo>→</mo>
    <mi>ϕ</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">ϕ</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\to\left(\psi\to\phi\right)
  </annotation>
 </semantics>
</math>


</dd>
<dd>P3. 

<math display="inline" id="Hilbert_system:17">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mrow>
     <mo>(</mo>
     <mi>ψ</mi>
     <mo>→</mo>
     <mi>ξ</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>ϕ</mi>
     <mo>→</mo>
     <mi>ψ</mi>
     <mo>)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo>(</mo>
     <mi>ϕ</mi>
     <mo>→</mo>
     <mi>ξ</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ξ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ξ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\phi\to\left(\psi\rightarrow\xi\right)\right)\to\left(\left(\phi\to\psi%
\right)\to\left(\phi\to\xi\right)\right)
  </annotation>
 </semantics>
</math>


</dd>
<dd>P4. 

<math display="inline" id="Hilbert_system:18">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>ψ</mi>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mi>ψ</mi>
    <mo>→</mo>
    <mi>ϕ</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\lnot\phi\to\lnot\psi\right)\to\left(\psi\to\phi\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>The axiom P1 is redundant, as it follows from P3, P2 and modus ponens. These axioms describe <a href="classical_propositional_logic" title="wikilink">classical propositional logic</a>; without axiom P4 we get <a href="minimal_logic" title="wikilink">minimal logic</a>. <a href="Intuitionistic_logic" title="wikilink">Intuitionistic logic</a> is achieved by adding instead the axiom P4i for ex falso quodlibet, which is an axiom of classical propositional logic.</p>
<dl>
<dd>P4i. 

<math display="inline" id="Hilbert_system:19">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <not></not>
    <csymbol cd="unknown">ϕ</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot\phi\to\left(\phi\to\psi\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Note that these are axiom schemes, which represent infinitely many specific instances of axioms. For example, P1 might represent the particular axiom instance 

<math display="inline" id="Hilbert_system:20">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>→</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\to p
  </annotation>
 </semantics>
</math>

, or it might represent 

<math display="inline" id="Hilbert_system:21">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(p\to q\right)\to\left(p\to q\right)
  </annotation>
 </semantics>
</math>

: the 

<math display="inline" id="Hilbert_system:22">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is a place where any formula can be placed. A variable such as this that ranges over formulae is called a 'schematic variable'.</p>

<p>With a second rule of <a href="uniform_substitution" title="wikilink">uniform substitution</a> (US), we can change each of these axiom schemes into a single axiom, replacing each schematic variable by some propositional variable that isn't mentioned in any axiom to get what we call the substitutional axiomatisation. Both formalisations have variables, but where the one-rule axiomatisation has schematic variables that are outside the logic's language, the substitutional axiomatisation uses propositional variables that do the same work by expressing the idea of a variable ranging over formulae with a rule that uses substitution.</p>
<dl>
<dd>US. Let 

<math display="inline" id="Hilbert_system:23">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(p)
  </annotation>
 </semantics>
</math>

 be a formula with one or more instances of the propositional variable 

<math display="inline" id="Hilbert_system:24">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, and let 

<math display="inline" id="Hilbert_system:25">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 be another formula. Then from 

<math display="inline" id="Hilbert_system:26">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(p)
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Hilbert_system:27">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(\psi)
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>The next three logical axiom schemes provide ways to add, manipulate, and remove universal quantifiers.</p>
<dl>
<dd>Q5. 

<math display="inline" id="Hilbert_system:28">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo>(</mo>
    <mi>ϕ</mi>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>t</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">ϕ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\left(\phi\right)\to\phi[x:=t]
  </annotation>
 </semantics>
</math>

 where <em>t</em> may be substituted for <em>x</em> in 

<math display="inline" id="Hilbert_system:29">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\!\phi
  </annotation>
 </semantics>
</math>


</dd>
<dd>Q6. 

<math display="inline" id="Hilbert_system:30">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo>(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mrow>
     <mo>(</mo>
     <mi>ϕ</mi>
     <mo>)</mo>
    </mrow>
    <mo>→</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mrow>
     <mo>(</mo>
     <mi>ψ</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\left(\phi\to\psi\right)\to\left(\forall x\left(\phi\right)\to\forall
x%
\left(\psi\right)\right)
  </annotation>
 </semantics>
</math>


</dd>
<dd>Q7. 

<math display="inline" id="Hilbert_system:31">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>→</mo>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo>(</mo>
      <mi>ϕ</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ϕ</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>ϕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\to\forall x\left(\phi\right)
  </annotation>
 </semantics>
</math>

 where <em>x</em> is not a <a href="free_variable" title="wikilink">free variable</a> of 

<math display="inline" id="Hilbert_system:32">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\!\phi
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>These three additional rules extend the propositional system to axiomatise <a href="classical_predicate_logic" title="wikilink">classical predicate logic</a>. Likewise, these three rules extend system for intuitionstic propositional logic (with P1-3 and P4i) to <a href="intuitionistic_predicate_logic" title="wikilink">intuitionistic predicate logic</a>.</p>

<p>Universal quantification is often given an alternative axiomatisation using an extra rule of generalisation (see the section on Metatheorems), in which case the rules Q5 and Q6 are redundant.</p>

<p>The final axiom schemes are required to work with formulas involving the equality symbol.</p>
<dl>
<dd>I8. 

<math display="inline" id="Hilbert_system:33">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=x
  </annotation>
 </semantics>
</math>

 for every variable <em>x</em>.
</dd>
<dd>I9. 

<math display="inline" id="Hilbert_system:34">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>y</mi>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>z</mi>
     <mo>:=</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>→</mo>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>z</mi>
     <mo>:=</mo>
     <mi>y</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">z</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(x=y\right)\to\left(\phi[z:=x]\to\phi[z:=y]\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<h2 id="conservative-extensions">Conservative extensions</h2>

<p>It is common to include in a Hilbert-style deduction system only axioms for implication and negation. Given these axioms, it is possible to form <a href="conservative_extension" title="wikilink">conservative extensions</a> of the <a href="deduction_theorem" title="wikilink">deduction theorem</a> that permit the use of additional connectives. These extensions are called conservative because if a formula φ involving new connectives is rewritten as a <a href="Logical_equivalence" title="wikilink">logically equivalent</a> formula θ involving only negation, implication, and universal quantification, then φ is derivable in the extended system if and only if θ is derivable in the original system. When fully extended, a Hilbert-style system will resemble more closely a system of <a href="natural_deduction" title="wikilink">natural deduction</a>.</p>
<h3 id="existential-quantification">Existential quantification</h3>
<ul>
<li>Introduction</li>
</ul>

<p>

<math display="block" id="Hilbert_system:35">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mo>∃</mo>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo>:=</mo>
      <mi>y</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <exists></exists>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ϕ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x(\phi\to\exists y(\phi[x:=y]))
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>Elimination</li>
</ul>

<p>

<math display="block" id="Hilbert_system:36">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>∃</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <exists></exists>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">ψ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x(\phi\to\psi)\to\exists x(\phi)\to\psi
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Hilbert_system:37">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is not a <a href="free_variable" title="wikilink">free variable</a> of 

<math display="inline" id="Hilbert_system:38">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="conjunction-and-disjunction">Conjunction and Disjunction</h3>
<ul>
<li>Conjunction introduction and elimination</li>
</ul>
<dl>
<dd>introduction

<math display="block" id="Hilbert_system:39">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <mi>β</mi>
   <mo>→</mo>
   <mrow>
    <mi>α</mi>
    <mo>∧</mo>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>α</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <ci>α</ci>
      <ci>β</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\to\beta\to\alpha\land\beta
  </annotation>
 </semantics>
</math>


</dd>
<dd>elimination left

<math display="block" id="Hilbert_system:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mo>∧</mo>
    <mi>β</mi>
   </mrow>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <ci>α</ci>
     <ci>β</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\wedge\beta\to\alpha
  </annotation>
 </semantics>
</math>


</dd>
<dd>elimination right

<math display="block" id="Hilbert_system:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mo>∧</mo>
    <mi>β</mi>
   </mrow>
   <mo>→</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <ci>α</ci>
     <ci>β</ci>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\wedge\beta\to\beta
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<ul>
<li>Disjunction introduction and elimination</li>
</ul>
<dl>
<dd>introduction left

<math display="block" id="Hilbert_system:42">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <mrow>
    <mi>α</mi>
    <mo>∨</mo>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>α</ci>
    <apply>
     <or></or>
     <ci>α</ci>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\to\alpha\vee\beta
  </annotation>
 </semantics>
</math>


</dd>
<dd>introduction right

<math display="block" id="Hilbert_system:43">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>→</mo>
   <mrow>
    <mi>α</mi>
    <mo>∨</mo>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>β</ci>
    <apply>
     <or></or>
     <ci>α</ci>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\to\alpha\vee\beta
  </annotation>
 </semantics>
</math>


</dd>
<dd>elimination

<math display="block" id="Hilbert_system:44">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo>→</mo>
    <mi>γ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>β</mi>
    <mo>→</mo>
    <mi>γ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>α</mi>
   <mo>∨</mo>
   <mi>β</mi>
   <mo>→</mo>
   <mi>γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">γ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">β</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">γ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
    <or></or>
    <csymbol cd="unknown">β</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">γ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha\to\gamma)\to(\beta\to\gamma)\to\alpha\vee\beta\to\gamma
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<h2 id="metatheorems">Metatheorems</h2>

<p>Because Hilbert-style systems have very few deduction rules, it is common to prove <strong>metatheorems</strong> that show that additional deduction rules add no deductive power, in the sense that a deduction using the new deduction rules can be converted into a deduction using only the original deduction rules.</p>

<p>Some common metatheorems of this form are:</p>
<ul>
<li>The <strong>deduction theorem</strong>

<math display="block" id="Hilbert_system:45">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>;</mo>
    <mi>ϕ</mi>
   </mrow>
   <mo>⊢</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <ci>normal-Γ</ci>
     <ci>ϕ</ci>
    </list>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma;\phi\vdash\psi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Hilbert_system:46">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\phi\to\psi
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Hilbert_system:47">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mi>ϕ</mi>
   <mo>↔</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <ci>ϕ</ci>
    </apply>
    <apply>
     <ci>normal-↔</ci>
     <share href="#.cmml">
     </share>
     <ci>ψ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\phi\leftrightarrow\psi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Hilbert_system:48">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\phi\to\psi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hilbert_system:49">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi>ψ</mi>
    <mo>→</mo>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ψ</ci>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\psi\to\phi
  </annotation>
 </semantics>
</math>

.</li>
<li>Contraposition: If 

<math display="inline" id="Hilbert_system:50">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>;</mo>
    <mi>ϕ</mi>
   </mrow>
   <mo>⊢</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <ci>normal-Γ</ci>
     <ci>ϕ</ci>
    </list>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma;\phi\vdash\psi
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Hilbert_system:51">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>;</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>ψ</mi>
    </mrow>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <ci>normal-Γ</ci>
     <apply>
      <times></times>
      <not></not>
      <ci>ψ</ci>
     </apply>
    </list>
    <apply>
     <times></times>
     <not></not>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma;\lnot\psi\vdash\lnot\phi
  </annotation>
 </semantics>
</math>

.</li>
<li>Generalization: If 

<math display="inline" id="Hilbert_system:52">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\phi
  </annotation>
 </semantics>
</math>

 and <em>x</em> does not occur free in any formula of 

<math display="inline" id="Hilbert_system:53">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Hilbert_system:54">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mi>ϕ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>ϕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\forall x\phi
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="alternative-axiomatizations">Alternative axiomatizations</h2>

<p>The axiom 3 above is credited to <a href="Jan_Łukasiewicz" title="wikilink">Łukasiewicz</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The original system by <a href="Gottlob_Frege" title="wikilink">Frege</a> had axioms P2 and P3 but four other axioms instead of axiom P4 (see <a href="Frege's_propositional_calculus" title="wikilink">Frege's propositional calculus</a>). <a href="Bertrand_Russell" title="wikilink">Russell</a> and <a href="Alfred_North_Whitehead" title="wikilink">Whitehead</a> also suggested a system with five propositional axioms.</p>
<h2 id="further-connections">Further connections</h2>

<p>Axioms P1, P2 and P3, with the deduction rule modus ponens (formalising <a href="intuitionistic_propositional_logic" title="wikilink">intuitionistic propositional logic</a>), correspond to <a href="combinatory_logic" title="wikilink">combinatory logic</a> base combinators <strong>I</strong>, <strong>K</strong> and <strong>S</strong> with the application operator. Proofs in the Hilbert system then correspond to combinator terms in combinatory logic. See also <a href="Curry-Howard_correspondence" title="wikilink">Curry-Howard correspondence</a>.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li>

<p>It is a Hungarian translation of <a href="Alfred_Tarski" title="wikilink">Alfred Tarski</a>'s selected papers on <a href="semantic_theory_of_truth" title="wikilink">semantic theory of truth</a>.</p></li>
<li>David Hilbert (1927) "The foundations of mathematics", translated by Stephan Bauer-Menglerberg and Dagfinn Føllesdal (pp. 464–479). in:
<ul>
<li></li>
</ul></li>
</ul>
<dl>
<dd><dl>
<dd>Hilbert's 1927, Based on an earlier 1925 "foundations" lecture (pp. 367–392), presents his 17 axioms -- axioms of implication #1-4, axioms about &amp; and V #5-10, axioms of negation #11-12, his logical ε-axiom #13, axioms of equality #14-15, and axioms of number #16-17 -- along with the other necessary elements of his Formalist "proof theory" -- e.g. induction axioms, recursion axioms, etc; he also offers up a spirited defense against L.E.J. Brouwer's Intuitionism. Also see Hermann Weyl's (1927) comments and rebuttal (pp. 480–484), Paul Bernay's (1927) appendix to Hilbert's lecture (pp. 485–489) and Luitzen Egbertus Jan Brouwer's (1927) response (pp. 490–495)
</dd>
</dl>
</dd>
</dl>
<ul>
<li></li>
</ul>
<dl>
<dd><dl>
<dd>See in particular Chapter IV Formal System (pp. 69–85) wherein Kleene presents subchapters §16 Formal symbols, §17 Formation rules, §18 Free and bound variables (including substitution), §19 Transformation rules (e.g. modus ponens) -- and from these he presents 21 "postulates" -- 18 axioms and 3 "immediate-consequence" relations divided as follows: Postulates for the propostional calculus #1-8, Additional postulates for the predicate calculus #9-12, and Additional postulates for number theory #13-21.
</dd>
</dl>
</dd>
</dl>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li>

<p>It describes (among others) a part of the Hilbert-style deduction system (restricted to <a href="propositional_calculus" title="wikilink">propositional calculus</a>).</p></li>
</ul>

<p>"</p>

<p><a href="Category:Proof_theory" title="wikilink">Category:Proof theory</a> <a href="Category:Logical_calculi" title="wikilink">Category:Logical calculi</a> <a href="Category:Automated_theorem_proving" title="wikilink">Category:Automated theorem proving</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Máté &amp; Ruzsa 1997:129<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3">A. Tarski, Logic, semantics, metamathematics, Oxford, 1956<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
