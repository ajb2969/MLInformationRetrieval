<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="221">A* search algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>A* search algorithm</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>A*</strong> (pronounced as "A star"<small> ( <a href=":Media:En-us-a-star.ogg" title="wikilink">listen</a>)</small>) is a <a href="computer_algorithm" title="wikilink">computer algorithm</a> that is widely used in <a class="uri" href="pathfinding" title="wikilink">pathfinding</a> and <a href="graph_traversal" title="wikilink">graph traversal</a>, the process of plotting an efficiently traversable path between multiple points, called nodes. Noted for its <a href="Computer_performance" title="wikilink">performance</a> and accuracy, it enjoys widespread use. However, in practical travel-routing systems, it is generally outperformed by algorithms which can pre-process the graph to attain better performance,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> although other work has found A* to be superior to other approaches.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p><a href="Peter_E._Hart" title="wikilink">Peter Hart</a>, <a href="Nils_Nilsson_(researcher)" title="wikilink">Nils Nilsson</a> and <a href="Bertram_Raphael" title="wikilink">Bertram Raphael</a> of Stanford Research Institute (now <a href="SRI_International" title="wikilink">SRI International</a>) first described the algorithm in 1968.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> It is an extension of <a href="Edsger_Dijkstra" title="wikilink">Edsger Dijkstra's</a> <a href="Dijkstra's_algorithm" title="wikilink">1959 algorithm</a>. A* achieves better time performance by using <a href="Heuristic_(computer_science)" title="wikilink">heuristics</a>.</p>
<h2 id="description">Description</h2>

<p>A* uses a <a href="best-first_search" title="wikilink">best-first search</a> and finds a least-cost path from a given initial <a href="node_(graph_theory)" title="wikilink">node</a> to one <a href="goal_node" title="wikilink">goal node</a> (out of one or more possible goals). As A* traverses the graph, it builds up a <a href="tree_(data_structure)" title="wikilink">tree</a> of partial paths. The leaves of this tree (called the <em>open set</em> or <em>fringe</em>) are stored in a <a href="priority_queue" title="wikilink">priority queue</a> that orders the leaf nodes by a cost function, which combines a <a class="uri" href="heuristic" title="wikilink">heuristic</a> estimate of the cost to reach a goal and the distance traveled from the initial node. Specifically, the cost function is</p>

<p>

<math display="block" id="A*_search_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)=g(n)+h(n)
  </annotation>
 </semantics>
</math>

.</p>

<p>Here, 

<math display="inline" id="A*_search_algorithm:1">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(n)
  </annotation>
 </semantics>
</math>

 is the known cost of getting from the initial node to 

<math display="inline" id="A*_search_algorithm:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

; this value is tracked by the algorithm. 

<math display="inline" id="A*_search_algorithm:3">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(n)
  </annotation>
 </semantics>
</math>


 is a heuristic estimate of the cost to get from 

<math display="inline" id="A*_search_algorithm:4">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 to any goal node. For the algorithm to find the actual shortest path, the heuristic function must be <a href="admissible_heuristic" title="wikilink">admissible</a>, meaning that it never overestimates the actual cost to get to the nearest goal node. The heuristic function is problem-specific and must be provided by the user of the algorithm.</p>

<p>For example, in an application like <a class="uri" href="routing" title="wikilink">routing</a>, <em>h(x)</em> might represent the straight-line distance to the goal, since that is physically the smallest possible distance between any two points.</p>

<p>If the <a class="uri" href="heuristic" title="wikilink">heuristic</a> <em>h</em> satisfies the additional condition 

<math display="inline" id="A*_search_algorithm:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)\leq d(x,y)+h(y)
  </annotation>
 </semantics>
</math>

 for every edge (<em>x, y</em>) of the graph (where <em>d</em> denotes the length of that edge), then <em>h</em> is called <a href="Consistent_heuristic" title="wikilink">monotone, or consistent</a>. In such a case, A* can be implemented more efficiently—roughly speaking, no node needs to be processed more than once (see <em>closed set</em> below)—and A* is equivalent to running <a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a> with the <a href="reduced_cost" title="wikilink">reduced cost</a> <em>d'(x, y) := d(x, y) + h(y) - h(x)</em>.</p>
<h2 id="history">History</h2>

<p>In 1968 Nils Nilsson suggested a heuristic approach for <a href="Shakey_the_Robot" title="wikilink">Shakey the Robot</a> to navigate through a room containing obstacles. This path-finding algorithm, called A1, was a faster version of the then best known formal approach, <a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a>, for finding shortest paths in graphs. Bertram Raphael suggested some significant improvements upon this algorithm, calling the revised version A2. Then Peter E. Hart introduced an argument that established A2, with only minor changes, to be the best possible algorithm for finding shortest paths. Hart, Nilsson and Raphael then jointly developed a proof that the revised A2 algorithm was <em>optimal</em> for finding shortest paths under certain well-defined conditions.</p>
<h2 id="process">Process</h2>

<p>Like all <a href="informed_search_algorithm" title="wikilink">informed search algorithms</a>, it first searches the routes that <em>appear</em> to be most likely to lead towards the goal. What sets A* apart from a <a href="greedy_algorithm" title="wikilink">greedy</a> <a href="best-first_search" title="wikilink">best-first search</a> is that it also takes the distance already traveled into account; the <em>g(x)</em> part of the heuristic is the cost from the starting point, not simply the local cost from the previously expanded node.</p>

<p>Starting with the initial node, it maintains a <a href="priority_queue" title="wikilink">priority queue</a> of nodes to be traversed, known as the <em>open set</em> or <em>fringe</em>. The lower <em>f(x)</em> for a given node <em>x</em>, the higher its priority. At each step of the algorithm, the node with the lowest <em>f(x)</em> value is removed from the queue, the <em>f</em> and <em>g</em> values of its neighbors are updated accordingly, and these neighbors are added to the queue. The algorithm continues until a goal node has a lower <em>f</em> value than any node in the queue (or until the queue is empty). (Goal nodes may be passed over multiple times if there remain other nodes with lower <em>f</em> values, as they may lead to a shorter path to a goal.) The <em>f</em> value of the goal is then the length of the shortest path, since <em>h</em> at the goal is zero in an admissible heuristic.</p>

<p>The algorithm described so far gives us only the length of the shortest path. To find the actual sequence of steps, the algorithm can be easily revised so that each node on the path keeps track of its predecessor. After this algorithm is run, the ending node will point to its predecessor, and so on, until some node's predecessor is the start node.</p>

<p>Additionally, if the heuristic is <em>monotonic</em> (or <a href="Consistent_heuristic" title="wikilink">consistent</a>, see below), a <em>closed set</em> of nodes already traversed may be used to make the search more efficient.</p>
<h2 id="pseudocode">Pseudocode</h2>

<p>The following <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> describes the algorithm:</p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal"><span class="kw">function</span> A*(start,goal)
    closedset := the empty <span class="kw">set</span>    <span class="co">// The set of nodes already evaluated.</span>
    openset := <span class="co">{start}</span>    <span class="co">// The set of tentative nodes to be evaluated, initially containing the start node</span>
    came_from := the empty map    <span class="co">// The map of navigated nodes.</span>
 
    g_score := map <span class="kw">with</span> default value <span class="kw">of</span> Infinity
    g_score[start] := <span class="dv">0</span>    <span class="co">// Cost from start along best known path.</span>
    <span class="co">// Estimated total cost from start to goal through y.</span>
    f_score = map <span class="kw">with</span> default value <span class="kw">of</span> Infinity
    f_score[start] := g_score[start] + heuristic_cost_estimate(start, goal)
     
    <span class="kw">while</span> openset <span class="kw">is</span> <span class="kw">not</span> empty
        current := the node <span class="kw">in</span> openset having the lowest f_score[] value
        <span class="kw">if</span> current = goal
            return reconstruct_path(came_from, goal)
         
        remove current from openset
        add current <span class="kw">to</span> closedset
        <span class="kw">for</span> each neighbor <span class="kw">in</span> neighbor_nodes(current)
            <span class="kw">if</span> neighbor <span class="kw">in</span> closedset
                <span class="kw">continue</span>
 
            tentative_g_score := g_score[current] + dist_between(current,neighbor)

            <span class="kw">if</span> neighbor <span class="kw">not</span> <span class="kw">in</span> openset <span class="kw">or</span> tentative_g_score &lt; g_score[neighbor] 
                came_from[neighbor] := current
                g_score[neighbor] := tentative_g_score
                f_score[neighbor] := g_score[neighbor] + heuristic_cost_estimate(neighbor, goal)
                <span class="kw">if</span> neighbor <span class="kw">not</span> <span class="kw">in</span> openset
                    add neighbor <span class="kw">to</span> openset
 
    return failure

<span class="kw">function</span> reconstruct_path(came_from,current)
    total_path := [current]
    <span class="kw">while</span> current <span class="kw">in</span> came_from:
        current := came_from[current]
        total_path.append(current)
    return total_path</code></pre></div>

<p><strong>Remark:</strong> the above pseudocode assumes that the heuristic function is <em>monotonic</em> (or <a href="Consistent_heuristic" title="wikilink">consistent</a>, see below), which is a frequent case in many practical problems, such as the Shortest Distance Path in road networks. However, if the assumption is not true, nodes in the <strong>closed</strong> set may be rediscovered and their cost improved. In other words, the closed set can be omitted (yielding a tree search algorithm) if a solution is guaranteed to exist, or if the algorithm is adapted so that new nodes are added to the open set only if they have a lower <em>f</em> value than at any previous iteration.</p>
<figure><b>(Figure)</b>
<figcaption>Illustration of A* search for finding path from a start node to a goal node in a <a href="robotics" title="wikilink">robot</a> <a href="motion_planning" title="wikilink">motion planning</a> problem. The empty circles represent the nodes in the <em>open set</em>, i.e., those that remain to be explored, and the filled ones are in the closed set. Color on each closed node indicates the distance from the start: the greener, the farther. One can first see the A* moving in a straight line in the direction of the goal, then when hitting the obstacle, it explores alternative routes through the nodes from the open set. </figcaption>
</figure>
<h3 id="example">Example</h3>

<p>An example of an A star (A*) algorithm in action where nodes are cities connected with roads and h(x) is the straight-line distance to target point:</p>
<figure><b>(Figure)</b>
<figcaption>An example of A star (A*) algorithm in action (nodes are cities connected with roads, h(x) is the straight-line distance to target point) Green: Start, Blue: Target, Orange: Visited</figcaption>
</figure>

<p><strong>Key:</strong> green: start; blue: goal; orange: visited</p>

<p>The A* algorithm also has real-world applications. In this example, edges are railroads and h(x) is the great-circle distance (the shortest possible distance on a sphere) to the target. The algorithm is searching for a path between Washington, D.C. and Los Angeles.</p>
<figure><b>(Figure)</b>
<figcaption>The A* algorithm finding a path of railroads between Washington, D.C. and Los Angeles.</figcaption>
</figure>
<h2 id="properties">Properties</h2>

<p>Like <a href="breadth-first_search" title="wikilink">breadth-first search</a>, A* is <em>complete</em> and will always find a solution if one exists.</p>

<p>If the heuristic function <em>h</em> is <a href="admissible_heuristic" title="wikilink">admissible</a>, meaning that it never overestimates the actual minimal cost of reaching the goal, then A* is itself admissible (or <em>optimal</em>) if we do not use a closed set. If a closed set is used, then <em>h</em> must also be <em>monotonic</em> (or <a href="consistent_heuristic" title="wikilink">consistent</a>) for A* to be optimal. This means that for any pair of adjacent nodes <em>x</em> and <em>y</em>, where <em>d(x,y)</em> denotes the length of the edge between them, we must have:</p>

<p>

<math display="block" id="A*_search_algorithm:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)\leq d(x,y)+h(y)
  </annotation>
 </semantics>
</math>

</p>

<p>This ensures that for any path <em>X</em> from the initial node to <em>x</em>:</p>

<p>

<math display="block" id="A*_search_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>X</ci>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>X</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>Y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(X)+h(x)\leq L(X)+d(x,y)+h(y)=L(Y)+h(y)
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>L</em> is a function that denotes the length of a path, and <em>Y</em> is the path <em>X</em> extended to include <em>y</em>. In other words, it is impossible to decrease (total distance so far + estimated remaining distance) by extending a path to include a neighboring node. (This is analogous to the restriction to nonnegative edge weights in <a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a>.) Monotonicity implies admissibility when the heuristic estimate at any goal node itself is zero, since (letting <em>P = (f,v<sub>1</sub>,v<sub>2</sub>,...,v<sub>n</sub>,g)</em> be a shortest path from any node <em>f</em> to the nearest goal <em>g</em>):</p>

<p>

<math display="block" id="A*_search_algorithm:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo>,</mo>
      <msub>
       <mi>v</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>v</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo>,</mo>
      <msub>
       <mi>v</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>v</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>v</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>v</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi mathvariant="normal">…</mi>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>P</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>d</ci>
       <interval closure="open">
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>d</ci>
       <interval closure="open">
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">2</cn>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>P</ci>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>g</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(f)\leq d(f,v_{1})+h(v_{1})\leq d(f,v_{1})+d(v_{1},v_{2})+h(v_{2})\leq\ldots%
\leq L(P)+h(g)=L(P)
  </annotation>
 </semantics>
</math>

</p>

<p>A* is also optimally efficient for any heuristic <em>h</em>, meaning that no optimal algorithm employing the same heuristic will expand fewer nodes than A*, except when there are multiple partial solutions where <em>h</em> exactly predicts the cost of the optimal path. Even in this case, for each graph there exists some order of breaking ties in the priority queue such that A* examines the fewest possible nodes.</p>
<h3 id="special-cases">Special cases</h3>

<p><a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a>, as another example of a uniform-cost search algorithm, can be viewed as a special case of A* where <em>h(x) = 0</em> for all <em>x</em>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> General <a href="depth-first_search" title="wikilink">depth-first search</a> can be implemented using the A* by considering that there is a global counter <em>C</em> initialized with a very large value. Every time we process a node we assign <em>C</em> to all of its newly discovered neighbors. After each single assignment, we decrease the counter <em>C</em> by one. Thus the earlier a node is discovered, the higher its <em>h(x)</em> value. It should be noted, however, that both Dijkstra's algorithm and depth-first search can be implemented more efficiently without including a <em>h(x)</em> value at each node.</p>
<h3 id="implementation-details">Implementation details</h3>

<p>There are a number of simple optimizations or implementation details that can significantly affect the performance of an A* implementation. The first detail to note is that the way the priority queue handles ties can have a significant effect on performance in some situations. If ties are broken so the queue behaves in a <a href="LIFO_(computing)" title="wikilink">LIFO</a> manner, A* will behave like <a href="depth-first_search" title="wikilink">depth-first search</a> among equal cost paths (avoiding exploring more than one equally optimal solution).</p>

<p>When a path is required at the end of the search, it is common to keep with each node a reference to that node's parent. At the end of the search these references can be used to recover the optimal path. If these references are being kept then it can be important that the same node doesn't appear in the priority queue more than once (each entry corresponding to a different path to the node, and each with a different cost). A standard approach here is to check if a node about to be added already appears in the priority queue. If it does, then the priority and parent pointers are changed to correspond to the lower cost path. A standard <a href="binary_heap" title="wikilink">binary heap</a> based priority queue does not directly support the operation of searching for one of its elements, but it can be augmented with a <a href="hash_table" title="wikilink">hash table</a> that maps elements to their position in the heap, allowing this decrease-priority operation to be performed in logarithmic time. Alternatively, a <a href="Fibonacci_heap" title="wikilink">Fibonacci heap</a> can perform the same decrease-priority operations on constant <a href="amortized_time" title="wikilink">amortized time</a>.</p>
<h2 id="admissibility-and-optimality">Admissibility and optimality</h2>

<p>A* is <a href="admissible_heuristic" title="wikilink">admissible</a> and <a href="Consistent_heuristic" title="wikilink">considers</a> fewer nodes than any other admissible search algorithm with the same heuristic. This is because A* uses an "optimistic" estimate of the cost of a path through every node that it considers—optimistic in that the true cost of a path through that node to the goal will be at least as great as the estimate. But, critically, as far as A* "knows", that optimistic estimate might be achievable.</p>

<p>Here is the main idea of the proof:</p>

<p>When A* terminates its search, it has found a path whose actual cost is lower than the estimated cost of any path through any open node. But since those estimates are optimistic, A* can safely ignore those nodes. In other words, A* will never overlook the possibility of a lower-cost path and so is admissible.</p>

<p>Suppose now that some other search algorithm B terminates its search with a path whose actual cost is <em>not</em> less than the estimated cost of a path through some open node. Based on the heuristic information it has, Algorithm B cannot rule out the possibility that a path through that node has a lower cost. So while B might consider fewer nodes than A*, it cannot be admissible. Accordingly, A* considers the fewest nodes of any admissible search algorithm.</p>

<p>This is only true if both:</p>
<ul>
<li>A* uses an <a href="admissible_heuristic" title="wikilink">admissible heuristic</a>. Otherwise, A* is not guaranteed to expand fewer nodes than another search algorithm with the same heuristic.<ref></ref></li>
</ul>

<p></p>
<ul>
<li>A* solves only one search problem rather than a series of similar search problems. Otherwise, A* is not guaranteed to expand fewer nodes than <a href="incremental_heuristic_search" title="wikilink">incremental heuristic search</a> algorithms.<ref></ref></li>
</ul>

<p></p>
<figure><b>(Figure)</b>
<figcaption>A* search that uses a heuristic that is 5.0(=ε) times a <a href="consistent_heuristic" title="wikilink">consistent heuristic</a>, and obtains a suboptimal path.</figcaption>
</figure>
<h3 id="bounded-relaxation">Bounded relaxation</h3>

<p>While the admissibility criterion guarantees an optimal solution path, it also means that A* must examine all equally meritorious paths to find the optimal path. It is possible to speed up the search at the expense of optimality by relaxing the admissibility criterion. Oftentimes we want to bound this relaxation, so that we can guarantee that the solution path is no worse than <em>(1 + ε)</em> times the optimal solution path. This new guarantee is referred to as <em>ε</em>-admissible.</p>

<p>There are a number of <em>ε</em>-admissible algorithms:</p>
<ul>
<li>Weighted A*/Static Weighting.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> If <em>h<sub>a</sub>(n)</em> is an admissible heuristic function, in the weighted version of the A* search one uses <em>h<sub>w</sub>(n) = ε h<sub>a</sub>(n)</em>, <em>ε &gt; 1</em> as the heuristic function, and perform the A* search as usual (which eventually happens faster than using <em>h<sub>a</sub></em> since fewer nodes are expanded). The path hence found by the search algorithm can have a cost of at most <em>ε</em> times that of the least cost path in the graph.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
</ul>
<ul>
<li>Dynamic Weighting<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> uses the cost function <em>f(n) = g(n) + (1 + ε w(n))h(n)</em>, where 

<math display="inline" id="A*_search_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mfrac>
         <mrow>
          <mi>d</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mi>N</mi>
        </mfrac>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>d</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>≤</mo>
        <mi>N</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>n</ci>
       </apply>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>n</ci>
      </apply>
      <ci>N</ci>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(n)=\begin{cases}1-\frac{d(n)}{N}&d(n)\leq N\\
0&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

, and where <em>d(n)</em> is the depth of the search and <em>N</em> is the anticipated length of the solution path.</li>
</ul>
<ul>
<li>Sampled Dynamic Weighting<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> uses sampling of nodes to better estimate and debias the heuristic error.</li>
</ul>
<ul>
<li>

<math display="inline" id="A*_search_algorithm:10">
 <semantics>
  <msubsup>
   <mi>A</mi>
   <mi>ε</mi>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <times></times>
    </apply>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{*}_{\varepsilon}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> uses two heuristic functions. The first is the FOCAL list, which is used to select candidate nodes, and the second <em>h<sub>F</sub></em> is used to select the most promising node from the FOCAL list.</li>
</ul>
<ul>
<li><em>A<sub>ε</sub></em><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> selects nodes with the function <em>A f(n) + B h<sub>F</sub>(n)</em>, where <em>A</em> and <em>B</em> are constants. If no nodes can be selected, the algorithm will backtrack with the function <em>C f(n) + D h<sub>F</sub>(n)</em>, where <em>C</em> and <em>D</em> are constants.</li>
</ul>
<ul>
<li>AlphA*<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> attempts to promote depth-first exploitation by preferring recently expanded nodes. AlphA* uses the cost function <em>f<sub>α</sub>(n) = (1 + w<sub>α</sub>(n)) f(n)</em>, where 

<math display="inline" id="A*_search_algorithm:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mi>λ</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>π</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>≤</mo>
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>n</mi>
           <mo stretchy="false">~</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mi mathvariant="normal">Λ</mi>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>α</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>λ</ci>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <ci>g</ci>
       <apply>
        <times></times>
        <ci>π</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>g</ci>
       <apply>
        <ci>normal-~</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <ci>normal-Λ</ci>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{\alpha}(n)=\begin{cases}\lambda&g(\pi(n))\leq g(\tilde{n})\\
\Lambda&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

, where <em>λ</em> and <em>Λ</em> are constants with 

<math display="inline" id="A*_search_algorithm:12">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>≤</mo>
   <mi mathvariant="normal">Λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>λ</ci>
    <ci>normal-Λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\leq\Lambda
  </annotation>
 </semantics>
</math>

, <em>π(n)</em> is the parent of n, and <em>ñ</em> is the most recently expanded node.</li>
</ul>
<h2 id="complexity">Complexity</h2>

<p>The <a href="computational_complexity_theory" title="wikilink">time complexity</a> of A* depends on the heuristic. In the worst case of an unbounded search space, the number of nodes expanded is <a href="exponential_time" title="wikilink">exponential</a> in the length of the solution (the shortest path) 

<math display="inline" id="A*_search_algorithm:13">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>




<math display="block" id="A*_search_algorithm:14">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>b</mi>
     <mi>d</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(b^{d})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="A*_search_algorithm:15">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is the <a href="branching_factor" title="wikilink">branching factor</a> (average number of successors per state).<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> This assumes that a goal state exists at all, and is reachable from the start state; if it is not, and the state space is infinite, the algorithm will not terminate. The time complexity is <a href="polynomial_time" title="wikilink">polynomial</a> when the search space is a tree, there is a single goal state, and the heuristic function <em>h</em> meets the following condition:</p>

<p>

<math display="block" id="A*_search_algorithm:16">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msup>
       <mi>h</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>log</mi>
       <msup>
        <mi>h</mi>
        <mo>*</mo>
       </msup>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <times></times>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <apply>
       <log></log>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <times></times>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |h(x)-h^{*}(x)|=O(\log h^{*}(x))
  </annotation>
 </semantics>
</math>

</p>

<p>where <mtpl></mtpl> is the optimal heuristic, the exact cost to get from 

<math display="inline" id="A*_search_algorithm:17">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to the goal. In other words, the error of 

<math display="inline" id="A*_search_algorithm:18">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>


 will not grow faster than the <a class="uri" href="logarithm" title="wikilink">logarithm</a> of the "perfect heuristic" <mtpl></mtpl> that returns the true distance from 

<math display="inline" id="A*_search_algorithm:19">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to the goal.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="applications">Applications</h2>

<p>A* is commonly used for the common pathfinding problem in applications such as games, but was originally designed as a general graph traversal algorithm.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> It finds applications to diverse problems, including the problem of <a class="uri" href="parsing" title="wikilink">parsing</a> using <a href="Stochastic_context-free_grammar" title="wikilink">stochastic grammars</a> in <a href="Natural_language_processing" title="wikilink">NLP</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="relations-to-other-algorithms">Relations to other algorithms</h2>

<p>Some common variants of <a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a> can be viewed as a special case of A* where 

<math display="inline" id="A*_search_algorithm:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(n)=0
  </annotation>
 </semantics>
</math>

 for all nodes.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> A* itself can be seen as a special case of <a href="branch_and_bound" title="wikilink">branch and bound</a>.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h3 id="variants-of-a">Variants of A*</h3>
<ul>
<li><a class="uri" href="D*" title="wikilink">D*</a></li>
<li><a href="Any-angle_path_planning" title="wikilink">Field D*</a></li>
<li><a class="uri" href="IDA*" title="wikilink">IDA*</a></li>
<li><a href="Fringe_search" title="wikilink">Fringe</a></li>
<li><a href="Incremental_heuristic_search" title="wikilink">Fringe Saving A* (FSA*)</a></li>
<li><a href="Incremental_heuristic_search" title="wikilink">Generalized Adaptive A* (GAA*)</a></li>
<li><a href="Incremental_heuristic_search" title="wikilink">Lifelong Planning A* (LPA*)</a></li>
<li><a href="SMA*" title="wikilink">Simplified Memory bounded A* (SMA*)</a></li>
<li><a href="Jump_point_search" title="wikilink">Jump point search</a></li>
<li><a href="Any-angle_path_planning" title="wikilink">Theta*</a></li>
<li>A* can be adapted to a <a href="bidirectional_search" title="wikilink">bidirectional search</a> algorithm. Special care needs to be taken for the stopping criterion.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Pathfinding" title="wikilink">Pathfinding</a></li>
<li><a href="Any-angle_path_planning" title="wikilink">Any-angle path planning</a>, search for paths that are not limited to move along graph edges but rather can take on any angle</li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://theory.stanford.edu/~amitp/GameProgramming/">Clear visual A* explanation, with advice and thoughts on path-finding</a></li>
<li>Variation on A* called <a href="http://www.cs.ualberta.ca/~mmueller/ps/hpastar.pdf">Hierarchical Path-Finding A* (HPA*)</a></li>
</ul>

<p>"</p>

<p><a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a> <a href="Category:Routing_algorithms" title="wikilink">Category:Routing algorithms</a> <a href="Category:Search_algorithms" title="wikilink">Category:Search algorithms</a> <a href="Category:Combinatorial_optimization" title="wikilink">Category:Combinatorial optimization</a> <a href="Category:Game_artificial_intelligence" title="wikilink">Category:Game artificial intelligence</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"> from <a href="Princeton_University" title="wikilink">Princeton University</a><a href="#fnref21">↩</a></li>
</ol>
</section>
</body>

