<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="151">Combinational logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Combinational logic</h1>
<hr/>

<p>In <a href="digital_circuit" title="wikilink">digital circuit</a> theory, <strong>combinational logic</strong> (sometimes also referred to as <strong>time-independent logic</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> ) is a type of <a href="digital_logic" title="wikilink">digital logic</a> which is implemented by <a href="Boolean_circuit" title="wikilink">Boolean circuits</a>, where the output is a <a href="pure_function" title="wikilink">pure function</a> of the present input only. This is in contrast to <a href="sequential_logic" title="wikilink">sequential logic</a>, in which the output depends not only on the present input but also on the history of the input. In other words, sequential logic has <em><a href="computer_storage" title="wikilink">memory</a></em> while combinational logic does not.</p>

<p>Combinational logic is used in <a class="uri" href="computer" title="wikilink">computer</a> circuits to perform <a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra</a> on input signals and on stored data. Practical computer circuits normally contain a mixture of combinational and sequential logic. For example, the part of an <a href="arithmetic_logic_unit" title="wikilink">arithmetic logic unit</a>, or ALU, that does mathematical calculations is constructed using combinational logic. Other circuits used in computers, such as <a href="half_adder" title="wikilink">half adders</a>, <a href="full_adder" title="wikilink">full adders</a>, <a href="half_subtractor" title="wikilink">half subtractors</a>, <a href="Half_subtractor" title="wikilink">full subtractors</a>, <a href="multiplexer" title="wikilink">multiplexers</a>, <a href="Multiplexer" title="wikilink">demultiplexers</a>, <a href="encoder" title="wikilink">encoders</a> and <a href="Binary_decoder" title="wikilink">decoders</a> are also made by using combinational logic.</p>

<p>An alternate term is <strong>combinatorial logic</strong>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> though this usage may be considered controversial.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="representation">Representation</h2>

<p>Combinational logic is used to build circuits that produce specified outputs from certain inputs. The construction of combinational logic is generally done using one of two methods: a sum of products, or a product of sums. A sum of products can be visualized in a truth table, as in this example:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Combinational_logic:0">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Combinational_logic:1">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Combinational_logic:2">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>Result</p></th>
<th style="text-align: left;">
<p><a href="logical_equivalence" title="wikilink">Logical equivalent</a></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Combinational_logic:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>A</mi>
      </mrow>
      <mo>⋅</mo>
      <mi mathvariant="normal">¬</mi>
     </mrow>
     <mi>B</mi>
    </mrow>
    <mo>⋅</mo>
    <mi mathvariant="normal">¬</mi>
   </mrow>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <not></not>
        <ci>A</ci>
       </apply>
       <not></not>
      </apply>
      <ci>B</ci>
     </apply>
     <not></not>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A\cdot\neg B\cdot\neg C
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Combinational_logic:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>A</mi>
     </mrow>
     <mo>⋅</mo>
     <mi mathvariant="normal">¬</mi>
    </mrow>
    <mi>B</mi>
   </mrow>
   <mo>⋅</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
      </apply>
      <not></not>
     </apply>
     <ci>B</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A\cdot\neg B\cdot C
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Combinational_logic:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mo>⋅</mo>
    <mi>B</mi>
    <mo>⋅</mo>
    <mi mathvariant="normal">¬</mi>
   </mrow>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
     </apply>
     <ci>B</ci>
     <not></not>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A\cdot B\cdot\neg C
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Combinational_logic:6">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
   <mo>⋅</mo>
   <mi>B</mi>
   <mo>⋅</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
    <ci>B</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A\cdot B\cdot C
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Combinational_logic:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>A</mi>
      <mo>⋅</mo>
      <mi mathvariant="normal">¬</mi>
     </mrow>
     <mi>B</mi>
    </mrow>
    <mo>⋅</mo>
    <mi mathvariant="normal">¬</mi>
   </mrow>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>A</ci>
       <not></not>
      </apply>
      <ci>B</ci>
     </apply>
     <not></not>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cdot\neg B\cdot\neg C
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Combinational_logic:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mo>⋅</mo>
     <mi mathvariant="normal">¬</mi>
    </mrow>
    <mi>B</mi>
   </mrow>
   <mo>⋅</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <ci>A</ci>
      <not></not>
     </apply>
     <ci>B</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cdot\neg B\cdot C
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Combinational_logic:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>⋅</mo>
    <mi>B</mi>
    <mo>⋅</mo>
    <mi mathvariant="normal">¬</mi>
   </mrow>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <ci>A</ci>
     <ci>B</ci>
     <not></not>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cdot B\cdot\neg C
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Combinational_logic:10">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⋅</mo>
   <mi>B</mi>
   <mo>⋅</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>A</ci>
    <ci>B</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cdot B\cdot C
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Using sum of products, all logical statements which yield true results are summed, giving the result:</p>

<p>

<math display="block" id="Combinational_logic:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mo>⋅</mo>
       <mi mathvariant="normal">¬</mi>
      </mrow>
      <mi>B</mi>
     </mrow>
     <mo>⋅</mo>
     <mi mathvariant="normal">¬</mi>
    </mrow>
    <mi>C</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>A</mi>
    <mo>⋅</mo>
    <mi>B</mi>
    <mo>⋅</mo>
    <mpadded width="+1.7pt">
     <mi>C</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>A</ci>
        <not></not>
       </apply>
       <ci>B</ci>
      </apply>
      <not></not>
     </apply>
     <ci>C</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>A</ci>
     <ci>B</ci>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cdot\neg B\cdot\neg C+A\cdot B\cdot C\,
  </annotation>
 </semantics>
</math>

</p>

<p>Using <a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra</a>, the result simplifies to the following equivalent of the truth table:</p>

<p>

<math display="block" id="Combinational_logic:12">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⋅</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>B</mi>
       </mrow>
       <mo>⋅</mo>
       <mi mathvariant="normal">¬</mi>
      </mrow>
      <mi>C</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>B</mi>
      <mo>⋅</mo>
      <mi>C</mi>
     </mrow>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>A</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <not></not>
        <ci>B</ci>
       </apply>
       <not></not>
      </apply>
      <ci>C</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>B</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cdot(\neg B\cdot\neg C+B\cdot C)\,
  </annotation>
 </semantics>
</math>

</p>
<h2 id="logic-formula-minimization">Logic formula minimization</h2>

<p>Minimization (simplification) of combinational logic formulas is done using the following rules:</p>

<p>

<math display="block" id="Combinational_logic:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⋅</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>A</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>B</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A+B)\cdot(A+C)=A+(B\cdot C)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Combinational_logic:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo lspace="12.5pt" stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>⋅</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>⋅</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>+</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>A</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>A</ci>
     <apply>
      <plus></plus>
      <ci>B</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad(A\cdot B)+(A\cdot C)=A\cdot(B+C)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Combinational_logic:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>⋅</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>A</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A+(A\cdot B)=A
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Combinational_logic:16">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="10pt" width="+10pt">
     <mi>A</mi>
    </mpadded>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>A</ci>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad A\cdot(A+B)=A
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Combinational_logic:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>A</mi>
      </mrow>
      <mo>⋅</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>A</ci>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A+(\lnot A\cdot B)=A+B
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Combinational_logic:18">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="10pt" width="+10pt">
     <mi>A</mi>
    </mpadded>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>A</mi>
      </mrow>
      <mo>+</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>⋅</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>A</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad A\cdot(\lnot A+B)=A\cdot B
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Combinational_logic:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>A</mi>
      </mrow>
      <mo>+</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A+B)\cdot(\lnot A+B)=B
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Combinational_logic:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo lspace="12.5pt" stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>⋅</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>A</mi>
      </mrow>
      <mo>⋅</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad(A\cdot B)+(\lnot A\cdot B)=B
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Combinational_logic:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>⋅</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>A</mi>
      </mrow>
      <mo>⋅</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⋅</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>⋅</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>A</mi>
      </mrow>
      <mo>⋅</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
      </apply>
      <ci>C</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>B</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
      </apply>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\cdot B)+(\lnot A\cdot C)+(B\cdot C)=(A\cdot B)+(\lnot A\cdot C)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Combinational_logic:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>A</mi>
      </mrow>
      <mo>+</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>+</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>A</mi>
      </mrow>
      <mo>+</mo>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
      </apply>
      <ci>C</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>B</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
      </apply>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A+B)\cdot(\lnot A+C)\cdot(B+C)=(A+B)\cdot(\lnot A+C)
  </annotation>
 </semantics>
</math>

</p>

<p>With the use of minimization (sometimes called <a href="logic_optimization" title="wikilink">logic optimization</a>), a simplified logical function or circuit may be arrived upon, and the logic <a href="combinational_circuit" title="wikilink">combinational circuit</a> becomes smaller, and easier to analyse, use, or build.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Sequential_logic" title="wikilink">Sequential logic</a></li>
<li><a href="Asynchronous_logic" title="wikilink">Asynchronous logic</a></li>
<li><a class="uri" href="FPGA" title="wikilink">FPGA</a></li>
<li><a href="Formal_verification" title="wikilink">Formal verification</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Michael Predko and Myke Predko, <em>Digital electronics demystified</em>, McGraw-Hill, 2004. ISBN 0-07-144141-7</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.ee.surrey.ac.uk/Projects/Labview/combindex.html">Combinational Logic &amp; Systems Tutorial Guide</a> by D. Belton, R. Bigwood.</li>
</ul>

<p>"</p>

<p><a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a> <a href="Category:Digital_electronics" title="wikilink">Category:Digital electronics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">C.J. Savant, Jr.; Martin Roden; Gordon Carpenter. "Electronic Design: Circuits and Systems". 1991. ISBN 0-8053-0285-9 p. 682<a href="#fnref1">↩</a></li>
<li id="fn2">Clive Maxfield. [<a class="uri" href="http://books.google.com/books?id=kQuOKBSOz5QC&amp;pg">http://books.google.com/books?id=kQuOKBSOz5QC&amp;pg;</a>;=PA70&amp;dq;=%22combinatorial+logic%22&amp;hl;=en&amp;sa;=X&amp;ei;=vBSdULe_LMPHqQGploDoCg&amp;ved;=0CEQQ6AEwBw#v=onepage&amp;q;=%22combinatorial%20logic%22&amp;f;=false "FPGAs: World Class Designs"]. p. 70. 2009. ISBN 1856176215<a href="#fnref2">↩</a></li>
<li id="fn3">Cliff Cummings. <a href="http://www.sunburst-design.com/papers/Technical_Text_Mistakes.pdf">"Common Mistakes In Technical Texts"</a>. 2009.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
