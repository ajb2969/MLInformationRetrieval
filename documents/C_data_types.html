<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="358">C data types</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>C data types</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In the <a href="C_(programming_language)" title="wikilink">C programming language</a>, <strong>data types</strong> refers to an extensive system for declaring variables of different types. The language itself provides basic arithmetic types and syntax to build array and compound types. Several headers in the <a href="C_standard_library" title="wikilink">standard library</a> contain definitions of support types, that have additional properties, such as exact size, guaranteed.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="basic-types">Basic types</h2>

<p>The C language provides many basic types. Most of them are formed from one of the four basic arithmetic type specifiers in C (<code>char</code>, <code>int</code>, <code>float</code> and <code>double</code>), and optional specifiers (<code>signed</code>, <code>unsigned</code>, <code>short</code>, <code>long</code>) and are listed below:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Type</p></th>
<th style="text-align: left;">
<p>| Explanation</p></th>
<th style="text-align: left;">
<p>| Format Specifier</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>| </p></td>
<td style="text-align: left;">
<p>Smallest addressable unit of the machine that can contain basic character set. It is an integer type. Actual type can be either signed or unsigned depending on the implementation. It contains <code>CHAR_BIT</code> bits.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p></td>
<td style="text-align: left;">
<p>%c</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>| </p></td>
<td style="text-align: left;">
<p>Of the same size as <code>char</code>, but guaranteed to be signed.</p></td>
<td style="text-align: left;">
<p>%c <small>(or %hhi for numerical output)</small></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Of the same size as <code>char</code>, but guaranteed to be unsigned. It is represented in binary notation without padding bits, thus its range is exactly [0,2<sup><code>CHAR_BIT</code></sup>−1].<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p></td>
<td style="text-align: left;">
<p>%c <small>(or %hhu for numerical output)</small></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><br/>
<br/>
<br/>
</p></td>
<td style="text-align: left;">
<p><em>Short</em> signed integer type. Capable of containing at least the [−32767,+32767] range;<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> thus, it is at least 16 bits in size.</p></td>
<td style="text-align: left;">
<p>%hi</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><br/>
</p></td>
<td style="text-align: left;">
<p>Similar to <code>short</code>, but unsigned.</p></td>
<td style="text-align: left;">
<p>%hu</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><br/>
</p></td>
<td style="text-align: left;">
<p>Basic signed integer type. Capable of containing at least the [−32767,+32767] range;<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> thus, it is at least 16 bits in size.</p></td>
<td style="text-align: left;">
<p>%i or %d</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><br/>
</p></td>
<td style="text-align: left;">
<p>Similar to <code>int</code>, but unsigned.</p></td>
<td style="text-align: left;">
<p>%u</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><br/>
<br/>
<br/>
</p></td>
<td style="text-align: left;">
<p><em>Long</em> signed integer type. Capable of containing at least the [−2147483647,+2147483647] range;<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> thus, it is at least 32 bits in size.</p></td>
<td style="text-align: left;">
<p>%li</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><br/>
</p></td>
<td style="text-align: left;">
<p>Similar to <code>long</code>, but unsigned.</p></td>
<td style="text-align: left;">
<p>%lu</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><br/>
<br/>
<br/>
</p></td>
<td style="text-align: left;">
<p><em>Long long</em> signed integer type. Capable of containing at least the [−9223372036854775807,+9223372036854775807] range;<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> thus, it is at least 64 bits in size. Specified since the <a class="uri" href="C99" title="wikilink">C99</a> version of the standard.</p></td>
<td style="text-align: left;">
<p>%lli</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><br/>
</p></td>
<td style="text-align: left;">
<p>Similar to <code>long long</code>, but unsigned. Specified since the <a class="uri" href="C99" title="wikilink">C99</a> version of the standard.</p></td>
<td style="text-align: left;">
<p>%llu</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Real floating-point type, usually referred to as a single-precision floating-point type. Actual properties unspecified (except minimum limits), however on most systems this is the <a href="Single-precision_floating-point_format" title="wikilink">IEEE 754 single-precision binary floating-point format</a>. This format is required by the optional Annex F "IEC 60559 floating-point arithmetic".</p></td>
<td style="text-align: left;">
<p>%f <small>(promoted automatically to <code>double</code> for <code>printf()</code>)</small></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Real floating-point type, usually referred to as a double-precision floating-point type. Actual properties unspecified (except minimum limits), however on most systems this is the <a href="Double-precision_floating-point_format" title="wikilink">IEEE 754 double-precision binary floating-point format</a>. This format is required by the optional Annex F "IEC 60559 floating-point arithmetic".</p></td>
<td style="text-align: left;">
<p>%f <small>(%lf for <code>scanf()</code>)</small></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Real floating-point type, usually mapped to an <a href="extended_precision" title="wikilink">extended precision</a> floating-point number format. Actual properties unspecified. Unlike types  and , it can be either <a href="80-bit_floating_point_format" title="wikilink">80-bit floating point format</a>, the non-IEEE "<a href="Double-double_arithmetic" title="wikilink">double-double</a>" or <a href="IEEE_754_quadruple-precision_floating-point_format" title="wikilink">IEEE 754 quadruple-precision floating-point format</a> if a higher precision format is provided, otherwise it is the same as . See <a href="long_double" title="wikilink">the article on long double</a> for details.</p></td>
<td style="text-align: left;">
<p>%Lf</p></td>
</tr>
</tbody>
</table>

<p>The actual size of integer types varies by implementation. The standard only requires size relations between the data types and minimum sizes for each data type:</p>

<p>The relation requirements are that the <code>long long</code> is not smaller than <code>long</code>, which is not smaller than <code>int</code>, which is not smaller than <code>short</code>. As <code>char</code>'s size is always the minimum supported data type, all other data types can't be smaller.</p>

<p>The minimum size for <code>char</code> is 8 bits, the minimum size for <code>short</code> and <code>int</code> is 16 bits, for <code>long</code> it is 32 bits and <code>long long</code> must contain at least 64 bits.</p>

<p>The type <code>int</code> should be the integer type that the target processor is most efficient working with. This allows great flexibility: for example, all types can be 64-bit. However, several different integer width schemes (data models) are popular. This is because the data model defines how different programs communicate, a uniform data model is used within a given operating system application interface.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>In practice it should be noted that <code>char</code> is usually 8 bits in size and <code>short</code> is usually 16 bits in size (as are their unsigned counterparts). This holds true for platforms as diverse as 1990s <a class="uri" href="SunOS" title="wikilink">SunOS</a> 4 Unix, Microsoft <a class="uri" href="MS-DOS" title="wikilink">MS-DOS</a>, modern <a class="uri" href="Linux" title="wikilink">Linux</a>, and Microchip MCC18 for embedded 8 bit PIC microcontrollers. <a class="uri" href="POSIX" title="wikilink">POSIX</a> requires <code>char</code> to be exactly 8 bits in size.</p>

<p>Various rules in the C standard make <code>unsigned char</code> the basic type used for arrays suitable to store arbitrary non-bit-field objects: its lack of padding bits and trap representations, the definition of <em>object representation</em>,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> and the possibility of aliasing.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>The actual size and behavior of floating-point types also vary by implementation. The only guarantee is that <code>long double</code> is not smaller than <code>double</code>, which is not smaller than <code>float</code>. Usually, the 32-bit and 64-bit <a href="IEEE_floating_point" title="wikilink">IEEE 754</a> binary floating-point formats are used, if supported by hardware.</p>

<p>The <a class="uri" href="C99" title="wikilink">C99</a> standard includes new real floating-point types <code>float_t</code> and <code>double_t</code>, defined in <code><math.h></math.h></code>. They correspond to the types used for the intermediate results of floating-point expressions when <code>FLT_EVAL_METHOD</code> is 0, 1, or 2. These types may be wider than <code>long double</code>.</p>

<p>C99 also added <a href="Complex_number" title="wikilink">complex</a> types: <code>float _Complex</code>, <code>double _Complex</code>, <code>long double _Complex</code>.</p>
<h3 id="boolean-type">Boolean type</h3>

<p><a class="uri" href="C99" title="wikilink">C99</a> added a boolean (true/false) type <code>_Bool</code>. Additionally, the new <code><stdbool.h></stdbool.h></code> header defines <code>bool</code> as a convenient alias for this type, and also provides macros for <code>true</code> and <code>false</code>. <code>_Bool</code> functions similarly to a normal integral type, with one exception: any assignments to a <code>_Bool</code> that are not 0 (false) are stored as 1 (true). This behavior exists to avoid <a href="integer_overflow" title="wikilink">integer overflows</a>. For example, in the following code:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">unsigned</span> <span class="dt">char</span> b = <span class="dv">256</span>;

<span class="kw">if</span> (b) {
   <span class="co">/* do something */</span>
}</code></pre></div>

<p><code>b</code> evaluates to false if <code>unsigned char</code> is 8 bits wide. However, changing the type causes the previous code to behave normally:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">_Bool</span> b = <span class="dv">256</span>;

<span class="kw">if</span> (b) {
   <span class="co">/* do something */</span>
}</code></pre></div>
<h3 id="size-and-pointer-difference-types">Size and pointer difference types</h3>

<p>The C language specification includes the typedefs <code>size_t</code> and <code>ptrdiff_t</code> to represent memory-related quantities. Their size is defined according to the target processor's arithmetic capabilities, not the memory capabilities, such as available address space. Both of these types are defined in the <code><stddef.h></stddef.h></code> header (<code>cstddef</code> header in C++).</p>

<p><code>size_t</code> is an unsigned integral type used to represent the size of any object (including arrays) in the particular implementation. It is used as the return type of the <code>sizeof</code> operator. The maximum size of <code>size_t</code> is provided via <code>SIZE_MAX</code>, a macro constant which is defined in the <code><stdint.h></stdint.h></code> header (<code>cstdint</code> header in C++). <code>size_t</code> is guaranteed to be at least 16 bits wide. Additionally, POSIX includes <code>ssize_t</code>, which is a signed integral type of the same width as <code>size_t</code>.</p>

<p><code>ptrdiff_t</code> is a signed integral type used to represent the difference between pointers. It is only guaranteed to be valid against pointers of the same type; subtraction of pointers consisting of different types is implementation-defined.</p>
<h3 id="interface-to-the-properties-of-the-basic-types">Interface to the properties of the basic types</h3>

<p>Information about the actual properties, such as size, of the basic arithmetic types, is provided via macro constants in two headers: <code><limits.h></limits.h></code> header (<code>climits</code> header in C++) defines macros for integer types and <code><float.h></float.h></code> header (<code>cfloat</code> header in C++) defines macros for floating-point types. The actual values depend on the implementation.</p>
<dl>
<dt>Properties of integer types</dt>
</dl>
<ul>
<li><code>CHAR_BIT</code> – size of the  type in bits (at least 8 bits)</li>
<li><code>SCHAR_MIN</code>, <code>SHRT_MIN</code>, <code>INT_MIN</code>, <code>LONG_MIN</code>, <code>LLONG_MIN</code><small>(C99)</small> – minimum possible value of signed integer types: , , , , </li>
<li><code>SCHAR_MAX</code>, <code>SHRT_MAX</code>, <code>INT_MAX</code>, <code>LONG_MAX</code>, <code>LLONG_MAX</code><small>(C99)</small> – maximum possible value of signed integer types: , , , , </li>
<li><code>UCHAR_MAX</code>, <code>USHRT_MAX</code>, <code>UINT_MAX</code>, <code>ULONG_MAX</code>, <code>ULLONG_MAX</code><small>(C99)</small> – maximum possible value of unsigned integer types: , , , , </li>
<li><code>CHAR_MIN</code> – minimum possible value of </li>
<li><code>CHAR_MAX</code> – maximum possible value of </li>
<li><code>MB_LEN_MAX</code> – maximum number of bytes in a multibyte character</li>
</ul>
<dl>
<dt>Properties of floating-point types</dt>
</dl>
<ul>
<li><code>FLT_MIN</code>, <code>DBL_MIN</code>, <code>LDBL_MIN</code> – minimum normalized positive value of , ,  respectively</li>
<li><code>FLT_TRUE_MIN</code>, <code>DBL_TRUE_MIN</code>, <code>LDBL_TRUE_MIN</code> (C11) – minimum positive value of , ,  respectively</li>
<li><code>FLT_MAX</code>, <code>DBL_MAX</code>, <code>LDBL_MAX</code> – maximum finite value of , ,  respectively</li>
<li><code>FLT_ROUNDS</code> – rounding mode for floating-point operations</li>
<li><code>FLT_EVAL_METHOD</code> (C99) – evaluation method of expressions involving different floating-point types</li>
<li><code>FLT_RADIX</code> – radix of the exponent in the floating-point types</li>
<li><code>FLT_DIG</code>, <code>DBL_DIG</code>, <code>LDBL_DIG</code> – number of decimal digits that can be represented without losing precision by , ,  respectively</li>
<li><code>FLT_EPSILON</code>, <code>DBL_EPSILON</code>, <code>LDBL_EPSILON</code> – <a href="Machine_epsilon" title="wikilink">difference between 1.0 and the next representable value</a> of , ,  respectively</li>
<li><code>FLT_MANT_DIG</code>, <code>DBL_MANT_DIG</code>, <code>LDBL_MANT_DIG</code> – number of <code>FLT_RADIX</code>-base digits in the floating-point significand for types , ,  respectively</li>
<li><code>FLT_MIN_EXP</code>, <code>DBL_MIN_EXP</code>, <code>LDBL_MIN_EXP</code> – minimum negative integer such that <code>FLT_RADIX</code> raised to a power one less than that number is a normalized , ,  respectively</li>
<li><code>FLT_MIN_10_EXP</code>, <code>DBL_MIN_10_EXP</code>, <code>LDBL_MIN_10_EXP</code> – minimum negative integer such that 10 raised to that power is a normalized , ,  respectively</li>
<li><code>FLT_MAX_EXP</code>, <code>DBL_MAX_EXP</code>, <code>LDBL_MAX_EXP</code> – maximum positive integer such that <code>FLT_RADIX</code> raised to a power one less than that number is a normalized , ,  respectively</li>
<li><code>FLT_MAX_10_EXP</code>, <code>DBL_MAX_10_EXP</code>, <code>LDBL_MAX_10_EXP</code> – maximum positive integer such that 10 raised to that power is a normalized , ,  respectively</li>
<li><code>DECIMAL_DIG</code> (C99) – minimum number of decimal digits such that any number of the widest supported floating-point type can be represented in decimal with a precision of <code>DECIMAL_DIG</code> digits and read back in the original floating-point type without changing its value. <code>DECIMAL_DIG</code> is at least 10.</li>
</ul>
<h2 id="fixed-width-integer-types">Fixed-width integer types</h2>

<p>The <a class="uri" href="C99" title="wikilink">C99</a> standard includes definitions of several new integer types to enhance the portability of programs.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The already available basic integer types were deemed insufficient, because their actual sizes are implementation defined and may vary across different systems. The new types are especially useful in <a href="Embedded_system" title="wikilink">embedded environments</a> where hardware usually supports only several types and that support varies between different environments. All new types are defined in <code><inttypes.h></inttypes.h></code> header (<code>cinttypes</code> header in C++) and also are available at <code><stdint.h></stdint.h></code> header (<code>cstdint</code> header in C++). The types can be grouped into the following categories:</p>
<ul>
<li>Exact-width integer types which are guaranteed to have the same number <strong>N</strong> of bits across all implementations. Included only if it is available in the implementation.</li>
<li>Least-width integer types which are guaranteed to be the smallest type available in the implementation, that has at least specified number <strong>N</strong> of bits. Guaranteed to be specified for at least N=8,16,32,64.</li>
<li>Fastest integer types which are guaranteed to be the fastest integer type available in the implementation, that has at least specified number <strong>N</strong> of bits. Guaranteed to be specified for at least N=8,16,32,64.</li>
<li>Pointer integer types which are guaranteed to be able to hold a pointer</li>
<li>Maximum-width integer types which are guaranteed to be the largest integer type in the implementation</li>
</ul>

<p>The following table summarizes the types and the interface to acquire the implementation details (<strong>N</strong> refers to the number of bits):</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Type category</p></th>
<th style="text-align: left;">
<p>Signed types</p></th>
<th style="text-align: left;">
<p>Unsigned types</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Type</p></td>
<td style="text-align: left;">
<p>Minimum value</p></td>
<td style="text-align: left;">
<p>Maximum value</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Exact width</p></td>
<td style="text-align: left;">
<p><code>int'''N'''_t</code></p></td>
<td style="text-align: left;">
<p><code>INT'''N'''_MIN</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Least width</p></td>
<td style="text-align: left;">
<p><code>int_least'''N'''_t</code></p></td>
<td style="text-align: left;">
<p><code>INT_LEAST'''N'''_MIN</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Fastest</p></td>
<td style="text-align: left;">
<p><code>int_fast'''N'''_t</code></p></td>
<td style="text-align: left;">
<p><code>INT_FAST'''N'''_MIN</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Pointer</p></td>
<td style="text-align: left;">
<p><code>intptr_t</code></p></td>
<td style="text-align: left;">
<p><code>INTPTR_MIN</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Maximum width</p></td>
<td style="text-align: left;">
<p><code>intmax_t</code></p></td>
<td style="text-align: left;">
<p><code>INTMAX_MIN</code></p></td>
</tr>
</tbody>
</table>
<h3 id="printf-and-scanf-format-specifiers">Printf and scanf format specifiers</h3>

<p>The <code><inttypes.h></inttypes.h></code> header (<code>cinttypes</code> header in C++) provides features that enhance the functionality of the types defined in <code><stdint.h></stdint.h></code> header. Included are macros that define <a href="printf_format_string" title="wikilink">printf format string</a> and <a href="scanf_format_string" title="wikilink">scanf format string</a> specifiers corresponding to the <code><stdint.h></stdint.h></code> types and several functions for working with <code>intmax_t</code> and <code>uintmax_t</code> types. This header was added in <a class="uri" href="C99" title="wikilink">C99</a>.</p>
<dl>
<dt>Printf format string</dt>
</dl>

<p>The macros are in the format <code>PRI''{fmt}{type}''</code>. Here <em>{fmt}</em> defines the output formatting and is one of <code>d</code> (decimal), <code>x</code> (hexadecimal), <code>o</code> (octal), <code>u</code> (unsigned) and <code>i</code> (integer). <em>{type}</em> defines the type of the argument and is one of <code>'''N'''</code>, <code>FAST'''N'''</code>, <code>LEAST'''N'''</code>, <code>PTR</code>, <code>MAX</code>, where <code>'''N'''</code> corresponds to the number of bits in the argument.</p>
<dl>
<dt>Scanf format string</dt>
</dl>

<p>The macros are in the format <code>SCN''{fmt}{type}''</code>. Here <em>{fmt}</em> defines the output formatting and is one of <code>d</code> (decimal), <code>x</code> (hexadecimal), <code>o</code> (octal), <code>u</code> (unsigned) and <code>i</code> (integer). <em>{type}</em> defines the type of the argument and is one of <code>'''N'''</code>, <code>FAST'''N'''</code>, <code>LEAST'''N'''</code>, <code>PTR</code>, <code>MAX</code>, where <code>'''N'''</code> corresponds to the number of bits in the argument.</p>
<dl>
<dt>Functions</dt>
</dl>
<h2 id="structures">Structures</h2>

<p>Structures are a way of storing multiple pieces of data in one variable. For example, say we wanted to store the name and birthday of a person in strings, in one variable. We could use a structure to house that data:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> birthday
{
    <span class="dt">char</span> name[<span class="dv">20</span>];
    <span class="dt">int</span> day;
    <span class="dt">int</span> month;
    <span class="dt">int</span> year;
};</code></pre></div>

<p>Structures may contain pointers to structs of its own type, which is common in <a href="linked_data_structure" title="wikilink">linked data structures</a>.</p>

<p>A C implementation has freedom to design the memory layout of the struct, with few restrictions; one being that the memory address of the first member will be the same as the address of struct itself. Structs may be <a href="C_syntax#Initialization" title="wikilink">initialized</a> or assigned to using compound literals. A user-written function can directly return a structure, though it will often not be very efficient at run-time. Since <a class="uri" href="C99" title="wikilink">C99</a>, a struct can also end with a <a href="flexible_array_member" title="wikilink">flexible array member</a>.</p>
<h2 id="arrays">Arrays</h2>

<p>For every type <em>T</em>, except void and function types, there exist the types "array of <em>N</em> elements of type <em>T</em>". An array is a collection of values, all of the same type, stored contiguously in memory. An array of size <em>N</em> is indexed by integers from <em>0</em> up to and including <em>N-1</em>. There are also "arrays of unspecified size" where the number of elements is not known by the compiler. Here is a brief example:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> cat[<span class="dv">10</span>];  <span class="co">// array of 10 elements, each of type int</span>
<span class="dt">int</span> bob[];    <span class="co">// array of an unspecified number of 'int' elements. </span></code></pre></div>

<p>Arrays can be initialized with a compound initializer, but not assigned. Arrays are passed to functions by passing a pointer to the first element. Multidimensional arrays are defined as "array of array …", and all except the outermost dimension must have compile-time constant size:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> a[<span class="dv">10</span>][<span class="dv">8</span>];  <span class="co">// array of 10 elements, each of type 'array of 8 int elements'</span>
<span class="dt">float</span> f[][<span class="dv">32</span>]; <span class="co">// array of unspecified number of 'array of 32 float elements'</span></code></pre></div>
<h2 id="pointer-types">Pointer types</h2>

<p>For every type <em>T</em> there exists a type “pointer to <em>T</em>”.</p>

<p>Variables can be declared as being <a href="pointer_(computer_programming)" title="wikilink">pointers</a> to values of various types, by means of the <code>*</code> type declarator. To declare a variable as a pointer, precede its name with an asterisk.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> *square;
<span class="dt">long</span> *circle;</code></pre></div>

<p>Hence "for every type T" also applies to pointer types there exists multi-indirect pointers like <code>char**</code> or <code>int***</code> and so on. There exists also "pointer to array" types, but they are less common than "array of pointer", and their syntax is quite confusing:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> *pc[<span class="dv">10</span>]; <span class="co">// array of 10 elements of 'pointer to char'</span>
<span class="dt">char</span> (*pa)[<span class="dv">10</span>]; <span class="co">// pointer to a 10-element array of char</span></code></pre></div>

<p><code>pc</code> consumes 10×<code>sizeof(char*)</code> bytes (usually 40 or 80 bytes on common platforms), but <code>pa</code> is only one pointer, so <code>sizeof(pa)</code> is usually 4 or 8, and the data it refers to is an array of 10 bytes: <code>sizeof(*pa) == 10</code>.</p>
<h2 id="unions">Unions</h2>

<p>Union types are special structures which allow access to the same memory using different type descriptions; one could, for example, describe a union of data types which would allow reading the same data as an integer, a float or a user declared type:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">union</span>
{
    <span class="dt">int</span> i;
    <span class="dt">float</span> f;
    <span class="kw">struct</span>
    {
        <span class="dt">unsigned</span> <span class="dt">int</span> u;
        <span class="dt">double</span> d;
    } s;
} u;</code></pre></div>

<p>In the above example the total size of <code>u</code> is the size of <code>u.s</code> (which happens to be the sum of the sizes of <code>u.s.u</code> and <code>u.s.d</code>), since s is larger than both <code>i</code> and <code>f</code>. When assigning something to <code>u.i</code>, some parts of <code>u.f</code> may be preserved if <code>u.i</code> is smaller than <code>u.f</code>.</p>

<p>Reading from a union member is not the same as casting since the value of the member is not converted, but merely read.</p>
<h2 id="function-pointers">Function pointers</h2>

<p>Function pointers allow referencing functions with a particular signature. For example, to store the address of the standard function <code>abs</code> in the variable <code>my_int_f</code>:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> (*my_int_f)(<span class="dt">int</span>) = &amp;abs;
<span class="co">// the &amp; operator can be omitted, but makes clear that the "address of" abs is used here</span></code></pre></div>

<p>Function pointers are invoked by name just like normal function calls. Function pointers are separate from pointers and <a href="void_pointer" title="wikilink">void pointers</a>.</p>
<h2 id="type-qualifiers">Type qualifiers</h2>

<p>The aforementioned types can be characterized further by <a href="type_qualifier" title="wikilink">type qualifiers</a>, yielding a <em>qualified type</em>.  and <a href="C11_(C_standard_revision)" title="wikilink">C11</a>, there are four type qualifiers in standard C: <code>[[const-correctness|const]]</code> (<a href="ANSI_C" title="wikilink">C89</a>), <code>[[volatile (computer programming)|volatile]]</code> (<a href="ANSI_C" title="wikilink">C89</a>), <code>[[restrict]]</code> (<a class="uri" href="C99" title="wikilink">C99</a>) and <code>_Atomic</code> (<a href="C11_(C_standard_revision)" title="wikilink">C11</a>) the latter has a private name to avoid clashing with user names,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> but the more ordinary name <code>atomic</code> can be used if the <code>stdatomic.h</code> header is included. Of these, <code>const</code> is by far the best-known and most used, appearing in the <a href="standard_library" title="wikilink">standard library</a> and encountered in any significant use of the C language, which must satisfy <a class="uri" href="const-correctness" title="wikilink">const-correctness</a>. The other qualifiers are used for low-level programming, and while widely used there, are rarely used by typical programmers.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="C_syntax" title="wikilink">C syntax</a></li>
<li><a href="Uninitialized_variable" title="wikilink">Uninitialized variable</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:C_(programming_language)" title="wikilink">Category:C (programming language)</a> <a href="Category:C_standard_library" title="wikilink">Category:C standard library</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><mtpl></mtpl><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3631.pdf">C11:The New C Standard</a>, Thomas Plum<a href="#fnref13">↩</a></li>
</ol>
</section>
</body>

