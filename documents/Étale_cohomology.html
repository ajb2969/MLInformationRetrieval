<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="600">Étale cohomology</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Étale cohomology</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>étale cohomology groups</strong> of an algebraic variety or scheme are algebraic analogues of the usual cohomology groups with finite coefficients of a topological space, introduced by <a class="uri" href="Grothendieck" title="wikilink">Grothendieck</a> in order to prove the <a href="Weil_conjectures" title="wikilink">Weil conjectures</a>. Étale cohomology theory can be used to construct <strong>ℓ-adic cohomology</strong>, which is an example of a <a href="Weil_cohomology_theory" title="wikilink">Weil cohomology theory</a> in algebraic geometry. This has many applications, such as the proof of the Weil conjectures and the construction of <a href="representations_of_finite_groups_of_Lie_type" title="wikilink">representations of finite groups of Lie type</a>.</p>
<h2 id="history">History</h2>

<p>Étale cohomology was suggested by , using some suggestions by <a href="J.-P._Serre" title="wikilink">J.-P. Serre</a>, and was motivated by the attempt to construct a <a href="Weil_cohomology_theory" title="wikilink">Weil cohomology theory</a> in order to prove the <a href="Weil_conjectures" title="wikilink">Weil conjectures</a>. The foundations were soon after worked out by Grothendieck together with <a href="Michael_Artin" title="wikilink">Michael Artin</a>, and published as Artin  and <a href="Grothendieck's_Séminaire_de_géométrie_algébrique" title="wikilink">SGA 4</a>. Grothendieck used étale cohomology to prove some of the Weil conjectures (<a href="Bernard_Dwork" title="wikilink">Dwork</a> had already managed to prove the rationality part of the conjectures in 1960 using <a href="p-adic_number" title="wikilink">p-adic</a> methods), and the remaining conjecture, the analogue of the <a href="Riemann_hypothesis" title="wikilink">Riemann hypothesis</a> was proved by <a href="Pierre_Deligne" title="wikilink">Pierre Deligne</a> (1974) using ℓ-adic cohomology.</p>

<p>Further contact with classical theory was found in the shape of the Grothendieck version of the <a href="Brauer_group" title="wikilink">Brauer group</a>; this was applied in short order to <a href="diophantine_geometry" title="wikilink">diophantine geometry</a>, by <a href="Yuri_Manin" title="wikilink">Yuri Manin</a>. The burden and success of the general theory was certainly both to integrate all this information, and to prove general results such as <a href="Poincaré_duality" title="wikilink">Poincaré duality</a> and the <a href="Lefschetz_fixed_point_theorem" title="wikilink">Lefschetz fixed point theorem</a> in this context.</p>

<p>Grothendieck originally developed étale cohomology in an extremely general setting, working with concepts such as <a href="Grothendieck_topos" title="wikilink">Grothendieck toposes</a> and <a href="Grothendieck_universe" title="wikilink">Grothendieck universes</a>. With hindsight, much of this machinery proved unnecessary for most practical applications of the étale theory, and  gave a simplified exposition of étale cohomology theory. Grothendieck's use of these universes (whose existence cannot be proved in <a class="uri" href="ZFC" title="wikilink">ZFC</a>) led to some uninformed speculation that étale cohomology and its applications (such as the proof of <a href="Fermat's_last_theorem" title="wikilink">Fermat's last theorem</a>) needed axioms beyond ZFC. In practice étale cohomology is used mainly for <a href="constructible_sheaf" title="wikilink">constructible sheaves</a> over schemes of finite type over the integers, and this needs no deep axioms of set theory: with a little care it can be constructed in this case without using any uncountable sets, and this can easily be done in ZFC (and even in much weaker theories).</p>

<p>Étale cohomology quickly found other applications, for example Deligne and Lusztig used it to construct <a href="representation_theory" title="wikilink">representations</a> of finite <a href="groups_of_Lie_type" title="wikilink">groups of Lie type</a>; see <a href="Deligne–Lusztig_theory" title="wikilink">Deligne–Lusztig theory</a>.</p>
<h2 id="motivation">Motivation</h2>

<p>For complex algebraic varieties, invariants from algebraic topology such as the <a href="fundamental_group" title="wikilink">fundamental group</a> and cohomology groups are very useful, and one would like to have analogues of these for varieties over other fields, such as finite fields. (One reason for this is that Weil suggested that the Weil conjectures could be proved using such a cohomology theory.) In the case of cohomology of <a href="coherent_sheaves" title="wikilink">coherent sheaves</a>, Serre showed that one could get a satisfactory theory just by using the <a href="Zariski_topology" title="wikilink">Zariski topology</a> of the algebraic variety, and in the case of complex varieties this gives the same cohomology groups (for coherent sheaves) as the much finer complex topology. However, for constant sheaves such as the sheaf of integers this does not work: the cohomology groups defined using the Zariski topology are badly behaved. For example, Weil envisioned a cohomology theory for varieties over finite fields with similar power as the usual <a href="singular_cohomology" title="wikilink">singular cohomology</a> of topological spaces, but in fact, any constant sheaf on an irreducible variety has trivial cohomology (all higher cohomology groups vanish).</p>

<p>The reason that the Zariski topology does not work well is that it is too coarse: it has too few open sets. There seems to be no good way to fix this by using a finer topology on a general algebraic variety. Grothendieck's key insight was to realize that there is no reason why the more general open sets should be subsets of the algebraic variety: the definition of a sheaf works perfectly well for any category, not just the category of open subsets of a space. He defined étale cohomology by replacing the category of open subsets of a space by the category of étale mappings to a space: roughly speaking, these can be thought of as open subsets of finite unbranched covers of the space. These turn out (after a lot of work) to give just enough extra open sets that one can get reasonable cohomology groups for some constant coefficients, in particular for coefficients <strong>Z</strong>/<em>n</em><strong>Z</strong> when <em>n</em> is coprime to the <a href="characteristic_(algebra)" title="wikilink">characteristic</a> of the field one is working over.</p>

<p>Some basic intuitions of the theory are these:</p>
<ul>
<li>The <em>étale</em> requirement is the condition that would allow one to apply the <a href="implicit_function_theorem" title="wikilink">implicit function theorem</a> if it were true in algebraic geometry (but it isn't — implicit algebraic functions are called <a class="uri" href="algebroid" title="wikilink">algebroid</a> in older literature).</li>
<li>There are certain basic cases, of dimension 0 and 1, and for an <a href="abelian_variety" title="wikilink">abelian variety</a>, where the answers with constant sheaves of coefficients can be predicted (via <a href="Galois_cohomology" title="wikilink">Galois cohomology</a> and <a href="Tate_module" title="wikilink">Tate modules</a>).</li>
</ul>
<h2 id="definitions">Definitions</h2>

<p>For any <a href="scheme_(mathematics)" title="wikilink">scheme</a> <em>X</em> the category Et(<em>X</em>) is the category of all <a href="étale_morphism" title="wikilink">étale morphisms</a> from a scheme to <em>X</em>. It is an analogue of the category of open subsets of a topological space, and its objects can be thought of informally as "étale open subsets" of <em>X</em>. The intersection of two open sets of a topological space corresponds to the pullback of two étale maps to <em>X</em>. There is a rather minor set-theoretical problem here, since Et(<em>X</em>) is a "large" category: its objects do not form a set. However, it is equivalent to a small category because étale morphisms are locally of finite presentation, so it is harmless to pretend that it is a small category.</p>

<p>A <a class="uri" href="presheaf" title="wikilink">presheaf</a> on a topological space <em>X</em> is a contravariant <a class="uri" href="functor" title="wikilink">functor</a> from the category of open subsets to sets. By analogy we define an <strong>étale presheaf</strong> on a scheme <em>X</em> to be a contravariant functor from Et(<em>X</em>) to sets.</p>

<p>A presheaf <em>F</em> on a topological space is called a <a href="sheaf_(mathematics)" title="wikilink">sheaf</a> if it satisfies the sheaf condition: whenever an open subset is covered by open subsets <em>U</em><sub><em>i</em></sub>, and we are given elements of <em>F</em>(<em>U</em><sub><em>i</em></sub>) for all <em>i</em> whose restrictions to <em>U</em><sub><em>i</em></sub>∩<em>U</em><sub><em>j</em></sub> agree for all <em>i</em>, <em>j</em>, then they are images of a unique element of <em>F</em>(<em>U</em>). By analogy, an étale presheaf is called a sheaf if it satisfies the same condition (with intersections of open sets replaced by pullbacks of étale morphisms, and where a set of étale maps to <em>U</em> is said to cover <em>U</em> if the topological space underlying <em>U</em> is the union of their images). More generally, one can define a sheaf for any <a href="Grothendieck_topology" title="wikilink">Grothendieck topology</a> on a category in a similar way.</p>

<p>The category of sheaves of abelian groups over a scheme has enough injective objects, so one can define right derived functors of left exact functors. The <strong>étale cohomology groups</strong> <em>H</em><sup><em>i</em></sup>(<em>F</em>) of the sheaf <em>F</em> of abelian groups are defined as the <a href="derived_functor" title="wikilink">right derived functors</a> of the functor of sections,</p>

<p>

<math display="block" id="Étale_cohomology:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mo>→</mo>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>F</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>F</ci>
    <apply>
     <times></times>
     <ci>normal-Γ</ci>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\to\Gamma(F),\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>(where the space of sections Γ(<em>F</em>) of <em>F</em> is <em>F</em>(<em>X</em>)). The sections of a sheaf can be thought of as Hom(<strong>Z</strong>,<em>F</em>) where <strong>Z</strong> is the sheaf that returns the integers as an <a href="abelian_group" title="wikilink">abelian group</a>. The idea of <em>derived functor</em> here is that the functor of sections doesn't respect <a href="exact_sequence" title="wikilink">exact sequences</a> as it is not right exact; according to general principles of <a href="homological_algebra" title="wikilink">homological algebra</a> there will be a sequence of functors <em>H<sup>i</sup></em> for <em>i</em> = 0,1, ... that represent the 'compensations' that must be made in order to restore some measure of exactness (long exact sequences arising from short ones). The <em>H<sup>0</sup></em> functor coincides with the section functor Γ.</p>

<p>More generally, if <em>f</em> is a morphism of schemes from <em>X</em> to <em>Y</em>, it induces a map <em>f</em><sub>*</sub> from étale sheaves over <em>X</em> to étale sheaves over <em>Y</em>, and its right derived functors are denoted by <em>R</em><sup><em>q</em></sup><em>f</em><sub>*</sub>, for <em>q</em> a non-negative integer. In the special case when <em>Y</em> is the spectrum of an algebraically closed field (a point), <em>R</em><sup><em>q</em></sup><em>f</em><sub>*</sub>(<em>F</em>) is the same as <em>H</em><sup><em>q</em></sup>(<em>F</em>).</p>

<p>Suppose that <em>X</em> is a Noetherian scheme. An abelian étale sheaf <em>F</em> over <em>X</em> is called <strong>finite locally constant</strong> if it is represented by an étale cover of <em>X</em>. It is called <strong><a href="constructible_sheaf" title="wikilink">constructible</a></strong> if <em>X</em> can be covered by a finite family of subschemes on each of which the restriction of <em>F</em> is finite locally constant. It is called <strong><a href="torsion_sheaf" title="wikilink">torsion</a></strong> if <em>F</em>(<em>U</em>) is a torsion group for all étale covers <em>U</em> of <em>X</em>. Finite locally constant sheaves are constructible, and constructible sheaves are torsion. Every torsion sheaf is a filtered inductive limit of constructible sheaves.</p>
<h2 id="ℓ-adic-cohomology-groups">ℓ-adic cohomology groups</h2>

<p>In applications to algebraic geometry over a <a href="finite_field" title="wikilink">finite field</a> <strong>F</strong><sub><em>q</em></sub>, the main objective was to find a replacement for the <a href="singular_cohomology" title="wikilink">singular cohomology</a> groups with integer (or rational) coefficients, which are not available in the same way as for geometry of an <a href="algebraic_variety" title="wikilink">algebraic variety</a> over the <a href="complex_number" title="wikilink">complex number</a> field. Étale cohomology works fine for coefficients <strong>Z</strong>/<em>n</em><strong>Z</strong> for <em>n</em> coprime to the characteristic, but gives unsatisfactory results for non-torsion coefficients. To get cohomology groups without torsion from étale cohomology one has to take an inverse limit of étale cohomology groups with certain torsion coefficients; this is called <strong>ℓ-adic cohomology</strong>. Here "<em>ℓ</em>" stands for any prime number different from <em>p</em>, where <em>p</em> is the characteristic of <strong>F</strong><sub><em>q</em></sub>. One considers, for schemes <em>V</em>, the cohomology groups</p>

<p>

<math display="block" id="Étale_cohomology:1">
 <semantics>
  <mrow>
   <msup>
    <mi>H</mi>
    <mi>i</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <msup>
       <mi mathvariant="normal">ℓ</mi>
       <mi>k</mi>
      </msup>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <ci>i</ci>
    </apply>
    <interval closure="open">
     <ci>V</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>ℤ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-ℓ</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>ℤ</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{i}(V,\mathbb{Z}/\ell^{k}\mathbb{Z})
  </annotation>
 </semantics>
</math>

</p>

<p>and <em>defines</em> the ℓ-adic cohomology group</p>

<p>

<math display="block" id="Étale_cohomology:2">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>H</mi>
     <mi>i</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo>,</mo>
     <msub>
      <mi>ℤ</mi>
      <mi mathvariant="normal">ℓ</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mo movablelimits="false">lim</mo>
     <mo>←</mo>
    </munder>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>i</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo>,</mo>
      <mrow>
       <mrow>
        <mi>ℤ</mi>
        <mo>/</mo>
        <msup>
         <mi mathvariant="normal">ℓ</mi>
         <mi>k</mi>
        </msup>
       </mrow>
       <mi>ℤ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>i</ci>
     </apply>
     <interval closure="open">
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℤ</ci>
       <ci>normal-ℓ</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">projective-limit</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>i</ci>
      </apply>
      <interval closure="open">
       <ci>V</ci>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <ci>ℤ</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>normal-ℓ</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <ci>ℤ</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{i}(V,\mathbb{Z}_{\ell})=\underleftarrow{\lim}H^{i}(V,\mathbb{Z}/\ell^{k}%
\mathbb{Z})
  </annotation>
 </semantics>
</math>

</p>

<p>as their <a href="inverse_limit" title="wikilink">inverse limit</a>. Here <strong>Z</strong><sub>ℓ</sub> denotes the <a href="p-adic_integers" title="wikilink">ℓ-adic integers</a>, but the definition is by means of the system of 'constant' sheaves with the finite coefficients <strong>Z</strong>/ℓ<sup><em>k</em></sup><strong>Z</strong>. (There is a notorious trap here: cohomology does <strong>not</strong> commute with taking inverse limits, and the ℓ-adic cohomology group, defined as an inverse limit, is <strong>not</strong> the cohomology with coefficients in the étale sheaf <strong>Z</strong><sub>ℓ</sub>; the latter cohomology group exists but gives the "wrong" cohomology groups.)</p>

<p>More generally, if <em>F</em> is an inverse system of étale sheaves <em>F</em><sub><em>i</em></sub>, then the cohomology of <em>F</em> is defined to be the inverse limit of the cohomology of the sheaves <em>F</em><sub><em>i</em></sub></p>

<p>

<math display="block" id="Étale_cohomology:3">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>H</mi>
     <mi>q</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>F</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mo movablelimits="false">lim</mo>
     <mo>←</mo>
    </munder>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>q</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <msub>
       <mi>F</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>q</ci>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>F</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">projective-limit</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>q</ci>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{q}(X,F)=\underleftarrow{\lim}H^{q}(X,F_{i})
  </annotation>
 </semantics>
</math>

 and though there is a natural map</p>

<p>

<math display="block" id="Étale_cohomology:4">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>H</mi>
     <mi>q</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mrow>
      <munder accentunder="true">
       <mo movablelimits="false">lim</mo>
       <mo>←</mo>
      </munder>
      <msub>
       <mi>F</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <munder accentunder="true">
     <mo movablelimits="false">lim</mo>
     <mo>←</mo>
    </munder>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>q</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <msub>
       <mi>F</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>q</ci>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <apply>
       <csymbol cd="latexml">projective-limit</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">projective-limit</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>q</ci>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{q}(X,\underleftarrow{\lim}F_{i})\to\underleftarrow{\lim}H^{q}(X,F_{i})
  </annotation>
 </semantics>
</math>

 this is <strong>not</strong> usually an isomorphism. An <strong>ℓ-adic sheaf</strong> is a special sort of inverse system of étale sheaves <em>F</em><sub><em>i</em></sub>, where <em>i</em> runs through positive integers, and <em>F</em><sub><em>i</em></sub> is a module over <strong>Z</strong>/ℓ<sup><em>i</em></sup><strong>Z</strong> and the map from <em>F</em><sub><em>i</em>+1</sub> to <em>F</em><sub><em>i</em></sub> is just reduction mod <strong>Z</strong>/ℓ<sup><em>i</em></sup><strong>Z</strong>.</p>

<p>In the case that <em>V</em> is a <a class="uri" href="non-singular" title="wikilink">non-singular</a> <a href="algebraic_curve" title="wikilink">algebraic curve</a> and <em>i</em> = 1, <em>H</em><sup><em>1</em></sup> is a free <strong>Z</strong><sub>ℓ</sub>-module of rank 2<em>g</em>, dual to the <a href="Tate_module" title="wikilink">Tate module</a> of the <a href="Jacobian_variety" title="wikilink">Jacobian variety</a> of <em>V</em>, where <em>g</em> is the <a href="genus_(mathematics)" title="wikilink">genus</a> of <em>V</em>. Since the first <a href="Betti_number" title="wikilink">Betti number</a> of a <a href="Riemann_surface" title="wikilink">Riemann surface</a> of genus <em>g</em> is 2<em>g</em>, this is isomorphic to the usual singular cohomology with <strong>Z</strong><sub>ℓ</sub> coefficients for complex algebraic curves. It also shows one reason why the condition ℓ ≠ <em>p</em> is required: when ℓ = <em>p</em> the rank of the Tate module is at most <em>g</em>.</p>

<p><a href="Torsion_subgroup" title="wikilink">Torsion subgroups</a> can occur, and were applied by <a href="Michael_Artin" title="wikilink">Michael Artin</a> and <a href="David_Mumford" title="wikilink">David Mumford</a> to geometric questions. To remove any torsion subgroup from the ℓ-adic cohomology groups and get cohomology groups that are vector spaces over fields of characteristic 0 one defines</p>

<p>

<math display="block" id="Étale_cohomology:5">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>H</mi>
     <mi>i</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo>,</mo>
     <msub>
      <mi>ℚ</mi>
      <mi mathvariant="normal">ℓ</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>i</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo>,</mo>
      <msub>
       <mi>ℤ</mi>
       <mi mathvariant="normal">ℓ</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊗</mo>
    <msub>
     <mi>ℚ</mi>
     <mi mathvariant="normal">ℓ</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>i</ci>
     </apply>
     <interval closure="open">
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℚ</ci>
       <ci>normal-ℓ</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>i</ci>
      </apply>
      <interval closure="open">
       <ci>V</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ℤ</ci>
        <ci>normal-ℓ</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℚ</ci>
      <ci>normal-ℓ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{i}(V,\mathbb{Q}_{\ell})=H^{i}(V,\mathbb{Z}_{\ell})\otimes\mathbb{Q}_{\ell}
  </annotation>
 </semantics>
</math>

 (though this notation is misleading: <strong>Q</strong><sub>ℓ</sub> is neither an étale sheaf nor an ℓ-adic sheaf).</p>
<h2 id="properties">Properties</h2>

<p>In general the ℓ-adic cohomology groups of a variety tend to have similar properties to the singular cohomology groups of complex varieties, except that they are modules over the ℓ-adic integers (or numbers) rather than the integers (or rationals). They satisfy a form of <a href="Poincaré_duality" title="wikilink">Poincaré duality</a> on non-singular projective varieties, and the ℓ-adic cohomology groups of a "reduction mod p" of a complex variety tend to have the same rank as the singular cohomology groups. A <a href="Künneth_formula" title="wikilink">Künneth formula</a> also holds.</p>

<p>For example, the first cohomology group of a complex elliptic curve is a free module of rank 2 over the integers, while the first ℓ-adic cohomology group of an elliptic curve over a finite field is a free module of rank 2 over the ℓ-adic integers, provided <em>l</em> is not the characteristic of the field concerned, and is dual to its <a href="Tate_module" title="wikilink">Tate module</a>.</p>

<p>There is one way in which ℓ-adic cohomology groups are better than singular cohomology groups: they tend to be acted on by <a href="Galois_group" title="wikilink">Galois groups</a>. For example, if a complex variety is defined over the rational numbers, its ℓ-adic cohomology groups are acted on by the <a href="absolute_Galois_group" title="wikilink">absolute Galois group</a> of the rational numbers: they afford <a href="Galois_representation" title="wikilink">Galois representations</a>.</p>

<p>Elements of the Galois group of the rationals, other than the identity and <a href="complex_conjugation" title="wikilink">complex conjugation</a>, do not usually act <em>continuously</em> on a complex variety defined over the rationals, so do not act on the singular cohomology groups. This phenomenon of Galois representations is related to the fact that the <a href="fundamental_group" title="wikilink">fundamental group</a> of a topological space acts on the singular cohomology groups, because Grothendieck showed that the Galois group can be regarded as a sort of fundamental group. (See also <a href="Grothendieck's_Galois_theory" title="wikilink">Grothendieck's Galois theory</a>.)</p>
<h2 id="calculation-of-étale-cohomology-groups">Calculation of étale cohomology groups</h2>

<p>The main initial step in calculating étale cohomology groups of a variety is to calculate them for complete connected smooth algebraic curves <em>X</em> over algebraically closed fields <em>k</em>. The étale cohomology groups of arbitrary varieties can then be controlled using analogues of the usual machinery of algebraic topology, such as the spectral sequence of a fibration. For curves the calculation takes several steps, as follows . (The sheaf <strong>G</strong><sub><em>m</em></sub> is the sheaf of non-vanishing functions.)</p>
<h3 id="calculation-of-h1x-gm">Calculation of H<sup>1</sup>(<em>X</em>, G''<sub>m''</sub>)</h3>

<p>The exact sequence of étale sheaves</p>

<p>

<math display="block" id="Étale_cohomology:6">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>→</mo>
   <msub>
    <mi>𝐆</mi>
    <mi>m</mi>
   </msub>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>j</mi>
     <mo>*</mo>
    </msub>
    <msub>
     <mi>𝐆</mi>
     <mrow>
      <mi>m</mi>
      <mo>,</mo>
      <mi>K</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>→</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>X</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>i</mi>
      <mrow>
       <mi>x</mi>
       <mo>*</mo>
      </mrow>
     </msub>
     <mi>𝐙</mi>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐆</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐆</ci>
       <list>
        <ci>m</ci>
        <ci>K</ci>
       </list>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <in></in>
        <ci>x</ci>
        <apply>
         <abs></abs>
         <ci>X</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <list>
         <ci>x</ci>
         <times></times>
        </list>
       </apply>
       <ci>𝐙</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\rightarrow\mathbf{G}_{m}\rightarrow j_{*}\mathbf{G}_{m,K}\rightarrow%
\bigoplus_{x\in|X|}i_{x*}\mathbf{Z}\rightarrow 1
  </annotation>
 </semantics>
</math>

 gives a long exact sequence of cohomology groups</p>

<p>

<math display="block" id="Étale_cohomology:7">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>0</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐆</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>0</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>j</mi>
       <mo>*</mo>
      </msub>
      <msub>
       <mi>𝐆</mi>
       <mrow>
        <mi>m</mi>
        <mo>,</mo>
        <mi>K</mi>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>X</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <msup>
      <mi>H</mi>
      <mn>0</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>i</mi>
        <mrow>
         <mi>x</mi>
         <mo>*</mo>
        </mrow>
       </msub>
       <mi>𝐙</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>1</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐆</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>1</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>j</mi>
       <mo>*</mo>
      </msub>
      <msub>
       <mi>𝐆</mi>
       <mrow>
        <mi>m</mi>
        <mo>,</mo>
        <mi>K</mi>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐆</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐆</ci>
        <list>
         <ci>m</ci>
         <ci>K</ci>
        </list>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <in></in>
        <ci>x</ci>
        <apply>
         <abs></abs>
         <ci>X</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>H</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <list>
          <ci>x</ci>
          <times></times>
         </list>
        </apply>
        <ci>𝐙</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐆</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐆</ci>
        <list>
         <ci>m</ci>
         <ci>K</ci>
        </list>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow H^{0}(\mathbf{G}_{m})\rightarrow H^{0}(j_{*}\mathbf{G}_{m,K})%
\rightarrow\bigoplus_{x\in|X|}H^{0}(i_{x*}\mathbf{Z})\rightarrow H^{1}(\mathbf%
{G}_{m})\rightarrow H^{1}(j_{*}\mathbf{G}_{m,K})\rightarrow\cdots
  </annotation>
 </semantics>
</math>

 Here <em>j</em> is the injection of the generic point, <em>i</em><sub>x</sub> is the injection of a closed point <em>x</em>, <strong>G</strong><sub><em>m</em>,<em>K</em></sub> is the sheaf <strong>G</strong><sub><em>m</em></sub> on  (the generic point of <em>X</em>), and <strong>Z</strong><sub><em>x</em></sub> is a copy of <strong>Z</strong> for each closed point of <em>X</em>. The groups H<sup>i</sup>(i<sub>x*</sub><strong>Z</strong>) vanish if <em>i</em>&gt;0 (because i<sub>x*</sub><strong>Z</strong> is a "skyscraper sheaf") and if <em>i</em>=0 they are <em>Z</em> so their sum is just the divisor group of <em>X</em>. Moreover the first cohomology group H<sup>1</sup>(<em>X</em>, j<sub>*</sub><strong>G</strong><sub>m,K</sub>) is isomorphic to the Galois cohomology group H<sup>1</sup>(<em>K</em>, <em>K</em><sup>*</sup>) which vanishes by <a href="Hilbert's_theorem_90" title="wikilink">Hilbert's theorem 90</a>. Therefore the long exact sequence of étale cohomology groups gives an exact sequence</p>

<p>

<math display="block" id="Étale_cohomology:8">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>⟶</mo>
   <mrow>
    <mi>Div</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⟶</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>1</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐆</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⟶</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⟶</ci>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>Div</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⟶</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐆</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⟶</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\longrightarrow\mathrm{Div}(X)\longrightarrow H^{1}(\mathbf{G}_{m})\longrightarrow
1
  </annotation>
 </semantics>
</math>

 where Div(<em>X</em>) is the group of divisors of <em>X</em> and <em>K</em> is its function field. In particular H<sup>1</sup>(<em>X</em>, <strong>G</strong><sub><em>m</em></sub>) is the <a href="Picard_group" title="wikilink">Picard group</a> Pic(<em>X</em>) (and the first cohomology groups of <strong>G</strong><sub><em>m</em></sub> are the same for the étale and Zariski topologies). This step works for varieties <em>X</em> of any dimension (with points replaced by codimension 1 subvarieties), not just curves.</p>
<h3 id="calculation-of-hix-gm">Calculation of H<sup><em>i</em></sup>(<em>X</em>, G''<sub>m''</sub>)</h3>

<p>The same long exact sequence above shows that if <em>i</em> ≥ 2 then the cohomology group H<sup><em>i</em></sup>(<em>X</em>, <strong>G</strong><sub><em>m</em></sub>) is isomorphic to H<sup><em>i</em></sup>(<em>X</em>, j<sub>*</sub><strong>G</strong><sub>m,K</sub>), which is isomorphic to the Galois cohomology group H<sup><em>i</em></sup>(<em>K</em>, K<sup>*</sup>). <a href="Tsen's_theorem" title="wikilink">Tsen's theorem</a> implies that the Brauer group of a function field <em>K</em> in one variable over an algebraically closed field vanishes. This in turn implies that all the Galois cohomology groups H<sup><em>i</em></sup>(<em>K</em>, <em>K</em><sup>*</sup>) vanish for <em>i</em> ≥ 1, so all the cohomology groups H<sup><em>i</em></sup>(<em>X</em>, <strong>G</strong><sub><em>m</em></sub>) vanish if <em>i</em> ≥ 2.</p>
<h3 id="calculation-of-hix-μn">Calculation of H<sup><em>i</em></sup>(<em>X</em>, μ<sub><em>n</em></sub>)</h3>

<p>If μ<sub><em>n</em></sub> is the sheaf of <em>n</em>th roots of 1 and <em>n</em> is prime to the characteristic of the field <em>k</em>, then H<sup><em>i</em></sup>(<em>X</em>,μ<sub><em>n</em></sub>) is μ<sub><em>n</em></sub>(<em>k</em>) if <em>i</em>=0, the group of <em>n</em>-division points of Pic(<em>X</em>) if <em>i</em>=1, and <strong>Z</strong>/<em>n</em><strong>Z</strong> if <em>i</em>=2, and 0 if <em>i</em>≥3. This follows from the previous results using the long exact sequence</p>

<p>

<math display="block" id="Étale_cohomology:9">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>0</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <msub>
      <mi>μ</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>0</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <msub>
      <mi>𝐆</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>0</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <msub>
      <mi>𝐆</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">0</cn>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">0</cn>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐆</ci>
        <ci>m</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">0</cn>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐆</ci>
        <ci>m</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">absent</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow H^{0}(X,\mu_{n})\rightarrow H^{0}(X,\mathbf{G}_{m})\rightarrow H^%
{0}(X,\mathbf{G}_{m})\rightarrow
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Étale_cohomology:10">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>1</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <msub>
      <mi>μ</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>1</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <msub>
      <mi>𝐆</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>1</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <msub>
      <mi>𝐆</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <msub>
      <mi>μ</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <msub>
      <mi>𝐆</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐆</ci>
        <ci>m</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐆</ci>
        <ci>m</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐆</ci>
        <ci>m</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow H^{1}(X,\mu_{n})\rightarrow H^{1}(X,\mathbf{G}_{m})\rightarrow H^{%
1}(X,\mathbf{G}_{m})\rightarrow H^{2}(X,\mu_{n})\rightarrow H^{2}(X,\mathbf{G}%
_{m})
  </annotation>
 </semantics>
</math>

 of the Kummer exact sequence of étale sheaves</p>

<p>

<math display="block" id="Étale_cohomology:11">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>→</mo>
   <msub>
    <mi>μ</mi>
    <mi>n</mi>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>𝐆</mi>
    <mi>m</mi>
   </msub>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝑛</mo>
   </mover>
   <msub>
    <mi>𝐆</mi>
    <mi>m</mi>
   </msub>
   <mo>→</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐆</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <ci>n</ci>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐆</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\rightarrow\mu_{n}\rightarrow\mathbf{G}_{m}\xrightarrow{n}\mathbf{G}_{m}%
\rightarrow 1.
  </annotation>
 </semantics>
</math>

 and inserting the known values H<sup>0</sup>(<em>X</em>,<strong>G</strong><sub><em>m</em></sub>) = <em>k</em><sup>*</sup>, H<sup>1</sup>(<em>X</em>,<strong>G</strong><sub><em>m</em></sub>) = Pic(<em>X</em>), and H<sup><em>i</em></sup>(<em>X</em>,<em>'G</em><sub><em>'m</em></sub>)=0 for <em>i</em> ≥ 2. In particular we get an exact sequence</p>

<p>

<math display="block" id="Étale_cohomology:12">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>1</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <msub>
      <mi>μ</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>Pic</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mrow>
     <mi></mi>
     <mo>×</mo>
     <mi>n</mi>
    </mrow>
   </mover>
   <mrow>
    <mi>Pic</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <msub>
      <mi>μ</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Pic</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <times></times>
       <csymbol cd="latexml">absent</csymbol>
       <ci>n</ci>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Pic</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\rightarrow H^{1}(X,\mu_{n})\rightarrow\mathrm{Pic}(X)\xrightarrow{\times n}%
\mathrm{Pic}(X)\rightarrow H^{2}(X,\mu_{n})\rightarrow 1.
  </annotation>
 </semantics>
</math>

 If <em>n</em> is divisible by <em>p</em> this argument breaks down because <em>p</em>th roots of 1 behave strangely over fields of characteristic <em>p</em>. In the Zariski topology the Kummer sequence is not exact on the right, as a non-vanishing function does not usually have an <em>n</em>th root locally for the Zariski topology, so this is one place where the use of the étale topology rather than the Zariski topology is essential.</p>
<h3 id="calculation-of-hix-znz">Calculation of H<sup><em>i</em></sup>(<em>X</em>, Z/<em>n</em>Z)</h3>

<p>By fixing a primitive <em>n</em>th root of 1 we can identify the group <strong>Z</strong>/<em>n<strong><em>Z</em>' with the group μ<sub><em>n</em></sub> of <em>n</em>th roots of 1. The étale group H<sup><em>i</em></sup>(<em>X</em>,</strong>Z<strong>/<em>n<strong>''Z</strong>) is then a free module over the ring <strong>Z</strong>/</em>n</strong></em>Z''' of rank 1 if <em>i</em>=0, 2<em>g</em> if <em>i</em>=1, 1 if <em>i</em>=2, and 0 if <em>i</em>≥ 3 (where <em>g</em> is the genus of the curve <em>X</em>). This follows from the previous result, using the fact that the Picard group of a curve is the points of its <a href="Jacobian_variety" title="wikilink">Jacobian variety</a>, an <a href="abelian_variety" title="wikilink">abelian variety</a> of dimension <em>g</em>, and if <em>n</em> is coprime to the characteristic then the points of order dividing <em>n</em> in an abelian variety of dimension <em>g</em> over an algebraically closed field form a group isomorphic to (<strong>Z</strong>/''n<em><strong>Z</strong>)<sup>2<em>g</em></sup>. These values for the étale group H<sup><em>i</em></sup>(</em>X<em>,<strong>Z</strong>/</em>n'<strong>'Z</strong>) are the same as the corresponding singular cohomology groups when <em>X</em> is a complex curve.</p>
<h3 id="calculation-of-hix-zpz">Calculation of H<sup><em>i</em></sup>(<em>X</em>, Z/<em>p</em>Z)</h3>

<p>It is possible to calculate étale cohomology groups with constant coefficients of order divisible by the characteristic in a similar way, using the <a href="Artin–Schreier_theory" title="wikilink">Artin–Schreier</a> sequence</p>

<p>

<math display="block" id="Étale_cohomology:13">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mi>𝐙</mi>
     <mo>/</mo>
     <mi>p</mi>
    </mrow>
    <mi>𝐙</mi>
   </mrow>
   <mo>→</mo>
   <mi>K</mi>
   <mover accent="true">
    <mo>→</mo>
    <mrow>
     <mi>x</mi>
     <mo>↦</mo>
     <mrow>
      <msup>
       <mi>x</mi>
       <mi>p</mi>
      </msup>
      <mo>-</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mover>
   <mi>K</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>𝐙</ci>
       <ci>p</ci>
      </apply>
      <ci>𝐙</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>K</ci>
    </apply>
    <apply>
     <apply>
      <apply>
       <csymbol cd="latexml">maps-to</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>p</ci>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>K</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow\mathbf{Z}/p\mathbf{Z}\rightarrow K\xrightarrow{x\mapsto x^{p}-x}K\rightarrow
0
  </annotation>
 </semantics>
</math>

</p>

<p>instead of the Kummer sequence. (For coefficients in <strong>Z</strong>/<em>p</em><sup><em>n</em></sup><strong>Z</strong> there is a similar sequence involving <a href="Witt_vector" title="wikilink">Witt vectors</a>.) The resulting cohomology groups usually have ranks less than that of the corresponding groups in characteristic 0.</p>
<h2 id="examples-of-étale-cohomology-groups">Examples of étale cohomology groups</h2>
<ul>
<li>If <em>X</em> is the spectrum of a field <em>K</em> with absolute Galois group <em>G</em>, then étale sheaves over <em>X</em> correspond to continuous sets (or abelian groups) acted on by the (profinite) group <em>G</em>, and étale cohomology of the sheaf is the same as the <a href="group_cohomology" title="wikilink">group cohomology</a> of <em>G</em>, i.e. the <a href="Galois_cohomology" title="wikilink">Galois cohomology</a> of <em>K</em>.</li>
</ul>
<ul>
<li>If <em>X</em> is a complex variety, then étale cohomology with finite coefficients is isomorphic to singular cohomology with finite coefficients. (This does not hold for integer coefficients.) More generally the cohomology with coefficients in any <a href="constructible_sheaf" title="wikilink">constructible sheaf</a> is the same.</li>
</ul>
<ul>
<li>If <em>F</em> is a <a href="coherent_sheaf" title="wikilink">coherent sheaf</a> (or <strong>G</strong><sub><em>m</em></sub>) then the étale cohomology of <em>F</em> is the same as Serre's coherent sheaf cohomology calculated with the Zariski topology (and if <em>X</em> is a complex variety this is the same as the sheaf cohomology calculated with the usual complex topology).</li>
</ul>
<ul>
<li>For abelian varieties and curves there is an elementary description of ℓ-adic cohomology. For abelian varieties the first ℓ-adic cohomology group is the dual of the <a href="Tate_module" title="wikilink">Tate module</a>, and the higher cohomology groups are given by its exterior powers. For curves the first cohomology group is the first cohomology group of its Jacobian. This explains why Weil was able to give a more elementary proof of the Weil conjectures in these two cases: in general one expects to find an elementary proof whenever there is an elementary description of the ℓ-adic cohomology.</li>
</ul>
<h2 id="poincaré-duality-and-cohomology-with-compact-support">Poincaré duality and cohomology with compact support</h2>

<p>The étale cohomology groups with compact support of a variety <em>X</em> are defined to be</p>

<p>

<math display="block" id="Étale_cohomology:14">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>H</mi>
     <mi>c</mi>
     <mi>q</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>F</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mi>q</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>j</mi>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </msub>
      <mi>F</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>c</ci>
      </apply>
      <ci>q</ci>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>F</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>q</ci>
     </apply>
     <interval closure="open">
      <ci>Y</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <factorial></factorial>
       </apply>
       <ci>F</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{c}^{q}(X,F)=H^{q}(Y,j_{!}F)
  </annotation>
 </semantics>
</math>

 where <em>j</em> is an open immersion of <em>X</em> into a proper variety <em>Y</em> and <em>j</em><sub>!</sub> is the extension by 0 of the étale sheaf <em>F</em> to <em>Y</em>. This is independent of the immersion <em>j</em>. If <em>X</em> has dimension at most <em>n</em> and <em>F</em> is a torsion sheaf then these cohomology groups 

<math display="inline" id="Étale_cohomology:15">
 <semantics>
  <mrow>
   <msubsup>
    <mi>H</mi>
    <mi>c</mi>
    <mi>q</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>c</ci>
     </apply>
     <ci>q</ci>
    </apply>
    <interval closure="open">
     <ci>X</ci>
     <ci>F</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{c}^{q}(X,F)
  </annotation>
 </semantics>
</math>

 with compact support vanish if <em>q</em> &gt; 2<em>n</em>, and if in addition <em>X</em> is affine of finite type over a separably closed field the cohomology groups 

<math display="inline" id="Étale_cohomology:16">
 <semantics>
  <mrow>
   <msup>
    <mi>H</mi>
    <mi>q</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <ci>q</ci>
    </apply>
    <interval closure="open">
     <ci>X</ci>
     <ci>F</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{q}(X,F)
  </annotation>
 </semantics>
</math>

 vanish for <em>q</em> &gt; <em>n</em> (for the last statement, see SGA 4, XIV, Cor.3.2).</p>

<p>More generally if <em>f</em> is a separated morphism of finite type from <em>X</em> to <em>S</em> (with <em>X</em> and <em>S</em> Noetherian) then the <strong>higher direct images with compact support</strong> <em>R</em><sup><em>q</em></sup><em>f</em><sub>!</sub> are defined by</p>

<p>

<math display="block" id="Étale_cohomology:17">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>R</mi>
     <mi>q</mi>
    </msup>
    <msub>
     <mi>f</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>F</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>R</mi>
     <mi>q</mi>
    </msup>
    <msub>
     <mi>g</mi>
     <mo>*</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>j</mi>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </msub>
      <mi>F</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>q</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <factorial></factorial>
     </apply>
     <ci>F</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>q</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <times></times>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <factorial></factorial>
      </apply>
      <ci>F</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{q}f_{!}(F)=R^{q}g_{*}(j_{!}F)
  </annotation>
 </semantics>
</math>

 for any torsion sheaf <em>F</em>. Here <em>j</em> is any open immersion of <em>X</em> into a scheme <em>Y</em> with a proper morphism <em>g</em> to <em>S</em> (with <em>f</em> = <em>gj</em>), and as before the definition does not depend on the choice of <em>j</em> and <em>Y</em>. Cohomology with compact support is the special case of this with <em>S</em> a point. If <em>f</em> is a separated morphism of finite type then <em>R</em><sup><em>q</em></sup><em>f</em><sub>!</sub> takes constructible sheaves on <em>X</em> to constructible sheaves on <em>S</em>. If in addition the fibers of <em>f</em> have dimension at most <em>n</em> then <em>R</em><sup><em>q</em></sup><em>f</em><sub>!</sub> vanishes on torsion sheaves for <em>q</em> &gt; <em>2n</em>. If <em>X</em> is a complex variety then <em>R</em><sup><em>q</em></sup><em>f</em><sub>!</sub> is the same as the usual higher direct image with compact support (for the complex topology) for torsion sheaves.</p>

<p>If <em>X</em> is a smooth algebraic variety of dimension <em>N</em> and <em>n</em> is coprime to the characteristic then the there is a trace map</p>

<p>

<math display="block" id="Étale_cohomology:18">
 <semantics>
  <mrow>
   <mi>Tr</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi>H</mi>
      <mi>c</mi>
      <mrow>
       <mn>2</mn>
       <mi>N</mi>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>,</mo>
      <msubsup>
       <mi>μ</mi>
       <mi>n</mi>
       <mi>N</mi>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>↦</mo>
    <mrow>
     <mrow>
      <mi>𝐙</mi>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
     <mi>𝐙</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>Tr</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>c</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>N</ci>
       </apply>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <ci>n</ci>
        </apply>
        <ci>N</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>𝐙</ci>
       <ci>n</ci>
      </apply>
      <ci>𝐙</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Tr}:H_{c}^{2N}(X,\mu_{n}^{N})\mapsto\mathbf{Z}/n\mathbf{Z}
  </annotation>
 </semantics>
</math>

 and the bilinear form Tr(<em>a</em>∪<em>b</em>) with values in <strong>Z</strong>/<em>n</em><strong>Z</strong> identifies each of the groups</p>

<p>

<math display="block" id="Étale_cohomology:19">
 <semantics>
  <mrow>
   <msubsup>
    <mi>H</mi>
    <mi>c</mi>
    <mi>i</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <msubsup>
     <mi>μ</mi>
     <mi>n</mi>
     <mi>N</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>i</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <interval closure="open">
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>n</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{i}_{c}(X,\mu_{n}^{N})
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Étale_cohomology:20">
 <semantics>
  <mrow>
   <msup>
    <mi>H</mi>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>N</mi>
     </mrow>
     <mo>-</mo>
     <mi>i</mi>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>𝐙</mi>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
     <mi>𝐙</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>N</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
    <interval closure="open">
     <ci>X</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>𝐙</ci>
       <ci>n</ci>
      </apply>
      <ci>𝐙</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{2N-i}(X,\mathbf{Z}/n\mathbf{Z})
  </annotation>
 </semantics>
</math>

 with the dual of the other. This is the analogue of Poincaré duality for étale cohomology.</p>
<h2 id="an-application-to-curves">An application to curves</h2>

<p>This is how the theory could be applied to the <a href="local_zeta-function" title="wikilink">local zeta-function</a> of an <a href="algebraic_curve" title="wikilink">algebraic curve</a>.</p>

<p><strong>Theorem.</strong> Let 

<math display="inline" id="Étale_cohomology:21">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 be a curve of <a href="genus_(mathematics)" title="wikilink">genus</a> 

<math display="inline" id="Étale_cohomology:22">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 defined over <mtpl></mtpl>, the <a href="finite_field" title="wikilink">finite field</a> with 

<math display="inline" id="Étale_cohomology:23">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 elements. Then for 

<math display="inline" id="Étale_cohomology:24">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">≥</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-≥</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n≥1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Étale_cohomology:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">#</mi>
     <mi>X</mi>
     <mrow>
      <mo>(</mo>
      <msub>
       <mi>𝐅</mi>
       <msup>
        <mi>p</mi>
        <mi>n</mi>
       </msup>
      </msub>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>p</mi>
       <mi>n</mi>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>-</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>g</mi>
       </mrow>
      </munderover>
      <msubsup>
       <mi>α</mi>
       <mi>i</mi>
       <mi>n</mi>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-#</ci>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>g</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \#X\left(\mathbf{F}_{p^{n}}\right)=p^{n}+1-\sum_{i=1}^{2g}\alpha_{i}^{n},
  </annotation>
 </semantics>
</math>

</p>

<p>where <mtpl></mtpl> are certain <a href="algebraic_number" title="wikilink">algebraic numbers</a> satisfying <mtpl><em>α<sub>i</sub></em>{{!}} {{=}} √<em>p</em>}}</mtpl>.</p>

<p>This agrees with <a href="projective_line" title="wikilink"><mtpl></mtpl></a> being a curve of genus 

<math display="inline" id="Étale_cohomology:26">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 with <mtpl></mtpl> points. It also shows that the number of points on any curve is rather close (within <mtpl></mtpl>) to that of the projective line; in particular, it generalizes <a href="Hasse's_theorem_on_elliptic_curves" title="wikilink">Hasse's theorem on elliptic curves</a>.</p>
<h3 id="idea-of-proof">Idea of proof</h3>

<p>According to the <a href="Lefschetz_fixed_point_theorem" title="wikilink">Lefschetz fixed point theorem</a>, the number of fixed points of any morphism 

<math display="inline" id="Étale_cohomology:27">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mi mathvariant="normal">→</mi>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>normal-→</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X→X
  </annotation>
 </semantics>
</math>

 is equal to the sum</p>

<p>

<math display="block" id="Étale_cohomology:28">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo>dim</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </munderover>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>i</mi>
     </msup>
     <mi>Tr</mi>
     <mrow>
      <mo>(</mo>
      <msub>
       <mrow>
        <mi>f</mi>
        <mo fence="true">|</mo>
       </mrow>
       <mrow>
        <msup>
         <mi>H</mi>
         <mi>i</mi>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>X</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msub>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="latexml">dimension</csymbol>
       <ci>X</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>Tr</ci>
     <apply>
      <csymbol cd="latexml">evaluated-at</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>H</ci>
        <ci>i</ci>
       </apply>
       <ci>X</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=0}^{2\dim(X)}(-1)^{i}\mathrm{Tr}\left(f|_{H^{i}(X)}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>This formula is valid for ordinary topological varieties and ordinary topology, but it is wrong for most <em>algebraic</em> topologies. However, this formula <em>does hold</em> for étale cohomology (though this is not so simple to prove).</p>

<p>The points of 

<math display="inline" id="Étale_cohomology:29">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 that are defined over <mtpl></mtpl> are those fixed by <mtpl></mtpl>, where 

<math display="inline" id="Étale_cohomology:30">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is the <a href="Frobenius_automorphism" title="wikilink">Frobenius automorphism</a> in <a href="characteristic_(algebra)" title="wikilink">characteristic</a> 

<math display="inline" id="Étale_cohomology:31">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

.</p>

<p>The étale cohomology <a href="Betti_number" title="wikilink">Betti numbers</a> of 

<math display="inline" id="Étale_cohomology:32">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 in dimensions 

<math display="inline" id="Étale_cohomology:33">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0,1,2
  </annotation>
 </semantics>
</math>

 are 

<math display="inline" id="Étale_cohomology:34">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>,</mo>
   <mrow>
    <mn>2</mn>
    <mi>g</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>g</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1,2g
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Étale_cohomology:35">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 respectively.</p>

<p>According to all of these,</p>

<p>

<math display="block" id="Étale_cohomology:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">#</mi>
     <mi>X</mi>
     <mrow>
      <mo>(</mo>
      <msub>
       <mi>𝐅</mi>
       <msup>
        <mi>p</mi>
        <mi>n</mi>
       </msup>
      </msub>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>Tr</mi>
       <mrow>
        <mo>(</mo>
        <msub>
         <mrow>
          <msup>
           <mi>F</mi>
           <mi>n</mi>
          </msup>
          <mo fence="true">|</mo>
         </mrow>
         <mrow>
          <msup>
           <mi>H</mi>
           <mn>0</mn>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>X</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msub>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>Tr</mi>
       <mrow>
        <mo>(</mo>
        <msub>
         <mrow>
          <msup>
           <mi>F</mi>
           <mi>n</mi>
          </msup>
          <mo fence="true">|</mo>
         </mrow>
         <mrow>
          <msup>
           <mi>H</mi>
           <mn>1</mn>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>X</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msub>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>Tr</mi>
      <mrow>
       <mo>(</mo>
       <msub>
        <mrow>
         <msup>
          <mi>F</mi>
          <mi>n</mi>
         </msup>
         <mo fence="true">|</mo>
        </mrow>
        <mrow>
         <msup>
          <mi>H</mi>
          <mn>2</mn>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msub>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-#</ci>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>Tr</ci>
       <apply>
        <csymbol cd="latexml">evaluated-at</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>F</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>H</ci>
          <cn type="integer">0</cn>
         </apply>
         <ci>X</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>Tr</ci>
       <apply>
        <csymbol cd="latexml">evaluated-at</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>F</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>H</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>X</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>Tr</ci>
      <apply>
       <csymbol cd="latexml">evaluated-at</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>F</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>H</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \#X\left(\mathbf{F}_{p^{n}}\right)=\mathrm{Tr}\left(F^{n}|_{H^{0}(X)}\right)-%
\mathrm{Tr}\left(F^{n}|_{H^{1}(X)}\right)+\mathrm{Tr}\left(F^{n}|_{H^{2}(X)}%
\right).
  </annotation>
 </semantics>
</math>

</p>

<p>This gives the general form of the theorem.</p>

<p>The assertion on the absolute values of the <mtpl></mtpl> is the 1-dimensional Riemann Hypothesis of the Weil Conjectures.</p>

<p>The whole idea fits into the framework of <a href="motive_(mathematics)" title="wikilink">motives</a>: formally [<em>X</em>] = [point]+[line]+[1-part], and [1-part] has something like 

<math display="inline" id="Étale_cohomology:37">
 <semantics>
  <mrow>
   <mi mathvariant="normal">√</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-√</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   √p
  </annotation>
 </semantics>
</math>

 points.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Locally_acyclic_morphism" title="wikilink">Locally acyclic morphism</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>Chapter1: </p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Archibald and Savitt <a href="http://www.math.mcgill.ca/goren/SeminarOnCohomology/etale2.pdf"><em>Étale cohomology</em></a></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Cohomology_theories" title="wikilink">Category:Cohomology theories</a> <a href="Category:Homological_algebra" title="wikilink">Category:Homological algebra</a> <a href="Category:Topological_methods_of_algebraic_geometry" title="wikilink">Category:Topological methods of algebraic geometry</a></p>
</body>
</html>
