<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1871">Truth function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Truth function</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, a <strong>truth function</strong> is a <a href="function_(mathematics)" title="wikilink">function</a> from a <a href="set_(mathematics)" title="wikilink">set</a> of <a href="truth_value" title="wikilink">truth values</a> to truth values. Classically the <a href="domain_of_a_function" title="wikilink">domain</a> and <a href="range_(mathematics)" title="wikilink">range</a> of a truth function are {<em><a class="uri" href="truth" title="wikilink">truth</a></em>, <em><a href="false_(logic)" title="wikilink">falsehood</a></em>}, but they may have any number of truth values, including an infinity of these.</p>

<p>A <a href="logical_connective" title="wikilink">logical connective</a> is truth-functional if the truth-value of a compound sentence is a function of the truth-value of its sub-sentences. A class of connectives is truth-functional if each of its members is. For example, the connective "<em>and</em>" is truth-functional since a sentence like "<em>Apples are fruits and carrots are vegetables</em>" is true <em><a href="if_and_only_if" title="wikilink">if, and only if</a></em> each of its sub-sentences "<em>apples are fruits</em>" and "<em>carrots are vegetables</em>" is true, and it is false otherwise. Some connectives of a natural language, such as English, are not truth-functional.</p>

<p>Connectives of the form "x <em>believes that</em> ..." are typical examples of connectives that are not truth-functional. If e.g. Mary mistakenly believes that Al Gore was President of the USA on April 20, 2000, but she does not believe that the moon is made of green cheese, then the sentence</p>
<dl>
<dd>"<em>Mary believes that Al Gore was President of the USA on April 20, 2000</em>"
</dd>
</dl>

<p>is true while</p>
<dl>
<dd>"<em>Mary believes that the moon is made of green cheese</em>"
</dd>
</dl>

<p>is false. In both cases, each component sentence (i.e. "<em>Al Gore was president of the USA on April 20, 2000</em>" and "<em>the moon is made of green cheese</em>") is false, but each compound sentence formed by prefixing the phrase "<em>Mary believes that</em>" differs in truth-value. That is, the truth-value of a sentence of the form "<em>Mary believes that...</em>" is not determined solely by the truth-value of its component sentence, and hence the (unary) <a href="Logical_connective" title="wikilink">connective</a> (or simply <em>operator</em> since it is unary) is non-truth-functional.</p>

<p>The class of <a href="classical_logic" title="wikilink">classical logic</a> connectives (e.g. <a href="and_(logic)" title="wikilink">&amp;</a>, <a href="material_conditional" title="wikilink">→</a>) used in the construction of formulas is truth-functional. Their values for various truth-values as argument are usually given by <a href="truth_table" title="wikilink">truth tables</a>. <a href="Truth-functional_propositional_calculus" title="wikilink">Truth-functional propositional calculus</a> is a <a href="formal_system" title="wikilink">formal system</a> whose formulas may be interpreted as either true or false.</p>
<h2 id="table-of-binary-truth-functions">Table of binary truth functions</h2>

<p>In two-valued logic, there are sixteen possible truth functions, also called <a href="Boolean_function" title="wikilink">Boolean functions</a>, of two inputs <em>P</em> and <em>Q</em>. Any of these functions corresponds to a truth table of a certain <a href="logical_connective" title="wikilink">logical connective</a> in classical logic, including several <a href="degeneracy_(mathematics)" title="wikilink">degenerate</a> cases such as a function not depending on one or both of its arguments. Truth and falsehood is denoted as 1 and 0 in the following truth tables, respectively, for sake of brevity.</p>
<center>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Contradiction|also=/<a href="false_(logic)" title="wikilink">False</a></p></td>
<td style="text-align: left;">
<p>notation=

<math display="inline" id="Truth_function:0">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

<br/>
"bottom"</p></td>
<td style="text-align: left;">
<p>equivalents=<em>P</em> 

<math display="inline" id="Truth_function:1">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 ¬<em>P</em><br/>
O<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=0</p></td>
<td style="text-align: left;">
<p>truthtable-01=0</p></td>
<td style="text-align: left;">
<p>truthtable-10=0</p></td>
<td style="text-align: left;">
<p>truthtable-11=0</p></td>
<td style="text-align: left;">
<p>image=Venn0000.svg }}</p></td>
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Tautology (logic)|also=/<a href="true_(logic)" title="wikilink">True</a></p></td>
<td style="text-align: left;">
<p>title=Tautology</p></td>
<td style="text-align: left;">
<p>notation=

<math display="inline" id="Truth_function:2">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

<br/>
"top"</p></td>
<td style="text-align: left;">
<p>equivalents=<em>P</em> 

<math display="inline" id="Truth_function:3">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>


 ¬<em>P</em><br/>
V<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=1</p></td>
<td style="text-align: left;">
<p>truthtable-01=1</p></td>
<td style="text-align: left;">
<p>truthtable-10=1</p></td>
<td style="text-align: left;">
<p>truthtable-11=1</p></td>
<td style="text-align: left;">
<p>image=Venn1111.svg }}</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Proposition</p></td>
<td style="text-align: left;">
<p>title=Proposition <em>P</em></p></td>
<td style="text-align: left;">
<p>notation=<em>P</em></p></td>
<td style="text-align: left;">
<p>equivalents=<em>p</em><br/>
I<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=0</p></td>
<td style="text-align: left;">
<p>truthtable-01=0</p></td>
<td style="text-align: left;">
<p>truthtable-10=1</p></td>
<td style="text-align: left;">
<p>truthtable-11=1</p></td>
<td style="text-align: left;">
<p>image=Venn0101.svg }}</p></td>
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Negation</p></td>
<td style="text-align: left;">
<p>title=Negation of <em>P</em></p></td>
<td style="text-align: left;">
<p>notation=¬<em>P</em><br/>
~<em>P</em></p></td>
<td style="text-align: left;">
<p>equivalents=N<em>p</em><br/>
F<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=1</p></td>
<td style="text-align: left;">
<p>truthtable-01=1</p></td>
<td style="text-align: left;">
<p>truthtable-10=0</p></td>
<td style="text-align: left;">
<p>truthtable-11=0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Proposition</p></td>
<td style="text-align: left;">
<p>title=Proposition <em>Q</em></p></td>
<td style="text-align: left;">
<p>notation=<em>Q</em></p></td>
<td style="text-align: left;">
<p>equivalents=<em>q</em><br/>
H<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=0</p></td>
<td style="text-align: left;">
<p>truthtable-01=1</p></td>
<td style="text-align: left;">
<p>truthtable-10=0</p></td>
<td style="text-align: left;">
<p>truthtable-11=1</p></td>
<td style="text-align: left;">
<p>image=Venn0011.svg }}</p></td>
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Negation</p></td>
<td style="text-align: left;">
<p>title=Negation of <em>Q</em></p></td>
<td style="text-align: left;">
<p>notation=¬<em>Q</em><br/>
~<em>Q</em></p></td>
<td style="text-align: left;">
<p>equivalents=N<em>q</em><br/>
G<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=1</p></td>
<td style="text-align: left;">
<p>truthtable-01=0</p></td>
<td style="text-align: left;">
<p>truthtable-10=1</p></td>
<td style="text-align: left;">
<p>truthtable-11=0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Logical conjunction</p></td>
<td style="text-align: left;">
<p>title=Conjunction</p></td>
<td style="text-align: left;">
<p>notation=<em>P</em> 

<math display="inline" id="Truth_function:4">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 <em>Q</em><br/>
<em>P</em> &amp; <em>Q</em><br/>
<em>P</em> <strong>·</strong> <em>Q</em><br/>
<em>P</em> AND <em>Q</em></p></td>
<td style="text-align: left;">
<p>equivalents=<em>P</em> 

<math display="inline" id="Truth_function:5">
 <semantics>
  <mo>↛</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\rightarrow
  </annotation>
 </semantics>
</math>

¬<em>Q</em><br/>
 ¬<em>P</em> 

<math display="inline" id="Truth_function:6">
 <semantics>
  <mo>↚</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftarrow
  </annotation>
 </semantics>
</math>

 <em>Q</em><br/>
 ¬<em>P</em> 

<math display="inline" id="Truth_function:7">
 <semantics>
  <mo>↓</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↓</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \downarrow
  </annotation>
 </semantics>
</math>

 ¬<em>Q</em><br/>
K<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=0</p></td>
<td style="text-align: left;">
<p>truthtable-01=0</p></td>
<td style="text-align: left;">
<p>truthtable-10=0</p></td>
<td style="text-align: left;">
<p>truthtable-11=1</p></td>
<td style="text-align: left;">
<p>image=Venn0001.svg }}</p></td>
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Sheffer stroke</p></td>
<td style="text-align: left;">
<p>title=Alternative denial</p></td>
<td style="text-align: left;">
<p>notation=<em>P</em> ↑ <em>Q</em><br/>
<em>P</em> | <em>Q</em><br/>
<em>P</em> NAND <em>Q</em></p></td>
<td style="text-align: left;">
<p>equivalents=<em>P</em> → ¬<em>Q</em><br/>
 ¬<em>P</em> ← <em>Q</em><br/>
¬<em>P</em>  ¬<em>Q</em><br/>
D<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=1</p></td>
<td style="text-align: left;">
<p>truthtable-01=1</p></td>
<td style="text-align: left;">
<p>truthtable-10=1</p></td>
<td style="text-align: left;">
<p>truthtable-11=0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Logical disjunction</p></td>
<td style="text-align: left;">
<p>title=Disjunction</p></td>
<td style="text-align: left;">
<p>notation=<em>P</em> <em>Q</em><br/>
<em>P</em> OR <em>Q</em></p></td>
<td style="text-align: left;">
<p>equivalents=<em>P</em> 

<math display="inline" id="Truth_function:8">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>


 ¬<em>Q</em><br/>
 ¬<em>P</em> → <em>Q</em><br/>
 ¬<em>P</em> ↑ ¬<em>Q</em><br/>
¬(¬<em>P</em> 

<math display="inline" id="Truth_function:9">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 ¬<em>Q</em>)<br/>
A<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=0</p></td>
<td style="text-align: left;">
<p>truthtable-01=1</p></td>
<td style="text-align: left;">
<p>truthtable-10=1</p></td>
<td style="text-align: left;">
<p>truthtable-11=1</p></td>
<td style="text-align: left;">
<p>image=Venn0111.svg }}</p></td>
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Logical NOR</p></td>
<td style="text-align: left;">
<p>title=Joint denial</p></td>
<td style="text-align: left;">
<p>notation=<em>P</em> ↓ <em>Q</em><br/>
<em>P</em> NOR <em>Q</em></p></td>
<td style="text-align: left;">
<p>equivalents=<em>P</em> 

<math display="inline" id="Truth_function:10">
 <semantics>
  <mo>↚</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftarrow
  </annotation>
 </semantics>
</math>

 ¬<em>Q</em><br/>
 ¬<em>P</em> 

<math display="inline" id="Truth_function:11">
 <semantics>
  <mo>↛</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\rightarrow
  </annotation>
 </semantics>
</math>

 <em>Q</em><br/>
 ¬<em>P</em> 

<math display="inline" id="Truth_function:12">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 ¬<em>Q</em><br/>
X<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=1</p></td>
<td style="text-align: left;">
<p>truthtable-01=0</p></td>
<td style="text-align: left;">
<p>truthtable-10=0</p></td>
<td style="text-align: left;">
<p>truthtable-11=0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Material nonimplication</p></td>
<td style="text-align: left;">
<p>title=Material nonimplication</p></td>
<td style="text-align: left;">
<p>notation=<em>P</em> 

<math display="inline" id="Truth_function:13">
 <semantics>
  <mo>↛</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\rightarrow
  </annotation>
 </semantics>
</math>


 <em>Q</em><br/>
<em>P</em> 

<math display="inline" id="Truth_function:14">
 <semantics>
  <mo>⊅</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">not-superset-of</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\supset
  </annotation>
 </semantics>
</math>

 <em>Q</em></p></td>
<td style="text-align: left;">
<p>equivalents=<em>P</em> 

<math display="inline" id="Truth_function:15">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 ¬<em>Q</em><br/>
 ¬<em>P</em> ↓ <em>Q</em><br/>
 ¬<em>P</em> 

<math display="inline" id="Truth_function:16">
 <semantics>
  <mo>↚</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftarrow
  </annotation>
 </semantics>
</math>

 ¬<em>Q</em><br/>
L<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=0</p></td>
<td style="text-align: left;">
<p>truthtable-01=0</p></td>
<td style="text-align: left;">
<p>truthtable-10=1</p></td>
<td style="text-align: left;">
<p>truthtable-11=0</p></td>
<td style="text-align: left;">
<p>image=Venn0100.svg }}</p></td>
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Material conditional</p></td>
<td style="text-align: left;">
<p>title=Material implication</p></td>
<td style="text-align: left;">
<p>notation=<em>P</em> → <em>Q</em><br/>
<em>P</em> 

<math display="inline" id="Truth_function:17">
 <semantics>
  <mo>⊃</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">superset-of</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \supset
  </annotation>
 </semantics>
</math>

 <em>Q</em></p></td>
<td style="text-align: left;">
<p>equivalents=<em>P</em> ↑ ¬<em>Q</em><br/>
 ¬<em>P</em> <em>Q</em><br/>
 ¬<em>P</em> ← ¬<em>Q</em><br/>
C<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=1</p></td>
<td style="text-align: left;">
<p>truthtable-01=1</p></td>
<td style="text-align: left;">
<p>truthtable-10=0</p></td>
<td style="text-align: left;">
<p>truthtable-11=1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Converse nonimplication</p></td>
<td style="text-align: left;">
<p>title=Converse nonimplication</p></td>
<td style="text-align: left;">
<p>notation=<em>P</em> 

<math display="inline" id="Truth_function:18">
 <semantics>
  <mo>↚</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftarrow
  </annotation>
 </semantics>
</math>


 <em>Q</em><br/>
<em>P</em> 

<math display="inline" id="Truth_function:19">
 <semantics>
  <mo>⊄</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">not-subset-of</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\subset
  </annotation>
 </semantics>
</math>

 <em>Q</em></p></td>
<td style="text-align: left;">
<p>equivalents=<em>P</em> ↓ ¬<em>Q</em><br/>
 ¬<em>P</em> 

<math display="inline" id="Truth_function:20">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 <em>Q</em><br/>
 ¬<em>P</em> 

<math display="inline" id="Truth_function:21">
 <semantics>
  <mo>↛</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\rightarrow
  </annotation>
 </semantics>
</math>

 ¬<em>Q</em><br/>
M<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=0</p></td>
<td style="text-align: left;">
<p>truthtable-01=1</p></td>
<td style="text-align: left;">
<p>truthtable-10=0</p></td>
<td style="text-align: left;">
<p>truthtable-11=0</p></td>
<td style="text-align: left;">
<p>image=Venn0010.svg }}</p></td>
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Converse implication</p></td>
<td style="text-align: left;">
<p>title=Converse implication</p></td>
<td style="text-align: left;">
<p>notation=<em>P</em> 

<math display="inline" id="Truth_function:22">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

 <em>Q</em><br/>
<em>P</em> 

<math display="inline" id="Truth_function:23">
 <semantics>
  <mo>⊂</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subset
  </annotation>
 </semantics>
</math>


 <em>Q</em></p></td>
<td style="text-align: left;">
<p>equivalents=<em>P</em>  ¬<em>Q</em><br/>
 ¬<em>P</em> ↑ <em>Q</em><br/>
 ¬<em>P</em> → ¬<em>Q</em><br/>
B<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=1</p></td>
<td style="text-align: left;">
<p>truthtable-01=0</p></td>
<td style="text-align: left;">
<p>truthtable-10=1</p></td>
<td style="text-align: left;">
<p>truthtable-11=1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Exclusive or</p></td>
<td style="text-align: left;">
<p>title=Exclusive disjunction</p></td>
<td style="text-align: left;">
<p>notation=<em>P</em> 

<math display="inline" id="Truth_function:24">
 <semantics>
  <mo>↮</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftrightarrow
  </annotation>
 </semantics>
</math>

 <em>Q</em><br/>
<em>P</em> 

<math display="inline" id="Truth_function:25">
 <semantics>
  <mo>≢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">not-equivalent-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\equiv
  </annotation>
 </semantics>
</math>

 <em>Q</em><br/>
<em>P</em> 

<math display="inline" id="Truth_function:26">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 <em>Q</em><br/>
<em>P</em> XOR <em>Q</em></p></td>
<td style="text-align: left;">
<p>equivalents=<em>P</em>  ¬<em>Q</em><br/>
 ¬<em>P</em> <em>Q</em><br/>
 ¬<em>P</em> 

<math display="inline" id="Truth_function:27">
 <semantics>
  <mo>↮</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftrightarrow
  </annotation>
 </semantics>
</math>

 ¬<em>Q</em><br/>
J<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=0</p></td>
<td style="text-align: left;">
<p>truthtable-01=1</p></td>
<td style="text-align: left;">
<p>truthtable-10=1</p></td>
<td style="text-align: left;">
<p>truthtable-11=0</p></td>
<td style="text-align: left;">
<p>image=Venn0110.svg }}</p></td>
<td style="text-align: left;">
<p>{{logicalconnective</p></td>
<td style="text-align: left;">
<p>main=Logical biconditional</p></td>
<td style="text-align: left;">
<p>title=Biconditional</p></td>
<td style="text-align: left;">
<p>notation=<em>P</em> <em>Q</em><br/>
<em>P</em> ≡ <em>Q</em><br/>
<em>P</em> XNOR <em>Q</em><br/>
<em>P</em> IFF <em>Q</em></p></td>
<td style="text-align: left;">
<p>equivalents=<em>P</em> 

<math display="inline" id="Truth_function:28">
 <semantics>
  <mo>↮</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftrightarrow
  </annotation>
 </semantics>
</math>


 ¬<em>Q</em><br/>
 ¬<em>P</em> 

<math display="inline" id="Truth_function:29">
 <semantics>
  <mo>↮</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftrightarrow
  </annotation>
 </semantics>
</math>

 <em>Q</em><br/>
 ¬<em>P</em>  ¬<em>Q</em><br/>
E<em>pq</em></p></td>
<td style="text-align: left;">
<p>truthtable-00=1</p></td>
<td style="text-align: left;">
<p>truthtable-01=0</p></td>
<td style="text-align: left;">
<p>truthtable-10=0</p></td>
<td style="text-align: left;">
<p>truthtable-11=1</p></td>
</tr>
</tbody>
</table>

<p></p>
</center>
<h2 id="functional-completeness">Functional completeness</h2>

<p>Because a function may be expressed as a <a href="composition_of_functions" title="wikilink">composition</a>, a truth-functional logical calculus does not need to have dedicated symbols for all of the above-mentioned functions to be <a href="functional_completeness" title="wikilink">functionally complete</a>. This is expressed in a <a href="propositional_calculus" title="wikilink">propositional calculus</a> as <a href="logical_equivalence" title="wikilink">logical equivalence</a> of certain compound statements. For example, classical logic has 

<math display="inline" id="Truth_function:30">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
   <mi mathvariant="normal">∨</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-¬</ci>
    <ci>P</ci>
    <ci>normal-∨</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ¬P∨Q
  </annotation>
 </semantics>
</math>

 equivalent to 

<math display="inline" id="Truth_function:31">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">→</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-→</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P→Q
  </annotation>
 </semantics>
</math>

. The conditional operator "→" is therefore not necessary for a classical-based <a href="logical_system" title="wikilink">logical system</a> if "¬" (not) and "∨" (or) are already in use.</p>

<p>A <a href="minimal_element" title="wikilink">minimal</a> set of operators that can express every statement expressible in the <a href="propositional_calculus" title="wikilink">propositional calculus</a> is called a <em>minimal functionally complete set</em>. A minimally complete set of operators is achieved by NAND alone {↑} and NOR alone {↓}.</p>

<p>The following are the minimal functionally complete sets of operators whose arities do not exceed 2:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<dl>
<dt>One element: {↑}, {↓}.<br/>
Two elements: {

<math display="inline" id="Truth_function:32">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>

, ¬}, {

<math display="inline" id="Truth_function:33">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>


, ¬}, {→, ¬}, {←, ¬}, {→, 

<math display="inline" id="Truth_function:34">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

}, {←, 

<math display="inline" id="Truth_function:35">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

}, {→, 

<math display="inline" id="Truth_function:36">
 <semantics>
  <mo>↮</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftrightarrow
  </annotation>
 </semantics>
</math>

}, {←, 

<math display="inline" id="Truth_function:37">
 <semantics>
  <mo>↮</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftrightarrow
  </annotation>
 </semantics>
</math>

}, {→, 

<math display="inline" id="Truth_function:38">
 <semantics>
  <mo>↛</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\to
  </annotation>
 </semantics>
</math>


}, {→, 

<math display="inline" id="Truth_function:39">
 <semantics>
  <mo>↚</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftarrow
  </annotation>
 </semantics>
</math>

}, {←, 

<math display="inline" id="Truth_function:40">
 <semantics>
  <mo>↛</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\to
  </annotation>
 </semantics>
</math>

}, {←, 

<math display="inline" id="Truth_function:41">
 <semantics>
  <mo>↚</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftarrow
  </annotation>
 </semantics>
</math>

}, {

<math display="inline" id="Truth_function:42">
 <semantics>
  <mo>↛</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\to
  </annotation>
 </semantics>
</math>

, ¬}, {

<math display="inline" id="Truth_function:43">
 <semantics>
  <mo>↚</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftarrow
  </annotation>
 </semantics>
</math>


, ¬}, {

<math display="inline" id="Truth_function:44">
 <semantics>
  <mo>↛</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\to
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:45">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

}, {

<math display="inline" id="Truth_function:46">
 <semantics>
  <mo>↚</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftarrow
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:47">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

}, {

<math display="inline" id="Truth_function:48">
 <semantics>
  <mo>↛</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\to
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Truth_function:49">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>

}, {

<math display="inline" id="Truth_function:50">
 <semantics>
  <mo>↚</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftarrow
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:51">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>

}.<br/>
Three elements: {

<math display="inline" id="Truth_function:52">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:53">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Truth_function:54">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

}, {

<math display="inline" id="Truth_function:55">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:56">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:57">
 <semantics>
  <mo>↮</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftrightarrow
  </annotation>
 </semantics>
</math>

}, {

<math display="inline" id="Truth_function:58">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Truth_function:59">
 <semantics>
  <mo>↮</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftrightarrow
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:60">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

}, {

<math display="inline" id="Truth_function:61">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:62">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:63">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>


}, {

<math display="inline" id="Truth_function:64">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:65">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:66">
 <semantics>
  <mo>↮</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftrightarrow
  </annotation>
 </semantics>
</math>

}, {

<math display="inline" id="Truth_function:67">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:68">
 <semantics>
  <mo>↮</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftrightarrow
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Truth_function:69">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

}.</dt>
</dl>
<h2 id="algebraic-properties">Algebraic properties</h2>

<p>Some truth functions possess properties which may be expressed in the theorems containing the corresponding connective. Some of those properties that a binary truth function (or a corresponding logical connective) may have are:</p>
<ul>
<li><strong><a class="uri" href="Associativity" title="wikilink">Associativity</a></strong>: Within an expression containing two or more of the same associative connectives in a row, the order of the operations does not matter as long as the sequence of the operands is not changed.</li>
<li><strong><a class="uri" href="Commutativity" title="wikilink">Commutativity</a></strong>: The operands of the connective may be swapped without affecting the truth-value of the expression.</li>
<li><strong><a class="uri" href="Distributivity" title="wikilink">Distributivity</a></strong>: A connective denoted by · distributes over another connective denoted by +, if <em>a</em> · (<em>b</em> + <em>c</em>) = (<em>a</em> · <em>b</em>) + (<em>a</em> · <em>c</em>) for all operands <em>a</em>, <em>b</em>, <em>c</em>.</li>
<li><strong><a class="uri" href="Idempotence" title="wikilink">Idempotence</a></strong>: Whenever the operands of the operation are the same, the connective gives the operand as the result. In other words, the operation is both truth-preserving and falsehood-preserving (see below).</li>
<li><strong><a href="Absorption_Law" title="wikilink">Absorption</a></strong>: A pair of connectives 

<math display="inline" id="Truth_function:70">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:71">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

 satisfies the absorption law if 

<math display="inline" id="Truth_function:72">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>∨</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <ci>a</ci>
     <apply>
      <or></or>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\land(a\lor b)=a
  </annotation>
 </semantics>
</math>

 for all operands <em>a</em>, <em>b</em>.</li>
</ul>

<p>A set of truth functions is <a href="functional_completeness" title="wikilink">functionally complete</a> if and only if for each of the following five properties it contains at least one member lacking it:</p>
<ul>
<li><strong><a class="uri" href="monotonic" title="wikilink">monotonic</a></strong>: If <em>f</em>(<em>a</em><sub>1</sub>, ..., <em>a</em><sub><em>n</em></sub>) ≤ <em>f</em>(<em>b</em><sub>1</sub>, ..., <em>b</em><sub><em>n</em></sub>) for all <em>a</em><sub>1</sub>, ..., <em>a</em><sub><em>n</em></sub>, <em>b</em><sub>1</sub>, ..., <em>b</em><sub><em>n</em></sub> ∈ {0,1} such that <em>a</em><sub>1</sub> ≤ <em>b</em><sub>1</sub>, <em>a</em><sub>2</sub> ≤ <em>b</em><sub>2</sub>, ..., <em>a</em><sub><em>n</em></sub> ≤ <em>b</em><sub><em>n</em></sub>. E.g., 

<math display="inline" id="Truth_function:73">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Truth_function:74">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:75">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:76">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

.</li>
<li><strong><a href="affine_transformation" title="wikilink">affine</a></strong>: Each variable always makes a difference in the truth-value of the operation or it never makes a difference. E.g., 

<math display="inline" id="Truth_function:77">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:78">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Truth_function:79">
 <semantics>
  <mo>↮</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftrightarrow
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:80">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:81">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

.</li>
<li><strong>self dual</strong>: To read the truth-value assignments for the operation from top to bottom on its <a href="truth_table" title="wikilink">truth table</a> is the same as taking the complement of reading it from bottom to top; in other words, <em>f</em>(¬<em>a</em><sub>1</sub>, ..., ¬<em>a</em><sub><em>n</em></sub>) = ¬<em>f</em>(<em>a</em><sub>1</sub>, ..., <em>a</em><sub><em>n</em></sub>). E.g., 

<math display="inline" id="Truth_function:82">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg
  </annotation>
 </semantics>
</math>

.</li>
<li><strong>truth-preserving</strong>: The interpretation under which all variables are assigned a <a href="truth_value" title="wikilink">truth value</a> of 'true' produces a truth value of 'true' as a result of these operations. E.g., 

<math display="inline" id="Truth_function:83">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Truth_function:84">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:85">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:86">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:87">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>

, ⊂. (see <a class="uri" href="validity" title="wikilink">validity</a>)</li>
<li><strong>falsehood-preserving</strong>: The interpretation under which all variables are assigned a <a href="truth_value" title="wikilink">truth value</a> of 'false' produces a truth value of 'false' as a result of these operations. E.g., 

<math display="inline" id="Truth_function:88">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Truth_function:89">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:90">
 <semantics>
  <mo>↮</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftrightarrow
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Truth_function:91">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

, ⊄, ⊅. (see <a class="uri" href="validity" title="wikilink">validity</a>)</li>
</ul>
<h3 id="arity">Arity</h3>

<p>A concrete function may be also referred to as an <em>operator</em>. In two-valued logic there are 2 nullary operators (constants), 4 <a href="unary_operation" title="wikilink">unary operators</a>, 16 <a href="binary_operation" title="wikilink">binary operators</a>, 256 <a href="ternary_operation" title="wikilink">ternary operators</a>, and 

<math display="inline" id="Truth_function:92">
 <semantics>
  <msup>
   <mn>2</mn>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{2^{n}}
  </annotation>
 </semantics>
</math>

 <em>n</em>-ary operators. In three-valued logic there are 3 nullary operators (constants), 27 <a href="unary_operation" title="wikilink">unary operators</a>, 19683 <a href="binary_operation" title="wikilink">binary operators</a>, 7625597484987 <a href="ternary_operation" title="wikilink">ternary operators</a>, and 

<math display="inline" id="Truth_function:93">
 <semantics>
  <msup>
   <mn>3</mn>
   <msup>
    <mn>3</mn>
    <mi>n</mi>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">3</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">3</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3^{3^{n}}
  </annotation>
 </semantics>
</math>


 <em>n</em>-ary operators. In <em>k</em>-valued logic, there are <em>k</em> nullary operators, 

<math display="inline" id="Truth_function:94">
 <semantics>
  <msup>
   <mi>k</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{k}
  </annotation>
 </semantics>
</math>

 unary operators, 

<math display="inline" id="Truth_function:95">
 <semantics>
  <msup>
   <mi>k</mi>
   <msup>
    <mi>k</mi>
    <mn>2</mn>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{k^{2}}
  </annotation>
 </semantics>
</math>

 binary operators, 

<math display="inline" id="Truth_function:96">
 <semantics>
  <msup>
   <mi>k</mi>
   <msup>
    <mi>k</mi>
    <mn>3</mn>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{k^{3}}
  </annotation>
 </semantics>
</math>

 ternary operators, and 

<math display="inline" id="Truth_function:97">
 <semantics>
  <msup>
   <mi>k</mi>
   <msup>
    <mi>k</mi>
    <mi>n</mi>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{k^{n}}
  </annotation>
 </semantics>
</math>

 <em>n</em>-ary operators. An <em>n</em>-ary operator in <em>k</em>-valued logic is a function from 

<math display="inline" id="Truth_function:98">
 <semantics>
  <mrow>
   <msubsup>
    <mi>ℤ</mi>
    <mi>k</mi>
    <mi>n</mi>
   </msubsup>
   <mo>→</mo>
   <msub>
    <mi>ℤ</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>k</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{k}^{n}\to\mathbb{Z}_{k}
  </annotation>
 </semantics>
</math>


. Therefore the number of such operators is 

<math display="inline" id="Truth_function:99">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>ℤ</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <msubsup>
      <mi>ℤ</mi>
      <mi>k</mi>
      <mi>n</mi>
     </msubsup>
     <mo stretchy="false">|</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>k</mi>
    <msup>
     <mi>k</mi>
     <mi>n</mi>
    </msup>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℤ</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ℤ</ci>
        <ci>k</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathbb{Z}_{k}|^{|\mathbb{Z}_{k}^{n}|}=k^{k^{n}}
  </annotation>
 </semantics>
</math>

, which is how the above numbers were derived.</p>

<p>However, some of the operators of a particular arity are actually degenerate forms that perform a lower-arity operation on some of the inputs and ignores the rest of the inputs. Out of the 256 ternary boolean operators cited above, 

<math display="inline" id="Truth_function:100">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mstyle scriptlevel="+1">
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mn>3</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mn>2</mn>
         </mtd>
        </mtr>
       </mtable>
      </mstyle>
      <mo>)</mo>
     </mrow>
     <mo>⋅</mo>
     <mn>16</mn>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mstyle scriptlevel="+1">
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mn>3</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mn>1</mn>
         </mtd>
        </mtr>
       </mtable>
      </mstyle>
      <mo>)</mo>
     </mrow>
     <mo>⋅</mo>
     <mn>4</mn>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mstyle scriptlevel="+1">
      <mtable columnspacing="0.4em" rowspacing="0.2ex">
       <mtr>
        <mtd>
         <mn>3</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd>
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
     </mstyle>
     <mo>)</mo>
    </mrow>
    <mo>⋅</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <cn type="integer">3</cn>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">16</cn>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <cn type="integer">3</cn>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="latexml">binomial</csymbol>
      <cn type="integer">3</cn>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\left({{3}\atop{2}}\right)}\cdot 16-{\left({{3}\atop{1}}\right)}\cdot 4+{%
\left({{3}\atop{0}}\right)}\cdot 2
  </annotation>
 </semantics>
</math>

 of them are such degenerate forms of binary or lower-arity operators, using the <a href="inclusion-exclusion_principle" title="wikilink">inclusion-exclusion principle</a>. The ternary operator 

<math display="inline" id="Truth_function:101">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y,z)=\lnot x
  </annotation>
 </semantics>
</math>

 is one such operator which is actually a unary operator applied to one input, and ignoring the other two inputs.</p>

<p><a href="Negation" title="wikilink">"Not"</a> is a <a href="unary_operation" title="wikilink">unary operator</a>, it takes a single term (¬<em>P</em>). The rest are <a href="binary_operation" title="wikilink">binary operators</a>, taking two terms to make a compound statement (<em>P</em> 

<math display="inline" id="Truth_function:102">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 <em>Q</em>, <em>P</em> 

<math display="inline" id="Truth_function:103">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>


 <em>Q</em>, <em>P</em> → <em>Q</em>, <em>P</em> ↔ <em>Q</em>).</p>

<p>The set of logical operators 

<math display="inline" id="Truth_function:104">
 <semantics>
  <mpadded width="-1.7pt">
   <mi mathvariant="normal">Ω</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega\!
  </annotation>
 </semantics>
</math>

 may be <a href="Partition_of_a_set" title="wikilink">partitioned</a> into disjoint subsets as follows:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Truth_function:105">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Ω</mi>
      <mn>0</mn>
     </msub>
     <mo>∪</mo>
     <msub>
      <mi mathvariant="normal">Ω</mi>
      <mn>1</mn>
     </msub>
     <mo>∪</mo>
     <mi mathvariant="normal">…</mi>
     <mo>∪</mo>
     <msub>
      <mi mathvariant="normal">Ω</mi>
      <mi>j</mi>
     </msub>
     <mo>∪</mo>
     <mi mathvariant="normal">…</mi>
     <mo>∪</mo>
     <mpadded width="+1.7pt">
      <msub>
       <mi mathvariant="normal">Ω</mi>
       <mi>m</mi>
      </msub>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ω</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\Omega_{0}\cup\Omega_{1}\cup\ldots\cup\Omega_{j}\cup\ldots\cup\Omega_{m%
}\,.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>In this partition, 

<math display="inline" id="Truth_function:106">
 <semantics>
  <mpadded width="-1.7pt">
   <msub>
    <mi mathvariant="normal">Ω</mi>
    <mi>j</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Ω</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{j}\!
  </annotation>
 </semantics>
</math>

 is the set of operator symbols of <em><a class="uri" href="arity" title="wikilink">arity</a></em> 

<math display="inline" id="Truth_function:107">
 <semantics>
  <mpadded width="-1.7pt">
   <mi>j</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\!
  </annotation>
 </semantics>
</math>

.</p>

<p>In the more familiar propositional calculi, 

<math display="inline" id="Truth_function:108">
 <semantics>
  <mpadded width="-1.7pt">
   <mi mathvariant="normal">Ω</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega\!
  </annotation>
 </semantics>
</math>


 is typically partitioned as follows:</p>
<dl>
<dd><dl>
<dd>nullary operators

<math display="block" id="Truth_function:109">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Ω</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo>⊥</mo>
    <mo>,</mo>
    <mo>⊤</mo>
    <mo rspace="4.2pt" stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <cn type="integer">0</cn>
    </apply>
    <set>
     <csymbol cd="latexml">bottom</csymbol>
     <csymbol cd="latexml">top</csymbol>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{0}=\{\bot,\top\}\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>unary operators

<math display="block" id="Truth_function:110">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Ω</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi mathvariant="normal">¬</mi>
    <mo rspace="4.2pt" stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <cn type="integer">1</cn>
    </apply>
    <set>
     <not></not>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{1}=\{\lnot\}\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>binary operators

<math display="block" id="Truth_function:111">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Ω</mi>
    <mn>2</mn>
   </msub>
   <mo>⊆</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo>∧</mo>
    <mo>,</mo>
    <mo>∨</mo>
    <mo>,</mo>
    <mo>→</mo>
    <mo>,</mo>
    <mo>↔</mo>
    <mo rspace="4.2pt" stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <cn type="integer">2</cn>
    </apply>
    <set>
     <and></and>
     <or></or>
     <ci>normal-→</ci>
     <ci>normal-↔</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{2}\subseteq\{\land,\lor,\rightarrow,\leftrightarrow\}\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h2 id="principle-of-compositionality">Principle of compositionality</h2>

<p>Instead of using <a href="truth_table" title="wikilink">truth tables</a>, logical connective symbols can be interpreted by means of an interpretation function and a functionally complete set of <a href="truth-function" title="wikilink">truth-functions</a> (Gamut 1991), as detailed by the <a href="principle_of_compositionality" title="wikilink">principle of compositionality</a> of meaning. Let <em>I</em> be an interpretation function, let <em>Φ</em>, <em>Ψ</em> be any two sentences and let the truth function <em>f</em><sub>nand</sub> be defined as:</p>
<ul>
<li><em>f</em><sub>nand</sub>(T,T)=F; <em>f</em><sub>nand</sub>(T,F)=<em>f</em><sub>nand</sub>(F,T)=<em>f</em><sub>nand</sub>(F,F)=T</li>
</ul>

<p>Then, for convenience, <em>f</em><sub>not</sub>, <em>f</em><sub>or</sub> <em>f</em><sub>and</sub> and so on are defined by means of <em>f</em><sub>nand</sub>:</p>
<ul>
<li><em>f</em><sub>not</sub>(<em>x</em>)=<em>f</em><sub>nand</sub>(<em>x</em>,<em>x</em>)</li>
<li><em>f</em><sub>or</sub>(<em>x</em>,<em>y</em>)= <em>f</em><sub>nand</sub>(<em>f</em><sub>not</sub>(<em>x</em>), <em>f</em><sub>not</sub>(<em>y</em>))</li>
<li><em>f</em><sub>and</sub>(<em>x</em>,<em>y</em>)=<em>f</em><sub>not</sub>(<em>f</em><sub>nand</sub>(<em>x</em>,<em>y</em>))</li>
</ul>

<p>or, alternatively <em>f</em><sub>not</sub>, <em>f</em><sub>or</sub> <em>f</em><sub>and</sub> and so on are defined directly:</p>
<ul>
<li><em>f</em><sub>not</sub>(T)=F; <em>f</em><sub>not</sub>(F)=T;</li>
<li><em>f</em><sub>or</sub>(T,T)=<em>f</em><sub>or</sub>(T,F)=<em>f</em><sub>or</sub>(F,T)=T;<em>f</em><sub>or</sub>(F,F)=F</li>
<li><em>f</em><sub>and</sub>(T,T)=T; <em>f</em><sub>and</sub>(T,F)=<em>f</em><sub>and</sub>(F,T)=<em>f</em><sub>and</sub>(F,F)=F</li>
</ul>

<p>Then</p>
<ul>
<li><em>I</em>(~)=<em>I</em>()=<em>f</em><sub>not</sub></li>
<li><em>I</em>(&amp;)=<em>I</em>(^)=<em>I</em>()=<em>f</em><sub>and</sub></li>
<li><em>I</em>(<em>v</em>)=<em>I</em>()= <em>f</em><sub>or</sub></li>
<li><em>I</em>(~<em>Φ</em>)=<em>I</em>(<em>Φ</em>)=<em>I</em>()(<em>I</em>(<em>Φ</em>))=<em>f</em><sub>not</sub>(<em>I</em>(<em>Φ</em>))</li>
<li><em>I</em>(<em>Φ</em><em>Ψ</em>) = <em>I</em>()(<em>I</em>(<em>Φ</em>), <em>I</em>(<em>Ψ</em>))= <em>f</em><sub>and</sub>(<em>I</em>(<em>Φ</em>), <em>I</em>(<em>Ψ</em>))</li>
</ul>

<p>etc.</p>

<p>Thus if <em>S</em> is a sentence that is a string of symbols consisting of logical symbols <em>v</em><sub>1</sub>...<em>v</em><sub><em>n</em></sub> representing logical connectives, and non-logical symbols <em>c</em><sub>1</sub>...<em>c</em><sub><em>n</em></sub>, then if and only if <em>I</em>(<em>v</em><sub>1</sub>)...<em>I</em>(<em>v</em><sub><em>n</em></sub>) have been provided interpreting <em>v</em><sub>1</sub> to <em>v</em><sub><em>n</em></sub> by means of <em>f</em><sub>nand</sub> (or any other set of functional complete truth-functions) then the truth-value of I(s) is determined entirely by the truth-values of <em>c</em><sub>1</sub>...<em>c</em><sub><em>n</em></sub>, i.e. of <em>I</em>(<em>c</em><sub>1</sub>)...<em>I</em>(<em>c</em><sub><em>n</em></sub>). In other words, as expected and required, <em>S</em> is true or false only under an interpretation of all its non-logical symbols.</p>
<h2 id="computer-science">Computer science</h2>

<p>Logical operators are implemented as <a href="logic_gate" title="wikilink">logic gates</a> in <a href="digital_circuit" title="wikilink">digital circuits</a>. Practically all digital circuits (the major exception is <a class="uri" href="DRAM" title="wikilink">DRAM</a>) are built up from <a href="logical_nand" title="wikilink">NAND</a>, <a href="logical_nor" title="wikilink">NOR</a>, <a href="negation" title="wikilink">NOT</a>, and <a href="logic_gate" title="wikilink">transmission gates</a>. NAND and NOR gates with 3 or more inputs rather than the usual 2 inputs are fairly common, although they are logically equivalent to a cascade of 2-input gates. All other operators are implemented by breaking them down into a logically equivalent combination of 2 or more of the above logic gates.</p>

<p>The "logical equivalence" of "NAND alone", "NOR alone", and "NOT and AND" is similar to <a href="Turing_equivalence_(theory_of_computation)" title="wikilink">Turing equivalence</a>.</p>

<p>That fact that all truth functions can be expressed with NOR alone is demonstrated by the <a href="Apollo_guidance_computer" title="wikilink">Apollo guidance computer</a>.</p>
<h2 id="notes">Notes</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bertrand_Russell" title="wikilink">Bertrand Russell</a> and <a href="Alfred_North_Whitehead" title="wikilink">Alfred North Whitehead</a>,<br/>
<em><a href="Principia_Mathematica" title="wikilink">Principia Mathematica</a></em>, 2nd edition.</li>
<li><a href="Ludwig_Wittgenstein" title="wikilink">Ludwig Wittgenstein</a>,<br/>
<em><a href="Tractatus_Logico-Philosophicus" title="wikilink">Tractatus Logico-Philosophicus</a></em>, Proposition 5.101.</li>
<li><a href="Bitwise_operation" title="wikilink">Bitwise operation</a></li>
<li><a href="Binary_function" title="wikilink">Binary function</a></li>
<li><a href="Boolean_domain" title="wikilink">Boolean domain</a></li>
<li><a href="Boolean_function" title="wikilink">Boolean function</a></li>
<li><a href="Boolean_logic" title="wikilink">Boolean logic</a></li>
<li><a href="Boolean-valued_function" title="wikilink">Boolean-valued function</a></li>
</ul>
<ul>
<li><a href="List_of_Boolean_algebra_topics" title="wikilink">List of Boolean algebra topics</a></li>
<li><a href="Logical_connective" title="wikilink">Logical connective</a></li>
<li><a href="Logical_constant" title="wikilink">Logical constant</a></li>
<li><a href="Modal_operator" title="wikilink">Modal operator</a></li>
<li><a href="Propositional_calculus" title="wikilink">Propositional calculus</a></li>
<li><a href="Truth-functional_propositional_logic" title="wikilink">Truth-functional propositional logic</a></li>
<li><a href="Truth_table" title="wikilink">Truth table</a></li>
<li><a href="Truth_value" title="wikilink">Truth values</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="Józef_Maria_Bocheński" title="wikilink">Józef Maria Bocheński</a> (1959), <em>A Précis of Mathematical Logic</em>, translated from the French and German versions by Otto Bird, Dordrecht, South Holland: D. Reidel.</li>
<li><a href="Alonzo_Church" title="wikilink">Alonzo Church</a> (1944), <em>Introduction to Mathematical Logic</em>, Princeton, NJ: Princeton University Press. See the Introduction for a history of the truth function concept.</li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_logic" title="wikilink">Category:Mathematical logic</a> <a href="Category:Truth" title="wikilink">Function</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Wernick, William (1942) "Complete Sets of Logical Functions," <em>Transactions of the American Mathematical Society 51</em>: 117–32. In his list on the last page of the article, Wernick does not distinguish between ← and →, or between 

<math display="inline" id="Truth_function:112">
 <semantics>
  <mo>↚</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftarrow
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Truth_function:113">
 <semantics>
  <mo>↛</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↛</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\rightarrow
  </annotation>
 </semantics>
</math>


.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
