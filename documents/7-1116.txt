   Initial algebra      Initial algebra   In mathematics , an initial algebra is an initial object in the category of F -algebras for a given endofunctor  F . The initiality provides a general framework for induction and recursion .  For instance, consider the endofunctor 1+(-) on the category of sets, where 1 is the one-point set, the terminal object in the category. An algebra for this endofunctor is a set X (called the carrier of the algebra) together with a point  and a function . The set of natural numbers is the carrier of the initial such algebra: the point is zero and the function is the successor map.  For a second example, consider the endofunctor 1+ N ×(-) on the category of sets, where N is the set of natural numbers. An algebra for this endofunctor is a set X together with a point  and a function . The set of finite lists of natural numbers is the initial such algebra. The point is the empty list, and the function is cons , taking a number and a finite list, and returning a new finite list with the number at the head.  Final coalgebra  Dually, a final coalgebra is a terminal object in the category of F -coalgebras . The finality provides a general framework for coinduction and corecursion .  For example, using the same functor 1+(-) as before, a coalgebra is a set   X   X   X   together with a truth-valued test function    p  :   X  →  2      normal-:  p   normal-→  X  2     p\colon X\to 2   and a partial function     f  :   X  →  X      normal-:  f   normal-→  X  X     f\colon X\to X   whose domain is formed by those    x  ∈  X      x  X    x\in X   for which     p   (  x  )    =  0        p  x   0    p(x)=0   . The set    ℕ  ∪   {  ω  }       ℕ   ω     \mathbb{N}\cup\{\omega\}   consisting of the natural numbers extended with a new element   ω   ω   \omega   is the carrier of the final coalgebra in the category, where   p   p   p   is the test for zero     p   (  0  )    =  1        p  0   1    p(0)=1   and     p   (   n  +  1   )    =   p   (  ω  )    =  0          p    n  1      p  ω        0     p(n+1)=p(\omega)=0   , and   f   f   f   is the predecessor function (the inverse of the successor function) on the positive naturals, but acts like the identity on the new element   ω   ω   \omega        f   (   n  +  1   )    =  n        f    n  1    n    f(n+1)=n   ,     f   (  ω  )    =  ω        f  ω   ω    f(\omega)=\omega   .  For a second example, consider the same functor    1  +   ℕ  ×   (  -  )        1    ℕ      1+\mathbb{N}\times(\mathord{-})   as before. In this case the carrier of the final coalgebra consists of all lists of natural numbers, finite as well as infinite . The operations are a test function testing whether a list is empty, and a deconstruction function defined on nonempty lists returning a pair consisting of the head and the tail of the input list.  Theorems   Initial algebras are minimal (i.e., have no proper subalgebra 1 )  Final coalgebras are simple (i.e., have no proper quotients 2 ). 3   Example  Consider the endofunctor    F  :   𝐒𝐞𝐭  →  𝐒𝐞𝐭      normal-:  F   normal-→  𝐒𝐞𝐭  𝐒𝐞𝐭     F:\mathbf{Set}\to\mathbf{Set}   sending   X   X   X   to    1  +  X      1  X    1+X   . Then the set   N   N   N   of natural numbers together with the functions     [  𝑧𝑒𝑟𝑜  ,  𝑠𝑢𝑐𝑐  ]   :    1  +  N   →  N      normal-:   𝑧𝑒𝑟𝑜  𝑠𝑢𝑐𝑐    normal-→    1  N   N     [\mathit{zero},\mathit{succ}]\colon 1+N\to N   , where    𝑧𝑒𝑟𝑜  :   1  →  N      normal-:  𝑧𝑒𝑟𝑜   normal-→  1  N     \mathit{zero}\colon 1\to N   and    𝑠𝑢𝑐𝑐  :   N  →  N      normal-:  𝑠𝑢𝑐𝑐   normal-→  N  N     \mathit{succ}\colon N\to N   are the obvious functions suggested by their names, is an initial   F   F   F   -algebra. The initiality (the universal property for this case) is not hard to establish; the unique homomorphism to an arbitrary   F   F   F   -algebra    (  A  ,   [  e  ,  f  ]   )     A   e  f     (A,[e,f])   , for    e  :   1  →  A      normal-:  e   normal-→  1  A     e\colon 1\to A   an element of   A   A   A   and    f  :   A  →  A      normal-:  f   normal-→  A  A     f\colon A\to A   a function on   A   A   A   , is the function sending the natural number   n   n   n   to     f  n    (  e  )        superscript  f  n   e    f^{n}(e)   , that is,    f   (   f   (   …   (   f   (  e  )    )   …   )    )       f    f    normal-…    f  e   normal-…      f(f(\dots(f(e))\dots))   , the   n   n   n   -fold application of   f   f   f   to   e   e   e   .  Use in Computer Science  Various finite data structures used in programming , such as lists and trees , can be obtained as initial algebras of specific endofunctors. While there may be several initial algebras for a given endofunctor, they are unique  up to  isomorphism , which informally means that the "observable" properties of a data structure can be adequately captured by defining it as an initial algebra.  To obtain the type     𝐿𝑖𝑠𝑡   (  A  )       𝐿𝑖𝑠𝑡  A    \mathit{List}(A)   of lists whose elements are members of set   A   A   A   , consider that the list-forming operations are:       𝑛𝑖𝑙  :   1  →   𝐿𝑖𝑠𝑡   (  A  )        normal-:  𝑛𝑖𝑙   normal-→  1    𝐿𝑖𝑠𝑡  A      \mathit{nil}\colon 1\to\mathit{List}(A)         𝑐𝑜𝑛𝑠  :     A  ×  𝐿𝑖𝑠𝑡    (  A  )    →   𝐿𝑖𝑠𝑡   (  A  )        normal-:  𝑐𝑜𝑛𝑠   normal-→      A  𝐿𝑖𝑠𝑡   A     𝐿𝑖𝑠𝑡  A      \mathit{cons}\colon A\times\mathit{List}(A)\to\mathit{List}(A)      Combined into one function, they give:        [  𝑛𝑖𝑙  ,  𝑐𝑜𝑛𝑠  ]   :    1  +   (    A  ×  𝐿𝑖𝑠𝑡    (  A  )    )    →   𝐿𝑖𝑠𝑡   (  A  )        normal-:   𝑛𝑖𝑙  𝑐𝑜𝑛𝑠    normal-→    1      A  𝐿𝑖𝑠𝑡   A      𝐿𝑖𝑠𝑡  A      [\mathit{nil},\mathit{cons}]\colon 1+(A\times\mathit{List}(A))\to\mathit{List}%
 (A)   ,   which makes this an   F   F   F   -algebra for the endofunctor   F   F   F   sending   X   X   X   to    1  +   (   A  ×  X   )       1    A  X     1+(A\times X)   . It is, in fact, the initial   F   F   F   -algebra. Initiality is established by the function known as foldr in functional  programming languages such as Haskell and ML .  Likewise, binary trees with elements at the leaves can be obtained as the initial algebra        [  𝑡𝑖𝑝  ,  𝑗𝑜𝑖𝑛  ]   :    A  +   (     𝑇𝑟𝑒𝑒   (  A  )    ×  𝑇𝑟𝑒𝑒    (  A  )    )    →   𝑇𝑟𝑒𝑒   (  A  )        normal-:   𝑡𝑖𝑝  𝑗𝑜𝑖𝑛    normal-→    A        𝑇𝑟𝑒𝑒  A   𝑇𝑟𝑒𝑒   A      𝑇𝑟𝑒𝑒  A      [\mathit{tip},\mathit{join}]\colon A+(\mathit{Tree}(A)\times\mathit{Tree}(A))%
 \to\mathit{Tree}(A)   .   Types obtained this way are known as algebraic data types .  Types defined by using least fixed point construct with functor   F   F   F   can be regarded as an initial F-algebra , provided that parametricity holds for the type. 4  In a dual way, similar relationship exists between notions of greatest fixed point and terminal F-coalgebra , with applications to coinductive types. These can be used for allowing potentially infinite objects while maintaining strong normalization property . 5 In the strongly normalizing Charity programming language (i.e. each program terminates), coinductive data types can be used achieving surprising results, e.g. defining lookup constructs to implement such “strong” functions like the Ackermann function . 6  See also   Algebraic data type  Catamorphism  Anamorphism   Notes    External links   Categorical programming with inductive and coinductive types by Varmo Vene  Philip Wadler: Recursive types for free! University of Glasgow, July 1998. Draft.  Initial Algebra and Final Coalgebra Semantics for Concurrency by J.J.M.M. Rutten and D. Turi  Initiality and finality from CLiki   "  Category:Category theory  Category:Functional programming  Category:Type theory      Induction and Co-induction from CLiki ↩  Initiality and finality from CLiki ↩  Philip Wadler: Recursive types for free! University of Glasgow, July 1998. Draft. ↩   Robin Cockett: Charitable Thoughts ( ps and ps.gz ) ↩     