<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="394">Commutator subspace</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Commutator subspace</h1>
<hr/>

<p>In mathematics, the <strong>commutator subspace</strong> of a two-sided <a href="ideal_(ring_theory)" title="wikilink">ideal</a> of <a href="linear_operators" title="wikilink">bounded linear operators</a> on a separable <a href="Hilbert_space" title="wikilink">Hilbert space</a> is the linear subspace spanned by <a href="commutator#Ring_theory" title="wikilink">commutators</a> of operators in the ideal with bounded operators. Modern characterisation of the commutator subspace is through the <a href="Calkin_correspondence" title="wikilink">Calkin correspondence</a> and it involves the invariance of the Calkin sequence space of an operator ideal to taking <a href="Cesàro_mean" title="wikilink">Cesàro means</a>. This explicit spectral characterisation reduces problems and questions about commutators and <a href="singular_trace" title="wikilink">traces</a> on two-sided ideals to (more resolvable) problems and conditions on sequence spaces.</p>
<h2 id="history">History</h2>

<p>Commutators of linear operators on Hilbert spaces came to prominence in the 1930s as they featured in the <a href="matrix_mechanics" title="wikilink">matrix mechanics</a>, or Heisenberg, formulation of quantum mechanics. Commutator subspaces, though, received sparse attention until the 1970s. American mathematician <a href="Paul_Halmos" title="wikilink">Paul Halmos</a> in 1954 showed that every bounded operator on a separable infinite dimensional Hilbert space is the sum of two commutators of bounded operators.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In 1971 Carl Pearcy and David Topping revisited the topic and studied commutator subspaces for <a href="Schatten_class_operator" title="wikilink">Schatten ideals</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> As a student American mathematician Gary Weiss began to investigate spectral conditions for commutators of <a href="Hilbert–Schmidt_operators" title="wikilink">Hilbert–Schmidt operators</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> British mathematician <a href="Nigel_Kalton" title="wikilink">Nigel Kalton</a>, noticing the spectral condition of Weiss, characterised all trace class commutators.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Kalton's result forms the basis for the modern characterisation of the commutator subspace. In 2004 Ken Dykema, Tadeusz Figiel, Gary Weiss and Mariusz Wodzicki published the spectral characterisation of normal operators in the commutator subspace for every two-sided ideal of compact operators.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="definition">Definition</h2>

<p>The commutator subspace of a two-sided ideal <em>J</em> of the bounded linear operators <em>B</em>(<em>H</em>) on a separable Hilbert space <em>H</em> is the linear span of operators in <em>J</em> of the form [<em>A</em>,<em>B</em>] = <em>AB</em> − <em>BA</em> for all operators <em>A</em> from <em>J</em> and <em>B</em> from <em>B</em>(<em>H</em>).</p>

<p>The commutator subspace of <em>J</em> is a linear subspace of <em>J</em> denoted by Com(<em>J</em>) or [<em>B</em>(<em>H</em>),<em>J</em>].</p>
<h2 id="spectral-characterisation">Spectral characterisation</h2>

<p>The <a href="Calkin_correspondence" title="wikilink">Calkin correspondence</a> states that a <a href="compact_operator" title="wikilink">compact operator</a> <em>A</em> belongs to a two-sided ideal <em>J</em> if and only if the <a href="singular_values" title="wikilink">singular values</a> μ(<em>A</em>) of <em>A</em> belongs to the Calkin sequence space <em>j</em> associated to <em>J</em>. <a href="Normal_operator" title="wikilink">Normal operators</a> that belong to the commutator subspace Com(<em>J</em>) can characterised as those <em>A</em> such that μ(<em>A</em>) belongs to <em>j</em> <em>and</em> the <a href="Cesàro_mean" title="wikilink">Cesàro mean</a> of the sequence μ(<em>A</em>) belongs to <em>j</em>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The following theorem is a slight extension to differences of normal operators<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> (setting <em>B</em> 

<math display="inline" id="Commutator_subspace:0">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 0 in the following gives the statement of the previous sentence).</p>
<dl>
<dd><strong>Theorem.</strong> Suppose <em>A,B</em> are compact normal operators that belong to a two-sided ideal <em>J</em>. Then <em>A</em> − <em>B</em> belongs to the commutator subspace Com(<em>J</em>) if and only if
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutator_subspace:1">
 <semantics>
  <mrow>
   <msubsup>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mi>n</mi>
       </mrow>
      </mfrac>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>k</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi>n</mi>
       </msubsup>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mi>μ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>k</mi>
           <mo>,</mo>
           <mi>A</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mi>μ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>k</mi>
           <mo>,</mo>
           <mi>B</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mo>∈</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <set>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
          <ci>n</ci>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>k</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <ci>n</ci>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>μ</ci>
           <interval closure="open">
            <ci>k</ci>
            <ci>A</ci>
           </interval>
          </apply>
          <apply>
           <times></times>
           <ci>μ</ci>
           <interval closure="open">
            <ci>k</ci>
            <ci>B</ci>
           </interval>
          </apply>
         </apply>
        </apply>
       </apply>
      </set>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\frac{1}{1+n}\sum_{k=0}^{n}\left(\mu(k,A)-\mu(k,B)\right)\right\}_{n=0}%
^{\infty}\in j
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
<dd>where <em>j</em> is the Calkin sequence space corresponding to <em>J</em> and μ(<em>A</em>), μ(<em>B</em>) are the singular values of <em>A</em> and <em>B</em>, respectively.
</dd>
</dl>

<p>Provided that the <a href="eigenvalue" title="wikilink">eigenvalue sequences</a> of all operators in <em>J</em> belong to the Calkin sequence space <em>j</em> there is a spectral characterisation for arbitrary (non-normal) operators. It is not valid for every two-sided ideal but necessary and sufficient conditions are known. Nigel Kalton and American mathematician Ken Dykema introduced the condition first for countably generated ideals.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Uzbek and Australian mathematicians Fedor Sukochev and Dmitriy Zanin completed the eigenvalue characterisation.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<dl>
<dd><strong>Theorem.</strong> Suppose <em>J</em> is a two-sided ideal such that a bounded operator <em>A</em> belongs to <em>J</em> whenever there is a bounded operator <em>B</em> in <em>J</em> such that
</dd>
</dl>
<dl>
<dd>If the bounded operator <em>A</em> and <em>B</em> belong to <em>J</em> then <em>A</em> − <em>B</em> belongs to the commutator subspace Com(<em>J</em>) if and only if
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutator_subspace:2">
 <semantics>
  <mrow>
   <msubsup>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mi>n</mi>
       </mrow>
      </mfrac>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>k</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi>n</mi>
       </msubsup>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mi>λ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>k</mi>
           <mo>,</mo>
           <mi>A</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mi>λ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>k</mi>
           <mo>,</mo>
           <mi>B</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mo>∈</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <set>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
          <ci>n</ci>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>k</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <ci>n</ci>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>λ</ci>
           <interval closure="open">
            <ci>k</ci>
            <ci>A</ci>
           </interval>
          </apply>
          <apply>
           <times></times>
           <ci>λ</ci>
           <interval closure="open">
            <ci>k</ci>
            <ci>B</ci>
           </interval>
          </apply>
         </apply>
        </apply>
       </apply>
      </set>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\frac{1}{1+n}\sum_{k=0}^{n}\left(\lambda(k,A)-\lambda(k,B)\right)\right%
\}_{n=0}^{\infty}\in j
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
<dd>where <em>j</em> is the Calkin sequence space corresponding to <em>J</em> and λ(<em>A</em>), λ(<em>B</em>) are the sequence of eigenvalues of the operators <em>A</em> and <em>B</em>, respectively, rearranged so that the absolute value of the eigenvalues is decreasing.
</dd>
</dl>

<p>Most two-sided ideals satisfy the condition in the Theorem, included all Banach ideals and quasi-Banach ideals.</p>
<h2 id="consequences-of-the-characterisation">Consequences of the characterisation</h2>
<ul>
<li>Every operator in <em>J</em> is a sum of commutators if and only if the corresponding Calkin sequence space <em>j</em> is invariant under taking <a href="Cesàro_mean" title="wikilink">Cesàro means</a>. In symbols, Com(<em>J</em>) 

<math display="inline" id="Commutator_subspace:3">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>


 <em>J</em> is equivalent to C(<em>j</em>) 

<math display="inline" id="Commutator_subspace:4">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 <em>j</em>, where C denotes the Cesàro operator on sequences.</li>
</ul>
<ul>
<li>In any two-sided ideal the difference between a positive operator and its diagonalisation is a sum of commutators. That is, <em>A</em> − diag(μ(<em>A</em>)) belongs to Com(<em>J</em>) for every positive operator <em>A</em> in <em>J</em> where diag(μ(<em>A</em>)) is the diagonalisation of <em>A</em> in an arbitrary orthonormal basis of the separable Hilbert space <em>H</em>.</li>
</ul>
<ul>
<li>In any two-sided ideal satisfying () the difference between an arbitrary operator and its diagonalisation is a sum of commutators. That is, <em>A</em> − diag(λ(<em>A</em>)) belongs to Com(<em>J</em>) for every operator <em>A</em> in <em>J</em> where diag(λ(<em>A</em>)) is the diagonalisation of <em>A</em> in an arbitrary orthonormal basis of the separable Hilbert space <em>H</em> and λ(<em>A</em>) is an eigenvalue sequence.</li>
</ul>
<ul>
<li>Every <a href="nilpotent_operator" title="wikilink">quasi-nilpotent operator</a> in a two-sided ideal satisfying () is a sum of commutators.</li>
</ul>
<h2 id="application-to-traces">Application to traces</h2>

<p>A trace φ on a two-sided ideal <em>J</em> of <em>B</em>(<em>H)</em> is a linear functional φ:<em>J</em> → ℂ that vanishes on Com(<em>J</em>). The consequences above imply</p>
<ul>
<li>The two-sided ideal <em>J</em> has a non-zero trace if and only if C(<em>j</em>) ≠ <em>j</em>.</li>
</ul>
<ul>
<li>φ(<em>A</em>) = φ∘diag(μ(<em>A</em>)) for every positive operator <em>A</em> in <em>J</em> where diag(μ(<em>A</em>)) is the diagonalisation of <em>A</em> in an arbitrary orthonormal basis of the separable Hilbert space <em>H</em>. That is, traces on <em>J</em> are in direct correspondence with <a href="symmetric_functional" title="wikilink">symmetric functionals</a> on <em>j</em>.</li>
</ul>
<ul>
<li>In any two-sided ideal satisfying (), φ(<em>A</em>) = φ∘diag(λ(<em>A</em>)) for every operator <em>A</em> in <em>J</em> where diag(λ(<em>A</em>)) is the diagonalisation of <em>A</em> in an arbitrary orthonormal basis of the separable Hilbert space <em>H</em> and λ(<em>A</em>) is an eigenvalue sequence.</li>
</ul>
<ul>
<li>In any two-sided ideal satisfying (), φ(<em>Q</em>)=0 for every <a href="nilpotent_operator" title="wikilink">quasi-nilpotent operator</a> <em>Q</em> from <em>J</em> and every trace φ on <em>J</em>.</li>
</ul>
<h2 id="examples">Examples</h2>

<p>Suppose <em>H</em> is a separable infinite dimensional Hilbert space.</p>
<ul>
<li><strong>Compact operators.</strong> The <a href="compact_operator_on_hilbert_space" title="wikilink">compact linear operators</a> <em>K</em>(<em>H</em>) correspond to the space of converging to zero sequences, <em>c</em><sub>0</sub>. For a converging to zero sequence the <a href="Cesàro_mean" title="wikilink">Cesàro means</a> converge to zero. Therefore C(<em>c</em><sub>0</sub>) = <em>c</em><sub>0</sub> and Com(<em>K</em>(<em>H</em>)) 

<math display="inline" id="Commutator_subspace:5">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 <em>K</em>(<em>H</em>).</li>
</ul>
<ul>
<li><strong>Finite rank operators.</strong> The <a href="finite-rank_operator" title="wikilink">finite rank operators</a> <em>F</em>(<em>H</em>) correspond to the space of sequences with finite non-zero terms, <em>c</em><sub>00</sub>. The condition</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutator_subspace:6">
 <semantics>
  <mrow>
   <msubsup>
    <mrow>
     <mo>{</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>a</mi>
        <mn>2</mn>
       </msub>
       <mo>+</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>+</mo>
       <msub>
        <mi>a</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mi>n</mi>
     </mfrac>
     <mo>}</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mo>∈</mo>
   <msub>
    <mi>c</mi>
    <mn>00</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <set>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>normal-⋯</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
      </set>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">00</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\frac{a_{1}+a_{2}+\cdots+a_{n}}{n}\right\}_{n=1}^{\infty}\in c_{00}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>occurs if and only if
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutator_subspace:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msub>
     <mi>a</mi>
     <mi>N</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}+a_{2}+\cdots+a_{N}=0
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
<dd>for the sequence (a<sub>1</sub>, a<sub>2</sub>, ... , a<sub>N</sub>, 0, 0 , ...) in <em>c</em><sub>00</sub>. The kernel of the <a href="trace_class#Definition" title="wikilink">operator trace</a> Tr on <em>F</em>(<em>H</em>) and the commutator subspace of the finite rank operators are equal, ker Tr 

<math display="inline" id="Commutator_subspace:8">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>


 Com(<em>F</em>(<em>H</em>)) ⊊ <em>F</em>(<em>H</em>).
</dd>
</dl>
<ul>
<li><strong>Trace class operators.</strong> The <a href="trace_class_operator" title="wikilink">trace class operators</a> <em>L</em><sub>1</sub> correspond to the <a href="sequence_space" title="wikilink">summable sequences</a>. The condition</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutator_subspace:9">
 <semantics>
  <mrow>
   <msubsup>
    <mrow>
     <mo>{</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>a</mi>
        <mn>2</mn>
       </msub>
       <mo>+</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>+</mo>
       <msub>
        <mi>a</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mi>n</mi>
     </mfrac>
     <mo>}</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mo>∈</mo>
   <msub>
    <mi mathvariant="normal">ℓ</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <set>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>normal-⋯</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
      </set>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-ℓ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\frac{a_{1}+a_{2}+\cdots+a_{n}}{n}\right\}_{n=1}^{\infty}\in\ell_{1}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>is stronger than the condition that a<sub>1</sub> + a<sub>2</sub> ... = 0. An example is the sequence with
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutator_subspace:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi>n</mi>
      <mrow>
       <msup>
        <mi>log</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>2.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="float">2.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{n}=\frac{1}{n\log^{2}(n)},\quad n\geq 2.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
<dd>and
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutator_subspace:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>2</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}=-\sum_{n=2}^{\infty}a_{n}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p>which has sum zero but does not have a summable sequence of Cesàro means. Hence Com(<em>L</em><sub>1</sub>) ⊊ ker Tr ⊊ <em>L</em><sub>1</sub>.</p>
<ul>
<li><strong>Weak trace class operators</strong>. The <a href="weak_trace-class_operator" title="wikilink">weak trace class operators</a> <em>L</em><sub>1,∞</sub> correspond to the <a href="Lp_space" title="wikilink">weak-<em>l</em><sub>1</sub> sequence space</a>. From the condition</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutator_subspace:12">
 <semantics>
  <mrow>
   <msubsup>
    <mrow>
     <mo>{</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>a</mi>
        <mn>2</mn>
       </msub>
       <mo>+</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>+</mo>
       <msub>
        <mi>a</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mi>n</mi>
     </mfrac>
     <mo>}</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mo>∈</mo>
   <msub>
    <mi mathvariant="normal">ℓ</mi>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <set>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>normal-⋯</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
      </set>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-ℓ</ci>
     <list>
      <cn type="integer">1</cn>
      <infinity></infinity>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\frac{a_{1}+a_{2}+\cdots+a_{n}}{n}\right\}_{n=1}^{\infty}\in\ell_{1,\infty}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>or equivalently
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutator_subspace:13">
 <semantics>
  <mrow>
   <msubsup>
    <mrow>
     <mo>{</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>a</mi>
       <mn>2</mn>
      </msub>
      <mo>+</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>+</mo>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>}</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <set>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-⋯</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </set>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{a_{1}+a_{2}+\cdots+a_{n}\right\}_{n=1}^{\infty}=O(1)
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p>it is immediate that Com(<em>L</em><sub><em>1</em>,∞</sub>)<sub>+</sub> 

<math display="inline" id="Commutator_subspace:14">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

 (<em>L</em><sub>1</sub>)<sub>+</sub>. The commutator subspace of the weak trace class operators contains the trace class operators. The <a href="harmonic_series_(mathematics)" title="wikilink">harmonic sequence</a> 1,1/2,1/3,...,1/n,... belongs to <em>l</em><sub>1,∞</sub> and it is has a divergent series, and therefore the Cesàro means of the harmonic sequence do not belong to <em>l</em><sub>1,∞</sub>. In summary, <em>L</em><sub>1</sub> ⊊ Com(<em>L</em><sub>1,∞</sub>) ⊊ <em>L</em><sub>1,∞</sub>.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Traces" title="wikilink">Category:Traces</a> <a href="Category:Hilbert_space" title="wikilink">Category:Hilbert space</a> <a href="Category:Von_Neumann_algebras" title="wikilink">Category:Von Neumann algebras</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
