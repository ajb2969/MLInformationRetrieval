<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1939">Belief revision</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Belief revision</h1>
<hr/>

<p><strong>Belief revision</strong> is the process of changing beliefs to take into account a new piece of information. The <a href="formal_logic" title="wikilink">logical</a> formalization of belief revision is researched in <a class="uri" href="philosophy" title="wikilink">philosophy</a>, in <a class="uri" href="databases" title="wikilink">databases</a>, and in artificial intelligence for the design of <a href="intelligent_agent" title="wikilink">rational agents</a>.</p>

<p>What makes belief revision non-trivial is that several different ways for performing this operation may be possible. For example, if the current knowledge includes the three facts "

<math display="inline" id="Belief_revision:0">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is true", "

<math display="inline" id="Belief_revision:1">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is true" and "if 

<math display="inline" id="Belief_revision:2">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:3">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 are true then 

<math display="inline" id="Belief_revision:4">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is true", the introduction of the new information "

<math display="inline" id="Belief_revision:5">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is false" can be done preserving consistency only by removing at least one of the three facts. In this case, there are at least three different ways for performing revision. In general, there may be several different ways for changing knowledge.</p>
<h2 id="revision-and-update">Revision and update</h2>

<p>Two kinds of changes are usually distinguished:</p>
<dl>
<dt>update : the new information is about the situation at present, while the old beliefs refer to the past; update is the operation of changing the old beliefs to take into account the change;</dt>
</dl>
<dl>
<dt>revision : both the old beliefs and the new information refer to the same situation; an inconsistency between the new and old information is explained by the possibility of old information being less reliable than the new one; revision is the process of inserting the new information into the set of old beliefs without generating an inconsistency.</dt>
</dl>

<p>The main assumption of belief revision is that of minimal change: the knowledge before and after the change should be as similar as possible. In the case of update, this principle formalizes the assumption of inertia. In the case of revision, this principle enforces as much information as possible to be preserved by the change.</p>
<h3 id="example">Example</h3>

<p>The following classical example shows that the operations to perform in the two settings of update and revision are not the same. The example is based on two different interpretations of the set of beliefs 

<math display="inline" id="Belief_revision:6">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mi>b</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <or></or>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a\vee b\}
  </annotation>
 </semantics>
</math>

 and the new piece of information 

<math display="inline" id="Belief_revision:7">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a
  </annotation>
 </semantics>
</math>

:</p>
<dl>
<dt>update : in this scenario, two satellites, Unit A and Unit B, orbit around Mars; the satellites are programmed to land while transmitting their status to Earth; Earth has received a transmission from one of the satellites, communicating that it is still in orbit; however, due to interference, it is not known which satellite sent the signal; subsequently, Earth receives the communication that Unit A has landed; this scenario can be modeled in the following way; two <a href="propositional_variable" title="wikilink">propositional variables</a> 

<math display="inline" id="Belief_revision:8">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:9">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 indicate that Unit A and Unit B, respectively, are still in orbit; the initial set of beliefs is 

<math display="inline" id="Belief_revision:10">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mi>b</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <or></or>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a\vee b\}
  </annotation>
 </semantics>
</math>

 (either one of the two satellites is still in orbit) and the new piece of information is 

<math display="inline" id="Belief_revision:11">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a
  </annotation>
 </semantics>
</math>

 (Unit A has landed, and is therefore not in orbit); the only rational result of the update is 

<math display="inline" id="Belief_revision:12">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a
  </annotation>
 </semantics>
</math>

; since the initial information that one of the two satellites had not landed yet was possibly coming from the Unit A, the position of the Unit B is not known;</dt>
</dl>
<dl>
<dt>revision : the play "Six Characters in Search of an Author" will be performed in one of the two local theatres; this information can be denoted by 

<math display="inline" id="Belief_revision:13">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mi>b</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <or></or>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a\vee b\}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Belief_revision:14">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:15">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 indicates that the play will be performed at the first or at the second theatre, respectively; a further information that "Jesus Christ Superstar" will be performed at the first theatre indicates that 

<math display="inline" id="Belief_revision:16">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a
  </annotation>
 </semantics>
</math>

 holds; in this case, the obvious conclusion is that "Six Characters in Search of an Author" will be performed at the second but not the first theatre, which is represented in logic by 

<math display="inline" id="Belief_revision:17">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
   </mrow>
   <mo>∧</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a\wedge b
  </annotation>
 </semantics>
</math>

.</dt>
</dl>

<p>This example shows that revising the belief 

<math display="inline" id="Belief_revision:18">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∨</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\vee b
  </annotation>
 </semantics>
</math>

 with the new information 

<math display="inline" id="Belief_revision:19">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a
  </annotation>
 </semantics>
</math>

 produces two different results 

<math display="inline" id="Belief_revision:20">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:21">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
   </mrow>
   <mo>∧</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a\wedge b
  </annotation>
 </semantics>
</math>

 depending on whether the setting is that of update or revision.</p>
<h2 id="contraction-expansion-revision-consolidation-and-merging">Contraction, expansion, revision, consolidation, and merging</h2>

<p>In the setting in which all beliefs refer to the same situation, a distinction between various operations that can be performed is made:</p>
<dl>
<dt>contraction : removal of a belief;</dt>
</dl>
<dl>
<dt>expansion : addition of a belief without checking consistency;</dt>
</dl>
<dl>
<dt>revision : addition of a belief while maintaining consistency;</dt>
</dl>
<dl>
<dt>consolidation : restoring consistency of a set of beliefs;</dt>
</dl>
<dl>
<dt>merging : fusion of two or more sets of beliefs while maintaining consistency.</dt>
</dl>

<p>Revision and merging differ in that the first operation is done when the new belief to incorporate is considered more reliable than the old ones; therefore, consistency is maintained by removing some of the old beliefs. Merging is a more general operation, in that the priority among the belief sets may or may not be the same.</p>

<p>Revision can be performed by first incorporating the new fact and then restoring consistency via consolidation. This is actually a form of merging rather than revision, as the new information is not always treated as more reliable than the old knowledge.</p>
<h2 id="the-agm-postulates">The AGM postulates</h2>

<p>The AGM postulates (named after the names of their proponents, <a href="Carlos_Alchourrón" title="wikilink">Alchourrón</a>, <a href="Peter_Gärdenfors" title="wikilink">Gärdenfors</a>, and <a href="David_Makinson" title="wikilink">Makinson</a>) are properties that an operator that performs revision should satisfy in order for that operator to be considered rational. The considered setting is that of revision, that is, different pieces of information referring to the same situation. Three operations are considered: expansion (addition of a belief without a consistency check), revision (addition of a belief while maintaining consistency), and contraction (removal of a belief).</p>

<p>The first six postulates are called "the basic AGM postulates". In the settings considered by Alchourrón, Gärdenfors, and Makinson, the current set of beliefs is represented by a <a href="Deductive_closure" title="wikilink">deductively closed</a> set of logical formulae 

<math display="inline" id="Belief_revision:22">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 called belief base, the new piece of information is a logical formula 

<math display="inline" id="Belief_revision:23">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, and revision is performed by a binary operator 

<math display="inline" id="Belief_revision:24">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

 that takes as its operands the current beliefs and the new information and produces as a result a belief base representing the result of the revision. The 

<math display="inline" id="Belief_revision:25">
 <semantics>
  <mo>+</mo>
  <annotation-xml encoding="MathML-Content">
   <plus></plus>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +
  </annotation>
 </semantics>
</math>

 operator denoted expansion

<math display="block" id="Belief_revision:26">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>+</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K+P
  </annotation>
 </semantics>
</math>

 is the deductive closure of 

<math display="inline" id="Belief_revision:27">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>P</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>K</ci>
    <set>
     <ci>P</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\cup\{P\}
  </annotation>
 </semantics>
</math>

. The AGM postulates for revision are:</p>
<ol>
<li>

<math display="inline" id="Belief_revision:28">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>*</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P
  </annotation>
 </semantics>
</math>

 is a belief base (i.e., a deductively closed set of formulae);</li>
<li>

<math display="inline" id="Belief_revision:29">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∈</mo>
   <mrow>
    <mi>K</mi>
    <mo>*</mo>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\in K*P
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Belief_revision:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mo>*</mo>
    <mi>P</mi>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <mi>K</mi>
    <mo>+</mo>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>K</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P\subseteq K+P
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Belief_revision:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>If</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>P</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∉</mo>
    <mi>K</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mtext>then</mtext>
      <mi>K</mi>
     </mrow>
     <mo>*</mo>
     <mi>P</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>K</mi>
     <mo>+</mo>
     <mi>P</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <notin></notin>
     <apply>
      <times></times>
      <mtext>If</mtext>
      <apply>
       <times></times>
       <not></not>
       <ci>P</ci>
      </apply>
     </apply>
     <ci>K</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <mtext>then</mtext>
       <ci>K</ci>
      </apply>
      <ci>P</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>K</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{If }(\neg P)\not\in K,\text{ then }K*P=K+P
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Belief_revision:32">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>*</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P
  </annotation>
 </semantics>
</math>

 is <a class="uri" href="inconsistent" title="wikilink">inconsistent</a> only if 

<math display="inline" id="Belief_revision:33">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is inconsistent or 

<math display="inline" id="Belief_revision:34">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is inconsistent</li>
<li>

<math display="inline" id="Belief_revision:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>If</mtext>
     <mi>P</mi>
     <mtext>and</mtext>
     <mi>Q</mi>
     <mtext>are logically equivalent, then</mtext>
     <mi>K</mi>
    </mrow>
    <mo>*</mo>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>K</mi>
    <mo>*</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <mtext>If</mtext>
      <ci>P</ci>
      <mtext>and</mtext>
      <ci>Q</ci>
      <mtext>are logically equivalent, then</mtext>
      <ci>K</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{If }P\text{ and }Q\text{ are logically equivalent, then }K*P=K*Q
  </annotation>
 </semantics>
</math>

 (see <a href="logical_equivalence" title="wikilink">logical equivalence</a>)</li>
<li>

<math display="inline" id="Belief_revision:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mo>∧</mo>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>K</mi>
      <mo>*</mo>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <and></and>
      <ci>P</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>P</ci>
     </apply>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*(P\wedge Q)\subseteq(K*P)+Q
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Belief_revision:37">
 <semantics>
  <mrow>
   <mrow>
    <mtext>If</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∉</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>K</mi>
      <mo>*</mo>
      <mi>P</mi>
     </mrow>
     <mtext>then</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>K</mi>
       <mo>*</mo>
       <mi>P</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>Q</mi>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <mi>K</mi>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mo>∧</mo>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <notin></notin>
     <apply>
      <times></times>
      <mtext>If</mtext>
      <apply>
       <times></times>
       <not></not>
       <ci>Q</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>K</ci>
        <ci>P</ci>
       </apply>
       <mtext>then</mtext>
       <apply>
        <times></times>
        <ci>K</ci>
        <ci>P</ci>
       </apply>
      </apply>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>K</ci>
      <apply>
       <and></and>
       <ci>P</ci>
       <ci>Q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{If }(\neg Q)\not\in K*P\text{ then }(K*P)+Q\subseteq K*(P\wedge Q)
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>A revision operator that satisfies all eight postulates is the full meet revision, in which 

<math display="inline" id="Belief_revision:38">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>*</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P
  </annotation>
 </semantics>
</math>

 is equal to 

<math display="inline" id="Belief_revision:39">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>+</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K+P
  </annotation>
 </semantics>
</math>

 if consistent, and to the deductive closure of 

<math display="inline" id="Belief_revision:40">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 otherwise. While satisfying all AGM postulates, this revision operator has been considered to be too conservative, in that no information from the old knowledge base is maintained if the revising formula is inconsistent with it.</p>
<h2 id="conditions-equivalent-to-the-agm-postulates">Conditions equivalent to the AGM postulates</h2>

<p>The AGM postulates are equivalent to several different conditions on the revision operator; in particular, they are equivalent to the revision operator being definable in terms of structures known as selection functions, epistemic entrenchments, systems of spheres, and preference relations. The latter are <a href="reflexive_relation" title="wikilink">reflexive</a>, <a href="transitive_relation" title="wikilink">transitive</a>, and <a href="total_relation" title="wikilink">total relations</a> over the set of models.</p>

<p>Each revision operator 

<math display="inline" id="Belief_revision:41">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

 satisfying the AGM postulates is associated to a set of preference relations 

<math display="inline" id="Belief_revision:42">
 <semantics>
  <msub>
   <mo>≤</mo>
   <mi>K</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <leq></leq>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq_{K}
  </annotation>
 </semantics>
</math>

, one for each possible belief base 

<math display="inline" id="Belief_revision:43">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

, such that the models of 

<math display="inline" id="Belief_revision:44">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 are exactly the minimal of all models according to 

<math display="inline" id="Belief_revision:45">
 <semantics>
  <msub>
   <mo>≤</mo>
   <mi>K</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <leq></leq>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq_{K}
  </annotation>
 </semantics>
</math>

. The revision operator and its associated family of orderings are related by the fact that 

<math display="inline" id="Belief_revision:46">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>*</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P
  </annotation>
 </semantics>
</math>

 is the set of formulae whose set of models contains all the minimal models of 

<math display="inline" id="Belief_revision:47">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 according to 

<math display="inline" id="Belief_revision:48">
 <semantics>
  <msub>
   <mo>≤</mo>
   <mi>K</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <leq></leq>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq_{K}
  </annotation>
 </semantics>
</math>

. This condition is equivalent to the set of models of 

<math display="inline" id="Belief_revision:49">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>*</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P
  </annotation>
 </semantics>
</math>

 being exactly the set of the minimal models of 

<math display="inline" id="Belief_revision:50">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 according to the ordering 

<math display="inline" id="Belief_revision:51">
 <semantics>
  <msub>
   <mo>≤</mo>
   <mi>K</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <leq></leq>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq_{K}
  </annotation>
 </semantics>
</math>

.</p>

<p>A preference ordering 

<math display="inline" id="Belief_revision:52">
 <semantics>
  <msub>
   <mo>≤</mo>
   <mi>K</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <leq></leq>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq_{K}
  </annotation>
 </semantics>
</math>

 represents an order of implausibility among all situations, including those that are conceivable but yet currently considered false. The minimal models according to such an ordering are exactly the models of the knowledge base, which are the models that are currently considered the most likely. All other models are greater than these ones, and are indeed considered less plausible. In general, 

<math display="inline" id="Belief_revision:53">
 <semantics>
  <mrow>
   <mi>I</mi>
   <msub>
    <mo><</mo>
    <mi>K</mi>
   </msub>
   <mi>J</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <lt></lt>
     <ci>K</ci>
    </apply>
    <ci>I</ci>
    <ci>J</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I<_{K}J
  </annotation>
 </semantics>
</math>

 indicates that the situation represented by the model 

<math display="inline" id="Belief_revision:54">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 is believed to be more plausible than the situation represented by 

<math display="inline" id="Belief_revision:55">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

. As a result, revising by a formula having 

<math display="inline" id="Belief_revision:56">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:57">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

 as models should select only 

<math display="inline" id="Belief_revision:58">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 to be a model of the revised knowledge base, as this model represent the most likely scenario among those supported by 

<math display="inline" id="Belief_revision:59">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="contraction">Contraction</h2>

<p>Contraction is the operation of removing a belief 

<math display="inline" id="Belief_revision:60">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 from a knowledge base 

<math display="inline" id="Belief_revision:61">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

; the result of this operation is denoted by 

<math display="inline" id="Belief_revision:62">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>-</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K-P
  </annotation>
 </semantics>
</math>

. The operators of revision and contractions are related by the Levi and Harper identities:</p>

<p>

<math display="block" id="Belief_revision:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mo>*</mo>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>K</mi>
      <mo>-</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>P</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>K</ci>
      <apply>
       <times></times>
       <not></not>
       <ci>P</ci>
      </apply>
     </apply>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P=(K-\neg P)+P
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Belief_revision:64">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mo>-</mo>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>K</mi>
    <mo>∩</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>K</mi>
       <mo>*</mo>
       <mi mathvariant="normal">¬</mi>
      </mrow>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>K</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <intersect></intersect>
     <ci>K</ci>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>K</ci>
       <not></not>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K-P=K\cap(K*\neg P)
  </annotation>
 </semantics>
</math>

</p>

<p>Eight postulates have been defined for contraction. Whenever a revision operator satisfies the eight postulates for revision, its corresponding contraction operator satisfies the eight postulates for contraction, and vice versa. If a contraction operator satisfies at least the first six postulates for contraction, translating it into a revision operator and then back into a contraction operator using the two identities above leads to the original contraction operator. The same holds starting from a revision operator.</p>

<p>One of the postulates for contraction has been longly discussed: the recovery postulate:</p>

<p>

<math display="block" id="Belief_revision:65">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>K</mi>
      <mo>-</mo>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>K</ci>
      <ci>P</ci>
     </apply>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=(K-P)+P
  </annotation>
 </semantics>
</math>

</p>

<p>According to this postulate, the removal of a belief 

<math display="inline" id="Belief_revision:66">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 followed by the reintroduction of the same belief in the belief base should lead to the original belief base. There are some examples showing that such behavior is not always reasonable: in particular, the contraction by a general condition such as 

<math display="inline" id="Belief_revision:67">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∨</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\vee b
  </annotation>
 </semantics>
</math>

 leads to the removal of more specific conditions such as 

<math display="inline" id="Belief_revision:68">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 from the belief base; it is then unclear why the reintroduction of 

<math display="inline" id="Belief_revision:69">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∨</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\vee b
  </annotation>
 </semantics>
</math>

 should also lead to the reintroduction of the more specific condition 

<math display="inline" id="Belief_revision:70">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

. For example, if George was previously believed to have German citizenship, it was also believed to be European. Contracting this latter belief amounts to stop believing that George is European; therefore, that George has German citizenship is also retracted from the belief base. If George is later discovered to have Austrian citizenship, then the fact that he is European is also reintroduced. According to the recovery postulate, however, the belief that he also has German citizenship should also be reintroduced.</p>

<p>The correspondence between revision and contraction induced by the Levi and Harper identities is such that a contraction not satisfying the recovery postulate is translated into a revision satisfying all eight postulates, and that a revision satisfying all eight postulates is translated into a contraction satisfying all eight postulates, including recovery. As a result, if recovery is excluded from consideration, a number of contraction operators are translated into a single revision operator, which can be then translated back into exactly one contraction operator. This operator is the only one of the initial group of contraction operators that satisfies recovery; among this group, it is the operator that preserves as much information as possible.</p>
<h2 id="the-ramsey-test">The Ramsey test</h2>

<p>The evaluation of a <a href="counterfactual_conditional" title="wikilink">counterfactual conditional</a> 

<math display="inline" id="Belief_revision:71">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>></mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a>b
  </annotation>
 </semantics>
</math>

 can be done, according to the <strong>Ramsey test</strong> (named for <a href="Frank_P._Ramsey" title="wikilink">Frank P. Ramsey</a>), to the hypothetical addition of 

<math display="inline" id="Belief_revision:72">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 to the set of current beliefs followed by a check for the truth of 

<math display="inline" id="Belief_revision:73">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Belief_revision:74">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is the set of beliefs currently held, the Ramsey test is formalized by the following correspondence:</p>

<p>

<math display="block" id="Belief_revision:75">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>></mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a>b
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Belief_revision:76">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>∈</mo>
   <mrow>
    <mi>K</mi>
    <mo>*</mo>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>b</ci>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\in K*a
  </annotation>
 </semantics>
</math>

</p>

<p>If the considered language of the formulae representing beliefs is propositional, the Ramsey test gives a consistent definition for counterfactual conditionals in terms of a belief revision operator. However, if the language of formulae representing beliefs itself includes the counterfactual conditional connective 

<math display="inline" id="Belief_revision:77">
 <semantics>
  <mo>></mo>
  <annotation-xml encoding="MathML-Content">
   <gt></gt>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   >
  </annotation>
 </semantics>
</math>

, the Ramsey test leads to the Gardenfors triviality result: there is no non-trivial revision operator that satisfies both the AGM postulates for revision and the condition of the Ramsey test. This result holds in the assumption that counterfactual formulae like 

<math display="inline" id="Belief_revision:78">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>></mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a>b
  </annotation>
 </semantics>
</math>

 can be present in belief bases and revising formulae. Several solutions to this problem have been proposed.</p>
<h2 id="non-monotonic-inference-relation">Non-monotonic inference relation</h2>

<p>Given a fixed knowledge base 

<math display="inline" id="Belief_revision:79">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 and a revision operator 

<math display="inline" id="Belief_revision:80">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

, one can define a non-monotonic inference relation using the following definition

<math display="block" id="Belief_revision:81">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>⊢</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\vdash Q
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Belief_revision:82">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mo>*</mo>
    <mi>P</mi>
   </mrow>
   <mo>⊧</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>P</ci>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P\models Q
  </annotation>
 </semantics>
</math>

. In other words, a formula 

<math display="inline" id="Belief_revision:83">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 <a href="logical_consequence" title="wikilink">entails</a> another formula 

<math display="inline" id="Belief_revision:84">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 if the addition of the first formula to the current knowledge base leads to the derivation of 

<math display="inline" id="Belief_revision:85">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

. This inference relation is non-monotonic.</p>

<p>The AGM postulates can be translated into a set of postulates for this inference relation. Each of these postulates is entailed by some previously considered set of postulates for non-monotonic inference relations. Vice versa, conditions that have been considered for non-monotonic inference relations can be translated into postulates for a revision operator. All these postulates are entailed by the AGM postulates.</p>
<h2 id="foundational-revision">Foundational revision</h2>

<p>In the AGM framework, a belief set is represented by a deductively closed set of <a href="propositional_formula" title="wikilink">propositional formulae</a>. While such sets are infinite, they can always be finitely representable. However, working with deductively closed sets of formulae leads to the implicit assumption that equivalent belief bases should be considered equal when revising. This is called the <em>principle of irrelevance of syntax</em>.</p>

<p>This principle has been and is currently debated: while 

<math display="inline" id="Belief_revision:86">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>a</ci>
    <ci>b</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,b\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:87">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>a</mi>
    <mo>∧</mo>
    <mi>b</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <and></and>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a\wedge b\}
  </annotation>
 </semantics>
</math>

 are two equivalent sets, revising by 

<math display="inline" id="Belief_revision:88">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a
  </annotation>
 </semantics>
</math>

 should produce different results. In the first case, 

<math display="inline" id="Belief_revision:89">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:90">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 are two separate beliefs; therefore, revising by 

<math display="inline" id="Belief_revision:91">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a
  </annotation>
 </semantics>
</math>

 should not produce any effect on 

<math display="inline" id="Belief_revision:92">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, and the result of revision is 

<math display="inline" id="Belief_revision:93">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
   </mrow>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
    <ci>b</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\neg a,b\}
  </annotation>
 </semantics>
</math>

. In the second case, 

<math display="inline" id="Belief_revision:94">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∧</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\wedge b
  </annotation>
 </semantics>
</math>

 is taken a single belief. The fact that 

<math display="inline" id="Belief_revision:95">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is false contradicts this belief, which should therefore be removed from the belief base. The result of revision is therefore 

<math display="inline" id="Belief_revision:96">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\neg a\}
  </annotation>
 </semantics>
</math>

 in this case.</p>

<p>The problem of using deductively closed knowledge bases is that no distinction is made between pieces of knowledge that are known by themselves and pieces of knowledge that are merely consequences of them. This distinction is instead done by the <em>foundational</em> approach to belief revision, which is related to <a class="uri" href="foundationalism" title="wikilink">foundationalism</a> in philosophy. According to this approach, retracting a non-derived piece of knowledge should lead to retracting all its consequences that are not otherwise supported (by other non-derived pieces of knowledge). This approach can be realized by using knowledge bases that are not deductively closed and assuming that all formulae in the knowledge base represent self-standing beliefs, that is, they are not derived beliefs. In order to distinguish the foundational approach to belief revision to that based on deductively closed knowledge bases, the latter is called the <em>coherentist</em> approach. This name has been chosen because the coherentist approach aims at restoring the coherence (consistency) among <em>all</em> beliefs, both self-standing and derived ones. This approach is related to <a class="uri" href="coherentism" title="wikilink">coherentism</a> in philosophy.</p>

<p>Foundationalist revision operators working on non-deductively closed belief bases typically select some subsets of 

<math display="inline" id="Belief_revision:97">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 that are consistent with 

<math display="inline" id="Belief_revision:98">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, combined them in some way, and then conjoined them with 

<math display="inline" id="Belief_revision:99">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. The following are two non-deductively closed base revision operators.</p>
<dl>
<dt>WIDTIO : (When in Doubt, Throw it Out) the maximal subsets of 

<math display="inline" id="Belief_revision:100">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 that are consistent with 

<math display="inline" id="Belief_revision:101">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are intersected, and 

<math display="inline" id="Belief_revision:102">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is added to the resulting set; in other words, the result of revision is composed by 

<math display="inline" id="Belief_revision:103">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and of all formulae of 

<math display="inline" id="Belief_revision:104">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 that are in all maximal subsets of 

<math display="inline" id="Belief_revision:105">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 that are consistent with 

<math display="inline" id="Belief_revision:106">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

;</dt>
</dl>
<dl>
<dt>Ginsberg-Fagin-Ullman-Vardi : the maximal subsets of 

<math display="inline" id="Belief_revision:107">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>P</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>K</ci>
    <set>
     <ci>P</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\cup\{P\}
  </annotation>
 </semantics>
</math>

 that are consistent and contain 

<math display="inline" id="Belief_revision:108">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are combined by disjunction;</dt>
</dl>
<dl>
<dt>Nebel : similar to the above, but a priority among formulae can be given, so that formulae with higher priority are less likely to being retracted than formulae with lower priority.</dt>
</dl>

<p>A different realization of the foundational approach to belief revision is based on explicitly declaring the dependences among beliefs. In the <a href="truth_maintenance_system" title="wikilink">truth maintenance systems</a>, dependence links among beliefs can be specified. In other worlds, one can explicitly declare that a given fact is believed because of one or more other facts; such a dependency is called a <em>justification</em>. Beliefs not having any justifications play the role of non-derived beliefs in the non-deductively closed knowledge base approach.</p>
<h2 id="model-based-revision-and-update">Model-based revision and update</h2>

<p>A number of proposals for revision and update based on the set of models of the involved formulae were developed independently of the AGM framework. The principle behind this approach is that a knowledge base is equivalent to a set of <em>possible worlds</em>, that is, to a set of scenarios that are considered possible according to that knowledge base. Revision can therefore be performed on the sets of possible worlds rather than on the corresponding knowledge bases.</p>

<p>The revision and update operators based on models are usually identified by the name of their authors: <a href="Marianne_Winslett" title="wikilink">Winslett</a>, Forbus, Satoh, Dalal, Hegner, and Weber. According to the first four of these proposal, the result of revising/updating a formula 

<math display="inline" id="Belief_revision:109">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 by another formula 

<math display="inline" id="Belief_revision:110">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is characterized by the set of models of 

<math display="inline" id="Belief_revision:111">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 that are the closest to the models of 

<math display="inline" id="Belief_revision:112">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

. Different notions of closeness can be defined, leading to the difference among these proposals.</p>
<dl>
<dt>Dalal : the models of 

<math display="inline" id="Belief_revision:113">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 having a minimal <a href="Hamming_distance" title="wikilink">Hamming distance</a> to models of 

<math display="inline" id="Belief_revision:114">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 are selected to be the models that result from the change;</dt>
</dl>
<dl>
<dt>Satoh : similar to Dalal, but distance between two models is defined as the set of literals that are given different values by them; similarity between models is defined as set containment of these differences;</dt>
</dl>
<dl>
<dt>Winslett : for each model of 

<math display="inline" id="Belief_revision:115">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

, the closest models of 

<math display="inline" id="Belief_revision:116">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are selected; comparison is done using set containment of the difference;</dt>
</dl>
<dl>
<dt>Borgida : equal to Winslett's if 

<math display="inline" id="Belief_revision:117">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:118">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are inconsistent; otherwise, the result of revision is 

<math display="inline" id="Belief_revision:119">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>∧</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\wedge P
  </annotation>
 </semantics>
</math>

;</dt>
</dl>
<dl>
<dt><a href="Ken_Forbus" title="wikilink">Forbus</a> : similar to Winslett, but the Hamming distance is used.</dt>
</dl>

<p>The revision operator defined by Hegner makes 

<math display="inline" id="Belief_revision:120">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 not to affect the value of the variables that are mentioned in 

<math display="inline" id="Belief_revision:121">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. What results from this operation is a formula 

<math display="inline" id="Belief_revision:122">
 <semantics>
  <msup>
   <mi>K</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>K</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K^{\prime}
  </annotation>
 </semantics>
</math>

 that is consistent with 

<math display="inline" id="Belief_revision:123">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, and can therefore be conjoined with it. The revision operator by Weber is similar, but the literals that are removed from 

<math display="inline" id="Belief_revision:124">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 are not all literals of 

<math display="inline" id="Belief_revision:125">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, but only the literals that are evaluated differently by a pair of closest models of 

<math display="inline" id="Belief_revision:126">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:127">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 according to the Satoh measure of closeness.</p>
<h2 id="iterated-revision">Iterated revision</h2>

<p>The AGM postulates are equivalent to a preference ordering (an ordering over models) to be associated to every knowledge base 

<math display="inline" id="Belief_revision:128">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

. However, they do not relate the orderings corresponding to two non-equivalent knowledge bases. In particular, the orderings associated to a knowledge base 

<math display="inline" id="Belief_revision:129">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 and its revised version 

<math display="inline" id="Belief_revision:130">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>*</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P
  </annotation>
 </semantics>
</math>

 can be completely different. This is a problem for performing a second revision, as the ordering associated with 

<math display="inline" id="Belief_revision:131">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>*</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P
  </annotation>
 </semantics>
</math>

 is necessary to calculate 

<math display="inline" id="Belief_revision:132">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>*</mo>
   <mi>P</mi>
   <mo>*</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P*Q
  </annotation>
 </semantics>
</math>

.</p>

<p>Establishing a relation between the ordering associated with 

<math display="inline" id="Belief_revision:133">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:134">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>*</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P
  </annotation>
 </semantics>
</math>

 has been however recognized not to be the right solution to this problem. Indeed, the preference relation should depend on the previous history of revisions, rather than on the resulting knowledge base only. More generally, a preference relation gives more information about the state of mind of an agent than a simple knowledge base. Indeed, two states of mind might represent the same piece of knowledge 

<math display="inline" id="Belief_revision:135">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 while at the same time being different in the way a new piece of knowledge would be incorporated. For example, two people might have the same idea as to where to go on holiday, but yet they differ on how they would change this idea if they win a million-dollar lottery. Since the basic condition of the preference ordering is that their minimal models are exactly the models of their associated knowledge base, a knowledge base can be considered implicitly represented by a preference ordering (but not vice versa).</p>

<p>Given that a preference ordering allows deriving its associated knowledge base but also allows performing a single step of revision, studies on iterated revision have been concentrated on how a preference ordering should be changed in response of a revision. While single-step revision is about how a knowledge base 

<math display="inline" id="Belief_revision:136">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 has to be changed into a new knowledge base 

<math display="inline" id="Belief_revision:137">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>*</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P
  </annotation>
 </semantics>
</math>

, iterated revision is about how a preference ordering (representing both the current knowledge and how much situations believed to be false are considered possible) should be turned into a new preference relation when 

<math display="inline" id="Belief_revision:138">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is learned. A single step of iterated revision produces a new ordering that allows for further revisions.</p>

<p>Two kinds of preference ordering are usually considered: numerical and non-numerical. In the first case, the level of plausibility of a model is representing by a non-negative integer number; the lower the rank, the more plausible the situation corresponding to the model. Non-numerical preference orderings correspond to the preference relations used in the AGM framework: a possibly total ordering over models. The non-numerical preference relation were initially considered unsuitable for iterated revision because of the impossibility of reverting a revision by a number of other revisions, which is instead possible in the numerical case.</p>

<p>Darwiche and <a href="Judea_Pearl" title="wikilink">Pearl</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> formulated the following postulates for iterated revision.</p>
<ol>
<li>if 

<math display="inline" id="Belief_revision:139">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>⊧</mo>
   <mi>μ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <ci>α</ci>
    <ci>μ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\models\mu
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Belief_revision:140">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ψ</mi>
      <mo>*</mo>
      <mi>μ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mi>α</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>ψ</mi>
    <mo>*</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>ψ</ci>
      <ci>μ</ci>
     </apply>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\psi*\mu)*\alpha\equiv\psi*\alpha
  </annotation>
 </semantics>
</math>

;</li>
<li>if 

<math display="inline" id="Belief_revision:141">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>⊧</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>μ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <ci>α</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>μ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\models\neg\mu
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Belief_revision:142">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ψ</mi>
      <mo>*</mo>
      <mi>μ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mi>α</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>ψ</mi>
    <mo>*</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>ψ</ci>
      <ci>μ</ci>
     </apply>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\psi*\mu)*\alpha\equiv\psi*\alpha
  </annotation>
 </semantics>
</math>

;</li>
<li>if 

<math display="inline" id="Belief_revision:143">
 <semantics>
  <mrow>
   <mrow>
    <mi>ψ</mi>
    <mo>*</mo>
    <mi>α</mi>
   </mrow>
   <mo>⊧</mo>
   <mi>μ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <ci>α</ci>
    </apply>
    <ci>μ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi*\alpha\models\mu
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Belief_revision:144">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ψ</mi>
      <mo>*</mo>
      <mi>μ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mi>α</mi>
   </mrow>
   <mo>⊧</mo>
   <mi>μ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>ψ</ci>
      <ci>μ</ci>
     </apply>
     <ci>α</ci>
    </apply>
    <ci>μ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\psi*\mu)*\alpha\models\mu
  </annotation>
 </semantics>
</math>

;</li>
<li>if 

<math display="inline" id="Belief_revision:145">
 <semantics>
  <mrow>
   <mrow>
    <mi>ψ</mi>
    <mo>*</mo>
    <mi>α</mi>
   </mrow>
   <mo>⊧̸</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>μ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-models</csymbol>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>μ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi*\alpha\not\models\neg\mu
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Belief_revision:146">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ψ</mi>
      <mo>*</mo>
      <mi>μ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mi>α</mi>
   </mrow>
   <mo>⊧̸</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>μ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-models</csymbol>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>ψ</ci>
      <ci>μ</ci>
     </apply>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>μ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\psi*\mu)*\alpha\not\models\neg\mu
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Specific iterated revision operators have been proposed by Spohn, Boutilier, Williams, Lehmann, and others.</p>
<dl>
<dt>Spohn rejected revision : this non-numerical proposal has been first considered by Spohn, who rejected it based on the fact that revisions can change some orderings in such a way the original ordering cannot be restored with a sequence of other revisions; this operator change a preference ordering in view of new information 

<math display="inline" id="Belief_revision:147">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 by making all models of 

<math display="inline" id="Belief_revision:148">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 being preferred over all other models; the original preference ordering is maintained when comparing two models that are both models of 

<math display="inline" id="Belief_revision:149">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 or both non-models of 

<math display="inline" id="Belief_revision:150">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

;</dt>
</dl>
<dl>
<dt>Natural revision : while revising a preference ordering by a formula 

<math display="inline" id="Belief_revision:151">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, all minimal models (according to the preference ordering) of 

<math display="inline" id="Belief_revision:152">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are made more preferred by all other ones; the original ordering of models is preserved when comparing two models that are not minimal models of 

<math display="inline" id="Belief_revision:153">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

; this operator changes the ordering among models minimally while preserving the property that the models of the knowledge base after revising by 

<math display="inline" id="Belief_revision:154">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are the minimal models of 

<math display="inline" id="Belief_revision:155">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 according to the preference ordering;</dt>
</dl>
<dl>
<dt>Transmutations : these are two forms of revision, conditionalization and adjustment, which work on numerical preference orderings; revision requires not only a formula but also a number indicating its degree of plausibility; while the preference ordering is still inverted (the lower a model, the most plausible it is) the degree of plausibility of a revising formula is direct (the higher the degree, the most believed the formula is);</dt>
</dl>
<dl>
<dt>Ranked revision : a ranked model, which is an assignment of non-negative integers to models, has to be specified at the beginning; this rank is similar to a preference ordering, but is not changed by revision; what is changed by a sequence of revisions are a current set of models (representing the current knowledge base) and a number called the rank of the sequence; since this number can only monotonically non-decrease, some sequences of revision lead to situations in which every further revision is performed as a full meet revision.</dt>
</dl>
<h2 id="merging">Merging</h2>

<p>The assumption implicit in the revision operator is that the new piece of information 

<math display="inline" id="Belief_revision:156">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is always to be considered more reliable than the old knowledge base 

<math display="inline" id="Belief_revision:157">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

. This is formalized by the second of the AGM postulates

<math display="block" id="Belief_revision:158">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is always believed after revising 

<math display="inline" id="Belief_revision:159">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Belief_revision:160">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. More generally, one can consider the process of merging several pieces of information (rather than just two) that might or might not have the same reliability. Revision becomes the particular instance of this process when a less reliable piece of information 

<math display="inline" id="Belief_revision:161">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is merged with a more reliable 

<math display="inline" id="Belief_revision:162">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</p>

<p>While the input to the revision process is a pair of formulae 

<math display="inline" id="Belief_revision:163">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:164">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, the input to merging is a <a class="uri" href="multiset" title="wikilink">multiset</a> of formulae 

<math display="inline" id="Belief_revision:165">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Belief_revision:166">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, etc. The use of multisets is necessary as two sources to the merging process might be identical.</p>

<p>When merging a number of knowledge bases with the same degree of plausibility, a distinction is made between arbitration and majority. This distinction depends on the assumption that is made about the information and how it has to be put together.</p>
<dl>
<dt>arbitration : the result of arbitrating two knowledge bases 

<math display="inline" id="Belief_revision:167">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:168">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 entails 

<math display="inline" id="Belief_revision:169">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>∨</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>K</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\vee T
  </annotation>
 </semantics>
</math>

; this condition formalizes the assumption of maintaining as much as the old information as possible, as it is equivalent to imposing that every formula entailed by both knowledge bases is also entailed by the result of their arbitration; in a possible world view, the "real" world is assumed one of the worlds considered possible according to at least one of the two knowledge bases;</dt>
</dl>
<dl>
<dt>majority : the result of merging a knowledge base 

<math display="inline" id="Belief_revision:170">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 with other knowledge bases can be forced to entail 

<math display="inline" id="Belief_revision:171">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 by adding a sufficient number of other knowledge bases equivalent to 

<math display="inline" id="Belief_revision:172">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

; this condition corresponds to a kind of vote-by-majority: a sufficiently large number of knowledge bases can always overcome the "opinion" of any other fixed set of knowledge bases.</dt>
</dl>

<p>The above is the original definition of arbitration. According to a newer definition, an arbitration operator is a merging operator that is insensitive to the number of equivalent knowledge bases to merge. This definition makes arbitration the exact opposite of majority.</p>

<p>Postulates for both arbitration and merging have been proposed. An example of an arbitration operator satisfying all postulates is the classical disjunction. An example of a majority operator satisfying all postulates is that selecting all models that have a minimal total Hamming distance to models of the knowledge bases to merge.</p>

<p>A merging operator can be expressed as a family of orderings over models, one for each possible multiset of knowledge bases to merge: the models of the result of merging a multiset of knowledge bases are the minimal models of the ordering associated to the multiset. A merging operator defined in this way satisfies the postulates for merging if and only if the family of orderings meets a given set of conditions. For the old definition of arbitration, the orderings are not on models but on pairs (or, in general, tuples) of models.</p>
<h2 id="social-choice-theory">Social choice theory</h2>

<p>Many revision proposals involve orderings over models representing the relative plausibility of the possible alternatives. The problem of merging amounts to combine a set of orderings into a single one expressing the combined plausibility of the alternatives. This is similar with what is done in <a href="social_choice_theory" title="wikilink">social choice theory</a>, which is the study of how the preferences of a group of agents can be combined in a rational way. Belief revision and social choice theory are similar in that they combine a set of orderings into one. They differ on how these orderings are interpreted: preferences in social choice theory; plausibility in belief revision. Another difference is that the alternatives are explicitly enumerated in social choice theory, while they are the propositional models over a given alphabet in belief revision.</p>
<h2 id="complexity">Complexity</h2>

<p>The problem about belief revision that is the most studied from the point of view of <a href="Computational_complexity_theory" title="wikilink">computational complexity</a> is that of query answering in the propositional case. This is the problem of establishing whether a formula follows from the result of a revision, that is, 

<math display="inline" id="Belief_revision:173">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mo>*</mo>
    <mi>P</mi>
   </mrow>
   <mo>⊧</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>P</ci>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P\models Q
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Belief_revision:174">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Belief_revision:175">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Belief_revision:176">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 are propositional formulae. More generally, query answering is the problem of telling whether a formula is entailed by the result of a belief revision, which could be update, merging, revision, iterated revision, etc. Another problem that has received some attention is that of model checking, that is, checking whether a model satisfies the result of a belief revision. A related question is whether such result can be represented in space polynomial in that of its arguments.</p>

<p>Since a deductively closed knowledge base is infinite, complexity studies on belief revision operators working on deductively closed knowledge bases are done in the assumption that such deductively closed knowledge base are given in the form of an equivalent finite knowledge base.</p>

<p>A distinction is made among belief revision operators and belief revision schemes. While the former are simple mathematical operators mapping a pair of formulae into another formula, the latter depend on further information such as a preference relation. For example, the Dalal revision is an operator because, once two formulae 

<math display="inline" id="Belief_revision:177">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:178">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are given, no other information is needed to compute 

<math display="inline" id="Belief_revision:179">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>*</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K*P
  </annotation>
 </semantics>
</math>

. On the other hand, revision based on a preference relation is a revision scheme, because 

<math display="inline" id="Belief_revision:180">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Belief_revision:181">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 do not allow determining the result of revision if the family of preference orderings between models is not given. The complexity for revision schemes is determined in the assumption that the extra information needed to compute revision is given in some compact form. For example, a preference relation can be represented by a sequence of formulae whose models are increasingly preferred. Explicitly storing the relation as a set of pairs of models is instead not a compact representation of preference because the space required is exponential in the number of propositional letters.</p>

<p>The complexity of query answering and model checking in the propositional case is in the second level of the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a> for most belief revision operators and schemas. Most revision operators suffer from the problem of representational blow up: the result of revising two formulae is not necessarily representable in space polynomial in that of the two original formulae. In other words, revision may exponentially increase the size of the knowledge base.</p>
<h2 id="implementations">Implementations</h2>

<p>Systems specifically implementing belief revision are: <a href="http://portal.acm.org/citation.cfm?id=122296.122301">Immortal</a>, <a href="http://magic.it.uts.edu.au/systems/saten.html">SATEN</a>, and <a href="http://www.dis.uniroma1.it/~liberato/brels/brels.html">BReLS</a>. Two systems including a belief revision feature are <a href="http://www.cse.buffalo.edu/sneps/">SNePS</a> and <a class="uri" href="Cyc" title="wikilink">Cyc</a>. <a href="Truth_maintenance_systems" title="wikilink">Truth maintenance systems</a> are used in <a href="Artificial_Intelligence" title="wikilink">Artificial Intelligence</a> to implement belief revision.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Artificial_intelligence" title="wikilink">Artificial intelligence</a></li>
<li><a class="uri" href="Inquiry" title="wikilink">Inquiry</a></li>
<li><a href="Knowledge_representation" title="wikilink">Knowledge representation</a></li>
<li><a href="Belief_propagation" title="wikilink">Belief propagation</a></li>
<li><a href="Reason_Maintanance" title="wikilink">Reason Maintanance</a></li>
<li><a href="Epistemic_closure" title="wikilink">Epistemic closure</a></li>
<li><a href="Non-monotonic_logic" title="wikilink">Non-monotonic logic</a></li>
<li><a href="Defeasible_reasoning" title="wikilink">Defeasible reasoning</a></li>
<li><a class="uri" href="Reasoning" title="wikilink">Reasoning</a></li>
<li><a href="Philosophy_of_science" title="wikilink">Philosophy of science</a></li>
<li><a href="Discursive_dilemma" title="wikilink">Discursive dilemma</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li>C. E. Alchourròn, P. Gärdenfors, and D. Makinson (1985). On the logic of theory change: Partial meet contraction and revision functions. <em>Journal of Symbolic Logic</em>, 50:510–530.</li>
</ul>
<ul>
<li>C. Boutilier (1993). Revision sequences and nested conditionals. In <em>Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence (IJCAI'93)</em>, pages 519–525.</li>
</ul>
<ul>
<li>C. Boutilier (1995). Generalized update: belief change in dynamic settings. In <em>Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence (IJCAI'95)</em>, pages 1550–1556.</li>
</ul>
<ul>
<li>C. Boutilier (1996). Abduction to plausible causes: an event-based model of belief update. <em>Artificial Intelligence</em>, 83:143–166.</li>
</ul>
<ul>
<li>M. Cadoli, F. M. Donini, P. Liberatore, and M. Schaerf (1999). The size of a revised knowledge base. <em>Artificial Intelligence</em>, 115(1):25–64.</li>
</ul>
<ul>
<li>T. Chou and <a href="Marianne_Winslett" title="wikilink">M. Winslett</a> (1991). Immortal: A model-based belief revision system. In <em>Proceedings of the Second International Conference on the Principles of Knowledge Representation and Reasoning (KR'91)</em>, pages 99–110. Morgan Kaufmann Publishers.</li>
</ul>
<ul>
<li>M. Dalal (1988). Investigations into a theory of knowledge base revision: Preliminary report. In <em>Proceedings of the Seventh National Conference on Artificial Intelligence (AAAI'88)</em>, pages 475–479.</li>
</ul>
<ul>
<li>T. Eiter and G. Gottlob (1992). On the complexity of propositional knowledge base revision, updates and counterfactuals. <em>Artificial Intelligence</em>, 57:227–270.</li>
</ul>
<ul>
<li>T. Eiter and G. Gottlob (1996). The complexity of nested counterfactuals and iterated knowledge base revisions. <em>Journal of Computer and System Sciences</em>, 53(3):497–512.</li>
</ul>
<ul>
<li>R. Fagin, J. D. Ullman, and M. Y. Vardi (1983). On the semantics of updates in databases. In <em>Proceedings of the Second ACM SIGACT SIGMOD Symposium on Principles of Database Systems (PODS'83)</em>, pages 352–365.</li>
</ul>
<ul>
<li>M. A. Falappa, G. Kern-Isberner, G. R. Simari (2002): Explanations, belief revision and defeasible reasoning. <em>Artificial Intelligence</em>, 141(1–2): 1–28.</li>
</ul>
<ul>
<li>M. Freund and D. Lehmann (2002). Belief Revision and Rational Inference. <a href="http://arxiv.org/abs/cs.AI/0204032">Arxiv preprint cs.AI/0204032</a>.</li>
</ul>
<ul>
<li>N. Friedman and J. Y. Halpern (1994). A knowledge-based framework for belief change, part II: Revision and update. In <em>Proceedings of the Fourth International Conference on the Principles of Knowledge Representation and Reasoning (KR'94)</em>, pages 190–200.</li>
</ul>
<ul>
<li>A. Fuhrmann (1991). Theory contraction through base contraction. <em>Journal of Philosophical Logic</em>, 20:175–203.</li>
</ul>
<ul>
<li>D. Gabbay, G. Pigozzi, and J. Woods (2003). Controlled Revision – An algorithmic approach for belief revision, <em>Journal of Logic and Computation</em>, 13(1): 15–35.</li>
</ul>
<ul>
<li>P. Gärdenfors and D. Makinson (1988). Revision of knowledge systems using epistemic entrenchment. In <em>Proceedings of the Second Conference on Theoretical Aspects of Reasoning about Knowledge (TARK'88)</em>, pages 83–95.</li>
</ul>
<ul>
<li>P. Gärdenfors and H. Rott (1995). Belief revision. In <em>Handbook of Logic in Artificial Intelligence and Logic Programming, Volume 4</em>, pages 35–132. Oxford University Press.</li>
</ul>
<ul>
<li>G. Grahne and <a href="Alberto_O._Mendelzon" title="wikilink">Alberto O. Mendelzon</a> (1995). Updates and subjunctive queries. <em>Information and Computation</em>, 2(116):241–252.</li>
</ul>
<ul>
<li>G. Grahne, <a href="Alberto_O._Mendelzon" title="wikilink">Alberto O. Mendelzon</a>, and P. Revesz (1992). Knowledge transformations. In <em>Proceedings of the Eleventh ACM SIGACT SIGMOD SIGART Symposium on Principles of Database Systems (PODS'92)</em>, pages 246–260.</li>
</ul>
<ul>
<li>S. O. Hansson (1999). <em>A Textbook of Belief Dynamics</em>. Dordrecht: Kluwer Academic Publishers.</li>
</ul>
<ul>
<li>A. Herzig (1996). The PMA revised. In <em>Proceedings of the Fifth International Conference on the Principles of Knowledge Representation and Reasoning (KR'96)</em>, pages 40–50.</li>
</ul>
<ul>
<li>A. Herzig (1998). Logics for belief base updating. In D. Dubois, D. Gabbay, H. Prade, and P. Smets, editors, <em>Handbook of defeasible reasoning and uncertainty management</em>, volume 3 – Belief Change, pages 189–231. Kluwer Academic Publishers.</li>
</ul>
<ul>
<li>H. Katsuno and A. O. Mendelzon (1991). On the difference between updating a knowledge base and revising it. In <em>Proceedings of the Second International Conference on the Principles of Knowledge Representation and Reasoning (KR'91)</em>, pages 387–394.</li>
</ul>
<ul>
<li>H. Katsuno and A. O. Mendelzon (1991). Propositional knowledge base revision and minimal change. <em>Artificial Intelligence</em>, 52:263–294.</li>
</ul>
<ul>
<li>S. Konieczny and R. Pino Perez (1998). On the logic of merging. In <em>Proceedings of the Sixth International Conference on Principles of Knowledge Representation and Reasoning (KR'98)</em>, pages 488–498.</li>
</ul>
<ul>
<li>D. Lehmann (1995). Belief revision, revised. In <em>Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence (IJCAI'95)</em>, pages 1534–1540.</li>
</ul>
<ul>
<li>P. Liberatore (1997). The complexity of iterated belief revision. In <em>Proceedings of the Sixth International Conference on Database Theory (ICDT'97)</em>, pages 276–290.</li>
</ul>
<ul>
<li>P. Liberatore and M. Schaerf (1998). Arbitration (or how to merge knowledge bases). <em>IEEE Transactions on Knowledge and Data Engineering</em>, 10(1):76–90.</li>
</ul>
<ul>
<li>P. Liberatore and M. Schaerf (2000). BReLS: A system for the integration of knowledge bases. In <em>Proceedings of the Seventh International Conference on Principles of Knowledge Representation and Reasoning (KR 2000)</em>, pages 145–152.</li>
</ul>
<ul>
<li>D. Makinson (1985). How to give up: A survey of some formal aspects of the logic of theory change. <em>Synthese</em>, 62:347–363.</li>
</ul>
<ul>
<li>A. Perea (2003). <em>Proper Rationalizability and Belief Revision in Dynamic Games</em>. Research Memoranda 048: METEOR, Maastricht Research School of Economics of Technology and Organization.</li>
</ul>
<ul>
<li>B. Nebel (1991). Belief revision and default reasoning: Syntax-based approaches. In <em>Proceedings of the Second International Conference on the Principles of Knowledge Representation and Reasoning (KR'91)</em>, pages 417–428.</li>
</ul>
<ul>
<li>B. Nebel (1994). Base revision operations and schemes: Semantics, representation and complexity. In <em>Proceedings of the Eleventh European Conference on Artificial Intelligence (ECAI'94)</em>, pages 341–345.</li>
</ul>
<ul>
<li>B. Nebel (1996). How hard is it to revise a knowledge base? Technical Report 83, Albert-Ludwigs-Universität Freiburg, Institut für Informatik.</li>
</ul>
<ul>
<li>G. Pigozzi (2005). Two aggregation paradoxes in social decision making: the Ostrogorski paradox and the <a href="discursive_dilemma" title="wikilink">discursive dilemma</a>, <em>Episteme: A Journal of Social Epistemology</em>, 2(2): 33–42.</li>
</ul>
<ul>
<li>G. Pigozzi (2006). <a href="http://pigozzi.org/Pigozzi_Judgment_Aggregation.pdf">Belief merging and the discursive dilemma: an argument-based account to paradoxes of judgment aggregation</a>. <em>Synthese</em> 152(2): 285–298.</li>
</ul>
<ul>
<li>P. Z. Revesz (1993). On the semantics of theory change: Arbitration between old and new information. In <em>Proceedings of the Twelfth ACM SIGACT SIGMOD SIGART Symposium on Principles of Database Systems (PODS'93)</em>, pages 71–82.</li>
</ul>
<ul>
<li>K. Satoh (1988). Nonmonotonic reasoning by minimal belief revision. In <em>Proceedings of the International Conference on Fifth Generation Computer Systems (FGCS'88)</em>, pages 455–462.</li>
</ul>
<ul>
<li>

<p>See Section 14.2; <a href="http://www.masfoundations.org/download.html">downloadable free online</a>.</p></li>
</ul>
<ul>
<li>V. S. Subrahmanian (1994). Amalgamating knowledge bases. <em>ACM Transactions on Database Systems</em>, 19(2):291–331.</li>
</ul>
<ul>
<li>A. Weber (1986). Updating propositional formulas. In <em>Proc. of First Conf. on Expert Database Systems</em>, pages 487–500.</li>
</ul>
<ul>
<li>M. Williams (1994). Transmutations of knowledge systems. In <em>Proceedings of the Fourth International Conference on the Principles of Knowledge Representation and Reasoning (KR'94)</em>, pages 619–629.</li>
</ul>
<ul>
<li>M. Winslett (1989). Sometimes updates are circumscription. In <em>Proceedings of the Eleventh International Joint Conference on Artificial Intelligence (IJCAI'89)</em>, pages 859–863.</li>
</ul>
<ul>
<li>M. Winslett (1990). <em>Updating Logical Databases</em>. Cambridge University Press.</li>
</ul>
<ul>
<li>Y. Zhang and N. Foo (1996). Updating knowledge bases with disjunctive information. In <em>Proceedings of the Thirteenth National Conference on Artificial Intelligence (AAAI'96)</em>, pages 562–568.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li><a href="http://www.beliefrevision.org/">Beliefrevision.org</a></li>
<li><a href="http://plato.stanford.edu/entries/reasoning-defeasible/#4.3">Defeasible Reasoning: 4.3 Belief Revision Theory</a> at <a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a></li>
</ul>

<p>"</p>

<p><a href="Category:Belief_revision" title="wikilink"> </a> <a class="uri" href="Category:Belief" title="wikilink">Category:Belief</a> <a href="Category:Formal_epistemology" title="wikilink">Category:Formal epistemology</a> <a href="Category:Knowledge_representation" title="wikilink">Category:Knowledge representation</a> <a class="uri" href="Category:Logic" title="wikilink">Category:Logic</a> <a href="Category:Logic_programming" title="wikilink">Category:Logic programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Darwiche, A. and Pearl, J. (1997) On the logic of iterated belief revision. <em>Artificial Intelligence</em> <strong>89</strong>(1-2): 1-29.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
