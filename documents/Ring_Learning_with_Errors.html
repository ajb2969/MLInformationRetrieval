<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1653">Ring Learning with Errors</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ring Learning with Errors</h1>
<hr>'''Ring Learning with Errors (RLWE)''' is a [[computational problem]] which serves as the foundation of new cryptographic algorithms designed to protect against cryptanalysis by [[quantum computers]] and also to provide the basis for [[homomorphic encryption]].  RLWE is more properly called Learning with Errors over Rings and is simply the larger [[Learning with errors|Learning with Errors]] problem specialized to [[polynomial rings]]
<p><code>over finite fields.</code><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><code>  Because of the presumed difficulty of solving the RLWE problem even on a quantum computer, RLWE based cryptography may form the fundamental base for </code><a href="Public-key_cryptography" title="wikilink"><code>public</code> <code>key</code> <code>cryptography</code></a><code> in the future just as the </code><a href="integer_factorization" title="wikilink"><code>integer</code> <code>factorization</code></a><code> and </code><a href="discrete_logarithm" title="wikilink"><code>discrete</code> <code>logarithm</code></a><code> problem have served as the base for public key cryptography since the early 1980's.</code><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><code>  An important feature of basing cryptography on the Ring Learning with Errors problem is the fact that the solution to the RLWE problem may be reducible to the </code><a href="NP-hard" title="wikilink"><code>NP-Hard</code></a><code> </code><a href="Shortest_vector_problem" title="wikilink"><code>Shortest</code> <code>Vector</code> <code>Problem</code></a><code> (SVP) in a Lattice.</code><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="background">Background</h2>

<p>The security of modern cryptography, in particular <a href="Public-key_cryptography" title="wikilink">Public Key Cryptography</a>, is based on the difficulty of solving computational problems believed to be intractable if the size of the problem is large enough and the instance of the problem to be solved is chosen randomly.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The classic example that has been used since the 1970's is the <a href="integer_factorization" title="wikilink">integer factorization</a> problem.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> It is believed that it is computationally intractable to factor the product of two prime numbers if those prime numbers are large enough and chosen at random. As of 2015 research has led to the factorization of the product of two 384-bit primes but not the product of two 512-bit primes. Integer factorization forms the basis of the widely used <a href="RSA_(cryptosystem)" title="wikilink">RSA</a> cryptographic algorithm.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>The Ring Learning with Errors (RLWE) problem is built on the arithmetic of <a class="uri" href="polynomials" title="wikilink">polynomials</a> with coefficients from a <a href="finite_field" title="wikilink">finite field</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> A typical polynomial a(x) is expressed as:</p>

<p>

<math display="inline" id="Ring_Learning_with_Errors:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msub>
     <msup>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msup>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x)=a_{0}+a_{1}x+a_{2}x^{2}+...+a_{n-2}x^{n-2}+a_{n-1}x^{n-1}
  </annotation>
 </semantics>
</math>

</p>

<p>Polynomials can be added and multiplied in the usual fashion. In the RLWE context the coefficients of the polynomials and all operations involving those coefficients will be done in a finite field, typically the field 

<math display="inline" id="Ring_Learning_with_Errors:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Z</mi>
     <mo>/</mo>
     <mi>q</mi>
    </mrow>
    <mi>Z</mi>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>F</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>Z</ci>
      <ci>q</ci>
     </apply>
     <ci>Z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z/qZ=F_{q}
  </annotation>
 </semantics>
</math>

 for a prime integer 

<math display="inline" id="Ring_Learning_with_Errors:2">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

. The set of polynomials over a finite field with the operations of addition and multiplication forms an infinite <a href="polynomial_ring" title="wikilink">polynomial ring</a> (

<math display="inline" id="Ring_Learning_with_Errors:3">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>q</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{q}[x]
  </annotation>
 </semantics>
</math>


).<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The RLWE context works with a finite sub-ring of this infinite ring. The sub-ring is typically the finite <a href="Quotient_ring" title="wikilink">quotient (factor) ring</a> formed by reducing all of the polynomials in 

<math display="inline" id="Ring_Learning_with_Errors:4">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>q</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{q}[x]
  </annotation>
 </semantics>
</math>

 modulo an <a href="irreducible_polynomial" title="wikilink">irreducible polynomial</a> 

<math display="inline" id="Ring_Learning_with_Errors:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x)
  </annotation>
 </semantics>
</math>

. This finite quotient ring can be written as 

<math display="inline" id="Ring_Learning_with_Errors:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>q</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-Φ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{q}[x]/\Phi(x)
  </annotation>
 </semantics>
</math>

 though many authors write 

<math display="inline" id="Ring_Learning_with_Errors:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Z</mi>
      <mi>q</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-Φ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{q}[x]/\Phi(x)
  </annotation>
 </semantics>
</math>

 .<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>If the degree polynomial 

<math display="inline" id="Ring_Learning_with_Errors:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x)
  </annotation>
 </semantics>
</math>


 is n, the sub-ring becomes the ring of polynomials of degree less than n modulo 

<math display="inline" id="Ring_Learning_with_Errors:9">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x)
  </annotation>
 </semantics>
</math>

 with coefficients from 

<math display="inline" id="Ring_Learning_with_Errors:10">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{q}
  </annotation>
 </semantics>
</math>

. The values n, q, together with the polynomial 

<math display="inline" id="Ring_Learning_with_Errors:11">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x)
  </annotation>
 </semantics>
</math>

 partially define the mathematical context for the RLWE problem.</p>

<p>Another concept necessary for the RLWE problem is the idea of "small" polynomials with respect to some norm. The typical norm used in the RLWE problem is known as the <a href="infinity_norm" title="wikilink">infinity norm</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The infinity norm of a polynomial is simply the largest coefficient of the polynomial when these coefficients are viewed as integers. Hence, 

<math display="inline" id="Ring_Learning_with_Errors:12">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msub>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||a(x)||_{\infty}=b
  </annotation>
 </semantics>
</math>

 states that the <a href="infinity_norm" title="wikilink">infinity norm</a> of the polynomial 

<math display="inline" id="Ring_Learning_with_Errors:13">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x)
  </annotation>
 </semantics>
</math>


 is 

<math display="inline" id="Ring_Learning_with_Errors:14">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. Thus 

<math display="inline" id="Ring_Learning_with_Errors:15">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is the largest coefficient of 

<math display="inline" id="Ring_Learning_with_Errors:16">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>The final concept necessary to understand the RLWE problem is the generation of random polynomials in 

<math display="inline" id="Ring_Learning_with_Errors:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Z</mi>
      <mi>q</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-Φ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{q}[x]/\Phi(x)
  </annotation>
 </semantics>
</math>

 and the generation of "small" polynomials . A random polynomial is easily generated by simply randomly sampling the n coefficients of the polynomial from 

<math display="inline" id="Ring_Learning_with_Errors:18">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{q}
  </annotation>
 </semantics>
</math>


 where 

<math display="inline" id="Ring_Learning_with_Errors:19">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{q}
  </annotation>
 </semantics>
</math>

 is typically represented as the set

<math display="block" id="Ring_Learning_with_Errors:20">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>q</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>q</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>q</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>q</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (-(q-1)/2,...,-1,0,1,...,(q-1)/2)
  </annotation>
 </semantics>
</math>

.</p>

<p>Randomly generating a "small" polynomial done by generating the coefficients of the polynomial from 

<math display="inline" id="Ring_Learning_with_Errors:21">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{q}
  </annotation>
 </semantics>
</math>

 in a way that either guarantees or makes very likely small coefficients. There are two common ways to do this:</p>
<ol>
<li>Using Uniform Sampling - The coefficients of the small polynomial are uniformly sampled from a set of small coefficients. Let b be an integer that is much less than q. If we randomly choose coefficients from the set: { -b, -b+1, -b+2. ... -2, -1, 0, 1, 2, ... , b-2, b-1, b} the polynomial will be small with respect to the bound (b).</li>
<li>Using <a href="Gaussian_function" title="wikilink">Discrete Gaussian Sampling</a> - For an odd value for q, the coefficients of the polynomial are randomly chosen by sampling from the set { -(q-1)/2 to (q-1)/2 } according to a discrete Gaussian distribution with mean 0 and distribution parameter σ. The references describe in full detail how this can be accomplished. It is more complicated than uniform sampling but it allows for a proof of security of the algorithm. The paper, "Sampling from Discrete Gaussians for Lattice-Based Cryptography on a Constrained Device," by Dwarakanath and Galbraith provide an overview of this problem.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
</ol>
<h2 id="the-rlwe-problem">The RLWE Problem</h2>

<p>The RLWE problem can be stated in two different ways. One is called the "Search" version and the other is the "Decision" version. The Search can be stated as follows. Let</p>
<ul>
<li>

<math display="inline" id="Ring_Learning_with_Errors:22">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}(x)
  </annotation>
 </semantics>
</math>

 be a set of random but <strong>known</strong> polynomials from 

<math display="inline" id="Ring_Learning_with_Errors:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Z</mi>
      <mi>q</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-Φ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{q}[x]/\Phi(x)
  </annotation>
 </semantics>
</math>


 with coefficients from all of 

<math display="inline" id="Ring_Learning_with_Errors:24">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{q}
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Ring_Learning_with_Errors:25">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i}(x)
  </annotation>
 </semantics>
</math>

 be a set of small random and <strong>unknown</strong> polynomials relative to a bound 

<math display="inline" id="Ring_Learning_with_Errors:26">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 in the ring 

<math display="inline" id="Ring_Learning_with_Errors:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Z</mi>
      <mi>q</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-Φ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{q}[x]/\Phi(x)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Ring_Learning_with_Errors:28">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)
  </annotation>
 </semantics>
</math>


 be a small <strong>unknown</strong> polynomial relative to a bound 

<math display="inline" id="Ring_Learning_with_Errors:29">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 in the ring 

<math display="inline" id="Ring_Learning_with_Errors:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Z</mi>
      <mi>q</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-Φ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{q}[x]/\Phi(x)
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Ring_Learning_with_Errors:31">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mi>a</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <mi>s</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>e</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <ci>s</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i}(x)=(a_{i}(x)\cdot s(x))+e_{i}(x)
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Given the list of polynomial pairs 

<math display="inline" id="Ring_Learning_with_Errors:32">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{i}(x),b_{i}(x))
  </annotation>
 </semantics>
</math>

 find the unknown polynomial 

<math display="inline" id="Ring_Learning_with_Errors:33">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)
  </annotation>
 </semantics>
</math>


</p>

<p>Using the same definitions, the Decision version of the problem can be stated as follows. Given a list of polynomial pairs 

<math display="inline" id="Ring_Learning_with_Errors:34">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{i}(x),b_{i}(x))
  </annotation>
 </semantics>
</math>

 determine whether the 

<math display="inline" id="Ring_Learning_with_Errors:35">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>i</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i}(x)
  </annotation>
 </semantics>
</math>

 polynomials were constructed as 

<math display="inline" id="Ring_Learning_with_Errors:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mi>a</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <mi>s</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>e</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <ci>s</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i}(x)=(a_{i}(x)\cdot s(x))+e_{i}(x)
  </annotation>
 </semantics>
</math>

 or were generated randomly from 

<math display="inline" id="Ring_Learning_with_Errors:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Z</mi>
      <mi>q</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-Φ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{q}[x]/\Phi(x)
  </annotation>
 </semantics>
</math>

 with coefficients from all of 

<math display="inline" id="Ring_Learning_with_Errors:38">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{q}
  </annotation>
 </semantics>
</math>


.</p>

<p>The difficulty of this problem is parameterized by the choice of the quotient polynomial ( 

<math display="inline" id="Ring_Learning_with_Errors:39">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x)
  </annotation>
 </semantics>
</math>

 ), its degree (n), the field (

<math display="inline" id="Ring_Learning_with_Errors:40">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{q}
  </annotation>
 </semantics>
</math>

), and the smallness bound (

<math display="inline" id="Ring_Learning_with_Errors:41">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

). In many RLWE based public key algorithms the private key will be a pair of small polynomials 

<math display="inline" id="Ring_Learning_with_Errors:42">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ring_Learning_with_Errors:43">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(x)
  </annotation>
 </semantics>
</math>


. The corresponding public key will be a pair of polynomials 

<math display="inline" id="Ring_Learning_with_Errors:44">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x)
  </annotation>
 </semantics>
</math>

, selected randomly from 

<math display="inline" id="Ring_Learning_with_Errors:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Z</mi>
      <mi>q</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-Φ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{q}[x]/\Phi(x)
  </annotation>
 </semantics>
</math>

, and the polynomial 

<math display="inline" id="Ring_Learning_with_Errors:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <mi>s</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
       <ci>s</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(x)=(a(x)\cdot s(x))+e(x)
  </annotation>
 </semantics>
</math>

. Given 

<math display="inline" id="Ring_Learning_with_Errors:47">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ring_Learning_with_Errors:48">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(x)
  </annotation>
 </semantics>
</math>


, it should be computationally infeasible to recover the polynomial 

<math display="inline" id="Ring_Learning_with_Errors:49">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="security-reduction">Security Reduction</h2>

<p>In cases where the polynomial 

<math display="inline" id="Ring_Learning_with_Errors:50">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x)
  </annotation>
 </semantics>
</math>

 is a cyclotomic polynomial, the difficulty of solving the search version of RLWE problem is equivalent to finding a short vector (but not necessarily the shortest) vector in an ideal lattice formed from elements of 

<math display="inline" id="Ring_Learning_with_Errors:51">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Z</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>Z</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-Φ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z[x]/\Phi(x)
  </annotation>
 </semantics>
</math>

 represented as integer vectors.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> This problem is commonly known as the <a href="Shortest_vector_problem" title="wikilink">Approximate Shortest Vector Problem (α-SVP)</a> and it is the problem of finding a vector shorter than α times the shortest vector. The authors of the proof for this equivalence write:</p>

<p><em>"... we give a quantum reduction from approximate SVP (in the worst case) on ideal lattices in R to the search version of ring-LWE, where the goal is to recover the secret s ∈ R<sub>q</sub> (with high probability, for any s) from arbitrarily many noisy products."</em><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>In that quote, The ring R is 

<math display="inline" id="Ring_Learning_with_Errors:52">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Z</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>Z</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-Φ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z[x]/\Phi(x)
  </annotation>
 </semantics>
</math>

 and the ring R<sub>q</sub> is 

<math display="inline" id="Ring_Learning_with_Errors:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Z</mi>
      <mi>q</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-Φ</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{q}[x]/\Phi(x)
  </annotation>
 </semantics>
</math>


.</p>

<p>The α-SVP in regular lattices is known to be <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> due to work by Daniele Micciancio in 2001.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> However, there is not yet a proof to show that the difficulty of the α-SVP for ideal lattices is equivalent to the average α-SVP. Rather we have a proof that if there are <strong>ANY</strong> α-SVP instances that are hard to solve in ideal lattices then the RLWE Problem will be hard in random instances.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>Regarding the difficulty of Shortest Vector Problems in Ideal Lattices, researcher Michael Schneider writes, <em>"So far there is no SVP algorithm making use of the special structure of ideal lattices. It is widely believed that solving SVP (and all other lattice problems) in ideal lattices is as hard as in regular lattices ."</em><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> The difficulty of these problems on regular lattices is provably <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> There are, however, a minority of researchers who do not believe that ideal lattices share the same security properties as regular lattices.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>Peikert believes that these security equivalences make the RLWE problem a good basis for future cryptography. He writes: <em>"There is a mathematical proof that the</em> <em>only</em> <em>way to break the cryptosystem (within some formal attack model) on its random instances is by being able to solve the underlying lattice problem in the</em> <em>worst case"</em> (emphasis in the original).<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h2 id="rlwe-cryptography">RLWE Cryptography</h2>

<p>A major advantage that RLWE based cryptography has over the original <a href="Learning_with_errors" title="wikilink">Learning With Errors</a> (LWE) based cryptography is found in the size of the public and private keys. RLWE keys are roughly the square root of keys in LWE.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> For 128-bits of security an RLWE cryptographic algorithm would use public keys around 7000 bits in length.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> The corresponding LWE scheme would require public keys of 49 million bits for the same level of security.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> On the other hand, RLWE keys are larger than the keys sizes for currently used public key algorithms like RSA and Elliptic Curve Diffie-Hellman which require public key sizes of 3072 bits and 256 bits, respectively, to achieve a 128-bit level of security.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> From a computational standpoint, however, RLWE algorithms have been shown to be the equal of or better than existing public key systems.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>Three groups of RLWE cryptographic algorithms exist:</p>
<h3 id="ring-learning-with-errors-key-exchanges-rlwe-kex"><a href="Ring_learning_with_errors_key_exchange" title="wikilink">Ring Learning with Errors Key Exchanges</a> (RLWE-KEX)</h3>

<p>A RLWE version of the classic Diffie-Hellman key exchange was designed by Peikert and published in early 2014.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> An RLWE version of the classic MQV variant of a Diffie-Hellman key exchange was later published by Zhang et. al.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> The security of both key exchanges is directly related to the problem of finding approximate short vectors in an ideal lattice.</p>
<h3 id="ring-learning-with-errors-signatures-rlwe-sig"><a href="Ring_learning_with_errors_signature" title="wikilink">Ring Learning with Errors Signatures</a> (RLWE-SIG)</h3>

<p>A RLWE version of the classic <a href="Feige–Fiat–Shamir_identification_scheme" title="wikilink">Feige-Fiat-Shamir Identification protocol</a> was created and converted to a digital signature in 2011 by Lyubashevsky.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> The details of this signature were extended in 2012 by Gunesyu, Lyubashevsky, and Popplemann in 2012 and published in their paper "Practical Lattice Based Cryptography - A Signature Scheme for Embedded Systems."<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> These papers laid the groundwork for a variety of recent signature algorithms some based directly on the Ring Learning with Errors problem and some which are not tied to the same hard RLWE problems.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h3 id="ring-learning-with-errors-homomorphic-encryption-rlwe-hom"><a href="Homomorphic_encryption" title="wikilink">Ring Learning with Errors Homomorphic Encryption</a> (RLWE-HOM)</h3>

<p>The purpose of <a href="homomorphic_encryption" title="wikilink">homomorphic encryption</a> is to allow the computations on sensitive data to occur on computing devices that should not be trusted with the data. These computing devices are allowed to process the ciphertext which is output from a homomorphic encryption.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> In 2011, Brakersky and Vaikuntanathan, published "Fully Homomorphic Encryption from Ring-LWE and Security for Key Dependent Messages" which builds a homomorphic encryption scheme directly on the RLWE problem.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<h3 id="references">References</h3>

<p>__NOINDEX__</p>

<p>"</p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
</ol>
</section>
</hr></body>
</html>
