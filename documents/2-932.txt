   Gradient descent      Gradient descent  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     Gradient descent is a first-order  optimization  algorithm . To find a local minimum of a function using gradient descent, one takes steps proportional to the negative of the gradient (or of the approximate gradient) of the function at the current point. If instead one takes steps proportional to the positive of the gradient , one approaches a local maximum of that function; the procedure is then known as gradient ascent .  Gradient descent is also known as steepest descent , or the method of steepest descent . However, gradient descent should not be confused with the method of steepest descent for approximating integrals.  Description  (Figure)  Illustration of gradient descent.   Gradient descent is based on the observation that if the multivariable function    F   (  ùê±  )       F  ùê±    F(\mathbf{x})   is defined and differentiable in a neighborhood of a point   ùêö   ùêö   \mathbf{a}   , then    F   (  ùê±  )       F  ùê±    F(\mathbf{x})   decreases fastest if one goes from   ùêö   ùêö   \mathbf{a}   in the direction of the negative gradient of   F   F   F   at   ùêö   ùêö   \mathbf{a}   ,    -    ‚àá  F    (  ùêö  )           normal-‚àá  F   ùêö     -\nabla F(\mathbf{a})   . It follows that, if      ùêõ  =   ùêö  -   Œ≥   ‚àá  F    (  ùêö  )         ùêõ    ùêö    Œ≥   normal-‚àá  F   ùêö      \mathbf{b}=\mathbf{a}-\gamma\nabla F(\mathbf{a})     for   Œ≥   Œ≥   \gamma   small enough, then     F   (  ùêö  )    ‚â•   F   (  ùêõ  )          F  ùêö     F  ùêõ     F(\mathbf{a})\geq F(\mathbf{b})   . With this observation in mind, one starts with a guess    ùê±  0     subscript  ùê±  0    \mathbf{x}_{0}   for a local minimum of   F   F   F   , and considers the sequence     ùê±  0   ,   ùê±  1   ,   ùê±  2   ,  ‚Ä¶      subscript  ùê±  0    subscript  ùê±  1    subscript  ùê±  2   normal-‚Ä¶    \mathbf{x}_{0},\mathbf{x}_{1},\mathbf{x}_{2},\dots   such that        ùê±   n  +  1    =    ùê±  n   -    Œ≥  n    ‚àá  F    (   ùê±  n   )      ,   n  ‚â•  0.      formulae-sequence     subscript  ùê±    n  1       subscript  ùê±  n      subscript  Œ≥  n    normal-‚àá  F    subscript  ùê±  n        n  0.     \mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma_{n}\nabla F(\mathbf{x}_{n}),\ n\geq 0.     We have        F   (   ùê±  0   )    ‚â•   F   (   ùê±  1   )    ‚â•   F   (   ùê±  2   )    ‚â•  ‚ãØ   ,          F   subscript  ùê±  0      F   subscript  ùê±  1           F   subscript  ùê±  2         normal-‚ãØ     F(\mathbf{x}_{0})\geq F(\mathbf{x}_{1})\geq F(\mathbf{x}_{2})\geq\cdots,     so hopefully the sequence    (   ùê±  n   )     subscript  ùê±  n    (\mathbf{x}_{n})   converges to the desired local minimum. Note that the value of the step size    Œ≥   Œ≥   \gamma   is allowed to change at every iteration. With certain assumptions on the function   F   F   F   (for example,   F   F   F    convex and    ‚àá  F     normal-‚àá  F    \nabla F    Lipschitz ) and particular choices of   Œ≥   Œ≥   \gamma   (e.g., chosen via a line search that satisfies the Wolfe conditions ), convergence to a local minimum can be guaranteed. When the function   F   F   F   is convex , all local minima are also global minima, so in this case gradient descent can converge to the global solution.  This process is illustrated in the picture to the right. Here   F   F   F   is assumed to be defined on the plane, and that its graph has a bowl shape. The blue curves are the contour lines , that is, the regions on which the value of   F   F   F   is constant. A red arrow originating at a point shows the direction of the negative gradient at that point. Note that the (negative) gradient at a point is orthogonal to the contour line going through that point. We see that gradient descent leads us to the bottom of the bowl, that is, to the point where the value of the function   F   F   F   is minimal.  Examples  Gradient descent has problems with pathological functions such as the Rosenbrock function shown here.      f   (   x  1   ,   x  2   )   =    (  1  -   x  1   )   2   +  100    (   x  2   -   x  1  2   )   2   .     fragments  f   fragments  normal-(   subscript  x  1   normal-,   subscript  x  2   normal-)     superscript   fragments  normal-(  1    subscript  x  1   normal-)   2    100   superscript   fragments  normal-(   subscript  x  2     superscript   subscript  x  1   2   normal-)   2   normal-.     f(x_{1},x_{2})=(1-x_{1})^{2}+100(x_{2}-x_{1}^{2})^{2}.\quad   The Rosenbrock function has a narrow curved valley which contains the minimum. The bottom of the valley is very flat. Because of the curved flat valley the optimization is zig-zagging slowly with small stepsizes towards the minimum.  (Figure)  Banana-SteepDesc.gif   The "Zig-Zagging" nature of the method is also evident below, where the gradient ascent method is applied to     F   (  x  ,  y  )    =    sin   (      1  2    x  2    -    1  4    y  2     +  3   )     cos   (     2  x   +  1   -   e  y    )           F   x  y                1  2    superscript  x  2        1  4    superscript  y  2     3            2  x   1    superscript  e  y        F(x,y)=\sin\left(\frac{1}{2}x^{2}-\frac{1}{4}y^{2}+3\right)\cos(2x+1-e^{y})   .     (Figure)  The gradient descent algorithm in action. (1: contour)   (Figure)  The gradient descent algorithm in action. (2: surface)      Limitations  For some of the above examples, gradient descent is relatively slow close to the minimum: technically, its asymptotic rate of convergence is inferior to many other methods. For poorly conditioned convex problems, gradient descent increasingly 'zigzags' as the gradients point nearly orthogonally to the shortest direction to a minimum point. For more details, see the comments below.  For non-differentiable functions, gradient methods are ill-defined. For locally Lipschitz problems and especially for convex minimization problems, bundle methods of descent are well-defined. Non-descent methods, like subgradient projection methods, may also be used. 1 These methods are typically slower than gradient descent. Another alternative for non-differentiable functions is to "smooth" the function, or bound the function by a smooth function. In this approach, the smooth problem is solved in the hope that the answer is close to the answer for the non-smooth problem (occasionally, this can be made rigorous).  Solution of a linear system  Gradient descent can be used to solve a system of linear equations, reformulated as a quadratic minimization problem, e.g., using linear least squares . The solution of        A  ùê±   -  ùêõ   =  0          A  ùê±   ùêõ   0    A\mathbf{x}-\mathbf{b}=0   in the sense of linear least squares is defined as minimizing the function        F   (  x  )    =    ‚à•    A  ùê±   -  ùêõ   ‚à•   2    .        F  x    superscript   norm      A  ùê±   ùêõ    2     F(x)=\|A\mathbf{x}-\mathbf{b}\|^{2}.     In traditional linear least squares for real   A   A   A   and   ùêõ   ùêõ   \mathbf{b}   the Euclidean norm is used, in which case         ‚àá  F    (  ùê±  )    =   2   A  T    (    A  ùê±   -  ùêõ   )     .         normal-‚àá  F   ùê±     2   superscript  A  T       A  ùê±   ùêõ      \nabla F(\mathbf{x})=2A^{T}(A\mathbf{x}-\mathbf{b}).   In this case, the line search minimization, finding the locally optimal step size   Œ≥   Œ≥   \gamma   on every iteration, can be performed analytically, and explicit formulas for the locally optimal   Œ≥   Œ≥   \gamma   are known. 2  For solving linear equations, gradient descent is rarely used, with the conjugate gradient method being one of the most popular alternatives. The speed of convergence of gradient descent depends on the maximal and minimal eigenvalues of   A   A   A   , while the speed of convergence of conjugate gradients has a more complex dependence on the eigenvalues, and can benefit from preconditioning . Gradient descent also benefits from preconditioning, but this is not done as commonly.  Solution of a non-linear system  Gradient descent can also be used to solve a system of nonlinear equations. Below is an example that shows how to use the gradient descent to solve for three unknown variables, x 1 , x 2 , and x 3 . This example shows one iteration of the gradient descent.  Consider a nonlinear system of equations:      {        3   x  1    -   cos   (    x  2    x  3    )    -    3  2     =  0             4   x  1  2    -   625   x  2  2     +   2   x  2     -  1   =  0           exp   (   -    x  1    x  2     )    +   20   x  3    +      10  œÄ   -  3   3     =  0          cases        3   subscript  x  1         subscript  x  2    subscript  x  3       3  2    0   otherwise            4   superscript   subscript  x  1   2      625   superscript   subscript  x  2   2       2   subscript  x  2     1   0   otherwise             subscript  x  1    subscript  x  2        20   subscript  x  3          10  œÄ   3   3    0   otherwise    \begin{cases}3x_{1}-\cos(x_{2}x_{3})-\tfrac{3}{2}=0\\
 4x_{1}^{2}-625x_{2}^{2}+2x_{2}-1=0\\
 \exp(-x_{1}x_{2})+20x_{3}+\tfrac{10\pi-3}{3}=0\end{cases}   suppose we have the function       G   (  ùê±  )    =   [       3   x  1    -   cos   (    x  2    x  3    )    -    3  2             4   x  1  2    -   625   x  2  2     +   2   x  2     -  1         exp   (   -    x  1    x  2     )    +   20   x  3    +      10  œÄ   -  3   3        ]         G  ùê±         3   subscript  x  1         subscript  x  2    subscript  x  3       3  2              4   superscript   subscript  x  1   2      625   superscript   subscript  x  2   2       2   subscript  x  2     1              subscript  x  1    subscript  x  2        20   subscript  x  3          10  œÄ   3   3        G(\mathbf{x})=\begin{bmatrix}3x_{1}-\cos(x_{2}x_{3})-\tfrac{3}{2}\\
 4x_{1}^{2}-625x_{2}^{2}+2x_{2}-1\\
 \exp(-x_{1}x_{2})+20x_{3}+\tfrac{10\pi-3}{3}\\
 \end{bmatrix}   where      ùê±  =   [      x  1        x  2        x  3      ]       ùê±     subscript  x  1      subscript  x  2      subscript  x  3       \mathbf{x}=\begin{bmatrix}x_{1}\\
 x_{2}\\
 x_{3}\\
 \end{bmatrix}     and the objective function       F   (  ùê±  )    =     1  2     G  T    (  ùê±  )   G   (  ùê±  )          F  ùê±       1  2    superscript  G  normal-T   ùê±  G  ùê±     F(\mathbf{x})=\tfrac{1}{2}G^{\mathrm{T}}(\mathbf{x})G(\mathbf{x})            =    1  2    (     (    3   x  1    -   cos   (    x  2    x  3    )    -   3  2    )   2   +    (      4   x  1  2    -   625   x  2  2     +   2   x  2     -  1   )   2   +    (    exp   (   -    x  1    x  2     )    +   20   x  3    +     10  œÄ   -  3   3    )   2    )        absent      1  2      superscript      3   subscript  x  1         subscript  x  2    subscript  x  3       3  2    2    superscript          4   superscript   subscript  x  1   2      625   superscript   subscript  x  2   2       2   subscript  x  2     1   2    superscript           subscript  x  1    subscript  x  2        20   subscript  x  3          10  œÄ   3   3    2       =\tfrac{1}{2}((3x_{1}-\cos(x_{2}x_{3})-\tfrac{3}{2})^{2}+(4x_{1}^{2}-625x_{2}^%
 {2}+2x_{2}-1)^{2}+(\exp(-x_{1}x_{2})+20x_{3}+\tfrac{10\pi-3}{3})^{2})        With initial guess       ùê±   (  0  )    =   [      x  1        x  2        x  3      ]   =   [     0      0      0     ]          superscript  ùê±  0      subscript  x  1      subscript  x  2      subscript  x  3            0    0    0       \mathbf{x}^{(0)}=\begin{bmatrix}x_{1}\\
 x_{2}\\
 x_{3}\\
 \end{bmatrix}=\begin{bmatrix}0\\
 0\\
 0\\
 \end{bmatrix}     We know that       ùê±   (  1  )    =    ùê±   (  0  )    -    Œ≥  0    ‚àá  F    (   x   (  0  )    )          superscript  ùê±  1      superscript  ùê±  0      subscript  Œ≥  0    normal-‚àá  F    superscript  x  0       \mathbf{x}^{(1)}=\mathbf{x}^{(0)}-\gamma_{0}\nabla F(x^{(0)})   where        ‚àá  F    (   ùê±   (  0  )    )    =    J  G     (   ùê±   (  0  )    )   T   G   (   ùê±   (  0  )    )           normal-‚àá  F    superscript  ùê±  0       subscript  J  G    superscript   superscript  ùê±  0   normal-T   G   superscript  ùê±  0      \nabla F(\mathbf{x}^{(0)})=J_{G}(\mathbf{x}^{(0)})^{\mathrm{T}}G(\mathbf{x}^{(%
 0)})     The Jacobian matrix      J  G    (   ùê±   (  0  )    )        subscript  J  G    superscript  ùê±  0     J_{G}(\mathbf{x}^{(0)})          J  G   =   [     3      sin   (    x  2    x  3    )     x  3        sin   (    x  2    x  3    )     x  2         8   x  1        -   1250   x  2     +  2     0       -    x  2    exp   (   -    x  1    x  2     )         -    x  1    exp   (   -    x  1    x  2     )        20     ]        subscript  J  G     3         subscript  x  2    subscript  x  3      subscript  x  3           subscript  x  2    subscript  x  3      subscript  x  2        8   subscript  x  1          1250   subscript  x  2     2   0         subscript  x  2          subscript  x  1    subscript  x  2             subscript  x  1          subscript  x  1    subscript  x  2        20      J_{G}=\begin{bmatrix}3&\sin(x_{2}x_{3})x_{3}&\sin(x_{2}x_{3})x_{2}\\
 8x_{1}&-1250x_{2}+2&0\\
 -x_{2}\exp{(-x_{1}x_{2})}&-x_{1}\exp(-x_{1}x_{2})&20\\
 \end{bmatrix}     Then evaluating these terms at    ùê±   (  0  )      superscript  ùê±  0    \mathbf{x}^{(0)}           J  G    (   ùê±   (  0  )    )    =   [     3    0    0      0    2    0      0    0    20     ]          subscript  J  G    superscript  ùê±  0      3  0  0    0  2  0    0  0  20      J_{G}\left(\mathbf{x}^{(0)}\right)=\begin{bmatrix}3&0&0\\
 0&2&0\\
 0&0&20\end{bmatrix}   and       G   (   ùê±   (  0  )    )    =   [      -  2.5        -  1       10.472     ]         G   superscript  ùê±  0        2.5       1     10.472      G(\mathbf{x}^{(0)})=\begin{bmatrix}-2.5\\
 -1\\
 10.472\end{bmatrix}     So that        ùê±   (  1  )    =   0  -    Œ≥  0    [      -  7.5        -  2       209.44     ]      .       superscript  ùê±  1     0     subscript  Œ≥  0       7.5       2     209.44        \mathbf{x}^{(1)}=0-\gamma_{0}\begin{bmatrix}-7.5\\
 -2\\
 209.44\end{bmatrix}.     and       F   (   ùê±   (  0  )    )    =   0.5   (     (   -  2.5   )   2   +    (   -  1   )   2   +    (  10.472  )   2    )    =  58.456          F   superscript  ùê±  0      0.5     superscript    2.5   2    superscript    1   2    superscript  10.472  2          58.456     F\left(\mathbf{x}^{(0)}\right)=0.5((-2.5)^{2}+(-1)^{2}+(10.472)^{2})=58.456     (Figure)  An animation showing the first 83 iterations of gradient descent applied to this example. Surfaces are isosurfaces of    F   (   ùê±   (  n  )    )       F   superscript  ùê±  n     F(\mathbf{x}^{(n)})   at current guess    ùê±   (  n  )      superscript  ùê±  n    \mathbf{x}^{(n)}   , and arrows show the direction of descent. Due to a small and constant step size, the convergence is slow.   Now a suitable    Œ≥  0     subscript  Œ≥  0    \gamma_{0}   must be found such that     F   (   ùê±   (  1  )    )    ‚â§   F   (   ùê±   (  0  )    )          F   superscript  ùê±  1      F   superscript  ùê±  0      F(\mathbf{x}^{(1)})\leq F(\mathbf{x}^{(0)})   . This can be done with any of a variety of line search algorithms. One might also simply guess     Œ≥  0   =  0.001       subscript  Œ≥  0   0.001    \gamma_{0}=0.001   which gives       ùê±   (  1  )    =   [     0.0075      0.002       -  0.20944      ]        superscript  ùê±  1     0.0075    0.002      0.20944       \mathbf{x}^{(1)}=\begin{bmatrix}0.0075\\
 0.002\\
 -0.20944\\
 \end{bmatrix}   evaluating at this value,       F   (   ùê±   (  1  )    )    =   0.5   (     (   -  2.48   )   2   +    (   -  1.00   )   2   +    (  6.28  )   2    )    =  23.306          F   superscript  ùê±  1      0.5     superscript    2.48   2    superscript    1.00   2    superscript  6.28  2          23.306     F\left(\mathbf{x}^{(1)}\right)=0.5((-2.48)^{2}+(-1.00)^{2}+(6.28)^{2})=23.306     The decrease from     F   (   ùê±   (  0  )    )    =  58.456        F   superscript  ùê±  0    58.456    F(\mathbf{x}^{(0)})=58.456   to the next step's value of     F   (   ùê±   (  1  )    )    =  23.306        F   superscript  ùê±  1    23.306    F(\mathbf{x}^{(1)})=23.306   is a sizable decrease in the objective function. Further steps would reduce its value until a solution to the system was found.  Comments  Gradient descent works in spaces of any number of dimensions, even in infinite-dimensional ones. In the latter case the search space is typically a function space , and one calculates the G√¢teaux derivative of the functional to be minimized to determine the descent direction. 3  The gradient descent can take many iterations to compute a local minimum with a required accuracy , if the curvature in different directions is very different for the given function. For such functions, preconditioning , which changes the geometry of the space to shape the function level sets like concentric circles , cures the slow convergence. Constructing and applying preconditioning can be computationally expensive, however.  The gradient descent can be combined with a line search , finding the locally optimal step size   Œ≥   Œ≥   \gamma   on every iteration. Performing the line search can be time-consuming. Conversely, using a fixed small   Œ≥   Œ≥   \gamma   can yield poor convergence.  Methods based on Newton's method and inversion of the Hessian using conjugate gradient techniques can be better alternatives. 4 5 Generally, such methods converge in fewer iterations, but the cost of each iteration is higher. An example is the BFGS method which consists in calculating on every step a matrix by which the gradient vector is multiplied to go into a "better" direction, combined with a more sophisticated line search algorithm, to find the "best" value of    Œ≥  .    Œ≥   \gamma.   For extremely large problems, where the computer memory issues dominate, a limited-memory method such as L-BFGS should be used instead of BFGS or the steepest descent.  Gradient descent can be viewed as Euler's method for solving ordinary differential equations       x  ‚Ä≤    (  t  )    =   -    ‚àá  f    (   x   (  t  )    )            superscript  x  normal-‚Ä≤   t        normal-‚àá  f     x  t       x^{\prime}(t)=-\nabla f(x(t))   of a gradient flow .  A computational example  The gradient descent algorithm is applied to find a local minimum of the function f ( x )= x 4 ‚àí3 x 3 +2, with derivative f '( x )=4 x 3 ‚àí9 x 2 . Here is an implementation in the Python programming language .  # From calculation, we expect that the local minimum occurs at x=9/4 x_old =  0 x_new =  6  # The algorithm starts at x=6 gamma =  0.01  # step size precision =  0.00001  def f_derivative(x): return  4  * x ** 3  -  9  * x ** 2  while  abs (x_new - x_old) > precision:
     x_old = x_new
     x_new = x_old - gamma * f_derivative(x_old) print ( "Local minimum occurs at" , x_new)  The above piece of code has to be modified with regard to step size according to the system at hand and convergence can be made faster by using an adaptive step size. In the above case the step size is not adaptive. It stays at 0.01 in all the directions which can sometimes cause the method to fail by diverging from the minimum.  Extensions  Gradient descent can be extended to handle constraints by including a projection onto the set of constraints. This method is only feasible when the projection is efficiently computable on a computer. Under suitable assumptions, this method converges. This method is a specific case of the forward-backward algorithm for monotone inclusions (which includes convex programming and variational inequalities ). 6  Fast proximal gradient method  Another extension of gradient descent is due to Yurii Nesterov from 1983, 7 and has been subsequently generalized. He provides a simple modification of the algorithm that enables faster convergence for convex problems. Specifically, if the function   F   F   F   is convex and    ‚àá  F     normal-‚àá  F    \nabla F   is Lipschitz , and it is not assumed that   F   F   F   is strongly convex , then the error in the objective value generated at each step   k   k   k   by the gradient descent method will be bounded by     ùí™   (   1  /  k   )       ùí™    1  k     \mathcal{O}(1/k)   . Using the Nesterov acceleration technique, the error decreases at    ùí™   (   1  /   k  2    )       ùí™    1   superscript  k  2      \mathcal{O}(1/k^{2})   . 8  The momentum method  Yet another extension, that reduces the risk of getting stuck in a local minimum, as well as speeds up the convergence considerably in cases where the process would otherwise zig-zag heavily, is the momentum method , which uses a momentum term in analogy to "the mass of Newtonian particles that move through a viscous medium in a conservative force field". 9 This method is often used as an extension to the backpropagation algorithms used to train artificial neural networks . 10 11  See also   Conjugate gradient method  Stochastic gradient descent  Rprop  Delta rule  Wolfe conditions  Preconditioning  BFGS method  Nelder‚ÄìMead method   References   Mordecai Avriel (2003). Nonlinear Programming: Analysis and Methods. Dover Publishing. ISBN 0-486-43227-0.  Jan A. Snyman (2005). Practical Mathematical Optimization: An Introduction to Basic Optimization Theory and Classical and New Gradient-Based Algorithms. Springer Publishing. ISBN 0-387-24348-8    External links   Interactive examples of gradient descent and some step size selection methods  Using gradient descent in C++, Boost, Ublas for linear regression   "  Category:First order methods  Category:Optimization algorithms and methods  Category:Gradient methods  Category:Articles with example Python code     ‚Ü©  ‚Ü©  G. P. Akilov, L. V. Kantorovich, Functional Analysis, Pergamon Pr; 2 Sub edition,ISBN 0-08-023036-9, 1982 ‚Ü©  W. H. Press, S. A. Teukolsky, W. T. Vetterling, B. P. Flannery, Numerical Recipes in C: The Art of Scientific Computing, 2nd Ed., Cambridge University Press, New York, 1992 ‚Ü©  T. Strutz: Data Fitting and Uncertainty (A practical introduction to weighted least squares and beyond). Vieweg+Teubner, Wiesbaden 2011, ISBN 978-3-8348-1022-9. ‚Ü©  P. L. Combettes and J.-C. Pesquet, "Proximal splitting methods in signal processing" , in: Fixed-Point Algorithms for Inverse Problems in Science and Engineering , (H. H. Bauschke, R. S. Burachik , P. L. Combettes, V. Elser, D. R. Luke, and H. Wolkowicz, Editors), pp. 185-212. Springer, New York, 2011. ‚Ü©  Yu. Nesterov, "Introductory Lectures on Convex Optimization. A Basic Course" (Springer, 2004, ISBN 1-4020-7553-7) ‚Ü©  Fast Gradient Methods , lecture notes by Prof. Lieven Vandenberghe for EE236C at UCLA ‚Ü©  ‚Ü©  ‚Ü©  Part of a lecture series for the Coursera online course Neural Networks for Machine Learning . ‚Ü©    