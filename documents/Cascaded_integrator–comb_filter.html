<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1249">Cascaded integrator–comb filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cascaded integrator–comb filter</h1>
<hr/>

<p>In <a href="digital_signal_processing" title="wikilink">digital signal processing</a>, a <strong>cascaded integrator–comb (CIC)</strong> is an optimized class of <a href="finite_impulse_response" title="wikilink">finite impulse response</a> (FIR) filter combined with an <a href="interpolation" title="wikilink">interpolator</a> or <a href="Decimation_(signal_processing)" title="wikilink">decimator</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>A CIC filter consists of one or more <a class="uri" href="integrator" title="wikilink">integrator</a> and <a href="comb_filter" title="wikilink">comb filter</a> pairs. In the case of a decimating CIC, the input signal is fed through one or more cascaded integrators, then a down-sampler, followed by one or more comb sections (equal in number to the number of integrators). An interpolating CIC is simply the reverse of this architecture, with the down-sampler replaced with a zero-stuffer (up-sampler).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="the-cic-filter">The CIC filter</h2>
<figure><b>(Figure)</b>
<figcaption>CIC interpolator by factor R, Hogenauer non-pipelined form</figcaption>
</figure>

<p>CIC filters were invented by <a href="Eugene_B._Hogenauer" title="wikilink">Eugene B. Hogenauer</a>, and are a class of FIR filters used in <a href="multi-rate_digital_signal_processing" title="wikilink">multi-rate digital signal processing</a>. The CIC filter finds applications in interpolation and decimation. Unlike most FIR filters, it has a decimator or interpolator built into the architecture. The figure at the right shows the Hogenauer architecture for a CIC interpolator.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The system function for the composite CIC filter referenced to the high sampling rate, f<sub>s</sub> is:</p>

<p>

<math display="inline" id="Cascaded_integrator–comb_filter:0">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle H(z)
  </annotation>
 </semantics>
</math>


</p>

<p>Where:</p>
<dl>
<dd><em>R</em> = decimation or interpolation ratio
</dd>
<dd><em>M</em> = number of samples per stage (usually 1 but sometimes 2)
</dd>
<dd><em>N</em> = number of stages in filter
</dd>
</dl>

<p>Characteristics of CIC Filters</p>
<ol>
<li>Linear phase response;</li>
<li>Utilize only delay and addition and subtraction; that is, it requires no multiplication operations;</li>
</ol>
<h2 id="cic-as-a-moving-average-filter">CIC as a moving average filter</h2>

<p>A CIC filter is an efficient implementation of a <a href="Finite_impulse_response#Moving_average_example" title="wikilink">moving-average</a> filter. To see this, consider how a moving average filter can be implemented recursively by adding the newest sample 

<math display="inline" id="Cascaded_integrator–comb_filter:1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

 to the previous result 

<math display="inline" id="Cascaded_integrator–comb_filter:2">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n-1]
  </annotation>
 </semantics>
</math>

 and subtracting the oldest sample. Omitting the division by 

<math display="inline" id="Cascaded_integrator–comb_filter:3">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   RM
  </annotation>
 </semantics>
</math>

, we have:</p>

<p>

<math display="inline" id="Cascaded_integrator–comb_filter:4">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y[n]
  </annotation>
 </semantics>
</math>


</p>

<p>The second equality corresponds to a comb (

<math display="inline" id="Cascaded_integrator–comb_filter:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mrow>
        <mi>R</mi>
        <mi>M</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <apply>
         <times></times>
         <ci>R</ci>
         <ci>M</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c[n]=x[n]-x[n-RM]
  </annotation>
 </semantics>
</math>

) followed by an integrator (

<math display="inline" id="Cascaded_integrator–comb_filter:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[n]=y[n-1]+c[n]
  </annotation>
 </semantics>
</math>

). The conventional CIC structure is obtained by cascading 

<math display="inline" id="Cascaded_integrator–comb_filter:7">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


 identical moving average filters, then rearranging the sections to place all integrators first (decimator) or combs first (interpolator). Such rearrangement is possible because both combs and integrators are <a href="LTI_system_theory" title="wikilink">LTI</a>. For an interpolator, the upsampler which normally precedes the interpolation filter can be passed through the comb sections using a <a href="Multi-rate_digital_signal_processing#Noble_identities" title="wikilink">Noble identity</a>, reducing the number of delay elements needed by a factor of 

<math display="inline" id="Cascaded_integrator–comb_filter:8">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

. Similarly, for a decimator, the downsampler which normally follows the decimation filter can be moved before the comb sections.</p>

<p>The equivalence of a CIC to moving average filter allows us to trivially calculate its bit growth as 

<math display="inline" id="Cascaded_integrator–comb_filter:9">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>R</mi>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\log_{2}(RM)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="comparison-with-other-filters">Comparison with other filters</h2>

<p>CIC filters are used in multi-rate processing. An <a href="FIR_filter" title="wikilink">FIR filter</a> is used in a wide array of applications, and can be used in multi-rate processing in conjunction with an interpolator or decimator. CIC filters have low pass frequency characteristics,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> while FIR filters can have <a class="uri" href="low-pass" title="wikilink">low-pass</a>, <a class="uri" href="high-pass" title="wikilink">high-pass</a>, or <a class="uri" href="band-pass" title="wikilink">band-pass</a> frequency characteristics. CIC filters use only addition and subtraction.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> FIR filters use addition, subtraction, but most FIR filters also require multiplication. CIC filters have a specific frequency <a class="uri" href="roll-off" title="wikilink">roll-off</a>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> while low pass FIR filters can have an arbitrarily sharp frequency roll-off.</p>

<p>CIC filters are in general much more economical than general FIR filters,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> but tradeoffs are involved. In cases where only a small amount of interpolation or decimation are needed, FIR filters generally have the advantage. However, when rates change by a factor of 10 or more, achieving a useful FIR filter anti-aliasing stop band requires many FIR taps.</p>

<p>For large rate changes, a CIC has a significant advantage over a FIR filter with respect to architectural and <a href="Computational_complexity_theory" title="wikilink">computational efficiency</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Additionally, CIC filters can typically be reconfigured for different rates by changing nothing more than the decimation/interpolation section assuming the bit width of the integrators and comb sections meets certain mathematical criteria based on the maximum possible rate change.</p>

<p>Whereas a FIR filter can use <a href="Fixed-point_arithmetic" title="wikilink">fixed</a> or <a href="floating_point" title="wikilink">floating point</a> math, a CIC filter uses only fixed point math.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> This is necessary because, as a recursively implemented FIR filter, a CIC filter relies on exact cancellation of poles from the integrator sections by zeros from the comb sections. While the reasons are less than intuitive, an inherent characteristic of the CIC architecture is that if fixed bit length <a href="arithmetic_overflow" title="wikilink">overflows</a> occur in the integrators, they are corrected in the comb sections.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>The range of filter shapes and responses available from a CIC filter is somewhat limited. Larger amounts of <a class="uri" href="stopband" title="wikilink">stopband</a> rejection can be achieved by increasing the number of poles.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> However, doing so requires an increase in <a href="Word_(computer_architecture)" title="wikilink">bit width</a> in the integrator and comb sections which increases filter <a class="uri" href="complexity" title="wikilink">complexity</a>. The shape of the filter response provides even fewer degrees of design freedom.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> For this reason, many real-world filtering requirements cannot be met by a CIC filter alone. However, a CIC filter followed by a short to moderate length FIR or IIR proves highly applicable. Additionally, the FIR filter shape is <a href="normalized_frequency_(digital_signal_processing)" title="wikilink">normalized</a> relative to the CIC's sampling rate at the FIR/CIC interface so one set of FIR coefficients can be used over a range of CIC interpolation and decimation rates.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://dspguru.com/dsp/tutorials/cic-filter-introduction">CIC Filter Introduction</a></li>
<li><a href="http://www.embedded.com/design/configurable-systems/4006446/Understanding-cascaded-integrator-comb-filters">Understanding cascaded integrator–comb filters</a></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Donadio, Matthew (2000) <a href="http://dspguru.com/dsp/tutorials/cic-filter-introduction"><em>CIC Filter Introduction</em></a> "Hogenauer introduced an important class of digital filters called 'Cascaded Integrator-Comb', or 'CIC' for short (also sometimes called 'Hogenauer filters').<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
</ol>
</section>
</body>
</html>
