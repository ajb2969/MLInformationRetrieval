<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="72">Recursive tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Recursive tree</h1>
<hr/>

<p>In <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>recursive tree</strong> (i.e., unordered tree) is a non-planar labeled rooted <a href="tree_(graph_theory)" title="wikilink">tree</a>. A size-<em>n</em> recursive tree is labeled by distinct integers 1, 2, ..., <em>n</em>, where the labels are strictly increasing starting at the root labeled 1. Recursive trees are non-planar, which means that the children of a particular node are not ordered. E.g. the following two size-three recursive trees are the same.</p>
<pre><code>       1          1
      / \   =    / \
     /   \      /   \
    2     3    3     2</code></pre>

<p>Recursive trees also appear in literature under the name Increasing Cayley trees.</p>
<h2 id="properties">Properties</h2>

<p>The number of size-<em>n</em> recursive trees is given by</p>

<p>

<math display="block" id="Recursive_tree:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <factorial></factorial>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{n}=(n-1)!.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Hence the exponential <a href="generating_function" title="wikilink">generating function</a> <em>T</em>(<em>z</em>) of the sequence <em>T</em><sub><em>n</em></sub> is given by</p>

<p>

<math display="block" id="Recursive_tree:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≥</mo>
       <mn>1</mn>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>T</mi>
       <mi>n</mi>
      </msub>
      <mfrac>
       <msup>
        <mi>z</mi>
        <mi>n</mi>
       </msup>
       <mrow>
        <mi>n</mi>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>z</mi>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <factorial></factorial>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(z)=\sum_{n\geq 1}T_{n}\frac{z^{n}}{n!}=\log\left(\frac{1}{1-z}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>Combinatorically a recursive tree can be interpreted as a root followed by an unordered sequence of recursive trees. Let <em>F</em> denote the family of recursive trees.</p>

<p>

<math display="block" id="Recursive_tree:2">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mo>∘</mo>
   <mo>+</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>1</mn>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mfrac>
   <mo>⋅</mo>
   <mo>∘</mo>
   <mo>×</mo>
   <mi>F</mi>
   <mo>+</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>2</mn>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mfrac>
   <mo>⋅</mo>
   <mo>∘</mo>
   <mo>×</mo>
   <mi>F</mi>
   <mo>*</mo>
   <mi>F</mi>
   <mo>+</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>3</mn>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mfrac>
   <mo>⋅</mo>
   <mo>∘</mo>
   <mo>×</mo>
   <mi>F</mi>
   <mo>*</mo>
   <mi>F</mi>
   <mo>*</mo>
   <mi>F</mi>
   <mo>*</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>=</mo>
   <mo>∘</mo>
   <mo>×</mo>
   <mi>exp</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <eq></eq>
    <compose></compose>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <factorial></factorial>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-⋅</ci>
    <compose></compose>
    <times></times>
    <csymbol cd="unknown">F</csymbol>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <factorial></factorial>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-⋅</ci>
    <compose></compose>
    <times></times>
    <csymbol cd="unknown">F</csymbol>
    <times></times>
    <csymbol cd="unknown">F</csymbol>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <factorial></factorial>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <ci>normal-⋅</ci>
    <compose></compose>
    <times></times>
    <csymbol cd="unknown">F</csymbol>
    <times></times>
    <csymbol cd="unknown">F</csymbol>
    <times></times>
    <csymbol cd="unknown">F</csymbol>
    <times></times>
    <ci>normal-⋯</ci>
    <eq></eq>
    <compose></compose>
    <times></times>
    <exp></exp>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=\circ+\frac{1}{1!}\cdot\circ\times F+\frac{1}{2!}\cdot\circ\times F*F+\frac{%
1}{3!}\cdot\circ\times F*F*F*\cdots=\circ\times\exp(F),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Recursive_tree:3">
 <semantics>
  <mo>∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ
  </annotation>
 </semantics>
</math>

 denotes the node labeled by 1, × the Cartesian product and 

<math display="inline" id="Recursive_tree:4">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

 the partition product for labeled objects.</p>

<p>By translation of the formal description one obtains the differential equation for <em>T</em>(<em>z</em>)</p>

<p>

<math display="block" id="Recursive_tree:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>T</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{\prime}(z)=\exp(T(z)),
  </annotation>
 </semantics>
</math>

</p>

<p>with <em>T</em>(0) = 0.</p>
<h2 id="bijections">Bijections</h2>

<p>There are <a href="bijection" title="wikilink">bijective</a> correspondences between recursive trees of size <em>n</em> and <a href="permutation" title="wikilink">permutations</a> of size <em>n</em> − 1.</p>
<h2 id="applications">Applications</h2>

<p>Recursive trees can be generated using a simple stochastic process. Such random recursive trees are used as simple models for epidemics.</p>
<h2 id="references">References</h2>
<ul>
<li><em>Analytic Combinatorics</em>, Philippe Flajolet and Robert Sedgewick, Cambridge University Press, 2008</li>
<li><em>Varieties of Increasing Trees</em>, Francois Bergeron, Philippe Flajolet, and Bruno Salvy. In Proceedings of the 17th Colloquium on Trees in Algebra and Programming, Rennes, France, February 1992. Proceedings published in Lecture Notes in Computer Science vol. 581, J.-C. Raoult Ed., 1992, pp. 24–48.</li>
<li><em>Profile of random trees: correlation and width of random recursive trees and binary search trees</em> Michael Drmota and Hsien-Kuei Hwang, Adv. Appl. Prob., 37, 1-21, 2005.</li>
<li><em>Profiles of random trees: Limit theorems for random recursive trees and binary search trees</em>, Michael Fuchs, Hsien-Kuei Hwang, Ralph Neininger., Algorithmica, 46:3-4, 2006, 367-407, 2006.</li>
</ul>

<p>"</p>

<p><a href="Category:Trees_(graph_theory)" title="wikilink">Category:Trees (graph theory)</a></p>
</body>
</html>
