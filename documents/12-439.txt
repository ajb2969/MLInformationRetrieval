   Overlap–save method      Overlap–save method   Overlap–save is the traditional name for an efficient way to evaluate the discrete convolution between a very long signal    x   [  n  ]       x   delimited-[]  n     x[n]   and a finite impulse response (FIR) filter    h   [  n  ]       h   delimited-[]  n     h[n]    :  {=} \ \sum_{m=-\infty}^{\infty} h[m] \cdot x[n-m] = \sum_{m=1}^{M} h[m] \cdot x[n-m],\,| Eq.1 }}  where h[m]=0 for m outside the region [1, M ].  The concept is to compute short segments of y [ n ] of an arbitrary length L , and concatenate the segments together. Consider a segment that begins at n = kL + M , for any integer k , and define :        x  k    [  n  ]     =  def    {      x   [   n  +   k  L    ]       1  ≤  n  ≤    L  +  M   -  1        0     otherwise  .           superscript   def      subscript  x  k    delimited-[]  n     cases    x   delimited-[]    n    k  L          1  n           L  M   1     0  otherwise     x_{k}[n]\ \stackrel{\mathrm{def}}{=}\begin{cases}x[n+kL]&1\leq n\leq L+M-1\\
 0&\textrm{otherwise}.\end{cases}           y  k    [  n  ]      =  def        x  k    [  n  ]    *  h    [  n  ]        superscript   def      subscript  y  k    delimited-[]  n           subscript  x  k    delimited-[]  n    h    delimited-[]  n      y_{k}[n]\ \stackrel{\mathrm{def}}{=}\ x_{k}[n]*h[n]\,     Then, for kL + M ≤ n ≤ kL + L + M − 1, and equivalently M ≤ n − kL ≤ L + M − 1, we can write :       y   [  n  ]    =     ∑   m  =  1   M       h   [  m  ]    ⋅   x  k     [   n  -   k  L   -  m   ]           y   delimited-[]  n      superscript   subscript     m  1    M      normal-⋅    h   delimited-[]  m     subscript  x  k     delimited-[]    n    k  L   m        \displaystyle y[n]=\sum_{m=1}^{M}h[m]\cdot x_{k}[n-kL-m]     The task is thereby reduced to computing y k [ n ], for M ≤ n ≤ L + M − 1. The process described above is illustrated in the accompanying figure.  Now note that if we periodically extend x k [ n ] with period N ≥ L + M − 1, according to :         x   k  ,  N     [  n  ]      =  def      ∑   ℓ  =   -  ∞    ∞     x  k    [   n  -   ℓ  N    ]      ,      superscript   def      subscript  x   k  N     delimited-[]  n      superscript   subscript     normal-ℓ             subscript  x  k    delimited-[]    n    normal-ℓ  N         x_{k,N}[n]\ \stackrel{\mathrm{def}}{=}\ \sum_{\ell=-\infty}^{\infty}x_{k}[n-%
 \ell N],     the convolutions     (   x   k  ,  N    )   *   h        subscript  x   k  N    h    (x_{k,N})*h\,   and     x  k   *   h        subscript  x  k   h    x_{k}*h\,   are equivalent in the region M ≤ n ≤ L + M − 1. So it is sufficient to compute the N -point circular (or cyclic) convolution of     x  k    [  n  ]        subscript  x  k    delimited-[]  n     x_{k}[n]\,   with    h   [  n  ]       h   delimited-[]  n     h[n]\,   in the region [1, N ].  The subregion [ M , L + M − 1] is appended to the output stream, and the other values are discarded .  The advantage is that the circular convolution can be computed very efficiently as follows, according to the circular convolution theorem :         y  k    [  n  ]    =    DFT   -  1     (     DFT   (    x  k    [  n  ]    )    ⋅  DFT    (   h   [  n  ]    )    )     ,         subscript  y  k    delimited-[]  n       superscript  DFT    1       normal-⋅    DFT     subscript  x  k    delimited-[]  n     DFT     h   delimited-[]  n        y_{k}[n]=\scriptstyle\text{DFT}^{-1}\displaystyle(\ \scriptstyle\text{DFT}%
 \displaystyle(x_{k}[n])\cdot\scriptstyle\text{DFT}\displaystyle(h[n])\ ),     where :   DFT and DFT −1 refer to the Discrete Fourier transform and inverse Discrete Fourier transform, respectively, evaluated over N discrete points, and  N is customarily chosen to be an integer power-of-2, which optimizes the efficiency of the FFT algorithm.  Optimal N is in the range [4M, 8M].   Pseudocode   (''Overlap–save algorithm for linear convolution'') h = FIR_impulse_response
   M = length(h)
   overlap = M-1
   N = 4*overlap (or a nearby power-of-2) step_size = N-overlap
   H = DFT(h, N)
   position = 0
   '''while''' position+N <= length(x)
       yt = IDFT( DFT( x(1+position : N+position), N ) * H, N )
       y(1+position : step_size+position) = yt(M : N)    #discard M-1 y-values
       position = position + step_size
   '''end'''  Efficiency  When the DFT and its inverse is implemented by the FFT algorithm, the pseudocode above requires about N log 2 (N) + N complex multiplications for the FFT, product of arrays, and IFFT. 1 Each iteration produces N-M+1 output samples, so the number of complex multiplications per output sample is about :  For example, when M =201 and N =1024,  equals 13.67, whereas direct evaluation of  would require up to 201 complex multiplications per output sample, the worst case being when both x and h are complex-valued. Also note that for any given M ,  has a minimum with respect to N . It diverges for both small and large block sizes.  Overlap–discard  Overlap–discard 2 and Overlap–scrap 3 are less commonly used labels for the same method described here. However, these labels are actually better (than overlap–save ) to distinguish from overlap–add , because both methods "save", but only one discards. "Save" merely refers to the fact that M − 1 input (or output) samples from segment k are needed to process segment k + 1.  Extending overlap–save  The overlap-save algorithm may be extended to include other common operations of a system: 4 5   additional channels can be processed more cheaply than the first by reusing the forward FFT  sampling rates can be changed by using different sized forward and inverse FFTs  frequency translation (mixing) can be accomplished by rearranging frequency bins   Notes  See also   Overlap–add method   References   Rabiner, Lawrence R.; Gold, Bernard (1975). Theory and application of digital signal processing . Englewood Cliffs, N.J.: Prentice-Hall. pp 65–67. ISBN 0139141014 .  Harris, F.J. (1987). "Time domain signal processing with the DFT". Handbook of Digital Signal Processing , D.F.Elliot, ed., San Diego: Academic Press. pp 633–699. ISBN 0122370759 .  Frerking, Marvin (1994). Digital Signal Processing in Communication Systems . New York: Van Nostrand Reinhold. ISBN 0442016166 .     "  Category:Signal processing  Category:Transforms  Category:Fourier analysis  Category:Numerical analysis     Cooley-Tukey FFT algorithm for N=2 k needs (N/2) log 2 (N) - see FFT - Definition and speed ↩  Harris 1987. ↩  Frerking 1994. ↩  Carlin et al. 1999, p 31, col 20. ↩  Borgerding 2006, pp 158–161. ↩     