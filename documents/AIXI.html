<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="656">AIXI</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>AIXI</h1>
<hr/>

<p><strong>AIXI</strong>  is a <a href="mathematical_formalism" title="wikilink">mathematical formalism</a> for <a href="artificial_general_intelligence" title="wikilink">artificial general intelligence</a>. It combines <a href="Solomonoff_induction" title="wikilink">Solomonoff induction</a> with <a href="Decision_theory" title="wikilink">sequential decision theory</a>. AIXI was first proposed by <a href="Marcus_Hutter" title="wikilink">Marcus Hutter</a> in 2000<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and the results below are proved in Hutter's 2005 book <em>Universal Artificial Intelligence</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>AIXI is a <a href="Reinforcement_learning" title="wikilink">reinforcement learning agent</a>; it maximizes the expected total rewards received from the environment. Intuitively, it simultaneously considers every computable hypothesis. In each time step, it looks at every possible program and evaluates how many rewards that program generates depending on the next action taken. The promised rewards are then weighted by the <a href="Subjective_logic" title="wikilink">subjective belief</a> that this program constitutes the true environment. This belief is computed from the length of the program: longer programs are considered less likely, in line with <a href="Occam's_razor" title="wikilink">Occam's razor</a>. AIXI then selects the action that has the highest expected total reward in the weighted sum of all these programs.</p>
<h2 id="definition">Definition</h2>

<p>The AIXI agent interacts sequentially with some (stochastic and unknown to AIXI) environment 

<math display="inline" id="AIXI:0">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

. In step <em>t</em>, the agent outputs an action 

<math display="inline" id="AIXI:1">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}
  </annotation>
 </semantics>
</math>

 and the environment responds with an observation 

<math display="inline" id="AIXI:2">
 <semantics>
  <msub>
   <mi>o</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{t}
  </annotation>
 </semantics>
</math>

 and a reward 

<math display="inline" id="AIXI:3">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{t}
  </annotation>
 </semantics>
</math>

 distributed according to the conditional probability 

<math display="inline" id="AIXI:4">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>o</mi>
     <mi>t</mi>
    </msub>
    <msub>
     <mi>r</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>o</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <msub>
     <mi>o</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <msub>
     <mi>a</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">μ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>o</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>o</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>o</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu(o_{t}r_{t}|a_{1}o_{1}r_{1}...a_{t-1}o_{t-1}r_{t-1}a_{t})
  </annotation>
 </semantics>
</math>

. Then this cycle repeats for <em>t + 1</em>. The agent tries to maximize cumulative future reward 

<math display="inline" id="AIXI:5">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>t</mi>
   </msub>
   <mo>+</mo>
   <mi mathvariant="normal">…</mi>
   <mo>+</mo>
   <msub>
    <mi>r</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>t</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{t}+\ldots+r_{m}
  </annotation>
 </semantics>
</math>

 for a fixed lifetime <em>m</em>.</p>

<p>Given a current time <em>t</em> and history 

<math display="inline" id="AIXI:6">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>o</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>r</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <msub>
    <mi>o</mi>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <msub>
    <mi>r</mi>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>o</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>o</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}o_{1}r_{1}...a_{t-1}o_{t-1}r_{t-1}
  </annotation>
 </semantics>
</math>

, the action AIXI outputs is defined as<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="AIXI:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>arg</mi>
     <munder>
      <mi>max</mi>
      <msub>
       <mi>a</mi>
       <mi>t</mi>
      </msub>
     </munder>
    </mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>o</mi>
        <mi>t</mi>
       </msub>
       <msub>
        <mi>r</mi>
        <mi>t</mi>
       </msub>
      </mrow>
     </munder>
     <mrow>
      <mi mathvariant="normal">…</mi>
      <munder>
       <mi>max</mi>
       <msub>
        <mi>a</mi>
        <mi>m</mi>
       </msub>
      </munder>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <msub>
          <mi>o</mi>
          <mi>m</mi>
         </msub>
         <msub>
          <mi>r</mi>
          <mi>m</mi>
         </msub>
        </mrow>
       </munder>
       <mrow>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <msub>
           <mi>r</mi>
           <mi>t</mi>
          </msub>
          <mo>+</mo>
          <mi mathvariant="normal">…</mi>
          <mo>+</mo>
          <msub>
           <mi>r</mi>
           <mi>m</mi>
          </msub>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
        <mrow>
         <munder>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <mrow>
           <mi>q</mi>
           <mo rspace="5.3pt">:</mo>
           <mrow>
            <mrow>
             <mi>U</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>q</mi>
              <mo>,</mo>
              <mrow>
               <msub>
                <mi>a</mi>
                <mn>1</mn>
               </msub>
               <mi mathvariant="normal">…</mi>
               <msub>
                <mi>a</mi>
                <mi>m</mi>
               </msub>
              </mrow>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>=</mo>
            <mrow>
             <msub>
              <mi>o</mi>
              <mn>1</mn>
             </msub>
             <msub>
              <mi>r</mi>
              <mn>1</mn>
             </msub>
             <mi mathvariant="normal">…</mi>
             <msub>
              <mi>o</mi>
              <mi>m</mi>
             </msub>
             <msub>
              <mi>r</mi>
              <mi>m</mi>
             </msub>
            </mrow>
           </mrow>
          </mrow>
         </munder>
         <msup>
          <mn>2</mn>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mtext>length</mtext>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>q</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
         </msup>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <arg></arg>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>o</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>o</ci>
          <ci>m</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>m</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <ci>t</ci>
          </apply>
          <ci>normal-…</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <ci>m</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <ci>normal-:</ci>
           <ci>q</ci>
           <apply>
            <eq></eq>
            <apply>
             <times></times>
             <ci>U</ci>
             <interval closure="open">
              <ci>q</ci>
              <apply>
               <times></times>
               <apply>
                <csymbol cd="ambiguous">subscript</csymbol>
                <ci>a</ci>
                <cn type="integer">1</cn>
               </apply>
               <ci>normal-…</ci>
               <apply>
                <csymbol cd="ambiguous">subscript</csymbol>
                <ci>a</ci>
                <ci>m</ci>
               </apply>
              </apply>
             </interval>
            </apply>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>o</ci>
              <cn type="integer">1</cn>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>r</ci>
              <cn type="integer">1</cn>
             </apply>
             <ci>normal-…</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>o</ci>
              <ci>m</ci>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>r</ci>
              <ci>m</ci>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <cn type="integer">2</cn>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <mtext>length</mtext>
            <ci>q</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \arg\max_{a_{t}}\sum_{o_{t}r_{t}}\ldots\max_{a_{m}}\sum_{o_{m}r_{m}}[r_{t}+%
\ldots+r_{m}]\sum_{q:\;U(q,a_{1}\ldots a_{m})=o_{1}r_{1}\ldots o_{m}r_{m}}2^{-%
\textrm{length}(q)},
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>U</em> denotes a <a href="monotone_class_theorem" title="wikilink">monotone</a> <a href="universal_Turing_machine" title="wikilink">universal Turing machine</a>, and <em>q</em> ranges over all programs on the universal machine <em>U</em>.</p>

<p>The parameters to AIXI are the universal Turing machine and the agent's lifetime <em>m</em>. The latter dependence can be removed by the use of discounting.</p>
<h2 id="optimality">Optimality</h2>

<p>AIXI's performance is measured by the expected total number of rewards it receives. AIXI has been proven to be optimal in the following ways.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<ul>
<li><a href="Pareto_optimality" title="wikilink">Pareto optimality</a>: there is no other agent that performs at least as well as AIXI in all environments while performing strictly better in at least one environment.</li>
<li>Balanced Pareto optimality: Like Pareto optimality, but considering a weighted sum of environments.</li>
<li>Self-optimizing: a policy <em>p</em> is called self-optimizing for an environment 

<math display="inline" id="AIXI:8">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 if the performance of <em>p</em> approaches the theoretical maximum for 

<math display="inline" id="AIXI:9">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 when the length of the agent's lifetime (not time) goes to infinity. For environment classes where self-optimizing policies exist, AIXI is self-optimizing.</li>
</ul>

<p>However, AIXI does have limitations. It is restricted to maximizing rewards based off of percepts as opposed to external states. It also assumes it interacts with the environment solely through action and percept channels, preventing it from considering the possibility of being damaged or modified. It also assumes the environment is computable.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Since AIXI is incomputable, it assigns zero probability to its own existence.</p>
<h2 id="computational-aspects">Computational aspects</h2>

<p>Like <a href="Solomonoff_induction" title="wikilink">Solomonoff induction</a>, AIXI is incomputable. However, there are computable approximations of it. One such approximation is AIXI<em>tl</em>, which performs as least as well as the provably best time <em>t</em> and space <em>l</em> limited agent.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Another approximation to AIXI with a restricted environment class is MC-AIXI(FAC-CTW), which has had some success playing simple games such as <a href="Partially_observable_system" title="wikilink">partially observable</a> <a class="uri" href="Pac-Man" title="wikilink">Pac-Man</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Decision_theory" title="wikilink">Category:Decision theory</a> <a href="Category:Statistical_inference" title="wikilink">Category:Statistical inference</a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a class="uri" href="http://hutter1.net/ai/uaibook.htm">http://hutter1.net/ai/uaibook.htm</a><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a class="uri" href="http://www.youtube.com/watch?v=yfsMHtmGDKE">http://www.youtube.com/watch?v=yfsMHtmGDKE</a><a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
