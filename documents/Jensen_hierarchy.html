<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="361">Jensen hierarchy</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Jensen hierarchy</h1>
<hr/>

<p>In <a href="set_theory" title="wikilink">set theory</a>, a mathematical discipline, the <strong>Jensen hierarchy</strong> or <strong>J-hierarchy</strong> is a modification of <a href="Kurt_Gödel" title="wikilink">Gödel</a>'s <a href="constructible_universe" title="wikilink">constructible hierarchy</a>, L, that circumvents certain technical difficulties that exist in the constructible hierarchy. The J-Hierarchy figures prominently in <a href="fine_structure_theory" title="wikilink">fine structure theory</a>, a field pioneered by <a href="Ronald_Jensen" title="wikilink">Ronald Jensen</a>, for whom the Jensen hierarchy is named.</p>
<h2 id="definition">Definition</h2>

<p>As in the definition of <em>L</em>, let Def(<em>X</em>) be the collection of sets definable with parameters over <em>X</em>:</p>
<dl>
<dd>Def(<em>X</em>) = { {<em>y</em> | <em>y</em> ε <em>X</em> and Φ(<em>y</em>, <em>z</em><sub>1</sub>, ..., <em>z</em><sub><em>n</em></sub>) is true in (<em>X</em>, ε)} | Φ is a first order formula and <em>z</em><sub>1</sub>, ..., <em>z</em><sub><em>n</em></sub> are elements of <em>X</em>}.
</dd>
</dl>

<p>The constructible hierarchy, L is defined by <a href="transfinite_recursion" title="wikilink">transfinite recursion</a>. In particular, at successor ordinals, <em>L</em><sub>α+1</sub> = Def(<em>L</em><sub>α</sub>).</p>

<p>The difficulty with this construction is that each of the levels is not closed under the formation of <a href="Axiom_of_pairing" title="wikilink">unordered pairs</a>; for a given x, y ε <em>L</em><sub>α+1</sub> − <em>L</em><sub>α</sub>, the set {<em>x</em>,<em>y</em>} will not be an element of <em>L</em><sub>α+1</sub>, since it is not a subset of <em>L</em><sub>α</sub>.</p>

<p>However, <em>L</em><sub>α</sub> does have the desirable property of being closed under <a href="Lévy_hierarchy" title="wikilink">Σ<sub>0</sub></a> <a href="Axiom_schema_of_separation" title="wikilink">separation</a>.</p>

<p>Jensen's modified hierarchy retains this property and the slightly weaker condition that 

<math display="inline" id="Jensen_hierarchy:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>J</mi>
     <mrow>
      <mi>α</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>∩</mo>
    <mrow>
     <mtext>Pow</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>J</mi>
       <mi>α</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mtext>Def</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>J</mi>
      <mi>α</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>J</ci>
      <apply>
       <plus></plus>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>Pow</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>J</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>Def</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>J</ci>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{\alpha+1}\cap\textrm{Pow}(J_{\alpha})=\textrm{Def}(J_{\alpha})
  </annotation>
 </semantics>
</math>

, but is also closed under pairing. The key technique is to encode hereditarily definable sets over <em>J</em><sub>α</sub> by codes; then <em>J</em><sub>α+1</sub> will contain all sets whose codes are in <em>J</em><sub>α</sub>.</p>

<p>Like <em>L</em><sub>α</sub>, <em>J</em><sub>α</sub> is <a href="recursive_definition" title="wikilink">defined recursively</a>. For each ordinal α, we define 

<math display="inline" id="Jensen_hierarchy:1">
 <semantics>
  <msubsup>
   <mi>W</mi>
   <mi>n</mi>
   <mi>α</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>α</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\alpha}_{n}
  </annotation>
 </semantics>
</math>

 to be a <a href="universal_predicate" title="wikilink">universal</a> Σ<sub>n</sub> predicate for <em>J</em><sub>α</sub>. We encode hereditarily definable sets as 

<math display="inline" id="Jensen_hierarchy:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <msubsup>
      <mi>W</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mi>α</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>e</mi>
      <mo>,</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>α</ci>
     </apply>
     <interval closure="open">
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>e</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <ci>X</ci>
      <interval closure="open">
       <ci>n</ci>
       <ci>f</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>W</ci>
        <ci>α</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <interval closure="open">
       <ci>e</ci>
       <ci>f</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{\alpha}(n+1,e)=\{X(n,f)\mid W^{\alpha}_{n+1}(e,f)\}
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Jensen_hierarchy:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>α</ci>
     </apply>
     <interval closure="open">
      <cn type="integer">0</cn>
      <ci>e</ci>
     </interval>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{\alpha}(0,e)=e
  </annotation>
 </semantics>
</math>

. Then set <em>J</em><sub>α, n</sub> to be {X(n, e) | e in J<sub>α</sub>}. Finally, <em>J</em><sub>α+1</sub> = 

<math display="inline" id="Jensen_hierarchy:4">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
    <mrow>
     <mi>n</mi>
     <mo>∈</mo>
     <mi>ω</mi>
    </mrow>
   </msub>
   <msub>
    <mi>J</mi>
    <mrow>
     <mi>α</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <union></union>
     <apply>
      <in></in>
      <ci>n</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <list>
      <ci>α</ci>
      <ci>n</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigcup_{n\in\omega}J_{\alpha,n}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="properties">Properties</h2>

<p>Each sublevel <em>J</em><sub><em>α</em>, <em>n</em></sub> is transitive and contains all ordinals less than or equal to <em>αω</em> + <em>n</em>. The sequence of sublevels is strictly increasing in <em>n</em>, since a Σ<sub><em>m</em></sub> predicate is also Σ<sub><em>n</em></sub> for any <em>n</em> &gt; <em>m</em>. The levels <em>J</em><sub><em>α</em></sub> will thus be transitive and strictly increasing as well, and are also closed under pairing, Delta-0 comprehension and transitive closure. Moreover, they have the property that</p>

<p>

<math display="block" id="Jensen_hierarchy:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>J</mi>
      <mrow>
       <mi>α</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>∩</mo>
     <mrow>
      <mtext>Pow</mtext>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>J</mi>
        <mi>α</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mtext>Def</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>J</mi>
       <mi>α</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>J</ci>
      <apply>
       <plus></plus>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>Pow</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>J</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>Def</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>J</ci>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{\alpha+1}\cap\text{Pow}(J_{\alpha})=\text{Def}(J_{\alpha}),
  </annotation>
 </semantics>
</math>

</p>

<p>as desired.</p>

<p>The levels and sublevels are themselves Σ<sub>1</sub> uniformly definable [i.e. the definition of <em>J</em><sub><em>α</em>, <em>n</em></sub> in <em>J</em><sub><em>β</em></sub> does not depend on <em>β</em>], and have a uniform Σ<sub>1</sub> well-ordering. Finally, the levels of the Jensen hierarchy satisfy a <a href="condensation_lemma" title="wikilink">condensation lemma</a> much like the levels of Godel's original hierarchy.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="Sy_Friedman" title="wikilink">Sy Friedman</a> (2000) <em>Fine Structure and Class Forcing</em>, Walter de Gruyter, ISBN 3-11-016777-8</li>
</ul>

<p>"</p>

<p><a href="Category:Constructible_universe" title="wikilink">Category:Constructible universe</a></p>
</body>
</html>
