   Resolution proof reduction via local context rewriting      Resolution proof reduction via local context rewriting   In proof theory , an area of mathematical logic , resolution proof reduction via local context rewriting is a technique for resolution proof reduction via local context rewriting . 1 This proof compression method was presented as an algorithm named ReduceAndReconstruct , that operates as a post-processing of resolution proofs.  ReduceAndReconstruct is based on a set of local proof rewriting rules that transform a subproof into an equivalent or stronger one. 2 Each rule is defined to match a specific context.  A context 3 involves two pivots (   p   p   p   and   q   q   q   ) and five clauses (   α   α   \alpha   ,   β   β   \beta   ,   γ   γ   \gamma   ,   δ   δ   \delta   and   η   η   \eta   ). The structure of a context is shown in (). Note that this implies that   p   p   p   is contained in   β   β   \beta   and   γ   γ   \gamma   (with opposite polarity) and   q   q   q   is contained in   δ   δ   \delta   and   α   α   \alpha   (also with opposite polarity).  The table below shows the rewriting rules proposed by Simone et al. . 4 The idea of the algorithm is to reduce proof size by opportunistically applying these rules.      Context   Rule       Case A1     s  ∉  α   ,   t  ∈  γ      formulae-sequence    s  α     t  γ     s\notin\alpha,t\in\gamma                     s  t  C     s  ¯   t  D     t  C  D       var   (  s  )       t  ¯   E     C  D  E       var   (  t  )     ⇒             s  t  C     t  ¯   E     s  C  E       var   (  t  )            t  ¯   E     s  ¯   t  D      s  ¯   D  E       var   (  t  )       C  D  E       var   (  s  )        normal-⇒     continued-fraction      continued-fraction     s  t  C      normal-¯  s   t  D      t  C  D     var  s       normal-¯  t   E      C  D  E     var  t       continued-fraction      continued-fraction     s  t  C      normal-¯  t   E      s  C  E     var  t       continued-fraction      normal-¯  t   E      normal-¯  s   t  D       normal-¯  s   D  E     var  t       C  D  E     var  s      \cfrac{\cfrac{stC\qquad\overline{s}tD}{tCD}\,\operatorname{var}(s)\qquad%
 \overline{t}E}{CDE}\,\operatorname{var}(t)\Rightarrow\cfrac{\cfrac{stC\qquad%
 \overline{t}E}{sCE}\,\operatorname{var}(t)\qquad\cfrac{\overline{t}E\qquad%
 \overline{s}tD}{\overline{s}DE}\,\operatorname{var}(t)}{CDE}\,\operatorname{%
 var}(s)        Case A2     s  ∉  α   ,   t  ∉  γ      formulae-sequence    s  α     t  γ     s\notin\alpha,t\notin\gamma                     s  t  C     s  ¯   D     t  C  D       var   (  s  )       t  ¯   E     C  D  E       var   (  t  )     ⇒             s  t  C     t  ¯   E     s  C  E       var   (  t  )       s  ¯   D     C  D  E       var   (  s  )        normal-⇒     continued-fraction      continued-fraction     s  t  C      normal-¯  s   D      t  C  D     var  s       normal-¯  t   E      C  D  E     var  t       continued-fraction      continued-fraction     s  t  C      normal-¯  t   E      s  C  E     var  t       normal-¯  s   D      C  D  E     var  s      \cfrac{\cfrac{stC\qquad\overline{s}D}{tCD}\,\operatorname{var}(s)\qquad%
 \overline{t}E}{CDE}\,\operatorname{var}(t)\Rightarrow\cfrac{\cfrac{stC\qquad%
 \overline{t}E}{sCE}\,\operatorname{var}(t)\qquad\overline{s}D}{CDE}\,%
 \operatorname{var}(s)        Case B1     s  ∈  α   ,   t  ∈  γ      formulae-sequence    s  α     t  γ     s\in\alpha,t\in\gamma                     s  t  C     s  ¯   t  D     t  C  D       var   (  s  )      s   t  ¯   E     s  C  D  E       var   (  t  )     ⇒        s  t  C    s   t  ¯   E     s  C  E       var   (  t  )        normal-⇒     continued-fraction      continued-fraction     s  t  C      normal-¯  s   t  D      t  C  D     var  s      s   normal-¯  t   E      s  C  D  E     var  t       continued-fraction     s  t  C     s   normal-¯  t   E      s  C  E     var  t      \cfrac{\cfrac{stC\qquad\overline{s}tD}{tCD}\,\operatorname{var}(s)\qquad s%
 \overline{t}E}{sCDE}\,\operatorname{var}(t)\Rightarrow\cfrac{stC\qquad s%
 \overline{t}E}{sCE}\,\operatorname{var}(t)        Case B2     s  ∈  α   ,   t  ∉  γ      formulae-sequence    s  α     t  γ     s\in\alpha,t\notin\gamma                     s  t  C     s  ¯   D     t  D  C       var   (  s  )      s   t  ¯   E     s  C  D  E       var   (  t  )     ⇒             s  t  C    s   t  ¯   E     s  C  E       var   (  t  )       s  ¯   D     C  D  E       var   (  s  )        normal-⇒     continued-fraction      continued-fraction     s  t  C      normal-¯  s   D      t  D  C     var  s      s   normal-¯  t   E      s  C  D  E     var  t       continued-fraction      continued-fraction     s  t  C     s   normal-¯  t   E      s  C  E     var  t       normal-¯  s   D      C  D  E     var  s      \cfrac{\cfrac{stC\qquad\overline{s}D}{tDC}\,\operatorname{var}(s)\qquad s%
 \overline{t}E}{sCDE}\,\operatorname{var}(t)\Rightarrow\cfrac{\cfrac{stC\qquad s%
 \overline{t}E}{sCE}\,\operatorname{var}(t)\qquad\overline{s}D}{CDE}\,%
 \operatorname{var}(s)        Case B3      s  ¯   ∈  α   ,   t  ∉  γ      formulae-sequence     normal-¯  s   α     t  γ     \overline{s}\in\alpha,t\notin\gamma                     s  t  C     s  ¯   D     t  D  C       var   (  s  )       s  ¯    t  ¯   E      s  ¯   C  D  E       var   (  t  )     ⇒    s  ¯   D      normal-⇒     continued-fraction      continued-fraction     s  t  C      normal-¯  s   D      t  D  C     var  s       normal-¯  s    normal-¯  t   E       normal-¯  s   C  D  E     var  t       normal-¯  s   D     \cfrac{\cfrac{stC\qquad\overline{s}D}{tDC}\,\operatorname{var}(s)\qquad%
 \overline{s}\overline{t}E}{\overline{s}CDE}\,\operatorname{var}(t)\Rightarrow%
 \overline{s}D        Case A1'                  s  t  C     s  ¯   t  D     t  C  D       var   (  s  )       t  ¯   E     C  D  E       var   (  t  )     ⇐             s  t  C     t  ¯   E     s  C  E       var   (  t  )            t  ¯   E     s  ¯   t  D      s  ¯   D  E       var   (  t  )       C  D  E       var   (  s  )        normal-⇐     continued-fraction      continued-fraction     s  t  C      normal-¯  s   t  D      t  C  D     var  s       normal-¯  t   E      C  D  E     var  t       continued-fraction      continued-fraction     s  t  C      normal-¯  t   E      s  C  E     var  t       continued-fraction      normal-¯  t   E      normal-¯  s   t  D       normal-¯  s   D  E     var  t       C  D  E     var  s      \cfrac{\cfrac{stC\qquad\overline{s}tD}{tCD}\,\operatorname{var}(s)\qquad%
 \overline{t}E}{CDE}\,\operatorname{var}(t)\Leftarrow\cfrac{\cfrac{stC\qquad%
 \overline{t}E}{sCE}\,\operatorname{var}(t)\qquad\cfrac{\overline{t}E\qquad%
 \overline{s}tD}{\overline{s}DE}\,\operatorname{var}(t)}{CDE}\,\operatorname{%
 var}(s)        Case B2'    t  ∉  γ      t  γ    t\notin\gamma                     s  t  C     s  ¯   D     t  C  D       var   (  s  )      s   t  ¯   E     s  C  D  E       var   (  t  )     ⇒        s  t  C    s   t  ¯   E     s  C  E       var   (  t  )        normal-⇒     continued-fraction      continued-fraction     s  t  C      normal-¯  s   D      t  C  D     var  s      s   normal-¯  t   E      s  C  D  E     var  t       continued-fraction     s  t  C     s   normal-¯  t   E      s  C  E     var  t      \cfrac{\cfrac{stC\qquad\overline{s}D}{tCD}\,\operatorname{var}(s)\qquad s%
 \overline{t}E}{sCDE}\,\operatorname{var}(t)\Rightarrow\cfrac{stC\qquad s%
 \overline{t}E}{sCE}\,\operatorname{var}(t)        The first five rules were introduced in an earlier paper. 5 In addition:   Rule A2 does not perform any reduction on its own. However, it is still useful, because of its "shuffling" effect that can create new opportunities for applying the other rules;  Rule A1 is not used in practice, because it may increase proof size;  Rules B1, B2, B2' and B3 are directly responsible for the reduction, as they produce a transformed root clause stronger than the original one;  The application of a B rule may lead to an illegal proof (see the example below), as some literals missing in the transformed root clause may be involved in another resolution step along the path to the proof root. Therefore, the algorithm also has to "reconstruct" a legal proof when this happen.   The following example 6 shows a situation where the proof becomes illegal after the application of B2' rule:  {\mathbf{qo}}\, p \qquad \mathbf{p \overline{q}}}{\mathbf{po}}\, q \qquad \cfrac{qr \qquad \overline{p} \overline{q}}{\overline{p} r}\, q}{or}\, p \qquad \overline{o} s}{rs}\, o | 2 }}  Applying rule B2' to the highlighted context:  }{\mathbf{p}}\, q \qquad \cfrac{qr \qquad \overline{p} \overline{q}}{\overline{p} r}\, q}{or}\, p \qquad \overline{o} s}{rs}\, o | 3 }}  The proof is now illegal because the literal   o   o   o   is missing from the transformed root clause. To reconstruct the proof, one can remove   o   o   o   together with the last resolution step (that is now redundant). The final result is the following legal (and stronger) proof:  {p}\, q \qquad \cfrac{qr \qquad \overline{p} \overline{q}}{\overline{p} r}\, q}{r}\, p | 4 }}  A further reduction of this proof by applying rule A2 to create a new opportunity to apply rule B2'. 7  There are usually a huge number of contexts where rule A2 may be applied, so an exhaustive approach is not feasible in general. One proposal 8 is to execute ReduceAndReconstruct as a loop with two termination criteria: number of iterations and a timeout (what is reached first). The pseudocode 9 below shows this.  1 function ReduceAndReconstruct(    π   π   \pi     /*  a  proof  */ , timelimit , maxIterations ):  2 for i = 1 to maxIterations  do  3          ReduceAndReconstructLoop();  4 if  time > timelimit  then  //  timeout  5 break ;  6 end  for  7 end  function  ReduceAndReconstruct uses the function ReduceAndReconstructLoop, which is specified below. The first part of the algorithm does a topological ordering of the resolution graph (considering that edges goes from antecedentes to resolvents). This is done to ensure that each node is visited after its antecedents (this way, broken resolution steps are always found and fixed). 10  1 function ReduceAndReconstructLoop(    π   π   \pi     /*  a  proof  */ ):  2 TS = TopologicalSorting(    π   π   \pi    );  3 for  each node    n   n   n     in  TS  4 if     n   n   n    is not a leaf  5 if       n  piv   ∈   n  clause  left        subscript  n  piv    superscript   subscript  n  clause   left     n_{\text{piv}}\in n_{\text{clause}}^{\text{left}}    and       n  piv   ¯   ∈   n  clause  right        normal-¯   subscript  n  piv     superscript   subscript  n  clause   right     \overline{n_{\text{piv}}}\in n_{\text{clause}}^{\text{right}}     then  6     n  clause     subscript  n  clause    n_{\text{clause}}    = Resolution(     n  clause  left     superscript   subscript  n  clause   left    n_{\text{clause}}^{\text{left}}    ,     n  clause  right     superscript   subscript  n  clause   right    n_{\text{clause}}^{\text{right}}    );  7                  Determine left context of    n   n   n    , if any;  8                  Determine right context of    n   n   n    , if any;  9                  Heuristically choose one context (if any) and apply the corresponding rule;  10 else  if       n  piv   ∉   n  clause  left        subscript  n  piv    superscript   subscript  n  clause   left     n_{\text{piv}}\notin n_{\text{clause}}^{\text{left}}    and       n  piv   ¯   ∈   n  clause  right        normal-¯   subscript  n  piv     superscript   subscript  n  clause   right     \overline{n_{\text{piv}}}\in n_{\text{clause}}^{\text{right}}     then  11                  Substitute    n   n   n    with     n  left     superscript  n  left    n^{\text{left}}    ;  12 else  if       n  piv   ∈   n  clause  left        subscript  n  piv    superscript   subscript  n  clause   left     n_{\text{piv}}\in n_{\text{clause}}^{\text{left}}    and       n  piv   ¯   ∉   n  clause  right        normal-¯   subscript  n  piv     superscript   subscript  n  clause   right     \overline{n_{\text{piv}}}\notin n_{\text{clause}}^{\text{right}}     then  13                  Substitute    n   n   n    with     n  right     superscript  n  right    n^{\text{right}}    ;  14 else  if       n  piv   ∉   n  clause  left        subscript  n  piv    superscript   subscript  n  clause   left     n_{\text{piv}}\notin n_{\text{clause}}^{\text{left}}    and       n  piv   ¯   ∉   n  clause  right        normal-¯   subscript  n  piv     superscript   subscript  n  clause   right     \overline{n_{\text{piv}}}\notin n_{\text{clause}}^{\text{right}}     then  15                  Heuristically choose an antecedent     n  left     superscript  n  left    n^{\text{left}}    or     n  right     superscript  n  right    n^{\text{right}}    ;  16                  Substitute    n   n   n    with     n  left     superscript  n  left    n^{\text{left}}    or     n  right     superscript  n  right    n^{\text{right}}    ;  17 end  for  18 end  function  If the input proof is not a tree (in general, resolution graphs are directed acyclic graphs ), then the clause   δ   δ   \delta   of a context may be involved in more than one resolution step. In this case, to ensure that an application of a rewriting rule is not going to interfere with other resolution steps, a safe solution is to create a copy of the node represented by clause   δ   δ   \delta   . 11 This solution increases proof size and some caution is needed when doing this.  The heuristic for rule selection is important to achieve a good compression performance. Simone et al.  12 use the following order of preference for the rules (if applicable to the given context): B2 > B3 > { B2', B1 } > A1' > A2 (X > Y means that X is preferred over Y).  Experiments have shown that ReduceAndReconstruct alone has a worse compression/time ratio than the algorithm RecyclePivots . 13 However, while RecyclePivots can be applied only once to a proof, ReduceAndReconstruct may be applied multiple times to produce a better compression. An attempt to combine ReduceAndReconstruct and RecyclePivots algorithms has led to good results. 14  Notes  "  Category:Proof theory     Simone, S.F. ; Brutomesso, R. ; Sharygina, N. "An Efficient and Flexible Approach to Resolution Proof Reduction". 6th Haifa Verification Conference, 2010. ↩     Bruttomesso, R. ; Rollini, S. ; Sharygina, N.; Tsitovich, A. "Flexible Interpolation with Local Proof Transformations". The International Conference on Computer-Aided Design, 2010. ↩         Bar-Ilan, O. ; Fuhrmann, O. ; Hoory, S. ; Shacham, O. ; Strichman, O. "Linear-Time Reductions of Resolution Proofs". HVC, 2008. ↩      