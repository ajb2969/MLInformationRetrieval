<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1675">Divide-and-conquer eigenvalue algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Divide-and-conquer eigenvalue algorithm</h1>
<hr/>

<p><strong>Divide-and-conquer eigenvalue algorithms</strong> are a class of <a href="eigenvalue_algorithm" title="wikilink">eigenvalue algorithms</a> for <a href="Hermitian_matrix" title="wikilink">Hermitian</a> or <a href="real_number" title="wikilink">real</a> <a href="Symmetric_matrix" title="wikilink">symmetric matrices</a> that have recently (circa 1990s) become competitive in terms of <a href="Numerical_stability" title="wikilink">stability</a> and <a href="Computational_complexity_theory" title="wikilink">efficiency</a> with more traditional algorithms such as the <a href="QR_algorithm" title="wikilink">QR algorithm</a>. The basic concept behind these algorithms is the <a href="Divide_and_conquer_algorithm" title="wikilink">divide-and-conquer</a> approach from <a href="computer_science" title="wikilink">computer science</a>. An <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> problem is divided into two problems of roughly half the size, each of these are solved <a href="Recursion" title="wikilink">recursively</a>, and the eigenvalues of the original problem are computed from the results of these smaller problems.</p>

<p>Here we present the simplest version of a divide-and-conquer algorithm, similar to the one originally proposed by Cuppen in 1981. Many details that lie outside the scope of this article will be omitted; however, without considering these details, the algorithm is not fully stable.</p>
<h2 id="background">Background</h2>

<p>As with most eigenvalue algorithms for Hermitian matrices, divide-and-conquer begins with a reduction to <a href="Tridiagonal_matrix" title="wikilink">tridiagonal</a> form. For an 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:0">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>×</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times m
  </annotation>
 </semantics>
</math>

 matrix, the standard method for this, via <a href="Householder_reflection" title="wikilink">Householder reflections</a>, takes 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:1">
 <semantics>
  <mrow>
   <mfrac>
    <mn>4</mn>
    <mn>3</mn>
   </mfrac>
   <msup>
    <mi>m</mi>
    <mn>3</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{4}{3}m^{3}
  </annotation>
 </semantics>
</math>

 <a class="uri" href="flops" title="wikilink">flops</a>, or 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:2">
 <semantics>
  <mrow>
   <mfrac>
    <mn>8</mn>
    <mn>3</mn>
   </mfrac>
   <msup>
    <mi>m</mi>
    <mn>3</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">8</cn>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{8}{3}m^{3}
  </annotation>
 </semantics>
</math>

 if <a href="eigenvector" title="wikilink">eigenvectors</a> are needed as well. There are other algorithms, such as the <a href="Arnoldi_iteration" title="wikilink">Arnoldi iteration</a>, which may do better for certain classes of matrices; we will not consider this further here.</p>

<p>In certain cases, it is possible to <em>deflate</em> an eigenvalue problem into smaller problems. Consider a <a href="block_diagonal_matrix" title="wikilink">block diagonal matrix</a></p>

<p>

<math display="block" id="Divide-and-conquer_eigenvalue_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>T</mi>
         <mn>1</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>T</mi>
         <mn>2</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\begin{bmatrix}T_{1}&0\\
0&T_{2}\end{bmatrix}.
  </annotation>
 </semantics>
</math>

 The eigenvalues and eigenvectors of 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:4">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 are simply those of 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:5">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:6">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{2}
  </annotation>
 </semantics>
</math>

, and it will almost always be faster to solve these two smaller problems than to solve the original problem all at once. This technique can be used to improve the efficiency of many eigenvalue algorithms, but it has special significance to divide-and-conquer.</p>

<p>For the rest of this article, we will assume the input to the divide-and-conquer algorithm is an 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:7">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>×</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times m
  </annotation>
 </semantics>
</math>

 real symmetric tridiagonal matrix 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:8">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. Although the algorithm can be modified for Hermitian matrices, we do not give the details here.</p>
<h2 id="divide">Divide</h2>

<p>The <em>divide</em> part of the divide-and-conquer algorithm comes from the realization that a tridiagonal matrix is "almost" block diagonal.</p>
<dl>
<dd>
</dd>
</dl>

<p>The size of submatrix 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:9">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}
  </annotation>
 </semantics>
</math>

 we will call 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:10">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

, and then 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:11">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{2}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <mo>-</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <mo>-</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <minus></minus>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m-n)\times(m-n)
  </annotation>
 </semantics>
</math>

. Note that the remark about 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:13">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 being almost block diagonal is true regardless of how 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:14">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is chosen (i.e., there are many ways to so decompose the matrix). However, it makes sense, from an efficiency standpoint, to choose 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:15">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≈</mo>
   <mrow>
    <mi>m</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>n</ci>
    <apply>
     <divide></divide>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\approx m/2
  </annotation>
 </semantics>
</math>

.</p>

<p>We write 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:16">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 as a block diagonal matrix, plus a <a href="Rank_(linear_algebra)" title="wikilink">rank-1</a> correction:</p>
<dl>
<dd>
</dd>
</dl>

<p>The only difference between 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:17">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:18">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>T</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>T</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{T}_{1}
  </annotation>
 </semantics>
</math>

 is that the lower right entry 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:19">
 <semantics>
  <msub>
   <mi>t</mi>
   <mrow>
    <mi>n</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{nn}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:20">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>T</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>T</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{T}_{1}
  </annotation>
 </semantics>
</math>

 has been replaced with 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:21">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mrow>
     <mi>n</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>-</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{nn}-\beta
  </annotation>
 </semantics>
</math>

 and similarly, in 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:22">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>T</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>T</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{T}_{2}
  </annotation>
 </semantics>
</math>

 the top left entry 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:23">
 <semantics>
  <msub>
   <mi>t</mi>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <list>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{n+1,n+1}
  </annotation>
 </semantics>
</math>

 has been replaced with 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:24">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mrow>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </msub>
   <mo>-</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <list>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{n+1,n+1}-\beta
  </annotation>
 </semantics>
</math>

.</p>

<p>The remainder of the divide step is to solve for the eigenvalues (and if desired the eigenvectors) of 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:25">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>T</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>T</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{T}_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:26">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>T</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>T</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{T}_{2}
  </annotation>
 </semantics>
</math>

, that is to find the <a href="diagonalizable_matrix" title="wikilink">diagonalizations</a> 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:27">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>T</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>D</mi>
     <mn>1</mn>
    </msub>
    <msubsup>
     <mi>Q</mi>
     <mn>1</mn>
     <mi>T</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>T</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{T}_{1}=Q_{1}D_{1}Q_{1}^{T}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:28">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>T</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mn>2</mn>
    </msub>
    <msub>
     <mi>D</mi>
     <mn>2</mn>
    </msub>
    <msubsup>
     <mi>Q</mi>
     <mn>2</mn>
     <mi>T</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>T</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{T}_{2}=Q_{2}D_{2}Q_{2}^{T}
  </annotation>
 </semantics>
</math>

. This can be accomplished with recursive calls to the divide-and-conquer algorithm, although practical implementations often switch to the QR algorithm for small enough submatrices.</p>
<h2 id="conquer">Conquer</h2>

<p>The <em>conquer</em> part of the algorithm is the unintuitive part. Given the diagonalizations of the submatrices, calculated above, how do we find the diagonalization of the original matrix?</p>

<p>First, define 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:29">
 <semantics>
  <mrow>
   <msup>
    <mi>z</mi>
    <mi>T</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>q</mi>
     <mn>1</mn>
     <mi>T</mi>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>q</mi>
     <mn>2</mn>
     <mi>T</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>T</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>T</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{T}=(q_{1}^{T},q_{2}^{T})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:30">
 <semantics>
  <msubsup>
   <mi>q</mi>
   <mn>1</mn>
   <mi>T</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{1}^{T}
  </annotation>
 </semantics>
</math>

 is the last row of 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:31">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:32">
 <semantics>
  <msubsup>
   <mi>q</mi>
   <mn>2</mn>
   <mi>T</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{2}^{T}
  </annotation>
 </semantics>
</math>

 is the first row of 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:33">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{2}
  </annotation>
 </semantics>
</math>

. It is now elementary to show that</p>

<p>

<math display="block" id="Divide-and-conquer_eigenvalue_algorithm:34">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>Q</mi>
         <mn>1</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>Q</mi>
         <mn>2</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>D</mi>
           <mn>1</mn>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mi></mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi></mi>
         </mtd>
         <mtd columnalign="center">
          <msub>
           <mi>D</mi>
           <mn>2</mn>
          </msub>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>β</mi>
       <mi>z</mi>
       <msup>
        <mi>z</mi>
        <mi>T</mi>
       </msup>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msubsup>
         <mi>Q</mi>
         <mn>1</mn>
         <mi>T</mi>
        </msubsup>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <msubsup>
         <mi>Q</mi>
         <mn>2</mn>
         <mi>T</mi>
        </msubsup>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">1</cn>
       </apply>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <plus></plus>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>D</ci>
         <cn type="integer">1</cn>
        </apply>
        <csymbol cd="latexml">absent</csymbol>
       </matrixrow>
       <matrixrow>
        <csymbol cd="latexml">absent</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>D</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
      </matrix>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>T</ci>
       </apply>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>T</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\begin{bmatrix}Q_{1}&\\
&Q_{2}\end{bmatrix}\left(\begin{bmatrix}D_{1}&\\
&D_{2}\end{bmatrix}+\beta zz^{T}\right)\begin{bmatrix}Q_{1}^{T}&\\
&Q_{2}^{T}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The remaining task has been reduced to finding the eigenvalues of a diagonal matrix plus a rank-one correction. Before showing how to do this, let us simplify the notation. We are looking for the eigenvalues of the matrix 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:35">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>+</mo>
   <mrow>
    <mi>w</mi>
    <msup>
     <mi>w</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>D</ci>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D+ww^{T}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:36">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is diagonal with distinct entries and 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:37">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 is any vector with nonzero entries.</p>

<p>If w<sub>i</sub> is zero, (

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:38">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i}
  </annotation>
 </semantics>
</math>

,d<sub>i</sub>) is an eigenpair of 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:39">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>+</mo>
   <mrow>
    <mi>w</mi>
    <msup>
     <mi>w</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>D</ci>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D+ww^{T}
  </annotation>
 </semantics>
</math>

 since 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>D</mi>
      <mo>+</mo>
      <mrow>
       <mi>w</mi>
       <msup>
        <mi>w</mi>
        <mi>T</mi>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <ci>D</ci>
       <apply>
        <times></times>
        <ci>w</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>w</ci>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (D+ww^{T})e_{i}=De_{i}=d_{i}e_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:41">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is an eigenvalue, we have:</p>

<p>

<math display="block" id="Divide-and-conquer_eigenvalue_algorithm:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>D</mi>
      <mo>+</mo>
      <mrow>
       <mi>w</mi>
       <msup>
        <mi>w</mi>
        <mi>T</mi>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>q</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>D</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>w</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
     <ci>q</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (D+ww^{T})q=\lambda q
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:43">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is the corresponding eigenvector. Now</p>

<p>

<math display="block" id="Divide-and-conquer_eigenvalue_algorithm:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>D</mi>
       <mo>-</mo>
       <mrow>
        <mi>λ</mi>
        <mi>I</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>q</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>w</mi>
        <mi>T</mi>
       </msup>
       <mi>q</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>D</ci>
       <apply>
        <times></times>
        <ci>λ</ci>
        <ci>I</ci>
       </apply>
      </apply>
      <ci>q</ci>
     </apply>
     <apply>
      <times></times>
      <ci>w</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>w</ci>
        <ci>T</ci>
       </apply>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (D-\lambda I)q+w(w^{T}q)=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Divide-and-conquer_eigenvalue_algorithm:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mo>+</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>D</mi>
        <mo>-</mo>
        <mrow>
         <mi>λ</mi>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>w</mi>
        <mi>T</mi>
       </msup>
       <mi>q</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>q</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>D</ci>
        <apply>
         <times></times>
         <ci>λ</ci>
         <ci>I</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>w</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>w</ci>
        <ci>T</ci>
       </apply>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q+(D-\lambda I)^{-1}w(w^{T}q)=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Divide-and-conquer_eigenvalue_algorithm:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>w</mi>
      <mi>T</mi>
     </msup>
     <mi>q</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>w</mi>
      <mi>T</mi>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>D</mi>
        <mo>-</mo>
        <mrow>
         <mi>λ</mi>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>w</mi>
        <mi>T</mi>
       </msup>
       <mi>q</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>T</ci>
      </apply>
      <ci>q</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>D</ci>
        <apply>
         <times></times>
         <ci>λ</ci>
         <ci>I</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>w</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>w</ci>
        <ci>T</ci>
       </apply>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{T}q+w^{T}(D-\lambda I)^{-1}w(w^{T}q)=0
  </annotation>
 </semantics>
</math>

 Keep in mind that 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:47">
 <semantics>
  <mrow>
   <msup>
    <mi>w</mi>
    <mi>T</mi>
   </msup>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <ci>T</ci>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{T}q
  </annotation>
 </semantics>
</math>

 is a nonzero scalar. Neither 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:48">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 nor 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:49">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 are zero. If 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:50">
 <semantics>
  <mrow>
   <msup>
    <mi>w</mi>
    <mi>T</mi>
   </msup>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <ci>T</ci>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{T}q
  </annotation>
 </semantics>
</math>

 were to be zero, 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:51">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 would be an eigenvector of 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:52">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>D</mi>
      <mo>+</mo>
      <mrow>
       <mi>w</mi>
       <msup>
        <mi>w</mi>
        <mi>T</mi>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>q</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>D</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>w</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
     <ci>q</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (D+ww^{T})q=\lambda q
  </annotation>
 </semantics>
</math>

. If that were the case, 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:54">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 would contain only one nonzero position since 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:55">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is distinct diagonal and thus the inner product 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:56">
 <semantics>
  <mrow>
   <msup>
    <mi>w</mi>
    <mi>T</mi>
   </msup>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <ci>T</ci>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{T}q
  </annotation>
 </semantics>
</math>

 can not be zero after all. Therefore, we have:</p>

<p>

<math display="block" id="Divide-and-conquer_eigenvalue_algorithm:57">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>w</mi>
      <mi>T</mi>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>D</mi>
        <mo>-</mo>
        <mrow>
         <mi>λ</mi>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>w</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>D</ci>
        <apply>
         <times></times>
         <ci>λ</ci>
         <ci>I</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>w</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+w^{T}(D-\lambda I)^{-1}w=0
  </annotation>
 </semantics>
</math>

 or written as a scalar equation,</p>

<p>

<math display="block" id="Divide-and-conquer_eigenvalue_algorithm:58">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </munderover>
     <mfrac>
      <msubsup>
       <mi>w</mi>
       <mi>j</mi>
       <mn>2</mn>
      </msubsup>
      <mrow>
       <msub>
        <mi>d</mi>
        <mi>j</mi>
       </msub>
       <mo>-</mo>
       <mi>λ</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>j</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <ci>j</ci>
        </apply>
        <ci>λ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+\sum_{j=1}^{m}\frac{w_{j}^{2}}{d_{j}-\lambda}=0.
  </annotation>
 </semantics>
</math>

 This equation is known as the <em>secular equation</em>. The problem has therefore been reduced to finding the roots of the <a href="rational_function" title="wikilink">rational function</a> defined by the left-hand side of this equation.</p>

<p>All general eigenvalue algorithms must be iterative, and the divide-and-conquer algorithm is no different. Solving the <a class="uri" href="nonlinear" title="wikilink">nonlinear</a> secular equation requires an iterative technique, such as the <a href="Newton's_method" title="wikilink">Newton–Raphson method</a>. However, each root can be found in <a href="Big_O_notation" title="wikilink">O</a>(1) iterations, each of which requires 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:59">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(m)
  </annotation>
 </semantics>
</math>

 flops (for an 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:60">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-degree rational function), making the cost of the iterative part of this algorithm 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:61">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>m</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(m^{2})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="analysis">Analysis</h2>

<p>As is common for divide and conquer algorithms, we will use the <a href="Master_theorem" title="wikilink">Master theorem</a> to analyze the running time. Remember that above we stated we choose 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:62">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≈</mo>
   <mrow>
    <mi>m</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>n</ci>
    <apply>
     <divide></divide>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\approx m/2
  </annotation>
 </semantics>
</math>

. We can write the <a href="recurrence_relation" title="wikilink">recurrence relation</a>:</p>

<p>

<math display="block" id="Divide-and-conquer_eigenvalue_algorithm:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mo>×</mo>
      <mi>T</mi>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mi>m</mi>
       <mn>2</mn>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>m</mi>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>T</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Θ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(m)=2\times T\left(\frac{m}{2}\right)+\Theta(m^{2})
  </annotation>
 </semantics>
</math>

 In the notation of the Master theorem, 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:64">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mi>b</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=b=2
  </annotation>
 </semantics>
</math>

 and thus 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:65">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>log</mi>
     <mi>b</mi>
    </msub>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <ci>b</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{b}a=1
  </annotation>
 </semantics>
</math>

. Clearly, 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:66">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>m</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>m</mi>
      <mn>1</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Θ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Ω</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(m^{2})=\Omega(m^{1})
  </annotation>
 </semantics>
</math>

, so we have</p>

<p>

<math display="block" id="Divide-and-conquer_eigenvalue_algorithm:67">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>m</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Θ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(m)=\Theta(m^{2})
  </annotation>
 </semantics>
</math>

</p>

<p>Remember that above we pointed out that reducing a Hermitian matrix to tridiagonal form takes 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:68">
 <semantics>
  <mrow>
   <mfrac>
    <mn>4</mn>
    <mn>3</mn>
   </mfrac>
   <msup>
    <mi>m</mi>
    <mn>3</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{4}{3}m^{3}
  </annotation>
 </semantics>
</math>

 flops. This dwarfs the running time of the divide-and-conquer part, and at this point it is not clear what advantage the divide-and-conquer algorithm offers over the QR algorithm (which also takes 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:69">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>m</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(m^{2})
  </annotation>
 </semantics>
</math>

 flops for tridiagonal matrices).</p>

<p>The advantage of divide-and-conquer comes when eigenvectors are needed as well. If this is the case, reduction to tridiagonal form takes 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:70">
 <semantics>
  <mrow>
   <mfrac>
    <mn>8</mn>
    <mn>3</mn>
   </mfrac>
   <msup>
    <mi>m</mi>
    <mn>3</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">8</cn>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{8}{3}m^{3}
  </annotation>
 </semantics>
</math>

, but the second part of the algorithm takes 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:71">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>m</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(m^{3})
  </annotation>
 </semantics>
</math>

 as well. For the QR algorithm with a reasonable target precision, this is 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:72">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≈</mo>
   <mrow>
    <mn>6</mn>
    <msup>
     <mi>m</mi>
     <mn>3</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <cn type="integer">6</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \approx 6m^{3}
  </annotation>
 </semantics>
</math>

, whereas for divide-and-conquer it is 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:73">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≈</mo>
   <mrow>
    <mfrac>
     <mn>4</mn>
     <mn>3</mn>
    </mfrac>
    <msup>
     <mi>m</mi>
     <mn>3</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \approx\frac{4}{3}m^{3}
  </annotation>
 </semantics>
</math>

. The reason for this improvement is that in divide-and-conquer, the 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:74">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>m</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(m^{3})
  </annotation>
 </semantics>
</math>

 part of the algorithm (multiplying 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:75">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 matrices) is separate from the iteration, whereas in QR, this must occur in every iterative step. Adding the 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:76">
 <semantics>
  <mrow>
   <mfrac>
    <mn>8</mn>
    <mn>3</mn>
   </mfrac>
   <msup>
    <mi>m</mi>
    <mn>3</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">8</cn>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{8}{3}m^{3}
  </annotation>
 </semantics>
</math>

 flops for the reduction, the total improvement is from 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:77">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≈</mo>
   <mrow>
    <mn>9</mn>
    <msup>
     <mi>m</mi>
     <mn>3</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <cn type="integer">9</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \approx 9m^{3}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:78">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≈</mo>
   <mrow>
    <mn>4</mn>
    <msup>
     <mi>m</mi>
     <mn>3</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \approx 4m^{3}
  </annotation>
 </semantics>
</math>

 flops.</p>

<p>Practical use of the divide-and-conquer algorithm has shown that in most realistic eigenvalue problems, the algorithm actually does better than this. The reason is that very often the matrices 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:79">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 and the vectors 

<math display="inline" id="Divide-and-conquer_eigenvalue_algorithm:80">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 tend to be <em>numerically sparse</em>, meaning that they have many entries with values smaller than the <a href="floating_point" title="wikilink">floating point</a> precision, allowing for <em>numerical deflation</em>, i.e. breaking the problem into uncoupled subproblems.</p>
<h2 id="variants-and-implementation">Variants and implementation</h2>

<p>The algorithm presented here is the simplest version. In many practical implementations, more complicated rank-1 corrections are used to guarantee stability; some variants even use rank-2 corrections.</p>

<p>There exist specialized root-finding techniques for rational functions that may do better than the Newton-Raphson method in terms of both performance and stability. These can be used to improve the iterative part of the divide-and-conquer algorithm.</p>

<p>The divide-and-conquer algorithm is readily <a href="Parallel_algorithm" title="wikilink">parallelized</a>, and <a href="linear_algebra" title="wikilink">linear algebra</a> computing packages such as <a class="uri" href="LAPACK" title="wikilink">LAPACK</a> contain high-quality parallel implementations.</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a></p>
</body>
</html>
