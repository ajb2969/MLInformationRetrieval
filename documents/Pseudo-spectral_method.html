<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1133">Pseudo-spectral method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Pseudo-spectral method</h1>
<hr/>

<p><strong>Pseudo-spectral methods</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> also known as discrete variable representation (DVR) methods, are a class of <a href="numerical_methods" title="wikilink">numerical methods</a> used in <a href="applied_mathematics" title="wikilink">applied mathematics</a> and <a href="scientific_computing" title="wikilink">scientific computing</a> for the solution of <a href="partial_differential_equation" title="wikilink">partial differential equations</a>. They are closely related to <a href="spectral_method" title="wikilink">spectral methods</a>, but complement the <a href="Basis_(linear_algebra)" title="wikilink">basis</a> by an additional pseudo-spectral basis, which allows to represent functions on a quadrature grid. This simplifies the evaluation of certain operators, and can considerably speed up the calculation when using fast algorithms such as the <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a>.</p>
<h2 id="motivation-with-a-concrete-example">Motivation with a concrete example</h2>

<p>Take the initial-value problem</p>

<p>

<math display="block" id="Pseudo-spectral_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mfrac>
      <mo>∂</mo>
      <mrow>
       <mo>∂</mo>
       <mi>t</mi>
      </mrow>
     </mfrac>
     <mi>ψ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo maxsize="160%" minsize="160%">[</mo>
      <mrow>
       <mrow>
        <mo>-</mo>
        <mfrac>
         <msup>
          <mo>∂</mo>
          <mn>2</mn>
         </msup>
         <mrow>
          <mo>∂</mo>
          <msup>
           <mi>x</mi>
           <mn>2</mn>
          </msup>
         </mrow>
        </mfrac>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo maxsize="160%" minsize="160%">]</mo>
     </mrow>
     <mi>ψ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="42.5pt">,</mo>
   <mrow>
    <mrow>
     <mi>ψ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>ψ</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>i</ci>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>ψ</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <partialdiff></partialdiff>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <partialdiff></partialdiff>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>x</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>V</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <ci>ψ</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ψ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\frac{\partial}{\partial t}\psi(x,t)=\Bigl[-\frac{\partial^{2}}{\partial x^{2%
}}+V(x)\Bigr]\psi(x,t),\qquad\qquad\psi(t_{0})=\psi_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>with periodic conditions 

<math display="inline" id="Pseudo-spectral_method:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <interval closure="open">
      <apply>
       <plus></plus>
       <ci>x</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi(x+2\pi,t)=\psi(x,t)
  </annotation>
 </semantics>
</math>

. This specific example is the <a href="Schrödinger_equation" title="wikilink">Schrödinger equation</a> for a particle in a potential 

<math display="inline" id="Pseudo-spectral_method:2">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(x)
  </annotation>
 </semantics>
</math>

, but the structure is more general. In many practical partial differential equations, one has a term that involves derivatives (such as a kinetic energy contributions), and a multiplication with a function (for example, a potential).</p>

<p>In the spectral method, the solution 

<math display="inline" id="Pseudo-spectral_method:3">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>


 is expanded in a suitable set of basis functions, for example plane waves,</p>

<p>

<math display="block" id="Pseudo-spectral_method:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ψ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
       </mrow>
      </msqrt>
     </mfrac>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>n</mi>
      </munder>
      <mrow>
       <msub>
        <mi>c</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mi>e</mi>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
         <mi>i</mi>
         <mi>n</mi>
         <mi>x</mi>
        </mrow>
       </msup>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>n</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>i</ci>
         <ci>n</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi(x,t)=\frac{1}{\sqrt{2\pi}}\sum_{n}c_{n}(t)e^{2\pi inx}.
  </annotation>
 </semantics>
</math>

</p>

<p>Insertion and equating identical coefficients yields a set of <a href="ordinary_differential_equation" title="wikilink">ordinary differential equations</a> for the coefficients,</p>

<p>

<math display="block" id="Pseudo-spectral_method:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mfrac>
      <mi>d</mi>
      <mrow>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
     <msub>
      <mi>c</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <msub>
       <mi>c</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>k</mi>
      </munder>
      <mrow>
       <msub>
        <mi>V</mi>
        <mrow>
         <mi>n</mi>
         <mi>k</mi>
        </mrow>
       </msub>
       <msub>
        <mi>c</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>i</ci>
     <apply>
      <divide></divide>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>n</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\frac{d}{dt}c_{n}(t)=(2\pi n)^{2}c_{n}+\sum_{k}V_{nk}c_{k},
  </annotation>
 </semantics>
</math>

</p>

<p>where the elements 

<math display="inline" id="Pseudo-spectral_method:6">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>n</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{nk}
  </annotation>
 </semantics>
</math>

 are calculated through the explicit Fourier-transform</p>

<p>

<math display="block" id="Pseudo-spectral_method:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>V</mi>
     <mrow>
      <mi>n</mi>
      <mi>k</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mn>0</mn>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
       </mrow>
      </msubsup>
      <mrow>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
       <msup>
        <mi>e</mi>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
         <mi>i</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>k</mi>
           <mo>-</mo>
           <mi>n</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>x</mi>
        </mrow>
       </msup>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>V</ci>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>i</ci>
         <apply>
          <minus></minus>
          <ci>k</ci>
          <ci>n</ci>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{nk}=\frac{1}{2\pi}\int_{0}^{2\pi}V(x)\ e^{2\pi i(k-n)x}dx.
  </annotation>
 </semantics>
</math>

</p>

<p>The solution would then be obtained by truncating the expansion to 

<math display="inline" id="Pseudo-spectral_method:8">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


 basis functions, and finding a solution for the 

<math display="inline" id="Pseudo-spectral_method:9">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{n}(t)
  </annotation>
 </semantics>
</math>

. In general, this is done by <a href="Numerical_methods_for_ordinary_differential_equations" title="wikilink">numerical methods</a>, such as <a href="Runge–Kutta_methods" title="wikilink">Runge–Kutta methods</a>. For the numerical solutions, the right-hand side of the ordinary differential equation has to be evaluated repeatedly at different time steps. At this point, the spectral method has a major problem with the potential term 

<math display="inline" id="Pseudo-spectral_method:10">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>In the spectral representation, the multiplication with the function 

<math display="inline" id="Pseudo-spectral_method:11">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(x)
  </annotation>
 </semantics>
</math>

 transforms into a vector-matrix multiplication, which scales as 

<math display="inline" id="Pseudo-spectral_method:12">
 <semantics>
  <msup>
   <mi>N</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{2}
  </annotation>
 </semantics>
</math>

. Also, the matrix elements 

<math display="inline" id="Pseudo-spectral_method:13">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>n</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{nk}
  </annotation>
 </semantics>
</math>


 need to be evaluated explicitly before the differential equation for the coefficients can be solved, which requires an additional step.</p>

<p>In the pseudo-spectral method, this term is evaluated differently. Given the coefficients 

<math display="inline" id="Pseudo-spectral_method:14">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{n}(t)
  </annotation>
 </semantics>
</math>

, an inverse discrete Fourier transform yields the value of the function 

<math display="inline" id="Pseudo-spectral_method:15">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 at discrete grid points 

<math display="inline" id="Pseudo-spectral_method:16">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
     <mi>j</mi>
    </mrow>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <ci>j</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}=2\pi j/N
  </annotation>
 </semantics>
</math>

. At these grid points, the function is then multiplied, 

<math display="inline" id="Pseudo-spectral_method:17">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ψ</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ψ</ci>
      <ci>normal-′</ci>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>ψ</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi^{\prime}(x_{i},t)=V(x_{i})\psi(x_{i},t)
  </annotation>
 </semantics>
</math>

, and the result Fourier-transformed back. This yields a new set of coefficients 

<math display="inline" id="Pseudo-spectral_method:18">
 <semantics>
  <mrow>
   <msubsup>
    <mi>c</mi>
    <mi>n</mi>
    <mo>′</mo>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c^{\prime}_{n}(t)
  </annotation>
 </semantics>
</math>


 that are used instead of the matrix product 

<math display="inline" id="Pseudo-spectral_method:19">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mi>k</mi>
   </msub>
   <mrow>
    <msub>
     <mi>V</mi>
     <mrow>
      <mi>n</mi>
      <mi>k</mi>
     </mrow>
    </msub>
    <msub>
     <mi>c</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>k</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k}V_{nk}c_{k}(t)
  </annotation>
 </semantics>
</math>

.</p>

<p>It can be shown that both methods have similar accuracy. However, the pseudo-spectral method allows the use of a fast Fourier transform, which scales as 

<math display="inline" id="Pseudo-spectral_method:20">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mi>ln</mi>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <ln></ln>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N\ln N)
  </annotation>
 </semantics>
</math>

, and is therefore significantly more efficient than the matrix multiplication. Also, the function 

<math display="inline" id="Pseudo-spectral_method:21">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(x)
  </annotation>
 </semantics>
</math>

 can be used directly without evaluating any additional integrals.</p>
<h2 id="technical-discussion">Technical discussion</h2>

<p>In a more abstract way, the pseudo-spectral method deals with the multiplication of two functions 

<math display="inline" id="Pseudo-spectral_method:22">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Pseudo-spectral_method:23">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>


 as part of a partial differential equation. To simplify the notation, the time-dependence is dropped. Conceptually, it consists of three steps:</p>
<ol>
<li>

<math display="inline" id="Pseudo-spectral_method:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-~</ci>
       <ci>f</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </list>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>x</ci>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x),\tilde{f}(x)=V(x)f(x)
  </annotation>
 </semantics>
</math>

 are expanded in a finite set of basis functions (this is the <a href="spectral_method" title="wikilink">spectral method</a>).</li>
<li>For a given set of basis functions, a quadrature is sought that converts scalar products of these basis functions into a weighted sum over grid points.</li>
<li>The product is calculated by multiplying 

<math display="inline" id="Pseudo-spectral_method:25">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>,</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>V</ci>
    <ci>f</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V,f
  </annotation>
 </semantics>
</math>

 at each grid point.</li>
</ol>
<h3 id="expansion-in-a-basis">Expansion in a basis</h3>

<p>The functions 

<math display="inline" id="Pseudo-spectral_method:26">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>,</mo>
   <mover accent="true">
    <mi>f</mi>
    <mo stretchy="false">~</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>f</ci>
    <apply>
     <ci>normal-~</ci>
     <ci>f</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f,\tilde{f}
  </annotation>
 </semantics>
</math>

 can be expanded in a finite basis 

<math display="inline" id="Pseudo-spectral_method:27">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>N</mi>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </set>
    <apply>
     <eq></eq>
     <ci>n</ci>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <ci>N</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\phi_{n}\}_{n=0,\ldots,N}
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Pseudo-spectral_method:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>ϕ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\sum_{n=0}^{N}c_{n}\phi_{n}(x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Pseudo-spectral_method:29">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>c</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>ϕ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>c</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}(x)=\sum_{n=0}^{N}\tilde{c}_{n}\phi_{n}(x)
  </annotation>
 </semantics>
</math>

</p>

<p>For simplicity, let the basis be orthogonal and normalized, 

<math display="inline" id="Pseudo-spectral_method:30">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>δ</mi>
    <mrow>
     <mi>n</mi>
     <mi>m</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>m</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\phi_{n},\phi_{m}\rangle=\delta_{nm}
  </annotation>
 </semantics>
</math>

 using the <a href="inner_product" title="wikilink">inner product</a> 

<math display="inline" id="Pseudo-spectral_method:31">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>g</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>a</mi>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mover accent="true">
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>¯</mo>
     </mover>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>f</ci>
     <ci>g</ci>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f,g\rangle=\int_{a}^{b}f(x)\overline{g(x)}dx
  </annotation>
 </semantics>
</math>

 with appropriate boundaries 

<math display="inline" id="Pseudo-spectral_method:32">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b
  </annotation>
 </semantics>
</math>

. The coefficients are then obtained by</p>

<p>

<math display="block" id="Pseudo-spectral_method:33">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>f</mi>
    <mo>,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
    <list>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{n}=\langle f,\phi_{n}\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Pseudo-spectral_method:34">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>c</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>c</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <list>
     <apply>
      <ci>normal-~</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{c}_{n}=\langle\tilde{f},\phi_{n}\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>A bit of calculus yields then</p>

<p>

<math display="block" id="Pseudo-spectral_method:35">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>c</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>m</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>n</mi>
       <mi>m</mi>
      </mrow>
     </msub>
     <msub>
      <mi>c</mi>
      <mi>m</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>c</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>m</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{c}_{n}=\sum_{m=0}^{N}V_{nm}c_{m}
  </annotation>
 </semantics>
</math>

</p>

<p>with 

<math display="inline" id="Pseudo-spectral_method:36">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>n</mi>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>V</mi>
     <msub>
      <mi>ϕ</mi>
      <mi>m</mi>
     </msub>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <list>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{nm}=\langle V\phi_{m},\phi_{n}\rangle
  </annotation>
 </semantics>
</math>

. This forms the basis of the spectral method. To distinguish the basis of the 

<math display="inline" id="Pseudo-spectral_method:37">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{n}
  </annotation>
 </semantics>
</math>

 from the quadrature basis, the expansion is sometimes called Finite Basis Representation (FBR).</p>
<h3 id="quadrature">Quadrature</h3>

<p>For a given basis 

<math display="inline" id="Pseudo-spectral_method:38">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>ϕ</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\phi_{n}\}
  </annotation>
 </semantics>
</math>


 and number of 

<math display="inline" id="Pseudo-spectral_method:39">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N+1
  </annotation>
 </semantics>
</math>

 basis functions, one can try to find a quadrature, i.e., a set of 

<math display="inline" id="Pseudo-spectral_method:40">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N+1
  </annotation>
 </semantics>
</math>

 points and weights such that</p>

<p>

<math display="block" id="Pseudo-spectral_method:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>ϕ</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>ϕ</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi>N</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>w</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>ϕ</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mover accent="true">
        <mrow>
         <msub>
          <mi>ϕ</mi>
          <mi>m</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>¯</mo>
       </mover>
      </mrow>
     </mrow>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>m</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>N</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>m</ci>
      </apply>
     </list>
     <list>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϕ</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <ci>normal-¯</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ϕ</ci>
           <ci>m</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>n</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <ci>m</ci>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <ci>N</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\phi_{n},\phi_{m}\rangle=\sum_{i=0}^{N}w_{i}\phi_{n}(x_{i})\overline{%
\phi_{m}(x_{i})}\qquad\qquad n,m=0,\ldots,N
  </annotation>
 </semantics>
</math>

</p>

<p>Special examples are the <a href="Gaussian_quadrature" title="wikilink">Gaussian quadrature</a> for polynomials and the <a href="Discrete_Fourier_Transform" title="wikilink">Discrete Fourier Transform</a> for plane waves. It should be stressed that the grid points and weights, 

<math display="inline" id="Pseudo-spectral_method:42">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i},w_{i}
  </annotation>
 </semantics>
</math>

 are a function of the basis <em>and</em> the number 

<math display="inline" id="Pseudo-spectral_method:43">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


.</p>

<p>The quadrature allows an alternative numerical representation of the function 

<math display="inline" id="Pseudo-spectral_method:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x),\tilde{f}(x)
  </annotation>
 </semantics>
</math>

 through their value at the grid points. This representation is sometimes denoted Discrete Variable Representation (DVR), and is completely equivalent to the expansion in the basis.</p>

<p>

<math display="block" id="Pseudo-spectral_method:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>ϕ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i})=\sum_{n=0}^{N}c_{n}\phi_{n}(x_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Pseudo-spectral_method:46">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>f</mi>
    <mo>,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mover accent="true">
      <mrow>
       <msub>
        <mi>ϕ</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>¯</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>n</ci>
     </apply>
     <list>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <ci>normal-¯</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ϕ</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{n}=\langle f,\phi_{n}\rangle=\sum_{n=0}^{N}w_{i}f(x_{i})\overline{\phi_{n}(%
x_{i})}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="multiplication">Multiplication</h3>

<p>The multiplication with the function 

<math display="inline" id="Pseudo-spectral_method:47">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(x)
  </annotation>
 </semantics>
</math>

 is then done at each grid point,</p>

<p>

<math display="block" id="Pseudo-spectral_method:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}(x_{i})=V(x_{i})f(x_{i}).
  </annotation>
 </semantics>
</math>

</p>

<p>This generally introduces an additional approximation. To see this, we can calculate one of the coefficients 

<math display="inline" id="Pseudo-spectral_method:49">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>c</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>c</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{c}_{n}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Pseudo-spectral_method:50">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>c</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mover accent="true">
      <mrow>
       <msub>
        <mi>ϕ</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>¯</mo>
     </mover>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mover accent="true">
      <mrow>
       <msub>
        <mi>ϕ</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>¯</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>c</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <list>
      <apply>
       <ci>normal-~</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <ci>normal-~</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <ci>normal-¯</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ϕ</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>i</ci>
       </apply>
       <ci>V</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <ci>normal-¯</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ϕ</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{c}_{n}=\langle\tilde{f},\phi_{n}\rangle=\sum_{i}w_{i}\tilde{f}(x_{i})%
\overline{\phi_{n}(x_{i})}=\sum_{i}w_{i}V(x_{i})f(x_{i})\overline{\phi_{n}(x_{%
i})}
  </annotation>
 </semantics>
</math>

</p>

<p>However, using the spectral method, the same coefficient would be 

<math display="inline" id="Pseudo-spectral_method:51">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>c</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>V</mi>
     <mi>f</mi>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>c</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <list>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{c}_{n}=\langle Vf,\phi_{n}\rangle
  </annotation>
 </semantics>
</math>

. The pseudo-spectral method thus introduces the additional approximation</p>

<p>

<math display="block" id="Pseudo-spectral_method:52">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>V</mi>
      <mi>f</mi>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>ϕ</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msub>
       <mi>w</mi>
       <mi>i</mi>
      </msub>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mover accent="true">
       <mrow>
        <msub>
         <mi>ϕ</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>¯</mo>
      </mover>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <list>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϕ</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Vf,\phi_{n}\rangle\approx\sum_{i}w_{i}V(x_{i})f(x_{i})\overline{\phi_{%
n}(x_{i})}.
  </annotation>
 </semantics>
</math>

</p>

<p>If the product 

<math display="inline" id="Pseudo-spectral_method:53">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Vf
  </annotation>
 </semantics>
</math>


 can be represented with the given finite set of basis functions, the above equation is exact due to the chosen quadrature.</p>
<h2 id="special-pseudospectral-schemes">Special pseudospectral schemes</h2>
<h3 id="the-fourier-method">The Fourier method</h3>

<p>If periodic boundary conditions with period 

<math display="inline" id="Pseudo-spectral_method:54">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi>L</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <ci>L</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,L]
  </annotation>
 </semantics>
</math>

 are imposed on the system, the basis functions can be generated by plane waves,</p>

<p>

<math display="block" id="Pseudo-spectral_method:55">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mi>L</mi>
     </msqrt>
    </mfrac>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>ı</mi>
       <msub>
        <mi>k</mi>
        <mi>n</mi>
       </msub>
       <mi>x</mi>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <ci>L</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>ı</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <ci>n</ci>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{n}(x)=\frac{1}{\sqrt{L}}e^{-\imath k_{n}x}
  </annotation>
 </semantics>
</math>

</p>

<p>with 

<math display="inline" id="Pseudo-spectral_method:56">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo stretchy="false">⌈</mo>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">⌉</mo>
     </mrow>
     <mn>2</mn>
     <mi>π</mi>
    </mrow>
    <mo>/</mo>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <ceiling></ceiling>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
      <ci>π</ci>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{n}=(-1)^{n}\lceil n/2\rceil 2\pi/L
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Pseudo-spectral_method:57">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list></list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\rceil
  </annotation>
 </semantics>
</math>

 is the <a href="ceiling_function" title="wikilink">ceiling function</a>.</p>

<p>The quadrature for a cut-off at 

<math display="inline" id="Pseudo-spectral_method:58">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mtext>max</mtext>
   </msub>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <mtext>max</mtext>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{\text{max}}=N
  </annotation>
 </semantics>
</math>


 is given by the <a href="discrete_Fourier_transformation" title="wikilink">discrete Fourier transformation</a>. The grid points are equally spaced, 

<math display="inline" id="Pseudo-spectral_method:59">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>i</mi>
    <mi mathvariant="normal">Δ</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>normal-Δ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=i\Delta x
  </annotation>
 </semantics>
</math>

 with spacing 

<math display="inline" id="Pseudo-spectral_method:60">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>L</ci>
     <apply>
      <plus></plus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta x=L/(N+1)
  </annotation>
 </semantics>
</math>

, and the constant weights are 

<math display="inline" id="Pseudo-spectral_method:61">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}=\Delta x
  </annotation>
 </semantics>
</math>

.</p>

<p>For the discussion of the error, note that the product of two plane waves is again a plane wave, 

<math display="inline" id="Pseudo-spectral_method:62">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mi>a</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>b</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>ϕ</mi>
    <mi>c</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{a}+\phi_{b}=\phi_{c}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Pseudo-spectral_method:63">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>≤</mo>
   <mrow>
    <mi>a</mi>
    <mo>+</mo>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>c</ci>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\leq a+b
  </annotation>
 </semantics>
</math>


. Thus, qualitatively, if the functions 

<math display="inline" id="Pseudo-spectral_method:64">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>x</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x),V(x)
  </annotation>
 </semantics>
</math>

 can be represented sufficiently accurately with 

<math display="inline" id="Pseudo-spectral_method:65">
 <semantics>
  <mrow>
   <msub>
    <mi>N</mi>
    <mi>f</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>N</mi>
    <mi>V</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <ci>V</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{f},N_{V}
  </annotation>
 </semantics>
</math>

 basis functions, the pseudo-spectral method gives accurate results if 

<math display="inline" id="Pseudo-spectral_method:66">
 <semantics>
  <mrow>
   <msub>
    <mi>N</mi>
    <mi>f</mi>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>N</mi>
    <mi>V</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{f}+N_{V}
  </annotation>
 </semantics>
</math>

 basis functions are used.</p>

<p>An expansion in plane waves often has a poor quality and needs many basis functions to converge. However, the transformation between the basis expansion and the grid representation can be done using a <a href="Fast_Fourier_transform" title="wikilink">Fast Fourier transform</a>, which scales favorably as 

<math display="inline" id="Pseudo-spectral_method:67">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mi>ln</mi>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <apply>
     <ln></ln>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\ln N
  </annotation>
 </semantics>
</math>

. As a consequence, plane waves are one of the most common expansion that is encountered with pseudo-spectral methods.</p>
<h3 id="polynomials">Polynomials</h3>

<p>Another common expansion is into classical polynomials. Here, the <a href="Gaussian_quadrature" title="wikilink">Gaussian quadrature</a> is used, which states that one can always find weights 

<math display="inline" id="Pseudo-spectral_method:68">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>


 and points 

<math display="inline" id="Pseudo-spectral_method:69">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Pseudo-spectral_method:70">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>a</mi>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>i</mi>
     </msub>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>x</ci>
      <ci>p</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{a}^{b}w(x)p(x)dx=\sum_{i=0}^{N}w_{i}p(x_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>holds for any polynomial 

<math display="inline" id="Pseudo-spectral_method:71">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

 of degree 

<math display="inline" id="Pseudo-spectral_method:72">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>N</mi>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>N</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2N+1
  </annotation>
 </semantics>
</math>

 or less. Typically, the weight function 

<math display="inline" id="Pseudo-spectral_method:73">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(x)
  </annotation>
 </semantics>
</math>


 and ranges 

<math display="inline" id="Pseudo-spectral_method:74">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b
  </annotation>
 </semantics>
</math>

 are chosen for a specific problem, and leads to one of the different forms of the quadrature. To apply this to the pseudo-spectral method, we choose basis functions 

<math display="inline" id="Pseudo-spectral_method:75">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msqrt>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
    <msub>
     <mi>P</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <ci>w</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{n}(x)=\sqrt{w(x)}P_{n}(x)
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Pseudo-spectral_method:76">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{n}
  </annotation>
 </semantics>
</math>

 being a polynomial of degree 

<math display="inline" id="Pseudo-spectral_method:77">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 with the property</p>

<p>

<math display="block" id="Pseudo-spectral_method:78">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>a</mi>
      <mi>b</mi>
     </msubsup>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>P</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>P</mi>
       <mi>m</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>δ</mi>
     <mrow>
      <mi>m</mi>
      <mi>n</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>m</ci>
      </apply>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{a}^{b}w(x)P_{n}(x)P_{m}(x)dx=\delta_{mn}.
  </annotation>
 </semantics>
</math>

</p>

<p>Under these conditions, the 

<math display="inline" id="Pseudo-spectral_method:79">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{n}
  </annotation>
 </semantics>
</math>

 form an orthonormal basis with respect to the scalar product 

<math display="inline" id="Pseudo-spectral_method:80">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>g</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>a</mi>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mover accent="true">
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>¯</mo>
     </mover>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>f</ci>
     <ci>g</ci>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f,g\rangle=\int_{a}^{b}f(x)\overline{g(x)}dx
  </annotation>
 </semantics>
</math>

. This basis, together with the quadrature points can then be used for the pseudo-spectral method.</p>

<p>For the discussion of the error, note that if 

<math display="inline" id="Pseudo-spectral_method:81">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is well represented by 

<math display="inline" id="Pseudo-spectral_method:82">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{f}
  </annotation>
 </semantics>
</math>

 basis functions and 

<math display="inline" id="Pseudo-spectral_method:83">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>


 is well represented by a polynomial of degree 

<math display="inline" id="Pseudo-spectral_method:84">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>V</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{V}
  </annotation>
 </semantics>
</math>

, their product can be expanded in the first 

<math display="inline" id="Pseudo-spectral_method:85">
 <semantics>
  <mrow>
   <msub>
    <mi>N</mi>
    <mi>f</mi>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>N</mi>
    <mi>V</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{f}+N_{V}
  </annotation>
 </semantics>
</math>

 basis functions, and the pseudo-spectral method will give accurate results for that many basis functions.</p>

<p>Such polynomials occur naturally in several standard problems. For example, the quantum harmonic oscillator is ideally expanded in Hermite polynomials, and Jacobi-polynomials can be used to define the associated Legendre functions typically appearing in rotational problems.</p>
<h2 id="references">References</h2>
<ul>
<li>Steven A. Orszag (1969) <em>Numerical Methods for the Simulation of Turbulence</em>, Phys. Fluids Supp. II, 12, 250-257</li>
<li>D. Gottlieb and S. Orzag (1977) "Numerical Analysis of Spectral Methods : Theory and Applications", SIAM, Philadelphia, PA</li>
<li>J. Hesthaven, S. Gottlieb and D. Gottlieb (2007) "Spectral methods for time-dependent problems", Cambridge UP, Cambridge, UK</li>
<li>Lloyd N. Trefethen (2000) <em>Spectral Methods in MATLAB.</em> SIAM, Philadelphia, PA</li>
<li>Bengt Fornberg (1996) <em>A Practical Guide to Pseudospectral Methods.</em> Cambridge University Press, Cambridge, UK</li>
<li><a href="http://www-personal.umich.edu/~jpboyd/BOOK_Spectral2000.html">Chebyshev and Fourier Spectral Methods</a> by John P. Boyd.</li>
<li><a href="http://cdm.unimo.it/home/matematica/funaro.daniele/bube.htm">Polynomial Approximation of Differential Equations</a>, by Daniele Funaro, Lecture Notes in Physics, Volume 8, Springer-Verlag, Heidelberg 1992</li>
<li>Javier de Frutos, Julia Novo: <a href="http://epubs.siam.org/sam-bin/dbq/article/35198">A Spectral Element Method for the Navier--Stokes Equations with Improved Accuracy</a></li>
<li>Canuto C., <a href="M._Yousuff_Hussaini" title="wikilink">Hussaini M. Y.</a>, Quarteroni A., and Zang T.A. (2006) <em>Spectral Methods. Fundamentals in Single Domains.</em> Springer-Verlag, Berlin Heidelberg</li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
