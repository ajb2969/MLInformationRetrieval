<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1633">Range concatenation grammars</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Range concatenation grammars</h1>
<hr/>

<p><strong>Range concatenation grammar</strong> (RCG) is a grammar formalism developed by Pierre Boullier <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in 1998 as an attempt to characterize a number of phenomena of natural language, such as Chinese numbers and German word order scrambling, which are outside the bounds of the <a href="Mildly_context-sensitive_language" title="wikilink">Mildly context-sensitive languages</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>From a theoretical point of view, any language that can be parsed in <a href="PTIME" title="wikilink">polynomial time</a> belongs to the subset of RCG called positive range concatenation grammars, and reciprocally.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Though intended as a variant on Groenink's <a href="Literal_movement_grammar" title="wikilink">Literal movement grammars</a>, RCGs treat the grammatical process more as a proof than as a production. Whereas LMGs produce a terminal string from a start predicate, RCGs aim to reduce a start predicate (which predicates of a terminal string) to the empty string, which constitutes a proof of the terminal strings membership in the language.</p>
<h2 id="description">Description</h2>
<h3 id="formal-definition">Formal definition</h3>

<p>A <strong>Positive Range Concatenation Grammar</strong> (PRCG) is a tuple 

<math display="inline" id="Range_concatenation_grammars:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo rspace="5.8pt">,</mo>
    <mi>T</mi>
    <mo rspace="5.8pt">,</mo>
    <mi>V</mi>
    <mo rspace="5.8pt">,</mo>
    <mi>S</mi>
    <mo rspace="5.8pt">,</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <vector>
     <ci>N</ci>
     <ci>T</ci>
     <ci>V</ci>
     <ci>S</ci>
     <ci>P</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(N,~{}T,~{}V,~{}S,~{}P)
  </annotation>
 </semantics>
</math>

, where:</p>
<ul>
<li>

<math display="inline" id="Range_concatenation_grammars:1">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Range_concatenation_grammars:2">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Range_concatenation_grammars:3">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 are disjoint finite sets of (respectively) <em>predicate names</em>, <em>terminal symbols</em> and <em>variable names</em>. Each predicate name has an associated arity given by the function 

<math display="inline" id="Range_concatenation_grammars:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>i</mi>
    <mi>m</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>N</mi>
    <mo>→</mo>
    <mrow>
     <mi>ℕ</mi>
     <mo>∖</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>i</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>N</ci>
     <apply>
      <setdiff></setdiff>
      <ci>ℕ</ci>
      <set>
       <cn type="integer">0</cn>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dim:N\rightarrow\mathbb{N}\setminus\{0\}
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Range_concatenation_grammars:5">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>∈</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>S</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\in N
  </annotation>
 </semantics>
</math>

 is the start predicate name and verify 

<math display="inline" id="Range_concatenation_grammars:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>i</mi>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>i</ci>
     <ci>m</ci>
     <ci>S</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dim(S)=1
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Range_concatenation_grammars:7">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is a finite set of <em>clauses</em> of the form 

<math display="inline" id="Range_concatenation_grammars:8">
 <semantics>
  <mrow>
   <msub>
    <mi>ψ</mi>
    <mn>0</mn>
   </msub>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>ψ</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>ψ</mi>
     <mi>m</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi_{0}\rightarrow\psi_{1}\ldots\psi_{m}
  </annotation>
 </semantics>
</math>

, where the 

<math display="inline" id="Range_concatenation_grammars:9">
 <semantics>
  <msub>
   <mi>ψ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ψ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi_{i}
  </annotation>
 </semantics>
</math>

 are <em>predicates</em> of the form 

<math display="inline" id="Range_concatenation_grammars:10">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>α</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>α</mi>
     <mrow>
      <mi>d</mi>
      <mi>i</mi>
      <mi>m</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>A</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>i</ci>
       <ci>m</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}(\alpha_{1},\ldots,\alpha_{dim(A_{i})})
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Range_concatenation_grammars:11">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}\in N
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Range_concatenation_grammars:12">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mo>∪</mo>
      <mi>V</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋆</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <union></union>
      <ci>T</ci>
      <ci>V</ci>
     </apply>
     <ci>normal-⋆</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}\in(T\cup V)^{\star}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>A <strong>Negative Range Concatenation Grammar</strong> (NRCG) is defined like a PRCG, but with the addition that some predicates occurring in the right-hand side of a clause can have the form 

<math display="inline" id="Range_concatenation_grammars:13">
 <semantics>
  <mover accent="true">
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>α</mi>
      <mrow>
       <mi>d</mi>
       <mi>i</mi>
       <mi>m</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>A</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>i</ci>
        <ci>m</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{A_{i}(\alpha_{1},\ldots,\alpha_{dim(A_{i})})}
  </annotation>
 </semantics>
</math>

. Such predicates are called <em>negative predicates</em>.</p>

<p>A <strong>Range Concatenation Grammar</strong> is a positive or a negative one. Although PRCGs are technically NRCGs, the terms are used to highlight the absence (PRCG) or presence (NRCG) of negative predicates.</p>

<p>A <strong>range</strong> in a word 

<math display="inline" id="Range_concatenation_grammars:14">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∈</mo>
   <msup>
    <mi>T</mi>
    <mo>⋆</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>w</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>normal-⋆</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in T^{\star}
  </annotation>
 </semantics>
</math>

 is a couple 

<math display="inline" id="Range_concatenation_grammars:15">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>l</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>w</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <list>
     <ci>l</ci>
     <ci>r</ci>
    </list>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle l,r\rangle_{w}
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Range_concatenation_grammars:16">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>l</mi>
   <mo>≤</mo>
   <mi>r</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>l</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>r</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq l\leq r\leq n
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Range_concatenation_grammars:17">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the length of 

<math display="inline" id="Range_concatenation_grammars:18">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. Two ranges 

<math display="inline" id="Range_concatenation_grammars:19">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>l</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>w</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>l</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle l_{1},r_{1}\rangle_{w}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Range_concatenation_grammars:20">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>l</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>r</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>w</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>l</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle l_{2},r_{2}\rangle_{w}
  </annotation>
 </semantics>
</math>

 can be concatenated iff 

<math display="inline" id="Range_concatenation_grammars:21">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>l</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{1}=l_{2}
  </annotation>
 </semantics>
</math>

, and we then have

<math display="block" id="Range_concatenation_grammars:22">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>l</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>r</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>w</mi>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>l</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>r</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>w</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>l</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>r</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>w</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>l</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
      <ci>w</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>l</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">2</cn>
       </apply>
      </list>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
     </list>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle l_{1},r_{1}\rangle_{w}\cdot\langle l_{2},r_{2}\rangle_{w}=\langle l_{1%
},r_{2}\rangle_{w}
  </annotation>
 </semantics>
</math>

.</p>

<p>For a word 

<math display="inline" id="Range_concatenation_grammars:23">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>w</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>w</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>w</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=w_{1}w_{2}\ldots w_{n}
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Range_concatenation_grammars:24">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}\in T
  </annotation>
 </semantics>
</math>

, the <strong>dotted notation</strong> for ranges is

<math display="block" id="Range_concatenation_grammars:25">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>l</mi>
     <mo>,</mo>
     <mi>r</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>w</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mi>w</mi>
         <mn>1</mn>
        </msub>
        <mi mathvariant="normal">…</mi>
        <msub>
         <mi>w</mi>
         <mrow>
          <mi>l</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
       <mo>∙</mo>
       <msub>
        <mi>w</mi>
        <mi>l</mi>
       </msub>
      </mrow>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>w</mi>
       <mrow>
        <mi>r</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mo>∙</mo>
     <msub>
      <mi>w</mi>
      <mi>r</mi>
     </msub>
    </mrow>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>w</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <ci>l</ci>
      <ci>r</ci>
     </list>
     <ci>w</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∙</ci>
      <apply>
       <times></times>
       <apply>
        <ci>normal-∙</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <apply>
           <minus></minus>
           <ci>l</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>l</ci>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <apply>
         <minus></minus>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>r</ci>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle l,r\rangle_{w}=w_{1}\ldots w_{l-1}\bullet w_{l}\ldots w_{r-1}\bullet w%
_{r}\ldots w_{n}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="recognition-of-strings">Recognition of strings</h3>

<p>Like LMGs, RCG clauses have the general schema 

<math display="inline" id="Range_concatenation_grammars:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x_{1},...,x_{n})\to\alpha
  </annotation>
 </semantics>
</math>

, where in an RCG, 

<math display="inline" id="Range_concatenation_grammars:27">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is either the empty string or a string of predicates. The arguments 

<math display="inline" id="Range_concatenation_grammars:28">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 consist of strings of terminal symbols and/or variable symbols, which pattern match against actual argument values like in LMG. Adjacent variables constitute a family of matches against partitions, so that the argument 

<math display="inline" id="Range_concatenation_grammars:29">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xy
  </annotation>
 </semantics>
</math>

, with two variables, matches the literal string 

<math display="inline" id="Range_concatenation_grammars:30">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ab
  </annotation>
 </semantics>
</math>

 in three different ways

<math display="block" id="Range_concatenation_grammars:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mi>ϵ</mi>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mo>=</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </mrow>
    <mo rspace="7.5pt">;</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mo>=</mo>
      <mi>a</mi>
     </mrow>
     <mo rspace="7.5pt">,</mo>
     <mrow>
      <mrow>
       <mi>y</mi>
       <mo>=</mo>
       <mi>b</mi>
      </mrow>
      <mo rspace="7.5pt">;</mo>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mo>=</mo>
        <mrow>
         <mi>a</mi>
         <mi>b</mi>
        </mrow>
       </mrow>
       <mo rspace="7.5pt">,</mo>
       <mrow>
        <mi>y</mi>
        <mo>=</mo>
        <mi>ϵ</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <ci>x</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <ci>y</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <eq></eq>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>a</ci>
          <ci>b</ci>
         </apply>
        </apply>
        <apply>
         <eq></eq>
         <ci>y</ci>
         <ci>ϵ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\epsilon,\ y=ab;\ x=a,\ y=b;\ x=ab,\ y=\epsilon
  </annotation>
 </semantics>
</math>

.</p>

<p>Predicate terms come in two forms, positive (which produce the empty string on success), and negative (which produce the empty string on failure/if the positive term does <em>not</em> produce the empty string). Negative terms are denoted the same as positive terms, with an overbar, as in 

<math display="inline" id="Range_concatenation_grammars:32">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{A(x_{1},...,x_{n})}
  </annotation>
 </semantics>
</math>

.</p>

<p>The rewrite semantics for RCGs is rather simple, identical to the corresponding semantics of LMGs. Given a predicate string 

<math display="inline" id="Range_concatenation_grammars:33">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>α</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>α</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(\alpha_{1},...,\alpha_{n})
  </annotation>
 </semantics>
</math>

, where the symbols 

<math display="inline" id="Range_concatenation_grammars:34">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 are terminal strings, if there is a rule 

<math display="inline" id="Range_concatenation_grammars:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x_{1},...,x_{n})\to\beta
  </annotation>
 </semantics>
</math>

 in the grammar that the predicate string matches, the predicate string is replaced by 

<math display="inline" id="Range_concatenation_grammars:36">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

, substituting for the matched variables in each 

<math display="inline" id="Range_concatenation_grammars:37">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>For example, given the rule 

<math display="inline" id="Range_concatenation_grammars:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mi>y</mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>x</mi>
      <mi>b</mi>
     </mrow>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>y</ci>
       <ci>b</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>x</ci>
       <ci>b</ci>
      </apply>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x,ayb)\to B(axb,y)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Range_concatenation_grammars:39">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Range_concatenation_grammars:40">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 are variable symbols and 

<math display="inline" id="Range_concatenation_grammars:41">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Range_concatenation_grammars:42">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 are terminal symbols, the predicate string 

<math display="inline" id="Range_concatenation_grammars:43">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
     <mi>b</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
      <ci>b</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(a,abb)
  </annotation>
 </semantics>
</math>

 can be rewritten as 

<math display="inline" id="Range_concatenation_grammars:44">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>a</mi>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>b</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(aab,b)
  </annotation>
 </semantics>
</math>

, because 

<math display="inline" id="Range_concatenation_grammars:45">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
     <mi>b</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
      <ci>b</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(a,abb)
  </annotation>
 </semantics>
</math>

 matches 

<math display="inline" id="Range_concatenation_grammars:46">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <mi>a</mi>
     <mi>y</mi>
     <mi>b</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>y</ci>
      <ci>b</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x,ayb)
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Range_concatenation_grammars:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mi>a</mi>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>y</mi>
    <mo>=</mo>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <eq></eq>
     <ci>y</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=a,\ y=b
  </annotation>
 </semantics>
</math>

. Similarly, if there were a rule 

<math display="inline" id="Range_concatenation_grammars:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mi>y</mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>y</ci>
       <ci>b</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>x</ci>
     </interval>
     <ci>A</ci>
     <interval closure="open">
      <ci>y</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x,ayb)\to A(x,x)\ A(y,y)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Range_concatenation_grammars:49">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
     <mi>b</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
      <ci>b</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(a,abb)
  </annotation>
 </semantics>
</math>

 could be rewritten as 

<math display="inline" id="Range_concatenation_grammars:50">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>a</ci>
    </interval>
    <ci>A</ci>
    <interval closure="open">
     <ci>b</ci>
     <ci>b</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(a,a)\ A(b,b)
  </annotation>
 </semantics>
</math>

.</p>

<p>A proof/recognition of a string 

<math display="inline" id="Range_concatenation_grammars:51">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is done by showing that 

<math display="inline" id="Range_concatenation_grammars:52">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\alpha)
  </annotation>
 </semantics>
</math>

 produces the empty string. For the individual rewrite steps, when multiple alternative variable matches are possible, any rewrite which could lead the whole proof to succeed is considered. Thus, if there is at least one way to produce the empty string from the initial string 

<math display="inline" id="Range_concatenation_grammars:53">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\alpha)
  </annotation>
 </semantics>
</math>

, the proof is considered a success, regardless of how many other ways to fail exist.</p>
<h2 id="example">Example</h2>

<p>RCGs are capable of recognizing the non-linear index language 

<math display="inline" id="Range_concatenation_grammars:54">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>w</mi>
    <mi>w</mi>
    <mi>w</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>w</mi>
    <mo>∈</mo>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>w</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <in></in>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <ci>a</ci>
       <ci>b</ci>
      </set>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{www:w\in\{a,b\}^{*}\}
  </annotation>
 </semantics>
</math>

 as follows:</p>

<p>Letting x, y, and z be variable symbols:</p>

<p>

<math display="inline" id="Range_concatenation_grammars:55">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mi>y</mi>
      <mi>z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(xyz)\to A(x,y,z)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Range_concatenation_grammars:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mi>y</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mi>z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <vector>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>z</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(ax,ay,az)\to A(x,y,z)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Range_concatenation_grammars:57">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>b</mi>
      <mi>y</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>b</mi>
      <mi>z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <vector>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>z</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(bx,by,bz)\to A(x,y,z)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Range_concatenation_grammars:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϵ</mi>
     <mo>,</mo>
     <mi>ϵ</mi>
     <mo>,</mo>
     <mi>ϵ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <vector>
      <ci>ϵ</ci>
      <ci>ϵ</ci>
      <ci>ϵ</ci>
     </vector>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(\epsilon,\epsilon,\epsilon)\to\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p>The proof for <em>abbabbabb</em> is then</p>

<p>

<math display="inline" id="Range_concatenation_grammars:59">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
      <mi>b</mi>
      <mi>a</mi>
      <mi>b</mi>
      <mi>b</mi>
      <mi>a</mi>
      <mi>b</mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
      <mi>b</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
      <mi>b</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mi>b</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>b</mi>
      <mi>b</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>b</mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϵ</mi>
     <mo>,</mo>
     <mi>ϵ</mi>
     <mo>,</mo>
     <mi>ϵ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⇒</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇒</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
       <ci>b</ci>
       <ci>a</ci>
       <ci>b</ci>
       <ci>b</ci>
       <ci>a</ci>
       <ci>b</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <vector>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
        <ci>b</ci>
       </apply>
      </vector>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>A</ci>
      <vector>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>b</ci>
       </apply>
      </vector>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>A</ci>
      <vector>
       <ci>b</ci>
       <ci>b</ci>
       <ci>b</ci>
      </vector>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>A</ci>
      <vector>
       <ci>ϵ</ci>
       <ci>ϵ</ci>
       <ci>ϵ</ci>
      </vector>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(abbabbabb)\Rightarrow A(abb,abb,abb)\Rightarrow A(bb,bb,bb)\Rightarrow A(b,b%
,b)\Rightarrow A(\epsilon,\epsilon,\epsilon)\Rightarrow\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p>Or, using the more correct dotted notation for ranges:</p>

<p>

<math display="inline" id="Range_concatenation_grammars:60">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∙</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mo>∙</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇒</mo>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∙</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mo>∙</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mo>∙</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mo>∙</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mo>∙</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mo>∙</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇒</mo>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>∙</mo>
    <mi>b</mi>
    <mi>b</mi>
    <mo>∙</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mo>∙</mo>
    <mi>b</mi>
    <mi>b</mi>
    <mo>∙</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mo>∙</mo>
    <mi>b</mi>
    <mi>b</mi>
    <mo>∙</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\bullet{}abbabbabb\bullet{})\Rightarrow A(\bullet{}abb\bullet{}abbabb,abb%
\bullet{}abb\bullet{}abb,abbabb\bullet{}abb\bullet{})\Rightarrow A(a\bullet{}%
bb\bullet{}abbabb,abba\bullet{}bb\bullet{}abb,abbabba\bullet{}bb\bullet{})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Range_concatenation_grammars:61">
 <semantics>
  <mrow>
   <mo>⇒</mo>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mo>∙</mo>
    <mi>b</mi>
    <mo>∙</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mo>∙</mo>
    <mi>b</mi>
    <mo>∙</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mi>b</mi>
    <mo>∙</mo>
    <mi>b</mi>
    <mo>∙</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇒</mo>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϵ</mi>
    <mo>,</mo>
    <mi>ϵ</mi>
    <mo>,</mo>
    <mi>ϵ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇒</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-∙</ci>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϵ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">ϵ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">ϵ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">ϵ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow A(ab\bullet{}b\bullet{}abbabb,abbab\bullet{}b\bullet{}abb,abbabbab%
\bullet{}b\bullet{})\Rightarrow A(\epsilon,\epsilon,\epsilon)\Rightarrow\epsilon
  </annotation>
 </semantics>
</math>

</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Grammar_frameworks" title="wikilink">Category:Grammar frameworks</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"> citing <a class="uri" href="http://mjn.host.cs.st-andrews.ac.uk/publications/2001d.pdf">http://mjn.host.cs.st-andrews.ac.uk/publications/2001d.pdf</a><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
