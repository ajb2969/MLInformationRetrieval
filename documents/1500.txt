   Hadamard code      Hadamard code     The Hadamard code is an error-correcting code that is used for error detection and correction when transmitting messages over very noisy or unreliable channels. In 1971, the code was used to transmit photos of Mars back to Earth from the NASA space probe Mariner 9 Because of its unique mathematical properties, the Hadamard code is not only used by engineers, but also intensely studied in coding theory , mathematics , and theoretical computer science . The Hadamard code is named after the French mathematician Jacques Hadamard . It also known under the names Walsh code , Walsh family , 1 and Walsh‚ÄìHadamard code 2 in recognition of the American mathematician Joseph Leonard Walsh .  The Hadamard code is an example of a linear code over a binary alphabet that maps messages of length   k   k   k   to codewords of length    2  k     superscript  2  k    2^{k}   . It is unique in that each non-zero codeword has a Hamming weight of exactly     2  k   /  2       superscript  2  k   2    2^{k}/2   , which implies that the distance of the code is also     2  k   /  2       superscript  2  k   2    2^{k}/2   . In standard coding theory notation for block codes , the Hadamard code is a     [   2  k   ,  k  ,    2  k   /  2   ]   2     subscript    superscript  2  k   k     superscript  2  k   2    2    [2^{k},k,2^{k}/2]_{2}   -code, that is, it is a linear code over a binary alphabet , has block length     2  k     superscript  2  k    2^{k}   , message length (or dimension)   k   k   k   , and minimum distance      2  k   /  2       superscript  2  k   2    2^{k}/2   . The block length is very large compared to the message length, but on the other hand, errors can be corrected even in extremely noisy conditions. The punctured Hadamard code is a slightly improved version of the Hadamard code; it is a     [   2   k  -  1    ,  k  ,   2   k  -  2    ]   2     subscript    superscript  2    k  1    k   superscript  2    k  2     2    [2^{k-1},k,2^{k-2}]_{2}   -code and thus has a slightly better rate while maintaining the relative distance of    1  /  2      1  2    1/2   , and is thus preferred in practical applications. The punctured Hadamard code is the same as the first order Reed‚ÄìMuller code over the binary alphabet. 3  Normally, Hadamard codes are based on Sylvester's construction of Hadamard matrices , but the term ‚ÄúHadamard code‚Äù is also used to refer to codes constructed from arbitrary Hadamard matrices , which are not necessarily of Sylvester type. In general, such a code is not linear. Such codes were first constructed by R. C. Bose and S. S. Shrikhande in 1959. 4 If n is the size of the Hadamard matrix, the code has parameters     (  n  ,   2  n   ,   n  /  2   )   2     subscript   n    2  n     n  2    2    (n,2n,n/2)_{2}   , meaning it is a not-necessarily-linear binary code with 2 n codewords of block length n and minimal distance n /2. The construction and decoding scheme described below apply for general n , but the property of linearity and the identification with Reed‚ÄìMuller codes require that n be a power of 2 and that the Hadamard matrix be equivalent to the matrix constructed by Sylvester's method.  The Hadamard code is a locally decodable code, which provides a way to recover parts of the original message with high probability, while only looking at a small fraction of the received word. This gives rise to applications in computational complexity theory and particularly in the design of probabilistically checkable proofs . Since the relative distance of the Hadamard code is 1/2, normally one can only hope to recover from at most a 1/4 fraction of error. Using list decoding , however, it is possible to compute a short list of possible candidate messages as long as fewer than     1  2   -  œµ        1  2   œµ    \frac{1}{2}-\epsilon   of the bits in the received word have been corrupted.  In code division multiple access (CDMA) communication, the Hadamard code is referred to as Walsh Code, and is used to define individual communication  channels . It is usual in the CDMA literature to refer to codewords as ‚Äúcodes‚Äù. Each user will use a different codeword, or ‚Äúcode‚Äù, to modulate their signal. Because Walsh codewords are mathematically orthogonal , a Walsh-encoded signal appears as random noise to a CDMA capable mobile terminal , unless that terminal uses the same codeword as the one used to encode the incoming signal . 5  History  Hadamard code is the name that is most commonly used for this code in the literature. Jacques Hadamard did not invent the code himself, but he defined Hadamard matrices around 1893, long before the first error-correcting code , the Hamming code , was developed in the 1940s. The Hadamard code is based on Hadamard matrices, and while there are many different Hadamard matrices that could be used here, normally only Sylvester's construction of Hadamard matrices is used to obtain the codewords of the Hadamard code. James Joseph Sylvester developed his construction of Hadamard matrices in 1867, which actually predates Hadamard's work on Hadamard matrices. Hence the name Hadamard code is not undisputed and sometimes the code is called Walsh code , honoring the American mathematician Joseph Leonard Walsh .  A Hadamard code was used during the 1971 Mariner 9 mission to correct for picture transmission errors. The data words used during this mission were 6 bits long, which represented 64 grayscale values. Because of limitations of the quality of the alignment of the transmitter the maximum useful data length was about 30 bits. Instead of using a repetition code , a [32, 6, 16] Hadamard code was used. Errors of up to 7 bits per word could be corrected using this scheme. Compared to a 5- repetition code , the error correcting properties of this Hadamard code are much better, yet its rate is comparable. The efficient decoding algorithm was an important factor in the decision to use this code. The circuitry used was called the "Green Machine". It employed the fast Fourier transform which can increase the decoding speed by a factor of three. Since the 1990s use of this code by space programs has more or less ceased, and the Deep Space Network does not support this error correction scheme for its dishes that are greater than 26¬†m.  Constructions  While all Hadamard codes are based on Hadamard matrices, the constructions differ in subtle ways for different scientific fields, authors, and uses. Engineers, who use the codes for data transmission, and coding theorists , who analyze extremal properties of codes, typically want the rate of the code to be as high as possible, even if this means that the construction becomes mathematically slightly less elegant. On the other hand, for many applications of Hadamard codes in theoretical computer science it is not so important to achieve the optimal rate, and hence simpler constructions of Hadamard codes are preferred since they can be analyzed more elegantly.  Construction using inner products  When given a binary message    x  ‚àà    {  0  ,  1  }   k       x   superscript   0  1   k     x\in\{0,1\}^{k}   of length   k   k   k   , the Hadamard code encodes the message into a codeword    Had   (  x  )       Had  x    \text{Had}(x)   using an encoding function    Had  :     {  0  ,  1  }   k   ‚Üí    {  0  ,  1  }    2  k        normal-:  Had   normal-‚Üí   superscript   0  1   k    superscript   0  1    superscript  2  k       \text{Had}:\{0,1\}^{k}\to\{0,1\}^{2^{k}}   . This function makes use of the inner product     ‚ü®  x  ,  y  ‚ü©     x  y    \langle x,y\rangle   of two vectors     x  ,  y   ‚àà    {  0  ,  1  }   k        x  y    superscript   0  1   k     x,y\in\{0,1\}^{k}   , which is defined as follows:       ‚ü®  x  ,  y  ‚ü©   =     ‚àë   i  =  1   k     x  i     y  i      mod  2‚Äâ.        x  y    modulo    superscript   subscript     i  1    k      subscript  x  i    subscript  y  i     2‚Äâ.     \langle x,y\rangle=\sum_{i=1}^{k}x_{i}y_{i}\ \bmod\ 2\,.   Then the Hadamard encoding of   x   x   x   is defined as the sequence of all inner products with   x   x   x   :       Had   (  x  )    =    (   ‚ü®  x  ,  y  ‚ü©   )    y  ‚àà    {  0  ,  1  }   k           Had  x    subscript   x  y     y   superscript   0  1   k       \text{Had}(x)=\Big(\langle x,y\rangle\Big)_{y\in\{0,1\}^{k}}     As mentioned above, the punctured Hadamard code is used in practice since the Hadamard code itself is somewhat wasteful. This is because, if the first bit of   y   y   y   is zero,     y  1   =  0       subscript  y  1   0    y_{1}=0   , then the inner product contains no information whatsoever about    x  1     subscript  x  1    x_{1}   , and hence, it is impossible to fully decode   x   x   x   from those positions of the codeword alone. On the other hand, when the codeword is restricted to the positions where     y  1   =  1       subscript  y  1   1    y_{1}=1   , it is still possible to fully decode   x   x   x   . Hence it makes sense to restrict the Hadamard code to these positions, which gives rise to the punctured Hadamard encoding of   x   x   x   ; that is,     pHad   (  x  )    =    (   ‚ü®  x  ,  y  ‚ü©   )    y  ‚àà    {  1  }   √ó    {  0  ,  1  }    k  -  1             pHad  x    subscript   x  y     y     1    superscript   0  1     k  1         \text{pHad}(x)=\Big(\langle x,y\rangle\Big)_{y\in\{1\}\times\{0,1\}^{k-1}}   .  Construction using a generator matrix  The Hadamard code is a linear code, and all linear codes can be generated by a generator matrix   G   G   G   . This is a matrix such that     Had   (  x  )    =   x  ‚ãÖ  G         Had  x    normal-‚ãÖ  x  G     \text{Had}(x)=x\cdot G   holds for all    x  ‚àà    {  0  ,  1  }   k       x   superscript   0  1   k     x\in\{0,1\}^{k}   , where the message   x   x   x   is viewed as a row vector and the vector-matrix product is understood in the vector space over the finite field     ùîΩ  2     subscript  ùîΩ  2    \mathbb{F}_{2}   . In particular, an equivalent way to write the inner product definition for the Hadamard code arises by using the generator matrix whose columns consist of all strings   y   y   y   of length   k   k   k   , that is,       G  =    (     ‚Üë    ‚Üë       ‚Üë       y  1      y  2     ‚Ä¶     y   2  k        ‚Üì    ‚Üì       ‚Üì     )     .      G    normal-‚Üë  normal-‚Üë  absent  normal-‚Üë     subscript  y  1    subscript  y  2   normal-‚Ä¶   subscript  y   superscript  2  k      normal-‚Üì  normal-‚Üì  absent  normal-‚Üì      G=\begin{pmatrix}\uparrow&\uparrow&&\uparrow\\
 y_{1}&y_{2}&\dots&y_{2^{k}}\\
 \downarrow&\downarrow&&\downarrow\end{pmatrix}\,.     where     y  i   ‚àà    {  0  ,  1  }   k        subscript  y  i    superscript   0  1   k     y_{i}\in\{0,1\}^{k}   is the   i   i   i   -th binary vector in lexicographical order . For example, the generator matrix for the Hadamard code of dimension    k  =  3      k  3    k=3   is:       G  =   [     0    0    0    0    1    1    1    1      0    0    1    1    0    0    1    1      0    1    0    1    0    1    0    1     ]    .      G    0  0  0  0  1  1  1  1    0  0  1  1  0  0  1  1    0  1  0  1  0  1  0  1      G=\begin{bmatrix}0&0&0&0&1&1&1&1\\
 0&0&1&1&0&0&1&1\\
 0&1&0&1&0&1&0&1\end{bmatrix}.     The matrix   G   G   G   is a    (   k  √ó   2  k    )      k   superscript  2  k     (k\times 2^{k})   -matrix and gives rise to the linear operator     Had  :     {  0  ,  1  }   k   ‚Üí    {  0  ,  1  }    2  k        normal-:  Had   normal-‚Üí   superscript   0  1   k    superscript   0  1    superscript  2  k       \text{Had}:\{0,1\}^{k}\to\{0,1\}^{2^{k}}   .  The generator matrix of the punctured Hadamard code is obtained by restricting the matrix   G   G   G   to the columns whose first entry is one. For example, the generator matrix for the punctured Hadamard code of dimension    k  =  3      k  3    k=3   is:        G  ‚Ä≤   =   [     1    1    1    1      0    0    1    1      0    1    0    1     ]    .       superscript  G  normal-‚Ä≤     1  1  1  1    0  0  1  1    0  1  0  1      G^{\prime}=\begin{bmatrix}1&1&1&1\\
 0&0&1&1\\
 0&1&0&1\end{bmatrix}.   Then    pHad  :     {  0  ,  1  }   k   ‚Üí    {  0  ,  1  }    2   k  -  1         normal-:  pHad   normal-‚Üí   superscript   0  1   k    superscript   0  1    superscript  2    k  1        \text{pHad}:\{0,1\}^{k}\to\{0,1\}^{2^{k-1}}   is a linear mapping with     pHad   (  x  )    =   x  ‚ãÖ   G  ‚Ä≤          pHad  x    normal-‚ãÖ  x   superscript  G  normal-‚Ä≤      \text{pHad}(x)=x\cdot G^{\prime}   .  For general   k   k   k   , the generator matrix of the punctured Hadamard code is a parity-check matrix for the extended Hamming code of length    2   k  -  1      superscript  2    k  1     2^{k-1}   and dimension     2   k  -  1    -  k       superscript  2    k  1    k    2^{k-1}-k   , which makes the punctured Hadamard code the dual code of the extended Hamming code. Hence an alternative way to define the Hadamard code is in terms of its parity-check matrix: the parity-check matrix of the Hadamard code is equal to the generator matrix of the Hamming code.  Construction using general Hadamard matrices  Generalized Hadamard codes are obtained from an n -by- n  Hadamard matrix  H . In particular, the 2 n codewords of the code are the rows of H and the rows of ‚àí H . To obtain a code over the alphabet {0,1}, the mapping ‚àí1¬†‚Ü¶¬†1, 1¬†‚Ü¶¬†0, or, equivalently, x ‚Ü¶¬†(1¬†‚àí x )/2, is applied to the matrix elements. That the minimum distance of the code is n /2 follows from the defining property of Hadamard matrices, namely that their rows are mutually orthogonal. This implies that two distinct rows of a Hadamard matrix differ in exactly n /2 positions, and, since negation of a row does not affect orthogonality, that any row of H differs from any row of ‚àí H in n /2 positions as well, except when the rows correspond, in which case they differ in n positions.  To get the punctured Hadamard code above with    n  =   2   k  -  1        n   superscript  2    k  1      n=2^{k-1}   , the chosen Hadamard matrix H has to be of Sylvester type, which gives rise to a message length of      log  2    (   2  n   )    =  k        subscript   2     2  n    k    \log_{2}(2n)=k   .  Distance  The distance of a code is the minimum Hamming distance between any two distinct codewords, i.e., the minimum number of positions at which two distinct codewords differ. Since the Walsh‚ÄìHadamard code is a linear code , the distance is equal to the minimum Hamming weight among all of its non-zero codewords. All non-zero codewords of the Walsh‚ÄìHadamard code have a Hamming weight of exactly    2   k  -  1      superscript  2    k  1     2^{k-1}   by the following argument.  Let    x  ‚àà    {  0  ,  1  }   k       x   superscript   0  1   k     x\in\{0,1\}^{k}   be a non-zero message. Then the following value is exactly equal to the fraction of positions in the codeword that are equal to one:         Pr   y  ‚àà    {  0  ,  1  }   k      [     (   Had   (  x  )    )   y   =  1   ]    =    Pr   y  ‚àà    {  0  ,  1  }   k      [    ‚ü®  x  ,  y  ‚ü©   =  1   ]     .        subscript  Pr    y   superscript   0  1   k        subscript    Had  x   y   1      subscript  Pr    y   superscript   0  1   k        x  y   1      \Pr_{y\in\{0,1\}^{k}}\big[(\text{Had}(x))_{y}=1\big]=\Pr_{y\in\{0,1\}^{k}}\big%
 [\langle x,y\rangle=1\big]\,.     The fact that the latter value is exactly    1  /  2      1  2    1/2   is called the random subsum principle . To see that it is true, assume without loss of generality that     x  1   =  1       subscript  x  1   1    x_{1}=1   . Then, when conditioned on the values of     y  2   ,  ‚Ä¶  ,   y  k       subscript  y  2   normal-‚Ä¶   subscript  y  k     y_{2},\dots,y_{k}   , the event is equivalent to      y  1   ‚ãÖ   x  1    =  b       normal-‚ãÖ   subscript  y  1    subscript  x  1    b    y_{1}\cdot x_{1}=b   for some    b  ‚àà   {  0  ,  1  }       b   0  1     b\in\{0,1\}   depending on     x  2   ,  ‚Ä¶  ,   x  k       subscript  x  2   normal-‚Ä¶   subscript  x  k     x_{2},\dots,x_{k}   and     y  2   ,  ‚Ä¶  ,   y  k       subscript  y  2   normal-‚Ä¶   subscript  y  k     y_{2},\dots,y_{k}   . The probability that     y  1   =  b       subscript  y  1   b    y_{1}=b   happens is exactly    1  /  2      1  2    1/2   . Thus, in fact, all non-zero codewords of the Hadamard code have relative Hamming weight    1  /  2      1  2    1/2   , and thus, its relative distance is    1  /  2      1  2    1/2   .  The relative distance of the punctured Hadamard code is    1  /  2      1  2    1/2   as well, but it no longer has the property that every non-zero codeword has weight exactly    1  /  2      1  2    1/2   since the all   1   1   1   s vector    1   2   k  -  1       superscript  1   superscript  2    k  1      1^{2^{k-1}}   is a codeword of the punctured Hadamard code. This is because the vector    x  =   10   k  -  1        x   superscript  10    k  1      x=10^{k-1}   encodes to     pHad   (   10   k  -  1    )    =   1   2   k  -  1           pHad   superscript  10    k  1      superscript  1   superscript  2    k  1       \text{pHad}(10^{k-1})=1^{2^{k-1}}   . Furthermore, whenever   x   x   x   is non-zero and not the vector    10   k  -  1      superscript  10    k  1     10^{k-1}   , the random subsum principle applies again, and the relative weight of    Had   (  x  )       Had  x    \text{Had}(x)   is exactly    1  /  2      1  2    1/2   .  Local decodability  A locally decodable code is a code that allows a single bit of the original message to be recovered with high probability by only looking at a small portion of the received word. A code is   q   q   q   -query locally decodable if a message bit,    x  i     subscript  x  i    x_{i}   , can be recovered by checking   q   q   q   bits of the received word. More formally, a code,    C  :     {  0  ,  1  }   k   ‚Üí    {  0  ,  1  }   n       normal-:  C   normal-‚Üí   superscript   0  1   k    superscript   0  1   n      C:\{0,1\}^{k}\rightarrow\{0,1\}^{n}   , is    (     q  ,  Œ¥   ‚â•  0   ,   œµ  ‚â•  0    )     formulae-sequence     q  Œ¥   0     œµ  0     (q,\delta\geq 0,\epsilon\geq 0)   -locally decodable, if there exists a probabilistic decoder,    D  :     {  0  ,  1  }   n   ‚Üí    {  0  ,  1  }   k       normal-:  D   normal-‚Üí   superscript   0  1   n    superscript   0  1   k      D:\{0,1\}^{n}\rightarrow\{0,1\}^{k}   , such that (Note    Œî   (  x  ,  y  )       normal-Œî   x  y     \Delta(x,y)   represents the Hamming distance between vectors   x   x   x   and   y   y   y   ) :        ‚àÄ  x   ‚àà    {  0  ,  1  }   k    ,    ‚àÄ  y   ‚àà    {  0  ,  1  }   n       formulae-sequence     for-all  x    superscript   0  1   k       for-all  y    superscript   0  1   n      \forall x\in\{0,1\}^{k},\forall y\in\{0,1\}^{n}   ,     Œî   (  y  ,   C   (  x  )    )    ‚â§   Œ¥  n         normal-Œî   y    C  x       Œ¥  n     \Delta(y,C(x))\leq\delta n   implies that    P  r   [  D    (  y  )   i   =   x  i   ]   ‚â•   1  2   +  œµ  ,  ‚àÄ  i  ‚àà   [  k  ]      fragments  P  r   fragments  normal-[  D   subscript   fragments  normal-(  y  normal-)   i     subscript  x  i   normal-]      1  2    œµ  normal-,  for-all  i    fragments  normal-[  k  normal-]     Pr[D(y)_{i}=x_{i}]\geq\frac{1}{2}+\epsilon,\forall i\in[k]     Theorem 1: The Walsh‚ÄìHadamard code is    (  2  ,  Œ¥  ,    1  2   -   2  Œ¥    )     2  Œ¥      1  2     2  Œ¥      (2,\delta,\frac{1}{2}-2\delta)   -locally decodable for    0  ‚â§  Œ¥  ‚â§   1  4         0  Œ¥         1  4      0\leq\delta\leq\frac{1}{4}   .  Lemma 1: For all codewords,   c   c   c   in a Walsh‚ÄìHadamard code,   C   C   C   ,      c  i   +   c  j    =   c   i  +  j           subscript  c  i    subscript  c  j     subscript  c    i  j      c_{i}+c_{j}=c_{i+j}   , where     c  i   ,   c  j       subscript  c  i    subscript  c  j     c_{i},c_{j}   represent the bits in   c   c   c   in positions   i   i   i   and   j   j   j   respectively, and    c   i  +  j      subscript  c    i  j     c_{i+j}   represents the bit at position    (   i  +  j   )      i  j    (i+j)   .  Proof of lemma 1   Let     C   (  x  )    =  c  =   (   c  0   ,  ‚Ä¶  ,   c    2  n   -  1    )           C  x   c         subscript  c  0   normal-‚Ä¶   subscript  c     superscript  2  n   1        C(x)=c=(c_{0},\dots,c_{2^{n}-1})   be the codeword in   C   C   C   corresponding to message   x   x   x   .  Let    G  =   (     ‚Üë    ‚Üë       ‚Üë       g  0      g  1     ‚Ä¶     g    2  n   -  1        ‚Üì    ‚Üì       ‚Üì     )       G    normal-‚Üë  normal-‚Üë  absent  normal-‚Üë     subscript  g  0    subscript  g  1   normal-‚Ä¶   subscript  g     superscript  2  n   1      normal-‚Üì  normal-‚Üì  absent  normal-‚Üì      G=\begin{pmatrix}\uparrow&\uparrow&&\uparrow\\
 g_{0}&g_{1}&\dots&g_{2^{n}-1}\\
 \downarrow&\downarrow&&\downarrow\end{pmatrix}   be the generator matrix of   C   C   C   .  By definition,     c  i   =   x  ‚ãÖ   g  i         subscript  c  i    normal-‚ãÖ  x   subscript  g  i      c_{i}=x\cdot g_{i}   . From this,      c  i   +   c  j    =    x  ‚ãÖ   g  i    +   x  ‚ãÖ   g  j     =   x  ‚ãÖ   (    g  i   +   g  j    )             subscript  c  i    subscript  c  j       normal-‚ãÖ  x   subscript  g  i     normal-‚ãÖ  x   subscript  g  j           normal-‚ãÖ  x     subscript  g  i    subscript  g  j        c_{i}+c_{j}=x\cdot g_{i}+x\cdot g_{j}=x\cdot(g_{i}+g_{j})   . By the construction of   G   G   G   ,      g  i   +   g  j    =   g   i  +  j           subscript  g  i    subscript  g  j     subscript  g    i  j      g_{i}+g_{j}=g_{i+j}   . Therefore, by substitution,      c  i   +   c  j    =   x  ‚ãÖ   g   i  +  j     =   c   i  +  j             subscript  c  i    subscript  c  j     normal-‚ãÖ  x   subscript  g    i  j           subscript  c    i  j       c_{i}+c_{j}=x\cdot g_{i+j}=c_{i+j}   .  Proof of theorem 1   To prove theorem 1 we will construct a decoding algorithm and prove its correctness.  Algorithm  Input: Received word    y  =   (   y  0   ,  ‚Ä¶  ,   y    2  n   -  1    )       y    subscript  y  0   normal-‚Ä¶   subscript  y     superscript  2  n   1       y=(y_{0},\dots,y_{2^{n}-1})     For each    i  ‚àà   {  1  ,  ‚Ä¶  ,  n  }       i   1  normal-‚Ä¶  n     i\in\{1,\dots,n\}   :   Pick    j  ‚àà   {  0  ,  ‚Ä¶  ,    2  n   -  1   }       j   0  normal-‚Ä¶     superscript  2  n   1      j\in\{0,\dots,2^{n}-1\}   independently at random  Pick    k  ‚àà   {  0  ,  ‚Ä¶  ,    2  n   -  1   }       k   0  normal-‚Ä¶     superscript  2  n   1      k\in\{0,\dots,2^{n}-1\}   such that     j  +  k   =   e  i         j  k    subscript  e  i     j+k=e_{i}   where    j  +  k      j  k    j+k   is the bitwise xor of   j   j   j   and   k   k   k   .       x  i   ‚Üê    y  j   +   y  k       normal-‚Üê   subscript  x  i      subscript  y  j    subscript  y  k      x_{i}\leftarrow y_{j}+y_{k}      Output: Message    x  =   (   x  1   ,  ‚Ä¶  ,   x  n   )       x    subscript  x  1   normal-‚Ä¶   subscript  x  n      x=(x_{1},\dots,x_{n})     Proof of correctness  For any message,   x   x   x   , and received word   y   y   y   such that   y   y   y   differs from    c  =   C   (  x  )        c    C  x     c=C(x)   on at most   Œ¥   Œ¥   \delta   fraction of bits,    x  i     subscript  x  i    x_{i}   can be decoded with probability at least     1  2   +   (   1  -   2  Œ¥    )         1  2     1    2  Œ¥      \frac{1}{2}+(1-2\delta)   .  By lemma 1,      c  j   +   c  k    =   c   j  +  k    =   x  ‚ãÖ   g   j  +  k     =   x  ‚ãÖ   e  i    =   x  i            subscript  c  j    subscript  c  k     subscript  c    j  k          normal-‚ãÖ  x   subscript  g    j  k           normal-‚ãÖ  x   subscript  e  i          subscript  x  i      c_{j}+c_{k}=c_{j+k}=x\cdot g_{j+k}=x\cdot e_{i}=x_{i}   . Since   j   j   j   and   k   k   k   are picked uniformly, the probability that     y  j   ‚â†   c  j        subscript  y  j    subscript  c  j     y_{j}\not=c_{j}   is at most   Œ¥   Œ¥   \delta   . Similarly, the probability that     y  k   ‚â†   c  k        subscript  y  k    subscript  c  k     y_{k}\not=c_{k}   is at most   Œ¥   Œ¥   \delta   . By the union bound , the probability that either    y  j     subscript  y  j    y_{j}   or    y  k     subscript  y  k    y_{k}   do not match the corresponding bits in   c   c   c   is at most    2  Œ¥      2  Œ¥    2\delta   . If both    y  j     subscript  y  j    y_{j}   and    y  k     subscript  y  k    y_{k}   correspond to   c   c   c   , then lemma 1 will apply, and therefore, the proper value of    x  i     subscript  x  i    x_{i}   will be computed. Therefore the probability    x  i     subscript  x  i    x_{i}   is decoded properly is at least    1  -   2  Œ¥       1    2  Œ¥     1-2\delta   . Therefore,    œµ  =    1  2   -   2  Œ¥        œµ      1  2     2  Œ¥      \epsilon=\frac{1}{2}-2\delta   and for   œµ   œµ   \epsilon   to be positive,    0  ‚â§  Œ¥  ‚â§   1  4         0  Œ¥         1  4      0\leq\delta\leq\frac{1}{4}   .  Therefore, the Walsh‚ÄìHadamard code is    (  2  ,  Œ¥  ,    1  2   -   2  Œ¥    )     2  Œ¥      1  2     2  Œ¥      (2,\delta,\frac{1}{2}-2\delta)   locally decodable for    0  ‚â§  Œ¥  ‚â§   1  4         0  Œ¥         1  4      0\leq\delta\leq\frac{1}{4}     Optimality  For k ‚â§¬†7 the linear Hadamard codes have been proven optimal in the sense of minimum distance. 6  See also   Zadoff‚ÄìChu sequence ‚Äî improve over the Walsh‚ÄìHadamard codes   Notes  References        de:Walsh-Code  ja:Áõ¥‰∫§Á¨¶Âè∑ "  Category:Coding theory  Category:Error detection and correction     See, e.g., ‚Ü©  See, e.g., . ‚Ü©  See, e.g., . ‚Ü©  ‚Ü©  ‚Ü©  ‚Ü©     