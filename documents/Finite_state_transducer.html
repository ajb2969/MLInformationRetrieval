<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1569">Finite state transducer</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Finite state transducer</h1>
<hr/>

<p>A <strong>finite state transducer</strong> (<strong>FST</strong>) is a <a href="finite_state_machine" title="wikilink">finite state machine</a> with two tapes: an input tape and an output tape. This contrasts with an ordinary <a href="finite_state_automaton" title="wikilink">finite state automaton</a> (or <a href="finite_state_acceptor" title="wikilink">finite state acceptor</a>), which has a single tape.</p>
<h2 id="overview">Overview</h2>

<p>An <a class="uri" href="automaton" title="wikilink">automaton</a> can be said to <em>recognize</em> a string if we view the content of its tape as input. In other words, the automaton computes a function that maps strings into the set {0,1}. Alternatively, we can say that an automaton <em>generates</em> strings, which means viewing its tape as an output tape. On this view, the automaton generates a <a href="formal_language" title="wikilink">formal language</a>, which is a set of strings. The two views of automata are equivalent: the function that the automaton computes is precisely the <a href="indicator_function" title="wikilink">indicator function</a> of the set of strings it generates. The class of languages generated by finite automata is known as the class of <a href="regular_language" title="wikilink">regular languages</a>.</p>

<p>The two tapes of a transducer are typically viewed as an input tape and an output tape. On this view, a transducer is said to <em>transduce</em> (i.e., translate) the contents of its input tape to its output tape, by accepting a string on its input tape and generating another string on its output tape. It may do so <a href="Nondeterministic_algorithm" title="wikilink">nondeterministically</a> and it may produce more than one output for each input string. A transducer may also produce no output for a given input string, in which case it is said to <em>reject</em> the input. In general, a transducer computes a <a href="relation_(mathematics)" title="wikilink">relation</a> between two formal languages.</p>

<p>Each string-to-string finite state transducer relates the input alphabet Σ to the output alphabet Γ. Relations <em>R</em> on Σ*×Γ* that can be implemented as finite state transducers are called <strong>rational relations</strong>. Rational relations that are <a href="partial_function" title="wikilink">partial functions</a>, i.e. that relate every input string from Σ* to at most one Γ*, are called <strong>rational functions</strong>.</p>

<p>Finite-state transducers are often used for <a href="phonology" title="wikilink">phonological</a> and <a href="morphology_(linguistics)" title="wikilink">morphological analysis</a> in <a href="natural_language_processing" title="wikilink">natural language processing</a> research and applications. Pioneers in this field include <a href="Ronald_Kaplan" title="wikilink">Ronald Kaplan</a>, <a href="Lauri_Karttunen" title="wikilink">Lauri Karttunen</a>, <a href="Martin_Kay" title="wikilink">Martin Kay</a> and <a href="Kimmo_Koskenniemi" title="wikilink">Kimmo Koskenniemi</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> A common way of using transducers is in a so-called "cascade", where transducers for various operations are combined into a single transducer by repeated application of the composition operator (defined below).</p>
<h2 id="formal-construction">Formal construction</h2>

<p>Formally, a finite transducer <em>T</em> is a 6-tuple (<em>Q</em>, Σ, Γ, <em>I</em>, <em>F</em>, δ) such that:</p>
<ul>
<li><em>Q</em> is a <a href="finite_set" title="wikilink">finite set</a>, the set of <em>states</em>;</li>
<li>Σ is a finite set, called the <em>input alphabet</em>;</li>
<li>Γ is a finite set, called the <em>output alphabet</em>;</li>
<li><em>I</em> is a <a class="uri" href="subset" title="wikilink">subset</a> of <em>Q</em>, the set of <em>initial states</em>;</li>
<li><em>F</em> is a subset of <em>Q</em>, the set of <em>final states</em>; and</li>
<li>

<math display="inline" id="Finite_state_transducer:0">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>⊆</mo>
   <mrow>
    <mi>Q</mi>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Σ</mi>
      <mo>∪</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>ϵ</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>∪</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>ϵ</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>δ</ci>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <union></union>
      <ci>normal-Σ</ci>
      <set>
       <ci>ϵ</ci>
      </set>
     </apply>
     <apply>
      <union></union>
      <ci>normal-Γ</ci>
      <set>
       <ci>ϵ</ci>
      </set>
     </apply>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta\subseteq Q\times(\Sigma\cup\{\epsilon\})\times(\Gamma\cup\{\epsilon\})\times
Q
  </annotation>
 </semantics>
</math>

 (where ε is the <a href="empty_string" title="wikilink">empty string</a>) is the <em>transition relation</em>.</li>
</ul>

<p>We can view (<em>Q</em>, δ) as a labeled <a href="directed_graph" title="wikilink">directed graph</a>, known as the <em>transition graph</em> of <em>T</em>: the set of vertices is <em>Q</em>, and 

<math display="inline" id="Finite_state_transducer:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <ci>q</ci>
     <ci>a</ci>
     <ci>b</ci>
     <ci>r</ci>
    </vector>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q,a,b,r)\in\delta
  </annotation>
 </semantics>
</math>

 means that there is a labeled edge going from vertex <em>q</em> to vertex <em>r</em>. We also say that <em>a</em> is the <em>input label</em> and <em>b</em> the <em>output label</em> of that edge.</p>

<p>NOTE: This definition of finite transducer is also called <em>letter transducer</em> (Roche and Schabes 1997); alternative definitions are possible, but can all be converted into transducers following this one.</p>

<p>Define the <em>extended transition relation</em> 

<math display="inline" id="Finite_state_transducer:2">
 <semantics>
  <msup>
   <mi>δ</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>δ</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{*}
  </annotation>
 </semantics>
</math>

 as the smallest set such that:</p>
<ul>
<li>

<math display="inline" id="Finite_state_transducer:3">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>⊆</mo>
   <msup>
    <mi>δ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>δ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>δ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta\subseteq\delta^{*}
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Finite_state_transducer:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>ϵ</mi>
    <mo>,</mo>
    <mi>ϵ</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>δ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <ci>q</ci>
     <ci>ϵ</ci>
     <ci>ϵ</ci>
     <ci>q</ci>
    </vector>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>δ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q,\epsilon,\epsilon,q)\in\delta^{*}
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Finite_state_transducer:5">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>q</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\in Q
  </annotation>
 </semantics>
</math>

; and</li>
<li>whenever 

<math display="inline" id="Finite_state_transducer:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>δ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <ci>q</ci>
     <ci>x</ci>
     <ci>y</ci>
     <ci>r</ci>
    </vector>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>δ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q,x,y,r)\in\delta^{*}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_state_transducer:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <ci>r</ci>
     <ci>a</ci>
     <ci>b</ci>
     <ci>s</ci>
    </vector>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (r,a,b,s)\in\delta
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Finite_state_transducer:8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mrow>
     <mi>x</mi>
     <mi>a</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>y</mi>
     <mi>b</mi>
    </mrow>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>δ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <ci>q</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>b</ci>
     </apply>
     <ci>s</ci>
    </vector>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>δ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q,xa,yb,s)\in\delta^{*}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The extended transition relation is essentially the reflexive <a href="transitive_closure" title="wikilink">transitive closure</a> of the transition graph that has been augmented to take edge labels into account. The elements of 

<math display="inline" id="Finite_state_transducer:9">
 <semantics>
  <msup>
   <mi>δ</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>δ</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{*}
  </annotation>
 </semantics>
</math>

 are known as <em>paths</em>. The edge labels of a path are obtained by concatenating the edge labels of its constituent transitions in order.</p>

<p>The <em>behavior</em> of the transducer <em>T</em> is the rational relation [<em>T</em>] defined as follows

<math display="block" id="Finite_state_transducer:10">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>T</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>T</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[T]y
  </annotation>
 </semantics>
</math>

 <a href="if_and_only_if" title="wikilink">if and only if</a> there exists 

<math display="inline" id="Finite_state_transducer:11">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in I
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_state_transducer:12">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>f</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in F
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Finite_state_transducer:13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>δ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <vector>
     <ci>i</ci>
     <ci>x</ci>
     <ci>y</ci>
     <ci>f</ci>
    </vector>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>δ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,x,y,f)\in\delta^{*}
  </annotation>
 </semantics>
</math>

. This is to say that <em>T</em> transduces a string 

<math display="inline" id="Finite_state_transducer:14">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Σ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\Sigma^{*}
  </annotation>
 </semantics>
</math>

 into a string 

<math display="inline" id="Finite_state_transducer:15">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in\Gamma^{*}
  </annotation>
 </semantics>
</math>

 if there exists a path from an initial state to a final state whose input label is <em>x</em> and whose output label is <em>y</em>.</p>
<h3 id="weighted-automata">Weighted automata</h3>

<p>Finite State Transducers can be weighted, where each transition is labelled with a weight in addition to the input and output labels. A Weighted Finite State Transducer (WFST) over a set <em>K</em> can be defined similarly to an unweighted one as an 8-tuple <em>T</em>=(<em>Q</em>, Σ, Γ, <em>I</em>, <em>F</em>, E, λ, ρ), where:</p>
<ul>
<li><em>Q</em>, Σ, Γ, <em>I</em>, <em>F</em> are defined as above;</li>
<li>

<math display="inline" id="Finite_state_transducer:16">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>⊆</mo>
   <mrow>
    <mi>Q</mi>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Σ</mi>
      <mo>∪</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>ϵ</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>∪</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>ϵ</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mi>Q</mi>
    <mo>×</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>E</ci>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <union></union>
      <ci>normal-Σ</ci>
      <set>
       <ci>ϵ</ci>
      </set>
     </apply>
     <apply>
      <union></union>
      <ci>normal-Γ</ci>
      <set>
       <ci>ϵ</ci>
      </set>
     </apply>
     <ci>Q</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\subseteq Q\times(\Sigma\cup\{\epsilon\})\times(\Gamma\cup\{\epsilon\})\times
Q\times
K
  </annotation>
 </semantics>
</math>

 (where ε is the <a href="empty_string" title="wikilink">empty string</a>) is the finite set of transitions;</li>
<li>

<math display="inline" id="Finite_state_transducer:17">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>:</mo>
   <mrow>
    <mi>I</mi>
    <mo>→</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>λ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>I</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda:I\rightarrow K
  </annotation>
 </semantics>
</math>

 maps initial states to weights;</li>
<li>

<math display="inline" id="Finite_state_transducer:18">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>:</mo>
   <mrow>
    <mi>F</mi>
    <mo>→</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ρ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>F</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho:F\rightarrow K
  </annotation>
 </semantics>
</math>

 maps final states to weights.</li>
</ul>

<p>In order to make certain operations on WFSTs well-defined, it is convenient to require the set of weights to form a <a class="uri" href="semiring" title="wikilink">semiring</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Two typical semirings used in practice are the <a href="log_semiring" title="wikilink">log semiring</a> and <a href="tropical_semiring" title="wikilink">tropical semiring</a>: unweighted automata may be regarded as having weights in the <a href="Boolean_semiring" title="wikilink">Boolean semiring</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="operations-on-finite-state-transducers">Operations on finite state transducers</h2>

<p>The following operations defined on finite automata also apply to finite transducers:</p>
<ul>
<li><a href="Union_(set_theory)" title="wikilink">Union</a>. Given transducers <em>T</em> and <em>S</em>, there exists a transducer 

<math display="inline" id="Finite_state_transducer:19">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>∪</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>T</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\cup S
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Finite_state_transducer:20">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>T</mi>
     <mo>∪</mo>
     <mi>S</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <union></union>
      <ci>T</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[T\cup S]y
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Finite_state_transducer:21">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>T</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>T</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[T]y
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Finite_state_transducer:22">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>S</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[S]y
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>Concatenation. Given transducers <em>T</em> and <em>S</em>, there exists a transducer 

<math display="inline" id="Finite_state_transducer:23">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>⋅</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>T</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\cdot S
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Finite_state_transducer:24">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>T</mi>
     <mo>⋅</mo>
     <mi>S</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <ci>T</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <ci>y</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wx[T\cdot S]yz
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Finite_state_transducer:25">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>T</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>T</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w[T]y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_state_transducer:26">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>S</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[S]z
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li><a href="Kleene_closure" title="wikilink">Kleene closure</a>. Given a transducer <em>T</em>, there exists a transducer 

<math display="inline" id="Finite_state_transducer:27">
 <semantics>
  <msup>
   <mi>T</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>T</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{*}
  </annotation>
 </semantics>
</math>

 with the following properties: (1) 

<math display="inline" id="Finite_state_transducer:28">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mi>T</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϵ</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <times></times>
     </apply>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon[T^{*}]\epsilon
  </annotation>
 </semantics>
</math>

; (2) if 

<math display="inline" id="Finite_state_transducer:29">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mi>T</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <times></times>
     </apply>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w[T^{*}]y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_state_transducer:30">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>T</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>T</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[T]z
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Finite_state_transducer:31">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mi>T</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <times></times>
     </apply>
    </apply>
    <ci>y</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wx[T^{*}]yz
  </annotation>
 </semantics>
</math>

; and 

<math display="inline" id="Finite_state_transducer:32">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mi>T</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <times></times>
     </apply>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[T^{*}]y
  </annotation>
 </semantics>
</math>

 does not hold unless mandated by (1) or (2).</li>
</ul>
<ul>
<li><a href="Intersection_(set_theory)" title="wikilink">Intersection</a>. Given transducers <em>T</em> and <em>S</em>, there exists a transducer 

<math display="inline" id="Finite_state_transducer:33">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>∩</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <ci>T</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\cap S
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Finite_state_transducer:34">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>T</mi>
     <mo>∩</mo>
     <mi>S</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <intersect></intersect>
      <ci>T</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[T\cap S]y
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Finite_state_transducer:35">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>T</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>T</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[T]y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_state_transducer:36">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>S</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[S]y
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li><a href="Composition_of_relations" title="wikilink">Composition</a>. Given a transducer <em>T</em> on alphabets Σ and Γ and a transducer <em>S</em> on alphabets Γ and Δ, there exists a transducer 

<math display="inline" id="Finite_state_transducer:37">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>∘</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>T</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\circ S
  </annotation>
 </semantics>
</math>

 on Σ and Δ such that 

<math display="inline" id="Finite_state_transducer:38">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>T</mi>
     <mo>∘</mo>
     <mi>S</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <compose></compose>
      <ci>T</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[T\circ S]z
  </annotation>
 </semantics>
</math>

 if and only if there exists a string 

<math display="inline" id="Finite_state_transducer:39">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Γ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in\Gamma^{*}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Finite_state_transducer:40">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>T</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>T</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[T]y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_state_transducer:41">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>S</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>S</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y[S]z
  </annotation>
 </semantics>
</math>

. This operation extends to the weighted case.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
</ul>
<dl>
<dd>This definition uses the same notation which is used in mathematics for <a href="Composition_of_relations" title="wikilink">relation composition</a>. However, the conventional reading for relation composition is the other way around: given two relations 

<math display="inline" id="Finite_state_transducer:42">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_state_transducer:43">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Finite_state_transducer:44">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>T</mi>
    <mo>∘</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>x</ci>
     <ci>z</ci>
    </interval>
    <apply>
     <compose></compose>
     <ci>T</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,z)\in T\circ S
  </annotation>
 </semantics>
</math>

 when there exist some 

<math display="inline" id="Finite_state_transducer:45">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Finite_state_transducer:46">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)\in S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_state_transducer:47">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>y</ci>
     <ci>z</ci>
    </interval>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y,z)\in T
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<ul>
<li><a href="Projection_(mathematics)" title="wikilink">Projection</a> to an automaton. There are two projection functions

<math display="block" id="Finite_state_transducer:48">
 <semantics>
  <msub>
   <mi>π</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}
  </annotation>
 </semantics>
</math>

 preserves the input tape, and 

<math display="inline" id="Finite_state_transducer:49">
 <semantics>
  <msub>
   <mi>π</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{2}
  </annotation>
 </semantics>
</math>

 preserves the output tape. The first projection, 

<math display="inline" id="Finite_state_transducer:50">
 <semantics>
  <msub>
   <mi>π</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}
  </annotation>
 </semantics>
</math>

 is defined as follows:</li>
</ul>
<dl>
<dd>Given a transducer <em>T</em>, there exists a finite automaton 

<math display="inline" id="Finite_state_transducer:51">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}T
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Finite_state_transducer:52">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}T
  </annotation>
 </semantics>
</math>

 accepts <em>x</em> if and only if there exists a string <em>y</em> for which 

<math display="inline" id="Finite_state_transducer:53">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>T</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>T</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[T]y
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<dl>
<dd>The second projection, 

<math display="inline" id="Finite_state_transducer:54">
 <semantics>
  <msub>
   <mi>π</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{2}
  </annotation>
 </semantics>
</math>

 is defined similarly.
</dd>
</dl>
<ul>
<li><a class="uri" href="Determinization" title="wikilink">Determinization</a>. Given a transducer <em>T</em>, we want to build an equivalent transducer which has a unique initial state and such that no two transitions leaving any state share the same input label. The <a href="powerset_construction" title="wikilink">powerset construction</a> can be extended to transducers, or even weighted transducers, but sometimes fails to halt; indeed, some non-deterministic transducers do not admit equivalent deterministic transducers.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a href="Characterization_(mathematics)" title="wikilink">Characterizations</a> of determinizable transducers have been proposed<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> along with efficient algorithms to test them:<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> they rely on the <a class="uri" href="semiring" title="wikilink">semiring</a> used in the weighted case as well as a general property on the structure of the transducer (the <a href="twins_property" title="wikilink">twins property</a>).</li>
</ul>
<ul>
<li>Weight pushing for the weighted case.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></li>
</ul>
<ul>
<li>Minimization for the weighted case.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></li>
</ul>
<ul>
<li>Removal of <a href="Nondeterministic_finite_automaton" title="wikilink">epsilon-transitions</a>.</li>
</ul>
<h2 id="additional-properties-of-finite-state-transducers">Additional properties of finite state transducers</h2>
<ul>
<li>It is <a href="Decidability_(logic)" title="wikilink">decidable</a> whether the relation [<em>T</em>] of a transducer <em>T</em> is empty.</li>
</ul>
<ul>
<li>It is decidable whether there exists a string <em>y</em> such that <em>x</em>[<em>T</em>]<em>y</em> for a given string <em>x</em>.</li>
</ul>
<ul>
<li>It is <a href="undecidable_problem" title="wikilink">undecidable</a> whether two transducers are equivalent.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Equivalence is however decidable in the special case where the relation [<em>T</em>] of a transducer <em>T</em> is a (partial) function.</li>
</ul>
<ul>
<li>If one defines the alphabet of labels 

<math display="inline" id="Finite_state_transducer:55">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Σ</mi>
      <mo>∪</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>ϵ</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>∪</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>ϵ</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <times></times>
     <apply>
      <union></union>
      <ci>normal-Σ</ci>
      <set>
       <ci>ϵ</ci>
      </set>
     </apply>
     <apply>
      <union></union>
      <ci>normal-Γ</ci>
      <set>
       <ci>ϵ</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=(\Sigma\cup\{\epsilon\})\times(\Gamma\cup\{\epsilon\})
  </annotation>
 </semantics>
</math>

, finite state transducers are isomorphic to <a href="nondeterministic_finite_automata" title="wikilink">NDFA</a> over the alphabet 

<math display="inline" id="Finite_state_transducer:56">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

, and may therefore be determinized (turned into <a href="deterministic_finite_automaton" title="wikilink">deterministic finite automata</a> over the alphabet 

<math display="inline" id="Finite_state_transducer:57">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi mathvariant="normal">Σ</mi>
        <mo>∪</mo>
        <mrow>
         <mo stretchy="false">{</mo>
         <mi>ϵ</mi>
         <mo stretchy="false">}</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>×</mo>
      <mi mathvariant="normal">Γ</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi mathvariant="normal">Σ</mi>
      <mo>×</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>∪</mo>
        <mrow>
         <mo stretchy="false">{</mo>
         <mi>ϵ</mi>
         <mo stretchy="false">}</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <union></union>
        <ci>normal-Σ</ci>
        <set>
         <ci>ϵ</ci>
        </set>
       </apply>
       <ci>normal-Γ</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>normal-Σ</ci>
       <apply>
        <union></union>
        <ci>normal-Γ</ci>
        <set>
         <ci>ϵ</ci>
        </set>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=[(\Sigma\cup\{\epsilon\})\times\Gamma]\cup[\Sigma\times(\Gamma\cup\{\epsilon%
\})]
  </annotation>
 </semantics>
</math>

 ) and subsequently minimized so that they have the minimum number of states.</li>
</ul>
<h2 id="applications">Applications</h2>

<p>Context-sensitive rewriting rules of the form <em>a → b / c _ d</em>, used in <a class="uri" href="linguistics" title="wikilink">linguistics</a> to model <a href="phonological_rule" title="wikilink">phonological rules</a> and <a href="sound_change" title="wikilink">sound change</a>, are computationally equivalent to finite-state transducers, provided that application is nonrecursive, i.e. the rule is not allowed to rewrite the same substring twice.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>Weighted FSTs found applications in <a href="natural_language_processing" title="wikilink">natural language processing</a>, including <a href="machine_translation" title="wikilink">machine translation</a>, and in <a href="machine_learning" title="wikilink">machine learning</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Mealy_machine" title="wikilink">Mealy machine</a></li>
<li><a href="Moore_machine" title="wikilink">Moore machine</a></li>
<li><a href="Morphological_dictionary" title="wikilink">Morphological dictionary</a></li>
<li><a href="foma_(software)" title="wikilink">foma (software)</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://openfst.org/">OpenFst</a>, an open-source library for FST operations.</li>
<li><a href="http://www.cis.uni-muenchen.de/~schmid/tools/SFST/">Stuttgart Finite State Transducer Tools</a>, another open-source FST toolkit</li>
<li><a href="http://jsalatas.ictpro.gr/java-fst-framework-api-review/">java FST Framework</a>, an open-source java FST Framework capable of handling OpenFst text format.</li>
<li><a href="http://vcsn.lrde.epita.fr/">Vcsn</a>, an open-source platform (C++ &amp; IPython) platform for weighted automata and rational expressions.</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>. <a href="http://www-igm.univ-mlv.fr/~berstel/LivreTransductions/LivreTransductions.html">Free PDF version</a></p></li>
</ul>

<p>"</p>

<p><a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a> <a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://www.let.rug.nl/~vannoord/papers/preds/node22.html">1</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a class="uri" href="http://www.cs.nyu.edu/~mohri/pub/fsmnlp08.pdf">http://www.cs.nyu.edu/~mohri/pub/fsmnlp08.pdf</a><a href="#fnref13">↩</a></li>
</ol>
</section>
</body>
</html>
