<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="644">Maximum flow problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Maximum flow problem</h1>
<hr/>

<p><a href="File:Max_flow.svg" title="wikilink">thumb|upright=1.5|A network with an example of maximum flow. The source is <em>s</em>, and the sink <em>t</em>. The numbers denote flow and capacity.</a> In <a href="Optimization_(mathematics)" title="wikilink">optimization theory</a>, <strong>maximum flow problems</strong> involve finding a feasible flow through a single-source, single-sink <a href="flow_network" title="wikilink">flow network</a> that is maximum.</p>

<p>The maximum flow problem can be seen as a special case of more complex network flow problems, such as the <a href="circulation_problem" title="wikilink">circulation problem</a>. The maximum value of an s-t flow (i.e., flow from <a href="Glossary_of_graph_theory#Direction" title="wikilink">source</a> s to <a href="Glossary_of_graph_theory#Direction" title="wikilink">sink</a> t) is equal to the minimum capacity of an <a href="Cut_(graph_theory)" title="wikilink">s-t cut</a> (i.e., cut severing s from t) in the network, as stated in the <a href="max-flow_min-cut_theorem" title="wikilink">max-flow min-cut theorem</a>.</p>
<h2 id="history">History</h2>

<p>The maximum flow problem was first formulated in 1954 by <a href="Ted_Harris_(mathematician)" title="wikilink">T. E. Harris</a> and F. S. Ross as a simplified model of Soviet railway traffic flow.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In 1955, <a href="Lester_R._Ford,_Jr." title="wikilink">Lester R. Ford, Jr.</a> and <a href="D._R._Fulkerson" title="wikilink">Delbert R. Fulkerson</a> created the first known algorithm, the <a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Over the years, various improved solutions to the maximum flow problem were discovered, notably the shortest augmenting path algorithm of Edmonds and Karp and independently Dinitz; the blocking flow algorithm of Dinitz; the push-relabel algorithm of <a href="Andrew_V._Goldberg" title="wikilink">Goldberg</a> and <a href="Robert_Tarjan" title="wikilink">Tarjan</a>; and the binary blocking flow algorithm of Goldberg and Rao. The electrical flow algorithm of Christiano, Kelner, Madry, and Spielman finds an approximately optimal maximum flow but only works in undirected graphs.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="definition">Definition</h2>

<p><a href="File:MFP1.jpg" title="wikilink">thumb|upright=0.8|A flow network, with source s and sink t. The numbers next to the edge are the capacities.</a> Let 

<math display="inline" id="Maximum_flow_problem:0">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle N=(V,E)
  </annotation>
 </semantics>
</math>

 be a network with 

<math display="inline" id="Maximum_flow_problem:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
   </mrow>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>s</ci>
     <ci>t</ci>
    </list>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle s,t\in V
  </annotation>
 </semantics>
</math>

 being the source and the sink of 

<math display="inline" id="Maximum_flow_problem:2">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle N
  </annotation>
 </semantics>
</math>

 respectively.</p>
<dl>
<dd>The <strong>capacity</strong> of an edge is a mapping 

<math display="inline" id="Maximum_flow_problem:3">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>:</mo>
   <mrow>
    <mi>E</mi>
    <mo>→</mo>
    <msup>
     <mi>ℝ</mi>
     <mo>+</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>c</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle c:E\to\mathbb{R}^{+}
  </annotation>
 </semantics>
</math>

, denoted by 

<math display="inline" id="Maximum_flow_problem:4">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>u</mi>
    <mi>v</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle c_{uv}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Maximum_flow_problem:5">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle c(u,v)
  </annotation>
 </semantics>
</math>

. It represents the maximum amount of flow that can pass through an edge.
</dd>
</dl>
<dl>
<dd>A <strong>flow</strong> is a mapping 

<math display="inline" id="Maximum_flow_problem:6">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>E</mi>
    <mo>→</mo>
    <msup>
     <mi>ℝ</mi>
     <mo>+</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f:E\to\mathbb{R}^{+}
  </annotation>
 </semantics>
</math>

, denoted by 

<math display="inline" id="Maximum_flow_problem:7">
 <semantics>
  <msub>
   <mi>f</mi>
   <mrow>
    <mi>u</mi>
    <mi>v</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f_{uv}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Maximum_flow_problem:8">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f(u,v)
  </annotation>
 </semantics>
</math>

, subject to the following two constraints:
<dl>
<dd>1. 

<math display="inline" id="Maximum_flow_problem:9">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>u</mi>
     <mi>v</mi>
    </mrow>
   </msub>
   <mo>≤</mo>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>u</mi>
     <mi>v</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f_{uv}\leq c_{uv}
  </annotation>
 </semantics>
</math>

, for each 

<math display="inline" id="Maximum_flow_problem:10">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle(u,v)\in E
  </annotation>
 </semantics>
</math>

 (capacity constraint: the flow of an edge cannot exceed its capacity)
</dd>
<dd>2. 

<math display="inline" id="Maximum_flow_problem:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>u</mi>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo>,</mo>
        <mi>v</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∈</mo>
       <mi>E</mi>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mi>f</mi>
     <mrow>
      <mi>u</mi>
      <mi>v</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>u</mi>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo>,</mo>
        <mi>u</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∈</mo>
       <mi>E</mi>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mi>f</mi>
     <mrow>
      <mi>v</mi>
      <mi>u</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <ci>normal-:</ci>
       <ci>u</ci>
       <apply>
        <in></in>
        <interval closure="open">
         <ci>u</ci>
         <ci>v</ci>
        </interval>
        <ci>E</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>u</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <ci>normal-:</ci>
       <ci>u</ci>
       <apply>
        <in></in>
        <interval closure="open">
         <ci>v</ci>
         <ci>u</ci>
        </interval>
        <ci>E</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>v</ci>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\sum_{u:(u,v)\in E}f_{uv}=\sum_{u:(v,u)\in E}f_{vu}
  </annotation>
 </semantics>
</math>

, for each 

<math display="inline" id="Maximum_flow_problem:12">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mrow>
    <mi>V</mi>
    <mo>∖</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <setdiff></setdiff>
     <ci>V</ci>
     <set>
      <ci>s</ci>
      <ci>t</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle v\in V\setminus\{s,t\}
  </annotation>
 </semantics>
</math>

 (conservation of flows: the sum of the flows entering a node must equal the sum of the flows exiting a node, except for the source and the sink nodes)
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>The <strong>value of flow</strong> is defined by 

<math display="inline" id="Maximum_flow_problem:13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>f</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>v</mi>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo>,</mo>
        <mi>v</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∈</mo>
       <mi>E</mi>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mi>f</mi>
     <mrow>
      <mi>s</mi>
      <mi>v</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>f</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <ci>normal-:</ci>
       <ci>v</ci>
       <apply>
        <in></in>
        <interval closure="open">
         <ci>s</ci>
         <ci>v</ci>
        </interval>
        <ci>E</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle|f|=\sum_{v:(s,v)\in E}f_{sv}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Maximum_flow_problem:14">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle s
  </annotation>
 </semantics>
</math>

 is the source of 

<math display="inline" id="Maximum_flow_problem:15">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle N
  </annotation>
 </semantics>
</math>

. It represents the amount of flow passing from the source to the sink.
</dd>
</dl>

<p>The <strong>maximum flow problem</strong> is to maximize 

<math display="inline" id="Maximum_flow_problem:16">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>f</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle|f|
  </annotation>
 </semantics>
</math>

, that is, to route as much flow as possible from 

<math display="inline" id="Maximum_flow_problem:17">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Maximum_flow_problem:18">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle t
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="solutions">Solutions</h2>

<p>We can define the <strong>Residual Graph</strong>, which provides a systematic way to search for forward-backward operations in order to find the maximum flow.</p>

<p>Given a flow network 

<math display="inline" id="Maximum_flow_problem:19">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle G
  </annotation>
 </semantics>
</math>

, and a flow 

<math display="inline" id="Maximum_flow_problem:20">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Maximum_flow_problem:21">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle G
  </annotation>
 </semantics>
</math>

, we define the residual graph 

<math display="inline" id="Maximum_flow_problem:22">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle G_{f}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Maximum_flow_problem:23">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle G
  </annotation>
 </semantics>
</math>

 with respect to 

<math display="inline" id="Maximum_flow_problem:24">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f
  </annotation>
 </semantics>
</math>

 as follows.</p>

<p>1. The node set of 

<math display="inline" id="Maximum_flow_problem:25">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle G_{f}
  </annotation>
 </semantics>
</math>

 is the same as that of 

<math display="inline" id="Maximum_flow_problem:26">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle G
  </annotation>
 </semantics>
</math>

.</p>

<p>2. Each edge 

<math display="inline" id="Maximum_flow_problem:27">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle e=(u,v)
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Maximum_flow_problem:28">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle G_{f}
  </annotation>
 </semantics>
</math>

 is with a capacity of 

<math display="inline" id="Maximum_flow_problem:29">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>e</mi>
   </msub>
   <mo>-</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle c_{e}-f(e)
  </annotation>
 </semantics>
</math>

.</p>

<p>3. Each edge 

<math display="inline" id="Maximum_flow_problem:30">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>normal-′</ci>
    </apply>
    <interval closure="open">
     <ci>v</ci>
     <ci>u</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle e^{\prime}=(v,u)
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Maximum_flow_problem:31">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle G_{f}
  </annotation>
 </semantics>
</math>

 is with a capacity of 

<math display="inline" id="Maximum_flow_problem:32">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f(e)
  </annotation>
 </semantics>
</math>

.</p>

<p>The following table lists algorithms for solving the maximum flow problem.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Method</p></th>
<th style="text-align: left;">
<p>Complexity</p></th>
<th style="text-align: left;">
<p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Linear_programming" title="wikilink">Linear programming</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Constraints given by the definition of a <a href="flow_network" title="wikilink">legal flow</a>. See the <a href="Max-flow_min-cut_theorem#Linear_program_formulation" title="wikilink">linear program</a> here.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>E</em> max| <em>f</em> |)</p></td>
<td style="text-align: left;">
<p>As long as there is an open path through the residual graph, send the minimum of the residual capacities on the path. The algorithm is only guaranteed to terminate if all weights are <a href="rational_numbers" title="wikilink">rational</a>. Otherwise it is possible that the algorithm will not converge to the maximum value. However, if the algorithm terminates, it is guaranteed to find the maximum value.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Edmonds–Karp_algorithm" title="wikilink">Edmonds–Karp algorithm</a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>VE</em><sup>2</sup>)</p></td>
<td style="text-align: left;">
<p>A specialization of Ford–Fulkerson, finding augmenting paths with <a href="breadth-first_search" title="wikilink">breadth-first search</a>.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Dinic's_algorithm" title="wikilink">Dinic's blocking flow algorithm</a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>V</em><sup>2</sup><em>E</em>)</p></td>
<td style="text-align: left;">
<p>In each phase the algorithms builds a layered graph with <a href="breadth-first_search" title="wikilink">breadth-first search</a> on the <a href="residual_graph" title="wikilink">residual graph</a>. The maximum flow in a layered graph can be calculated in <em>O</em>(<em>VE</em>) time, and the maximum number of the phases is <em>n</em>-1. In networks with unit capacities, Dinic's algorithm terminates in 

<math display="inline" id="Maximum_flow_problem:33">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <msqrt>
      <mi>V</mi>
     </msqrt>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <root></root>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptscriptstyle O(E\sqrt{V})
  </annotation>
 </semantics>
</math>

 time.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>MPM (Malhotra, Pramodh-Kumar and Maheshwari) algorithm<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>V</em><sup>3</sup>)</p></td>
<td style="text-align: left;">
<p>Refer to the <a href="http://dx.doi.org/10.1016/0020-0190(78)90016-9">Original Paper</a>.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Dinic's_algorithm" title="wikilink">Dinic's algorithm</a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>VE</em> log(<em>V</em>))</p></td>
<td style="text-align: left;">
<p>The <a href="dynamic_trees" title="wikilink">dynamic trees</a> data structure speeds up the maximum flow computation in the layered graph to <em>O</em>(<em>E</em>log(<em>V</em>)).</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Relabel-to-front_algorithm" title="wikilink">General push-relabel maximum flow algorithm</a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>V</em><sup>2</sup><em>E</em>)</p></td>
<td style="text-align: left;">
<p>The push relabel algorithm maintains a preflow, i.e. a flow function with the possibility of excess in the vertices. The algorithm runs while there is a vertex with positive excess, i.e. an active vertex in the graph. The push operation increases the flow on a residual edge, and a height function on the vertices controls which residual edges can be pushed. The height function is changed with a relabel operation. The proper definitions of these operations guarantee that the resulting flow function is a maximum flow.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Relabel-to-front_algorithm" title="wikilink">Push-relabel algorithm with <em>FIFO</em> vertex selection rule</a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>V</em><sup>3</sup>)</p></td>
<td style="text-align: left;">
<p>Push-relabel algorithm variant which always selects the most recently active vertex, and performs push operations until the excess is positive or there are admissible residual edges from this vertex.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Relabel-to-front_algorithm" title="wikilink">Push-relabel algorithm with dynamic trees</a></p></td>
<td style="text-align: left;">
<p><em>O</em>(<em>VE</em> log(<em>V</em><sup>2</sup>/<em>E</em>))</p></td>
<td style="text-align: left;">
<p>The algorithm builds limited size trees on the residual graph regarding to height function. These trees provide multilevel push operations.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>KRT (King, Rao, Tarjan)'s algorithm<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Maximum_flow_problem:34">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <mi>V</mi>
     <mrow>
      <msub>
       <mi>log</mi>
       <mrow>
        <mrow>
         <mi>E</mi>
         <mo>/</mo>
         <mi>V</mi>
        </mrow>
        <mrow>
         <mi>log</mi>
         <mi>V</mi>
        </mrow>
       </mrow>
      </msub>
      <mi>V</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>V</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <ci>E</ci>
         <ci>V</ci>
        </apply>
        <apply>
         <log></log>
         <ci>V</ci>
        </apply>
       </apply>
      </apply>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptscriptstyle O(EV\log_{E/V\log V}V)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Binary blocking flow algorithm<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Maximum_flow_problem:35">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mi>min</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>V</mi>
        <mrow>
         <mn>2</mn>
         <mo>/</mo>
         <mn>3</mn>
        </mrow>
       </msup>
       <mo>,</mo>
       <msqrt>
        <mi>E</mi>
       </msqrt>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>V</mi>
         <mn>2</mn>
        </msup>
        <mo>/</mo>
        <mi>E</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>log</mi>
      <mi>U</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <min></min>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <root></root>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>V</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <log></log>
      <ci>U</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptscriptstyle O(E\min(V^{2/3},\sqrt{E})\log(V^{2}/E)\log{U})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>The value <em>U</em> corresponds to the maximum capacity of the network.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Jim Orlin's + KRT (King, Rao, Tarjan)'s algorithm<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Maximum_flow_problem:36">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptscriptstyle O(VE)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><a href="http://jorlin.scripts.mit.edu/Max_flows_in_O(nm)_time.html">Orlin's algorithm</a> solves max-flow in <em>O</em>(<em>VE</em>) time for 

<math display="inline" id="Maximum_flow_problem:37">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>≤</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>V</mi>
      <mrow>
       <mfrac>
        <mn>16</mn>
        <mn>15</mn>
       </mfrac>
       <mo>-</mo>
       <mi>ϵ</mi>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>E</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">16</cn>
        <cn type="integer">15</cn>
       </apply>
       <ci>ϵ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\leq O(V^{{16\over 15}-\epsilon})
  </annotation>
 </semantics>
</math>

 while KRT solves it in <em>O</em>(<em>VE</em>) for 

<math display="inline" id="Maximum_flow_problem:38">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>></mo>
   <msup>
    <mi>V</mi>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mi>ϵ</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>ϵ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E>V^{1+\epsilon}
  </annotation>
 </semantics>
</math>

.</p></td>
</tr>
</tbody>
</table>

<p>For a more extensive list, see<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="integral-flow-theorem">Integral flow theorem</h2>

<p>The integral flow theorem states that</p>
<dl>
<dd><strong>If each edge in a flow network has integral capacity, then there exists an integral maximal flow.</strong>
</dd>
</dl>
<h2 id="application">Application</h2>
<h3 id="multi-source-multi-sink-maximum-flow-problem">Multi-source multi-sink maximum flow problem</h3>

<p> Given a network <em>N</em> = (<em>V</em>,<em>E</em>) with a set of sources <em>S</em> = {<em>s</em><sub>1</sub>, ..., <em>s</em><sub>n</sub>} and a set of sinks <em>T</em> = {<em>t</em><sub>1</sub>, ..., <em>t</em><sub>m</sub>} instead of only one source and one sink, we are to find the maximum flow across <em>N</em>. We can transform the multi-source multi-sink problem into a maximum flow problem by adding a <em>consolidated source</em> connecting to each vertex in <em>S</em> and a ''consolidated sink ''connected by each vertex in <em>T</em> (also known as <em>supersource</em> and <em>supersink</em>) with infinite capacity on each edge (See Fig. 4.1.1.).</p>
<h3 id="minimum-path-cover-in-directed-acyclic-graph">Minimum path cover in directed acyclic graph</h3>

<p>Given a <a href="directed_acyclic_graph" title="wikilink">directed acyclic graph</a> <em>G</em> = (<em>V</em>, <em>E</em>), we are to find the minimum number of <a href="Path_(graph_theory)" title="wikilink">vertex-disjoint paths</a> to cover each vertex in <em>V</em>. We can construct a bipartite graph <em>G</em>' = (<em>V</em><sub><em>out</em></sub>∪<em>V</em><sub><em>in</em></sub>, <em>E</em>' ) from <em>G</em>, where</p>
<ol>
<li><em>V</em><sub><em>out</em></sub> = {<em>v</em>∈<em>V</em>: <em>v</em> has positive out-degree}.</li>
<li><em>V</em><sub><em>in</em></sub> = {<em>v</em>∈<em>V</em>: <em>v</em> has positive in-degree}.</li>
<li><em>E</em>' = {(<em>u</em>,<em>v</em>)∈<em>V</em><sub><em>out</em></sub>×<em>V</em><sub><em>in</em></sub>: (<em>u</em>,<em>v</em>)∈<em>E</em>}.</li>
</ol>

<p>Then it can be shown, via <a href="König's_theorem_(graph_theory)" title="wikilink">König's theorem</a>, that <em>G</em>' has a matching of size <em>m</em> if and only if there exists <em>n</em>-<em>m</em> vertex-disjoint paths that cover each vertex in <em>G</em>, where <em>n</em> is the number of vertices in <em>G</em>. Therefore, the problem can be solved by finding the maximum cardinality matching in <em>G</em>' instead.</p>
<h3 id="maximum-cardinality-bipartite-matching">Maximum cardinality bipartite matching</h3>

<p> Given a <a href="bipartite_graph" title="wikilink">bipartite graph</a> <em>G</em> = (<em>X</em>∪<em>Y</em>, <em>E</em>), we are to find a <a href="maximum_cardinality_matching" title="wikilink">maximum cardinality matching</a> in <em>G</em>, that is a matching that contains the largest possible number of edges. This problem can be transformed into a maximum flow problem by constructing a network <em>N</em> = (<em>X</em>∪<em>Y</em>∪{<em>s</em>,<em>t</em>), <em>E</em>' }, where</p>
<ol>
<li><em>E</em>' contains the edges in <em>G</em> directed from <em>X</em> to <em>Y</em>.</li>
<li>(<em>s</em>,<em>x</em>)∈<em>E</em>' for each <em>x</em>∈<em>X</em> and (<em>y</em>,<em>t</em>)∈<em>E</em>' for each <em>y</em>∈<em>Y</em>.</li>
<li><em>c</em>(<em>e</em>) = 1 for each <em>e</em>∈<em>E</em>' (See Fig. 4.3.1).</li>
</ol>

<p>Then the value of the maximum flow in <em>N</em> is equal to the size of the maximum matching in <em>G</em>.</p>
<h3 id="maximum-flow-problem-with-vertex-capacities">Maximum flow problem with vertex capacities</h3>

<p> Given a network 

<math display="inline" id="Maximum_flow_problem:39">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=(V,E)
  </annotation>
 </semantics>
</math>

, in which there is capacity at each node in addition to edge capacity, that is, a mapping 

<math display="inline" id="Maximum_flow_problem:40">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>:</mo>
   <mrow>
    <mi>V</mi>
    <mo>↦</mo>
    <msup>
     <mi>ℝ</mi>
     <mo>+</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>c</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c:V\mapsto\mathbb{R}^{+}
  </annotation>
 </semantics>
</math>

, denoted by 

<math display="inline" id="Maximum_flow_problem:41">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(v)
  </annotation>
 </semantics>
</math>

, such that the flow 

<math display="inline" id="Maximum_flow_problem:42">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 has to satisfy not only the capacity constraint and the conservation of flows, but also the vertex capacity constraint</p>
<center>

<p>

<math display="inline" id="Maximum_flow_problem:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
     </msub>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>i</mi>
       <mi>v</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>v</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>V</mi>
     <mo>\</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>v</ci>
     </apply>
     <apply>
      <ci>normal-\</ci>
      <ci>V</ci>
      <set>
       <ci>s</ci>
       <ci>t</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i\in V}f_{iv}\leq c(v)\qquad\forall v\in V\backslash\{s,t\}
  </annotation>
 </semantics>
</math>

.</p>
</center>

<p>In other words, the amount of flow passing through a vertex cannot exceed its capacity. To find the maximum flow across 

<math display="inline" id="Maximum_flow_problem:44">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, we can transform the problem into the maximum flow problem in the original sense by expanding 

<math display="inline" id="Maximum_flow_problem:45">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

. First, each 

<math display="inline" id="Maximum_flow_problem:46">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V
  </annotation>
 </semantics>
</math>

 is replaced by 

<math display="inline" id="Maximum_flow_problem:47">
 <semantics>
  <msub>
   <mi>v</mi>
   <mtext>in</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <mtext>in</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{\text{in}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Maximum_flow_problem:48">
 <semantics>
  <msub>
   <mi>v</mi>
   <mtext>out</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <mtext>out</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{\text{out}}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Maximum_flow_problem:49">
 <semantics>
  <msub>
   <mi>v</mi>
   <mtext>in</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <mtext>in</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{\text{in}}
  </annotation>
 </semantics>
</math>

 is connected by edges going into 

<math display="inline" id="Maximum_flow_problem:50">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Maximum_flow_problem:51">
 <semantics>
  <msub>
   <mi>v</mi>
   <mtext>out</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <mtext>out</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{\text{out}}
  </annotation>
 </semantics>
</math>

 is connected to edges coming out from 

<math display="inline" id="Maximum_flow_problem:52">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, then assign capacity 

<math display="inline" id="Maximum_flow_problem:53">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(v)
  </annotation>
 </semantics>
</math>

 to the edge connecting 

<math display="inline" id="Maximum_flow_problem:54">
 <semantics>
  <msub>
   <mi>v</mi>
   <mtext>in</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <mtext>in</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{\text{in}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Maximum_flow_problem:55">
 <semantics>
  <msub>
   <mi>v</mi>
   <mtext>out</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <mtext>out</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{\text{out}}
  </annotation>
 </semantics>
</math>

 (see Fig. 4.4.1, but note that it has incorrectly swapped 

<math display="inline" id="Maximum_flow_problem:56">
 <semantics>
  <msub>
   <mi>v</mi>
   <mtext>in</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <mtext>in</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{\text{in}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Maximum_flow_problem:57">
 <semantics>
  <msub>
   <mi>v</mi>
   <mtext>out</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <mtext>out</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{\text{out}}
  </annotation>
 </semantics>
</math>

). In this expanded network, the vertex capacity constraint is removed and therefore the problem can be treated as the original maximum flow problem.</p>
<h3 id="maximum-edge-disjoint-path">Maximum edge-disjoint path</h3>

<p>Given a directed graph <em>G</em> = (<em>V</em>, <em>E</em>) and two vertices <em>s</em> and <em>t</em>, we are to find the maximum number of edge-disjoint paths from <em>s</em> to <em>t</em>. This problem can be transformed to a maximum flow problem by constructing a network <em>N</em> = (<em>V</em>, <em>E</em>) from <em>G</em> with <em>s</em> and <em>t</em> being the source and the sink of <em>N</em> respectively and assign each edge with unit capacity.</p>
<h3 id="maximum-independent-vertex-disjoint-path">Maximum independent (vertex-disjoint) path</h3>

<p>Given a directed graph <em>G</em> = (<em>V</em>, <em>E</em>) and two vertices <em>s</em> and <em>t</em>, we are to find the maximum number of independent paths from <em>s</em> to <em>t</em>. Two paths are said to be independent if they do not have a vertex in common apart from <em>s</em> and <em>t</em>. We can construct a network <em>N</em> = (<em>V</em>, <em>E</em>) from <em>G</em> with vertex capacities, where</p>
<ol>
<li><em>s</em> and <em>t</em> are the source and the sink of <em>N</em> respectively.</li>
<li><em>c</em>(<em>v</em>) = 1 for each <em>v</em>∈<em>V</em>.</li>
<li><em>c</em>(<em>e</em>) = 1 for each <em>e</em>∈<em>E</em>.</li>
</ol>

<p>Then the value of the maximum flow is equal to the maximum number of independent paths from <em>s</em> to <em>t</em>.</p>
<h2 id="real-world-applications">Real world applications</h2>
<h3 id="baseball-elimination">Baseball Elimination</h3>

<p>In the Baseball Elimination Problem there are <em>n</em> teams competing in a league. At a specific stage of the league season, <em>w</em><sub>i</sub> is the number of wins and <em>r</em><sub>i</sub> is the number of games left to play for team <em>i</em> and <em>r</em><sub>ij</sub> is the number of games left against team <em>j</em>. A team is eliminated if it has no chance to finish the season in the first place. The task of Baseball Elimination Problem is to determine which teams are eliminated at each point during the season. Schwartz<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> proposed a method which reduces this problem to maximum network flow. In this method a network is created to determine whether team <em>k</em> is eliminated.</p>

<p>Let <em>G</em> = (<em>V</em>, <em>E</em>) be a network with <em>s</em>,<em>t</em> ∈ <em>V</em> being the source and the sink respectively. We add a game node {<em>i</em>,<em>j</em>} with <em>i</em> ij — which represents the number of plays between these two teams. We also add a team node for each team and connect each game node {<em>i</em>,<em>j</em>} with to team nodes <em>i</em> and <em>j</em> to ensure one of them wins. We do not need to restrict the flow value on these edges. Finally, we make edges from team node <em>i</em> to the sink node <em>t</em> and set the capacity of <em>w</em><sub>k</sub>+<em>r</em><sub>k</sub>–<em>w</em><sub>i</sub> to prevent team <em>i</em> from winning more than <em>w</em><sub>k</sub>+<em>r</em><sub>k</sub>. Let <em>S</em> be the set of all team participating in the league and let 

<math display="inline" id="Maximum_flow_problem:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>k</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
       <mo>∈</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mrow>
         <mi>S</mi>
         <mo>-</mo>
         <mrow>
          <mo stretchy="false">{</mo>
          <mi>k</mi>
          <mo stretchy="false">}</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>i</mi>
       <mo><</mo>
       <mi>j</mi>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <apply>
      <minus></minus>
      <ci>S</ci>
      <set>
       <ci>k</ci>
      </set>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
        <set>
         <apply>
          <minus></minus>
          <ci>S</ci>
          <set>
           <ci>k</ci>
          </set>
         </apply>
        </set>
       </apply>
       <apply>
        <lt></lt>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle r(S-\{k\})=\sum_{i,j\in\{S-\{k\}\},i<j}r_{ij}
  </annotation>
 </semantics>
</math>

. In this method it is claimed team <em>k</em> is not eliminated if and only if a flow value of size <em>r</em>(<em>S</em> - {<em>k</em>}) exists in network <em>G</em>. In the mentioned article it is proved that this flow value is the maximum flow value from <em>s</em> to <em>t</em>.</p>
<h3 id="airline-scheduling">Airline scheduling</h3>

<p>In the airline industry a major problem is the scheduling of the flight crews. Airline scheduling problem could be considered as an application of extended maximum network flow. The input of this problem is a set of flights <em>F</em> which contains the information about where and when each flight departs and arrives. In one version of Airline Scheduling the goal is to produce a feasible schedule with at most <em>k</em> crews.</p>

<p>In order to solve this problem we use a variation of <a href="circulation_problem" title="wikilink">circulation problem</a> called bounded circulation which is the generalization of <a href="flow_network" title="wikilink">network flow</a> problems, with the added constraint of a lower bound on edge flows.</p>

<p>Let <em>G</em> = (<em>V</em>, <em>E</em>) be a network with <em>s</em>,<em>t</em> ∈ <em>V</em> as the source and the sink nodes. For the source and destination of every flight <em>i</em> we add two nodes to <em>V</em>, node <em>s</em><sub>i</sub> as the source and node <em>d</em><sub>i</sub> as the destination node of flight <em>i</em>. We also add the following edges to <em>E</em>:</p>
<ol>
<li>An edge with capacity [0, 1] between <em>s</em> and each <em>s</em><sub>i</sub>.</li>
<li>An edge with capacity [0, 1] between each <em>d</em><sub>i</sub> and <em>t</em>.</li>
<li>An edge with capacity [1, 1] between each pair of <em>s</em><sub>i</sub> and <em>d</em><sub>i</sub>.</li>
<li>An edge with capacity [0, 1] between each <em>d</em><sub>i</sub> and <em>s</em><sub>j</sub>, if source <em>s</em><sub>j</sub> is reachable with a reasonable amount of time and cost from the destination of flight <em>i</em>.</li>
<li>An edge with capacity [0, <em><big>∞</big></em>] between <em>s</em> and <em>t</em>.</li>
</ol>

<p>In the mentioned method, it is claimed and proved that finding a flow value of <em>k</em> in <em>G</em> between <em>s</em> and <em>t</em> is equal to finding a feasible schedule for flight set <em>F</em> with at most <em>k</em> crews.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>Another version of Airline Scheduling is finding the minimum needed crews to perform all the flights. In order to find an answer to this problem we create a bipartite graph <em>G’</em> = (<em>A</em> ∪ <em>B</em>, <em>E</em>) where each flight has a copy in set <em>A</em> and set <em>B</em>. If the same plane can perform flight <em>j</em> after flight <em>i</em>, connect <em>i</em>∈<em>A</em> to <em>j</em>∈<em>B</em>. A matching in <em>G’</em> induces a schedule for <em>F</em> and obviously maximum bipartite matching in this graph produces the an airline schedule with minimum number of crews.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> As it is mentioned in the Application part of this article, the maximum cardinality bipartite matching is an application of maximum flow problem.</p>
<h3 id="circulation-demand-problem">Circulation-demand problem</h3>

<p>There are some factories that produce goods and some villages where the goods have to be delivered. They are connected by a networks of roads with each road having a capacity 

<math display="inline" id="Maximum_flow_problem:59">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 for maximum goods that can flow through it. The problem is to find if there is a circulation that satisfies the demand. This problem can be transformed into a max-flow problem.</p>
<ol>
<li>Add a source node 

<math display="inline" id="Maximum_flow_problem:60">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and add edges from it to every factory node 

<math display="inline" id="Maximum_flow_problem:61">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>

 with capacity 

<math display="inline" id="Maximum_flow_problem:62">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Maximum_flow_problem:63">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 is the production rate of factory 

<math display="inline" id="Maximum_flow_problem:64">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>

.</li>
<li>Add a sink node 

<math display="inline" id="Maximum_flow_problem:65">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and add edges from all villages 

<math display="inline" id="Maximum_flow_problem:66">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Maximum_flow_problem:67">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 with capacity 

<math display="inline" id="Maximum_flow_problem:68">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{i}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Maximum_flow_problem:69">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{i}
  </annotation>
 </semantics>
</math>

 is the demand rate of village 

<math display="inline" id="Maximum_flow_problem:70">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Let <em>G</em> = (<em>V</em>, <em>E</em>) be this new network. There exists a circulation that satisfies the demand if and only if :</p>

<p>

<math display="block" id="Maximum_flow_problem:71">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="4.2pt">MaximumFlowValue</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>v</mi>
     </mrow>
    </munder>
    <msub>
     <mi>d</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>MaximumFlowValue</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{MaximumFlowValue}\,(G)=\sum_{i\in v}d_{i}
  </annotation>
 </semantics>
</math>

 If there exists a circulation, looking at the max-flow solution would give us the answer as to how much goods have to be send on a particular road for satisfying the demands.</p>
<h3 id="fairness-in-car-sharing-carpool">Fairness in car sharing (carpool)</h3>

<p>The problem exactly is that 

<math display="inline" id="Maximum_flow_problem:72">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 people are pooling a car for 

<math display="inline" id="Maximum_flow_problem:73">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 days. Each participant can choose if he participates on each day. We aim to fairly decide who will be driving on a given day.<br/>
The solution is the following:<br/>
We can decide this on the basis of the number of people using the car i.e.; if 

<math display="inline" id="Maximum_flow_problem:74">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 people use the car on a day, each person has a responsibility of 

<math display="inline" id="Maximum_flow_problem:75">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/m
  </annotation>
 </semantics>
</math>

. Thus, for every person 

<math display="inline" id="Maximum_flow_problem:76">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, his driving obligation 

<math display="inline" id="Maximum_flow_problem:77">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{i}
  </annotation>
 </semantics>
</math>

 as shown. Then person 

<math display="inline" id="Maximum_flow_problem:78">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is required to drive only 

<math display="inline" id="Maximum_flow_problem:79">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <msub>
    <mi>D</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [D_{i}]
  </annotation>
 </semantics>
</math>

 times in 

<math display="inline" id="Maximum_flow_problem:80">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 days.<br/>
Our aim is to ﬁnd if such a setting is possible. For this we try to model the problem as a network.<br/>
Now, it can be proved that if a ﬂow 

<math display="inline" id="Maximum_flow_problem:81">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 exists then such a fair setting exists and such a ﬂow of value 

<math display="inline" id="Maximum_flow_problem:82">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 always exists.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Closure_problem" title="wikilink">Closure problem</a></li>
<li><a href="Minimum-cost_flow_problem" title="wikilink">Minimum-cost flow problem</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Network_flow" title="wikilink">Category:Network flow</a> <a href="Category:Mathematical_problems" title="wikilink">Category:Mathematical problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Ford, L.R., Jr.; Fulkerson, D.R., <em>Flows in Networks</em>, Princeton University Press (1962).<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
</ol>
</section>
</body>
</html>
