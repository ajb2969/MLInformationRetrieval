   Gaussâ€“Seidel method      Gaussâ€“Seidel method  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     In numerical linear algebra , the Gaussâ€“Seidel method , also known as the Liebmann method or the method of successive displacement , is an iterative method used to solve a linear system of equations . It is named after the German  mathematicians  Carl Friedrich Gauss and Philipp Ludwig von Seidel , and is similar to the Jacobi method . Though it can be applied to any matrix with non-zero elements on the diagonals, convergence is only guaranteed if the matrix is either diagonally dominant , or symmetric and positive definite . It was only mentioned in a private letter from Gauss to his student Gerling in 1823. 1 A publication was not delivered before 1874 by Seidel.  Description  The Gaussâ€“Seidel method is an iterative technique for solving a square system of n linear equations with unknown x :       A  ğ±   =  ğ›        A  ğ±   ğ›    A\mathbf{x}=\mathbf{b}   .  It is defined by the iteration         L  *    ğ±   (   k  +  1   )     =   ğ›  -   U   ğ±   (  k  )       ,         subscript  L     superscript  ğ±    k  1       ğ›    U   superscript  ğ±  k       L_{*}\mathbf{x}^{(k+1)}=\mathbf{b}-U\mathbf{x}^{(k)},     where    ğ±   (  k  )      superscript  ğ±  k    \mathbf{x}^{(k)}   is the k th approximation or iteration of    ğ±  ,   ğ±   k  +  1       ğ±   superscript  ğ±    k  1      \mathbf{x},\,\mathbf{x}^{k+1}   is the next or k + 1 iteration of   ğ±   ğ±   \mathbf{x}   , and the matrix A is decomposed into a lower triangular component    L  *     subscript  L     L_{*}   , and a strictly upper triangular component U     A  =    L  *   +  U       A     subscript  L    U     A=L_{*}+U   . 2  In more detail, write out A , x and b in their components:        A  =   [      a  11      a  12     â‹¯     a   1  n         a  21      a  22     â‹¯     a   2  n        â‹®    â‹®    â‹±    â‹®       a   n  1       a   n  2      â‹¯     a   n  n       ]    ,    ğ±  =   [      x  1        x  2       â‹®       x  n      ]    ,   ğ›  =   [      b  1        b  2       â‹®       b  n      ]      .     formulae-sequence    A     subscript  a  11    subscript  a  12   normal-â‹¯   subscript  a    1  n       subscript  a  21    subscript  a  22   normal-â‹¯   subscript  a    2  n      normal-â‹®  normal-â‹®  normal-â‹±  normal-â‹®     subscript  a    n  1     subscript  a    n  2    normal-â‹¯   subscript  a    n  n        formulae-sequence    ğ±     subscript  x  1      subscript  x  2     normal-â‹®     subscript  x  n        ğ›     subscript  b  1      subscript  b  2     normal-â‹®     subscript  b  n         A=\begin{bmatrix}a_{11}&a_{12}&\cdots&a_{1n}\\
 a_{21}&a_{22}&\cdots&a_{2n}\\
 \vdots&\vdots&\ddots&\vdots\\
 a_{n1}&a_{n2}&\cdots&a_{nn}\end{bmatrix},\qquad\mathbf{x}=\begin{bmatrix}x_{1}%
 \\
 x_{2}\\
 \vdots\\
 x_{n}\end{bmatrix},\qquad\mathbf{b}=\begin{bmatrix}b_{1}\\
 b_{2}\\
 \vdots\\
 b_{n}\end{bmatrix}.     Then the decomposition of A into its lower triangular component and its strictly upper triangular component is given by:        A  =     L  *   +  U   where       L  *   =   [      a  11     0    â‹¯    0       a  21      a  22     â‹¯    0      â‹®    â‹®    â‹±    â‹®       a   n  1       a   n  2      â‹¯     a   n  n       ]    ,   U  =   [     0     a  12     â‹¯     a   1  n        0    0    â‹¯     a   2  n        â‹®    â‹®    â‹±    â‹®      0    0    â‹¯    0     ]      .     formulae-sequence    A      subscript  L    U   where     formulae-sequence     subscript  L       subscript  a  11   0  normal-â‹¯  0     subscript  a  21    subscript  a  22   normal-â‹¯  0    normal-â‹®  normal-â‹®  normal-â‹±  normal-â‹®     subscript  a    n  1     subscript  a    n  2    normal-â‹¯   subscript  a    n  n         U    0   subscript  a  12   normal-â‹¯   subscript  a    1  n      0  0  normal-â‹¯   subscript  a    2  n      normal-â‹®  normal-â‹®  normal-â‹±  normal-â‹®    0  0  normal-â‹¯  0        A=L_{*}+U\qquad\text{where}\qquad L_{*}=\begin{bmatrix}a_{11}&0&\cdots&0\\
 a_{21}&a_{22}&\cdots&0\\
 \vdots&\vdots&\ddots&\vdots\\
 a_{n1}&a_{n2}&\cdots&a_{nn}\end{bmatrix},\quad U=\begin{bmatrix}0&a_{12}&%
 \cdots&a_{1n}\\
 0&0&\cdots&a_{2n}\\
 \vdots&\vdots&\ddots&\vdots\\
 0&0&\cdots&0\end{bmatrix}.     The system of linear equations may be rewritten as:        L  *   ğ±   =   ğ›  -   U  ğ±           subscript  L    ğ±     ğ›    U  ğ±      L_{*}\mathbf{x}=\mathbf{b}-U\mathbf{x}     The Gaussâ€“Seidel method now solves the left hand side of this expression for x , using previous value for x on the right hand side. Analytically, this may be written as:        ğ±   (   k  +  1   )    =    L  *   -  1     (   ğ›  -   U   ğ±   (  k  )      )     .       superscript  ğ±    k  1       superscript   subscript  L      1      ğ›    U   superscript  ğ±  k        \mathbf{x}^{(k+1)}=L_{*}^{-1}(\mathbf{b}-U\mathbf{x}^{(k)}).     However, by taking advantage of the triangular form of    L  *     subscript  L     L_{*}   , the elements of x ( k +1) can be computed sequentially using forward substitution :      Ï‰  =  1      Ï‰  1    \omega=1    3  The procedure is generally continued until the changes made by an iteration are below some tolerance, such as a sufficiently small residual .  Discussion  The element-wise formula for the Gaussâ€“Seidel method is extremely similar to that of the Jacobi method .  The computation of x i ( k +1) uses only the elements of x ( k +1) that have already been computed, and only the elements of x ( k ) that have not yet to be advanced to iteration k +1. This means that, unlike the Jacobi method, only one storage vector is required as elements can be overwritten as they are computed, which can be advantageous for very large problems.  However, unlike the Jacobi method, the computations for each element cannot be done in parallel . Furthermore, the values at each iteration are dependent on the order of the original equations.  Gauss-Seidel is the same as SOR (successive over-relaxation) with   A   A   A   .  Convergence  The convergence properties of the Gaussâ€“Seidel method are dependent on the matrix A . Namely, the procedure is known to converge if either:   A is symmetric positive-definite , 4 or  A is strictly or irreducibly diagonally dominant .   The Gaussâ€“Seidel method sometimes converges even if these conditions are not satisfied.  Algorithm  Since elements can be overwritten as they are computed in this algorithm, only one storage vector is needed, and vector indexing is omitted. The algorithm goes as follows:  Inputs:    b   b   b    ,    Ï•   Ï•   \phi     Output    Ï•   Ï•   \phi      ChooseÂ anÂ initialÂ guess    i   i   i    toÂ theÂ solution  repeat untilÂ convergence   for     n   n   n     from 1 until      Ïƒ  â†  0     normal-â†  Ïƒ  0    \sigma\leftarrow 0     do      j   j   j      for     n   n   n     from 1 until     j   j   j     do   if     i   i   i    â‰      Ïƒ  â†   Ïƒ  +    a   i  j     Ï•  j        normal-â†  Ïƒ    Ïƒ     subscript  a    i  j     subscript  Ï•  j       \sigma\leftarrow\sigma+a_{ij}\phi_{j}     then      j   j   j      end  if   end (      Ï•  i   â†    1   a   i  i      (    b  i   -  Ïƒ   )       normal-â†   subscript  Ï•  i       1   subscript  a    i  i        subscript  b  i   Ïƒ      \phi_{i}\leftarrow\frac{1}{a_{ii}}(b_{i}-\sigma)    -loop)      i   i   i      end (      A  ğ±   =  ğ›        A  ğ±   ğ›    A\mathbf{x}=\mathbf{b}    -loop)  checkÂ ifÂ convergenceÂ isÂ reached  end (repeat)  Examples  An example for the matrix version  A linear system shown as    A  =   [     16    3      7     -  11      ]       A    16  3    7    11       A=\begin{bmatrix}16&3\\
 7&-11\\
 \end{bmatrix}   is given by:       b  =   [     11      13     ]    .      b    11    13      b=\begin{bmatrix}11\\
 13\end{bmatrix}.   and     ğ±   (   k  +  1   )    =    L  *   -  1     (   ğ›  -   U   ğ±   (  k  )      )         superscript  ğ±    k  1       superscript   subscript  L      1      ğ›    U   superscript  ğ±  k        \mathbf{x}^{(k+1)}=L_{*}^{-1}(\mathbf{b}-U\mathbf{x}^{(k)})     We want to use the equation       ğ±   (   k  +  1   )    =    T   ğ±   (  k  )     +  C        superscript  ğ±    k  1        T   superscript  ğ±  k    C     \mathbf{x}^{(k+1)}=T\mathbf{x}^{(k)}+C     in the form      T  =   -    L  *   -  1    U        T       superscript   subscript  L      1    U      T=-L_{*}^{-1}U     where:       C  =    L  *   -  1    ğ›    .      C     superscript   subscript  L      1    ğ›     C=L_{*}^{-1}\mathbf{b}.   and   A   A   A     We must decompose    L  *     subscript  L     L_{*}   into the sum of a lower triangular component   U   U   U   and a strict upper triangular component     L  *   =   [     16    0      7     -  11      ]        subscript  L      16  0    7    11       L_{*}=\begin{bmatrix}16&0\\
 7&-11\\
 \end{bmatrix}   :       U  =   [     0    3      0    0     ]    .      U    0  3    0  0      U=\begin{bmatrix}0&3\\
 0&0\end{bmatrix}.   and    L  *     subscript  L     L_{*}     The inverse of     L  *   -  1    =    [     16    0      7     -  11      ]    -  1    =   [     0.0625    0.0000      0.0398     -  0.0909      ]          superscript   subscript  L      1     superscript    16  0    7    11       1           0.0625  0.0000    0.0398    0.0909        L_{*}^{-1}=\begin{bmatrix}16&0\\
 7&-11\end{bmatrix}^{-1}=\begin{bmatrix}0.0625&0.0000\\
 0.0398&-0.0909\\
 \end{bmatrix}   is:       T  =   -    [     0.0625    0.0000      0.0398     -  0.0909      ]   Ã—   [     0    3      0    0     ]     =   [     0.000     -  0.1875       0.000     -  0.1193      ]    ,        T        0.0625  0.0000    0.0398    0.0909       0  3    0  0             0.000    0.1875     0.000    0.1193        T=-\begin{bmatrix}0.0625&0.0000\\
 0.0398&-0.0909\end{bmatrix}\times\begin{bmatrix}0&3\\
 0&0\end{bmatrix}=\begin{bmatrix}0.000&-0.1875\\
 0.000&-0.1193\end{bmatrix},   .  Now we can find:       C  =    [     0.0625    0.0000      0.0398     -  0.0909      ]   Ã—   [     11      13     ]    =   [     0.6875       -  0.7443      ]    .        C      0.0625  0.0000    0.0398    0.0909       11    13            0.6875      0.7443        C=\begin{bmatrix}0.0625&0.0000\\
 0.0398&-0.0909\end{bmatrix}\times\begin{bmatrix}11\\
 13\end{bmatrix}=\begin{bmatrix}0.6875\\
 -0.7443\end{bmatrix}.        T   T   T     Now we have   C   C   C   and   ğ±   ğ±   \mathbf{x}   and we can use them to obtain the vectors    ğ±   (  0  )      superscript  ğ±  0    \mathbf{x}^{(0)}   iteratively.  First of all, we have to choose      x   (  0  )    =   [     1.0      1.0     ]    .       superscript  x  0     1.0    1.0      x^{(0)}=\begin{bmatrix}1.0\\
 1.0\end{bmatrix}.   : we can only guess. The better the guess, the quicker the algorithm will perform.  We suppose:        x   (  1  )    =     [     0.000     -  0.1875       0.000     -  0.1193      ]   Ã—   [     1.0      1.0     ]    +   [     0.6875       -  0.7443      ]    =   [     0.5000       -  0.8636      ]    .         superscript  x  1         0.000    0.1875     0.000    0.1193       1.0    1.0       0.6875      0.7443             0.5000      0.8636        x^{(1)}=\begin{bmatrix}0.000&-0.1875\\
 0.000&-0.1193\end{bmatrix}\times\begin{bmatrix}1.0\\
 1.0\end{bmatrix}+\begin{bmatrix}0.6875\\
 -0.7443\end{bmatrix}=\begin{bmatrix}0.5000\\
 -0.8636\end{bmatrix}.     We can then calculate:        x   (  2  )    =     [     0.000     -  0.1875       0.000     -  0.1193      ]   Ã—   [     0.5000       -  0.8636      ]    +   [     0.6875       -  0.7443      ]    =   [     0.8494       -  0.6413      ]    .         superscript  x  2         0.000    0.1875     0.000    0.1193       0.5000      0.8636        0.6875      0.7443             0.8494      0.6413        x^{(2)}=\begin{bmatrix}0.000&-0.1875\\
 0.000&-0.1193\end{bmatrix}\times\begin{bmatrix}0.5000\\
 -0.8636\end{bmatrix}+\begin{bmatrix}0.6875\\
 -0.7443\end{bmatrix}=\begin{bmatrix}0.8494\\
 -0.6413\end{bmatrix}.           x   (  3  )    =     [     0.000     -  0.1875       0.000     -  0.1193      ]   Ã—   [     0.8494       -  0.6413      ]    +   [     0.6875       -  0.7443      ]    =   [     0.8077       -  0.6678      ]    .         superscript  x  3         0.000    0.1875     0.000    0.1193       0.8494      0.6413        0.6875      0.7443             0.8077      0.6678        x^{(3)}=\begin{bmatrix}0.000&-0.1875\\
 0.000&-0.1193\end{bmatrix}\times\begin{bmatrix}0.8494\\
 -0.6413\\
 \end{bmatrix}+\begin{bmatrix}0.6875\\
 -0.7443\end{bmatrix}=\begin{bmatrix}0.8077\\
 -0.6678\end{bmatrix}.           x   (  4  )    =     [     0.000     -  0.1875       0.000     -  0.1193      ]   Ã—   [     0.8077       -  0.6678      ]    +   [     0.6875       -  0.7443      ]    =   [     0.8127       -  0.6646      ]    .         superscript  x  4         0.000    0.1875     0.000    0.1193       0.8077      0.6678        0.6875      0.7443             0.8127      0.6646        x^{(4)}=\begin{bmatrix}0.000&-0.1875\\
 0.000&-0.1193\end{bmatrix}\times\begin{bmatrix}0.8077\\
 -0.6678\end{bmatrix}+\begin{bmatrix}0.6875\\
 -0.7443\end{bmatrix}=\begin{bmatrix}0.8127\\
 -0.6646\end{bmatrix}.           x   (  5  )    =     [     0.000     -  0.1875       0.000     -  0.1193      ]   Ã—   [     0.8127       -  0.6646      ]    +   [     0.6875       -  0.7443      ]    =   [     0.8121       -  0.6650      ]    .         superscript  x  5         0.000    0.1875     0.000    0.1193       0.8127      0.6646        0.6875      0.7443             0.8121      0.6650        x^{(5)}=\begin{bmatrix}0.000&-0.1875\\
 0.000&-0.1193\end{bmatrix}\times\begin{bmatrix}0.8127\\
 -0.6646\end{bmatrix}+\begin{bmatrix}0.6875\\
 -0.7443\end{bmatrix}=\begin{bmatrix}0.8121\\
 -0.6650\end{bmatrix}.           x   (  6  )    =     [     0.000     -  0.1875       0.000     -  0.1193      ]   Ã—   [     0.8121       -  0.6650      ]    +   [     0.6875       -  0.7443      ]    =   [     0.8122       -  0.6650      ]    .         superscript  x  6         0.000    0.1875     0.000    0.1193       0.8121      0.6650        0.6875      0.7443             0.8122      0.6650        x^{(6)}=\begin{bmatrix}0.000&-0.1875\\
 0.000&-0.1193\end{bmatrix}\times\begin{bmatrix}0.8121\\
 -0.6650\end{bmatrix}+\begin{bmatrix}0.6875\\
 -0.7443\end{bmatrix}=\begin{bmatrix}0.8122\\
 -0.6650\end{bmatrix}.           x   (  7  )    =     [     0.000     -  0.1875       0.000     -  0.1193      ]   Ã—   [     0.8122       -  0.6650      ]    +   [     0.6875       -  0.7443      ]    =   [     0.8122       -  0.6650      ]    .         superscript  x  7         0.000    0.1875     0.000    0.1193       0.8122      0.6650        0.6875      0.7443             0.8122      0.6650        x^{(7)}=\begin{bmatrix}0.000&-0.1875\\
 0.000&-0.1193\end{bmatrix}\times\begin{bmatrix}0.8122\\
 -0.6650\end{bmatrix}+\begin{bmatrix}0.6875\\
 -0.7443\end{bmatrix}=\begin{bmatrix}0.8122\\
 -0.6650\end{bmatrix}.          ğ±  =    A   -  1    ğ›   =   [     0.8122       -  0.6650      ]    .        ğ±     superscript  A    1    ğ›          0.8122      0.6650        \mathbf{x}=A^{-1}\mathbf{b}=\begin{bmatrix}0.8122\\
 -0.6650\end{bmatrix}.     As expected, the algorithm converges to the exact solution:       A  ğ±   =  ğ›        A  ğ±   ğ›    A\mathbf{x}=\mathbf{b}     In fact, the matrix A is strictly diagonally dominant (but not positive definite).  Another example for the matrix version  Another linear system shown as    A  =   [     2    3      5    7     ]       A    2  3    5  7      A=\begin{bmatrix}2&3\\
 5&7\\
 \end{bmatrix}   is given by:       b  =   [     11      13     ]    .      b    11    13      b=\begin{bmatrix}11\\
 13\\
 \end{bmatrix}.   and     ğ±   (   k  +  1   )    =    L  *   -  1     (   ğ›  -   U   ğ±   (  k  )      )         superscript  ğ±    k  1       superscript   subscript  L      1      ğ›    U   superscript  ğ±  k        \mathbf{x}^{(k+1)}=L_{*}^{-1}(\mathbf{b}-U\mathbf{x}^{(k)})     We want to use the equation       ğ±   (   k  +  1   )    =    T   ğ±   (  k  )     +  C        superscript  ğ±    k  1        T   superscript  ğ±  k    C     \mathbf{x}^{(k+1)}=T\mathbf{x}^{(k)}+C     in the form      T  =   -    L  *   -  1    U        T       superscript   subscript  L      1    U      T=-L_{*}^{-1}U     where:       C  =    L  *   -  1    ğ›    .      C     superscript   subscript  L      1    ğ›     C=L_{*}^{-1}\mathbf{b}.   and   A   A   A     We must decompose    L  *     subscript  L     L_{*}   into the sum of a lower triangular component   U   U   U   and a strict upper triangular component     L  *   =   [     2    0      5    7     ]        subscript  L      2  0    5  7      L_{*}=\begin{bmatrix}2&0\\
 5&7\\
 \end{bmatrix}   :       U  =   [     0    3      0    0     ]    .      U    0  3    0  0      U=\begin{bmatrix}0&3\\
 0&0\\
 \end{bmatrix}.   and    L  *     subscript  L     L_{*}     The inverse of     L  *   -  1    =    [     2    0      5    7     ]    -  1    =   [     0.500    0.000       -  0.357     0.143     ]          superscript   subscript  L      1     superscript    2  0    5  7      1           0.500  0.000      0.357   0.143       L_{*}^{-1}=\begin{bmatrix}2&0\\
 5&7\\
 \end{bmatrix}^{-1}=\begin{bmatrix}0.500&0.000\\
 -0.357&0.143\\
 \end{bmatrix}   is:       T  =   -    [     0.500    0.000       -  0.357     0.143     ]   Ã—   [     0    3      0    0     ]     =   [     0.000     -  1.500       0.000    1.071     ]    ,        T        0.500  0.000      0.357   0.143      0  3    0  0             0.000    1.500     0.000  1.071       T=-\begin{bmatrix}0.500&0.000\\
 -0.357&0.143\\
 \end{bmatrix}\times\begin{bmatrix}0&3\\
 0&0\\
 \end{bmatrix}=\begin{bmatrix}0.000&-1.500\\
 0.000&1.071\\
 \end{bmatrix},   .  Now we can find:       C  =    [     0.500    0.000       -  0.357     0.143     ]   Ã—   [     11      13     ]    =   [     5.500       -  2.071      ]    .        C      0.500  0.000      0.357   0.143      11    13            5.500      2.071        C=\begin{bmatrix}0.500&0.000\\
 -0.357&0.143\\
 \end{bmatrix}\times\begin{bmatrix}11\\
 13\\
 \end{bmatrix}=\begin{bmatrix}5.500\\
 -2.071\\
 \end{bmatrix}.        T   T   T     Now we have   C   C   C   and   ğ±   ğ±   \mathbf{x}   and we can use them to obtain the vectors    ğ±   (  0  )      superscript  ğ±  0    \mathbf{x}^{(0)}   iteratively.  First of all, we have to choose      x   (  0  )    =   [     1.1      2.3     ]    .       superscript  x  0     1.1    2.3      x^{(0)}=\begin{bmatrix}1.1\\
 2.3\\
 \end{bmatrix}.   : we can only guess. The better the guess, the quicker will perform the algorithm.  We suppose:        x   (  1  )    =     [     0     -  1.500       0    1.071     ]   Ã—   [     1.1      2.3     ]    +   [     5.500       -  2.071      ]    =   [     2.050      0.393     ]    .         superscript  x  1         0    1.500     0  1.071      1.1    2.3       5.500      2.071             2.050    0.393       x^{(1)}=\begin{bmatrix}0&-1.500\\
 0&1.071\\
 \end{bmatrix}\times\begin{bmatrix}1.1\\
 2.3\\
 \end{bmatrix}+\begin{bmatrix}5.500\\
 -2.071\\
 \end{bmatrix}=\begin{bmatrix}2.050\\
 0.393\\
 \end{bmatrix}.     We can then calculate:        x   (  2  )    =     [     0     -  1.500       0    1.071     ]   Ã—   [     2.050      0.393     ]    +   [     5.500       -  2.071      ]    =   [     4.911       -  1.651      ]    .         superscript  x  2         0    1.500     0  1.071      2.050    0.393       5.500      2.071             4.911      1.651        x^{(2)}=\begin{bmatrix}0&-1.500\\
 0&1.071\\
 \end{bmatrix}\times\begin{bmatrix}2.050\\
 0.393\\
 \end{bmatrix}+\begin{bmatrix}5.500\\
 -2.071\\
 \end{bmatrix}=\begin{bmatrix}4.911\\
 -1.651\\
 \end{bmatrix}.           x   (  3  )    =  â‹¯   .       superscript  x  3   normal-â‹¯    x^{(3)}=\cdots.\,         ğ±  =    A   -  1    ğ›   =   [      -  38       29     ]         ğ±     superscript  A    1    ğ›            38     29       \mathbf{x}=A^{-1}\mathbf{b}=\begin{bmatrix}-38\\
 29\end{bmatrix}     If we test for convergence we'll find that the algorithm diverges. In fact, the matrix A is neither diagonally dominant nor positive definite. Then, convergence to the exact solution        x   n  +  1    ,   x   n  +  2    ,  â€¦  ,   x  n    .      subscript  x    n  1     subscript  x    n  2    normal-â€¦   subscript  x  n     x_{n+1},x_{n+2},\dots,x_{n}.     is not guaranteed and, in this case, will not occur.  An example for the equation version  Suppose given k equations where x n are vectors of these equations and starting point x 0 . From the first equation solve for x 1 in terms of      10   x  1    -   x  2    +   2   x  3            10   subscript  x  1     subscript  x  2      2   subscript  x  3      \displaystyle 10x_{1}-x_{2}+2x_{3}   For the next equations substitute the previous values of x s.  To make it clear let's consider an example.      x  1     subscript  x  1    x_{1}     Solving for    x  2     subscript  x  2    x_{2}   ,    x  3     subscript  x  3    x_{3}   ,    x  4     subscript  x  4    x_{4}   and    x  1     subscript  x  1    \displaystyle x_{1}   gives:      x  1     subscript  x  1    \displaystyle x_{1}     Suppose we choose (0,Â 0,Â 0,Â 0) as the initial approximation, then the first approximate solution is given by      x  1     subscript  x  1    x_{1}     Using the approximations obtained, the iterative procedure is repeated until the desired accuracy has been reached. The following are the approximated solutions after four iterations.          x  2     subscript  x  2    x_{2}          x  3     subscript  x  3    x_{3}          x  4     subscript  x  4    x_{4}         0.6   0.6   0.6             2.32727   2.32727   2.32727          -  0.987273      0.987273    -0.987273         0.878864   0.878864   0.878864         1.03018   1.03018   1.03018           2.03694   2.03694   2.03694          -  1.01446      1.01446    -1.01446         0.984341   0.984341   0.984341         1.00659   1.00659   1.00659           2.00356   2.00356   2.00356          -  1.00253      1.00253    -1.00253         0.998351   0.998351   0.998351         1.00086   1.00086   1.00086           2.0003   2.0003   2.0003          -  1.00031      1.00031    -1.00031         0.99985   0.99985   0.99985      $0.99985$     The exact solution of the system is (1,Â 2,Â âˆ’1,Â 1).  An example using Python 3 and NumPy  The following numerical procedure simply iterates to produce the solution vector.  import numpy as np
 
 ITERATION_LIMIT =  1000  # initialize the matrix A = np.array([[ 10 ., - 1 ., 2 ., 0 .],
               [ - 1 ., 11 ., - 1 ., 3 .],
               [ 2 ., - 1 ., 10 ., - 1 .],
               [ 0.0 , 3 ., - 1 ., 8 .]]) # initialize the RHS vector b = np.array([ 6 ., 25 ., - 11 ., 15 .]) # prints the system  print ( "System:" ) for i in  range (A.shape[ 0 ]):
     row = [ "{}*x{}" . format (A[i, j], j +  1 ) for j in  range (A.shape[ 1 ])] print ( " + " .join(row), "=" , b[i]) print ()
 
 x = np.zeros_like(b) for it_count in  range (ITERATION_LIMIT): print ( "Current solution:" , x)
     x_new = np.zeros_like(x) for i in  range (A.shape[ 0 ]):
         s1 = np.dot(A[i, :i], x_new[:i])
         s2 = np.dot(A[i, i +  1 :], x[i +  1 :])
         x_new[i] = (b[i] - s1 - s2) / A[i, i] if np.allclose(x, x_new, rtol = 1e-8 ): break x = x_new print ( "Solution:" ) print (x)
 error = np.dot(A, x) - b print ( "Error:" ) print (error)  Produces the output:  System: 10.0 * x1 +  - 1.0 * x2 +  2.0 * x3 +  0.0 * x4 =  6.0  - 1.0 * x1 +  11.0 * x2 +  - 1.0 * x3 +  3.0 * x4 =  25.0  2.0 * x1 +  - 1.0 * x2 +  10.0 * x3 +  - 1.0 * x4 =  - 11.0  0.0 * x1 +  3.0 * x2 +  - 1.0 * x3 +  8.0 * x4 =  15.0 Current solution: [ 0 . 0 . 0 . 0 .]
 Current solution: [ 0.6  2.32727273  - 0.98727273  0.87886364 ]
 Current solution: [ 1.03018182  2.03693802  - 1.0144562  0.98434122 ]
 Current solution: [ 1.00658504  2.00355502  - 1.00252738  0.99835095 ]
 Current solution: [ 1.00086098  2.00029825  - 1.00030728  0.99984975 ]
 Current solution: [ 1.00009128  2.00002134  - 1.00003115  0.9999881 ]
 Current solution: [ 1.00000836  2.00000117  - 1.00000275  0.99999922 ]
 Current solution: [ 1.00000067  2.00000002  - 1.00000021  0.99999996 ]
 Current solution: [ 1.00000004  1.99999999  - 1.00000001  1 .        ]
 Current solution: [ 1 . 2 . - 1 . 1 .]
 Solution:
 [ 1 . 2 . - 1 . 1 .]
 Error:
 [ 2.06480930e-08  - 1.25551054e-08  3.61417563e-11  0.00000000e+00 ]  Program to solve arbitrary no. of equations using Matlab  The following code uses the formula $x^{(k+1)}_i  = \frac{1}{a_{ii}} \left(b_i - \sum_{j i}a_{ij}x^{(k)}_j \right),\quad i,j=1,2,\ldots,n $  function [x] = gauss_seidel(A, b, x0, iters)
     n = length(A);
     x = x0;
     for k = 1 :iters
         for i = 1 :n
             x(i) = ( 1 /A(i, i))*(b(i) - A(i, 1 :n)*x + A(i, i)*x(i));
         end
     end
 end  See also   Jacobi method  Successive over-relaxation  Iterative method. Linear systems  Gaussian belief propagation  Matrix splitting  Richardson iteration   Notes  References    .   .    External links    Gaussâ€“Seidel from www.math-linux.com  Module for Gaussâ€“Seidel Iteration  Gaussâ€“Seidel From Holistic Numerical Methods Institute  [ http://www.webcitation.org/query?url=http://www.geocities.com/rsrirang2001/Mathematics/NumericalMethods/gsiedel/gsiedel.htm&date; ;=2009-10-26+01:52:27 Gauss Siedel Iteration from www.geocities.com]  The Gauss-Seidel Method  Bickson  Matlab code  C code example   "  Category:Numerical linear algebra  Category:Articles with example pseudocode  Category:Relaxation (iterative methods)  Category:Articles with example Python code  Category:Articles with example MATLAB/Octave code     ; [ http://gdz.sub.uni-goettingen.de/en/dms/loader/img/?PPN=PPN23601515X&DMDID; ;=DMDLOG_0112&LOGID;=LOG_0112&PHYSID;=PHYS_0286 direct link]. â†©  . â†©  . â†©  . â†©    