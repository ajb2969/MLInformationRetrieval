<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1506">Elliptic curve primality</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Elliptic curve primality</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> <strong><a href="elliptic_curve" title="wikilink">elliptic curve</a> primality testing</strong> techniques are among the quickest and most widely used methods in primality proving.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is an idea forwarded by <a href="Shafi_Goldwasser" title="wikilink">Shafi Goldwasser</a> and <a href="Joe_Kilian" title="wikilink">Joe Kilian</a> in 1986 and turned into an algorithm by <a href="A._O._L._Atkin" title="wikilink">A. O. L. Atkin</a> the same year. The algorithm was altered and improved by several collaborators subsequently, and notably by Atkin and , in 1993.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The concept of using <a href="Lenstra_elliptic_curve_factorization" title="wikilink">elliptic curves in factorization</a> had been developed by <a href="H._W._Lenstra" title="wikilink">H. W. Lenstra</a> in 1985, and the implications for its use in primality testing (and proving) followed quickly.</p>

<p><a href="Primality_testing" title="wikilink">Primality testing</a> is a field that has been around since the time of <a class="uri" href="Fermat" title="wikilink">Fermat</a>, in whose time most algorithms were based on factoring, which become unwieldy with large input; modern algorithms treat the problems of determining whether a number is prime and what its factors are separately. It became of practical importance with the advent of modern cryptography. Although many current tests result in a probabilistic output (<em>N</em> is either shown composite, or probably prime, such as with the <a href="Baillie–PSW_primality_test" title="wikilink">Baillie–PSW primality test</a> or the <a href="Miller–Rabin_test" title="wikilink">Miller–Rabin test</a>), the elliptic curve test proves primality (or compositeness) with a quickly verifiable certificate.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Elliptic curve primality proving provides an alternative to (among others) the <a href="Pocklington_primality_test" title="wikilink">Pocklington primality test</a>, which can be difficult to implement in practice. The elliptic curve primality tests are based on criteria analogous to the Pocklington criterion, on which that test is based,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> where the group 

<math display="inline" id="Elliptic_curve_primality:0">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbb{Z}/n\mathbb{Z})^{*}
  </annotation>
 </semantics>
</math>

 is replaced by 

<math display="inline" id="Elliptic_curve_primality:1">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
     <mi>ℤ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{Z}/n\mathbb{Z})
  </annotation>
 </semantics>
</math>

, and <em>E</em> is a properly chosen elliptic curve. We will now state a proposition on which to base our test, which is analogous to the Pocklington criterion, and gives rise to the Goldwasser–Kilian–Atkin form of the elliptic curve primality test.</p>
<h2 id="elliptic-curve-primality-proving">Elliptic curve primality proving</h2>

<p>It is a general-purpose <a class="uri" href="algorithm" title="wikilink">algorithm</a>, meaning it does not depend on the number being of a special form. ECPP is currently in practice the fastest known algorithm for testing the primality of general numbers, but the <a href="worst-case_execution_time" title="wikilink">worst-case execution time</a> is not known. ECPP <a href="Heuristic_argument" title="wikilink">heuristically</a> runs in time:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>

<math display="block" id="Elliptic_curve_primality:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mn>5</mn>
      <mo>+</mo>
      <mi>ε</mi>
     </mrow>
    </msup>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">5</cn>
      <ci>ε</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O((\log n)^{5+\varepsilon})\,
  </annotation>
 </semantics>
</math>

</p>

<p>for some 

<math display="inline" id="Elliptic_curve_primality:3">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ε</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon>0
  </annotation>
 </semantics>
</math>

. This exponent may be decreased to 

<math display="inline" id="Elliptic_curve_primality:4">
 <semantics>
  <mrow>
   <mn>4</mn>
   <mo>+</mo>
   <mi>ε</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">4</cn>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4+\varepsilon
  </annotation>
 </semantics>
</math>

 for some versions by heuristic arguments. ECPP works the same way as most other <a href="primality_test" title="wikilink">primality tests</a> do, finding a <a href="group_(mathematics)" title="wikilink">group</a> and showing its size is such that 

<math display="inline" id="Elliptic_curve_primality:5">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is prime. For ECPP the group is an elliptic curve over a finite set of quadratic forms such that 

<math display="inline" id="Elliptic_curve_primality:6">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p-1
  </annotation>
 </semantics>
</math>

 is trivial to factor over the group.</p>

<p>ECPP generates an <a href="A._O._L._Atkin" title="wikilink">Atkin</a>–<a href="Shafi_Goldwasser" title="wikilink">Goldwasser</a>–Kilian–Morain <a href="primality_certificate" title="wikilink">certificate</a> of primality by <a href="recursion_(computer_science)" title="wikilink">recursion</a> and then attempts to verify the certificate. The step that takes the most <a class="uri" href="CPU" title="wikilink">CPU</a> time is the certificate generation, because factoring over a <a href="class_field" title="wikilink">class field</a> must be performed. The certificate can be verified quickly, allowing a check of operation to take very little time.</p>

<p>As of December 2014 the largest prime <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> that has been proved with ECPP method is the 29,271-digits prime value of the <a href="Lucas_sequence" title="wikilink">Lucas sequence</a>:</p>

<p>

<math display="block" id="Elliptic_curve_primality:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mi>u</mi>
    <mi>c</mi>
    <mi>a</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>140057</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>u</ci>
    <ci>c</ci>
    <ci>a</ci>
    <ci>s</ci>
    <cn type="integer">140057</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Lucas(140057).
  </annotation>
 </semantics>
</math>

 The proof certification with Marcel Martin's multi-processor Primo software by Peter Kaiser and Paul Underwood started in January 2014 and ended in December 2014. The certification took 6 months on a 16 core Xeon computer at 3 GHz plus a further 6 months on a 32 core AMD computer at 2.2 GHz.</p>
<h2 id="proposition">Proposition</h2>

<p>Let <em>N</em> be a positive integer, and <em>E</em> be the set which is defined by the equation 

<math display="inline" id="Elliptic_curve_primality:8">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mi>b</mi>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{2}=x^{3}+ax+b\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

. Consider <em>E</em> over 

<math display="inline" id="Elliptic_curve_primality:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>N</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/N\mathbb{Z}
  </annotation>
 </semantics>
</math>

, use the usual addition law on <em>E</em>, and write 0 for the neutral element on <em>E</em>.</p>

<p>Let <em>m</em> be an integer. If there is a prime <em>q</em> which divides <em>m</em>, and is greater than 

<math display="inline" id="Elliptic_curve_primality:10">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>N</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>4</mn>
      </mrow>
     </msup>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">4</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (N^{1/4}+1)^{2}
  </annotation>
 </semantics>
</math>

 and there exists a point <em>P</em> on <em>E</em> such that</p>

<p>(1) <em>mP</em> = 0</p>

<p>(2) (<em>m</em>/<em>q</em>)<em>P</em> is defined and not equal to 0</p>

<p>Then <em>N</em> is prime.</p>
<h3 id="proof">Proof</h3>

<p>If <em>N</em> is composite, then there exists a prime 

<math display="inline" id="Elliptic_curve_primality:11">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≤</mo>
   <msqrt>
    <mi>N</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>p</ci>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\leq\sqrt{N}
  </annotation>
 </semantics>
</math>

 that divides <em>N</em>. Define 

<math display="inline" id="Elliptic_curve_primality:12">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{p}
  </annotation>
 </semantics>
</math>

 as the elliptic curve defined by the same equation as <em>E</em> but evaluated modulo <em>p</em> rather than modulo <em>N</em>. Define 

<math display="inline" id="Elliptic_curve_primality:13">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{p}
  </annotation>
 </semantics>
</math>

 as the order of the group 

<math display="inline" id="Elliptic_curve_primality:14">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{p}
  </annotation>
 </semantics>
</math>

. By <a href="Hasse's_theorem_on_elliptic_curves" title="wikilink">Hasse's theorem on elliptic curves</a> we know</p>

<p>

<math display="block" id="Elliptic_curve_primality:15">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>p</mi>
   </msub>
   <mo>≤</mo>
   <mrow>
    <mi>p</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mi>p</mi>
     </msqrt>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msqrt>
       <mi>p</mi>
      </msqrt>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>≤</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>N</mi>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>4</mn>
       </mrow>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo><</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>p</ci>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <root></root>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <root></root>
        <ci>p</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>N</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">4</cn>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{p}\leq p+1+2\sqrt{p}=(\sqrt{p}+1)^{2}\leq(N^{1/4}+1)^{2}<q
  </annotation>
 </semantics>
</math>

</p>

<p>and thus 

<math display="inline" id="Elliptic_curve_primality:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo>,</mo>
     <msub>
      <mi>m</mi>
      <mi>p</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <gcd></gcd>
     <ci>q</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gcd{(q,m_{p})}=1
  </annotation>
 </semantics>
</math>

 and there exists an integer <em>u</em> with the property that</p>

<p>

<math display="block" id="Elliptic_curve_primality:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mi>q</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msub>
       <mi>m</mi>
       <mi>p</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   uq\equiv 1\;\;(\mathop{{\rm mod}}m_{p})
  </annotation>
 </semantics>
</math>

</p>

<p>Let 

<math display="inline" id="Elliptic_curve_primality:18">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{p}
  </annotation>
 </semantics>
</math>

 be the point <em>P</em> evaluated <em>modulo p</em>. Thus, on 

<math display="inline" id="Elliptic_curve_primality:19">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{p}
  </annotation>
 </semantics>
</math>

 we have</p>

<p>

<math display="block" id="Elliptic_curve_primality:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>/</mo>
      <mi>q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>P</mi>
     <mi>p</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>u</mi>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>/</mo>
      <mi>q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>P</mi>
     <mi>p</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>u</mi>
    <mi>m</mi>
    <msub>
     <mi>P</mi>
     <mi>p</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>m</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>q</ci>
      <apply>
       <divide></divide>
       <ci>m</ci>
       <ci>q</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>m</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m/q)P_{p}=uq(m/q)P_{p}=umP_{p}=0\,
  </annotation>
 </semantics>
</math>

</p>

<p>by (1), as 

<math display="inline" id="Elliptic_curve_primality:21">
 <semantics>
  <mrow>
   <mi>m</mi>
   <msub>
    <mi>P</mi>
    <mi>p</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   mP_{p}
  </annotation>
 </semantics>
</math>

 is calculated using the same method as <em>mP</em>, except modulo <em>p</em> rather than modulo <em>N</em> (and 

<math display="inline" id="Elliptic_curve_primality:22">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∣</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">N</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mid N
  </annotation>
 </semantics>
</math>

).</p>

<p>This contradicts (2), because if (<em>m</em>/<em>q</em>)<em>P</em> is defined and not equal to 0 (mod <em>N</em>), then the same method calculated modulo <em>p</em> instead of modulo <em>N</em> will yield</p>

<p>

<math display="inline" id="Elliptic_curve_primality:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>/</mo>
      <mi>q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>P</mi>
     <mi>p</mi>
    </msub>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>m</ci>
      <ci>q</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m/q)P_{p}\neq 0
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="goldwasserkilian-algorithm">Goldwasser–Kilian algorithm</h2>

<p>From this proposition an algorithm can be constructed to prove an integer, <em>N</em>, is prime. This is done as follows:</p>

<p>Choose three integers at random, <em>a, x, y</em> and set</p>

<p>

<math display="block" id="Elliptic_curve_primality:24">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>y</mi>
      <mn>2</mn>
     </msup>
     <mo>-</mo>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
     <mo>-</mo>
     <mrow>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>b</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\equiv y^{2}-x^{3}-ax\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

</p>

<p>Now <em>P</em> = (<em>x</em>,<em>y</em>) is a point on <em>E</em>, where we have that <em>E</em> is defined by 

<math display="inline" id="Elliptic_curve_primality:25">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{2}=x^{3}+ax+b
  </annotation>
 </semantics>
</math>

. Next we need an algorithm to count the number of points on <em>E</em>. Applied to <em>E</em>, this algorithm (Koblitz and others suggest <a href="Schoof's_algorithm" title="wikilink">Schoof's algorithm</a>) produces a number <em>m</em> which is the number of points on curve <em>E</em> over <strong>F<sub><em>N</em></sub></strong>, provided <em>N</em> is prime. Next we have a criterion for deciding whether our curve <em>E</em> is acceptable.</p>

<p>If we can write <em>m</em> in the form 

<math display="inline" id="Elliptic_curve_primality:26">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=kq
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Elliptic_curve_primality:27">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\geq 2
  </annotation>
 </semantics>
</math>

 is a small integer and <em>q</em> a probable prime (it has passed some previous probabilistic <a href="primality_test" title="wikilink">primality test</a>, for example), then we do not discard <em>E</em>. If it is not possible to write <em>m</em> in this form, we discard our curve and randomly select another triple <em>(a, x, y)</em> to start over.</p>

<p>Assuming we find a curve which passes the criterion, proceed to calculate <em>mP</em> and <em>kP</em>. If at any stage in the calculation we encounter an undefined expression (from calculating the multiples of <em>P</em> or in our point counting algorithm), it gives us a non-trivial factor of <em>N</em>.</p>

<p>If 

<math display="inline" id="Elliptic_curve_primality:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mi>P</mi>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>P</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   mP\neq 0
  </annotation>
 </semantics>
</math>

 it is clear that <em>N</em> is not prime, because if <em>N</em> were prime then <em>E</em> would have order <em>m</em>, and any element of <em>E</em> would become 0 on multiplication by <em>m</em>. If <em>kP</em> = 0 then we have hit a dead-end and must start again with a different triple.</p>

<p>Now if 

<math display="inline" id="Elliptic_curve_primality:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>P</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   mP=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_curve_primality:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mi>P</mi>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>P</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   kP\neq 0
  </annotation>
 </semantics>
</math>

 then our previous proposition tells us that <em>N</em> is prime. However there is one possible problem, which is the primality of <em>q</em>. This must be verified, using the same algorithm. So we have described a down-run procedure, where the primality of <em>N</em> can be proven through the primality of <em>q</em> and indeed smaller 'probable primes' until we have reached certain primes and are finished.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="problems-with-the-algorithm">Problems with the algorithm</h2>

<p>Atkin and Morain state "the problem with GK is that Schoof's algorithm seems almost impossible to implement.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> It is very slow and cumbersome to count all of the points on <em>E</em> using Schoof's algorithm, which is the preferred algorithm for the Goldwasser–Kilian algorithm. However, the original algorithm by Schoof is not efficient enough to provide the number of points in short time.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> These comments have to be seen in the historical context, before the improvements by Elkies and Atkin to Schoof's method.</p>

<p>A second problem Koblitz notes is the difficulty of finding the curve <em>E</em> whose number of points is of the form <em>kq</em>, as above. There is no known theorem which guarantees we can find a suitable <em>E</em> in polynomially many attempts. The distribution of primes on the Hasse interval 

<math display="inline" id="Elliptic_curve_primality:31">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mi>p</mi>
     </msqrt>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>p</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mi>p</mi>
     </msqrt>
    </mrow>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>p</ci>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [p+1-2\sqrt{p},p+1+2\sqrt{p}]
  </annotation>
 </semantics>
</math>

, which contains <em>m</em>, is not the same as the distribution of primes in the group orders, counting curves with multiplity. However, this is not a significant problem in practice.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="atkinmorain-elliptic-curve-primality-test-ecpp">Atkin–Morain elliptic curve primality test (ECPP)</h2>

<p>In a 1993 paper, Atkin and Morain described an algorithm ECPP which avoided the trouble of relying on a cumbersome point counting algorithm (Schoof's). The algorithm still relies on the proposition stated above, but rather than randomly generating elliptic curves and searching for a proper <em>m</em>, their idea was to construct a curve <em>E</em> where the number of points is easy to compute. <a href="Complex_multiplication" title="wikilink">Complex multiplication</a> is key in the construction of the curve.</p>

<p>Now, given an <em>N</em> for which primality needs to be proven we need to find a suitable <em>m</em> and <em>q</em>, just as in the Goldwasser–Kilian test, that will fulfill the proposition and prove the primality of <em>N</em>. (Of course, a point <em>P</em> and the curve itself, <em>E</em>, must also be found.)</p>

<p>ECPP uses complex multiplication to construct the curve <em>E</em>, doing so in a way that allows for <em>m</em> (the number of points on <em>E</em>) to be easily computed. We will now describe this method:</p>

<p>Utilization of complex multiplication requires a negative <a class="uri" href="discriminant" title="wikilink">discriminant</a>, <em>D</em>, such that <em>D</em> can be written as the product of two elements 

<math display="inline" id="Elliptic_curve_primality:32">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mi>π</mi>
    <mover accent="true">
     <mi>π</mi>
     <mo stretchy="false">¯</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <times></times>
     <ci>π</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>π</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\pi\bar{\pi}
  </annotation>
 </semantics>
</math>

, or completely equivalently, we can write the equation:</p>

<p>

<math display="block" id="Elliptic_curve_primality:33">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>a</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>D</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <msup>
      <mi>b</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>4</mn>
    <mpadded width="+1.7pt">
     <mi>N</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <abs></abs>
       <ci>D</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{2}+|D|b^{2}=4N\,
  </annotation>
 </semantics>
</math>

</p>

<p>For some <em>a, b</em>. If we can describe <em>N</em> in terms of either of these forms, we can create an elliptic curve <em>E</em> on 

<math display="inline" id="Elliptic_curve_primality:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>N</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/N\mathbb{Z}
  </annotation>
 </semantics>
</math>

 with complex multiplication (described in detail below), and the number of points is given by:</p>

<p>

<math display="block" id="Elliptic_curve_primality:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>ℤ</mi>
         <mo>/</mo>
         <mi>N</mi>
        </mrow>
        <mi>ℤ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>N</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>-</mo>
     <mi>π</mi>
     <mo>-</mo>
     <mover accent="true">
      <mi>π</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>N</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>-</mo>
     <mi>a</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <ci>ℤ</ci>
         <ci>N</ci>
        </apply>
        <ci>ℤ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>π</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>π</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E(\mathbb{Z}/N\mathbb{Z})|=N+1-\pi-\bar{\pi}=N+1-a.\,
  </annotation>
 </semantics>
</math>

</p>

<p>For <em>N</em> to split into two the two elements, we need that 

<math display="inline" id="Elliptic_curve_primality:36">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mi>D</mi>
     <mi>N</mi>
    </mfrac>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>D</ci>
     <ci>N</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\frac{D}{N}\right)=1
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Elliptic_curve_primality:37">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mfrac>
    <mi>D</mi>
    <mi>N</mi>
   </mfrac>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>D</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\frac{D}{N}\right)
  </annotation>
 </semantics>
</math>

 denotes the <a href="Legendre_symbol" title="wikilink">Legendre symbol</a>). This is a necessary condition, and we achieve sufficiency if the <a href="Ideal_class_group" title="wikilink">class number</a> <em>h</em>(<em>D</em>) of the order in 

<math display="inline" id="Elliptic_curve_primality:38">
 <semantics>
  <mrow>
   <mi>ℚ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mi>D</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℚ</ci>
    <apply>
     <root></root>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}(\sqrt{D})
  </annotation>
 </semantics>
</math>

 is 1. This happens for only 13 values of <em>D</em>, which are the elements of {−3, −4, −7, −8, −11, −12, −16, −19, −27, −28, −43, −67, −163}</p>
<h2 id="the-test">The test</h2>

<p>Pick discriminants <em>D</em> in sequence of increasing <em>h</em>(<em>D</em>). For each <em>D</em> check if 

<math display="inline" id="Elliptic_curve_primality:39">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mi>D</mi>
     <mi>N</mi>
    </mfrac>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>D</ci>
     <ci>N</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\frac{D}{N}\right)=1
  </annotation>
 </semantics>
</math>

 and whether 4<em>N</em> can be written as:</p>

<p>

<math display="block" id="Elliptic_curve_primality:40">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>a</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>D</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <msup>
      <mi>b</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>4</mn>
    <mpadded width="+1.7pt">
     <mi>N</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <abs></abs>
       <ci>D</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{2}+|D|b^{2}=4N\,
  </annotation>
 </semantics>
</math>

</p>

<p>This part can be verified using <a href="Cornacchia's_algorithm" title="wikilink">Cornacchia's algorithm</a>. Once acceptable <em>D</em> and <em>a</em> have been discovered, calculate 

<math display="inline" id="Elliptic_curve_primality:41">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>-</mo>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=N+1-a
  </annotation>
 </semantics>
</math>

. Now if <em>m</em> has a prime factor <em>q</em> of size</p>

<p>

<math display="block" id="Elliptic_curve_primality:42">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>></mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>N</mi>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>4</mn>
       </mrow>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>q</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">4</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q>(N^{1/4}+1)^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>use the complex multiplication method to construct the curve <em>E</em> and a point <em>P</em> on it. Then we can use our proposition to verify the primality of <em>N</em>. Note that if <em>m</em> does not have a large prime factor or cannot be factored quickly enough, another choice of <em>D</em> can be made.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="complex-multiplication-method">Complex multiplication method</h2>

<p>For completeness, we will provide an overview of <a href="complex_multiplication" title="wikilink">complex multiplication</a>, the way in which an elliptic curve can be created, given our <em>D</em> (which can be written as a product of two elements).</p>

<p>Assume first that 

<math display="inline" id="Elliptic_curve_primality:43">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>≠</mo>
   <mrow>
    <mo>-</mo>
    <mn>3</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>D</ci>
    <apply>
     <minus></minus>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\neq-3
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_curve_primality:44">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>≠</mo>
   <mrow>
    <mo>-</mo>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>D</ci>
    <apply>
     <minus></minus>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\neq-4
  </annotation>
 </semantics>
</math>

 (these cases are much more easily done). It is necessary to calculate the elliptic <a href="j-invariant" title="wikilink">j-invariants</a> of the <em>h</em>(<em>D</em>) classes of the order of discriminant <em>D</em> as complex numbers. There are several formulas to calculate these.</p>

<p>Next create the monic polynomial 

<math display="inline" id="Elliptic_curve_primality:45">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>D</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>D</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{D}(X)
  </annotation>
 </semantics>
</math>

, which has roots corresponding to the <em>h</em>(<em>D</em>) values. Note, that 

<math display="inline" id="Elliptic_curve_primality:46">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>D</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>D</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{D}(X)
  </annotation>
 </semantics>
</math>

 is the <a href="class_polynomial" title="wikilink">class polynomial</a>. From complex multiplication theory, we know that 

<math display="inline" id="Elliptic_curve_primality:47">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>D</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>D</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{D}(X)
  </annotation>
 </semantics>
</math>

 has integer coefficients, which allows us to estimate these coefficients accurately enough to discover their true values.</p>

<p>Now, if <em>N</em> is prime, CM tells us that 

<math display="inline" id="Elliptic_curve_primality:48">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>D</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>D</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{D}(X)
  </annotation>
 </semantics>
</math>

 splits modulo <em>N</em> into a product of <em>h</em>(<em>D</em>) linear factors, based on the fact that <em>D</em> was chosen so that <em>N</em> splits as the product of two elements. Now if <em>j</em> is one of the <em>h</em>(<em>D</em>) roots <em>modulo N</em> we can define <em>E</em> as:</p>

<p>

<math display="block" id="Elliptic_curve_primality:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>y</mi>
      <mn>2</mn>
     </msup>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>x</mi>
        <mn>3</mn>
       </msup>
       <mo>-</mo>
       <mrow>
        <mn>3</mn>
        <mi>k</mi>
        <msup>
         <mi>c</mi>
         <mrow>
          <mn>2</mn>
          <mi>r</mi>
         </mrow>
        </msup>
        <mi>x</mi>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>2</mn>
       <mi>k</mi>
       <msup>
        <mi>c</mi>
        <mrow>
         <mn>3</mn>
         <mi>r</mi>
        </mrow>
       </msup>
      </mrow>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mtext>where</mtext>
      <mi>k</mi>
     </mrow>
     <mo>=</mo>
     <mfrac>
      <mi>j</mi>
      <mrow>
       <mi>j</mi>
       <mo>-</mo>
       <mn>1728</mn>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">3</cn>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>c</ci>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>r</ci>
         </apply>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>k</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>c</ci>
        <apply>
         <times></times>
         <cn type="integer">3</cn>
         <ci>r</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>where</mtext>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>j</ci>
      <apply>
       <minus></minus>
       <ci>j</ci>
       <cn type="integer">1728</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{2}=x^{3}-3kc^{2r}x+2kc^{3r},\text{ where }k=\frac{j}{j-1728},
  </annotation>
 </semantics>
</math>

</p>

<p><em>c</em> is any <a href="quadratic_nonresidue" title="wikilink">quadratic nonresidue</a> mod <em>N</em>, and <em>r</em> is either 0 or 1.</p>

<p>Given a root <em>j</em> there are only two possible nonisomorphic choices of <em>E</em>, one for each choice of <em>r</em>. We have the cardinality of these curves as</p>

<p>

<math display="block" id="Elliptic_curve_primality:50">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>ℤ</mi>
        <mo>/</mo>
        <mi>N</mi>
       </mrow>
       <mi>ℤ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>-</mo>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>ℤ</ci>
        <ci>N</ci>
       </apply>
       <ci>ℤ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E(\mathbb{Z}/N\mathbb{Z})|=N+1-a
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Elliptic_curve_primality:51">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>ℤ</mi>
        <mo>/</mo>
        <mi>N</mi>
       </mrow>
       <mi>ℤ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo>+</mo>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>ℤ</ci>
        <ci>N</ci>
       </apply>
       <ci>ℤ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>N</ci>
     <cn type="integer">1</cn>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |E(\mathbb{Z}/N\mathbb{Z})|=N+1+a
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h3 id="discussion">Discussion</h3>

<p>Just as with the Goldwasser–Killian test, this one leads to a down-run procedure. Again, the culprit is <em>q</em>. Once we find a <em>q</em> that works, we must check it to be prime, so in fact we are doing the whole test now for <em>q</em>. Then again we may have to perform the test for factors of <em>q</em>. This leads to a nested certificate where at each level we have an elliptic curve <em>E</em>, an <em>m</em> and the prime in doubt, <em>q</em>.</p>
<h2 id="example-of-atkinmorain-ecpp">Example of Atkin–Morain ECPP</h2>

<p>We construct an example to prove that 

<math display="inline" id="Elliptic_curve_primality:52">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mn>167</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <cn type="integer">167</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=167
  </annotation>
 </semantics>
</math>

 is prime using the Atkin–Morain ECPP test. First proceed through the set of 13 possible discriminants, testing whether the Legendre Symbol 

<math display="inline" id="Elliptic_curve_primality:53">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>D</mi>
     <mo>/</mo>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>D</ci>
     <ci>N</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (D/N)=1
  </annotation>
 </semantics>
</math>

, and if 4<em>N</em> can be written as 

<math display="inline" id="Elliptic_curve_primality:54">
 <semantics>
  <mrow>
   <mrow>
    <mn>4</mn>
    <mi>N</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>D</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <msup>
      <mi>b</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <ci>N</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <abs></abs>
       <ci>D</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4N=a^{2}+|D|b^{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>For our example <em>D</em> = −43 is chosen. This is because 

<math display="inline" id="Elliptic_curve_primality:55">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>D</mi>
     <mo>/</mo>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mn>43</mn>
      <mo>/</mo>
      <mn>167</mn>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>D</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">43</cn>
       <cn type="integer">167</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (D/N)=(-43/167)=1
  </annotation>
 </semantics>
</math>

 and also, using Cornacchia's algorithm, we know that 

<math display="inline" id="Elliptic_curve_primality:56">
 <semantics>
  <mrow>
   <mrow>
    <mn>4</mn>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>167</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>25</mn>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>43</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mn>1</mn>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">4</cn>
     <cn type="integer">167</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">25</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">43</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4\cdot(167)=25^{2}+(43)(1^{2})
  </annotation>
 </semantics>
</math>

 and thus <em>a</em> = 25 and <em>b</em> = 1.</p>

<p>The next step is to calculate <em>m</em>. This is easily done as 

<math display="inline" id="Elliptic_curve_primality:57">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>-</mo>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=N+1-a
  </annotation>
 </semantics>
</math>

 which yields 

<math display="inline" id="Elliptic_curve_primality:58">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>167</mn>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>-</mo>
    <mn>25</mn>
   </mrow>
   <mo>=</mo>
   <mn>143</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>m</ci>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <cn type="integer">167</cn>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">25</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">143</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=167+1-25=143
  </annotation>
 </semantics>
</math>

. Next we need to find a probable prime divisor of <em>m</em>, which was referred to as <em>q</em>. It must satisfy the condition that 

<math display="inline" id="Elliptic_curve_primality:59">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>></mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>N</mi>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>4</mn>
       </mrow>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>q</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">4</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q>(N^{1/4}+1)^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>Now in this case, <em>m</em> = 143 = 11*13. So unfortunately we cannot choose 11 or 13 as our <em>q</em>, for it does not satisfy the necessary inequality. We are saved, however, by an analogous proposition to that which we stated before the Goldwasser–Kilian algorithm, which comes from a paper by Morain.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> It states, that given our <em>m</em>, we look for an <em>s</em> which divides <em>m</em>, 

<math display="inline" id="Elliptic_curve_primality:60">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>></mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>N</mi>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>4</mn>
       </mrow>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">4</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s>(N^{1/4}+1)^{2}
  </annotation>
 </semantics>
</math>

, but is not necessarily prime, and check whether, for each 

<math display="inline" id="Elliptic_curve_primality:61">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 which divides <em>s</em></p>

<p>

<math display="block" id="Elliptic_curve_primality:62">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mo>/</mo>
     <msub>
      <mi>p</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mi>P</mi>
   </mrow>
   <mo>≠</mo>
   <msub>
    <mi>P</mi>
    <mi mathvariant="normal">∞</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>m</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m/p_{i}P\neq P_{\infty}
  </annotation>
 </semantics>
</math>

</p>

<p>for some point <em>P</em> on our yet to be constructed curve.</p>

<p>If <em>s</em> satisfies the inequality, and its prime factors satisfy the above, then <em>N</em> is prime.</p>

<p>So in our case, we choose <em>s</em> = <em>m</em> = 143. Thus our possible 

<math display="inline" id="Elliptic_curve_primality:63">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

's are 11 and 13. First, it is clear that 

<math display="inline" id="Elliptic_curve_primality:64">
 <semantics>
  <mrow>
   <mn>143</mn>
   <mo>></mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mn>167</mn>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>4</mn>
       </mrow>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <cn type="integer">143</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">167</cn>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">4</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   143>(167^{1/4}+1)^{2}
  </annotation>
 </semantics>
</math>

, and so we need only check the values of</p>

<p>

<math display="block" id="Elliptic_curve_primality:65">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>143</mn>
       <mo>/</mo>
       <mn>11</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>13</mn>
     <mi>P</mi>
     <mtext>and</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>143</mn>
       <mo>/</mo>
       <mn>13</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>11</mn>
     <mi>P</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">143</cn>
       <cn type="integer">11</cn>
      </apply>
      <ci>P</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">13</cn>
      <ci>P</ci>
      <mtext>and</mtext>
      <apply>
       <divide></divide>
       <cn type="integer">143</cn>
       <cn type="integer">13</cn>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">11</cn>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (143/11)P=13P\text{ and }(143/13)P=11P.
  </annotation>
 </semantics>
</math>

</p>

<p>But before we can do this, we must construct our curve, and choose a point <em>P</em>. In order to construct the curve, we make use of complex multiplication. In our case we compute the <a class="uri" href="J-invariant" title="wikilink">J-invariant</a></p>

<p>

<math display="block" id="Elliptic_curve_primality:66">
 <semantics>
  <mrow>
   <mrow>
    <mi>j</mi>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mo>-</mo>
      <msup>
       <mn>960</mn>
       <mn>3</mn>
      </msup>
     </mrow>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mn>167</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mn>107</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mn>167</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <ci>j</ci>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">960</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">167</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">107</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">167</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\equiv-960^{3}\;\;(\mathop{{\rm mod}}167)\equiv 107\;\;(\mathop{{\rm mod}}167%
).\,
  </annotation>
 </semantics>
</math>

</p>

<p>Next we compute 

<math display="inline" id="Elliptic_curve_primality:67">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mi>j</mi>
     <mrow>
      <mn>1728</mn>
      <mo>-</mo>
      <mi>j</mi>
     </mrow>
    </mfrac>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>167</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>158</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>167</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <apply>
       <divide></divide>
       <ci>j</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1728</cn>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">167</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">158</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">167</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=\frac{j}{1728-j}\;\;(\mathop{{\rm mod}}167)\equiv 158\;\;(\mathop{{\rm mod}}%
167)
  </annotation>
 </semantics>
</math>

 and we know our elliptic curve is of the form:</p>

<p>

<math display="block" id="Elliptic_curve_primality:68">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mn>3</mn>
     <mi>k</mi>
     <msup>
      <mi>c</mi>
      <mn>2</mn>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>k</mi>
     <msup>
      <mi>c</mi>
      <mn>3</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>k</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>k</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{2}=x^{3}+3kc^{2}x+2kc^{3}
  </annotation>
 </semantics>
</math>

,</p>

<p>where <em>k</em> is as described previously and <em>c</em> a non-square in 

<math display="inline" id="Elliptic_curve_primality:69">
 <semantics>
  <msub>
   <mi>𝔽</mi>
   <mn>167</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔽</ci>
    <cn type="integer">167</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{167}
  </annotation>
 </semantics>
</math>

. So we can begin with</p>

<p>

<math display="inline" id="Elliptic_curve_primality:70">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mn>3</mn>
     <mi>k</mi>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mn>140</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mn>167</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>r</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">140</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">167</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=0,3k\equiv 140\;\;(\mathop{{\rm mod}}167)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Elliptic_curve_primality:71">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>k</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>149</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>167</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">149</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">167</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k\equiv 149\;\;(\mathop{{\rm mod}}167)
  </annotation>
 </semantics>
</math>

 which yields</p>

<p><em>E</em>

<math display="block" id="Elliptic_curve_primality:72">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mn>140</mn>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mn>149</mn>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>167</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">140</cn>
       <ci>x</ci>
      </apply>
      <cn type="integer">149</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">167</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{2}=x^{3}+140x+149\;\;(\mathop{{\rm mod}}167)
  </annotation>
 </semantics>
</math>

</p>

<p>Now, utilizing the point <em>P</em> = (6,6) on <em>E</em> it can be verified that 143<em>P</em> = 

<math display="inline" id="Elliptic_curve_primality:73">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi mathvariant="normal">∞</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\infty}
  </annotation>
 </semantics>
</math>

.</p>

<p>It is simple to check that 13(6, 6) = (12, 65) and 11P = (140, 147), and so, by Morain's proposition, <em>N</em> is prime.</p>
<h2 id="complexity-and-running-times">Complexity and running times</h2>

<p>Goldwasser and Kilian's elliptic curve primality proving algorithm terminates in expected polynomial time for at least</p>

<p>

<math display="block" id="Elliptic_curve_primality:74">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo>(</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>N</mi>
        <mfrac>
         <mn>1</mn>
         <mrow>
          <mi>log</mi>
          <mrow>
           <mi>log</mi>
           <mi>n</mi>
          </mrow>
         </mrow>
        </mfrac>
       </mrow>
      </mrow>
     </msup>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>N</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <log></log>
          <apply>
           <log></log>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-O\left(2^{-N\frac{1}{\log\log n}}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>of prime inputs.</p>
<h3 id="conjecture">Conjecture</h3>

<p>Let 

<math display="inline" id="Elliptic_curve_primality:75">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(x)
  </annotation>
 </semantics>
</math>

 be the number of primes smaller than <em>x</em></p>

<p>

<math display="block" id="Elliptic_curve_primality:76">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∃</mo>
      <msub>
       <mi>c</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>c</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>></mo>
    <mn>0</mn>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <msqrt>
         <mi>x</mi>
        </msqrt>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>c</mi>
       <mn>2</mn>
      </msub>
      <msqrt>
       <mi>x</mi>
      </msqrt>
     </mrow>
     <mrow>
      <msup>
       <mi>log</mi>
       <msub>
        <mi>c</mi>
        <mn>1</mn>
       </msub>
      </msup>
      <mi>x</mi>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <gt></gt>
     <list>
      <apply>
       <exists></exists>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">2</cn>
      </apply>
     </list>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>π</ci>
       <apply>
        <plus></plus>
        <ci>x</ci>
        <apply>
         <root></root>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>π</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <root></root>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <log></log>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists c_{1},c_{2}>0:\pi(x+\sqrt{x})-\pi(x)\geq\frac{c_{2}\sqrt{x}}{\log^{c_{%
1}}x}
  </annotation>
 </semantics>
</math>

</p>

<p>for sufficiently large <em>x</em>.</p>

<p>If one accepts this conjecture then the Goldwasser–Kilian algorithm terminates in expected polynomial time for every input. Also, if our <em>N</em> is of length <em>k</em>, then the algorithm creates a certificate of size 

<math display="inline" id="Elliptic_curve_primality:77">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{2})
  </annotation>
 </semantics>
</math>

 that can be verified in 

<math display="inline" id="Elliptic_curve_primality:78">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mn>4</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{4})
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>Now consider another conjecture, which will give us a bound on the total time of the algorithm.</p>
<h3 id="conjecture-2">Conjecture 2</h3>

<p>Suppose there exist positive constants 

<math display="inline" id="Elliptic_curve_primality:79">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_curve_primality:80">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{2}
  </annotation>
 </semantics>
</math>

 such that the amount of primes in the interval</p>

<p>

<math display="block" id="Elliptic_curve_primality:81">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <msqrt>
       <mrow>
        <mn>2</mn>
        <mi>x</mi>
       </mrow>
      </msqrt>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>,</mo>
    <mi>x</mi>
   </mrow>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <list>
     <interval closure="closed">
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <apply>
        <root></root>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </interval>
     <ci>x</ci>
    </list>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x,x+\sqrt{2x}],x\geq 2
  </annotation>
 </semantics>
</math>

 is larger than 

<math display="inline" id="Elliptic_curve_primality:82">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <msqrt>
    <mi>x</mi>
   </msqrt>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>log</mi>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <msub>
      <mi>c</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <root></root>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <log></log>
      <ci>x</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}\sqrt{x}(\log x)^{-c_{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>Then the Goldwasser Kilian algorithm proves the primality of <em>N</em> in an expected time of</p>

<p>

<math display="block" id="Elliptic_curve_primality:83">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mrow>
       <mn>10</mn>
       <mo>+</mo>
       <msub>
        <mi>c</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </msup>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <apply>
       <plus></plus>
       <cn type="integer">10</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{10+c_{2}}n)
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>For the Atkin–Morain algorithm, the running time stated is</p>

<p>

<math display="block" id="Elliptic_curve_primality:84">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>log</mi>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mn>6</mn>
      <mo>+</mo>
      <mi>ϵ</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <log></log>
      <ci>N</ci>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">6</cn>
      <ci>ϵ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O((\log N)^{6+\epsilon})
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Elliptic_curve_primality:85">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="primes-of-special-form">Primes of special form</h2>

<p>For some forms of numbers, it is possible to find 'short-cuts' to a primality proof. This is the case for the <a href="Mersenne_numbers" title="wikilink">Mersenne numbers</a>. In fact, due to their special structure, which allows for easier verification of primality, the largest known prime number is a Mersenne number.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> There has been a method in use for some time to verify primality of Mersenne numbers, known as the <a href="Lucas–Lehmer_test" title="wikilink">Lucas–Lehmer test</a>. This test does not rely on elliptic curves. However we present a result where numbers of the form 

<math display="inline" id="Elliptic_curve_primality:86">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mi>n</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=2^{k}n-1
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Elliptic_curve_primality:87">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>k</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
    <mo>∈</mo>
    <mi>ℤ</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>k</mi>
    <mo>≥</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <ci>k</ci>
      <ci>n</ci>
     </list>
     <ci>ℤ</ci>
    </apply>
    <apply>
     <geq></geq>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k,n\in\mathbb{Z},k\geq 2
  </annotation>
 </semantics>
</math>

, n odd can be proven prime (or composite) using elliptic curves. Of course this will also provide a method for proving primality of Mersenne numbers, which correspond to the case where <em>n</em> = 1. It should be noted that there is a method in place for testing this form of number without elliptic curves (with a limitation on the size of k) known as the <a href="Lucas–Lehmer–Riesel_test" title="wikilink">Lucas–Lehmer–Riesel test</a>. The following method is drawn from the paper <em>Primality Test for 

<math display="inline" id="Elliptic_curve_primality:88">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>k</mi>
    </msup>
    <mi>n</mi>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}n-1
  </annotation>
 </semantics>
</math>

 using Elliptic Curves</em>, by Yu Tsumura.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h3 id="group-structure-of-efn">Group structure of <em>E</em>(F<sub><em>N</em></sub>)</h3>

<p>We take <em>E</em> as our elliptic curve, where <em>E</em> is of the form 

<math display="inline" id="Elliptic_curve_primality:89">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>-</mo>
    <mrow>
     <mi>m</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{2}=x^{3}-mx
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Elliptic_curve_primality:90">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>∈</mo>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>m</ci>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\in\mathbb{Z}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Elliptic_curve_primality:91">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>≢</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-equivalent-to</csymbol>
    <ci>m</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\not\equiv 0\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Elliptic_curve_primality:92">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≡</mo>
   <mrow>
    <mn>3</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>4</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>p</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">3</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\equiv 3\;\;(\mathop{{\rm mod}}4)
  </annotation>
 </semantics>
</math>

 is prime, and 

<math display="inline" id="Elliptic_curve_primality:93">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>k</mi>
     <mo>∈</mo>
     <mi>ℤ</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>k</mi>
     <mo>≥</mo>
     <mrow>
      <mn>2</mn>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>k</ci>
      <ci>ℤ</ci>
     </apply>
     <apply>
      <geq></geq>
      <ci>k</ci>
      <list>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p+1=2^{k}n,k\in\mathbb{Z},k\geq 2,n
  </annotation>
 </semantics>
</math>

 odd.</p>
<h3 id="theorem-1">Theorem 1</h3>

<p><em>#E</em>

<math display="inline" id="Elliptic_curve_primality:94">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝔽</mi>
     <mi>p</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔽</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbb{F}_{p})=p+1
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h3 id="theorem-2">Theorem 2</h3>

<p><em>E</em>

<math display="inline" id="Elliptic_curve_primality:95">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝔽</mi>
     <mi>p</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≅</mo>
   <msub>
    <mi>ℤ</mi>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mi>n</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔽</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbb{F}_{p})\cong\mathbb{Z}_{2^{k}n}
  </annotation>
 </semantics>
</math>

 or</p>

<p><em>E</em>

<math display="inline" id="Elliptic_curve_primality:96">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝔽</mi>
     <mi>p</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <msub>
     <mi>ℤ</mi>
     <mn>2</mn>
    </msub>
    <mo>⊕</mo>
    <msub>
     <mi>ℤ</mi>
     <mrow>
      <msup>
       <mn>2</mn>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>n</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔽</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbb{F}_{p})\cong\mathbb{Z}_{2}\oplus\mathbb{Z}_{2^{k-1}n}
  </annotation>
 </semantics>
</math>

</p>

<p>Depending on whether or not <em>m</em> is a <a href="quadratic_residue" title="wikilink">quadratic residue</a> <em>modulo p</em>.</p>
<h3 id="theorem-3">Theorem 3</h3>

<p>Let 

<math display="inline" id="Elliptic_curve_primality:97">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≡</mo>
   <mrow>
    <mn>3</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>4</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>p</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">3</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\equiv 3\;\;(\mathop{{\rm mod}}4)
  </annotation>
 </semantics>
</math>

 be prime, <em>E</em>, <em>k</em>, <em>n</em>, <em>m</em> as above. Take <em>Q</em> = (<em>x</em>,<em>y</em>) on <em>E</em>, <em>x</em> a quadratic nonresidue <em>modulo p</em>.</p>

<p>Then the order of <em>Q</em> is divisible by 

<math display="inline" id="Elliptic_curve_primality:98">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}
  </annotation>
 </semantics>
</math>

 in the cyclic group 

<math display="inline" id="Elliptic_curve_primality:99">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝔽</mi>
      <mi>p</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <msub>
    <mi>ℤ</mi>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mi>n</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔽</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\mathbb{F}_{p})\cong\mathbb{Z}_{2^{k}n}
  </annotation>
 </semantics>
</math>

.</p>

<p>First we will present the case where <em>n</em> is relatively small with respect to 

<math display="inline" id="Elliptic_curve_primality:100">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}
  </annotation>
 </semantics>
</math>

, and this will require one more theorem.</p>
<h3 id="theorem-4">Theorem 4</h3>

<p>Choose a 

<math display="inline" id="Elliptic_curve_primality:101">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>λ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda>1
  </annotation>
 </semantics>
</math>

. <em>E</em>, <em>k</em>, <em>n</em>, <em>m</em> are specified as above with the added restrictions that</p>

<p>

<math display="block" id="Elliptic_curve_primality:102">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≤</mo>
   <mrow>
    <msqrt>
     <mi>p</mi>
    </msqrt>
    <mo>/</mo>
    <mi>λ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>n</ci>
    <apply>
     <divide></divide>
     <apply>
      <root></root>
      <ci>p</ci>
     </apply>
     <ci>λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\leq\sqrt{p}/\lambda
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_curve_primality:103">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <msqrt>
     <mi>p</mi>
    </msqrt>
   </mrow>
   <mo>></mo>
   <mpadded width="+1.7pt">
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>p</mi>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>4</mn>
        </mrow>
       </msup>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <root></root>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">4</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\sqrt{p}>(p^{1/4}+1)^{2}\,
  </annotation>
 </semantics>
</math>

</p>

<p><em>p</em> is a prime if and only if there exists a <em>Q</em> = (<em>x</em>,<em>y</em>) which is on <em>E</em>, such that the</p>

<p>

<math display="inline" id="Elliptic_curve_primality:104">
 <semantics>
  <mrow>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <gcd></gcd>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>i</ci>
     </apply>
     <ci>p</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gcd{(S_{i},p)}=1
  </annotation>
 </semantics>
</math>

 for <em>i</em> = 1, 2, ...,<em>k</em> − 1 and 

<math display="inline" id="Elliptic_curve_primality:105">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>k</mi>
   </msub>
   <mo>≡</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{k}\equiv 0\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Elliptic_curve_primality:106">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}
  </annotation>
 </semantics>
</math>

 is a sequence with initial value 

<math display="inline" id="Elliptic_curve_primality:107">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{0}=x
  </annotation>
 </semantics>
</math>

</p>
<h2 id="the-algorithm">The algorithm</h2>

<p>We provide the following algorithm, which relies mainly on Theorems 3 and 4. To verify the primality of a given number <em>N</em>, perform the following steps:</p>

<p><strong>(1)</strong> Chose 

<math display="inline" id="Elliptic_curve_primality:108">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathbb{Z}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Elliptic_curve_primality:109">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mi>x</mi>
     <mi>N</mi>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>x</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\frac{x}{N})=-1
  </annotation>
 </semantics>
</math>

, and find <em>y</em> such that 

<math display="inline" id="Elliptic_curve_primality:110">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mrow>
      <msup>
       <mi>x</mi>
       <mn>3</mn>
      </msup>
      <mo>-</mo>
      <msup>
       <mi>y</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mi>N</mi>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\frac{x^{3}-y^{2}}{N})=1
  </annotation>
 </semantics>
</math>

</p>

<p>Take 

<math display="inline" id="Elliptic_curve_primality:111">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msup>
       <mi>x</mi>
       <mn>3</mn>
      </msup>
      <mo>-</mo>
      <msup>
       <mi>y</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mi>x</mi>
    </mfrac>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=\frac{x^{3}-y^{2}}{x}\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

</p>

<p>Then <em>Q</em>' = (<em>x</em>,<em>y</em>) is on <em>E</em>

<math display="block" id="Elliptic_curve_primality:112">
 <semantics>
  <mrow>
   <msup>
    <mi>y</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>-</mo>
    <mrow>
     <mi>m</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{2}=x^{3}-mx
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Elliptic_curve_primality:113">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>≢</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-equivalent-to</csymbol>
    <ci>m</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\not\equiv 0\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

</p>

<p>Calculate <em>Q</em> = <em>nQ</em>'. If 

<math display="inline" id="Elliptic_curve_primality:114">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <msub>
    <mi>P</mi>
    <mi mathvariant="normal">∞</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=P_{\infty}
  </annotation>
 </semantics>
</math>

 then <em>N</em> is composite, otherwise proceed to (2).</p>

<p><strong>(2)</strong> Set 

<math display="inline" id="Elliptic_curve_primality:115">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}
  </annotation>
 </semantics>
</math>

 as the sequence with initial value <em>Q</em>. Calculate 

<math display="inline" id="Elliptic_curve_primality:116">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}
  </annotation>
 </semantics>
</math>

 for <em>i</em> = 1,2,..., <em>k</em> − 1</p>

<p>If 

<math display="inline" id="Elliptic_curve_primality:117">
 <semantics>
  <mrow>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <gcd></gcd>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>i</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gcd({S_{i},N})>1
  </annotation>
 </semantics>
</math>

 for an <em>i</em>, where 

<math display="inline" id="Elliptic_curve_primality:118">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq k-1
  </annotation>
 </semantics>
</math>

 then <em>N</em> is composite. Otherwise, proceed to (3).</p>

<p><strong>(3)</strong> If 

<math display="inline" id="Elliptic_curve_primality:119">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>k</mi>
   </msub>
   <mo>≡</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{k}\equiv 0\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

 then <em>N</em> is prime. Otherwise, <em>N</em> is composite. This completes the test.</p>
<h2 id="justification-of-the-algorithm">Justification of the algorithm</h2>

<p>In (1), and elliptic curve, <em>E</em> is picked, along with a point <em>Q</em> on <em>E</em>, such that the <em>x</em>-coordinate of <em>Q</em> is a quadratic nonresidue. We can say</p>

<p>

<math display="block" id="Elliptic_curve_primality:120">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mi>m</mi>
     <mi>N</mi>
    </mfrac>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mfrac>
      <mrow>
       <msup>
        <mi>x</mi>
        <mn>3</mn>
       </msup>
       <mo>-</mo>
       <msup>
        <mi>y</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mi>x</mi>
     </mfrac>
     <mi>N</mi>
    </mfrac>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mi>x</mi>
      <mi>N</mi>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <msup>
        <mi>x</mi>
        <mn>3</mn>
       </msup>
       <mo>-</mo>
       <msup>
        <mi>y</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mi>N</mi>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mn>1</mn>
     <mo>⋅</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>m</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>x</ci>
       <ci>N</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="float">1.</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\frac{m}{N}\right)=\left(\frac{\frac{x^{3}-y^{2}}{x}}{N}\right)=\left(%
\frac{x}{N}\right)\left(\frac{x^{3}-y^{2}}{N}\right)=-1\cdot 1=-1.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, if <em>N</em> is prime, <em>Q</em>' has order divisible by 

<math display="inline" id="Elliptic_curve_primality:121">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}
  </annotation>
 </semantics>
</math>

, by Theorem 3, and therefore the order of <em>Q</em>' is 

<math display="inline" id="Elliptic_curve_primality:122">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>k</mi>
   </msup>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}d
  </annotation>
 </semantics>
</math>

 <em>d</em> | <em>n</em>.</p>

<p>This means <em>Q</em> = <em>nQ</em>' has order 

<math display="inline" id="Elliptic_curve_primality:123">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}
  </annotation>
 </semantics>
</math>

. Therefore, if (1) concludes that <em>N</em> is composite, it truly is composite. (2) and (3) check if <em>Q</em> has order 

<math display="inline" id="Elliptic_curve_primality:124">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}
  </annotation>
 </semantics>
</math>

. Thus, if (2) or (3) conclude <em>N</em> is composite, it is composite.</p>

<p>Now, if the algorithm concludes that <em>N</em> is prime, then that means 

<math display="inline" id="Elliptic_curve_primality:125">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}
  </annotation>
 </semantics>
</math>

 satisfies the condition of Theorem 4, and so <em>N</em> is truly prime.</p>

<p>There is an algorithm as well for when <em>n</em> is large, however for this we refer to the aforementioned article.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.ams.org/journals/mcom/1993-61-203/S0025-5718-1993-1199989-X/">Elliptic Curves and Primality Proving</a> by <a href="A._O._L._Atkin" title="wikilink">Atkin</a> and Morain.</li>
<li></li>
<li>Chris Caldwell, <a href="http://primes.utm.edu/prove/prove4_2.html">"Primality Proving 4.2: Elliptic curves and the ECPP test"</a> at the <a href="Prime_Pages" title="wikilink">Prime Pages</a>.</li>
<li>François Morain, <a href="http://www.lix.polytechnique.fr/~morain/Prgms/ecpp.english.html">"The ECPP home page"</a> (includes old ECPP software for some architectures).</li>
<li>Marcel Martin, <a href="http://www.ellipsa.eu/public/primo/index.html">"Primo"</a> (binary for Linux 64-bit)</li>
<li><a href="http://sourceforge.net/projects/gmp-ecpp">GMP-ECPP</a>, a free ECPP implementation</li>
<li><a href="http://web.archive.org/web/20110719095735/http://www.cdc.informatik.tu-darmstadt.de/TI/LiDIA/">LiDIA</a>, a free <a class="uri" href="C++" title="wikilink">C++</a> library with ECPP support</li>
</ul>

<p>"</p>

<p><a href="Category:Primality_tests" title="wikilink">Category:Primality tests</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Top, Jaap, <em>Elliptic Curve Primality Proving</em>, <a class="uri" href="http://www.math.rug.nl/~top/atkin.pdf">http://www.math.rug.nl/~top/atkin.pdf</a><a href="#fnref2">↩</a></li>
<li id="fn3">Atkin, A.O.L., Morain, F., <em>Elliptic Curves and Primality Proving</em>, <a class="uri" href="http://www.iai.uni-bonn.de/~adrian/ecpp/1992-atkin-morain-elliptic.pdf">http://www.iai.uni-bonn.de/~adrian/ecpp/1992-atkin-morain-elliptic.pdf</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="Lawrence_C._Washington" title="wikilink">Washington, Lawrence C.</a>, <strong>Elliptic Curves: Number Theory and Cryptography</strong>, Chapman &amp; Hall/CRC, 2003<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">Caldwell, Chris. <a href="http://primes.utm.edu/top20/page.php?id=27"><em>The Top Twenty: Elliptic Curve Primality Proof</em></a> from the <a href="Prime_Pages" title="wikilink">Prime Pages</a>.<a href="#fnref6">↩</a></li>
<li id="fn7">Koblitz, Neal, <strong>Introduction to Number Theory and Cryptography</strong>, 2nd Ed, Springer, 1994<a href="#fnref7">↩</a></li>
<li id="fn8"><a class="uri" href="http://www.mast.queensu.ca/~math418/m418oh/m418oh27.pdf">http://www.mast.queensu.ca/~math418/m418oh/m418oh27.pdf</a><a href="#fnref8">↩</a></li>
<li id="fn9">Blake, Ian F., Seroussi, Gadiel, Smart, Nigel Paul, <strong>Elliptic Curves in Cryptography</strong>, Cambridge University Press, 1999<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11">Lenstra, Hendrik W., <em>Efficient Algorithms in Number Theory</em>, <a class="uri" href="https://openaccess.leidenuniv.nl/bitstream/1887/2141/1/346_081.pdf">https://openaccess.leidenuniv.nl/bitstream/1887/2141/1/346_081.pdf</a><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"><a class="uri" href="http://algo.inria.fr/seminars/sem97-98/morain.html">http://algo.inria.fr/seminars/sem97-98/morain.html</a><a href="#fnref16">↩</a></li>
<li id="fn17">Morain, Francois, Implementation of the Atkin–Goldwasser–Kilian Primality Testing Algorithm, <a class="uri" href="https://eprints.kfupm.edu.sa/44864/1/44864.pdf">https://eprints.kfupm.edu.sa/44864/1/44864.pdf</a><a href="#fnref17">↩</a></li>
<li id="fn18">Goldwasser, Shafi, Kilian, Joe, <em>Almost All Primes Can Be Quickly Certified</em>, <a class="uri" href="http://www.iai.uni-bonn.de/~adrian/ecpp/p316-goldwasser.pdf">http://www.iai.uni-bonn.de/~adrian/ecpp/p316-goldwasser.pdf</a><a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"><a class="uri" href="http://primes.utm.edu/notes/by_year.html">http://primes.utm.edu/notes/by_year.html</a><a href="#fnref21">↩</a></li>
<li id="fn22">Tsumura, Yu, ''Primality Tests for 

<math display="inline" id="Elliptic_curve_primality:126">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>k</mi>
    </msup>
    <mi>n</mi>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}n-1
  </annotation>
 </semantics>
</math>

 Using Elliptic Curves, <a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24"></li>
</ol>
</section>
</body>
</html>
