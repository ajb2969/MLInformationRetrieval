   Range mode query      Range mode query   In data structures , the range mode query problem asks to build a data structure on some input data to efficiently answer queries asking for the mode of any consecutive subset of the input.  Problem Statement  Given an array    A   [  1  :  n  ]   =   [   a  1   ,   a  2   ,  …  ,   a  n   ]      fragments  A   fragments  normal-[  1  normal-:  n  normal-]     fragments  normal-[   subscript  a  1   normal-,   subscript  a  2   normal-,  normal-…  normal-,   subscript  a  n   normal-]     A[1:n]=[a_{1},a_{2},...,a_{n}]   , we wish to answer queries of the form    m  o  d  e   (  A  ,  i  :  j  )      fragments  m  o  d  e   fragments  normal-(  A  normal-,  i  normal-:  j  normal-)     mode(A,i:j)   , where    1  ≤  i  ≤  j  ≤  n        1  i       j       n     1\leq i\leq j\leq n   . The mode of an array    S  =   [   s  1   ,   s  2   ,  …  ,   s  n   ]       S    subscript  s  1    subscript  s  2   normal-…   subscript  s  n      S=[s_{1},s_{2},...,s_{n}]   ,    m  o  d  e   (  S  )       m  o  d  e  S    mode(S)   , is an element    s  i     subscript  s  i    s_{i}   such that the frequency of    s  i     subscript  s  i    s_{i}   is greater than the frequency of       s  j     ∀  j    ∈   {  1  ,  …  ,  n  }          subscript  s  j    for-all  j     1  normal-…  n     s_{j}\;\forall j\in\{1,...,n\}   . For example, if    S  =   [  1  ,  2  ,  4  ,  2  ,  3  ,  4  ,  2  ]       S   1  2  4  2  3  4  2     S=[1,2,4,2,3,4,2]   ,     m  o  d  e   (  s  )    =  2        m  o  d  e  s   2    mode(s)=2   . This definition can be extended to the mode of any subset of the array    A   [  i  :  j  ]   =   [   a  i   ,   a  i   +  1  ,  …  ,   a  j   ]      fragments  A   fragments  normal-[  i  normal-:  j  normal-]     fragments  normal-[   subscript  a  i   normal-,   subscript  a  i    1  normal-,  normal-…  normal-,   subscript  a  j   normal-]     A[i:j]=[a_{i},a_{i}+1,...,a_{j}]   .  Theorem 1  Let   A   A   A   and   B   B   B   be any multisets . If   c   c   c   is a mode of    A  ∪  B      A  B    A\cup B   and    c  ∉  A      c  A    c\notin A   , then   c   c   c   is a mode of   B   B   B   .  Proof  Let    c  ∉  A      c  A    c\notin A   be a mode of    C  =   A  ∪  B       C    A  B     C=A\cup B   and    f  c     subscript  f  c    f_{c}   be its frequency in   C   C   C   . Suppose that   c   c   c   is not a mode of   B   B   B   . Thus, there exists an element   b   b   b   with frequency    f  b     subscript  f  b    f_{b}   that is the mode of   B   B   B   . Since   b   b   b   is the mode of   B   B   B   and that    c  ∉  A      c  A    c\notin A   , then     f  b   >   f  c        subscript  f  b    subscript  f  c     f_{b}>f_{c}   . Thus,   b   b   b   should be the mode of   C   C   C   which is a contradiction.  Results      Space   Query Time   Restrictions   Source           O   (  n  )       O  n    O(n)          O   (   n   )       O    n     O(\sqrt{n})       1         O   (  n  )       O  n    O(n)          O   (    n  /  w    )       O      n  w      O(\sqrt{n/w})         w   w   w   is the word size   2         O   (    n  2    log   log   n  /   log  n       )       O     superscript  n  2         n    n         O(n^{2}\log\log n/\log n)          O   (  1  )       O  1    O(1)       3         O   (   n   2  -   2  ϵ     )       O   superscript  n    2    2  ϵ       O(n^{2-2\epsilon})          O   (    n  ϵ    log  n    )       O     superscript  n  ϵ     n      O(n^{\epsilon}\log n)          0  ≤  ϵ  ≤   1  /  2         0  ϵ         1  2      0\leq\epsilon\leq 1/2      4       Lower bound  Any data structure using   S   S   S   cells of   w   w   w   bits each needs    Ω   (    log  n    log   (    S  w   /  n   )     )       normal-Ω      n         S  w   n       \Omega\left(\frac{\log n}{\log(Sw/n)}\right)   time to answer a range mode query. 5  This contrasts with other range mode problems, such as the range minimum query which have solutions offering constant time query time and linear space. This is due to the hardness of the mode problem, since if we know the mode of    A   [  i  :  j  ]      fragments  A   fragments  normal-[  i  normal-:  j  normal-]     A[i:j]   and the mode of    A   [  j  +  i  :  k  ]      fragments  A   fragments  normal-[  j   i  normal-:  k  normal-]     A[j+i:k]   , there is no simple way of computing the mode of    A   [  i  :  k  ]      fragments  A   fragments  normal-[  i  normal-:  k  normal-]     A[i:k]   . Any element of    A   [  j  +  i  :  k  ]      fragments  A   fragments  normal-[  j   i  normal-:  k  normal-]     A[j+i:k]   or    A   [  j  +  i  :  k  ]      fragments  A   fragments  normal-[  j   i  normal-:  k  normal-]     A[j+i:k]   could be the mode. For example, if    m  o  d  e   (  A   [  i  :  j  ]   )   =  a     fragments  m  o  d  e   fragments  normal-(  A   fragments  normal-[  i  normal-:  j  normal-]   normal-)    a    mode(A[i:j])=a   and its frequency is    f  a     subscript  f  a    f_{a}   , and    m  o  d  e   (  A   [  j  +  1  :  k  ]   )   =  b     fragments  m  o  d  e   fragments  normal-(  A   fragments  normal-[  j   1  normal-:  k  normal-]   normal-)    b    mode(A[j+1:k])=b   and its frequency is also    f  a     subscript  f  a    f_{a}   , there could be an element   c   c   c   with frequency     f  a   -  1       subscript  f  a   1    f_{a}-1   in    A   [  i  :  j  ]      fragments  A   fragments  normal-[  i  normal-:  j  normal-]     A[i:j]   and frequency     f  a   -  1       subscript  f  a   1    f_{a}-1   in    A   [  j  +  1  :  k  ]      fragments  A   fragments  normal-[  j   1  normal-:  k  normal-]     A[j+1:k]   .    a  ≠  c  ≠  b        a  c       b     a\not=c\not=b   , but its frequency in    A   [  i  :  k  ]      fragments  A   fragments  normal-[  i  normal-:  k  normal-]     A[i:k]   is greater than the frequency of   a   a   a   and   b   b   b   , which makes   c   c   c   a better candidate for    m  o  d  e   (  A   [  i  :  k  ]   )      fragments  m  o  d  e   fragments  normal-(  A   fragments  normal-[  i  normal-:  k  normal-]   normal-)     mode(A[i:k])   than   a   a   a   or   b   b   b   .  Linear space data structure with square root query time  This method by Chan et al. 6 uses    O   (   n  +   s  2    )       O    n   superscript  s  2      O(n+s^{2})   space and    O   (   n  /  s   )       O    n  s     O(n/s)   query time. By setting    s  =   n       s    n     s=\sqrt{n}   , we get    O   (  n  )       O  n    O(n)   and    O   (   n   )       O    n     O(\sqrt{n})   bounds for space and query time.  Preprocessing  Let    A   [  1  :  n  ]      fragments  A   fragments  normal-[  1  normal-:  n  normal-]     A[1:n]   be an array, and    D   [  1  :  Δ  ]      fragments  D   fragments  normal-[  1  normal-:  Δ  normal-]     D[1:\Delta]   be an array that contains the distinct values of A, where   Δ   normal-Δ   \Delta   is the number of distinct elements. We define    B   [  1  :  n  ]      fragments  B   fragments  normal-[  1  normal-:  n  normal-]     B[1:n]   to be an array such that, for each   i   i   i   ,    B   [  i  ]       B   delimited-[]  i     B[i]   contains the rank (position) of    A   [  i  ]       A   delimited-[]  i     A[i]   in   D   D   D   . Arrays    B  ,  D     B  D    B,D   can be created by a linear scan of   A   A   A   .  Arrays     Q  1   ,   Q  2   ,  …  ,   Q  Δ       subscript  Q  1    subscript  Q  2   normal-…   subscript  Q  normal-Δ     Q_{1},Q_{2},...,Q_{\Delta}   are also created, such that, for each    a  ∈   {  1  ,  …  ,  Δ  }       a   1  normal-…  normal-Δ     a\in\{1,...,\Delta\}   ,     Q  a   =   {   b   |    B   [  b  ]    =  a   }        subscript  Q  a    conditional-set  b      B   delimited-[]  b    a      Q_{a}=\{b\;|\;B[b]=a\}   . We then create an array     B  ′    [  1  :  n  ]      fragments   superscript  B  normal-′    fragments  normal-[  1  normal-:  n  normal-]     B^{\prime}[1:n]   , such that, for all    b  ∈   {  1  ,  …  ,  n  }       b   1  normal-…  n     b\in\{1,...,n\}   ,     B  ′    [  b  ]        superscript  B  normal-′    delimited-[]  b     B^{\prime}[b]   contains the rank of   b   b   b   in    Q   B   [  b  ]       subscript  Q    B   delimited-[]  b      Q_{B[b]}   . Again, a linear scan of   B   B   B   suffices to create arrays     Q  1   ,   Q  2   ,  …  ,   Q  Δ       subscript  Q  1    subscript  Q  2   normal-…   subscript  Q  normal-Δ     Q_{1},Q_{2},...,Q_{\Delta}   and    B  ′     superscript  B  normal-′    B^{\prime}   .  It is now possible to answer queries of the form "is the frequency of    B   [  i  ]       B   delimited-[]  i     B[i]   in    B   [  i  :  j  ]      fragments  B   fragments  normal-[  i  normal-:  j  normal-]     B[i:j]   at least   q   q   q   " in constant time, by checking whether      Q   B   [  i  ]      [      B  ′    [  i  ]    +  q   -  1   ]    ≤  j         subscript  Q    B   delimited-[]  i      delimited-[]         superscript  B  normal-′    delimited-[]  i    q   1     j    Q_{B[i]}[B^{\prime}[i]+q-1]\leq j   .  The array is split B into   s   s   s   blocks     b  1   ,   b  2   ,  …  ,   b  s       subscript  b  1    subscript  b  2   normal-…   subscript  b  s     b_{1},b_{2},...,b_{s}   , each of size    t  =   ⌈   n  /  s   ⌉       t      n  s      t=\lceil n/s\rceil   . Thus, a block    b  i     subscript  b  i    b_{i}   spans over    B   [  i  ⋅  t  +  1  :   (  i  +  1  )   t  ]      fragments  B   fragments  normal-[  i  normal-⋅  t   1  normal-:   fragments  normal-(  i   1  normal-)   t  normal-]     B[i\cdot t+1:(i+1)t]   . The mode and the frequency of each block or set of consecutive blocks will be pre-computed in two tables   S   S   S   and    S  ′     superscript  S  normal-′    S^{\prime}   .    S   [   b  i   ,   b  j   ]       S    subscript  b  i    subscript  b  j      S[b_{i},b_{j}]   is the mode of     b  i   ∪   b   i  +  1    ∪  …  ∪   b  j        subscript  b  i    subscript  b    i  1    normal-…   subscript  b  j     b_{i}\cup b_{i+1}\cup...\cup b_{j}   , or equivalently, the mode of    B   [   b  i   t  +  1  :   (   b  j   +  1  )   t  ]      fragments  B   fragments  normal-[   subscript  b  i   t   1  normal-:   fragments  normal-(   subscript  b  j    1  normal-)   t  normal-]     B[b_{i}t+1:(b_{j}+1)t]   , and    S  ′     superscript  S  normal-′    S^{\prime}   stores the corresponding frequency. These two tables can be stored in    O   (   s  2   )       O   superscript  s  2     O(s^{2})   space, and can be populated in    O   (   s  ⋅  n   )       O   normal-⋅  s  n     O(s\cdot n)   by scanning   B   B   B      s   s   s   times, computing a row of    S  ,   S  ′      S   superscript  S  normal-′     S,S^{\prime}   each time with the following algorithm:  algorithm computeS_Sprime is   input: Array B =[0:n-1],  Array D =[0:Delta-1],  Integer s   output: Tables S and Sprime  let S ← Table(0:s-1,0:s-1)  let Sprime ← Table(0:s-1,0:s-1)  let firstOccurence ← Array(0:Delta-1)   for  all i in {0,...,Delta-1} do  firstOccurence[i] ← -1   end  for   for i ← 0:s-1 do   let j ← i*t  let c ← 0  let fc ← 0  let noBlock ← i  let block_start ← j  let block_end ← min{(i+1)*t-1, n-1}   while j B . This can be translated to an answer over    A   A   A    , since for any     a  ,  i  ,  j     a  i  j    a,i,j    ,     B   [  a  ]       B   delimited-[]  a     B[a]    is a mode for     B   [  i  :  j  ]      fragments  B   fragments  normal-[  i  normal-:  j  normal-]     B[i:j]    if and only if     A   [  a  ]       A   delimited-[]  a     A[a]    is a mode for     A   [  i  :  j  ]      fragments  A   fragments  normal-[  i  normal-:  j  normal-]     A[i:j]    . We can convert an answer for    B   B   B    to an answer for    A   A   A    in constant time by looking in    A   A   A    or    B   B   B    at the corresponding index.  Given a query    m  o  d  e   (  B  ,  i  ,  j  )       m  o  d  e   B  i  j     mode(B,i,j)   , the query is split in three parts: the prefix, the span and the suffix. Let     b  i   =   ⌈    (   i  -  1   )   /  t   ⌉        subscript  b  i         i  1   t      b_{i}=\lceil(i-1)/t\rceil   and     b  j   =    ⌊   j  /  t   ⌋   -  1        subscript  b  j         j  t    1     b_{j}=\lfloor j/t\rfloor-1   . These denote the indices of the first and last block that are completely contained in   B   B   B   . The range of these blocks is called the span. The prefix is then    B   [  i  :  m  i  n   {   b  i   t  ,  j  }   ]      fragments  B   fragments  normal-[  i  normal-:  m  i  n   fragments  normal-{   subscript  b  i   t  normal-,  j  normal-}   normal-]     B[i:min\{b_{i}t,j\}]   (the set of indices before the span), and the suffix is    B   [  m  a  x   {   (   b  j   +  1  )   t  +  1  ,  i  }   :  j  ]      fragments  B   fragments  normal-[  m  a  x   fragments  normal-{   fragments  normal-(   subscript  b  j    1  normal-)   t   1  normal-,  i  normal-}   normal-:  j  normal-]     B[max\{(b_{j}+1)t+1,i\}:j]   (the set of indices after the span). The prefix, suffix or span can be empty, the latter is if     b  j   <   b  i        subscript  b  j    subscript  b  i     b_{j}   .  For the span, the mode   c   c   c   is already stored in    S   [   b  i   ,   b  j   ]       S    subscript  b  i    subscript  b  j      S[b_{i},b_{j}]   . Let    f  c     subscript  f  c    f_{c}   be the frequency of the mode, which is stored in     S  ′    [   b  i   ,   b  j   ]        superscript  S  normal-′     subscript  b  i    subscript  b  j      S^{\prime}[b_{i},b_{j}]   . If the span is empty, let     f  c   =  0       subscript  f  c   0    f_{c}=0   . Recall that, by Theorem 1, the mode of    B   [  i  :  j  ]      fragments  B   fragments  normal-[  i  normal-:  j  normal-]     B[i:j]   is either an element of the prefix, span or suffix  . A linear scan is performed over each element in the prefix and in the suffix to check if its frequency is greater than the current candidate   c   c   c   , in which case   c   c   c   and    f  c     subscript  f  c    f_{c}   are updated to the new value. At the end of the scan,   c   c   c   contains the mode of    B   [  i  :  j  ]      fragments  B   fragments  normal-[  i  normal-:  j  normal-]     B[i:j]   and    f  c     subscript  f  c    f_{c}   its frequency.  Scanning procedure  The procedure is similar for both prefix and suffix, so it suffice to run this procedure for both:  Let   x   x   x   be the index of the current element. There are three cases:   If      Q   B   [  x  ]      [     B  ′    [  x  ]    -  1   ]    ≥  i         subscript  Q    B   delimited-[]  x      delimited-[]       superscript  B  normal-′    delimited-[]  x    1     i    Q_{B[x]}[B^{\prime}[x]-1]\geq i   , then it was present in    B   [  i  :  x  -  1  ]      fragments  B   fragments  normal-[  i  normal-:  x   1  normal-]     B[i:x-1]   and its frequency has already been counted. Pass to the next element.  Otherwise, check if the frequency of    B   [  x  ]       B   delimited-[]  x     B[x]   in    B   [  i  :  j  ]      fragments  B   fragments  normal-[  i  normal-:  j  normal-]     B[i:j]   is at least    f  c     subscript  f  c    f_{c}   (this can be done in constant time since it is the equivalent of checking it for    B   [  x  :  j  ]      fragments  B   fragments  normal-[  x  normal-:  j  normal-]     B[x:j]   ).  If it is not, then pass to the next element.  If it is, then compute the actual frequency    f  x     subscript  f  x    f_{x}   of    B   [  x  ]       B   delimited-[]  x     B[x]   in    B   [  i  :  j  ]      fragments  B   fragments  normal-[  i  normal-:  j  normal-]     B[i:j]   by a linear scan (starting at index       B  ′    [  x  ]    +   f  c    -  1           superscript  B  normal-′    delimited-[]  x     subscript  f  c    1    B^{\prime}[x]+f_{c}-1   ) or a binary search in    Q   B   [  x  ]       subscript  Q    B   delimited-[]  x      Q_{B[x]}   . Set    c  :=   B   [  x  ]       assign  c    B   delimited-[]  x      c:=B[x]   and     f  c   :=   f  x      assign   subscript  f  c    subscript  f  x     f_{c}:=f_{x}   .    This linear scan (excluding the frequency computations) is bounded by the block size   t   t   t   , since neither the prefix or the suffix can be greater than   t   t   t   . A further analysis of the linear scans done for frequency computations shows that it is also bounded by the block size. 7 Thus, the query time is     O   (  t  )    =   O   (   n  /  s   )          O  t     O    n  s      O(t)=O(n/s)   .  Subquadratic space data structure with constant query time  This method by 8 uses    O   (     n  2    log   log  n      log  n    )       O       superscript  n  2       n       n      O\left(\frac{n^{2}\log{\log{n}}}{\log{n}}\right)   space for a constant time query. We can observe that, if a constant query time is desired, this is a better solution than the one proposed by Chan et al., 9 as the latter gives a space of    O   (   n  2   )       O   superscript  n  2     O(n^{2})   for constant query time if    s  =  n      s  n    s=n   .  Preprocessing  Let    A   [  1  :  n  ]      fragments  A   fragments  normal-[  1  normal-:  n  normal-]     A[1:n]   be an array. The preprocessing is done in three steps:   Split the array   A   A   A   in   s   s   s   blocks     b  1   ,   b  2   ,  …  ,   b  s       subscript  b  1    subscript  b  2   normal-…   subscript  b  s     b_{1},b_{2},...,b_{s}   , where the size of each block is    t  =   ⌈   n  /  s   ⌉       t      n  s      t=\lceil n/s\rceil   . Build a table   S   S   S   of size    s  ×  s      s  s    s\times s   where    S   [  i  ,  j  ]       S   i  j     S[i,j]   is the mode of     b  i   ∪   b   i  +  1    ∪  …  ∪   b  j        subscript  b  i    subscript  b    i  1    normal-…   subscript  b  j     b_{i}\cup b_{i+1}\cup...\cup b_{j}   . The total space for this step is    O   (   s  2   )       O   superscript  s  2     O(s^{2})     For any query    m  o  d  e   (  A  ,  i  ,  j  )       m  o  d  e   A  i  j     mode(A,i,j)   , let    b   i  ′      subscript  b   superscript  i  normal-′     b_{i^{\prime}}   be the block that contains   i   i   i   and    b   j  ′      subscript  b   superscript  j  normal-′     b_{j^{\prime}}   be the block that contains   j   j   j   . Let the span be the set of blocks completely contained in    A   [  i  :  j  ]      fragments  A   fragments  normal-[  i  normal-:  j  normal-]     A[i:j]   . The mode   c   c   c   of the block can be retrieved from   S   S   S   . By Theorem 1, the mode can be either the mode of the prefix (indices of    A   [  i  :  j  ]      fragments  A   fragments  normal-[  i  normal-:  j  normal-]     A[i:j]   before the start of the span), the mode of the suffix (indices of    A   [  i  :  j  ]      fragments  A   fragments  normal-[  i  normal-:  j  normal-]     A[i:j]   after the end of the span), or   c   c   c   . The size of the prefix plus the size of the suffix is bounded by    2  t      2  t    2t   , thus the position of the mode isstored as an integer ranging from   0   0    to    2  t      2  t    2t   , where    [   0  :    2  t   -  1    ]     delimited-[]   normal-:  0      2  t   1      [0:2t-1]   indicates a position in the prefix/suffix and    2  t      2  t    2t   indicates that the mode is the mode of the span. There are    (      t      2      )     binomial  t  2    {\left({{t}\atop{2}}\right)}   possible queries involving blocks    b   i  ′      subscript  b   superscript  i  normal-′     b_{i^{\prime}}   and    b   j  ′      subscript  b   superscript  j  normal-′     b_{j^{\prime}}   , so these values are stored in a table of size    t  2     superscript  t  2    t^{2}   . Furthermore, there are     (    2  t   +  1   )    t  2      superscript      2  t   1    superscript  t  2     (2t+1)^{t^{2}}   such tables, so the total space required for this step is    O   (    t  2     (    2  t   +  1   )    t  2     )       O     superscript  t  2    superscript      2  t   1    superscript  t  2       O(t^{2}(2t+1)^{t^{2}})   . To access those tables, a pointer is added in addition to the mode in the table   S   S   S   for each pair of blocks.  To handle queries    m  o  d  e   (  A  ,  i  ,  j  )       m  o  d  e   A  i  j     mode(A,i,j)   where   i   i   i   and   j   j   j   are in the same block, all such solutions are precomputed. There are    O   (   s   t  2    )       O    s   superscript  t  2      O(st^{2})   of them, they are stored in a three dimensional table   T   T   T   of this size.   The total space used by this data structure is    O   (    s  2   +    t  2     (    2  t   +  1   )    t  2     +   s   t  2     )       O     superscript  s  2      superscript  t  2    superscript      2  t   1    superscript  t  2       s   superscript  t  2       O(s^{2}+t^{2}(2t+1)^{t^{2}}+st^{2})   , which reduces to    O   (     n  2    log   log  n      log  n    )       O       superscript  n  2       n       n      O\left(\frac{n^{2}\log{\log{n}}}{\log{n}}\right)   if we take    t  =    log   n  /   log   log  n           t        n      n         t=\sqrt{\log{n}/\log{\log{n}}}   .  Query  Given a query    m  o  d  e   (  A  ,  i  ,  j  )       m  o  d  e   A  i  j     mode(A,i,j)   , check if it is completely contained inside a block, in which case the answer is stored in table   T   T   T   . If the query spans exactly one or more blocks, then the answer is found in table   S   S   S   . Otherwise, use the pointer stored in table   S   S   S   at position    S   [   b   i  ′    ,   b   j  ′    ]       S    subscript  b   superscript  i  normal-′     subscript  b   superscript  j  normal-′       S[b_{i^{\prime}},b_{j^{\prime}}]   , where     b   i  ′    ,   b   j  ′        subscript  b   superscript  i  normal-′     subscript  b   superscript  j  normal-′      b_{i^{\prime}},b_{j^{\prime}}   are the indices of the blocks that contain respectively   i   i   i   and   j   j   j   , to find the table    U    b   i  ′    ,   b   j  ′        subscript  U    subscript  b   superscript  i  normal-′     subscript  b   superscript  j  normal-′       U_{b_{i^{\prime}},b_{j^{\prime}}}   that contains the positions of the mode for these blocks and use the position to find the mode in   A   A   A   . This can be done in constant time.  References  "  Category:Arrays     ↩    ↩  ↩         