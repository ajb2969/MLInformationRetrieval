<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="330">Generalized filtering</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Generalized filtering</h1>
<hr>'''Generalized filtering''' is a generic [[Recursive Bayesian estimation|Bayesian filtering]] scheme for nonlinear state-space models.<ref>K Friston, K Stephan, B Li, and J. Daunizeau, "[http://www.fil.ion.ucl.ac.uk/~karl/Generalised%20Filtering.pdf Generalised Filtering]," [[Mathematical Problems in Engineering]], vol. vol., 2010, p. 621670, 2010.</ref> It is based on a [[Principle of least action|variational principle 
<p>of least action]], formulated in <a href="generalized_coordinates" title="wikilink">generalized coordinates</a> of motion.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Generalized filtering furnishes posterior densities over hidden states (and parameters) generating observed data using a generalized gradient descent on variational free energy, under the <a href="Laplace's_method" title="wikilink">Laplace assumption</a>. Unlike classical (e.g., <a href="Kalman_filter" title="wikilink">Kalman-Bucy</a> or <a href="Particle_filter" title="wikilink">particle</a>) filtering, generalized filtering eschews Markovian assumptions about random fluctuations. Furthermore, it operates online, assimilating data to approximate the posterior density over unknown quantities, without the need for a backward pass. Special cases include <strong>variational filtering</strong>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <strong>dynamic expectation maximization</strong><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and <strong>generalized predictive coding</strong>.</p>
<h2 id="definition">Definition</h2>

<p><strong>Definition</strong>: Generalized filtering rests on the <a class="uri" href="tuple" title="wikilink">tuple</a> 

<math display="inline" id="Generalized_filtering:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi mathvariant="normal">Ω</mi>
   <mo>,</mo>
   <mi>U</mi>
   <mo>,</mo>
   <mi>X</mi>
   <mo>,</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>normal-Ω</ci>
    <ci>U</ci>
    <ci>X</ci>
    <ci>S</ci>
    <ci>p</ci>
    <ci>q</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Omega,U,X,S,p,q)
  </annotation>
 </semantics>
</math>

:</p>
<ul>
<li><em>A sample space</em> 

<math display="inline" id="Generalized_filtering:1">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 from which random fluctuations 

<math display="inline" id="Generalized_filtering:2">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ω</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega\in\Omega
  </annotation>
 </semantics>
</math>

 are drawn</li>
</ul>
<ul>
<li><em>Control states</em> 

<math display="inline" id="Generalized_filtering:3">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>∈</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>U</ci>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U\in\mathbb{R}
  </annotation>
 </semantics>
</math>

 – that act as external causes, input or forcing terms</li>
</ul>
<ul>
<li><em>Hidden states</em> 

<math display="inline" id="Generalized_filtering:4">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>×</mo>
     <mi>U</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Ω</mi>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>X</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>U</ci>
      <ci>normal-Ω</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X:X\times U\times\Omega\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 – that cause sensor states and depend on control states</li>
</ul>
<ul>
<li><em>Sensor states</em> 

<math display="inline" id="Generalized_filtering:5">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>×</mo>
     <mi>U</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Ω</mi>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>S</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>U</ci>
      <ci>normal-Ω</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S:X\times U\times\Omega\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 – a probabilistic mapping from hidden and control states</li>
</ul>
<ul>
<li><em>Generative density</em> 

<math display="inline" id="Generalized_filtering:6">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>s</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>∣</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>u</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\tilde{s},\tilde{x},\tilde{u}\mid m)
  </annotation>
 </semantics>
</math>

 – over sensory, hidden and control states under a generative model</li>
</ul>
<ul>
<li><em>Variational density</em> 

<math display="inline" id="Generalized_filtering:7">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>∣</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>u</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(\tilde{x},\tilde{u}\mid m)
  </annotation>
 </semantics>
</math>

 – over hidden and control states with mean 

<math display="inline" id="Generalized_filtering:8">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>μ</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>∈</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <ci>normal-~</ci>
     <ci>μ</ci>
    </apply>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\mu}\in\mathbb{R}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Here ~ denotes a variable in generalized coordinates of motion

<math display="block" id="Generalized_filtering:9">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>u</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>u</mi>
     <mo>,</mo>
     <msup>
      <mi>u</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <msup>
      <mi>u</mi>
      <mi>′′</mi>
     </msup>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <list>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <ci>′′</ci>
      </apply>
      <ci>normal-…</ci>
     </list>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{u}=[u,u^{\prime},u^{\prime\prime},\ldots]^{T}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="generalized-filtering">Generalized filtering</h3>

<p>The objective is to approximate the posterior density over hidden and control states, given sensor states and a generative model – and estimate the (path integral of) <a href="Marginal_likelihood" title="wikilink">model evidence</a> 

<math display="inline" id="Generalized_filtering:10">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>s</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>s</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\tilde{s}(t)|m)
  </annotation>
 </semantics>
</math>

 to compare different models. This generally involves an intractable marginalization over hidden states, so model evidence (or marginal likelihood) is replaced with a variational free energy bound.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Given the following definitions:</p>

<p>

<math display="block" id="Generalized_filtering:11">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>μ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mrow>
      <mpadded width="+1.7pt">
       <mi>arg</mi>
      </mpadded>
      <mi>min</mi>
     </mrow>
     <mover accent="true">
      <mi>μ</mi>
      <mo stretchy="false">~</mo>
     </mover>
    </munder>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mover accent="true">
         <mi>s</mi>
         <mo stretchy="false">~</mo>
        </mover>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mover accent="true">
        <mi>μ</mi>
        <mo stretchy="false">~</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <ci>μ</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <ci>normal-~</ci>
       <ci>μ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>arg</ci>
       <ci>min</ci>
      </apply>
     </apply>
     <set>
      <apply>
       <times></times>
       <ci>F</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <ci>normal-~</ci>
          <ci>s</ci>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <ci>normal-~</ci>
         <ci>μ</ci>
        </apply>
       </interval>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\mu}(t)=\underset{\tilde{\mu}}{\operatorname{arg\,min}}\{F(\tilde{{s}}(%
t),\tilde{{\mu}})\}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Generalized_filtering:12">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>s</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>-</mo>
   <mi>ln</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>s</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo stretchy="false">|</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">G</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>u</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <minus></minus>
    <ln></ln>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>u</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(\tilde{s},\tilde{x},\tilde{u})=-\ln p(\tilde{s},\tilde{x},\tilde{u}|m)
  </annotation>
 </semantics>
</math>

</p>

<p>Denote the <a href="Entropy_(information_theory)" title="wikilink">Shannon entropy</a> of the density 

<math display="inline" id="Generalized_filtering:13">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Generalized_filtering:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>E</mi>
     <mi>q</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>q</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>q</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>q</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <log></log>
        <ci>q</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H[q]=E_{q}[-\log(q)]
  </annotation>
 </semantics>
</math>

. We can then write the variational free energy in two ways:</p>

<p>

<math display="block" id="Generalized_filtering:15">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>s</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>μ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>E</mi>
    <mi>q</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>s</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo>,</mo>
     <mo>⋅</mo>
     <mo>,</mo>
     <mo>⋅</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>-</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>⋅</mo>
     <mo>,</mo>
     <mo>⋅</mo>
     <mo stretchy="false">|</mo>
     <mover accent="true">
      <mi>μ</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mo>-</mo>
   <mi>ln</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>s</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo stretchy="false">|</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <msub>
    <mi>D</mi>
    <mrow>
     <mi>K</mi>
     <mi>L</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>⋅</mo>
     <mo>,</mo>
     <mo>⋅</mo>
     <mo stretchy="false">|</mo>
     <mover accent="true">
      <mi>μ</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mo stretchy="false">|</mo>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>⋅</mo>
     <mo>,</mo>
     <mo>⋅</mo>
     <mo stretchy="false">|</mo>
     <mover accent="true">
      <mi>s</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo>,</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>μ</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>q</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">G</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <ci>normal-~</ci>
       <ci>s</ci>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-⋅</ci>
      <ci>normal-,</ci>
      <ci>normal-⋅</ci>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>normal-⋅</ci>
      <ci>normal-,</ci>
      <ci>normal-⋅</ci>
      <ci>normal-|</ci>
      <apply>
       <ci>normal-~</ci>
       <ci>μ</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <minus></minus>
    <ln></ln>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>normal-⋅</ci>
      <ci>normal-,</ci>
      <ci>normal-⋅</ci>
      <ci>normal-|</ci>
      <apply>
       <ci>normal-~</ci>
       <ci>μ</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <ci>normal-|</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>normal-⋅</ci>
      <ci>normal-,</ci>
      <ci>normal-⋅</ci>
      <ci>normal-|</ci>
      <apply>
       <ci>normal-~</ci>
       <ci>s</ci>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">m</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\tilde{s},\tilde{\mu})=E_{q}[G(\tilde{s},\cdot,\cdot)]-H[q(\cdot,\cdot|%
\tilde{\mu})]=-\ln p(\tilde{s}|m)+D_{KL}[q(\cdot,\cdot|\tilde{\mu})||p(\cdot,%
\cdot|\tilde{s},m)]
  </annotation>
 </semantics>
</math>

</p>

<p>The second equality shows that minimizing variational free energy (i) minimizes the <a href="Kullback–Leibler_divergence" title="wikilink">Kullback-Leibler divergence</a> between the variational and true posterior density and (ii) renders the variational free energy (a bound approximation to) the negative log evidence (because the divergence can never be less than zero).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Under the Laplace assumption 

<math display="inline" id="Generalized_filtering:16">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>μ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>μ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>u</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>μ</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">N</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>μ</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(\tilde{x},\tilde{{u}}|\tilde{\mu})=\mathcal{N}(\tilde{\mu},C)
  </annotation>
 </semantics>
</math>

 the variational density is Gaussian and the precision that minimizes free energy is 

<math display="inline" id="Generalized_filtering:17">
 <semantics>
  <mrow>
   <msup>
    <mi>C</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mi mathvariant="normal">Π</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo>∂</mo>
      <mrow>
       <mover accent="true">
        <mi>μ</mi>
        <mo stretchy="false">~</mo>
       </mover>
       <mover accent="true">
        <mi>μ</mi>
        <mo stretchy="false">~</mo>
       </mover>
      </mrow>
     </msub>
     <mi>G</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>μ</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-Π</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <partialdiff></partialdiff>
        <apply>
         <times></times>
         <apply>
          <ci>normal-~</ci>
          <ci>μ</ci>
         </apply>
         <apply>
          <ci>normal-~</ci>
          <ci>μ</ci>
         </apply>
        </apply>
       </apply>
       <ci>G</ci>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>μ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{-1}=\Pi=\partial_{\tilde{\mu}\tilde{\mu}}G(\tilde{\mu})
  </annotation>
 </semantics>
</math>

. This means that free-energy can be expressed in terms of the variational mean <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> (omitting constants):</p>

<p>

<math display="block" id="Generalized_filtering:18">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>μ</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mstyle displaystyle="false">
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mstyle>
     <mrow>
      <mi>ln</mi>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mrow>
         <msub>
          <mo>∂</mo>
          <mrow>
           <mover accent="true">
            <mi>μ</mi>
            <mo stretchy="false">~</mo>
           </mover>
           <mover accent="true">
            <mi>μ</mi>
            <mo stretchy="false">~</mo>
           </mover>
          </mrow>
         </msub>
         <mi>G</mi>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mover accent="true">
          <mi>μ</mi>
          <mo stretchy="false">~</mo>
         </mover>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>G</ci>
      <apply>
       <ci>normal-~</ci>
       <ci>μ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <ln></ln>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <partialdiff></partialdiff>
           <apply>
            <times></times>
            <apply>
             <ci>normal-~</ci>
             <ci>μ</ci>
            </apply>
            <apply>
             <ci>normal-~</ci>
             <ci>μ</ci>
            </apply>
           </apply>
          </apply>
          <ci>G</ci>
         </apply>
         <apply>
          <ci>normal-~</ci>
          <ci>μ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=G(\tilde{\mu})+\textstyle{1\over 2}\ln|\partial_{\tilde{\mu}\tilde{\mu}}G(%
\tilde{\mu})|
  </annotation>
 </semantics>
</math>

</p>

<p>The variational means that minimize the (path integral) of free energy can now be recovered by solving the generalized filter:</p>

<p>

<math display="block" id="Generalized_filtering:19">
 <semantics>
  <mrow>
   <mover accent="true">
    <mover accent="true">
     <mi>μ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mover accent="true">
      <mi>μ</mi>
      <mo stretchy="false">~</mo>
     </mover>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <msub>
       <mo>∂</mo>
       <mover accent="true">
        <mi>μ</mi>
        <mo stretchy="false">~</mo>
       </mover>
      </msub>
      <mi>F</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>s</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mo>,</mo>
      <mover accent="true">
       <mi>μ</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-˙</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>μ</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <ci>normal-~</ci>
       <ci>μ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <partialdiff></partialdiff>
        <apply>
         <ci>normal-~</ci>
         <ci>μ</ci>
        </apply>
       </apply>
       <ci>F</ci>
      </apply>
      <interval closure="open">
       <apply>
        <ci>normal-~</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <ci>normal-~</ci>
        <ci>μ</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\tilde{\mu}}=D\tilde{\mu}-\partial_{\tilde{\mu}}F(\tilde{s},\tilde{\mu})
  </annotation>
 </semantics>
</math>

</p>

<p>where,

<math display="inline" id="Generalized_filtering:20">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is a block matrix derivative operator of identify matrices such that 

<math display="inline" id="Generalized_filtering:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">~</mo>
    </mover>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <msup>
      <mi>u</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <msup>
      <mi>u</mi>
      <mi>′′</mi>
     </msup>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>u</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <ci>′′</ci>
      </apply>
      <ci>normal-…</ci>
     </list>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\tilde{u}=[u^{\prime},u^{\prime\prime},\ldots]^{T}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="variational-basis">Variational basis</h3>

<p>Generalized filtering is based on the following lemma: <em>The self-consistent solution to</em> 

<math display="inline" id="Generalized_filtering:22">
 <semantics>
  <mrow>
   <mover accent="true">
    <mover accent="true">
     <mi>μ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mover accent="true">
      <mi>μ</mi>
      <mo stretchy="false">~</mo>
     </mover>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <msub>
       <mo>∂</mo>
       <mover accent="true">
        <mi>μ</mi>
        <mo stretchy="false">~</mo>
       </mover>
      </msub>
      <mi>F</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mover accent="true">
       <mi>μ</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-˙</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>μ</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <ci>normal-~</ci>
       <ci>μ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <partialdiff></partialdiff>
        <apply>
         <ci>normal-~</ci>
         <ci>μ</ci>
        </apply>
       </apply>
       <ci>F</ci>
      </apply>
      <interval closure="open">
       <ci>s</ci>
       <apply>
        <ci>normal-~</ci>
        <ci>μ</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\tilde{\mu}}=D\tilde{\mu}-\partial_{\tilde{\mu}}F(s,\tilde{\mu})
  </annotation>
 </semantics>
</math>

 <em>satisfies the variational <a href="Principle_of_least_action" title="wikilink">principle of stationary action</a>, where action is the path integral of variational free energy</em></p>

<p>

<math display="block" id="Generalized_filtering:23">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mi>d</mi>
     <mpadded width="+1.7pt">
      <mi>t</mi>
     </mpadded>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mover accent="true">
        <mi>s</mi>
        <mo stretchy="false">~</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mover accent="true">
        <mi>μ</mi>
        <mo stretchy="false">~</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>t</ci>
      <ci>F</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <apply>
         <ci>normal-~</ci>
         <ci>s</ci>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-~</ci>
         <ci>μ</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\int dt\,F(\tilde{s}(t),\tilde{\mu}(t))
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Proof</strong>: self-consistency requires the motion of the mean to be the mean of the motion and (by the <a href="Fundamental_lemma_of_calculus_of_variations" title="wikilink">fundamental lemma of variational calculus</a>)</p>

<p>

<math display="block" id="Generalized_filtering:24">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mover accent="true">
      <mi>μ</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo>˙</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <mi>D</mi>
     <mover accent="true">
      <mi>μ</mi>
      <mo stretchy="false">~</mo>
     </mover>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mo>∂</mo>
       <mover accent="true">
        <mi>μ</mi>
        <mo stretchy="false">~</mo>
       </mover>
      </msub>
      <mi>F</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>s</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mo>,</mo>
      <mover accent="true">
       <mi>μ</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>δ</mi>
      <mover accent="true">
       <mi>μ</mi>
       <mo stretchy="false">~</mo>
      </mover>
     </msub>
     <mi>S</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇔</ci>
     <apply>
      <eq></eq>
      <apply>
       <ci>normal-˙</ci>
       <apply>
        <ci>normal-~</ci>
        <ci>μ</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>D</ci>
       <apply>
        <ci>normal-~</ci>
        <ci>μ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <partialdiff></partialdiff>
         <apply>
          <ci>normal-~</ci>
          <ci>μ</ci>
         </apply>
        </apply>
        <ci>F</ci>
       </apply>
       <interval closure="open">
        <apply>
         <ci>normal-~</ci>
         <ci>s</ci>
        </apply>
        <apply>
         <ci>normal-~</ci>
         <ci>μ</ci>
        </apply>
       </interval>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇔</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>δ</ci>
        <apply>
         <ci>normal-~</ci>
         <ci>μ</ci>
        </apply>
       </apply>
       <ci>S</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\tilde{\mu}}=D\tilde{\mu}\Leftrightarrow\partial_{\tilde{\mu}}F(\tilde{s}%
,\tilde{\mu})=0\Leftrightarrow\delta_{\tilde{\mu}}S=0
  </annotation>
 </semantics>
</math>

</p>

<p>Put simply, small perturbations to the path of the mean do not change variational free energy and it has the least action of all possible (local) paths.</p>

<p><strong>Remarks</strong>: Heuristically, generalized filtering performs a gradient descent on variational free energy in a moving frame of reference

<math display="block" id="Generalized_filtering:25">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mrow>
      <mover accent="true">
       <mo stretchy="false">|</mo>
       <mo stretchy="false">~</mo>
      </mover>
      <mi>μ</mi>
     </mrow>
     <mo>˙</mo>
    </mover>
    <mo>-</mo>
    <mrow>
     <mi>D</mi>
     <mover accent="true">
      <mi>μ</mi>
      <mo stretchy="false">~</mo>
     </mover>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <msub>
       <mo>∂</mo>
       <mover accent="true">
        <mi>μ</mi>
        <mo stretchy="false">~</mo>
       </mover>
      </msub>
      <mi>F</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mover accent="true">
       <mi>μ</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-˙</ci>
      <apply>
       <times></times>
       <apply>
        <ci>normal-~</ci>
        <ci>normal-|</ci>
       </apply>
       <ci>μ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <ci>normal-~</ci>
       <ci>μ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <partialdiff></partialdiff>
        <apply>
         <ci>normal-~</ci>
         <ci>μ</ci>
        </apply>
       </apply>
       <ci>F</ci>
      </apply>
      <interval closure="open">
       <ci>s</ci>
       <apply>
        <ci>normal-~</ci>
        <ci>μ</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{{\tilde{|}{{\mu}}}}-D\tilde{{\mu}}=-\partial_{\tilde{\mu}}F(s,\tilde{\mu})
  </annotation>
 </semantics>
</math>

, where the frame itself minimizes variational free energy. For a related example in statistical physics, see Kerr and Graham <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> who use ensemble dynamics in generalized coordinates to provide a generalized phase-space version of Langevin and associated Fokker-Planck equations.</p>

<p>In practice, generalized filtering uses <a href="Linearization" title="wikilink">local linearization</a> <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> over intervals 

<math display="inline" id="Generalized_filtering:26">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

 to recover discrete updates</p>

<p>

<math display="inline" id="Generalized_filtering:27">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mover accent="true">
    <mi>μ</mi>
    <mo stretchy="false">~</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <apply>
     <ci>normal-~</ci>
     <ci>μ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\Delta\tilde{\mu}
  </annotation>
 </semantics>
</math>


</p>

<p>This updates the means of hidden variables at each interval (usually the interval between observations).</p>
<h2 id="generative-state-space-models-in-generalized-coordinates">Generative (state-space) models in generalized coordinates</h2>

<p>Usually, the generative density or model is specified in terms of a nonlinear input-state-output model with continuous nonlinear functions:</p>

<p>

<math display="inline" id="Generalized_filtering:28">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle s
  </annotation>
 </semantics>
</math>


</p>

<p>The corresponding generalized model (under local linearity assumptions) obtains the from the chain rule</p>

<p>

<math display="block" id="Generalized_filtering:29">
 <semantics>
  <mrow>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="right">
      <mover accent="true">
       <mi>s</mi>
       <mo stretchy="false">~</mo>
      </mover>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mover accent="true">
          <mi>g</mi>
          <mo stretchy="false">~</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>x</mi>
           <mo stretchy="false">~</mo>
          </mover>
          <mo>,</mo>
          <mover accent="true">
           <mi>u</mi>
           <mo stretchy="false">~</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <msub>
         <mover accent="true">
          <mi>ω</mi>
          <mo stretchy="false">~</mo>
         </mover>
         <mi>s</mi>
        </msub>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="right">
      <mi>s</mi>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>u</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <msub>
         <mi>ω</mi>
         <mi>s</mi>
        </msub>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="right">
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <msub>
          <mo>∂</mo>
          <mi>x</mi>
         </msub>
         <mrow>
          <mi>g</mi>
          <mo>⋅</mo>
          <msup>
           <mi>x</mi>
           <mo>′</mo>
          </msup>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mo>∂</mo>
          <mi>u</mi>
         </msub>
         <mrow>
          <mi>g</mi>
          <mo>⋅</mo>
          <msup>
           <mi>u</mi>
           <mo>′</mo>
          </msup>
         </mrow>
        </mrow>
        <mo>+</mo>
        <msubsup>
         <mi>ω</mi>
         <mi>x</mi>
         <mo>′</mo>
        </msubsup>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="right">
      <msup>
       <mi>s</mi>
       <mi>′′</mi>
      </msup>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <msub>
          <mo>∂</mo>
          <mi>x</mi>
         </msub>
         <mrow>
          <mi>g</mi>
          <mo>⋅</mo>
          <msup>
           <mi>x</mi>
           <mi>′′</mi>
          </msup>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mo>∂</mo>
          <mi>u</mi>
         </msub>
         <mrow>
          <mi>g</mi>
          <mo>⋅</mo>
          <msup>
           <mi>u</mi>
           <mi>′′</mi>
          </msup>
         </mrow>
        </mrow>
        <mo>+</mo>
        <msubsup>
         <mi>ω</mi>
         <mi>x</mi>
         <mi>′′</mi>
        </msubsup>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd></mtd>
     <mtd columnalign="left">
      <mi mathvariant="normal">⋮</mi>
     </mtd>
    </mtr>
   </mtable>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="right">
      <mover accent="true">
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">~</mo>
       </mover>
       <mo>˙</mo>
      </mover>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mover accent="true">
          <mi>f</mi>
          <mo stretchy="false">~</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>x</mi>
           <mo stretchy="false">~</mo>
          </mover>
          <mo>,</mo>
          <mover accent="true">
           <mi>u</mi>
           <mo stretchy="false">~</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <msub>
         <mover accent="true">
          <mi>ω</mi>
          <mo stretchy="false">~</mo>
         </mover>
         <mi>x</mi>
        </msub>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="right">
      <mover accent="true">
       <mi>x</mi>
       <mo>˙</mo>
      </mover>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>u</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <msub>
         <mi>ω</mi>
         <mi>x</mi>
        </msub>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="right">
      <msup>
       <mover accent="true">
        <mi>x</mi>
        <mo>˙</mo>
       </mover>
       <mo>′</mo>
      </msup>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <msub>
          <mo>∂</mo>
          <mi>x</mi>
         </msub>
         <mrow>
          <mi>f</mi>
          <mo>⋅</mo>
          <msup>
           <mi>x</mi>
           <mo>′</mo>
          </msup>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mo>∂</mo>
          <mi>u</mi>
         </msub>
         <mrow>
          <mi>f</mi>
          <mo>⋅</mo>
          <msup>
           <mi>u</mi>
           <mo>′</mo>
          </msup>
         </mrow>
        </mrow>
        <mo>+</mo>
        <msubsup>
         <mi>ω</mi>
         <mi>x</mi>
         <mo>′</mo>
        </msubsup>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="right">
      <msup>
       <mover accent="true">
        <mi>x</mi>
        <mo>˙</mo>
       </mover>
       <mi>′′</mi>
      </msup>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <msub>
          <mo>∂</mo>
          <mi>x</mi>
         </msub>
         <mrow>
          <mi>f</mi>
          <mo>⋅</mo>
          <msup>
           <mi>x</mi>
           <mi>′′</mi>
          </msup>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mo>∂</mo>
          <mi>u</mi>
         </msub>
         <mrow>
          <mi>f</mi>
          <mo>⋅</mo>
          <msup>
           <mi>u</mi>
           <mi>′′</mi>
          </msup>
         </mrow>
        </mrow>
        <mo>+</mo>
        <msubsup>
         <mi>ω</mi>
         <mi>x</mi>
         <mi>′′</mi>
        </msubsup>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd></mtd>
     <mtd columnalign="left">
      <mi mathvariant="normal">⋮</mi>
     </mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <matrix>
     <matrixrow>
      <apply>
       <ci>normal-~</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <eq></eq>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <ci>normal-~</ci>
          <ci>g</ci>
         </apply>
         <interval closure="open">
          <apply>
           <ci>normal-~</ci>
           <ci>x</ci>
          </apply>
          <apply>
           <ci>normal-~</ci>
           <ci>u</ci>
          </apply>
         </interval>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-~</ci>
          <ci>ω</ci>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cerror>
       <csymbol cd="ambiguous">missing-subexpression</csymbol>
      </cerror>
     </matrixrow>
     <matrixrow>
      <ci>s</ci>
      <apply>
       <eq></eq>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>g</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>u</ci>
         </interval>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <eq></eq>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <partialdiff></partialdiff>
          <ci>x</ci>
         </apply>
         <apply>
          <ci>normal-⋅</ci>
          <ci>g</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <ci>normal-′</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <partialdiff></partialdiff>
          <ci>u</ci>
         </apply>
         <apply>
          <ci>normal-⋅</ci>
          <ci>g</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>u</ci>
           <ci>normal-′</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ω</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>′′</ci>
      </apply>
      <apply>
       <eq></eq>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <partialdiff></partialdiff>
          <ci>x</ci>
         </apply>
         <apply>
          <ci>normal-⋅</ci>
          <ci>g</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <ci>′′</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <partialdiff></partialdiff>
          <ci>u</ci>
         </apply>
         <apply>
          <ci>normal-⋅</ci>
          <ci>g</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>u</ci>
           <ci>′′</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ω</ci>
          <ci>′′</ci>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cerror>
       <csymbol cd="ambiguous">missing-subexpression</csymbol>
      </cerror>
      <ci>normal-⋮</ci>
     </matrixrow>
    </matrix>
    <matrix>
     <matrixrow>
      <apply>
       <ci>normal-˙</ci>
       <apply>
        <ci>normal-~</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <ci>normal-~</ci>
          <ci>f</ci>
         </apply>
         <interval closure="open">
          <apply>
           <ci>normal-~</ci>
           <ci>x</ci>
          </apply>
          <apply>
           <ci>normal-~</ci>
           <ci>u</ci>
          </apply>
         </interval>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-~</ci>
          <ci>ω</ci>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cerror>
       <csymbol cd="ambiguous">missing-subexpression</csymbol>
      </cerror>
     </matrixrow>
     <matrixrow>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <eq></eq>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>f</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>u</ci>
         </interval>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <eq></eq>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <partialdiff></partialdiff>
          <ci>x</ci>
         </apply>
         <apply>
          <ci>normal-⋅</ci>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <ci>normal-′</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <partialdiff></partialdiff>
          <ci>u</ci>
         </apply>
         <apply>
          <ci>normal-⋅</ci>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>u</ci>
           <ci>normal-′</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ω</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <ci>′′</ci>
      </apply>
      <apply>
       <eq></eq>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <partialdiff></partialdiff>
          <ci>x</ci>
         </apply>
         <apply>
          <ci>normal-⋅</ci>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <ci>′′</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <partialdiff></partialdiff>
          <ci>u</ci>
         </apply>
         <apply>
          <ci>normal-⋅</ci>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>u</ci>
           <ci>′′</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ω</ci>
          <ci>′′</ci>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cerror>
       <csymbol cd="ambiguous">missing-subexpression</csymbol>
      </cerror>
      <ci>normal-⋮</ci>
     </matrixrow>
    </matrix>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle\tilde{s}&\displaystyle=\tilde{g}(\tilde{x},\tilde%
{u})+\tilde{\omega}_{s}\\
\\
\displaystyle s&\displaystyle=g(x,u)+\omega_{s}\\
\displaystyle s^{\prime}&\displaystyle=\partial_{x}g\cdot x^{\prime}+\partial_%
{u}g\cdot u^{\prime}+\omega^{\prime}_{x}\\
\displaystyle s^{\prime\prime}&\displaystyle=\partial_{x}g\cdot x^{\prime%
\prime}+\partial_{u}g\cdot u^{\prime\prime}+\omega^{\prime\prime}_{x}\\
&\displaystyle\vdots\\
\end{aligned}\qquad\begin{aligned}\displaystyle\dot{\tilde{x}}&\displaystyle=%
\tilde{f}(\tilde{x},\tilde{u})+\tilde{\omega}_{x}\\
\\
\displaystyle\dot{x}&\displaystyle=f(x,u)+\omega_{x}\\
\displaystyle\dot{x}^{\prime}&\displaystyle=\partial_{x}f\cdot x^{\prime}+%
\partial_{u}f\cdot u^{\prime}+\omega^{\prime}_{x}\\
\displaystyle\dot{x}^{\prime\prime}&\displaystyle=\partial_{x}f\cdot x^{\prime%
\prime}+\partial_{u}f\cdot u^{\prime\prime}+\omega^{\prime\prime}_{x}\\
&\displaystyle\vdots\end{aligned}
  </annotation>
 </semantics>
</math>

</p>

<p>Gaussian assumptions about the random fluctuations 

<math display="inline" id="Generalized_filtering:30">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

 then prescribe the likelihood and empirical priors on the motion of hidden states</p>

<p>

<math display="inline" id="Generalized_filtering:31">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo>(</mo>
    <mover accent="true">
     <mi>s</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo stretchy="false">|</mo>
    <mi>m</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>u</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle p\left(\tilde{s},\tilde{x},\tilde{u}|m\right)
  </annotation>
 </semantics>
</math>


</p>

<p>The covariances 

<math display="inline" id="Generalized_filtering:32">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi mathvariant="normal">Σ</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mo>⊗</mo>
    <mi mathvariant="normal">Σ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>normal-Σ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>V</ci>
     <ci>normal-Σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{{\Sigma}}=V\otimes\Sigma
  </annotation>
 </semantics>
</math>

 factorize into a covariance among variables and correlations 

<math display="inline" id="Generalized_filtering:33">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 among generalized fluctuations that encodes their <a class="uri" href="autocorrelation" title="wikilink">autocorrelation</a>:</p>

<p>

<math display="block" id="Generalized_filtering:34">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mover accent="true">
         <mi>ρ</mi>
         <mo>¨</mo>
        </mover>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>0</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋯</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mrow>
         <mover accent="true">
          <mi>ρ</mi>
          <mo>¨</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>0</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mover accent="true">
         <mi>ρ</mi>
         <mo>¨</mo>
        </mover>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>0</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mover accent="true">
         <mover accent="true">
          <mi>ρ</mi>
          <mo>¨</mo>
         </mover>
         <mo>¨</mo>
        </mover>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>0</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋱</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <apply>
       <times></times>
       <apply>
        <ci>normal-¨</ci>
        <ci>ρ</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-⋯</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <ci>normal-¨</ci>
         <ci>ρ</ci>
        </apply>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <cn type="integer">0</cn>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <apply>
        <ci>normal-¨</ci>
        <ci>ρ</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">0</cn>
      <apply>
       <times></times>
       <apply>
        <ci>normal-¨</ci>
        <apply>
         <ci>normal-¨</ci>
         <ci>ρ</ci>
        </apply>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-⋱</ci>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=\begin{bmatrix}1&0&\ddot{\rho}(0)&\cdots\\
0&-\ddot{\rho}(0)&0&\\
\ddot{\rho}(0)&0&\ddot{\ddot{\rho}}(0)&\\
\vdots&&&\ddots\\
\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Here, 

<math display="inline" id="Generalized_filtering:35">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>ρ</mi>
    <mo>¨</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¨</ci>
     <ci>ρ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ddot{{\rho}}(0)
  </annotation>
 </semantics>
</math>

 is the second derivative of the autocorrelation function evaluated at zero. This is a ubiquitous measure of roughness in the theory of <a href="stochastic_processes" title="wikilink">stochastic processes</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Crucially, the precision (inverse variance) of high order derivatives fall to zero fairly quickly, which means it is only necessary to model relatively low order generalized motion (usually between two and eight) for any given or parameterized autocorrelation function.</p>
<h2 id="special-cases">Special cases</h2>
<h3 id="filtering-discrete-time-series">Filtering discrete time series</h3>

<p>When time series are observed as a discrete sequence of 

<math display="inline" id="Generalized_filtering:36">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 observations, the implicit sampling is treated as part of the generative process, where (using <a href="Taylor's_theorem" title="wikilink">Taylor's theorem</a>)</p>

<p>

<math display="block" id="Generalized_filtering:37">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>s</mi>
      <mi>N</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>T</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo>⊗</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mover accent="true">
    <mi>s</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <msub>
    <mi>E</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>j</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>j</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-…</ci>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>N</ci>
      </apply>
      <ci>normal-]</ci>
     </cerror>
     <ci>T</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">E</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <apply>
     <ci>normal-~</ci>
     <ci>s</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>italic-</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <factorial></factorial>
      <apply>
       <minus></minus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [s_{1},\dots,s_{N}]^{T}=(E\otimes I)\cdot\tilde{s}(t):\qquad E_{ij}=\frac{(i-t%
)^{(j-1)}}{(j-1)!}
  </annotation>
 </semantics>
</math>

</p>

<p>In principle, the entire sequence could be used to estimate hidden variables at each point in time. However, the precision of samples in the past and future falls quickly and can be ignored. This allows the scheme to assimilate data online, using local observations around each time point (typically between and eight).</p>
<h3 id="generalized-filtering-and-model-parameters">Generalized filtering and model parameters</h3>

<p>For any slowly varying model parameters of the equations of motion 

<math display="inline" id="Generalized_filtering:38">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <ci>x</ci>
     <ci>u</ci>
     <ci>θ</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,u,\theta)
  </annotation>
 </semantics>
</math>

 or precision 

<math display="inline" id="Generalized_filtering:39">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi mathvariant="normal">Π</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-~</ci>
     <ci>normal-Π</ci>
    </apply>
    <vector>
     <ci>x</ci>
     <ci>u</ci>
     <ci>θ</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{{\Pi}}(x,u,\theta)
  </annotation>
 </semantics>
</math>

 generalized filtering takes the following form (where 

<math display="inline" id="Generalized_filtering:40">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 corresponds to the variational mean of the parameters)</p>

<p>

<math display="inline" id="Generalized_filtering:41">
 <semantics>
  <mover accent="true">
   <mi>μ</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>μ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\dot{\mu}
  </annotation>
 </semantics>
</math>


</p>

<p>Here, the solution 

<math display="inline" id="Generalized_filtering:42">
 <semantics>
  <mrow>
   <mover accent="true">
    <mrow>
     <mover accent="true">
      <mo stretchy="false">|</mo>
      <mo stretchy="false">~</mo>
     </mover>
     <mi>μ</mi>
    </mrow>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-˙</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-~</ci>
       <ci>normal-|</ci>
      </apply>
      <ci>μ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{{\tilde{|}{{\mu}}}}=0
  </annotation>
 </semantics>
</math>


 minimizes variational free energy, when the motion of the mean is small. This can be seen by noting 

<math display="inline" id="Generalized_filtering:43">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>μ</mi>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <msup>
    <mover accent="true">
     <mi>μ</mi>
     <mo>˙</mo>
    </mover>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mn>0</mn>
   <mo>⇒</mo>
   <mrow>
    <msub>
     <mo>∂</mo>
     <mi>μ</mi>
    </msub>
    <mi>F</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
   <mo>⇒</mo>
   <mrow>
    <msub>
     <mi>δ</mi>
     <mi>μ</mi>
    </msub>
    <mi>S</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-˙</ci>
      <ci>μ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-˙</ci>
       <ci>μ</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <ci>μ</ci>
      </apply>
      <ci>F</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>δ</ci>
       <ci>μ</ci>
      </apply>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{{\mu}}={\dot{{\mu}}}^{\prime}=0\Rightarrow\partial_{\mu}F=0\Rightarrow%
\delta_{\mu}S=0
  </annotation>
 </semantics>
</math>

. It is straightforward to show that this solution corresponds to a classical <a href="Newton's_method_in_optimization" title="wikilink">Newton update</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="relationship-to-bayesian-filtering-and-predictive-coding">Relationship to Bayesian filtering and predictive coding</h2>
<h3 id="generalized-filtering-and-kalman-filtering">Generalized filtering and Kalman filtering</h3>

<p>Classical filtering under Markovian or Wiener assumptions is equivalent to assuming the precision of the motion of random fluctuations is zero. In this limiting case, one only has to consider the states and their first derivative 

<math display="inline" id="Generalized_filtering:44">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>μ</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>μ</mi>
    <mo>,</mo>
    <msup>
     <mi>μ</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>μ</ci>
    </apply>
    <interval closure="open">
     <ci>μ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>μ</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{{\mu}}=(\mu,{\mu}^{\prime})
  </annotation>
 </semantics>
</math>

. This means generalized filtering takes the form of a Kalman-Bucy filter, with prediction and correction terms:</p>

<p>

<math display="inline" id="Generalized_filtering:45">
 <semantics>
  <mover accent="true">
   <mi>μ</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>μ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\dot{\mu}
  </annotation>
 </semantics>
</math>


</p>

<p>Substituting this first-order filtering into the discrete update scheme above gives the equivalent of (extended) Kalman filtering.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="generalized-filtering-and-particle-filtering">Generalized filtering and particle filtering</h3>

<p><a href="Particle_filter" title="wikilink">Particle filtering</a> is a sampling-based scheme that relaxes assumptions about the form of the variational or approximate posterior density. The corresponding generalized filtering scheme is called <strong>variational filtering</strong>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> In variational filtering, an ensemble of particles diffuse over the free energy landscape in a frame of reference that moves with the expected (generalized) motion of the ensemble. This provides a relatively simple scheme that eschews Gaussian (unimodal) assumptions. Unlike particle filtering it does not require proposal densities—or the elimination or creation of particles.</p>
<h3 id="generalized-filtering-and-variational-bayes">Generalized filtering and variational Bayes</h3>

<p><a href="Variational_Bayesian_methods" title="wikilink">Variational Bayes</a> rests on a mean field partition of the variational density:</p>

<p>

<math display="block" id="Generalized_filtering:46">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mi>θ</mi>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>μ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mi>μ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>μ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">|</mo>
    <mi>μ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>u</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-…</ci>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>μ</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">μ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>u</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>μ</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">μ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-…</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(\tilde{x},\tilde{u},\theta\dots|\tilde{\mu},\mu)=q(\tilde{x},\tilde{u}|%
\tilde{\mu})q(\theta|\mu)\dots
  </annotation>
 </semantics>
</math>

</p>

<p>This partition induces a variational update or step for each marginal density—that is usually solved analytically using conjugate priors. In generalized filtering, this leads to <strong>dynamic expectation maximisation</strong>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> that comprises a D-step that optimizes the sufficient statistics of unknown states, an E-step for parameters and an M-step for precisions.</p>
<h3 id="generalized-filtering-and-predictive-coding">Generalized filtering and predictive coding</h3>

<p>Generalized filtering is usually used to invert hierarchical models of the following form</p>

<p>

<math display="inline" id="Generalized_filtering:47">
 <semantics>
  <mover accent="true">
   <mi>s</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\tilde{s}
  </annotation>
 </semantics>
</math>


</p>

<p>The ensuing generalized gradient descent on free energy can then be expressed compactly in terms of prediction errors, where (omitting high order terms):</p>

<p>

<math display="inline" id="Generalized_filtering:48">
 <semantics>
  <msubsup>
   <mover accent="true">
    <mover accent="true">
     <mi>μ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>˙</mo>
   </mover>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-˙</ci>
      <apply>
       <ci>normal-~</ci>
       <ci>μ</ci>
      </apply>
     </apply>
     <ci>u</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\dot{\tilde{\mu}}_{u}^{(i)}
  </annotation>
 </semantics>
</math>


</p>

<p>Here, 

<math display="inline" id="Generalized_filtering:49">
 <semantics>
  <msup>
   <mi mathvariant="normal">Π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Π</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{(i)}
  </annotation>
 </semantics>
</math>

 is the precision of random fluctuations at the <em>i</em>-th level. This is known as generalized predictive coding [11], with <a href="linear_predictive_coding" title="wikilink">linear predictive coding</a> as a special case.</p>
<h2 id="applications">Applications</h2>

<p>Generalized filtering has been primarily applied to biological timeseries—in particular functional magnetic resonance imaging and electrophysiological data. This is usually in the context of <a href="dynamic_causal_modelling" title="wikilink">dynamic causal modelling</a> to make inferences about the underlying architectures of (neuronal) systems generating data.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> It is also used to simulate inference in terms of generalized (hierarchical) predictive coding in the brain.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Dynamic_Bayesian_network" title="wikilink">Dynamic Bayesian network</a></li>
<li><a href="Kalman_filter" title="wikilink">Kalman filter</a></li>
<li><a href="Linear_predictive_coding" title="wikilink">Linear predictive coding</a></li>
<li><a href="Optimal_control" title="wikilink">Optimal control</a></li>
<li><a href="Particle_filter" title="wikilink">Particle filter</a></li>
<li><a href="Recursive_Bayesian_estimation" title="wikilink">Recursive Bayesian estimation</a></li>
<li><a href="System_identification" title="wikilink">System identification</a></li>
<li><a href="Variational_Bayesian_methods" title="wikilink">Variational Bayesian methods</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.fil.ion.ucl.ac.uk/spm/software/">software</a> demonstrations and applications are available as academic freeware (as Matlab code) in the DEM toolbox of SPM</li>
<li><a href="http://www.fil.ion.ucl.ac.uk/~karl/#_Bayesian_and_Variational">papers</a> collection of technical and application papers</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Systems" title="wikilink">Category:Systems</a> <a href="Category:Systems_theory" title="wikilink">Category:Systems theory</a> <a href="Category:Control_theory" title="wikilink">Category:Control theory</a> <a href="Category:Nonlinear_filters" title="wikilink">Category:Nonlinear filters</a> <a href="Category:Linear_filters" title="wikilink">Category:Linear filters</a> <a href="Category:Signal_estimation" title="wikilink">Category:Signal estimation</a> <a href="Category:Stochastic_differential_equations" title="wikilink">Category:Stochastic differential equations</a> <a href="Category:Markov_models" title="wikilink">Category:Markov models</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">B Balaji and K Friston, "<a href="http://www.fil.ion.ucl.ac.uk/~karl/Bayesian%20State%20Estimation%20Using%20Generalized%20Coordinates.pdf">Bayesian state estimation using generalized coordinates</a>," Proc. SPIE, p. 80501Y , 2011<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4">R P Feynman, Statistical mechanics. Reading MA: Benjamin, 1972<a href="#fnref4">↩</a></li>
<li id="fn5">M J Beal, "<a href="http://www.cse.buffalo.edu/faculty/mbeal/papers/beal03.pdf">Variational Algorithms for Approximate Bayesian Inference</a>," PhD. Thesis, University College London, 2003.<a href="#fnref5">↩</a></li>
<li id="fn6">K Friston, J Mattout, N Trujillo-Barreto, J Ashburner, and W Penny, "<a href="http://www.fil.ion.ucl.ac.uk/~karl/Variational%20free%20energy%20and%20the%20Laplace%20approximation.pdf">Variational free energy and the Laplace approximation</a>," NeuroImage, vol. 34, no. 1, pp. 220-34, 2007<a href="#fnref6">↩</a></li>
<li id="fn7">W C Kerr and A J Graham, "<a href="http://epjb.epj.org/articles/epjb/abs/2000/10/b9689/b9689.html">Generalised phase space version of Langevin equations and associated Fokker-Planck equations</a>," Eur. Phys. J. B., vol. 15, pp. 305-11, 2000.<a href="#fnref7">↩</a></li>
<li id="fn8">T Ozaki, "<a href="http://www3.stat.sinica.edu.tw/statistica/oldpdf/A2n16.pdf">A bridge between nonlinear time-series models and nonlinear stochastic dynamical systems: A local linearization approach</a>," Statistica Sin., vol. 2, pp. 113-135, 1992<a href="#fnref8">↩</a></li>
<li id="fn9">D R Cox and H D Miller, The theory of stochastic processes. London: Methuen, 1965.<a href="#fnref9">↩</a></li>
<li id="fn10">K Friston, K Stephan, B Li, and J. Daunizeau, "Generalised Filtering," Mathematical Problems in Engineering, vol. vol., 2010, p. 621670, 2010.<a href="#fnref10">↩</a></li>
<li id="fn11">K J Friston, N Trujillo-Barreto, and J Daunizeau, "DEM: A variational treatment of dynamic systems," Neuroimage, vol. 41, no. 3, pp. 849-85, 2008<a href="#fnref11">↩</a></li>
<li id="fn12">K J Friston, "<a href="http://www.fil.ion.ucl.ac.uk/~karl/Variational%20filtering.pdf">Variational filtering</a>," Neuroimage, vol. 41, no. 3, pp. 747-66, 2008.<a href="#fnref12">↩</a></li>
<li id="fn13">K J Friston, N Trujillo-Barreto, and J Daunizeau, "<a href="http://www.fil.ion.ucl.ac.uk/~karl/DEM%20A%20variational%20treatment%20of%20dynamic%20systems.pdf">DEM: A variational treatment of dynamic systems</a>," Neuroimage, vol. 41, no. 3, pp. 849-85, 2008<a href="#fnref13">↩</a></li>
<li id="fn14">J Daunizeau, O David, and K E Stephan, "<a href="http://www.fil.ion.ucl.ac.uk/~jdaunize/publications/dcm_review.pdf">Dynamic causal modelling: a critical review of the biophysical and statistical foundations</a>," Neuroimage, vol. 58, no. 2, pp. 312-22, 2011<a href="#fnref14">↩</a></li>
<li id="fn15">K Friston, "<a href="http://www.fil.ion.ucl.ac.uk/~karl/Hierarchical%20Models%20in%20the%20Brain.pdf">Hierarchical models in the brain</a>," PLoS Comput Biol., vol. 4, no. 11, p. e1000211, 2008.<a href="#fnref15">↩</a></li>
</ol>
</section>
</hr></body>
</html>
