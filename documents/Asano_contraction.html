<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1777">Asano contraction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Asano contraction</h1>
<hr/>

<p>In <a href="complex_analysis" title="wikilink">complex analysis</a>, a discipline in mathematics, and in <a href="statistical_physics" title="wikilink">statistical physics</a>, the <strong>Asano contraction</strong> or <strong>Asano–Ruelle contraction</strong> is a transformation on a separately affine multivariate polynomial. It was first presented in 1970 by Taro Asano to prove the <a href="Lee–Yang_theorem" title="wikilink">Lee–Yang theorem</a> in the <a href="Heisenberg_model_(quantum)" title="wikilink">Heisenberg spin model</a> case. This also yielded a simple proof of the Lee–Yang theorem in the <a href="Ising_model" title="wikilink">Ising model</a>. <a href="David_Ruelle" title="wikilink">David Ruelle</a> proved a general theorem relating the location of the roots of a contracted polynomial to that of the original. Asano contractions have also been used to study polynomials in graph theory.</p>
<h2 id="definition">Definition</h2>

<p>Let 

<math display="inline" id="Asano_contraction:0">
<semantics>
<mrow>
<mi mathvariant="normal">Φ</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>z</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>normal-Φ</ci>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>n</ci>
</apply>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Phi(z_{1},z_{2},\ldots,z_{n})
  </annotation>
</semantics>
</math>

 be a polynomial which, when viewed as a function of only one of these variables is an <a href="linear_equation" title="wikilink">affine function</a>. Such functions are called separately affine. For example, 

<math display="inline" id="Asano_contraction:1">
<semantics>
<mrow>
<mi>a</mi>
<mo>+</mo>
<mrow>
<mi>b</mi>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<mi>c</mi>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<mi>d</mi>
<msub>
<mi>z</mi>
<mn>1</mn>
</msub>
<msub>
<mi>z</mi>
<mn>2</mn>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<ci>a</ci>
<apply>
<times></times>
<ci>b</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<times></times>
<ci>c</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<ci>d</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a+bz_{1}+cz_{2}+dz_{1}z_{2}
  </annotation>
</semantics>
</math>

 is the general form of a separately affine function in two variables. Any separately affine function can be written in terms of any two of its variables as 

<math display="inline" id="Asano_contraction:2">
<semantics>
<mrow>
<mrow>
<mi mathvariant="normal">Φ</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mi>i</mi>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mi>j</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>a</mi>
<mo>+</mo>
<mrow>
<mi>b</mi>
<msub>
<mi>z</mi>
<mi>i</mi>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<mi>c</mi>
<msub>
<mi>z</mi>
<mi>j</mi>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<mi>d</mi>
<msub>
<mi>z</mi>
<mi>i</mi>
</msub>
<msub>
<mi>z</mi>
<mi>j</mi>
</msub>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>normal-Φ</ci>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>j</ci>
</apply>
</interval>
</apply>
<apply>
<plus></plus>
<ci>a</ci>
<apply>
<times></times>
<ci>b</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>c</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>j</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>d</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Phi(z_{i},z_{j})=a+bz_{i}+cz_{j}+dz_{i}z_{j}
  </annotation>
</semantics>
</math>

. The Asano contraction 

<math display="inline" id="Asano_contraction:3">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mi>i</mi>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mi>j</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo>↦</mo>
<mi>z</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">maps-to</csymbol>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>j</ci>
</apply>
</interval>
<ci>z</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (z_{i},z_{j})\mapsto z
  </annotation>
</semantics>
</math>

 sends 

<math display="inline" id="Asano_contraction:4">
<semantics>
<mi mathvariant="normal">Φ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Φ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Phi
  </annotation>
</semantics>
</math>

 to 

<math display="inline" id="Asano_contraction:5">
<semantics>
<mrow>
<mover accent="true">
<mi mathvariant="normal">Φ</mi>
<mo stretchy="false">~</mo>
</mover>
<mo>=</mo>
<mrow>
<mi>a</mi>
<mo>+</mo>
<mrow>
<mi>d</mi>
<mi>z</mi>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ci>normal-~</ci>
<ci>normal-Φ</ci>
</apply>
<apply>
<plus></plus>
<ci>a</ci>
<apply>
<times></times>
<ci>d</ci>
<ci>z</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \tilde{\Phi}=a+dz
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="location-of-zeroes">Location of zeroes</h2>

<p>Asano contractions are often used in the context of theorems about the location of roots. Asano originally used them because they preserve the property of having no roots when all the variables have magnitude greater than 1.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Ruelle provided a more general relationship which allowed the contractions to be used in more applications.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> He showed that if there are <a href="closed_set" title="wikilink">closed sets</a>
<math display="inline" id="Asano_contraction:6">
<semantics>
<mrow>
<msub>
<mi>M</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>M</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>M</mi>
<mi>n</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>n</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   M_{1},M_{2},\ldots,M_{n}
  </annotation>
</semantics>
</math>

 not containing 0 such that 

<math display="inline" id="Asano_contraction:7">
<semantics>
<mi mathvariant="normal">Φ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Φ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Phi
  </annotation>
</semantics>
</math>

 cannot vanish unless 

<math display="inline" id="Asano_contraction:8">
<semantics>
<mrow>
<msub>
<mi>z</mi>
<mi>i</mi>
</msub>
<mo>∈</mo>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z_{i}\in M_{i}
  </annotation>
</semantics>
</math>

 for some index 

<math display="inline" id="Asano_contraction:9">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

, then 

<math display="inline" id="Asano_contraction:10">
<semantics>
<mrow>
<mover accent="true">
<mi mathvariant="normal">Φ</mi>
<mo stretchy="false">~</mo>
</mover>
<mo>=</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mi>j</mi>
</msub>
<mo>,</mo>
<msub>
<mi>z</mi>
<mi>k</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo>↦</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Φ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<ci>normal-~</ci>
<ci>normal-Φ</ci>
</apply>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>j</ci>
</apply>
<ci>normal-,</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>k</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<csymbol cd="latexml">maps-to</csymbol>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">Φ</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \tilde{\Phi}=((z_{j},z_{k})\mapsto z)(\Phi)
  </annotation>
</semantics>
</math>

 can only vanish if 

<math display="inline" id="Asano_contraction:11">
<semantics>
<mrow>
<msub>
<mi>z</mi>
<mi>i</mi>
</msub>
<mo>∈</mo>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z_{i}\in M_{i}
  </annotation>
</semantics>
</math>

 for some index 

<math display="inline" id="Asano_contraction:12">
<semantics>
<mrow>
<mi>i</mi>
<mo>≠</mo>
<mrow>
<mi>k</mi>
<mo>,</mo>
<mi>j</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<neq></neq>
<ci>i</ci>
<list>
<ci>k</ci>
<ci>j</ci>
</list>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   i\neq k,j
  </annotation>
</semantics>
</math>

 or 

<math display="inline" id="Asano_contraction:13">
<semantics>
<mrow>
<mi>z</mi>
<mo>∈</mo>
<mrow>
<mo>-</mo>
<mrow>
<msub>
<mi>M</mi>
<mi>j</mi>
</msub>
<msub>
<mi>M</mi>
<mi>k</mi>
</msub>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>z</ci>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>j</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z\in-M_{j}M_{k}
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Asano_contraction:14">
<semantics>
<mrow>
<mo>-</mo>
<msub>
<mi>M</mi>
<mi>j</mi>
</msub>
<msub>
<mi>M</mi>
<mi>k</mi>
</msub>
<mo>=</mo>
<mrow>
<mo stretchy="false">{</mo>
<mo>-</mo>
<mi>a</mi>
<mi>b</mi>
<mo>;</mo>
<mi>a</mi>
<mo>∈</mo>
<msub>
<mi>M</mi>
<mi>j</mi>
</msub>
<mo>,</mo>
<mi>b</mi>
<mo>∈</mo>
<msub>
<mi>M</mi>
<mi>k</mi>
</msub>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>j</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>k</ci>
</apply>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-{</ci>
<minus></minus>
<csymbol cd="unknown">a</csymbol>
<csymbol cd="unknown">b</csymbol>
<ci>normal-;</ci>
<csymbol cd="unknown">a</csymbol>
<in></in>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>j</ci>
</apply>
<ci>normal-,</ci>
<csymbol cd="unknown">b</csymbol>
<in></in>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>k</ci>
</apply>
<ci>normal-}</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   -M_{j}M_{k}=\{-ab;a\in M_{j},b\in M_{k}\}
  </annotation>
</semantics>
</math>
<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Ruelle and others have used this theorem to relate the zeroes of the partition function to zeroes of the partition function of its subsystems.</p>
<h2 id="use">Use</h2>

<p>Asano contractions can be used in statistical physics to gain information about a system from its subsystems. For example, suppose we have a system with a finite set 

<math display="inline" id="Asano_contraction:15">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

 of particles with <a href="spin_(physics)" title="wikilink">magnetic spin</a> either 1 or -1. For each site, we have a complex variable 

<math display="inline" id="Asano_contraction:16">
<semantics>
<msub>
<mi>z</mi>
<mi>x</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z_{x}
  </annotation>
</semantics>
</math>

 Then we can define a separately affine polynomial 

<math display="inline" id="Asano_contraction:17">
<semantics>
<mrow>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mi mathvariant="normal">Λ</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mrow>
<mi>X</mi>
<mo>⊆</mo>
<mi mathvariant="normal">Λ</mi>
</mrow>
</msub>
<mrow>
<msub>
<mi>c</mi>
<mi>X</mi>
</msub>
<msup>
<mi>z</mi>
<mi>X</mi>
</msup>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>normal-Λ</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<subset></subset>
<ci>X</ci>
<ci>normal-Λ</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>X</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<ci>X</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(z_{\Lambda})=\sum_{X\subseteq\Lambda}c_{X}z^{X}
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Asano_contraction:18">
<semantics>
<mrow>
<msup>
<mi>z</mi>
<mi>X</mi>
</msup>
<mo>=</mo>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∏</mo>
<mrow>
<mi>x</mi>
<mo>∈</mo>
<mi>X</mi>
</mrow>
</msub>
<msub>
<mi>z</mi>
<mi>x</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<ci>X</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">product</csymbol>
<apply>
<in></in>
<ci>x</ci>
<ci>X</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z^{X}=\prod_{x\in X}z_{x}
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Asano_contraction:19">
<semantics>
<mrow>
<msub>
<mi>c</mi>
<mi>X</mi>
</msub>
<mo>=</mo>
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mrow>
<mi>β</mi>
<mi>U</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>X</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>β</ci>
<ci>U</ci>
<ci>X</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   c_{X}=e^{-\beta U(X)}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Asano_contraction:20">
<semantics>
<mrow>
<mi>U</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>X</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>U</ci>
<ci>X</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   U(X)
  </annotation>
</semantics>
</math>

 is the energy of the state where only the sites in 

<math display="inline" id="Asano_contraction:21">
<semantics>
<mi>X</mi>
<annotation-xml encoding="MathML-Content">
<ci>X</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   X
  </annotation>
</semantics>
</math>

 have positive spin. If all the variables are the same, this is the <a href="Partition_function_(statistical_mechanics)" title="wikilink">partition function</a>. Now if 

<math display="inline" id="Asano_contraction:22">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>=</mo>
<mrow>
<msub>
<mi mathvariant="normal">Λ</mi>
<mn>1</mn>
</msub>
<mo>∩</mo>
<msub>
<mi mathvariant="normal">Λ</mi>
<mn>2</mn>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>normal-Λ</ci>
<apply>
<intersect></intersect>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>normal-Λ</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda=\Lambda_{1}\cap\Lambda_{2}
  </annotation>
</semantics>
</math>

, then 

<math display="inline" id="Asano_contraction:23">
<semantics>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<mi mathvariant="normal">Λ</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>normal-Λ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(z_{\Lambda})
  </annotation>
</semantics>
</math>

 is obtained from 

<math display="inline" id="Asano_contraction:24">
<semantics>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<msub>
<mi mathvariant="normal">Λ</mi>
<mn>1</mn>
</msub>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<msub>
<mi mathvariant="normal">Λ</mi>
<mn>2</mn>
</msub>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>normal-Λ</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(z_{\Lambda_{1}})P(z_{\Lambda_{2}})
  </annotation>
</semantics>
</math>

 by contracting the variable attached to identical sites.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This is because the Asano contraction essentially eliminates all terms where the spins at a site are distinct in the 

<math display="inline" id="Asano_contraction:25">
<semantics>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<msub>
<mi mathvariant="normal">Λ</mi>
<mn>1</mn>
</msub>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>normal-Λ</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(z_{\Lambda_{1}})
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Asano_contraction:26">
<semantics>
<mrow>
<mi>P</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>z</mi>
<msub>
<mi mathvariant="normal">Λ</mi>
<mn>2</mn>
</msub>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P(z_{\Lambda_{2}})
  </annotation>
</semantics>
</math>

.</p>

<p>Ruelle has also used Asano contractions to find information about the location of roots of a generalization of <a href="matching_polynomial" title="wikilink">matching polynomials</a> which he calls graph-counting polynomials. He assigns a variable to each edge. For each vertex, he computes a symmetric polynomial in the variables corresponding to the edges incident on that vertex. The symmetric polynomial contains the terms of degree equal to the allowed degree for that node. He then multiplies these symmetric polynomials together and uses Asano contractions to only keep terms where the edge is present at both its endpoints. By using the <a href="Grace–Walsh–Szegő_theorem" title="wikilink">Grace–Walsh–Szegő theorem</a> and intersecting all the sets that can be obtained, Ruelle gives sets containing the roots of several types of these symmetric polynomials. Since the graph-counting polynomial was obtained from these by Asano contractions, most of the remaining work is computing products of these sets.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Functions_and_mappings" title="wikilink">Category:Functions and mappings</a> <a href="Category:Complex_analysis" title="wikilink">Category:Complex analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
