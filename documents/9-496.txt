   Forward–backward algorithm      Forward–backward algorithm  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     The forward–backward algorithm is an inference  algorithm for hidden Markov models which computes the posterior  marginals of all hidden state variables given a sequence of observations/emissions     o   1  :  t    :=    o  1   ,  …  ,   o  t       assign   subscript  o   normal-:  1  t      subscript  o  1   normal-…   subscript  o  t      o_{1:t}:=o_{1},\dots,o_{t}   , i.e. it computes, for all hidden state variables     X  k   ∈   {   X  1   ,  …  ,   X  t   }        subscript  X  k     subscript  X  1   normal-…   subscript  X  t      X_{k}\in\{X_{1},\dots,X_{t}\}   , the distribution    P   (    X  k    |   o   1  :  t    )      fragments  P   fragments  normal-(   subscript  X  k   normal-|   subscript  o   normal-:  1  t    normal-)     P(X_{k}\ |\ o_{1:t})   . This inference task is usually called smoothing . The algorithm makes use of the principle of dynamic programming to compute efficiently the values that are required to obtain the posterior marginal distributions in two passes. The first pass goes forward in time while the second goes backward in time; hence the name forward–backward algorithm .  The term forward–backward algorithm is also used to refer to any algorithm belonging to the general class of algorithms that operate on sequence models in a forward–backward manner. In this sense, the descriptions in the remainder of this article refer but to one specific instance of this class.  Overview  In the first pass, the forward–backward algorithm computes a set of forward probabilities which provide, for all    k  ∈   {  1  ,  …  ,  t  }       k   1  normal-…  t     k\in\{1,\dots,t\}   , the probability of ending up in any particular state given the first   k   k   k   observations in the sequence, i.e.    P   (    X  k    |   o   1  :  k    )      fragments  P   fragments  normal-(   subscript  X  k   normal-|   subscript  o   normal-:  1  k    normal-)     P(X_{k}\ |\ o_{1:k})   . In the second pass, the algorithm computes a set of backward probabilities which provide the probability of observing the remaining observations given any starting point   k   k   k   , i.e.    P   (    o    k  +  1   :  t     |   X  k   )      fragments  P   fragments  normal-(   subscript  o   normal-:    k  1   t    normal-|   subscript  X  k   normal-)     P(o_{k+1:t}\ |\ X_{k})   . These two sets of probability distributions can then be combined to obtain the distribution over states at any specific point in time given the entire observation sequence:      P   (    X  k    |   o   1  :  t    )   =  P   (    X  k    |   o   1  :  k    ,   o    k  +  1   :  t    )   ∝  P   (    o    k  +  1   :  t     |   X  k   )   P   (    X  k    |   o   1  :  k    )      fragments  P   fragments  normal-(   subscript  X  k   normal-|   subscript  o   normal-:  1  t    normal-)    P   fragments  normal-(   subscript  X  k   normal-|   subscript  o   normal-:  1  k    normal-,   subscript  o   normal-:    k  1   t    normal-)   proportional-to  P   fragments  normal-(   subscript  o   normal-:    k  1   t    normal-|   subscript  X  k   normal-)   P   fragments  normal-(   subscript  X  k   normal-|   subscript  o   normal-:  1  k    normal-)     P(X_{k}\ |\ o_{1:t})=P(X_{k}\ |\ o_{1:k},o_{k+1:t})\propto P(o_{k+1:t}\ |\ X_{%
 k})P(X_{k}\ |\ o_{1:k})     The last step follows from an application of the Bayes' rule and the conditional independence of    o    k  +  1   :  t      subscript  o   normal-:    k  1   t     o_{k+1:t}   and    o   1  :  k      subscript  o   normal-:  1  k     o_{1:k}   given    X  k     subscript  X  k    X_{k}   .  As outlined above, the algorithm involves three steps:   computing forward probabilities  computing backward probabilities  computing smoothed values.   The forward and backward steps may also be called "forward message pass" and "backward message pass" - these terms are due to the message-passing used in general belief propagation approaches. At each single observation in the sequence, probabilities to be used for calculations at the next observation are computed. The smoothing step can be calculated simultaneously during the backward pass. This step allows the algorithm to take into account any past observations of output for computing more accurate results.  The forward–backward algorithm can be used to find the most likely state for any point in time. It cannot, however, be used to find the most likely sequence of states (see Viterbi algorithm ).  Forward probabilities  The following description will use matrices of probability values rather than probability distributions, although in general the forward-backward algorithm can be applied to continuous as well as discrete probability models.  We transform the probability distributions related to a given hidden Markov model into matrix notation as follows. The transition probabilities    𝐏   (   X  t   ∣   X   t  -  1    )      fragments  P   fragments  normal-(   subscript  X  t   normal-∣   subscript  X    t  1    normal-)     \mathbf{P}(X_{t}\mid X_{t-1})   of a given random variable    X  t     subscript  X  t    X_{t}   representing all possible states in the hidden Markov model will be represented by the matrix   𝐓   𝐓   \mathbf{T}   where the row index, i, will represent the start state and the column index, j, represents the target state. The example below represents a system where the probability of staying in the same state after each step is 70% and the probability of transitioning to the other state is 30%. The transition matrix is then:      𝐓  =   (     0.7    0.3      0.3    0.7     )       𝐓    0.7  0.3    0.3  0.7      \mathbf{T}=\begin{pmatrix}0.7&0.3\\
 0.3&0.7\end{pmatrix}     In a typical Markov model we would multiply a state vector by this matrix to obtain the probabilities for the subsequent state. In a hidden Markov model the state is unknown, and we instead observe events associated with the possible states. An event matrix of the form:      𝐁  =   (     0.9    0.1      0.2    0.8     )       𝐁    0.9  0.1    0.2  0.8      \mathbf{B}=\begin{pmatrix}0.9&0.1\\
 0.2&0.8\end{pmatrix}     provides the probabilities for observing events given a particular state. In the above example, event 1 will be observed 90% of the time if we are in state 1 while event 2 has a 10% probability of occurring in this state. In contrast, event 1 will only be observed 20% of the time if we are in state 2 and event 2 has an 80% chance of occurring. Given a state vector (   π   π   \mathbf{\pi}   ), the probability of observing event j is then:      𝐏   (  O  =  j  )   =   ∑  i    π  i    b   i  ,  j       fragments  P   fragments  normal-(  O   j  normal-)     subscript   i    subscript  π  i    subscript  b   i  j      \mathbf{P}(O=j)=\sum_{i}\pi_{i}b_{i,j}     This can be represented in matrix form by multiplying the state vector (   π   π   \mathbf{\pi}   ) by an observation matrix (     𝐎  𝐣   =   diag   (   b   *  ,   o  j     )         subscript  𝐎  𝐣     diag   subscript  b     subscript  o  j        \mathbf{O_{j}}=\mathrm{diag}(b_{*,o_{j}})   ) containing only diagonal entries. Each entry is the probability of the observed event given each state. Continuing the above example, an observation of event 1 would be:       𝐎  𝟏   =   (     0.9    0.0      0.0    0.2     )        subscript  𝐎  1     0.9  0.0    0.0  0.2      \mathbf{O_{1}}=\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}     This allows us to calculate the probabilities associated with transitioning to a new state and observing the given event as:       𝐟   𝟎  :  𝟏    =   π   𝐎  𝟏         subscript  𝐟   normal-:  0  1      π   subscript  𝐎  1      \mathbf{f_{0:1}}=\mathbf{\pi}\mathbf{O_{1}}     The probability vector that results contains entries indicating the probability of transitioning to each state and observing the given event. This process can be carried forward with additional observations using:       𝐟   𝟎  :  𝐭    =    𝐟   𝟎  :   𝐭  -  𝟏      𝐓𝐎  𝐭         subscript  𝐟   normal-:  0  𝐭       subscript  𝐟   normal-:  0    𝐭  1      subscript  𝐓𝐎  𝐭      \mathbf{f_{0:t}}=\mathbf{f_{0:t-1}}\mathbf{T}\mathbf{O_{t}}     This value is the forward probability vector. The i'th entry of this vector provides:       𝐟   𝟎  :  𝐭     (  i  )   =  𝐏   (   o  1   ,   o  2   ,  …  ,   o  t   ,   X  t   =   x  i   |  π  )      fragments   subscript  𝐟   normal-:  0  𝐭     fragments  normal-(  i  normal-)    P   fragments  normal-(   subscript  o  1   normal-,   subscript  o  2   normal-,  normal-…  normal-,   subscript  o  t   normal-,   subscript  X  t     subscript  x  i   normal-|  π  normal-)     \mathbf{f_{0:t}}(i)=\mathbf{P}(o_{1},o_{2},\dots,o_{t},X_{t}=x_{i}|\mathbf{\pi})     Typically, we will normalize the probability vector at each step so that its entries sum to 1. A scaling factor is thus introduced at each step such that:        𝐟  ^    𝟎  :  𝐭    =     c  t   -  1       𝐟  ^    𝟎  :   𝐭  -  𝟏      𝐓𝐎  𝐭         subscript   normal-^  𝐟    normal-:  0  𝐭       superscript   subscript  c  t     1     subscript   normal-^  𝐟    normal-:  0    𝐭  1      subscript  𝐓𝐎  𝐭      \mathbf{\hat{f}_{0:t}}=c_{t}^{-1}\ \mathbf{\hat{f}_{0:t-1}}\mathbf{T}\mathbf{O%
 _{t}}     where     𝐟  ^    𝟎  :   𝐭  -  𝟏       subscript   normal-^  𝐟    normal-:  0    𝐭  1      \mathbf{\hat{f}_{0:t-1}}   represents the scaled vector from the previous step and    c  t     subscript  c  t    c_{t}   represents the scaling factor that causes the resulting vector's entries to sum to 1. The product of the scaling factors is the total probability for observing the given events irrespective of the final states:      𝐏   (   o  1   ,   o  2   ,  …  ,   o  t   |  π  )   =   ∏   s  =  1   t    c  s      fragments  P   fragments  normal-(   subscript  o  1   normal-,   subscript  o  2   normal-,  normal-…  normal-,   subscript  o  t   normal-|  π  normal-)     superscript   subscript  product    s  1    t    subscript  c  s     \mathbf{P}(o_{1},o_{2},\dots,o_{t}|\mathbf{\pi})=\prod_{s=1}^{t}c_{s}     This allows us to interpret the scaled probability vector as:        𝐟  ^    𝟎  :  𝐭     (  i  )   =     𝐟   𝟎  :  𝐭     (  i  )      ∏   s  =  1   t    c  s     =    𝐏   (   o  1   ,   o  2   ,  …  ,   o  t   ,   X  t   =   x  i   |  π  )     𝐏   (   o  1   ,   o  2   ,  …  ,   o  t   |  π  )     =  𝐏   (   X  t   =   x  i   |   o  1   ,   o  2   ,  …  ,   o  t   ,  π  )      fragments   subscript   normal-^  𝐟    normal-:  0  𝐭     fragments  normal-(  i  normal-)         subscript  𝐟   normal-:  0  𝐭    i     superscript   subscript  product    s  1    t    subscript  c  s         fragments  P   fragments  normal-(   subscript  o  1   normal-,   subscript  o  2   normal-,  normal-…  normal-,   subscript  o  t   normal-,   subscript  X  t     subscript  x  i   normal-|  π  normal-)     fragments  P   fragments  normal-(   subscript  o  1   normal-,   subscript  o  2   normal-,  normal-…  normal-,   subscript  o  t   normal-|  π  normal-)      P   fragments  normal-(   subscript  X  t     subscript  x  i   normal-|   subscript  o  1   normal-,   subscript  o  2   normal-,  normal-…  normal-,   subscript  o  t   normal-,  π  normal-)     \mathbf{\hat{f}_{0:t}}(i)=\frac{\mathbf{f_{0:t}}(i)}{\prod_{s=1}^{t}c_{s}}=%
 \frac{\mathbf{P}(o_{1},o_{2},\dots,o_{t},X_{t}=x_{i}|\mathbf{\pi})}{\mathbf{P}%
 (o_{1},o_{2},\dots,o_{t}|\mathbf{\pi})}=\mathbf{P}(X_{t}=x_{i}|o_{1},o_{2},%
 \dots,o_{t},\mathbf{\pi})     We thus find that the product of the scaling factors provides us with the total probability for observing the given sequence up to time t and that the scaled probability vector provides us with the probability of being in each state at this time.  Backward probabilities  A similar procedure can be constructed to find backward probabilities. These intend to provide the probabilities:       𝐛   𝐭  :  𝐓     (  i  )   =  𝐏   (   o   t  +  1    ,   o   t  +  2    ,  …  ,   o  T   |   X  t   =   x  i   )      fragments   subscript  𝐛   normal-:  𝐭  𝐓     fragments  normal-(  i  normal-)    P   fragments  normal-(   subscript  o    t  1    normal-,   subscript  o    t  2    normal-,  normal-…  normal-,   subscript  o  T   normal-|   subscript  X  t     subscript  x  i   normal-)     \mathbf{b_{t:T}}(i)=\mathbf{P}(o_{t+1},o_{t+2},\dots,o_{T}|X_{t}=x_{i})     That is, we now want to assume that we start in a particular state (     X  t   =   x  i        subscript  X  t    subscript  x  i     X_{t}=x_{i}   ), and we are now interested in the probability of observing all future events from this state. Since the initial state is assumed as given (i.e. the prior probability of this state = 100%), we begin with:       𝐛   𝐓  :  𝐓    =    [    1 1 1   …   ]   T        subscript  𝐛   normal-:  𝐓  𝐓     superscript   delimited-[]    1 1 1  normal-…    T     \mathbf{b_{T:T}}=[1\ 1\ 1\ \dots]^{T}     Notice that we are now using a column vector while the forward probabilities used row vectors. We can then work backwards using:       𝐛    𝐭  -  𝟏   :  𝐓    =    𝐓𝐎  𝐭    𝐛   𝐭  :  𝐓          subscript  𝐛   normal-:    𝐭  1   𝐓       subscript  𝐓𝐎  𝐭    subscript  𝐛   normal-:  𝐭  𝐓       \mathbf{b_{t-1:T}}=\mathbf{T}\mathbf{O_{t}}\mathbf{b_{t:T}}     While we could normalize this vector as well so that its entries sum to one, this is not usually done. Noting that each entry contains the probability of the future event sequence given a particular initial state, normalizing this vector would be equivalent to applying Bayes' theorem to find the likelihood of each initial state given the future events (assuming uniform priors for the final state vector). However, it is more common to scale this vector using the same    c  t     subscript  c  t    c_{t}   constants used in the forward probability calculations.    𝐛   𝐓  :  𝐓      subscript  𝐛   normal-:  𝐓  𝐓     \mathbf{b_{T:T}}   is not scaled, but subsequent operations use:        𝐛  ^     𝐭  -  𝟏   :  𝐓    =    c  t   -  1     𝐓𝐎  𝐭     𝐛  ^    𝐭  :  𝐓          subscript   normal-^  𝐛    normal-:    𝐭  1   𝐓       superscript   subscript  c  t     1     subscript  𝐓𝐎  𝐭    subscript   normal-^  𝐛    normal-:  𝐭  𝐓       \mathbf{\hat{b}_{t-1:T}}=c_{t}^{-1}\mathbf{T}\mathbf{O_{t}}\mathbf{\hat{b}_{t:%
 T}}     where     𝐛  ^    𝐭  :  𝐓      subscript   normal-^  𝐛    normal-:  𝐭  𝐓     \mathbf{\hat{b}_{t:T}}   represents the previous, scaled vector. This result is that the scaled probability vector is related to the backward probabilities by:         𝐛  ^    𝐭  :  𝐓     (  i  )    =     𝐛   𝐭  :  𝐓     (  i  )      ∏   s  =   t  +  1    T    c  s            subscript   normal-^  𝐛    normal-:  𝐭  𝐓    i        subscript  𝐛   normal-:  𝐭  𝐓    i     superscript   subscript  product    s    t  1     T    subscript  c  s       \mathbf{\hat{b}_{t:T}}(i)=\frac{\mathbf{b_{t:T}}(i)}{\prod_{s=t+1}^{T}c_{s}}     This is useful because it allows us to find the total probability of being in each state at a given time, t, by multiplying these values:       γ  𝐭    (  i  )   =  𝐏   (   X  t   =   x  i   |   o  1   ,   o  2   ,  …  ,   o  T   ,  π  )   =    𝐏   (   o  1   ,   o  2   ,  …  ,   o  T   ,   X  t   =   x  i   |  π  )     𝐏   (   o  1   ,   o  2   ,  …  ,   o  T   |  π  )     =       𝐟   𝟎  :  𝐭     (  i  )    ⋅   𝐛   𝐭  :  𝐓      (  i  )      ∏   s  =  1   T    c  s     =    𝐟  ^    𝟎  :  𝐭     (  i  )   ⋅    𝐛  ^    𝐭  :  𝐓     (  i  )      fragments   subscript  γ  𝐭    fragments  normal-(  i  normal-)    P   fragments  normal-(   subscript  X  t     subscript  x  i   normal-|   subscript  o  1   normal-,   subscript  o  2   normal-,  normal-…  normal-,   subscript  o  T   normal-,  π  normal-)       fragments  P   fragments  normal-(   subscript  o  1   normal-,   subscript  o  2   normal-,  normal-…  normal-,   subscript  o  T   normal-,   subscript  X  t     subscript  x  i   normal-|  π  normal-)     fragments  P   fragments  normal-(   subscript  o  1   normal-,   subscript  o  2   normal-,  normal-…  normal-,   subscript  o  T   normal-|  π  normal-)           normal-⋅     subscript  𝐟   normal-:  0  𝐭    i    subscript  𝐛   normal-:  𝐭  𝐓     i     superscript   subscript  product    s  1    T    subscript  c  s       subscript   normal-^  𝐟    normal-:  0  𝐭     fragments  normal-(  i  normal-)   normal-⋅   subscript   normal-^  𝐛    normal-:  𝐭  𝐓     fragments  normal-(  i  normal-)     \mathbf{\gamma_{t}}(i)=\mathbf{P}(X_{t}=x_{i}|o_{1},o_{2},\dots,o_{T},\mathbf{%
 \pi})=\frac{\mathbf{P}(o_{1},o_{2},\dots,o_{T},X_{t}=x_{i}|\mathbf{\pi})}{%
 \mathbf{P}(o_{1},o_{2},\dots,o_{T}|\mathbf{\pi})}=\frac{\mathbf{f_{0:t}}(i)%
 \cdot\mathbf{b_{t:T}}(i)}{\prod_{s=1}^{T}c_{s}}=\mathbf{\hat{f}_{0:t}}(i)\cdot%
 \mathbf{\hat{b}_{t:T}}(i)     To understand this, we note that       𝐟   𝟎  :  𝐭     (  i  )    ⋅   𝐛   𝐭  :  𝐓      (  i  )        normal-⋅     subscript  𝐟   normal-:  0  𝐭    i    subscript  𝐛   normal-:  𝐭  𝐓     i    \mathbf{f_{0:t}}(i)\cdot\mathbf{b_{t:T}}(i)   provides the probability for observing the given events in a way that passes through state    x  i     subscript  x  i    x_{i}   at time t. This probability includes the forward probabilities covering all events up to time t as well as the backward probabilities which include all future events. This is the numerator we are looking for in our equation, and we divide by the total probability of the observation sequence to normalize this value and extract only the probability that     X  t   =   x  i        subscript  X  t    subscript  x  i     X_{t}=x_{i}   . These values are sometimes called the "smoothed values" as they combine the forward and backward probabilities to compute a final probability.  The values     γ  𝐭    (  i  )        subscript  γ  𝐭   i    \mathbf{\gamma_{t}}(i)   thus provide the probability of being in each state at time t. As such, they are useful for determining the most probable state at any time. It should be noted, however, that the term "most probable state" is somewhat ambiguous. While the most probable state is the most likely to be correct at a given point, the sequence of individually probable states is not likely to be the most probable sequence. This is because the probabilities for each point are calculated independently of each other. They do not take into account the transition probabilities between states, and it is thus possible to get states at two moments (t and t+1) that are both most probable at those time points but which have very little probability of occurring together, i.e.    𝐏   (   X  t   =   x  i   ,   X   t  +  1    =   x  j   )   ≠  𝐏   (   X  t   =   x  i   )   𝐏   (   X   t  +  1    =   x  j   )      fragments  P   fragments  normal-(   subscript  X  t     subscript  x  i   normal-,   subscript  X    t  1      subscript  x  j   normal-)    P   fragments  normal-(   subscript  X  t     subscript  x  i   normal-)   P   fragments  normal-(   subscript  X    t  1      subscript  x  j   normal-)     \mathbf{P}(X_{t}=x_{i},X_{t+1}=x_{j})\neq\mathbf{P}(X_{t}=x_{i})\mathbf{P}(X_{%
 t+1}=x_{j})   . The most probable sequence of states that produced an observation sequence can be found using the Viterbi algorithm .  Example  This example takes as its basis the umbrella world in Russell & Norvig 2010 Chapter 15 pp. 566 in which we would like to infer the weather given observation of a man either carrying or not carrying an umbrella. We assume two possible states for the weather: state 1 = rain, state 2 = no rain. We assume that the weather has a 70% chance of staying the same each day and a 30% chance of changing. The transition probabilities are then:      𝐓  =   (     0.7    0.3      0.3    0.7     )       𝐓    0.7  0.3    0.3  0.7      \mathbf{T}=\begin{pmatrix}0.7&0.3\\
 0.3&0.7\end{pmatrix}     We also assume each state generates 2 events: event 1 = umbrella, event 2 = no umbrella. The conditional probabilities for these occurring in each state are given by the probability matrix:      𝐁  =   (     0.9    0.1      0.2    0.8     )       𝐁    0.9  0.1    0.2  0.8      \mathbf{B}=\begin{pmatrix}0.9&0.1\\
 0.2&0.8\end{pmatrix}     We then observe the following sequence of events: {umbrella, umbrella, no umbrella, umbrella, umbrella} which we will represent in our calculations as:       𝐎  𝟏   =     (     0.9    0.0      0.0    0.2     )     𝐎  𝟐    =     (     0.9    0.0      0.0    0.2     )     𝐎  𝟑    =     (     0.1    0.0      0.0    0.8     )     𝐎  𝟒    =     (     0.9    0.0      0.0    0.2     )     𝐎  𝟓    =   (     0.9    0.0      0.0    0.2     )          subscript  𝐎  1       0.9  0.0    0.0  0.2     subscript  𝐎  2             0.9  0.0    0.0  0.2     subscript  𝐎  3             0.1  0.0    0.0  0.8     subscript  𝐎  4             0.9  0.0    0.0  0.2     subscript  𝐎  5           0.9  0.0    0.0  0.2       \mathbf{O_{1}}=\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}~{}~{}\mathbf{O_{2}}=\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}~{}~{}\mathbf{O_{3}}=\begin{pmatrix}0.1&0.0\\
 0.0&0.8\end{pmatrix}~{}~{}\mathbf{O_{4}}=\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}~{}~{}\mathbf{O_{5}}=\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}     Note that    𝐎  𝟑     subscript  𝐎  3    \mathbf{O_{3}}   differs from the others because of the "no umbrella" observation.  In computing the forward probabilities we begin with:       𝐟   𝟎  :  𝟎    =   (     0.5    0.5     )        subscript  𝐟   normal-:  0  0      0.5  0.5      \mathbf{f_{0:0}}=\begin{pmatrix}0.5&0.5\end{pmatrix}     which is our prior state vector indicating that we don't know which state the weather is in before our observations. While a state vector should be given as a row vector, we will use the transpose of the matrix so that the calculations below are easier to read. Our calculations are then written in the form:        (    𝐟  ^    𝟎  :  𝐭    )   T   =    c   -  1     𝐎  𝐭     (  𝐓  )   T     (    𝐟  ^    𝟎  :   𝐭  -  𝟏     )   T         superscript   subscript   normal-^  𝐟    normal-:  0  𝐭    T      superscript  c    1     subscript  𝐎  𝐭    superscript  𝐓  T    superscript   subscript   normal-^  𝐟    normal-:  0    𝐭  1     T      (\mathbf{\hat{f}_{0:t}})^{T}=c^{-1}\mathbf{O_{t}}(\mathbf{T})^{T}(\mathbf{\hat%
 {f}_{0:t-1}})^{T}     instead of:        𝐟  ^    𝟎  :  𝐭    =    c   -  1      𝐟  ^    𝟎  :   𝐭  -  𝟏      𝐓𝐎  𝐭         subscript   normal-^  𝐟    normal-:  0  𝐭       superscript  c    1     subscript   normal-^  𝐟    normal-:  0    𝐭  1      subscript  𝐓𝐎  𝐭      \mathbf{\hat{f}_{0:t}}=c^{-1}\mathbf{\hat{f}_{0:t-1}}\mathbf{T}\mathbf{O_{t}}     Notice that the transformation matrix is also transposed, but in our example the transpose is equal to the original matrix. Performing these calculations and normalizing the results provides:        (    𝐟  ^    𝟎  :  𝟏    )   T   =    c  1   -  1     (     0.9    0.0      0.0    0.2     )    (     0.7    0.3      0.3    0.7     )    (     0.5000      0.5000     )    =    c  1   -  1     (     0.4500      0.1000     )    =   (     0.8182      0.1818     )          superscript   subscript   normal-^  𝐟    normal-:  0  1    T      superscript   subscript  c  1     1      0.9  0.0    0.0  0.2      0.7  0.3    0.3  0.7      0.5000    0.5000             superscript   subscript  c  1     1      0.4500    0.1000            0.8182    0.1818       (\mathbf{\hat{f}_{0:1}})^{T}=c_{1}^{-1}\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}\begin{pmatrix}0.7&0.3\\
 0.3&0.7\end{pmatrix}\begin{pmatrix}0.5000\\
 0.5000\end{pmatrix}=c_{1}^{-1}\begin{pmatrix}0.4500\\
 0.1000\end{pmatrix}=\begin{pmatrix}0.8182\\
 0.1818\end{pmatrix}           (    𝐟  ^    𝟎  :  𝟐    )   T   =    c  2   -  1     (     0.9    0.0      0.0    0.2     )    (     0.7    0.3      0.3    0.7     )    (     0.8182      0.1818     )    =    c  2   -  1     (     0.5645      0.0745     )    =   (     0.8834      0.1166     )          superscript   subscript   normal-^  𝐟    normal-:  0  2    T      superscript   subscript  c  2     1      0.9  0.0    0.0  0.2      0.7  0.3    0.3  0.7      0.8182    0.1818             superscript   subscript  c  2     1      0.5645    0.0745            0.8834    0.1166       (\mathbf{\hat{f}_{0:2}})^{T}=c_{2}^{-1}\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}\begin{pmatrix}0.7&0.3\\
 0.3&0.7\end{pmatrix}\begin{pmatrix}0.8182\\
 0.1818\end{pmatrix}=c_{2}^{-1}\begin{pmatrix}0.5645\\
 0.0745\end{pmatrix}=\begin{pmatrix}0.8834\\
 0.1166\end{pmatrix}           (    𝐟  ^    𝟎  :  𝟑    )   T   =    c  3   -  1     (     0.1    0.0      0.0    0.8     )    (     0.7    0.3      0.3    0.7     )    (     0.8834      0.1166     )    =    c  3   -  1     (     0.0653      0.2772     )    =   (     0.1907      0.8093     )          superscript   subscript   normal-^  𝐟    normal-:  0  3    T      superscript   subscript  c  3     1      0.1  0.0    0.0  0.8      0.7  0.3    0.3  0.7      0.8834    0.1166             superscript   subscript  c  3     1      0.0653    0.2772            0.1907    0.8093       (\mathbf{\hat{f}_{0:3}})^{T}=c_{3}^{-1}\begin{pmatrix}0.1&0.0\\
 0.0&0.8\end{pmatrix}\begin{pmatrix}0.7&0.3\\
 0.3&0.7\end{pmatrix}\begin{pmatrix}0.8834\\
 0.1166\end{pmatrix}=c_{3}^{-1}\begin{pmatrix}0.0653\\
 0.2772\end{pmatrix}=\begin{pmatrix}0.1907\\
 0.8093\end{pmatrix}           (    𝐟  ^    𝟎  :  𝟒    )   T   =    c  4   -  1     (     0.9    0.0      0.0    0.2     )    (     0.7    0.3      0.3    0.7     )    (     0.1907      0.8093     )    =    c  4   -  1     (     0.3386      0.1247     )    =   (     0.7308      0.2692     )          superscript   subscript   normal-^  𝐟    normal-:  0  4    T      superscript   subscript  c  4     1      0.9  0.0    0.0  0.2      0.7  0.3    0.3  0.7      0.1907    0.8093             superscript   subscript  c  4     1      0.3386    0.1247            0.7308    0.2692       (\mathbf{\hat{f}_{0:4}})^{T}=c_{4}^{-1}\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}\begin{pmatrix}0.7&0.3\\
 0.3&0.7\end{pmatrix}\begin{pmatrix}0.1907\\
 0.8093\end{pmatrix}=c_{4}^{-1}\begin{pmatrix}0.3386\\
 0.1247\end{pmatrix}=\begin{pmatrix}0.7308\\
 0.2692\end{pmatrix}           (    𝐟  ^    𝟎  :  𝟓    )   T   =    c  5   -  1     (     0.9    0.0      0.0    0.2     )    (     0.7    0.3      0.3    0.7     )    (     0.7308      0.2692     )    =    c  5   -  1     (     0.5331      0.0815     )    =   (     0.8673      0.1327     )          superscript   subscript   normal-^  𝐟    normal-:  0  5    T      superscript   subscript  c  5     1      0.9  0.0    0.0  0.2      0.7  0.3    0.3  0.7      0.7308    0.2692             superscript   subscript  c  5     1      0.5331    0.0815            0.8673    0.1327       (\mathbf{\hat{f}_{0:5}})^{T}=c_{5}^{-1}\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}\begin{pmatrix}0.7&0.3\\
 0.3&0.7\end{pmatrix}\begin{pmatrix}0.7308\\
 0.2692\end{pmatrix}=c_{5}^{-1}\begin{pmatrix}0.5331\\
 0.0815\end{pmatrix}=\begin{pmatrix}0.8673\\
 0.1327\end{pmatrix}     For the backward probabilities we start with:       𝐛   𝟓  :  𝟓    =   (     1.0      1.0     )        subscript  𝐛   normal-:  5  5      1.0    1.0      \mathbf{b_{5:5}}=\begin{pmatrix}1.0\\
 1.0\end{pmatrix}     We are then able to compute (using the observations in reverse order and normalizing with different constants):        𝐛  ^    𝟒  :  𝟓    =   α   (     0.7    0.3      0.3    0.7     )    (     0.9    0.0      0.0    0.2     )    (     1.0000      1.0000     )    =   α   (     0.6900      0.4100     )    =   (     0.6273      0.3727     )          subscript   normal-^  𝐛    normal-:  4  5      α    0.7  0.3    0.3  0.7      0.9  0.0    0.0  0.2      1.0000    1.0000            α    0.6900    0.4100            0.6273    0.3727       \mathbf{\hat{b}_{4:5}}=\alpha\begin{pmatrix}0.7&0.3\\
 0.3&0.7\end{pmatrix}\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}\begin{pmatrix}1.0000\\
 1.0000\end{pmatrix}=\alpha\begin{pmatrix}0.6900\\
 0.4100\end{pmatrix}=\begin{pmatrix}0.6273\\
 0.3727\end{pmatrix}           𝐛  ^    𝟑  :  𝟓    =   α   (     0.7    0.3      0.3    0.7     )    (     0.9    0.0      0.0    0.2     )    (     0.6273      0.3727     )    =   α   (     0.4175      0.2215     )    =   (     0.6533      0.3467     )          subscript   normal-^  𝐛    normal-:  3  5      α    0.7  0.3    0.3  0.7      0.9  0.0    0.0  0.2      0.6273    0.3727            α    0.4175    0.2215            0.6533    0.3467       \mathbf{\hat{b}_{3:5}}=\alpha\begin{pmatrix}0.7&0.3\\
 0.3&0.7\end{pmatrix}\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}\begin{pmatrix}0.6273\\
 0.3727\end{pmatrix}=\alpha\begin{pmatrix}0.4175\\
 0.2215\end{pmatrix}=\begin{pmatrix}0.6533\\
 0.3467\end{pmatrix}           𝐛  ^    𝟐  :  𝟓    =   α   (     0.7    0.3      0.3    0.7     )    (     0.1    0.0      0.0    0.8     )    (     0.6533      0.3467     )    =   α   (     0.1289      0.2138     )    =   (     0.3763      0.6237     )          subscript   normal-^  𝐛    normal-:  2  5      α    0.7  0.3    0.3  0.7      0.1  0.0    0.0  0.8      0.6533    0.3467            α    0.1289    0.2138            0.3763    0.6237       \mathbf{\hat{b}_{2:5}}=\alpha\begin{pmatrix}0.7&0.3\\
 0.3&0.7\end{pmatrix}\begin{pmatrix}0.1&0.0\\
 0.0&0.8\end{pmatrix}\begin{pmatrix}0.6533\\
 0.3467\end{pmatrix}=\alpha\begin{pmatrix}0.1289\\
 0.2138\end{pmatrix}=\begin{pmatrix}0.3763\\
 0.6237\end{pmatrix}           𝐛  ^    𝟏  :  𝟓    =   α   (     0.7    0.3      0.3    0.7     )    (     0.9    0.0      0.0    0.2     )    (     0.3763      0.6237     )    =   α   (     0.2745      0.1889     )    =   (     0.5923      0.4077     )          subscript   normal-^  𝐛    normal-:  1  5      α    0.7  0.3    0.3  0.7      0.9  0.0    0.0  0.2      0.3763    0.6237            α    0.2745    0.1889            0.5923    0.4077       \mathbf{\hat{b}_{1:5}}=\alpha\begin{pmatrix}0.7&0.3\\
 0.3&0.7\end{pmatrix}\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}\begin{pmatrix}0.3763\\
 0.6237\end{pmatrix}=\alpha\begin{pmatrix}0.2745\\
 0.1889\end{pmatrix}=\begin{pmatrix}0.5923\\
 0.4077\end{pmatrix}           𝐛  ^    𝟎  :  𝟓    =   α   (     0.7    0.3      0.3    0.7     )    (     0.9    0.0      0.0    0.2     )    (     0.5923      0.4077     )    =   α   (     0.3976      0.2170     )    =   (     0.6469      0.3531     )          subscript   normal-^  𝐛    normal-:  0  5      α    0.7  0.3    0.3  0.7      0.9  0.0    0.0  0.2      0.5923    0.4077            α    0.3976    0.2170            0.6469    0.3531       \mathbf{\hat{b}_{0:5}}=\alpha\begin{pmatrix}0.7&0.3\\
 0.3&0.7\end{pmatrix}\begin{pmatrix}0.9&0.0\\
 0.0&0.2\end{pmatrix}\begin{pmatrix}0.5923\\
 0.4077\end{pmatrix}=\alpha\begin{pmatrix}0.3976\\
 0.2170\end{pmatrix}=\begin{pmatrix}0.6469\\
 0.3531\end{pmatrix}     Finally, we will compute the smoothed probability values. These result also must be scaled so that its entries sum to 1 because we did not scale the backward probabilities with the    c  t     subscript  c  t    c_{t}   's found earlier. The backward probability vectors above thus actually represent the likelihood of each state at time t given the future observations. Because these vectors are proportional to the actual backward probabilities, the result has to be scaled an additional time.        (   γ  𝟎   )   T   =    α   (     0.5000      0.5000     )    ∘   (     0.6469      0.3531     )    =   α   (     0.3235      0.1765     )    =   (     0.6469      0.3531     )          superscript   subscript  γ  0   T       α    0.5000    0.5000       0.6469    0.3531            α    0.3235    0.1765            0.6469    0.3531       (\mathbf{\gamma_{0}})^{T}=\alpha\begin{pmatrix}0.5000\\
 0.5000\end{pmatrix}\circ\begin{pmatrix}0.6469\\
 0.3531\end{pmatrix}=\alpha\begin{pmatrix}0.3235\\
 0.1765\end{pmatrix}=\begin{pmatrix}0.6469\\
 0.3531\end{pmatrix}           (   γ  𝟏   )   T   =    α   (     0.8182      0.1818     )    ∘   (     0.5923      0.4077     )    =   α   (     0.4846      0.0741     )    =   (     0.8673      0.1327     )          superscript   subscript  γ  1   T       α    0.8182    0.1818       0.5923    0.4077            α    0.4846    0.0741            0.8673    0.1327       (\mathbf{\gamma_{1}})^{T}=\alpha\begin{pmatrix}0.8182\\
 0.1818\end{pmatrix}\circ\begin{pmatrix}0.5923\\
 0.4077\end{pmatrix}=\alpha\begin{pmatrix}0.4846\\
 0.0741\end{pmatrix}=\begin{pmatrix}0.8673\\
 0.1327\end{pmatrix}           (   γ  𝟐   )   T   =    α   (     0.8834      0.1166     )    ∘   (     0.3763      0.6237     )    =   α   (     0.3324      0.0728     )    =   (     0.8204      0.1796     )          superscript   subscript  γ  2   T       α    0.8834    0.1166       0.3763    0.6237            α    0.3324    0.0728            0.8204    0.1796       (\mathbf{\gamma_{2}})^{T}=\alpha\begin{pmatrix}0.8834\\
 0.1166\end{pmatrix}\circ\begin{pmatrix}0.3763\\
 0.6237\end{pmatrix}=\alpha\begin{pmatrix}0.3324\\
 0.0728\end{pmatrix}=\begin{pmatrix}0.8204\\
 0.1796\end{pmatrix}           (   γ  𝟑   )   T   =    α   (     0.1907      0.8093     )    ∘   (     0.6533      0.3467     )    =   α   (     0.1246      0.2806     )    =   (     0.3075      0.6925     )          superscript   subscript  γ  3   T       α    0.1907    0.8093       0.6533    0.3467            α    0.1246    0.2806            0.3075    0.6925       (\mathbf{\gamma_{3}})^{T}=\alpha\begin{pmatrix}0.1907\\
 0.8093\end{pmatrix}\circ\begin{pmatrix}0.6533\\
 0.3467\end{pmatrix}=\alpha\begin{pmatrix}0.1246\\
 0.2806\end{pmatrix}=\begin{pmatrix}0.3075\\
 0.6925\end{pmatrix}           (   γ  𝟒   )   T   =    α   (     0.7308      0.2692     )    ∘   (     0.6273      0.3727     )    =   α   (     0.4584      0.1003     )    =   (     0.8204      0.1796     )          superscript   subscript  γ  4   T       α    0.7308    0.2692       0.6273    0.3727            α    0.4584    0.1003            0.8204    0.1796       (\mathbf{\gamma_{4}})^{T}=\alpha\begin{pmatrix}0.7308\\
 0.2692\end{pmatrix}\circ\begin{pmatrix}0.6273\\
 0.3727\end{pmatrix}=\alpha\begin{pmatrix}0.4584\\
 0.1003\end{pmatrix}=\begin{pmatrix}0.8204\\
 0.1796\end{pmatrix}           (   γ  𝟓   )   T   =    α   (     0.8673      0.1327     )    ∘   (     1.0000      1.0000     )    =   α   (     0.8673      0.1327     )    =   (     0.8673      0.1327     )          superscript   subscript  γ  5   T       α    0.8673    0.1327       1.0000    1.0000            α    0.8673    0.1327            0.8673    0.1327       (\mathbf{\gamma_{5}})^{T}=\alpha\begin{pmatrix}0.8673\\
 0.1327\end{pmatrix}\circ\begin{pmatrix}1.0000\\
 1.0000\end{pmatrix}=\alpha\begin{pmatrix}0.8673\\
 0.1327\end{pmatrix}=\begin{pmatrix}0.8673\\
 0.1327\end{pmatrix}     Notice that the value of    γ  𝟎     subscript  γ  0    \mathbf{\gamma_{0}}   is equal to     𝐛  ^    𝟎  :  𝟓      subscript   normal-^  𝐛    normal-:  0  5     \mathbf{\hat{b}_{0:5}}   and that    γ  𝟓     subscript  γ  5    \mathbf{\gamma_{5}}   is equal to     𝐟  ^    𝟎  :  𝟓      subscript   normal-^  𝐟    normal-:  0  5     \mathbf{\hat{f}_{0:5}}   . This follows naturally because both     𝐟  ^    𝟎  :  𝟓      subscript   normal-^  𝐟    normal-:  0  5     \mathbf{\hat{f}_{0:5}}   and     𝐛  ^    𝟎  :  𝟓      subscript   normal-^  𝐛    normal-:  0  5     \mathbf{\hat{b}_{0:5}}   begin with uniform priors over the initial and final state vectors (respectively) and take into account all of the observations. However,    γ  𝟎     subscript  γ  0    \mathbf{\gamma_{0}}   will only be equal to     𝐛  ^    𝟎  :  𝟓      subscript   normal-^  𝐛    normal-:  0  5     \mathbf{\hat{b}_{0:5}}   when our initial state vector represents a uniform prior (i.e. all entries are equal). When this is not the case     𝐛  ^    𝟎  :  𝟓      subscript   normal-^  𝐛    normal-:  0  5     \mathbf{\hat{b}_{0:5}}   needs to be combined with the initial state vector to find the most likely initial state. We thus find that the forward probabilities by themselves are sufficient to calculate the most likely final state. Similarly, the backward probabilities can be combined with the initial state vector to provide the most probable initial state given the observations. The forward and backward probabilities need only be combined to infer the most probable states between the initial and final points.  The calculations above reveal that the most probable weather state on every day except for the third one was "rain." They tell us more than this, however, as they now provide a way to quantify the probabilities of each state at different times. Perhaps most importantly, our value at    γ  𝟓     subscript  γ  5    \mathbf{\gamma_{5}}   quantifies our knowledge of the state vector at the end of the observation sequence. We can then use this to predict the probability of the various weather states tomorrow as well as the probability of observing an umbrella.  Performance  The brute-force procedure for the solution of this problem is the generation of all possible    N  T     superscript  N  T    N^{T}   state sequences and calculating the joint probability of each state sequence with the observed series of events. This approach has time complexity     O   (   T  ⋅   N  T    )       O   normal-⋅  T   superscript  N  T      O(T\cdot N^{T})   , where   T   T   T   is the length of sequences and   N   N   N   is the number of symbols in the state alphabet. This is intractable for realistic problems, as the number of possible hidden node sequences typically is extremely high. However, the forward–backward algorithm has time complexity    O   (    N  2   T   )       O     superscript  N  2   T     O(N^{2}T)\,   .  An enhancement to the general forward-backward algorithm, called the Island algorithm , trades smaller memory usage for longer running time, taking    O   (    N  2   T   log  T    )       O     superscript  N  2   T    T      O(N^{2}T\log T)\,   time and    O   (    N  2    log  T    )       O     superscript  N  2     T      O(N^{2}\log T)\,   memory. On a computer with an unlimited number of processors, this can be reduced to    O   (    N  2   T   )       O     superscript  N  2   T     O(N^{2}T)\,   total time, while still taking only    O   (    N  2    log  T    )       O     superscript  N  2     T      O(N^{2}\log T)\,   memory. 1  In addition, algorithms have been developed to compute    𝐟   𝟎  :   𝐭  +  𝟏       subscript  𝐟   normal-:  0    𝐭  1      \mathbf{f_{0:t+1}}   efficiently through online smoothing such as the fixed-lag smoothing (FLS) algorithm Russell & Norvig 2010 Figure 15.6 pp. 580 .  Pseudocode  ForwardBackward(guessState, sequenceIndex):
     if sequenceIndex is past the end of the sequence, return 1
     if (guessState, sequenceIndex) has been seen before, return saved result
     result = 0
     for each neighboring state n:
         result = result + (transition probability from guessState to 
                            n given observation element at sequenceIndex)
                         * ForwardBackward(n, sequenceIndex+1)
     save result for (guessState, sequenceIndex)
     return result  Python example  Given HMM (just like in Viterbi algorithm ) represented in the Python programming language :  states = ( 'Healthy' , 'Fever' )
 end_state =  'E' observations = ( 'normal' , 'cold' , 'dizzy' )
  
 start_probability = { 'Healthy' : 0.6 , 'Fever' : 0.4 }
  
 transition_probability = { 'Healthy' : { 'Healthy' : 0.69 , 'Fever' : 0.3 , 'E' : 0.01 }, 'Fever' : { 'Healthy' : 0.4 , 'Fever' : 0.59 , 'E' : 0.01 },
    }
  
 emission_probability = { 'Healthy' : { 'normal' : 0.5 , 'cold' : 0.4 , 'dizzy' : 0.1 }, 'Fever' : { 'normal' : 0.1 , 'cold' : 0.3 , 'dizzy' : 0.6 },
    }  We can write implementation like this:  def fwd_bkw(x, states, a_0, a, e, end_st):
     L =  len (x)
  
     fwd = []
     f_prev = {} # forward part of the algorithm  for i, x_i in  enumerate (x):
         f_curr = {} for st in states: if i ==  0 : # base case for the forward part prev_f_sum = a_0[st] else :
                 prev_f_sum =  sum (f_prev[k] * a[k][st] for k in states)
  
             f_curr[st] = e[st][x_i] * prev_f_sum
         
         sum_prob =  sum (f_curr.values()) for st in states:
             f_curr[st] /= sum_prob # normalising to make sum == 1 fwd.append(f_curr)
         f_prev = f_curr
  
     p_fwd =  sum (f_curr[k] * a[k][end_st] for k in states)
  
     bkw = []
     b_prev = {} # backward part of the algorithm  for i, x_i_plus in  enumerate ( reversed (x[ 1 :] + ( None ,))):
         b_curr = {} for st in states: if i ==  0 : # base case for backward part b_curr[st] = a[st][end_st] else :
                 b_curr[st] =  sum (a[st][l] * e[l][x_i_plus] * b_prev[l] for l in states)
  
 
         sum_prob =  sum (b_curr.values()) for st in states:
             b_curr[st] /= sum_prob # normalising to make sum == 1 bkw.insert( 0 ,b_curr)
         b_prev = b_curr
  
     p_bkw =  sum (a_0[l] * e[l][x[ 0 ]] * b_curr[l] for l in states) # merging the two parts posterior = [] for i in  range (L):
         posterior.append({st: fwd[i][st] * bkw[i][st] / p_fwd for st in states}) assert p_fwd == p_bkw return fwd, bkw, posterior  The function fwd_bkw takes the following arguments: x is the sequence of observations, e.g. ['normal', 'cold', 'dizzy'] ; states is the set of hidden states; a_0 is the start probability; a are the transition probabilities; and e are the emission probabilities.  For simplicity of code, we assume that the observation sequence x is non-empty and that a[i][j] and e[i][j] is defined for all states i,j.  In the running example, the forward-backward algorithm is used as follows:  def example(): return fwd_bkw(observations,
                    states,
                    start_probability,
                    transition_probability,
                    emission_probability,
                    end_state) for line in example(): print ( ' ' .join( map ( str , line)))  See also   Baum-Welch algorithm  Viterbi algorithm  BCJR algorithm   References   Lawrence R. Rabiner , A Tutorial on Hidden Markov Models and Selected Applications in Speech Recognition. Proceedings of the IEEE , 77 (2), p. 257–286, February 1989. 10.1109/5.18626         External links   An interactive spreadsheet for teaching the forward–backward algorithm (spreadsheet and article with step-by-step walk-through)  Tutorial of hidden Markov models including the forward–backward algorithm  Collection of AI algorithms implemented in Java (including HMM and the forward–backward algorithm)   "  Category:Dynamic programming  Category:Error detection and correction  Category:Machine learning algorithms  Category:Markov models     J. Binder, K. Murphy and S. Russell. Space-Efficient Inference in Dynamic Probabilistic Networks. Int'l, Joint Conf. on Artificial Intelligence, 1997. ↩    