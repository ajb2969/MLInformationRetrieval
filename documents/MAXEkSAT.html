<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="481">MAXEkSAT</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>MAXEkSAT</h1>
<hr/>

<p><strong>MAXEkSAT</strong> is a problem in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> that is a maximization version of the Boolean satisfiability problem <a class="uri" href="3SAT" title="wikilink">3SAT</a>.</p>

<p>In MAXEkSAT, each clause has exactly <em>k</em> literals, each with distinct variables, and is in <a href="conjunctive_normal_form" title="wikilink">conjunctive normal form</a>. These formulas are called k-CNF formulas.</p>

<p>The problem is to determine the maximum number of clauses that can be satisfied by a truth assignment to the variables in the clauses.</p>

<p>We say that an algorithm <em>A</em> provides an <em>α</em>-<a href="approximation_algorithm" title="wikilink">approximation</a> to MAXEkSAT if, for some fixed positive <em>α</em> less than or equal to 1, and every kCNF formula <em>φ</em>, <em>A</em> can find a truth assignment to the variables of <em>φ</em> that will satisfy at least an <em>α</em>-fraction of the maximum number of satisfiable clauses of <em>φ</em>.</p>

<p>Because the <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> <em>k</em>-SAT problem (for <em>k</em> ≥ 3) is equivalent to determining if the corresponding MAXEkSAT instance has a value equal to the number of clauses, MAXEkSAT must also be NP-hard, meaning that there is no polynomial time algorithm unless <a class="uri" href="P=NP" title="wikilink">P=NP</a>. A natural next question, then, is that of finding approximate solutions: what's the largest real number ''α \textstyle(1-\frac{1}{2^k})-approximation to MAXEkSAT: independently set each variable to true with probability 

<math display="inline" id="MAXEkSAT:0">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {1}/{2}
  </annotation>
 </semantics>
</math>

, otherwise set it to false.</p>

<p>Any given clause <em>c</em> is unsatisfied only if all of its <em>k</em> constituent literals evaluates to false. Because each literal within a clause has a 

<math display="inline" id="MAXEkSAT:1">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {1}/{2}
  </annotation>
 </semantics>
</math>

 chance of evaluating to true independently of any of the truth value of any of the other literals, the probability that they are all false is 

<math display="inline" id="MAXEkSAT:2">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>k</mi>
   </msup>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msup>
     <mn>2</mn>
     <mi>k</mi>
    </msup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(\frac{1}{2})^{k}=\frac{1}{2^{k}}
  </annotation>
 </semantics>
</math>

. Thus, the probability that <em>c</em> is indeed satisfied is 

<math display="inline" id="MAXEkSAT:3">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mfrac>
    <mn>1</mn>
    <msup>
     <mn>2</mn>
     <mi>k</mi>
    </msup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle 1-\frac{1}{2^{k}}
  </annotation>
 </semantics>
</math>

, so the indicator variable 

<math display="inline" id="MAXEkSAT:4">
 <semantics>
  <msub>
   <mn>1</mn>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle 1_{c}
  </annotation>
 </semantics>
</math>

 (that is 1 if <em>c</em> is true and 0 otherwise) has expectation 

<math display="inline" id="MAXEkSAT:5">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mfrac>
    <mn>1</mn>
    <msup>
     <mn>2</mn>
     <mi>k</mi>
    </msup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle 1-\frac{1}{2^{k}}
  </annotation>
 </semantics>
</math>

. The sum of all of the indicator variables over all 

<math display="inline" id="MAXEkSAT:6">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>C</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle|C|
  </annotation>
 </semantics>
</math>

 clauses is 

<math display="inline" id="MAXEkSAT:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mn>2</mn>
       <mi>k</mi>
      </msup>
     </mfrac>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>C</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\textstyle 1-\frac{1}{2^{k}})|C|
  </annotation>
 </semantics>
</math>

, so by <a href="linearity_of_expectation" title="wikilink">linearity of expectation</a> we satisfy a 

<math display="inline" id="MAXEkSAT:8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
    </mfrac>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(1-\frac{1}{2^{k}})
  </annotation>
 </semantics>
</math>

 fraction of the clauses in expectation. Because the optimal solution can't satisfy more than all 

<math display="inline" id="MAXEkSAT:9">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>C</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle|C|
  </annotation>
 </semantics>
</math>

 of the clauses, we have that 

<math display="inline" id="MAXEkSAT:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>L</mi>
    <mi>G</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mfrac>
       <mn>1</mn>
       <msup>
        <mn>2</mn>
        <mi>k</mi>
       </msup>
      </mfrac>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>C</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mfrac>
        <mn>1</mn>
        <msup>
         <mn>2</mn>
         <mi>k</mi>
        </msup>
       </mfrac>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <mi>O</mi>
    </mrow>
    <mi>P</mi>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>L</ci>
      <ci>G</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <cn type="integer">2</cn>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <ci>O</ci>
      </apply>
      <ci>P</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle ALG=(1-\frac{1}{2^{k}})\cdot|C|>(1-\frac{1}{2^{k}})\cdot OPT
  </annotation>
 </semantics>
</math>

, so the algorithm finds a 

<math display="inline" id="MAXEkSAT:11">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≥</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mn>2</mn>
       <mi>k</mi>
      </msup>
     </mfrac>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\geq(1-\frac{1}{2^{k}})
  </annotation>
 </semantics>
</math>

 approximation to the true optimal solution in expectation.</p>

<p>Despite its high expectation, this algorithm may occasionally stumble upon solutions of value lower than the expectation we computed above. However, over a large number of trials, the average fraction of satisfied clauses will tend towards 

<math display="inline" id="MAXEkSAT:12">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
    </mfrac>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(1-\frac{1}{2^{k}})
  </annotation>
 </semantics>
</math>

. This implies two things:</p>
<ol>
<li>There must exist an assignment satisfying at least a 

<math display="inline" id="MAXEkSAT:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
    </mfrac>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(1-\frac{1}{2^{k}})
  </annotation>
 </semantics>
</math>

 fraction of the clauses. If there weren't, we could never attain a value this large on average over a large number of trials.</li>
<li>If we run the algorithm a large number of times, at least half of the trials (in expectation) will satisfy some 

<math display="inline" id="MAXEkSAT:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mn>2</mn>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
    </mfrac>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(1-\frac{2}{2^{k}})
  </annotation>
 </semantics>
</math>

 fraction of the clauses. This is because any smaller fraction would bring down the average enough that the algorithm must occasionally satisfy more than 100% of the clauses to get back to its expectation of 

<math display="inline" id="MAXEkSAT:15">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mn>2</mn>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
    </mfrac>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(1-\frac{2}{2^{k}})
  </annotation>
 </semantics>
</math>

, which cannot happen. Extending this using <a href="Markov's_inequality" title="wikilink">Markov's inequality</a>, at least some 

<math display="inline" id="MAXEkSAT:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <msup>
       <mn>2</mn>
       <mi>k</mi>
      </msup>
      <mi>ϵ</mi>
     </mrow>
    </mrow>
   </mfrac>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
      <ci>ϵ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(\frac{1}{1+2^{k}\epsilon})
  </annotation>
 </semantics>
</math>

-fraction of the trials (in expectation) will satisfy at least an 

<math display="inline" id="MAXEkSAT:17">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
    </mfrac>
    <mo>-</mo>
    <mi>ϵ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(1-\frac{1}{2^{k}}-\epsilon)
  </annotation>
 </semantics>
</math>

-fraction of the clauses. Therefore, for any positive 

<math display="inline" id="MAXEkSAT:18">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\epsilon
  </annotation>
 </semantics>
</math>

, it takes only a polynomial number of random trials until we expect to find an assignment satisfying at least an 

<math display="inline" id="MAXEkSAT:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
    </mfrac>
    <mo>-</mo>
    <mi>ϵ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(1-\frac{1}{2^{k}}-\epsilon)
  </annotation>
 </semantics>
</math>

 fraction of the clauses.</li>
</ol>

<p>A more robust analysis (such as that in <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>) shows that we will, in fact, satisfy at least a 

<math display="inline" id="MAXEkSAT:20">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
    </mfrac>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(1-\frac{1}{2^{k}})
  </annotation>
 </semantics>
</math>

-fraction of the clauses a constant fraction of the time (depending only on <em>k</em>), with no loss of 

<math display="inline" id="MAXEkSAT:21">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\epsilon
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="derandomization">Derandomization</h2>

<p>While the above algorithm is efficient, it's not obvious how to remove its dependence on randomness. Trying out all possible random assignments is equivalent to the naive brute force approach, so may take exponential time. One clever way to <a href="derandomization" title="wikilink">derandomize</a> the above in polynomial time relies on work in <a href="error_correcting_codes" title="wikilink">error correcting codes</a>, satisfying a 

<math display="inline" id="MAXEkSAT:22">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
    </mfrac>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(1-\frac{1}{2^{k}})
  </annotation>
 </semantics>
</math>

 fraction of the clauses in time polynomial in the input size (although the exponent depends on <em>k</em>).</p>

<p>We need one definition and two facts to find the algorithm.</p>
<h3 id="definition">Definition</h3>

<p>

<math display="inline" id="MAXEkSAT:23">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq\{0,1\}^{n}
  </annotation>
 </semantics>
</math>

 is an <em>ℓ</em>-wise independent source if, for a uniformly chosen random (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ..., <em>x</em><sub><em>n</em></sub>) ∈ <em>S</em>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ..., <em>x</em><sub><em>n</em></sub> are <a href="pairwise_independence" title="wikilink"><em>ℓ</em>-wise independent</a> random variables.</p>
<h3 id="fact-1">Fact 1</h3>

<p>Note that such an assignment can be found among elements of any <em>ℓ</em>-wise independent source over <em>n</em> binary variables. This is easier to see once you realize that an <em>ℓ</em>-wise independent source is really just any set of binary vectors over {0, 1}<sup><em>n</em></sup> with the property that all restrictions of those vectors to <em>ℓ</em> co-ordinates must present the 2<sup><em>ℓ</em></sup> possible binary combinations an equal number of times.</p>
<h3 id="fact-2">Fact 2</h3>

<p>Recall that BCH<sub>2,<em>m</em>,<em>d</em></sub> is an 

<math display="inline" id="MAXEkSAT:24">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo>=</mo>
    <msup>
     <mn>2</mn>
     <mi>m</mi>
    </msup>
    <mo>,</mo>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">⌈</mo>
     <mi>d</mi>
     <mo>-</mo>
     <mn>2</mn>
     <mo>/</mo>
     <mn>2</mn>
     <mo stretchy="false">⌉</mo>
    </mrow>
    <mi>m</mi>
    <mo>,</mo>
    <mi>d</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">n</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>m</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <minus></minus>
     <cn type="integer">1</cn>
     <minus></minus>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⌈</ci>
      <csymbol cd="unknown">d</csymbol>
      <minus></minus>
      <cn type="integer">2</cn>
      <divide></divide>
      <cn type="integer">2</cn>
      <ci>normal-⌉</ci>
     </cerror>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n=2^{m},n-1-\lceil{d-2}/2\rceil m,d]_{2}
  </annotation>
 </semantics>
</math>

 linear code.</p>

<p>There exists an <em>ℓ</em>-wise independent source of size 

<math display="inline" id="MAXEkSAT:25">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">⌊</mo>
      <mrow>
       <mi mathvariant="normal">ℓ</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">⌋</mo>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <floor></floor>
      <apply>
       <divide></divide>
       <ci>normal-ℓ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{\lfloor\ell/2\rfloor})
  </annotation>
 </semantics>
</math>

, namely the dual of a BCH<sub>2,log <em>n</em>,<em>ℓ</em>+1</sub> code, which is a linear code. Since every <a href="BCH_code" title="wikilink">BCH code</a> can be presented as a polynomial-time computable restriction of a related <a href="Reed_Solomon" title="wikilink">Reed Solomon</a> code, which itself is strongly explicit, there is a polynomial-time algorithm for finding such an assignment to the <em>x</em><sub><em>i</em></sub>'s. The proof of fact 2 can be found at <a href="Dual_of_BCH_is_an_independent_source" title="wikilink">Dual of BCH is an independent source</a>.</p>
<h3 id="outline-of-the-algorithm">Outline of the Algorithm</h3>

<p>The algorithm works by generating BCH<sub>2,log <em>n</em>,<em>ℓ</em>+1</sub>, computing its dual (which as a set is an <em>ℓ</em>-wise independent source) and treating each element (codeword) of that source as a truth assignment to the <em>n</em> variables in <em>φ</em>. At least one of them will satisfy at least 1 − 2<sup>−<em>ℓ</em></sup> of the clauses of <em>φ</em>, whenever <em>φ</em> is in kCNF form, <em>k</em> = <em>ℓ</em>.</p>
<h2 id="related-problems">Related problems</h2>

<p><a class="uri" href="MAX3SAT" title="wikilink">MAX3SAT</a> is a relaxed version of MAXEkSAT, where each clause can have no more than three literals.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/">Coding Theory notes at University at Buffalo</a></li>
<li><a href="http://people.csail.mit.edu/madhu/FT01/course.html">Coding Theory notes at MIT</a></li>
</ul>

<p>"</p>

<p><a href="Category:NP-hard_problems" title="wikilink">Category:NP-hard problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.cs.sfu.ca/CourseCentral/405/abulatov/lectures/18.pdf">Max-SAT</a><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
