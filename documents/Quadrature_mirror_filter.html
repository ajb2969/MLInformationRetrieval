<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1307">Quadrature mirror filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quadrature mirror filter</h1>
<hr/>

<p>In <a href="digital_signal_processing" title="wikilink">digital signal processing</a>, a <strong>quadrature mirror filter</strong> is a filter whose magnitude response is the mirror image around 

<math display="inline" id="Quadrature_mirror_filter:0">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi/2
  </annotation>
 </semantics>
</math>

 of that of another filter. Together these filters are known as the Quadrature Mirror Filter pair.</p>

<p>A filter 

<math display="inline" id="Quadrature_mirror_filter:1">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(z)
  </annotation>
 </semantics>
</math>

 will be quadrature mirror filter of 

<math display="inline" id="Quadrature_mirror_filter:2">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}(z)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Quadrature_mirror_filter:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mi>z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(z)=H_{0}(-z)
  </annotation>
 </semantics>
</math>


</p>

<p>The filter responses are symmetric about 

<math display="inline" id="Quadrature_mirror_filter:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mi>π</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ω</ci>
    <apply>
     <divide></divide>
     <ci>π</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\pi/2
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quadrature_mirror_filter:5">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>H</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>j</mi>
        <mi mathvariant="normal">Ω</mi>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>H</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>j</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>π</mi>
          <mo>-</mo>
          <mi mathvariant="normal">Ω</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>normal-Ω</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <apply>
         <minus></minus>
         <ci>π</ci>
         <ci>normal-Ω</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |H_{1}(e^{j\Omega})|=|H_{0}(e^{j(\pi-\Omega)})|
  </annotation>
 </semantics>
</math>

</p>

<p>In audio/voice codecs, a quadrature mirror filter pair is often used to implement a <a href="filter_bank" title="wikilink">filter bank</a> that splits an input <a href="signal_processing" title="wikilink">signal</a> into two bands. The resulting high-pass and low-pass signals are often reduced by a factor of 2, giving a critically sampled two-channel representation of the original signal. The analysis filters are often related by the following formulae in addition to quadrate mirror property:</p>

<p>

<math display="block" id="Quadrature_mirror_filter:6">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msub>
        <mi>H</mi>
        <mn>0</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>e</mi>
         <mrow>
          <mi>j</mi>
          <mi mathvariant="normal">Ω</mi>
         </mrow>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msub>
        <mi>H</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>e</mi>
         <mrow>
          <mi>j</mi>
          <mi mathvariant="normal">Ω</mi>
         </mrow>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>normal-Ω</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>normal-Ω</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |H_{0}(e^{j\Omega})|^{2}+|H_{1}(e^{j\Omega})|^{2}=1
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Quadrature_mirror_filter:7">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 is the <a class="uri" href="frequency" title="wikilink">frequency</a>, and the sampling rate is normalized to 

<math display="inline" id="Quadrature_mirror_filter:8">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\pi
  </annotation>
 </semantics>
</math>


. This is known as power complementary property. In other words, the power sum of the high-pass and low-pass filters is equal to 1.</p>

<p>Orthogonal <a href="wavelet" title="wikilink">wavelets</a> -- the <a href="Haar_wavelet" title="wikilink">Haar wavelets</a> and related <a href="Daubechies_wavelet" title="wikilink">Daubechies wavelets</a>, <a href="Coiflet" title="wikilink">Coiflets</a>, and some developed by <a href="Stéphane_Mallat" title="wikilink">Mallat</a>, are generated by <a href="Wavelet#Scaling_function" title="wikilink">scaling functions</a> which, with the wavelet, satisfy a quadrature mirror filter relationship.</p>
<h2 id="further-description">Further Description</h2>

<p>The earliest wavelets were based on expanding a function in terms of rectangular steps, the Haar wavelets. This is usually a poor approximation, whereas Daubechies wavelets are among the simplest but most important families of wavelets. A linear filter that is zero for “smooth” signals, given a record of 

<math display="inline" id="Quadrature_mirror_filter:9">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 points 

<math display="inline" id="Quadrature_mirror_filter:10">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

 is defined as:</p>

<p>

<math display="block" id="Quadrature_mirror_filter:11">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>M</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <msub>
      <mi>b</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n}=\sum_{i=0}^{M-1}b_{i}x_{n-i}
  </annotation>
 </semantics>
</math>

</p>

<p>It is desirable to have it vanish for a constant, so taking the order 

<math display="inline" id="Quadrature_mirror_filter:12">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=4
  </annotation>
 </semantics>
</math>

 for example:</p>

<p>

<math display="block" id="Quadrature_mirror_filter:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>0</mn>
     </msub>
     <mo>∙</mo>
     <mn>1</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>∙</mo>
     <mn>1</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo>∙</mo>
     <mn>1</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>3</mn>
     </msub>
     <mo>∙</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-∙</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>normal-∙</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>normal-∙</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>normal-∙</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{0}\centerdot 1+b_{1}\centerdot 1+b_{2}\centerdot 1+b_{3}\centerdot 1=0
  </annotation>
 </semantics>
</math>

 And to have it vanish for a linear ramp so that:</p>

<p>

<math display="block" id="Quadrature_mirror_filter:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>0</mn>
     </msub>
     <mo>∙</mo>
     <mn>0</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>∙</mo>
     <mn>1</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo>∙</mo>
     <mn>2</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>3</mn>
     </msub>
     <mo>∙</mo>
     <mn>3</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-∙</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <ci>normal-∙</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>normal-∙</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ci>normal-∙</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{0}\centerdot 0+b_{1}\centerdot 1+b_{2}\centerdot 2+b_{3}\centerdot 3=0
  </annotation>
 </semantics>
</math>

</p>

<p>A linear filter will vanish for any 

<math display="inline" id="Quadrature_mirror_filter:15">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mi>n</mi>
    </mrow>
    <mo>+</mo>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>n</ci>
     </apply>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\alpha n+\beta
  </annotation>
 </semantics>
</math>

, and this is all that can be done with a fourth order wavelet. Six terms will be needed to vanish a quadratic curve and so on given the other constraints to be included. Next an accompanying filter may be defined as:</p>

<p>

<math display="block" id="Quadrature_mirror_filter:16">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>M</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{n}=\sum_{i=0}^{M-1}c_{i}x_{n-i}
  </annotation>
 </semantics>
</math>

</p>

<p>This filter responds in an exactly opposite manner, being large for smooth signals and small for non-smooth signals. A linear filter is just a convolution of the signal with the filter’s coefficients, so the series of the coefficients is the signal that the filter responds to maximally. Thus, the output of the second filter vanishes when the coefficients of the first one are input into it. The aim is to have:</p>

<p>

<math display="block" id="Quadrature_mirror_filter:17">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>M</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>b</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=0}^{M-1}c_{i}b_{i}=0
  </annotation>
 </semantics>
</math>

</p>

<p>Where the associated time series flips the order of the coefficients because the linear filter is a convolution, and so both have the same index in this sum. A pair of filters with this property are defined as quadrature mirror filters.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Even if the two resulting bands have been subsampled by a factor of 2, the relationship between the filters means that approximately <a href="perfect_reconstruction" title="wikilink">perfect reconstruction</a> is possible. That is, the two bands can then be upsampled, filtered again with the same filters and added together, to reproduce the original signal exactly (but with a small delay). (In practical implementations, numeric precision issues in floating-point arithmetic may affect the perfection of the reconstruction.)</p>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Johnston, JD, A Filter Family Designed for use in Quadrature Mirror Filter Banks. <a href="http://www.info490b.ece.mcgill.ca/Data/Exp4/Johnston.pdf">1</a>, Acoustics, Speech and Signal Processing,IEEE International Conference, 5, 291-294, April, 1980.</li>
<li>Mohlenkamp, M. J, A Tutorial on Wavelets and Their Applications. <a href="http://www.ohio.edu/people/mohlenka/20044/PASIII/waveletIPAM.pdf">2</a>, University of Colorado, Boulder, Dept. of Applied Mathematics, 2004.</li>
<li>Polikar, R, Multiresolution Analysis: The Discrete Wavelet Transform. <a href="http://users.rowan.edu/~polikar/WAVELETS/WTpart4.html">3</a>, Rowan University, NJ, Dept. of Electrical and Computer Engineering</li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a> <a href="Category:Filter_theory" title="wikilink">Category:Filter theory</a> <a class="uri" href="Category:Wavelets" title="wikilink">Category:Wavelets</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
