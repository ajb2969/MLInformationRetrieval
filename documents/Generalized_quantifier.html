<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1814">Generalized quantifier</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Generalized quantifier</h1>
<hr/>

<p>In <a href="linguistics" title="wikilink">linguistic</a> <a class="uri" href="semantics" title="wikilink">semantics</a>, a <strong>generalized quantifier</strong> is an expression that denotes a <a href="Property_(philosophy)" title="wikilink">property</a> of a property, also called a <a class="uri" href="higher-order" title="wikilink">higher-order</a> property. This is the standard semantics assigned to <a href="Quantifier_(linguistics)" title="wikilink">quantified</a> <a href="noun_phrase" title="wikilink">noun phrases</a>, also called <a href="determiner_phrase" title="wikilink">determiner phrases</a>, or DP for short. In the example below, the DP <em>every boy</em> says of a property X that the <a href="set_theory" title="wikilink">set</a> of entities that are <em>boys</em> is a <a class="uri" href="subset" title="wikilink">subset</a> of the set of entities that have property X. So the following sentence says that the set of boys is a subset of the set of sleepers.</p>
<dl>
<dd><dl>
<dd>Every boy sleeps.
</dd>
<dd>

<math display="inline" id="Generalized_quantifier:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mo rspace="4.2pt" stretchy="false">|</mo>
    <mrow>
     <mi>x</mi>
     <mtext>is a boy</mtext>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mo rspace="4.2pt" stretchy="false">|</mo>
    <mrow>
     <mi>x</mi>
     <mtext>sleeps</mtext>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <mtext>is a boy</mtext>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>x</ci>
      <mtext>sleeps</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x\,|\,x\mbox{ is a boy}\}\subseteq\{x\,|\,x\mbox{ sleeps}\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>This treatment of quantifiers has been essential in achieving a <a href="compositionality" title="wikilink">compositional</a> <a class="uri" href="semantics" title="wikilink">semantics</a> for sentences containing quantifiers.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="type-theory">Type theory</h2>

<p>A version of <a href="type_theory" title="wikilink">type theory</a> is often used to make the semantics of different kinds of expressions explicit. The standard construction defines the set of types <a href="recursion" title="wikilink">recursively</a> as follows:</p>
<ol>
<li><em>e</em> and <em>t</em> are types.</li>
<li>If <em>a</em> and <em>b</em> are both types, then so is 

<math display="inline" id="Generalized_quantifier:1">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a,b\rangle
  </annotation>
 </semantics>
</math>

</li>
<li>Nothing is a type, except what can be constructed on the basis of lines 1 and 2 above.</li>
</ol>

<p>Given this definition, we have the simple types <em>e</em> and <em>t</em>, but also a <a class="uri" href="countable" title="wikilink">countable</a> <a class="uri" href="infinity" title="wikilink">infinity</a> of complex types, some of which include:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Generalized_quantifier:2">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo rspace="22.5pt">;</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo rspace="22.5pt">;</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo rspace="22.5pt">;</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo rspace="22.5pt">;</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>e</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo rspace="22.5pt">;</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <list>
     <ci>e</ci>
     <ci>t</ci>
    </list>
    <list>
     <ci>t</ci>
     <ci>t</ci>
    </list>
    <list>
     <list>
      <ci>e</ci>
      <ci>t</ci>
     </list>
     <ci>t</ci>
    </list>
    <list>
     <ci>e</ci>
     <list>
      <ci>e</ci>
      <ci>t</ci>
     </list>
    </list>
    <list>
     <list>
      <ci>e</ci>
      <ci>t</ci>
     </list>
     <list>
      <list>
       <ci>e</ci>
       <ci>t</ci>
      </list>
      <ci>t</ci>
     </list>
    </list>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle e,t\rangle;\qquad\langle t,t\rangle;\qquad\langle\langle e,t\rangle,t%
\rangle;\qquad\langle e,\langle e,t\rangle\rangle;\qquad\langle\langle e,t%
\rangle,\langle\langle e,t\rangle,t\rangle\rangle;\qquad\ldots
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>Expressions of type <em>e</em> denote elements of the <a href="universe_of_discourse" title="wikilink">universe of discourse</a>, the set of entities the discourse is about. This set is usually written as 

<math display="inline" id="Generalized_quantifier:3">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{e}
  </annotation>
 </semantics>
</math>

. Examples of type <em>e</em> expressions include <em>John</em> and <em>he</em>.</li>
<li>Expressions of type <em>t</em> denote a <a href="truth_value" title="wikilink">truth value</a>, usually rendered as the set

<math display="inline" id="Generalized_quantifier:4">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1\}
  </annotation>
 </semantics>
</math>

, where 0 stands for "false" and 1 stands for "true". Examples of expressions that are sometimes said to be of type <em>t</em> are <em>sentences</em> or <em>propositions</em>.</li>
<li>Expressions of type 

<math display="inline" id="Generalized_quantifier:5">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>e</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>e</ci>
    <ci>t</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle e,t\rangle
  </annotation>
 </semantics>
</math>

 denote <a href="Function_(mathematics)" title="wikilink">functions</a> from the set of entities to the set of truth values. This set of functions is rendered as 

<math display="inline" id="Generalized_quantifier:6">
 <semantics>
  <msubsup>
   <mi>D</mi>
   <mi>t</mi>
   <msub>
    <mi>D</mi>
    <mi>e</mi>
   </msub>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}^{D_{e}}
  </annotation>
 </semantics>
</math>

. Such functions are <a href="Indicator_function" title="wikilink">characteristic functions</a> of <a href="Set_(mathematics)" title="wikilink">sets</a>. They map every individual that is an element of the set to "true", and everything else to "false." It is common to say that they denote <em>sets</em> rather than characteristic functions, although, strictly speaking, the latter is more accurate. Examples of expressions of this type are <a href="predicate_(grammar)" title="wikilink">predicates</a>, <a href="noun" title="wikilink">nouns</a> and some kinds of <a href="adjective" title="wikilink">adjectives</a>.</li>
<li>In general, expressions of complex types 

<math display="inline" id="Generalized_quantifier:7">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a,b\rangle
  </annotation>
 </semantics>
</math>

 denote functions from the set of entities of type 

<math display="inline" id="Generalized_quantifier:8">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 to the set of entities of type 

<math display="inline" id="Generalized_quantifier:9">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, a construct we can write as follows

<math display="block" id="Generalized_quantifier:10">
 <semantics>
  <msubsup>
   <mi>D</mi>
   <mi>b</mi>
   <msub>
    <mi>D</mi>
    <mi>a</mi>
   </msub>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{b}^{D_{a}}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>We can now assign types to the words in our sentence above (Every boy sleeps) as follows.</p>
<ul>
<li><ul>
<li>Type(boy)=

<math display="inline" id="Generalized_quantifier:11">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>e</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>e</ci>
    <ci>t</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle e,t\rangle
  </annotation>
 </semantics>
</math>

</li>
<li>Type(sleeps)=

<math display="inline" id="Generalized_quantifier:12">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>e</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>e</ci>
    <ci>t</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle e,t\rangle
  </annotation>
 </semantics>
</math>

</li>
<li>Type(every)= 

<math display="inline" id="Generalized_quantifier:13">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <list>
     <ci>e</ci>
     <ci>t</ci>
    </list>
    <list>
     <list>
      <ci>e</ci>
      <ci>t</ci>
     </list>
     <ci>t</ci>
    </list>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\langle e,t\rangle,\langle\langle e,t\rangle,t\rangle\rangle
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
</ul>

<p>Thus, every denotes a function from a <em>set</em> to a function from a set to a truth value. Put differently, it denotes a function from a set to a set of sets. It is that function which for any two sets <em>A,B</em>, <em>every</em>(<em>A</em>)(<em>B</em>)= 1 if and only if 

<math display="inline" id="Generalized_quantifier:14">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊆</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\subseteq B
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="typed-lambda-calculus">Typed lambda calculus</h2>

<p>A useful way to write complex functions is the <a href="lambda_calculus" title="wikilink">lambda calculus</a>. For example, one can write the meaning of <em>sleeps</em> as the following lambda expression, which is a function from an individual <em>x</em> to the proposition that <em>x sleeps</em>.</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Generalized_quantifier:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>s</mi>
    <mi>l</mi>
    <mi>e</mi>
    <mi>e</mi>
    <msup>
     <mi>p</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>l</ci>
     <ci>e</ci>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.sleep^{\prime}(x)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Such lambda terms are functions whose domain is what precedes the period, and whose range are the type of thing that follows the period. If <em>x</em> is a variable that ranges over elements of 

<math display="inline" id="Generalized_quantifier:16">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{e}
  </annotation>
 </semantics>
</math>

, then the following lambda term denotes the <a href="identity_function" title="wikilink">identity function</a> on individuals:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Generalized_quantifier:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.x
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>We can now write the meaning of <em>every</em> with the following lambda term, where <em>X,Y</em> are variables of type 

<math display="inline" id="Generalized_quantifier:18">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>e</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>e</ci>
    <ci>t</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle e,t\rangle
  </annotation>
 </semantics>
</math>

:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Generalized_quantifier:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>X</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>Y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>X</mi>
    <mo>⊆</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <subset></subset>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda X.\lambda Y.X\subseteq Y
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>If we abbreviate the meaning of <em>boy</em> and <em>sleeps</em> as "<em>B</em>" and "<em>S</em>", respectively, we have that the sentence <em>every boy sleeps</em> now means the following:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Generalized_quantifier:20">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>X</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>Y</mi>
    <mo>.</mo>
    <mi>X</mi>
    <mo>⊆</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">X</csymbol>
     <subset></subset>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda X.\lambda Y.X\subseteq Y)(B)(S)
  </annotation>
 </semantics>
</math>

 — <a href="Lambda_calculus#β-reduction" title="wikilink">β-reduction</a>
</dd>
<dd>

<math display="inline" id="Generalized_quantifier:21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>Y</mi>
    <mo>.</mo>
    <mi>B</mi>
    <mo>⊆</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">B</csymbol>
     <subset></subset>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda Y.B\subseteq Y)(S)
  </annotation>
 </semantics>
</math>

 — β-reduction
</dd>
<dd>

<math display="inline" id="Generalized_quantifier:22">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>⊆</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>B</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\subseteq S
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The expression <em>every</em> is a <a href="determiner_(linguistics)" title="wikilink">determiner</a>. Combined with a <a class="uri" href="noun" title="wikilink">noun</a>, it yields a <em>generalized quantifier</em> of type 

<math display="inline" id="Generalized_quantifier:23">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <list>
     <ci>e</ci>
     <ci>t</ci>
    </list>
    <ci>t</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\langle e,t\rangle,t\rangle
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="properties">Properties</h2>
<h3 id="monotonicity">Monotonicity</h3>
<h4 id="monotone-increasing-gqs">Monotone increasing GQs</h4>

<p>A <em>generalized quantifier</em> GQ is said to be <a href="monotone_increasing" title="wikilink">monotone increasing</a>, also called <a href="upward_entailing" title="wikilink">upward entailing</a>, just in case, for any two sets <em>X</em> and <em>Y</em> the following holds:</p>
<dl>
<dd><dl>
<dd>if 

<math display="inline" id="Generalized_quantifier:24">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊆</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>X</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\subseteq Y
  </annotation>
 </semantics>
</math>

, then GQ(<em>X</em>) <a href="Entailment" title="wikilink">entails</a> GQ(<em>Y</em>).
</dd>
</dl>
</dd>
</dl>

<p>The GQ <em>every boy</em> is monotone increasing. For example, the set of things that <em>run fast</em> is a subset of the set of things that <em>run</em>. Therefore, the first sentence below <a href="Entailment" title="wikilink">entails</a> the second:</p>
<ol>
<li>Every boy runs fast.</li>
<li>Every boy runs.</li>
</ol>
<h4 id="monotone-decreasing-gqs">Monotone decreasing GQs</h4>

<p>A GQ is said to be <a href="monotone_decreasing" title="wikilink">monotone decreasing</a>, also called <a href="downward_entailing" title="wikilink">downward entailing</a> just in case, for any two sets <em>X</em> and <em>Y</em>, the following holds:</p>
<dl>
<dd><dl>
<dd>If 

<math display="inline" id="Generalized_quantifier:25">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊆</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>X</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\subseteq Y
  </annotation>
 </semantics>
</math>

, then GQ(<em>Y</em>) entails GQ(<em>X</em>).
</dd>
</dl>
</dd>
</dl>

<p>An example of a monotone decreasing GQ is <em>no boy</em>. For this GQ we have that the first sentence below entails the second.</p>
<ol>
<li>No boy runs.</li>
<li>No boy runs fast.</li>
</ol>

<p>The lambda term for the <a href="determiner_(linguistics)" title="wikilink">determiner</a> <em>no</em> is the following. It says that the two sets have an empty <a href="Intersection_(set_theory)" title="wikilink">intersection</a>.</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Generalized_quantifier:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>X</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>Y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>∩</mo>
     <mi>Y</mi>
    </mrow>
    <mo>=</mo>
    <mi mathvariant="normal">∅</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <intersect></intersect>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <emptyset></emptyset>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda X.\lambda Y.X\cap Y=\emptyset
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Monotone decreasing GQs are among the expressions that can license a <a href="negative_polarity_item" title="wikilink">negative polarity item</a>, such as <em>any</em>. Monotone increasing GQs do not license negative polarity items.</p>
<ol>
<li>Good: No boy has <strong>any</strong> money.</li>
<li>Bad: *Every boy has <strong>any</strong> money.</li>
</ol>
<h4 id="non-monotone-gqs">Non-monotone GQs</h4>

<p>A GQ is said to be <em>non-monotone</em> if it is neither monotone increasing nor monotone decreasing. An example of such a GQ is <em>exactly three boys</em>. Neither of the following two sentences entail the other.</p>
<ol>
<li>Exactly three students ran.</li>
<li>Exactly three students ran fast.</li>
</ol>

<p>The first sentence doesn't entail the second. The fact that the number of students that ran is exactly three doesn't entail that each of these students <em>ran fast</em>, so the number of students that did that can be smaller than 3. Conversely, the second sentence doesn't entail the first. The sentence <em>exactly three students ran fast</em> can be true, even though the number of students who merely ran (i.e. not so fast) is greater than 3.</p>

<p>The lambda term for the (complex) <a href="determiner_(linguistics)" title="wikilink">determiner</a> <em>exactly three</em> is the following. It says that the <a class="uri" href="cardinality" title="wikilink">cardinality</a> of the <a href="Intersection_(set_theory)" title="wikilink">intersection</a> between the two sets equals 3.</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Generalized_quantifier:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>X</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>Y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>X</mi>
      <mo>∩</mo>
      <mi>Y</mi>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mn>3</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <abs></abs>
      <apply>
       <intersect></intersect>
       <ci>X</ci>
       <ci>Y</ci>
      </apply>
     </apply>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda X.\lambda Y.|X\cap Y|=3
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="conservativity">Conservativity</h3>

<p>A determiner D is said to be <em>conservative</em> if the following equivalence holds:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Generalized_quantifier:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>A</ci>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(A)(B)\leftrightarrow D(A)(A\cap B)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>For example, the following two sentences are equivalent.</p>
<ol>
<li>Every boy sleeps.</li>
<li>Every boy is a boy who sleeps.</li>
</ol>

<p>It has been proposed that <em>all</em> natural language determiners (i.e. in every language) are conservative (Barwise and Cooper 1981). The expression <em>only</em> is not conservative. The following two sentences are not equivalent. But it is, in fact not common to analyze <em>only</em> as a <a href="determiner_(linguistics)" title="wikilink">determiner</a>. Rather, it is standardly treated as a <a class="uri" href="focus-sensitive" title="wikilink">focus-sensitive</a> <a class="uri" href="adverb" title="wikilink">adverb</a>.</p>
<ol>
<li>Only boys sleep.</li>
<li>Only boys are boys who sleep.</li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lindström_quantifier" title="wikilink">Lindström quantifier</a></li>
<li><a href="Branching_quantifier" title="wikilink">Branching quantifier</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Dag Westerståhl, 2011. '<a href="http://plato.stanford.edu/entries/generalized-quantifiers/">Generalized Quantifiers</a>'. <a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Semantics" title="wikilink">Category:Semantics</a> <a class="uri" href="Category:Quantification" title="wikilink">Category:Quantification</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Montague, Richard: 1974, '<a href="http://www.blackwellpublishing.com/content/BPL_Images/Content_store/Sample_chapter/9780631215417/Portner.pdf">The proper treatment of quantification in English</a>', in R. Montague, Formal Philosophy, ed. by R. Thomason (New Haven).<a href="#fnref1">↩</a></li>
<li id="fn2">Barwise, Jon and Robin Cooper. 1981. Generalized quantifiers and natural language. <em>Linguistics and Philosophy</em> 4: 159-219.<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
