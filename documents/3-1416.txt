   Eigenvalue algorithm      Eigenvalue algorithm  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     In numerical analysis , one of the most important problems is designing efficient and stable  algorithms for finding the eigenvalues of a matrix . These eigenvalue algorithms may also find eigenvectors .  Eigenvalues and eigenvectors  Given an    n  ×  n      n  normal-×  n    n×n    square matrix    A   A   A   of real or complex numbers, an eigenvalue    λ   λ   λ   and its associated generalized eigenvector    𝐯   𝐯   \mathbf{v}   are a pair obeying the relation 1          (   A  -   λ  I    )   k   𝕧   =  0   ,         superscript    A    λ  I    k   𝕧   0    \left(A-\lambda I\right)^{k}{\mathbb{v}}=0,     where   𝐯   𝐯   \mathbf{v}   is a nonzero    n  ×  1      n  normal-×  1    n×1   column vector,   I   I   I   is the    n  ×  n      n  normal-×  n    n×n    identity matrix ,   k   k   k   is a positive integer, and both   λ   λ   λ   and   𝐯   𝐯   \mathbf{v}   are allowed to be complex even when   A   A   A   is real. When    k  =  1      k  1    k=1   , the vector is called simply an eigenvector , and the pair is called an eigenpair . In this case,     A  𝐯   =   λ  𝐯         A  𝐯     λ  𝐯     A\mathbf{v}=λ\mathbf{v}   . Any eigenvalue   λ   λ   λ   of   A   A   A   has ordinary 2 eigenvectors associated to it, for if   k   k   k   is the smallest integer such that for a generalized eigenvector   𝐯   𝐯   \mathbf{v}   , then is an ordinary eigenvector. The value   k   k   k   can always be taken as less than or equal to   n   n   n   . In particular, for all generalized eigenvectors   𝐯   𝐯   \mathbf{v}   associated with    λ  .    λ   λ.     For each eigenvalue   λ   λ   λ   of   A   A   A   , the kernel     k  e  r   (   A  -   λ  I    )       k  e  r    A    λ  I      ker(A-λI)   consists of all eigenvectors associated with   λ   λ   λ   (along with 0), called the eigenspace of   λ   λ   λ   , while the vector space consists of all generalized eigenvectors, and is called the generalized eigenspace . The geometric multiplicity of   λ   λ   λ   is the dimension of its eigenspace. The algebraic multiplicity of   λ   λ   λ   is the dimension of its generalized eigenspace. The latter terminology is justified by the equation         p  A    (  z  )    =   det   (    z  I   -  A   )    =    ∏   i  =  1   k     (   z  -   λ  i    )    α  i      ,           subscript  p  A   z     det      z  I   A           superscript   subscript  product    i  1    k    superscript    z   subscript  λ  i     subscript  α  i        p_{A}\left(z\right)={\rm det}\left(zI-A\right)=\prod_{i=1}^{k}(z-\lambda_{i})^%
 {\alpha_{i}},     where    d  e  t      d  e  t    det   is the determinant function, the are all the distinct eigenvalues of   A   A   A   and the are the corresponding algebraic multiplicities. The function is the characteristic polynomial of   A   A   A   . So the algebraic multiplicity is the multiplicity of the eigenvalue as a zero of the characteristic polynomial. Since any eigenvector is also a generalized eigenvector, the geometric multiplicity is less than or equal to the algebraic multiplicity. The algebraic multiplicities sum up to   n   n   n   , the degree of the characteristic polynomial. The equation is called the characteristic equation , as its roots are exactly the eigenvalues of   A   A   A   . By the Cayley-Hamilton theorem ,   A   A   A   itself obeys the same equation: 3 As a consequence, the columns of the matrix     ∏   i  ≠  j      (   A  -    λ  i   I    )    α  i        subscript  product    i  j     superscript    A     subscript  λ  i   I     subscript  α  i      \textstyle\prod_{i\neq j}(A-\lambda_{i}I)^{\alpha_{i}}   must be either 0 or generalized eigenvectors of the eigenvalue , since they are annihilated by      (   A  -    λ  j   I    )    α  j    .     superscript    A     subscript  λ  j   I     subscript  α  j     \textstyle(A-\lambda_{j}I)^{\alpha_{j}}.   In fact, the column space is the generalized eigenspace of  Any collection of generalized eigenvectors of distinct eigenvalues is linearly independent, so a basis for all of can be chosen consisting of generalized eigenvectors. More particularly, this basis v i {{)}}1}}}} can be chosen and organized so that  :* if and have the same eigenvalue, then so does for each   k   k   k   between   i   i   i   and   j   j   j   , and  :* if is not an ordinary eigenvector, and if is its eigenvalue, then (in particular, must be an ordinary eigenvector). If these basis vectors are placed as the column vectors of a matrix [ v 1  v 2 ... v n ]}} , then   V   V   V   can be used to convert   A   A   A   to its Jordan normal form :         V   -  1    A  V   =   [      λ  1      β  1     0    …    0      0     λ  2      β  2     …    0      0    0     λ  3     …    0      ⋮    ⋮    ⋮    ⋱    ⋮      0    0    0    …     λ  n      ]    ,         superscript  V    1    A  V      subscript  λ  1    subscript  β  1   0  normal-…  0    0   subscript  λ  2    subscript  β  2   normal-…  0    0  0   subscript  λ  3   normal-…  0    normal-⋮  normal-⋮  normal-⋮  normal-⋱  normal-⋮    0  0  0  normal-…   subscript  λ  n       V^{-1}AV=\begin{bmatrix}\lambda_{1}&\beta_{1}&0&\ldots&0\\
 0&\lambda_{2}&\beta_{2}&\ldots&0\\
 0&0&\lambda_{3}&\ldots&0\\
 \vdots&\vdots&\vdots&\ddots&\vdots\\
 0&0&0&\ldots&\lambda_{n}\end{bmatrix},     where the are the eigenvalues, if and otherwise.  More generally, if   W   W   W   is any invertible matrix, and   λ   λ   λ   is an eigenvalue of   A   A   A   with generalized eigenvector   𝐯   𝐯   \mathbf{v}   , then . Thus   λ   λ   λ   is an eigenvalue of with generalized eigenvector . That is, similar matrices have the same eigenvalues.  Normal, hermitian, and real-symmetric matrices  The adjoint  of a complex matrix   M   M   M   is the transpose of the conjugate of   M   M   M   : . A square matrix   A   A   A   is called normal if it commutes with its adjoint: . It is called hermitian if it is equal to its adjoint: . All hermitian matrices are normal. If   A   A   A   has only real elements, then the adjoint is just the transpose, and   A   A   A   is hermitian if and only if it is symmetric . When applied to column vectors, the adjoint can be used to define the canonical inner product on : . 4 Normal, hermitian, and real-symmetric matrices have several useful properties:  :* Every generalized eigenvector of a normal matrix is an ordinary eigenvector.  :* Any normal matrix is similar to a diagonal matrix, since its Jordan normal form is diagonal.  :* Eigenvectors of distinct eigenvalues of a normal matrix are orthogonal.  :* For any normal matrix   A   A   A   , has an orthonormal basis consisting of eigenvectors of   A   A   A   . The corresponding matrix of eigenvectors is unitary .  :* The eigenvalues of a hermitian matrix are real, since for a non-zero eigenvector   𝐯   𝐯   \mathbf{v}   .  :* If   A   A   A   is real, there is an orthonormal basis for consisting of eigenvectors of   A   A   A   if and only if   A   A   A   is symmetric.  It is possible for a real or complex matrix to have all real eigenvalues without being hermitian. For example, a real triangular matrix has its eigenvalues along its diagonal, but in general is not symmetric.  Condition number  Any problem of numeric calculation can be viewed as the evaluation of some function ƒ for some input   x   x   x   . The condition number     κ   (  ƒ  ,  x  )       κ   ƒ  x     κ(ƒ,x)   of the problem is the ratio of the relative error in the function's output to the relative error in the input, and varies with both the function and the input. The condition number describes how error grows during the calculation. Its base-10 logarithm tells how many fewer digits of accuracy exist in the result than existed in the input. The condition number is a best-case scenario. It reflects the instability built into the problem, regardless of how it is solved. No algorithm can ever produce more accurate results than indicated by the condition number, except by chance. However, a poorly designed algorithm may produce significantly worse results. For example, as mentioned below, the problem of finding eigenvalues for normal matrices is always well-conditioned. However, the problem of finding the roots of a polynomial can be very ill-conditioned . Thus eigenvalue algorithms that work by finding the roots of the characteristic polynomial can be ill-conditioned even when the problem is not.  For the problem of solving the linear equation     A  𝐯   =  𝐛        A  𝐯   𝐛    A\mathbf{v}=\mathbf{b}   where   A   A   A   is invertible, the condition number is given by A {{!!}} op {{!!}} A −1 {{!!}} op }} , where {{!!}} op }} is the operator norm subordinate to the normal Euclidean norm on . Since this number is independent of   𝐛   𝐛   \mathbf{b}   and is the same for   A   A   A   and , it is usually just called the condition number    κ   (  A  )       κ  A    κ(A)   of the matrix   A   A   A   . This value    κ   (  A  )       κ  A    κ(A)   is also the absolute value of the ratio of the largest eigenvalue of   A   A   A   to its smallest. If   A   A   A   is unitary , then A {{!!}} op = {{!!}} A −1 {{!!}} op = 1}} , so     κ   (  A  )    =  1        κ  A   1    κ(A)=1   . For general matrices, the operator norm is often difficult to calculate. For this reason, other matrix norms are commonly used to estimate the condition number.  For the eigenvalue problem, Bauer and Fike proved that if   λ   λ   λ   is an eigenvalue for a diagonalizable     n  ×  n      n  normal-×  n    n×n   matrix   A   A   A   with eigenvector matrix   V   V   V   , then the absolute error in calculating   λ   λ   λ   is bounded by the product of    κ   (  V  )       κ  V    κ(V)   and the absolute error in   A   A   A   . 5  As a result , the condition number for finding   λ   λ   λ   is V {{!!}} op {{!!}} V  −1 {{!!}} op }} . If   A   A   A   is normal, then   V   V   V   is unitary, and     κ   (  λ  ,  A  )    =  1        κ   λ  A    1    κ(λ,A)=1   . Thus the eigenvalue problem for all normal matrices is well-conditioned.  The condition number for the problem of finding the eigenspace of a normal matrix   A   A   A   corresponding to an eigenvalue   λ   λ   λ   has been shown to be inversely proportional to the minimum distance between   λ   λ   λ   and the other distinct eigenvalues of   A   A   A   . 6 In particular, the eigenspace problem for normal matrices is well-conditioned for isolated eigenvalues. When eigenvalues are not isolated, the best that can be hoped for is to identify the span of all eigenvectors of nearby eigenvalues.  Algorithms  Any monic polynomial is the characteristic polynomial of its companion matrix . Therefore a general algorithm for finding eigenvalues could also be used to find the roots of polynomials. The Abel-Ruffini theorem shows that any such algorithm for dimensions greater than 4 must either be infinite, or involve functions of greater complexity than elementary arithmetic operations and fractional powers. For this reason algorithms that exactly calculate eigenvalues in a finite number of steps only exist for a few special classes of matrices. For general matrices, algorithms are iterative , producing better approximate solutions with each iteration.  Some algorithms produce every eigenvalue, others will produce a few, or only one. However, even the latter algorithms can be used to find all eigenvalues. Once an eigenvalue   λ   λ   λ   of a matrix   A   A   A   has been identified, it can be used to either direct the algorithm towards a different solution next time, or to reduce the problem to one that no longer has   λ   λ   λ   as a solution.  Redirection is usually accomplished by shifting: replacing   A   A   A   with    A  -   μ  I       A    μ  I     A-μI   for some constant   μ   μ   μ   . The eigenvalue found for    A  -   μ  I       A    μ  I     A-μI   must have   μ   μ   μ   added back in to get an eigenvalue for   A   A   A   . For example, for power iteration ,    μ  =  λ      μ  λ    μ=λ   . Power iteration finds the largest eigenvalue in absolute value, so even when   λ   λ   λ   is only an approximate eigenvalue, power iteration is unlikely to find it a second time. Conversely, inverse iteration based methods find the lowest eigenvalue, so   μ   μ   μ   is chosen well away from   λ   λ   λ   and hopefully closer to some other eigenvalue.  Reduction can be accomplished by restricting   A   A   A   to the column space of the matrix    A  -   λ  I       A    λ  I     A-λI   , which   A   A   A   carries to itself. Since    A  -   λ  I       A    λ  I     A-λI   is singular, the column space is of lesser dimension. The eigenvalue algorithm can then be applied to the restricted matrix. This process can be repeated until all eigenvalues are found.  If an eigenvalue algorithm does not produce eigenvectors, a common practice is to use an inverse iteration based algorithm with   μ   μ   μ   set to a close approximation to the eigenvalue. This will quickly converge to the eigenvector of the closest eigenvalue to   μ   μ   μ   . For small matrices, an alternative is to look at the column space of the product of    A  -   λ  I       A    λ  I     A-λI   for each of the other eigenvalues    λ  .  .     fragments  λ  normal-.  normal-.    λ{{.}}.     Hessenberg and Tri-diagonal matrices  Because the eigenvalues of a triangular matrix are its diagonal elements, for general matrices there is no finite method like gaussian elimination to convert a matrix to triangular form while preserving eigenvalues. But it is possible to reach something close to triangular. An upper Hessenberg matrix is a square matrix for which all entries below the subdiagonal are zero. A lower Hessenberg matrix is one for which all entries above the superdiagonal are zero. Matrices that are both upper and lower Hessenberg are tridiagonal . Hessenberg and tridiagonal matrices are the starting points for many eigenvalue algorithms because the zero entries reduce the complexity of the problem. Several methods are commonly used to convert a general matrix into a Hessenberg matrix with the same eigenvalues. If the original matrix was symmetric or hermitian, then the resulting matrix will be tridiagonal.  When only eigenvalues are needed, there is no need to calculate the similarity matrix, as the transformed matrix has the same eigenvalues. If eigenvectors are needed as well, the similarity matrix may be needed to transform the eigenvectors of the Hessenberg matrix back into eigenvectors of the original matrix.      Method   Applies to   Produces   Cost without similarity matrix   Cost with similarity matrix   Description       Householder transformations   General   Hessenberg   {{cite book   last1 = Press   first1 = William H.     Givens rotations   General   Hessenberg   7    Apply planar rotations to zero out individual entries. Rotations are ordered so that later ones do not cause zero entries to become non-zero again.     Arnoldi iteration   General   Hessenberg     Perform Gram–Schmidt orthogonalization on Krylov subspaces.     Lanczos algorithm   Hermitian   Tridiagonal     Arnoldi iteration for hermitian matrices, with shortcuts.     Iterative algorithms  Iterative algorithms solve the eigenvalue problem by producing sequences that converge to the eigenvalues. Some algorithms also produce sequences of vectors that converge to the eigenvectors. Most commonly, the eigenvalue sequences are expressed as sequences of similar matrices which converge to a triangular or diagonal form, allowing the eigenvalues to be read easily. The eigenvector sequences are expressed as the corresponding similarity matrices.      Method   Applies to   Produces   Cost per step   Convergence   Description       Power iteration   General   eigenpair with largest value     Linear   Repeatedly applies the matrix to an arbitrary starting vector and renormalizes.     Inverse iteration   General     Linear   Power iteration for     Rayleigh quotient iteration   Hermitian   eigenpair with value closest to μ    Cubic   Power iteration for where for each iteration is the Rayleigh quotient of the previous iteration.     Preconditioned Inverse iteration {{Citation   last=Neymeyr   first=K.   title=A geometric theory for preconditioned inverse iteration IV: On the fastest convergence cases.   journal=Linear Algebra Appl.   volume=415     Bisection method   Real Symmetric Tridiagonal   any eigenvalue    linear   Uses the bisection method to find roots of the characteristic polynomial, supported by the Sturm sequence.     Laguerre iteration   Real Symmetric Tridiagonal   any eigenvalue    cubic {{Citation   last1=Li     QR algorithm   Hessenberg   all eigenvalues     cubic   align="left" Factors A = QR , where Q is orthogonal and R is triangular, then applies the next iteration to RQ .     all eigenpairs       Jacobi eigenvalue algorithm   Real Symmetric   all eigenvalues     quadratic   Uses Givens rotations to attempt clearing all off-diagonal entries. This fails, but strengthens the diagonal.     Divide-and-conquer   Hermitian Tridiagonal   all eigenvalues      align="left" Divides the matrix into submatrices that are diagonalized then recombined.     all eigenpairs       Homotopy method   Real Symmetric Tridiagonal   all eigenpairs   {{math| O ( n 2 ) {{Citation   last=Chu   first=Moody T.     Folded spectrum method   Real Symmetric   eigenpair with value closest to μ     Preconditioned inverse iteration applied to     MRRR algorithm {{Citation   last1=Dhillon   first1=Inderjit S.   last2=Parlett   first2=Beresford N.   last3=Vömel     Direct calculation  While there is no simple algorithm to directly calculate eigenvalues for general matrices, there are numerous special classes of matrices where eigenvalues can be directly calculated. These include:  Triangular matrices  Since the determinant of a triangular matrix is the product of its diagonal entries, if T is triangular, then  Thus the eigenvalues of T are its diagonal entries.  Factorable polynomial equations  If   p   p   p   is any polynomial and      p   (  A  )    =  0   ,        p  A   0    p(A)=0,   then the eigenvalues of   A   A   A   also satisfy the same equation. If   p   p   p   happens to have a known factorization, then the eigenvalues of   A   A   A   lie among its roots.  For example, a projection is a square matrix   P   P   P   satisfying . The roots of the corresponding scalar polynomial equation, , are 0 and 1. Thus any projection has 0 and 1 for its eigenvalues. The multiplicity of 0 as an eigenvalue is the nullity of   P   P   P   , while the multiplicity of 1 is the rank of   P   P   P   .  Another example is a matrix   A   A   A   that satisfies for some scalar   α   α   α   . The eigenvalues must be    ±  α      normal-±  α    ±α   . The projection operators       P  +   =    1  2    (   I  +   A  α    )         subscript  P        1  2     I    A  α       P_{+}=\frac{1}{2}\left(I+\frac{A}{\alpha}\right)          P  -   =    1  2    (   I  -   A  α    )         subscript  P        1  2     I    A  α       P_{-}=\frac{1}{2}\left(I-\frac{A}{\alpha}\right)   satisfy        A   P  +    =   α   P  +       A   P  -    =   -   α   P  -         formulae-sequence      A   subscript  P       α   subscript  P          A   subscript  P         α   subscript  P         AP_{+}=\alpha P_{+}\quad AP_{-}=-\alpha P_{-}   and         P  +    P  +    =   P  +        P  -    P  -    =   P  -       P  +    P  -    =    P  -    P  +    =  0.       formulae-sequence       subscript  P     subscript  P      subscript  P      formulae-sequence       subscript  P     subscript  P      subscript  P            subscript  P     subscript  P        subscript  P     subscript  P          0.       P_{+}P_{+}=P_{+}\quad P_{-}P_{-}=P_{-}\quad P_{+}P_{-}=P_{-}P_{+}=0.     The column spaces of and are the eigenspaces of   A   A   A   corresponding to    +  α      α    +α   and    -  α      α    -α   , respectively.  2×2 matrices  For dimensions 2 through 4, formulas involving radicals exist that can be used to find the eigenvalues. While a common practice for 2×2 and 3×3 matrices, for 4×4 matrices the increasing complexity of the root formulas makes this approach less attractive.  For the 2×2 matrix       A  =   [     a    b      c    d     ]    ,      A    a  b    c  d      A=\begin{bmatrix}a&b\\
 c&d\end{bmatrix},     the characteristic polynomial is        det   [      λ  -  a      -  b        -  c      λ  -  d      ]    =      λ  2    -    (   a  +  d   )    λ     +   (    a  d   -   b  c    )    =      λ  2    -    λ   tr   (  A  )     +   det   (  A  )      .          det      λ  a     b       c     λ  d           superscript  λ  2       a  d   λ        a  d     b  c               superscript  λ  2     λ  tr  A      det  A       {\rm det}\begin{bmatrix}\lambda-a&-b\\
 -c&\lambda-d\end{bmatrix}=\lambda^{2}\,-\,\left(a+d\right)\lambda\,+\,\left(ad%
 -bc\right)=\lambda^{2}\,-\,\lambda\,{\rm tr}(A)\,+\,{\rm det}(A).     Thus the eigenvalues can be found by using the quadratic formula :       λ  =     tr   (  A  )    ±      tr  2    (  A  )    -   4  d  e  t   (  A  )       2    .      λ     plus-or-minus    tr  A          superscript  tr  2   A     4  normal-d  normal-e  normal-t  A      2     \lambda=\frac{{\rm tr}(A)\pm\sqrt{{\rm tr}^{2}(A)-4{\rm det}(A)}}{2}.     Defining     gap   (  A  )    =      tr  2    (  A  )    -   4  d  e  t   (  A  )            gap  A          superscript  tr  2   A     4  normal-d  normal-e  normal-t  A       \textstyle{\rm gap}\left(A\right)=\sqrt{{\rm tr}^{2}(A)-4{\rm det}(A)}   to be the distance between the two eigenvalues, it is straightforward to calculate        P
                             a
                             r
                             t
                              
                             I
                           
                           λ
                         
                         
                           
                             I
                           
                           λ  P
                             a
                             r
                             t
                              
                             I
                             I
                           
                           a
                         
                         
                           
                             I
                             I
                           
                           a   =    1  2    (   1  ±    a  -  d    gap   (  A  )      )     ,    P
                             a
                             r
                             t
                              
                             I
                             I
                             I
                           
                           λ
                         
                         
                           
                             I
                             I
                             I
                           
                           λ  P
                             a
                             r
                             t
                              
                             I
                             V
                           
                           b
                         
                         
                           
                             I
                             V
                           
                           b   =    ±  c    gap   (  A  )         formulae-sequence      P
                             a
                             r
                             t
                              
                             I
                           
                           λ
                         
                         
                           
                             I
                           
                           λ  P
                             a
                             r
                             t
                              
                             I
                             I
                           
                           a
                         
                         
                           
                             I
                             I
                           
                           a       1  2    plus-or-minus  1      a  d     gap  A           P
                             a
                             r
                             t
                              
                             I
                             I
                             I
                           
                           λ
                         
                         
                           
                             I
                             I
                             I
                           
                           λ  P
                             a
                             r
                             t
                              
                             I
                             V
                           
                           b
                         
                         
                           
                             I
                             V
                           
                           b      plus-or-minus  c     gap  A       \frac{\@@section{part}{Pt1}{I}{Part~I}{{\@tag[][]{I}\lambda}}{{\@tag[][]{Part~%
 I}\lambda}}}{\@@section{part}{Pt2}{II}{Part~II}{{\@tag[][]{II}a}}{{\@tag[][]{%
 Part~II}a}}}=\frac{1}{2}\left(1\pm\frac{a-d}{{\rm gap}(A)}\right),\qquad\frac{%
 \@@section{part}{Pt3}{III}{Part~III}{{\@tag[][]{III}\lambda}}{{\@tag[][]{Part~%
 III}\lambda}}}{\@@section{part}{Pt4}{IV}{Part~IV}{{\@tag[][]{IV}b}}{{\@tag[][]%
 {Part~IV}b}}}=\frac{\pm c}{{\rm gap}(A)}     with similar formulas for   c   c   c   and   d   d   d   . From this it follows that the calculation is well-conditioned if the eigenvalues are isolated.  Eigenvectors can be found by exploiting the Cayley-Hamilton theorem . If are the eigenvalues, then , so the columns of are annihilated by and vice versa. Assuming neither matrix is zero, the columns of each must include eigenvectors for the other eigenvalue. (If either matrix is zero, then   A   A   A   is a multiple of the identity and any non-zero vector is an eigenvector.)  For example, suppose       A  =   [     4    3       -  2      -  3      ]    ,      A    4  3      2     3       A=\begin{bmatrix}4&3\\
 -2&-3\end{bmatrix},     then     t  r   (  A  )    =   4  -  3   =  1          t  r  A     4  3        1     tr(A)=4-3=1   and     d  e  t   (  A  )    =    4   (   -  3   )    -   3   (   -  2   )     =   -  6           d  e  t  A       4    3      3    2            6      det(A)=4(-3)-3(-2)=-6   , so the characteristic equation is       0  =    λ  2   -  λ  -  6   =    (   λ  -  3   )    (   λ  +  2   )     ,        0     superscript  λ  2   λ  6            λ  3     λ  2       0=\lambda^{2}-\lambda-6=(\lambda-3)(\lambda+2),     and the eigenvalues are 3 and -2. Now,         A  -   3  I    =   [     1    3       -  2      -  6      ]    ,    A  +   2  I    =   [     6    3       -  2      -  1      ]     .     formulae-sequence      A    3  I      1  3      2     6          A    2  I      6  3      2     1        A-3I=\begin{bmatrix}1&3\\
 -2&-6\end{bmatrix},\qquad A+2I=\begin{bmatrix}6&3\\
 -2&-1\end{bmatrix}.     In both matrices, the columns are multiples of each other, so either column can be used. Thus,    (  1  ,   -  2   )     1    2     (1,-2)   can be taken as an eigenvector associated with the eigenvalue -2, and    (  3  ,   -  1   )     3    1     (3,-1)   as an eigenvector associated with the eigenvalue 3, as can be verified by multiplying them by   A   A   A   .  3×3 matrices  If   A   A   A   is a 3×3 matrix, then its characteristic equation can be expressed as:       det   (    α  I   -  A   )    =    α  3   -    α  2   tr   (  A  )    -   α   1  2    (    tr   (   A  2   )    -    tr  2    (  A  )     )    -   det   (  A  )     =  0.          det      α  I   A       superscript  α  3      superscript  α  2   tr  A     α    1  2       tr   superscript  A  2       superscript  tr  2   A       det  A         0.     {\rm det}\left(\alpha I-A\right)=\alpha^{3}-\alpha^{2}{\rm tr}(A)-\alpha\frac{%
 1}{2}\left({\rm tr}(A^{2})-{\rm tr}^{2}(A)\right)-{\rm det}(A)=0.     This equation may be solved using the methods of Cardano or Lagrange , but an affine change to   A   A   A   will simplify the expression considerably, and lead directly to a trigonometric solution . If    A  =    p  B   +   q  I        A      p  B     q  I      A=pB+qI   , then   A   A   A   and   B   B   B   have the same eigenvectors, and   β   β   β   is an eigenvalue of   B   B   B   if and only if    α  =    p  β   +  q       α      p  β   q     α=pβ+q   is an eigenvalue of   A   A   A   . Letting    q  =    tr   (  A  )    /  3       q      tr  A   3     \textstyle q={\rm tr}(A)/3   and    p  =   tr    (     (   A  -   q  I    )   2   /  6   )    1  /  2         p    tr   superscript     superscript    A    q  I    2   6     1  2       \textstyle p={\rm tr}\left((A-qI)^{2}/6\right)^{1/2}   , gives       det   (    β  I   -  B   )    =    β  3   -   3  β   -   det   (  B  )     =  0.          det      β  I   B       superscript  β  3     3  β     det  B         0.     {\rm det}\left(\beta I-B\right)=\beta^{3}-3\beta-{\rm det}(B)=0.     The substitution    β  =   2  c  o  s  θ       β    2  c  o  s  θ     β=2cosθ   and some simplification using the identity reduces the equation to     c  o  s  3  θ   =    d  e  t   (  B  )    /  2         c  o  s  3  θ       d  e  t  B   2     cos3θ=det(B)/2   . Thus       β  =   2  c  o  s   (     1  3   arccos   (    det   (  B  )    /  2   )    +    2  k  π   3    )     ,   k  =   0  ,  1  ,  2.       formulae-sequence    β    2  normal-c  normal-o  normal-s        1  3   arccos      det  B   2        2  k  π   3        k   0  1  2.      \beta=2{\rm cos}\left(\frac{1}{3}{\rm arccos}\left({\rm det}(B)/2\right)+\frac%
 {2k\pi}{3}\right),\quad k=0,1,2.     If    d  e  t   (  B  )       d  e  t  B    det(B)   is complex or is greater than 2 in absolute value, the arccosine should be taken along the same branch for all three values of   k   k   k   . This issue doesn't arise when   A   A   A   is real and symmetric, resulting in a simple algorithm: 8  % Given a real symmetric 3x3 matrix A, compute the eigenvalues p1 = A( 1 , 2 )^ 2 + A( 1 , 3 )^ 2 + A( 2 , 3 )^ 2 if (p1 == 0 ) % A is diagonal. eig1 = A( 1 , 1 )
    eig2 = A( 2 , 2 )
    eig3 = A( 3 , 3 )
 else
    q = trace(A)/ 3 p2 = (A( 1 , 1 ) - q)^ 2 + (A( 2 , 2 ) - q)^ 2 + (A( 3 , 3 ) - q)^ 2 + 2 * p1
    p = sqrt(p2 / 6 )
    B = ( 1 / p) * (A - q * I) % I is the identity matrix r = det(B) / 2  % In exact arithmetic for a symmetric matrix  -1 <= r <= 1  % but computation error can leave it slightly outside this range. if (r <= - 1 ) 
       phi = pi / 3 elseif (r >= 1 )
       phi = 0 else
       phi = acos(r) / 3 end % the eigenvalues satisfy eig3 <= eig2 <= eig1 eig1 = q + 2 * p * cos(phi)
    eig3 = q + 2 * p * cos(phi + ( 2 *pi/ 3 ))
    eig2 = 3 * q - eig1 - eig3 % since trace(A) = eig1 + eig2 + eig3 end  Once again, the eigenvectors of   A   A   A   can be obtained by recourse to the Cayley-Hamilton theorem . If are distinct eigenvalues of   A   A   A   , then . Thus the columns of the product of any two of these matrices will contain an eigenvector for the third eigenvalue. However, if , then and . Thus the generalized eigenspace of is spanned by the columns of while the ordinary eigenspace is spanned by the columns of . The ordinary eigenspace of is spanned by the columns of .  For example, let       A  =   [     3    2    6      2    2    5       -  2      -  1      -  4      ]    .      A    3  2  6    2  2  5      2     1     4       A=\begin{bmatrix}3&2&6\\
 2&2&5\\
 -2&-1&-4\end{bmatrix}.     The characteristic equation is       0  =     λ  3   -   λ  2   -  λ   +  1   =     (   λ  -  1   )   2    (   λ  +  1   )     ,        0       superscript  λ  3    superscript  λ  2   λ   1           superscript    λ  1   2     λ  1       0=\lambda^{3}-\lambda^{2}-\lambda+1=(\lambda-1)^{2}(\lambda+1),     with eigenvalues 1 (of multiplicity 2) and -1. Calculating,        A  -  I   =   [     2    2    6      2    1    5       -  2      -  1      -  5      ]    ,    A  +  I   =   [     4    2    6      2    3    5       -  2      -  1      -  3      ]       formulae-sequence      A  I     2  2  6    2  1  5      2     1     5          A  I     4  2  6    2  3  5      2     1     3        A-I=\begin{bmatrix}2&2&6\\
 2&1&5\\
 -2&-1&-5\end{bmatrix},\qquad A+I=\begin{bmatrix}4&2&6\\
 2&3&5\\
 -2&-1&-3\end{bmatrix}     and         (   A  -  I   )   2   =   [      -  4     0     -  8        -  4     0     -  8       4    0    8     ]    ,     (   A  -  I   )    (   A  +  I   )    =   [     0    4    4      0    2    2      0     -  2      -  2      ]       formulae-sequence     superscript    A  I   2       4   0    8       4   0    8     4  0  8           A  I     A  I      0  4  4    0  2  2    0    2     2        (A-I)^{2}=\begin{bmatrix}-4&0&-8\\
 -4&0&-8\\
 4&0&8\end{bmatrix},\qquad(A-I)(A+I)=\begin{bmatrix}0&4&4\\
 0&2&2\\
 0&-2&-2\end{bmatrix}     Thus    (   -  4   ,   -  4   ,  4  )       4     4   4    (-4,-4,4)   is an eigenvector for -1, and    (  4  ,  2  ,   -  2   )     4  2    2     (4,2,-2)   is an eigenvector for 1.    (  2  ,  3  ,   -  1   )     2  3    1     (2,3,-1)   and    (  6  ,  5  ,   -  3   )     6  5    3     (6,5,-3)   are both generalized eigenvectors associated with 1, either one of which could be combined with    (   -  4   ,   -  4   ,  4  )       4     4   4    (-4,-4,4)   and    (  4  ,  2  ,   -  2   )     4  2    2     (4,2,-2)   to form a basis of generalized eigenvectors of   A   A   A   .In some routine eigenvectors are normalized to one, in such case make sure you normalized by column.  See also   List of eigenvalue algorithms   Notes  References  Further reading     "  Category:Numerical linear algebra     ↩  The term "ordinary" is used here only to emphasize the distinction between "eigenvector" and "generalized eigenvector". ↩  where the constant term is multiplied by the identity matrix   I   I   I   . ↩  This ordering of the inner product (with the conjugate-linear position on the left), is preferred by physicists. Algebraists often place the conjugate-linear position on the right: . ↩  ↩  ↩   ↩    