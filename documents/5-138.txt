   Newton's method in optimization      Newton's method in optimization   (Figure)  A comparison of gradient descent (green) and Newton's method (red) for minimizing a function (with small step sizes). Newton's method uses curvature information to take a more direct route.   In calculus , Newton's method is an iterative method for finding the roots of a differentiable function    f   f   f   (i.e. solutions to the equation      f   (  x  )    =  0        f  x   0    f(x)=0   ). In optimization , Newton's method is applied to the derivative     f  ′     superscript  f  normal-′    f^{\prime}   of a twice-differentiable function    f   f   f   to find the roots of the derivative (solutions to      f  ′    (  x  )    =  0         superscript  f  normal-′   x   0    f^{\prime}(x)=0   ), also known as the stationary points of   f   f   f   .  Method  In the one-dimensional problem, Newton's method attempts to construct a sequence  x n from an initial guess x 0 that converges towards some value x* satisfying f '( x* )=0. This x* is a stationary point of f .  The second order Taylor expansion  f T ( x ) of f around x n is:        f  T    (  x  )    =    f  T    (    x  n   +   Δ  x    )    ≈    f   (   x  n   )    +    f  ′    (   x  n   )   Δ  x   +     1  2     f  ′′    (   x  n   )   Δ   x  2              subscript  f  T   x      subscript  f  T      subscript  x  n     normal-Δ  x              f   subscript  x  n       superscript  f  normal-′    subscript  x  n   normal-Δ  x       1  2    superscript  f  ′′    subscript  x  n   normal-Δ   superscript  x  2        \displaystyle f_{T}(x)=f_{T}(x_{n}+\Delta x)\approx f(x_{n})+f^{\prime}(x_{n})%
 \Delta x+\frac{1}{2}f^{\prime\prime}(x_{n})\Delta x^{2}   .  The last expression attains its extremum with respect to Δ x when its derivative is equal to zero, i.e. when:      0  =     d   d  Δ  x      (    f   (   x  n   )    +    f  ′    (   x  n   )   Δ  x   +     1  2     f  ′′    (   x  n   )   Δ   x  2     )    =     f  ′    (   x  n   )    +    f  ′′    (   x  n   )   Δ  x          0      d    d  normal-Δ  x        f   subscript  x  n       superscript  f  normal-′    subscript  x  n   normal-Δ  x       1  2    superscript  f  ′′    subscript  x  n   normal-Δ   superscript  x  2                superscript  f  normal-′    subscript  x  n       superscript  f  ′′    subscript  x  n   normal-Δ  x       \displaystyle 0=\frac{d}{d\Delta x}\left(f(x_{n})+f^{\prime}(x_{n})\Delta x+%
 \frac{1}{2}f^{\prime\prime}(x_{n})\Delta x^{2}\right)=f^{\prime}(x_{n})+f^{%
 \prime\prime}(x_{n})\Delta x   .  For the value of     Δ  x   =   -     f  ′    (   x  n   )      f  ′′    (   x  n   )            normal-Δ  x          superscript  f  normal-′    subscript  x  n       superscript  f  ′′    subscript  x  n        \Delta x=-\frac{f^{\prime}(x_{n})}{f^{\prime\prime}(x_{n})}   , which satisfies this equation, it can be hoped that     x   n  +  1    =    x  n   +   Δ  x    =    x  n   -     f  ′    (   x  n   )      f  ′′    (   x  n   )             subscript  x    n  1       subscript  x  n     normal-Δ  x            subscript  x  n        superscript  f  normal-′    subscript  x  n       superscript  f  ′′    subscript  x  n         x_{n+1}=x_{n}+\Delta x=x_{n}-\frac{f^{\prime}(x_{n})}{f^{\prime\prime}(x_{n})}   will be closer to a stationary point x* . This is the case provided that f is a twice-differentiable function and other technical conditions are satisfied; the sequence x 0 , x 1 , x 2 , … converges to x* .  Geometric interpretation  The geometric interpretation of Newton's method is that at each iteration one approximates    f   (  𝐱  )       f  𝐱    f(\mathbf{x})   by a quadratic function around    𝐱  n     subscript  𝐱  n    \mathbf{x}_{n}   , and then takes a step towards the maximum/minimum of that quadratic function (in higher dimensions, this may also be a saddle point ). Note that if    f   (  𝐱  )       f  𝐱    f(\mathbf{x})   happens to be a quadratic function, then the exact extremum is found in one step.  Higher dimensions  The above iterative scheme can be generalized to several dimensions by replacing the derivative with the gradient ,     ∇  f    (  𝐱  )        normal-∇  f   𝐱    \nabla f(\mathbf{x})   , and the reciprocal of the second derivative with the inverse of the Hessian matrix ,    H  f   (  𝐱  )       H  f  𝐱    Hf(\mathbf{x})   . One obtains the iterative scheme        𝐱   n  +  1    =    𝐱  n   -     [   H  f   (   𝐱  n   )    ]    -  1     ∇  f    (   𝐱  n   )      ,   n  ≥  0.      formulae-sequence     subscript  𝐱    n  1       subscript  𝐱  n      superscript   delimited-[]    H  f   subscript  𝐱  n       1     normal-∇  f    subscript  𝐱  n        n  0.     \mathbf{x}_{n+1}=\mathbf{x}_{n}-[Hf(\mathbf{x}_{n})]^{-1}\nabla f(\mathbf{x}_{%
 n}),\ n\geq 0.     Often Newton's method is modified to include a small step size    γ  ∈   (  0  ,  1  )       γ   0  1     \gamma\in(0,1)   instead of    γ  =  1      γ  1    \gamma=1           𝐱   n  +  1    =    𝐱  n   -   γ    [   H  f   (   𝐱  n   )    ]    -  1     ∇  f    (   𝐱  n   )      .       subscript  𝐱    n  1       subscript  𝐱  n     γ   superscript   delimited-[]    H  f   subscript  𝐱  n       1     normal-∇  f    subscript  𝐱  n       \mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma[Hf(\mathbf{x}_{n})]^{-1}\nabla f(%
 \mathbf{x}_{n}).   This is often done to ensure that the Wolfe conditions are satisfied at each step     𝐱  n   →   𝐱   n  +  1       normal-→   subscript  𝐱  n    subscript  𝐱    n  1      \mathbf{x}_{n}\to\mathbf{x}_{n+1}   of the iteration.  Where applicable, Newton's method converges much faster towards a local maximum or minimum than gradient descent . In fact, every local minimum has a neighborhood   N   N   N   such that, if we start with      𝐱  0   ∈  N   ,       subscript  𝐱  0   N    \mathbf{x}_{0}\in N,   Newton's method with step size    γ  =  1      γ  1    \gamma=1   converges quadratically (if the Hessian is invertible and a Lipschitz continuous function of   𝐱   𝐱   \mathbf{x}   in that neighborhood).  Finding the inverse of the Hessian in high dimensions can be an expensive operation. In such cases, instead of directly inverting the Hessian it's better to calculate the vector     𝐩  n   =     [   H  f   (   𝐱  n   )    ]    -  1     ∇  f    (   𝐱  n   )         subscript  𝐩  n      superscript   delimited-[]    H  f   subscript  𝐱  n       1     normal-∇  f    subscript  𝐱  n      \mathbf{p}_{n}=[Hf(\mathbf{x}_{n})]^{-1}\nabla f(\mathbf{x}_{n})   as the solution to the system of linear equations        [   H  f   (   𝐱  n   )    ]    𝐩  n    =    ∇  f    (   𝐱  n   )           delimited-[]    H  f   subscript  𝐱  n      subscript  𝐩  n       normal-∇  f    subscript  𝐱  n      [Hf(\mathbf{x}_{n})]\mathbf{p}_{n}=\nabla f(\mathbf{x}_{n})     which may be solved by various factorizations or approximately (but to great accuracy) using iterative methods . Many of these methods are only applicable to certain types of equations, for example the Cholesky factorization and conjugate gradient will only work if    [   H  f   (   𝐱  n   )    ]     delimited-[]    H  f   subscript  𝐱  n      [Hf(\mathbf{x}_{n})]   is a positive definite matrix. While this may seem like a limitation, it's often useful indicator of something gone wrong, for example if a minimization problem is being approached and    [   H  f   (   𝐱  n   )    ]     delimited-[]    H  f   subscript  𝐱  n      [Hf(\mathbf{x}_{n})]   is not positive definite, then the iterations are converging to a saddle point and not a minimum.  On the other hand, if a constrained optimization is done (for example, with Lagrange multipliers ), the problem may become one of saddle point finding, in which case the Hessian will be symmetric indefinite and the solution of    𝐩  n     subscript  𝐩  n    \mathbf{p}_{n}   will need to be done with a method that will work for such, such as the LDL T variant of Cholesky factorization or the conjugate residual method .  There also exist various quasi-Newton methods , where an approximation for the Hessian (or its inverse directly) is built up from changes in the gradient.  If the Hessian is close to a non- invertible matrix , the inverted Hessian can be numerically unstable and the solution may diverge. In this case, certain workarounds have been tried in the past, which have varied success with certain problems. One can, for example, modify the Hessian by adding a correction matrix    B  n     subscript  B  n    B_{n}   so as to make      H  f    (   𝐱  n   )    +   B  n          subscript  H  f    subscript  𝐱  n     subscript  B  n     H_{f}(\mathbf{x}_{n})+B_{n}   positive definite. One approach is to diagonalize    H  f     subscript  H  f    H_{f}   and choose    B  n     subscript  B  n    B_{n}   so that      H  f    (   𝐱  n   )    +   B  n          subscript  H  f    subscript  𝐱  n     subscript  B  n     H_{f}(\mathbf{x}_{n})+B_{n}   has the same eigenvectors as    H  f     subscript  H  f    H_{f}   , but with each negative eigenvalue replaced by    ϵ  >  0.      ϵ  0.    \epsilon>0.     An approach exploited in the Levenberg–Marquardt algorithm (which uses an approximate Hessian) is to add a scaled identity matrix to the Hessian,    μ  𝐈      μ  𝐈    \mu\mathbf{I}   , with the scale adjusted at every iteration as needed. For large   μ   μ   \mu   and small Hessian, the iterations will behave like gradient descent with step size    1  μ      1  μ    \frac{1}{\mu}   . This results in slower but more reliable convergence where the Hessian doesn't provide useful information.  See also   Quasi-Newton method  Gradient descent  Gauss–Newton algorithm  Levenberg–Marquardt algorithm  Trust region  Optimization  Nelder–Mead method   Notes  References   Avriel, Mordecai (2003). Nonlinear Programming: Analysis and Methods . Dover Publishing. ISBN 0-486-43227-0.    .  Nocedal, Jorge & Wright, Stephen J. (1999). Numerical Optimization . Springer-Verlag. ISBN 0-387-98793-2.   .   fr:Méthode de Newton "  Category:Optimization algorithms and methods   