<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1343">Fractal flame</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Fractal flame</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p> <strong>Fractal flames</strong> are a member of the <a href="iterated_function_system" title="wikilink">iterated function system</a> class<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> of <a href="fractal" title="wikilink">fractals</a> created by <a href="Scott_Draves" title="wikilink">Scott Draves</a> in 1992.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Draves' open-source code was later ported into <a href="Adobe_After_Effects" title="wikilink">Adobe After Effects</a> graphics software<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and translated into the <a href="Apophysis_(software)" title="wikilink">Apophysis</a> fractal flame editor.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Fractal flames differ from ordinary iterated function systems in three ways:</p>
<ul>
<li><a class="uri" href="Nonlinear" title="wikilink">Nonlinear</a> functions are <a href="Iteration" title="wikilink">iterated</a> instead of <a href="Affine_transformation" title="wikilink">affine transforms</a>.</li>
<li>Log-density display instead of linear or binary (a form of <a href="tone_mapping" title="wikilink">tone mapping</a>)</li>
<li>Color by structure (i.e. by the recursive path taken) instead of monochrome or by density.</li>
</ul>

<p>The tone mapping and coloring are designed to display as much of the detail of the fractal as possible, which generally results in a more aesthetically pleasing image.</p>
<h2 id="algorithm">Algorithm</h2>

<p>The algorithm consists of two steps: creating a <a class="uri" href="histogram" title="wikilink">histogram</a> and then rendering the histogram.</p>
<h3 id="creating-the-histogram">Creating the histogram</h3>

<p>First one iterates a set of functions, starting from a randomly chosen point <em>P = (P.x,P.y,P.c)</em>, where the third coordinate indicated the current color of the point.</p>
<dl>
<dd>Set of flame functions:<math>\begin{cases}
</math></dd>
</dl>

<p>F_1(x,y), \quad p_1 \\ F_2(x,y), \quad p_2 \\ \dots \\ F_n(x,y), \quad p_n \end{cases}</p>

<p>In each iteration, choose one of the functions above where the probability that <em>F<sub>j</sub></em> is chosen is <em>p<sub>j</sub></em>. Then one computes the next iteration of <em>P</em> by applying <em>F<sub>j</sub></em> on <em>(P.x,P.y)</em>.</p>

<p>Each individual function has the following form:</p>

<p>

<math display="block" id="Fractal_flame:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>V</mi>
       <mi>k</mi>
      </msub>
      <mo>∈</mo>
      <mrow>
       <mi>V</mi>
       <mi>a</mi>
       <mi>r</mi>
       <mi>i</mi>
       <mi>a</mi>
       <mi>t</mi>
       <mi>i</mi>
       <mi>o</mi>
       <mi>n</mi>
       <mi>s</mi>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <mrow>
      <msub>
       <mi>w</mi>
       <mi>k</mi>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>V</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>a</mi>
         <mi>j</mi>
        </msub>
        <mi>x</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>b</mi>
         <mi>j</mi>
        </msub>
        <mi>y</mi>
       </mrow>
       <mo>+</mo>
       <msub>
        <mi>c</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>d</mi>
         <mi>j</mi>
        </msub>
        <mi>x</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>e</mi>
         <mi>j</mi>
        </msub>
        <mi>y</mi>
       </mrow>
       <mo>+</mo>
       <msub>
        <mi>f</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>j</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <ci>V</ci>
        <ci>a</ci>
        <ci>r</ci>
        <ci>i</ci>
        <ci>a</ci>
        <ci>t</ci>
        <ci>i</ci>
        <ci>o</ci>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <interval closure="open">
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>j</ci>
         </apply>
         <ci>x</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <ci>j</ci>
         </apply>
         <ci>y</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>d</ci>
          <ci>j</ci>
         </apply>
         <ci>x</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <ci>j</ci>
         </apply>
         <ci>y</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{j}(x,y)=\sum_{V_{k}\in Variations}w_{k}\cdot V_{k}(a_{j}x+b_{j}y+c_{j},d_{j%
}x+e_{j}y+f_{j})
  </annotation>
 </semantics>
</math>

</p>

<p>where the parameter <em>w<sub>k</sub></em> is called the weight of the <strong><em>variation</em></strong> <em>V<sub>k</sub></em>. Draves suggests <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> that all 

<math display="inline" id="Fractal_flame:1">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{k}
  </annotation>
 </semantics>
</math>

:s are non-negative and sum to one, but implementations such as Apophysis do not impose that restriction.</p>

<p>The functions <em>V<sub>k</sub></em> are a set of predefined functions. A few examples<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> are</p>
<ul>
<li>V<sub>0</sub>(<em>x</em>,<em>y</em>) = (<em>x</em>,<em>y</em>) (Linear)</li>
<li>V<sub>1</sub>(<em>x</em>,<em>y</em>) = (sin <em>x</em>,sin <em>y</em>) (Sinusoidal)</li>
<li>V<sub>2</sub>(<em>x</em>,<em>y</em>) = (<em>x</em>,<em>y</em>)/(<em>x</em><sup>2</sup>+<em>y</em><sup>2</sup>) (Spherical)</li>
</ul>

<p>The color <em>P.c</em> of the point is blended with the color associated with the latest applied function <em>F<sub>j</sub></em>:</p>
<dl>
<dd>P.c := (P.c + (F_j)<sub>color</sub>) / 2
</dd>
</dl>

<p>After each iteration, one updates the histogram at the point corresponding to <em>(P.x,P.y)</em>. This is done as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">histogram[x][y][FREQUENCY] := histogram[x][y][FREQUENCY]<span class="dv">+1</span>
histogram[x][y][COLOR] := (histogram[x][y][COLOR] + P.c )/<span class="dv">2</span></code></pre></div>

<p>The colors in the image will therefore reflect what functions were used to get to that part of the image.</p>
<h3 id="rendering-an-image">Rendering an image</h3>

<p>To increase the quality of the image, one can use <a class="uri" href="supersampling" title="wikilink">supersampling</a> to decrease the noise. This involves creating a histogram larger than the image so each pixel has multiple data points to pull from.</p>

<p>For example, creating a histogram with 300×300 cells in order to draw an 100×100 px image. Each pixel would use a 3×3 group of histogram buckets to calculate its value.</p>

<p>For each pixel <em>(x,y)</em> in the final image, do the following computations:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">frequency_avg[x][y]  := average_of_histogram_cells_frequency(x,y);
color_avg[x][y] := average_of_histogram_cells_color(x,y);

alpha[x][y] := log(frequency_avg[x][y]) / log(frequency_max);  
<span class="co">//frequency_max is the maximal number of iterations that hit a cell in the histogram.</span>

final_pixel_color[x][y] := color_avg[x][y] * alpha[x][y]^(<span class="dv">1</span>/gamma); <span class="co">//gamma is a value greater than 1.</span></code></pre></div>

<p>The algorithm above uses <a href="gamma_correction" title="wikilink">gamma correction</a> to make the colors appear brighter. This is implemented in for example the Apophysis software.</p>

<p>To increase the quality even more, one can use gamma correction on each individual color channel, but this is a very heavy computation, since the <em>log</em> function is slow.</p>

<p>A simplified algorithm would be to let the brightness be linearly dependent on the frequency:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">final_pixel_color[x][y] := color_avg[x][y] * frequency_avg[x][y]/frequency_max;</code></pre></div>

<p>but this would make some parts of the fractal lose detail, which is undesirable.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="density-estimation">Density Estimation</h2>
<figure><b>(Figure)</b>
<figcaption>A demonstration of Density Estimation. In the above half, you can see the noise and individual samples. On the below half, rendered with Density Estimation, the noise is smoothed out without destroying the sharp edges.</figcaption>
</figure>

<p>The flame algorithm is like a <a href="Monte_Carlo_simulation" title="wikilink">Monte Carlo simulation</a>, with the flame quality directly proportional to the number of iterations of the simulation. The noise that results from this stochastic sampling can be reduced by <a href="Gaussian_blur" title="wikilink">blurring</a> the image, to get a smoother result in less time. One does not however want to lose resolution in the parts of the image that receive many samples and so have little noise.</p>

<p>This problem can be solved with adaptive <a href="density_estimation" title="wikilink">density estimation</a> to increase image quality while keeping render times to a minimum. FLAM3 uses a simplification of the methods presented in *Adaptive Filtering for Progressive Monte Carlo Image Rendering*, a paper presented at <a href="Winter_School_of_Computer_Graphics" title="wikilink">WSCG</a> 2000 by Frank Suykens and Yves D. Willems. The idea is to vary with width of the filter <a href="inversely_proportional" title="wikilink">inversely proportional</a> to the number of samples available.</p>

<p>As a result, areas with few samples and lots of noise get blurred and smoothed, but areas with lots of samples and low noise are left unaffected. See <a class="uri" href="https://code.google.com/p/flam3/wiki/DensityEstimation">https://code.google.com/p/flam3/wiki/DensityEstimation</a>.</p>

<p>Not all Flame implementations use density estimation.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Apophysis_(software)" title="wikilink">Apophysis</a>, an open source fractal flame editor for Microsoft Windows.</li>
<li><a href="Chaotica_(software)" title="wikilink">Chaotica</a>, a commercial fractal editor which supports flam3, Apophysis and further generalizations.</li>
<li><a class="uri" href="JWildfire" title="wikilink">JWildfire</a>, a multi-platform, open-source fractal flame editor written in Java.</li>
<li><a href="Electric_Sheep" title="wikilink">Electric Sheep</a>, a screen saver created by the inventor of fractal flames which renders and displays them with <a href="Distributed_computing" title="wikilink">Distributed computing</a>.</li>
<li><a class="uri" href="GIMP" title="wikilink">GIMP</a>, a <a href="free_software" title="wikilink">free software</a>, multi OS <a href="image_manipulation" title="wikilink">image manipulation</a> program that can generate fractal flames.</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a class="uri" href="Category:Fractals" title="wikilink">Category:Fractals</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Mitchell Whitelaw (2004). <em>Metacreation: Art and Artificial Life</em>. MIT Press. pp 155.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Chris Gehman and Steve Reinke (2005). <em>The Sharpest Point: Animation at the End of Cinema</em>. YYZ Books. pp 269.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
</ol>
</section>
</body>

