<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="966">Multi-objective optimization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Multi-objective optimization</h1>
<hr>'''Multi-objective optimization''' (also known as '
<p><em>multi-objective programming</em>', <strong>vector optimization</strong>, <strong>multicriteria optimization</strong>, <strong>multiattribute optimization</strong> or <strong>Pareto optimization</strong>) is an area of <a href="MCDM" title="wikilink">multiple criteria decision making</a>, that is concerned with <a href="Mathematical_optimization" title="wikilink">mathematical optimization problems</a> involving more than one <a href="Loss_function" title="wikilink">objective function</a> to be optimized simultaneously. Multi-objective optimization has been applied in many fields of science, including engineering, economics and logistics (see the section on applications for detailed examples) where optimal decisions need to be taken in the presence of <a href="trade-off" title="wikilink">trade-offs</a> between two or more conflicting objectives. Minimizing cost while maximizing comfort while buying a car, and maximizing performance whilst minimizing fuel consumption and emission of pollutants of a vehicle are examples of multi-objective optimization problems involving two and three objectives, respectively. In practical problems, there can be more than three objectives.</p>

<p>For a nontrivial multi-objective optimization problem, there does not exist a single solution that simultaneously optimizes each objective. In that case, the objective functions are said to be conflicting, and there exists a (possibly infinite) number of Pareto optimal solutions. A solution is called nondominated, <a href="Pareto_optimal" title="wikilink">Pareto optimal</a>, <a href="Pareto_efficient" title="wikilink">Pareto efficient</a> or noninferior, if none of the objective functions can be improved in value without degrading some of the other objective values. Without additional <a href="Subjectivity" title="wikilink">subjective</a> preference information, all Pareto optimal solutions are considered equally good (as vectors cannot be ordered completely). Researchers study multi-objective optimization problems from different viewpoints and, thus, there exist different solution philosophies and goals when setting and solving them. The goal may be to find a representative set of Pareto optimal solutions, and/or quantify the trade-offs in satisfying the different objectives, and/or finding a single solution that satisfies the subjective preferences of a human decision maker (DM).</p>
<h2 id="introduction">Introduction</h2>

<p>A multi-objective optimization problem is an <a href="optimization_problem" title="wikilink">optimization problem</a> that involves multiple objective functions.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In mathematical terms, a multi-objective optimization problem can be formulated as</p>

<p>

<math display="inline" id="Multi-objective_optimization:0">
 <semantics>
  <mi>min</mi>
  <annotation-xml encoding="MathML-Content">
   <min></min>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\min
  </annotation>
 </semantics>
</math>


 where the integer 

<math display="inline" id="Multi-objective_optimization:1">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\geq 2
  </annotation>
 </semantics>
</math>

 is the number of objectives and the set 

<math display="inline" id="Multi-objective_optimization:2">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is the feasible set of decision vectors. The feasible set is typically defined by some constraint functions. In addition, the vector-valued objective function is often defined as</p>

<p>

<math display="block" id="Multi-objective_optimization:3">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>→</mo>
     <msup>
      <mi>ℝ</mi>
      <mi>k</mi>
     </msup>
    </mrow>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mi>k</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>X</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <vector>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>x</ci>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>k</ci>
         </apply>
         <ci>x</ci>
        </apply>
       </vector>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\to\mathbb{R}^{k},\ f(x)=(f_{1}(x),\ldots,f_{k}(x))^{T}
  </annotation>
 </semantics>
</math>

. If some objective function is to be maximized, it is equivalent to minimize its negative. The image of 

<math display="inline" id="Multi-objective_optimization:4">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is denoted by 

<math display="inline" id="Multi-objective_optimization:5">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>Y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y\in\mathbb{R}^{k}
  </annotation>
 </semantics>
</math>

 An element 

<math display="inline" id="Multi-objective_optimization:6">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mo>*</mo>
   </msup>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}\in X
  </annotation>
 </semantics>
</math>

 is called a <strong>feasible solution</strong> or a <strong>feasible decision</strong>. A vector 

<math display="inline" id="Multi-objective_optimization:7">
 <semantics>
  <mrow>
   <msup>
    <mi>z</mi>
    <mo>*</mo>
   </msup>
   <mo>:=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <times></times>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{*}:=f(x^{*})\in\mathbb{R}^{k}
  </annotation>
 </semantics>
</math>

 for a feasible solution 

<math display="inline" id="Multi-objective_optimization:8">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 is called an <strong>objective vector</strong> or an <strong>outcome</strong>. In multi-objective optimization, there does not typically exist a feasible solution that minimizes all objective functions simultaneously. Therefore, attention is paid to <strong>Pareto optimal solutions</strong>; that is, solutions that cannot be improved in any of the objectives without degrading at least one of the other objectives. In mathematical terms, a feasible solution 

<math display="inline" id="Multi-objective_optimization:9">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>1</mn>
   </msup>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{1}\in X
  </annotation>
 </semantics>
</math>

 is said to <strong>(Pareto) dominate</strong> another solution 

<math display="inline" id="Multi-objective_optimization:10">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}\in X
  </annotation>
 </semantics>
</math>

, if</p>
<ol>
<li>

<math display="inline" id="Multi-objective_optimization:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mn>1</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(x^{1})\leq f_{i}(x^{2})
  </annotation>
 </semantics>
</math>

 for all indices 

<math display="inline" id="Multi-objective_optimization:12">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mrow>
    <mo>{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>k</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in\left\{{1,2,\dots,k}\right\}
  </annotation>
 </semantics>
</math>

 and</li>
<li>

<math display="inline" id="Multi-objective_optimization:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mn>1</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}(x^{1})<f_{j}(x^{2})
  </annotation>
 </semantics>
</math>

 for at least one index 

<math display="inline" id="Multi-objective_optimization:14">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>∈</mo>
   <mrow>
    <mo>{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>j</ci>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>k</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\in\left\{{1,2,\dots,k}\right\}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>A solution 

<math display="inline" id="Multi-objective_optimization:15">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>1</mn>
   </msup>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{1}\in X
  </annotation>
 </semantics>
</math>

 (and the corresponding outcome 

<math display="inline" id="Multi-objective_optimization:16">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x^{*})
  </annotation>
 </semantics>
</math>

) is called Pareto optimal, if there does not exist another solution that dominates it. The set of Pareto optimal outcomes is often called the <strong><a href="Pareto_front" title="wikilink">Pareto front</a></strong> or Pareto boundary.</p>

<p>The Pareto front of a multi-objective optimization problem is bounded by a so-called <strong>nadir objective vector</strong> 

<math display="inline" id="Multi-objective_optimization:17">
 <semantics>
  <msup>
   <mi>z</mi>
   <mrow>
    <mi>n</mi>
    <mi>a</mi>
    <mi>d</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>a</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{nad}
  </annotation>
 </semantics>
</math>

 and an <strong>ideal objective vector</strong> 

<math display="inline" id="Multi-objective_optimization:18">
 <semantics>
  <msup>
   <mi>z</mi>
   <mrow>
    <mi>i</mi>
    <mi>d</mi>
    <mi>e</mi>
    <mi>a</mi>
    <mi>l</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>d</ci>
     <ci>e</ci>
     <ci>a</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{ideal}
  </annotation>
 </semantics>
</math>

, if these are finite. The nadir objective vector is defined as</p>

<p>

<math display="block" id="Multi-objective_optimization:19">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>z</mi>
     <mi>i</mi>
     <mrow>
      <mi>n</mi>
      <mi>a</mi>
      <mi>d</mi>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">sup</mo>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <mrow>
        <mi>X</mi>
        <mtext>is Pareto optimal</mtext>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mtext>for all</mtext>
      <mi>i</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>a</ci>
         <ci>d</ci>
        </apply>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">supremum</csymbol>
        <apply>
         <in></in>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>X</ci>
          <mtext>is Pareto optimal</mtext>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>i</ci>
        </apply>
        <ci>x</ci>
        <mtext>for all</mtext>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list>
     <ci>normal-…</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{nad}_{i}=\sup_{x\in X\text{ is Pareto optimal}}f_{i}(x)\text{ for all }i=1,%
\ldots,k
  </annotation>
 </semantics>
</math>

 and the ideal objective vector as</p>

<p>

<math display="block" id="Multi-objective_optimization:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>z</mi>
      <mi>i</mi>
      <mrow>
       <mi>i</mi>
       <mi>d</mi>
       <mi>e</mi>
       <mi>a</mi>
       <mi>l</mi>
      </mrow>
     </msubsup>
     <mo>=</mo>
     <mrow>
      <munder>
       <mo movablelimits="false">inf</mo>
       <mrow>
        <mi>x</mi>
        <mo>∈</mo>
        <mi>X</mi>
       </mrow>
      </munder>
      <mrow>
       <msub>
        <mi>f</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mtext>for all</mtext>
       <mi>i</mi>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>d</ci>
         <ci>e</ci>
         <ci>a</ci>
         <ci>l</ci>
        </apply>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">infimum</csymbol>
        <apply>
         <in></in>
         <ci>x</ci>
         <ci>X</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>i</ci>
        </apply>
        <ci>x</ci>
        <mtext>for all</mtext>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list>
     <ci>normal-…</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{ideal}_{i}=\inf_{x\in X}{f_{i}(x)}\text{ for all }i=1,\ldots,k.
  </annotation>
 </semantics>
</math>

 In other words, the components of a nadir and an ideal objective vector define upper and lower bounds for the objective function values of Pareto optimal solutions, respectively. In practice, the nadir objective vector can only be approximated as, typically, the whole Pareto optimal set is unknown. In addition, a <strong>utopian objective vector</strong> 

<math display="inline" id="Multi-objective_optimization:21">
 <semantics>
  <msup>
   <mi>z</mi>
   <mrow>
    <mi>u</mi>
    <mi>t</mi>
    <mi>o</mi>
    <mi>p</mi>
    <mi>i</mi>
    <mi>a</mi>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>t</ci>
     <ci>o</ci>
     <ci>p</ci>
     <ci>i</ci>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{utopian}
  </annotation>
 </semantics>
</math>

 with</p>

<p>

<math display="block" id="Multi-objective_optimization:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>z</mi>
      <mi>i</mi>
      <mrow>
       <mi>u</mi>
       <mi>t</mi>
       <mi>o</mi>
       <mi>p</mi>
       <mi>i</mi>
       <mi>a</mi>
       <mi>n</mi>
      </mrow>
     </msubsup>
     <mo>=</mo>
     <mrow>
      <msubsup>
       <mi>z</mi>
       <mi>i</mi>
       <mrow>
        <mi>i</mi>
        <mi>d</mi>
        <mi>e</mi>
        <mi>a</mi>
        <mi>l</mi>
       </mrow>
      </msubsup>
      <mo>-</mo>
      <mrow>
       <mi>ϵ</mi>
       <mtext>for all</mtext>
       <mi>i</mi>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <times></times>
         <ci>u</ci>
         <ci>t</ci>
         <ci>o</ci>
         <ci>p</ci>
         <ci>i</ci>
         <ci>a</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>d</ci>
          <ci>e</ci>
          <ci>a</ci>
          <ci>l</ci>
         </apply>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <ci>ϵ</ci>
        <mtext>for all</mtext>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list>
     <ci>normal-…</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{utopian}_{i}=z^{ideal}_{i}-\epsilon\text{ for all }i=1,\ldots,k,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Multi-objective_optimization:23">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

 is a small constant, is often defined because of numerical reasons.</p>
<h2 id="examples-of-multi-objective-optimization-applications">Examples of multi-objective optimization applications</h2>
<h3 id="economics">Economics</h3>

<p>In <a class="uri" href="economics" title="wikilink">economics</a>, many problems involve multiple objectives along with constraints on what combinations of those objectives are attainable. For example, consumer's <a class="uri" href="demand" title="wikilink">demand</a> for various goods is determined by the process of maximization of the <a href="utility" title="wikilink">utilities</a> derived from those goods, subject to a constraint based on how much income is available to spend on those goods and on the prices of those goods. This constraint allows more of one good to be purchased only at the sacrifice of consuming less of another good; therefore, the various objectives (more consumption of each good is preferred) are in conflict with each other. A common method for analyzing such a problem is to use a graph of <a href="indifference_curve" title="wikilink">indifference curves</a>, representing preferences, and a budget constraint, representing the trade-offs that the consumer is faced with.</p>

<p>Another example involves the <a href="production_possibilities_frontier" title="wikilink">production possibilities frontier</a>, which specifies what combinations of various types of goods can be produced by a society with certain amounts of various resources. The frontier specifies the trade-offs that the society is faced with — if the society is fully utilizing its resources, more of one good can be produced only at the expense of producing less of another good. A society must then use some process to choose among the possibilities on the frontier.</p>

<p><a href="Macroeconomics#Macroeconomic_policy" title="wikilink">Macroeconomic policy</a>-making is a context requiring multi-objective optimization. Typically a <a href="central_bank" title="wikilink">central bank</a> must choose a stance for <a href="monetary_policy" title="wikilink">monetary policy</a> that balances competing objectives — low <a class="uri" href="inflation" title="wikilink">inflation</a>, low <a class="uri" href="unemployment" title="wikilink">unemployment</a>, low <a href="balance_of_trade" title="wikilink">balance of trade</a> deficit, etc. To do this, the central bank uses a <a href="economic_model" title="wikilink">model of the economy</a> that quantitatively describes the various causal linkages in the economy; it <a href="simulation" title="wikilink">simulates</a> the model repeatedly under various possible stances of monetary policy, in order to obtain a menu of possible predicted outcomes for the various variables of interest. Then in principle it can use an aggregate objective function to rate the alternative sets of predicted outcomes, although in practice central banks use a non-quantitative, judgement-based, process for ranking the alternatives and making the policy choice.</p>
<h3 id="finance">Finance</h3>

<p>In <a class="uri" href="finance" title="wikilink">finance</a>, a common problem is to choose a portfolio when there are two conflicting objectives — the desire to have the <a href="expected_value" title="wikilink">expected value</a> of portfolio returns be as high as possible, and the desire to have <a href="financial_risk" title="wikilink">risk</a>, often measured by the <a href="standard_deviation" title="wikilink">standard deviation</a> of portfolio returns, be as low as possible. This problem is often represented by a graph in which the <a href="efficient_frontier" title="wikilink">efficient frontier</a> shows the best combinations of risk and expected return that are available, and in which indifference curves show the investor's preferences for various risk-expected return combinations. The problem of optimizing a function of the expected value (first <a href="moment_(mathematics)" title="wikilink">moment</a>) and the standard deviation (square root of the second central moment) of portfolio return is called a <a href="two-moment_decision_model" title="wikilink">two-moment decision model</a>.</p>
<h3 id="optimal-control">Optimal control</h3>

<p>In <a class="uri" href="engineering" title="wikilink">engineering</a> and <a class="uri" href="economics" title="wikilink">economics</a>, many problems involve multiple objectives which are not describable as the-more-the-better or the-less-the-better; instead, there is an ideal target value for each objective, and the desire is to get as close as possible to the desired value of each objective. For example, one might want to adjust a rocket's fuel usage and orientation so that it arrives both at a specified place and at a specified time; or one might want to conduct <a href="open_market_operations" title="wikilink">open market operations</a> so that both the <a href="inflation_rate" title="wikilink">inflation rate</a> and the <a href="unemployment_rate" title="wikilink">unemployment rate</a> are as close as possible to their desired values.</p>

<p>Often such problems are subject to linear equality constraints that prevent all objectives from being simultaneously perfectly met, especially when the number of controllable variables is less than the number of objectives and when the presence of random shocks generates uncertainty. Commonly a multi-objective <a href="quadratic_function#Bivariate_(two_variable)_quadratic_function" title="wikilink">quadratic objective function</a> is used, with the cost associated with an objective rising quadratically with the distance of the objective from its ideal value. Since these problems typically involve adjusting the controlled variables at various points in time and/or evaluating the objectives at various points in time, <a href="intertemporal_optimization" title="wikilink">intertemporal optimization</a> techniques are employed.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="optimal-design">Optimal design</h3>

<p>Product and process design can be largely improved using modern modeling, simulation and optimization techniques. The key question in optimal design is the measure of what is good or desirable about a design. Before looking for optimal designs it is important to identify characteristics which contribute the most to the overall value of the design. A good design typically involves multiple criteria/objectives such as capital cost/investment, operating cost, profit, quality and/or recovery of the product, efficiency, process safety, operation time etc. Therefore, in practical applications, the performance of process and product design is often measured with respect to multiple objectives. These objectives typically are conflicting, i.e. achieving the optimal value for one objective requires some compromise on one or more of other objectives.</p>

<p>For example, in paper industry when designing a paper mill, one can seek to decrease the amount of capital invested in a paper mill and enhance the quality of paper simultaneously. If the design of a paper mill is defined by large storage volumes and paper quality is defined by quality parameters, then the problem of optimal design of a paper mill can include objectives such as: i) minimization of expected variation of those quality parameter from their nominal values, ii) minimization of expected time of breaks and iii) minimization of investment cost of storage volumes. Here, maximum volume of towers are design variables. This example of optimal design of a paper mill is a simplification of the model used in.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="radio-resource-management">Radio resource management</h3>

<p>The purpose of <a href="radio_resource_management" title="wikilink">radio resource management</a> is to satisfy the data rates that are requested by the users of a cellular network.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The main resources are time intervals, frequency blocks, and transmit powers. Each user has its own objective function that, for example, can represent some combination of the data rate, latency, and energy efficiency. These objectives are conflicting since the frequency resources are very scarce, thus there is a need for tight spatial <a href="frequency_reuse" title="wikilink">frequency reuse</a> which causes immense inter-user interference if not properly controlled. <a href="Multi-user_MIMO" title="wikilink">Multi-user MIMO</a> techniques are nowadays used to reduce the interference by adaptive <a class="uri" href="precoding" title="wikilink">precoding</a>. The network operator would like to both bring great coverage and high data rates, thus the operator would like to find a Pareto optimal solution that balance the total network data throughput and the user fairness in an appropriate subjective manner.</p>

<p>Radio resource management is often solved by scalarization; that is, selection of a network utility function that tries to balance throughput and user fairness. The choice of utility function has a large impact on the computational complexity of the resulting single-objective optimization problem.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> For example, the common utility of weighted sum rate gives an <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> problem with a complexity that scales exponentially with the number of users, while the weighted max-min fairness utility results in a quasi-convex optimization problem with only a polynomial scaling with the number of users.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="electric-power-systems">Electric Power Systems</h3>

<p>Reconfiguration, by exchanging the functional links between the elements of the system, represents one of the most important measures which can improve the operational performance of a distribution system. The problem of optimization through the reconfiguration of a power distribution system, in terms of its definition, is a historical single objective problem with constraints. Since 1975, when Merlin and Back <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> introduced the idea of distribution system reconfiguration for active power loss reduction, until nowadays, a lot of researchers have proposed diverse methods and algorithms to solve the reconfiguration problem as a single objective problem. Some authors have proposed Pareto optimality based approaches (including active power losses and reliability indices as objectives). For this purpose, different artificial intelligence based methods have been used: microgenetic,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> branch exchange,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> particle swarm optimization <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> and non-dominated sorting genetic algorithm.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="solving-a-multi-objective-optimization-problem">Solving a multi-objective optimization problem</h2>

<p>As there usually exist multiple Pareto optimal solutions for multi-objective optimization problems, what it means to solve such a problem is not as straightforward as it is for a conventional single-objective optimization problem. Therefore, different researchers have defined the term "solving a multi-objective optimization problem" in various ways. This section summarizes some of them and the contexts in which they are used. Many methods convert the original problem with multiple objectives into a single-objective optimization problem. This is called a scalarized problem. If scalarization is done carefully, Pareto optimality of the solutions obtained can be guaranteed.</p>

<p>Solving a multi-objective optimization problem is sometimes understood as approximating or computing all or a representative set of Pareto optimal solutions.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>When decision making is emphasized, the objective of solving a multi-objective optimization problem is referred to supporting a decision maker in finding the most preferred Pareto optimal solution according to his/her subjective preferences.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The underlying assumption is that one solution to the problem must be identified to be implemented in practice. Here, a human <strong>decision maker</strong> (DM) plays an important role. The DM is expected to be an expert in the problem domain.</p>

<p>The most preferred solution can be found using different philosophies. Multi-objective optimization methods can be divided into four classes.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> In so-called no preference methods, no DM is expected to be available, but a neutral compromise solution is identified without preference information.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> The other classes are so-called a priori, a posteriori and interactive methods and they all involve preference information from the DM in different ways.</p>

<p>In a priori methods, preference information is first asked from the DM and then a solution best satisfying these preferences is found. In a posteriori methods, a representative set of Pareto optimal solutions is first found and then the DM must choose one of them. In interactive methods, the decision maker is allowed to iteratively search for the most preferred solution. In each iteration of the interactive method, the DM is shown Pareto optimal solution(s) and describes how the solution(s) could be improved. The information given by the decision maker is then taken into account while generating new Pareto optimal solution(s) for the DM to study in the next iteration. In this way, the DM learns about the feasibility of his/her wishes and can concentrate on solutions that are interesting to him/her. The DM may stop the search whenever he/she wants to. More information and examples of different methods in the four classes are given in the following sections.</p>
<h2 id="scalarizing-multi-objective-optimization-problems">Scalarizing multi-objective optimization problems</h2>

<p>Scalarizing a multi-objective optimization problem means formulating a single-objective optimization problem such that optimal solutions to the single-objective optimization problem are Pareto optimal solutions to the multi-objective optimization problem.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> In addition, it is often required that every Pareto optimal solution can be reached with some parameters of the scalarization.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> With different parameters for the scalarization, different Pareto optimal solutions are produced. A general formulation for a scalarization of a multiobjective optimization is thus</p>

<p>

<math display="block" id="Multi-objective_optimization:24">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <mi>min</mi>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mi>k</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <mtext>s.t</mtext>
        <mi>x</mi>
       </mrow>
       <mo>∈</mo>
       <msub>
        <mi>X</mi>
        <mi>θ</mi>
       </msub>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
    <mtd></mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <min></min>
     <apply>
      <times></times>
      <ci>g</ci>
      <vector>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>x</ci>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>k</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <ci>θ</ci>
      </vector>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <mtext>s.t</mtext>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>θ</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{ll}\min&g(f_{1}(x),\ldots,f_{k}(x),\theta)\\
\text{s.t }x\in X_{\theta},\end{array}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Multi-objective_optimization:25">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is a vector parameter, the set 

<math display="inline" id="Multi-objective_optimization:26">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>θ</mi>
   </msub>
   <mo>⊆</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>θ</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{\theta}\subseteq X
  </annotation>
 </semantics>
</math>

 is a set depending on the parameter 

<math display="inline" id="Multi-objective_optimization:27">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Multi-objective_optimization:28">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>↦</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:\mathbb{R}^{k+1}\mapsto\mathbb{R}
  </annotation>
 </semantics>
</math>

 is a function.</p>

<p>Very well-known examples are the so-called</p>
<ul>
<li><strong>linear scalarization</strong></li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\min_{x\in X} \sum_{i=1}^k w_if_i(x), </p>
<dl>
<dd>where the weights of the objectives 

<math display="inline" id="Multi-objective_optimization:29">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}>0
  </annotation>
 </semantics>
</math>

 are the parameters of the scalarization, and the
</dd>
</dl>
<ul>
<li><strong>

<math display="inline" id="Multi-objective_optimization:30">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

-constraint method</strong> (see, e.g.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a>)</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{array}{ll} \min &amp; f_j(x)\\ \text{s.t. }&amp;x; \in X\\</p>

<p><code>           &amp;f;_i(x)\leq \epsilon_j \text{ for }i\in\{1,\ldots,k\}\setminus\{j\},</code></p>

<p>\end{array} </p>
<dl>
<dd>where upper bounds 

<math display="inline" id="Multi-objective_optimization:31">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{j}
  </annotation>
 </semantics>
</math>

 are parameters as above and 

<math display="inline" id="Multi-objective_optimization:32">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j}
  </annotation>
 </semantics>
</math>

 is the objective to be minimized.
</dd>
</dl>

<p>A little bit more advanced examples are the <strong>Achievement scalarizing problems of Wierzbicki</strong>.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> One example of the Achievement scalarizing problems can be formulated as</p>

<p>

<math display="block" id="Multi-objective_optimization:33">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <mi>min</mi>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <munder>
        <mi>max</mi>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mrow>
          <mn>1</mn>
          <mo>,</mo>
          <mi mathvariant="normal">…</mi>
          <mo>,</mo>
          <mi>k</mi>
         </mrow>
        </mrow>
       </munder>
       <mrow>
        <mo>[</mo>
        <mfrac>
         <mrow>
          <mrow>
           <msub>
            <mi>f</mi>
            <mi>i</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>-</mo>
          <msub>
           <mover accent="true">
            <mi>z</mi>
            <mo stretchy="false">¯</mo>
           </mover>
           <mi>i</mi>
          </msub>
         </mrow>
         <mrow>
          <msubsup>
           <mi>z</mi>
           <mi>i</mi>
           <mtext>nad</mtext>
          </msubsup>
          <mo>-</mo>
          <msubsup>
           <mi>z</mi>
           <mi>i</mi>
           <mtext>utopia</mtext>
          </msubsup>
         </mrow>
        </mfrac>
        <mo>]</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>ρ</mi>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>k</mi>
        </munderover>
        <mfrac>
         <mrow>
          <msub>
           <mi>f</mi>
           <mi>i</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <msubsup>
           <mi>z</mi>
           <mi>i</mi>
           <mrow>
            <mi>n</mi>
            <mi>a</mi>
            <mi>d</mi>
           </mrow>
          </msubsup>
          <mo>-</mo>
          <msubsup>
           <mi>z</mi>
           <mi>i</mi>
           <mtext>utopian</mtext>
          </msubsup>
         </mrow>
        </mfrac>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <mi>S</mi>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <min></min>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <max></max>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <list>
          <cn type="integer">1</cn>
          <ci>normal-…</ci>
          <ci>k</ci>
         </list>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>i</ci>
          </apply>
          <ci>x</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-¯</ci>
           <ci>z</ci>
          </apply>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>z</ci>
           <mtext>nad</mtext>
          </apply>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>z</ci>
           <ci>i</ci>
          </apply>
          <mtext>utopia</mtext>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>k</ci>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>i</ci>
          </apply>
          <ci>x</ci>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>z</ci>
            <ci>i</ci>
           </apply>
           <apply>
            <times></times>
            <ci>n</ci>
            <ci>a</ci>
            <ci>d</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>z</ci>
            <ci>i</ci>
           </apply>
           <mtext>utopian</mtext>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>S</ci>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{ll}\min&\max_{i=1,\ldots,k}\left[\frac{f_{i}(x)-\bar{z}_{i}}{z%
^{\text{nad}}_{i}-z_{i}^{\text{utopia}}}\right]+\rho\sum_{i=1}^{k}\frac{f_{i}(%
x)}{z_{i}^{nad}-z_{i}^{\text{utopian}}}\\
\text{subject to }&x\in S,\end{array}
  </annotation>
 </semantics>
</math>

 where the term 

<math display="inline" id="Multi-objective_optimization:34">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </msubsup>
    <mfrac>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msubsup>
       <mi>z</mi>
       <mi>i</mi>
       <mrow>
        <mi>n</mi>
        <mi>a</mi>
        <mi>d</mi>
       </mrow>
      </msubsup>
      <mo>-</mo>
      <msubsup>
       <mi>z</mi>
       <mi>i</mi>
       <mtext>utopia</mtext>
      </msubsup>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>a</ci>
         <ci>d</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>i</ci>
        </apply>
        <mtext>utopia</mtext>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho\sum_{i=1}^{k}\frac{f_{i}(x)}{z_{i}^{nad}-z_{i}^{\text{utopia}}}
  </annotation>
 </semantics>
</math>

 is called the augmentation term, 

<math display="inline" id="Multi-objective_optimization:35">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ρ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho>0
  </annotation>
 </semantics>
</math>

 is a small constant, and 

<math display="inline" id="Multi-objective_optimization:36">
 <semantics>
  <msup>
   <mi>z</mi>
   <mtext>nad</mtext>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <mtext>nad</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\text{nad}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Multi-objective_optimization:37">
 <semantics>
  <msup>
   <mi>z</mi>
   <mtext>utopian</mtext>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>z</ci>
    <mtext>utopian</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\text{utopian}}
  </annotation>
 </semantics>
</math>

 are the nadir vector and a utopian vectors, respectively. In the above problem, the parameter is the so-called reference point 

<math display="inline" id="Multi-objective_optimization:38">
 <semantics>
  <mover accent="true">
   <mi>z</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{z}
  </annotation>
 </semantics>
</math>

 which represents objective function values preferred by the decision maker.</p>

<p>For example, <a href="Portfolio_optimization" title="wikilink">Portfolio optimization</a> is often conducted in terms of <a href="Modern_portfolio_theory" title="wikilink">mean-variance analysis</a>. In this context, the efficient set is a subset of the portfolios parametrized by the portfolio mean return 

<math display="inline" id="Multi-objective_optimization:39">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>P</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{P}
  </annotation>
 </semantics>
</math>

 in the problem of choosing portfolio shares so as to minimize the portfolio's variance of return 

<math display="inline" id="Multi-objective_optimization:40">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>P</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{P}
  </annotation>
 </semantics>
</math>

 subject to a given value of 

<math display="inline" id="Multi-objective_optimization:41">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>P</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{P}
  </annotation>
 </semantics>
</math>

; see <a href="Mutual_fund_separation_theorem#Portfolio_separation_in_mean-variance_analysis" title="wikilink">Mutual fund separation theorem</a> for details. Alternatively, the efficient set can be specified by choosing the portfolio shares so as to maximize the function 

<math display="inline" id="Multi-objective_optimization:42">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>P</mi>
   </msub>
   <mo>-</mo>
   <mrow>
    <mi>b</mi>
    <msub>
     <mi>σ</mi>
     <mi>P</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{P}-b\sigma_{P}
  </annotation>
 </semantics>
</math>

; the set of efficient portfolios consists of the solutions as <em>b</em> ranges from zero to infinity.</p>
<h2 id="no-preference-methods">No-preference methods</h2>

<p>Multi-objective optimization methods that do not require any preference information to be explicitly articulated by a decision maker can be classified as no-preference methods.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> A well-known example is the method of global criterion,<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> in which a scalarized problem of the form</p>

<p>

<math display="inline" id="Multi-objective_optimization:43">
 <semantics>
  <mi>min</mi>
  <annotation-xml encoding="MathML-Content">
   <min></min>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\min
  </annotation>
 </semantics>
</math>


 is solved. In the above problem, 

<math display="inline" id="Multi-objective_optimization:44">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mo>⋅</mo>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">parallel-to</csymbol>
    <ci>normal-⋅</ci>
    <csymbol cd="latexml">parallel-to</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\cdot\|
  </annotation>
 </semantics>
</math>

 can be any <a href="Lp_space#The_p-norm_in_finite_dimensions" title="wikilink">

<math display="inline" id="Multi-objective_optimization:45">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{p}
  </annotation>
 </semantics>
</math>

 norm</a>, with common choices including 

<math display="inline" id="Multi-objective_optimization:46">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Multi-objective_optimization:47">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{2}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Multi-objective_optimization:48">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi mathvariant="normal">∞</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\infty}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> The method of global criterion is sensitive to the scaling of the objective functions, and thus, it is recommended that the objectives are normalized into a uniform, dimensionless scale.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h2 id="a-priori-methods">A priori methods</h2>

<p>A priori methods require that sufficient preference information is expressed before the solution process.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> Well-known examples of a priori methods include the <strong>utility function method</strong>, <a href="Lexicographical_order" title="wikilink">lexicographic</a> method, and <a href="goal_programming" title="wikilink">goal programming</a>.</p>

<p>In the utility function method, it is assumed that the decision maker's <a href="utility" title="wikilink">utility function</a> is available. A mapping 

<math display="inline" id="Multi-objective_optimization:49">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>:</mo>
   <mrow>
    <mi>Y</mi>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>u</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>Y</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\colon Y\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 is a utility function if for all 

<math display="inline" id="Multi-objective_optimization:50">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐲</mi>
     <mn>1</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>𝐲</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>∈</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐲</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐲</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}^{1},\mathbf{y}^{2}\in Y
  </annotation>
 </semantics>
</math>

 it holds that 

<math display="inline" id="Multi-objective_optimization:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>𝐲</mi>
      <mn>1</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>𝐲</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐲</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐲</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(\mathbf{y}^{1})>u(\mathbf{y}^{2})
  </annotation>
 </semantics>
</math>

 if the decision maker prefers 

<math display="inline" id="Multi-objective_optimization:52">
 <semantics>
  <msup>
   <mi>𝐲</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐲</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}^{1}
  </annotation>
 </semantics>
</math>


 to 

<math display="inline" id="Multi-objective_optimization:53">
 <semantics>
  <msup>
   <mi>𝐲</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐲</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}^{2}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Multi-objective_optimization:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>𝐲</mi>
      <mn>1</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>𝐲</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐲</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐲</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(\mathbf{y}^{1})=u(\mathbf{y}^{2})
  </annotation>
 </semantics>
</math>

 if the decision maker is indifferent between 

<math display="inline" id="Multi-objective_optimization:55">
 <semantics>
  <msup>
   <mi>𝐲</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐲</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}^{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Multi-objective_optimization:56">
 <semantics>
  <msup>
   <mi>𝐲</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐲</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}^{2}
  </annotation>
 </semantics>
</math>

. The utility function specifies an ordering of the decision vectors (recall that vectors can be ordered in many different ways). Once 

<math display="inline" id="Multi-objective_optimization:57">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>


 is obtained, it suffices to solve</p>

<p>

<math display="block" id="Multi-objective_optimization:58">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mpadded width="+2.8pt">
       <mi>max</mi>
      </mpadded>
      <mi>u</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>𝐟</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>𝐱</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mtext>subject to</mtext>
     <mi>𝐱</mi>
    </mrow>
    <mo>∈</mo>
    <mi>X</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <max></max>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <ci>𝐟</ci>
      <ci>𝐱</ci>
     </apply>
     <mtext>subject to</mtext>
     <ci>𝐱</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\;u(\mathbf{f}(\mathbf{x}))\text{ subject to }\mathbf{x}\in X,
  </annotation>
 </semantics>
</math>

 but in practice it is very difficult to construct a utility function that would accurately represent the decision maker's preferences<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> - particularly since the Pareto front is unknown before the optimization begins.</p>

<p>Lexicographic method assumes that the objectives can be ranked in the order of importance. We can assume, without loss of generality, that the objective functions are in the order of importance so that 

<math display="inline" id="Multi-objective_optimization:59">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}
  </annotation>
 </semantics>
</math>

 is the most important and 

<math display="inline" id="Multi-objective_optimization:60">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{k}
  </annotation>
 </semantics>
</math>

 the least important to the decision maker. The lexicographic method consists of solving a sequence of single-objective optimization problems of the form</p>

<p>

<math display="inline" id="Multi-objective_optimization:61">
 <semantics>
  <mi>min</mi>
  <annotation-xml encoding="MathML-Content">
   <min></min>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\min
  </annotation>
 </semantics>
</math>


 where 

<math display="inline" id="Multi-objective_optimization:62">
 <semantics>
  <msubsup>
   <mi>𝐲</mi>
   <mi>j</mi>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐲</ci>
     <times></times>
    </apply>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}^{*}_{j}
  </annotation>
 </semantics>
</math>

 is the optimal value of the above problem with 

<math display="inline" id="Multi-objective_optimization:63">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>=</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>l</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l=j
  </annotation>
 </semantics>
</math>

. Thus, 

<math display="inline" id="Multi-objective_optimization:64">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝐲</mi>
    <mn>1</mn>
    <mo>*</mo>
   </msubsup>
   <mo>:=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msub>
       <mi>f</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝐱</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mi>𝐱</mi>
      <mo>∈</mo>
      <mi>X</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐲</ci>
      <times></times>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <min></min>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>𝐱</ci>
     </apply>
     <apply>
      <in></in>
      <ci>𝐱</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}^{*}_{1}:=\min\{f_{1}(\mathbf{x})\mid\mathbf{x}\in X\}
  </annotation>
 </semantics>
</math>

 and each new problem of the form in the above problem in the sequence adds one new constraint as 

<math display="inline" id="Multi-objective_optimization:65">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 goes from 

<math display="inline" id="Multi-objective_optimization:66">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Multi-objective_optimization:67">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="a-posteriori-methods">A posteriori methods</h2>

<p>A posteriori methods aim at producing all the Pareto optimal solutions or a representative subset of the Pareto optimal solutions. Most a posteriori methods fall into either one of the following two classes: <a href="mathematical_programming" title="wikilink">mathematical programming</a> -based a posteriori methods, where an algorithm is repeated and each run of the algorithm produces one Pareto optimal solution, and <a href="evolutionary_algorithm" title="wikilink">evolutionary algorithms</a> where one run of the algorithm produces a set of Pareto optimal solutions.</p>

<p>Well-known examples of mathematical programming -based a posteriori methods are the Normal Boundary Intersection (NBI),<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> Modified Normal Boundary Intersection (NBIm) <a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> Normal Constraint (NC),<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> Successive Pareto Optimization (SPO)<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> and Directed Search Domain (DSD)<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> methods that solve the multi-objective optimization problem by constructing several scalarizations. The solution to each scalarization yields a Pareto optimal solution, whether locally or globally. The scalarizations of the NBI, NBIm, NC and DSD methods are constructed with the target of obtaining evenly distributed Pareto points that give a good evenly distributed approximation of the real set of Pareto points.</p>

<p><a href="Evolutionary_algorithms" title="wikilink">Evolutionary algorithms</a> are popular approaches to generating Pareto optimal solutions to a multi-objective optimization problem. Currently, most evolutionary multi-objective optimization (EMO) algorithms apply Pareto-based ranking schemes. Evolutionary algorithms such as the Non-dominated Sorting Genetic Algorithm-II (NSGA-II) <a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> and Strength Pareto Evolutionary Algorithm 2 (SPEA-2)<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> have become standard approaches, although some schemes based on <a href="Particle_swarm_optimization#Variants" title="wikilink">particle swarm optimization</a> and <a href="simulated_annealing" title="wikilink">simulated annealing</a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> are significant. The main advantage of evolutionary algorithms, when applied to solve multi-objective optimization problems, is the fact that they typically generate sets of solutions, allowing computation of an approximation of the entire Pareto front. The main disadvantage of evolutionary algorithms is their lower speed and the Pareto optimality of the solutions cannot be guaranteed. It is only known that none of the generated solutions dominates the others.</p>

<p>Commonly known a posteriori methods are listed below:</p>
<ul>
<li>Normal Boundary Intersection (NBI) <a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></li>
<li>Modified Normal Boundary Intersection (NBIm) <a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> Normal Constraint (NC),<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a><a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a></li>
<li>Successive Pareto Optimization (SPO)<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a></li>
<li>Directed Search Domain (DSD)<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a></li>
<li>NSGA-II <a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></li>
<li>PGEN (Pareto surface generation for convex multi-objective instances)<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a></li>
<li><a class="uri" href="IOSO" title="wikilink">IOSO</a> (Indirect Optimization on the basis of Self-Organization)</li>
<li>SMS-EMOA (S-metric selection evolutionary multi-objective algorithm)<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a></li>
<li><a href="Reactive_Search_Optimization" title="wikilink">Reactive Search Optimization</a> (using machine learning for adapting strategies and objectives),<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a><a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> implemented in <a class="uri" href="LIONsolver" title="wikilink">LIONsolver</a></li>
<li><a href="Benson's_algorithm" title="wikilink">Benson's algorithm</a> for linear <a href="vector_optimization" title="wikilink">vector optimization</a> problems</li>
<li><a href="Particle_swarm_optimization#Variants" title="wikilink">Multi-objective particle swarm optimization</a></li>
</ul>
<h2 id="interactive-methods">Interactive methods</h2>

<p>In interactive methods, the solution process is iterative and the decision maker continuously interacts with the method when searching for the most preferred solution (see e.g.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a><a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a>). In other words, the decision maker is expected to express preferences at each iteration in order to get Pareto optimal solutions that are of interest to him/her and learn what kind of solutions are attainable. The following steps are commonly present in interactive methods:<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a></p>
<ol>
<li>initialize (e.g. calculate ideal and approximated nadir objective vectors and show them to the decision maker)</li>
<li>generate a Pareto optimal starting point (by using e.g. some no-preference method or solution given by the decision maker)</li>
<li>ask for preference information from the decision maker (e.g. aspiration levels or number of new solutions to be generated)</li>
<li>generate new Pareto optimal solution(s) according to the preferences and show it/them and possibly some other information about the problem to the decision maker</li>
<li>if several solutions were generated, ask the decision maker to select the best solution so far</li>
<li>stop, if the decision maker wants to; otherwise, go to step 3).</li>
</ol>

<p>Above, aspiration levels refer to desirable objective function values forming a reference point. Instead of mathematical convergence that is often used as a stopping criterion in <a href="mathematical_optimization" title="wikilink">mathematical optimization</a> methods, a psychological convergence is emphasized in interactive methods. Generally speaking, a method is terminated when the decision maker is confident that (s)he has found the most preferred solution available.</p>

<p>Different interactive methods involve different types of preference information. For example, three types can be identified: methods based on 1) trade-off information, 2) reference points and 3) classification of objective functions.<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> On the other hand, a fourth type of generating a small sample of solutions is included in<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a> and.<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a> An example of interactive method utilizing trade-off information is the <a href="Zionts-Wallenius_method" title="wikilink">Zionts-Wallenius method</a>,<a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> where the decision maker is shown several objective trade-offs at each iteration, and (s)he is expected to say whether (s)he likes, dislikes or is indifferent with respect to each trade-off. In reference point based methods (see e.g.<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a><a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a>), the decision maker is expected at each iteration to specify a reference point consisting of desired values for each objective and a corresponding Pareto optimal solution(s) is then computed and shown to him/her for analysis. In classification based interactive methods, the decision maker is assumed to give preferences in the form of classifying objectives at the current Pareto optimal solution into different classes indicating how the values of the objectives should be changed to get a more preferred solution. Then, the classification information given is taken into account when new (more preferred) Pareto optimal solution(s) are computed. In the satisficing trade-off method (STOM)<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a> three classes are used: objectives whose values 1) should be improved, 2) can be relaxed, and 3) are acceptable as such. In the NIMBUS method,<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a><a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a> two additional classes are also used: objectives whose values 4) should be improved until a given bound and 5) can be relaxed until a given bound.</p>
<h2 id="hybrid-methods">Hybrid methods</h2>

<p>Different <a href="hybrid_algorithm" title="wikilink">hybrid</a> methods exist, but here we consider hybridizing MCDM (<a href="multi-criteria_decision_making" title="wikilink">multi-criteria decision making</a>) and EMO (evolutionary multi-objective optimization). A hybrid algorithm in the context of multi-objective optimization is a combination of algorithms/approaches from these two fields (see e.g.<a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a>). Hybrid algorithms of EMO and MCDM are mainly used to overcome shortcomings by utilizing strengths. Several types of hybrid algorithms have been proposed in the literature, e.g. incorporating MCDM approaches into EMO algorithms as a local search operator and to lead a DM to the most preferred solution(s) etc. A local search operator is mainly used to enhance the rate of convergence of EMO algorithms.</p>

<p>The roots for hybrid multi-objective optimization can be traced to the first Dagstuhl seminar organized in November 2004 (see, <a href="http://www.dagstuhl.de/en/program/calendar/semhp/?semnr=04461">here</a>). Here some of the best minds in EMO (Professor Kalyanmoy Deb, Professor Jürgen Branke etc.) and MCDM (Professor Kaisa Miettinen, Professor Ralph E. Steuer etc.) realized the potential in combining ideas and approaches of MCDM and EMO fields to prepare hybrids of them. Subsequently many more Dagstuhl seminars have been arranged to foster collaboration. Recently, hybrid multi-objective optimization has become an important theme in several international conferences in the area of EMO and MCDM (see e.g.<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a> and.<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a>)</p>
<h2 id="visualization-of-the-pareto-front">Visualization of the Pareto front</h2>

<p>Visualization of the Pareto front is one of the a posteriori preference techniques of multi-objective optimization. The a posteriori preference techniques (see, for example,<a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a>) provide an important class of multi-objective optimization techniques. Usually the a posteriori preference techniques include four steps: (1) computer approximates the Pareto front, i.e. the Pareto optimal set in the objective space; (2) the decision maker studies the Pareto front approximation; (3) the decision maker identifies the preferred point at the Pareto front; (4) computer provides the Pareto optimal decision, which output coincides with the objective point identified by the decision maker. From the point of view of the decision maker, the second step of the a posteriori preference techniques is the most complicated one. There are two main approaches to informing the decision maker. First, a number of points of the Pareto front can be provided in the form of a list (interesting discussion and references are given in<a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a>) or using Heatmaps.<a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a> Alternative idea consists in visualizing the Pareto front.</p>
<h3 id="visualization-in-bi-objective-problems-tradeoff-curve">Visualization in bi-objective problems: tradeoff curve</h3>

<p>In the case of bi-objective problems, informing the decision maker concerning the Pareto front is usually carried out by its visualization: the Pareto front, often named the tradeoff curve in this case, can be drawn at the objective plane. The tradeoff curve gives full information on objective values and on objective tradeoffs, which inform how improving one objective is related to deteriorating the second one while moving along the tradeoff curve. The decision maker takes this information into account while specifying the preferred Pareto optimal objective point. The idea to approximate and visualize the Pareto front was introduced for linear bi-objective decision problems by S.Gass and T.Saaty.<a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a> This idea was developed and applied in environmental problems by J.L. Cohon.<a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a> A review of methods for approximating the Pareto front for various decision problems with a small number of objectives (mainly, two) is provided in.<a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a></p>
<h3 id="visualization-in-high-order-multi-objective-optimization-problems">Visualization in high-order multi-objective optimization problems</h3>

<p>There are two generic ideas how to visualize the Pareto front in high-order multi-objective decision problems (problems with more than two objectives). One of them, which is applicable in the case of a relatively small number of objective points that represent the Pareto front, is based on using the visualization techniques developed in statistics (various diagrams, etc. – see the corresponding subsection below). The second idea proposes the display of bi-objective cross-sections (slices) of the Pareto front. It was introduced by W.S. Meisel in 1973<a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a> who argued that such slices inform the decision maker on objective tradeoffs. The figures that display a series of bi-objective slices of the Pareto front for three-objective problems are known as the decision maps. They give a clear picture of tradeoffs between three criteria. Disadvantages of such an approach are related to two following facts. First, the computational procedures for constructing the bi-objective slices of the Pareto front are not stable since the Pareto front is usually not stable. Secondly, it is applicable in the case of only three objectives. In the 1980s, the idea W.S. Meisel of implemented in a different form – in the form of the <a href="Interactive_Decision_Maps" title="wikilink">Interactive Decision Maps</a> (IDM) technique.<a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a></p>
<h2 id="multi-objective-optimization-software">Multi-objective optimization software</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name (alphabetically)</p></th>
<th style="text-align: left;">
<p>License</p></th>
<th style="text-align: left;">
<p>Brief info</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="http://www.bensolve.org">BENSOLVE</a></p></td>
<td style="text-align: left;">
<p>GPL</p></td>
<td style="text-align: left;">
<p>free VLP (vector linear programs) solver - implementation of <a href="Benson's_algorithm" title="wikilink">Benson's algorithm</a> for solving vector linear programs,<a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a> in particular, multiobjective linear programs</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="https://github.com/DEAP/deap">Distributed Evolutionary Algorithms in Python</a></p></td>
<td style="text-align: left;">
<p>LGPL</p></td>
<td style="text-align: left;">
<p>A novel evolutionary computation framework for rapid prototyping and testing of ideas. It seeks to make algorithms explicit and data structures transparent. It works in perfect harmony with different parallelisation mechanisms.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="http://moeaframework.org">MOEA Framework</a></p></td>
<td style="text-align: left;">
<p>LGPL</p></td>
<td style="text-align: left;">
<p>Java-based framework for multi-objective optimization with real, discrete, grammatical, or program representations.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="http://decisionarium.aalto.fi/">Decisionarium</a></p></td>
<td style="text-align: left;">
<p>free for academic</p></td>
<td style="text-align: left;">
<p>global space for decision support (for academic use)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="http://guimoo.gforge.inria.fr/">GUIMOO</a></p></td>
<td style="text-align: left;">
<p>LGPL</p></td>
<td style="text-align: left;">
<p>Graphical User Interface for Multi Objective Optimization from INRIA</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="http://idss.cs.put.poznan.pl/site/software.html">IDSS Software</a></p></td>
<td style="text-align: left;">
<p>free for non-profit activities</p></td>
<td style="text-align: left;">
<p>MCDM software of the Laboratory of Intelligent Decision Support Systems (University of Poznan, Poland)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="http://ind-nimbus.it.jyu.fi/">IND-NIMBUS</a></p></td>
<td style="text-align: left;">
<p>proprietary</p></td>
<td style="text-align: left;">
<p>implementation of the interactive NIMBUS method that can be connected with different simulation and modelling tools</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="http://openopt.org/interalg">interalg</a></p></td>
<td style="text-align: left;">
<p>BSD</p></td>
<td style="text-align: left;">
<p>solver with specifiable accuracy from <a class="uri" href="OpenOpt" title="wikilink">OpenOpt</a> - free universal cross-platform numerical optimization framework written in <a href="Python_language" title="wikilink">Python language</a> using <a class="uri" href="NumPy" title="wikilink">NumPy</a> arrays, see its <a href="http://openopt.org/MOP">MOP</a> page and <a href="http://openopt.org/Problems">other problems</a> involved.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="http://jmetal.sourceforge.net">jMetal</a></p></td>
<td style="text-align: left;">
<p>LGPL</p></td>
<td style="text-align: left;">
<p>Java-based framework for multi-objecive optimization with metaheuristics.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="http://makeitrational.com/">MakeItRational</a></p></td>
<td style="text-align: left;">
<p>proprietary</p></td>
<td style="text-align: left;">
<p>AHP based decision software</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="http://www.midaco-solver.com/index.php/more/multi-objective">Midacomo</a></p></td>
<td style="text-align: left;">
<p>proprietary/free</p></td>
<td style="text-align: left;">
<p>Multi-Objective extension for <a href="http://www.midaco-solver.com/">MIDACO</a> (in Matlab, Python, C/C++ and Fortran), solves (constrained) problems with continuous, discrete and mixed integer variables.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="https://bitbucket.org/melihozlen/moip_aira/">MOIP_AIRA</a></p></td>
<td style="text-align: left;">
<p>free for academic</p></td>
<td style="text-align: left;">
<p>An improved recursive algorithm for multi-objective integer programming which uses an extended LP file format with arbitrary number of objectives and returns the set of nondominated solutions.<a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="http://www.isy.vcu.edu/~hweistro/mcdmchapter.htm">Collection of Multiple Criteria Decision Support Software</a></p></td>
<td style="text-align: left;">
<p>different</p></td>
<td style="text-align: left;">
<p>by Dr. Roland Weistroffer</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="https://github.com/openmole/mgo">MGO (Multiple Goal Optimization)</a></p></td>
<td style="text-align: left;">
<p>GNU Affero GPLv3 software licence</p></td>
<td style="text-align: left;">
<p>MGO is a scala library based on the <a href="Dependency_injection" title="wikilink"> cake pattern</a> for multi-objective Evolutionary Algorithms, work also with <a class="uri" href="OpenMOLE" title="wikilink">OpenMOLE</a> using <a class="uri" href="Netlogo" title="wikilink">Netlogo</a> <a href="Agent-based_model" title="wikilink"> and other agent based model software</a>, see tutorial <a href="http://www.openmole.org/documentation/tutorials/ea-with-netlogo/">EA using Netlogo</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="http://nimbus.mit.jyu.fi/">WWW-NIMBUS</a></p></td>
<td style="text-align: left;">
<p>free for academic</p></td>
<td style="text-align: left;">
<p>for solving nonlinear (and even nondifferentiable) multiobjective optimization problems in an interactive way. Operates via the Internet.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="http://paradiseo.gforge.inria.fr/">ParadisEO-MOEO</a></p></td>
<td style="text-align: left;">
<p>CeCill</p></td>
<td style="text-align: left;">
<p>module specifically devoted to multiobjective optimization in ParadisEO, software framework for the design and implementation of metaheuristics, hybrid methods as well as parallel and distributed models from INRIA</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="https://github.com/esa/pagmo">PaGMO / PyGMO</a></p></td>
<td style="text-align: left;">
<p>free</p></td>
<td style="text-align: left;">
<p>Parallel Global Multiobjective Optimizer (and its Python alter ego PyGMO) offers a user-friendly access to a wide array of global and local optimization algorithms and problems. The main purpose of the software is to provide a parallelization engine common to all algorithms through the 'generalized island model'. Initially developed within the European Space Agency, the code was intended to help the automated design of interplanetary trajectories and spacecraft transfers in general. The user can implement his own problem and algorithm both in C++ and in Python.</p></td>
</tr>
</tbody>
</table>

<p>Weistroffer et al. have written a book chapter<a class="footnoteRef" href="#fn76" id="fnref76"><sup>76</sup></a> on multi-objective optimization software.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="MCDM" title="wikilink">Multiple criteria decision making</a></li>
<li><a href="Multidisciplinary_design_optimization" title="wikilink">Multidisciplinary design optimization</a></li>
<li><a href="Pareto_efficiency" title="wikilink">Pareto efficiency</a></li>
<li><a href="Goal_Programming" title="wikilink">Goal Programming</a></li>
<li><a href="Concurrent_programming" title="wikilink">Concurrent programming</a></li>
<li><a href="Multi-criteria_decision_analysis" title="wikilink">Multi-criteria decision analysis</a></li>
<li><a href="Vector_optimization" title="wikilink">Vector optimization</a></li>
<li><a href="Interactive_Decision_Maps" title="wikilink">Interactive Decision Maps</a></li>
<li><a href="Utility_Function" title="wikilink">Utility Function</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://mcdmsociety.org/">International Society on Multiple Criteria Decision Making</a></li>
<li><a href="http://www.calresco.org/lucas/pmo.htm">A tutorial on multiobjective optimization</a></li>
<li><a href="http://demonstrations.wolfram.com/EvolutionaryMultiobjectiveOptimization/">Evolutionary Multiobjective Optimization</a>, <a href="The_Wolfram_Demonstrations_Project" title="wikilink">The Wolfram Demonstrations Project</a></li>
<li><a href="http://www.openeering.com/sites/default/files/Multiobjective_Optimization_NSGAII_0.pdf">A Tutorial on Multiobjective Optimization and Genetic Algorithms</a>, <a class="uri" href="Scilab" title="wikilink">Scilab</a> Professional Partner</li>
<li><a href="http://www.mdpi.com/1996-1073/6/3/1439/pdf">Tomoiagă, Bogdan; Chindriş, Mircea; Sumper, Andreas; Sudria-Andreu, Antoni; Villafafila-Robles, Roberto. 2013. "Pareto Optimal Reconfiguration of Power Distribution Systems Using a Genetic Algorithm Based on NSGA-II." Energies 6, no. 3: 1439-1455.</a></li>
<li><a href="http://www.lania.mx/~ccoello/EMOO/EMOObib.html">List of References on Evolutionary Multiobjective Optimization</a></li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">E. Björnson and E. Jorswieck, <a href="http://kth.diva-portal.org/smash/get/diva2:608533/FULLTEXT01">Optimal Resource Allocation in Coordinated Multi-Cell Systems</a>, Foundations and Trends in Communications and Information Theory, vol. 9, no. 2-3, pp. 113-381, 2013.<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8">Z.-Q. Luo and S. Zhang, <a href="http://www.ece.umn.edu/~luozq/assets/pdf/publications_files/Zhang08.pdf">Dynamic spectrum management: Complexity and duality</a>, IEEE Journal of Selected Topics in Signal Processing, vol. 2, no. 1, pp. 57–73, 2008.<a href="#fnref8">↩</a></li>
<li id="fn9">Merlin, A.; Back, H. Search for a Minimal-Loss Operating Spanning Tree Configuration in an Urban Power Distribution System. In Proceedings of the 1975 Fifth Power Systems Computer Conference (PSCC), Cambridge, UK, 1–5 September 1975; pp. 1–18.<a href="#fnref9">↩</a></li>
<li id="fn10">Mendoza, J.E.; Lopez, M.E.; Coello, C.A.; Lopez, E.A. Microgenetic multiobjective reconfiguration algorithm considering power losses and reliability indices for medium voltage distribution network. IET Gener. Transm. Distrib. 2009, 3, 825–840.<a href="#fnref10">↩</a></li>
<li id="fn11">Bernardon, D.P.; Garcia, V.J.; Ferreira, A.S.Q.; Canha, L.N. Multicriteria distribution network reconfiguration considering subtransmission analysis. IEEE Trans. Power Deliv. 2010, 25, 2684–2691.<a href="#fnref11">↩</a></li>
<li id="fn12">Amanulla, B.; Chakrabarti, S.; Singh, S.N. Reconfiguration of power distribution systems considering reliability and power loss. IEEE Trans. Power Deliv. 2012, 27, 918–926.<a href="#fnref12">↩</a></li>
<li id="fn13">Tomoiagă, B.; Chindriş, M.; Sumper, A.; Sudria-Andreu, A.; Villafafila-Robles, R. <a href="http://www.mdpi.com/1996-1073/6/3/1439/pdf">Pareto Optimal Reconfiguration of Power Distribution Systems Using a Genetic Algorithm Based on NSGA-II.</a> Energies 2013, 6, 1439-1455.<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"></li>
<li id="fn38">Zitzler, E., Laumanns, M., Thiele, L.: SPEA2: Improving the Performance of the Strength Pareto Evolutionary Algorithm, Technical Report 103, Computer Engineering and Communication Networks Lab (TIK), Swiss Federal Institute of Technology (ETH) Zurich (2001) [<a class="uri" href="http://www.tik.ee.ethz.ch/publications/?db=publications&amp;form">http://www.tik.ee.ethz.ch/publications/?db=publications&amp;form;</a>;=report_single_publication&amp;publication;_id=1319]<a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"></li>
<li id="fn41"></li>
<li id="fn42"></li>
<li id="fn43"></li>
<li id="fn44"></li>
<li id="fn45"><a href="#fnref45">↩</a></li>
<li id="fn46"></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48"><a href="#fnref48">↩</a></li>
<li id="fn49"><a href="#fnref49">↩</a></li>
<li id="fn50"><a href="#fnref50">↩</a></li>
<li id="fn51"></li>
<li id="fn52"></li>
<li id="fn53"><a href="#fnref53">↩</a></li>
<li id="fn54"></li>
<li id="fn55"><a href="#fnref55">↩</a></li>
<li id="fn56"><a href="#fnref56">↩</a></li>
<li id="fn57"><a href="#fnref57">↩</a></li>
<li id="fn58"><a href="#fnref58">↩</a></li>
<li id="fn59"><a href="#fnref59">↩</a></li>
<li id="fn60"><a href="#fnref60">↩</a></li>
<li id="fn61"><a href="#fnref61">↩</a></li>
<li id="fn62"><a href="#fnref62">↩</a></li>
<li id="fn63"></li>
<li id="fn64"><a href="#fnref64">↩</a></li>
<li id="fn65"><a href="#fnref65">↩</a></li>
<li id="fn66"></li>
<li id="fn67"><a href="#fnref67">↩</a></li>
<li id="fn68"><a href="#fnref68">↩</a></li>
<li id="fn69"><a href="#fnref69">↩</a></li>
<li id="fn70"><a href="#fnref70">↩</a></li>
<li id="fn71"><a href="#fnref71">↩</a></li>
<li id="fn72"><a href="#fnref72">↩</a></li>
<li id="fn73"><a href="#fnref73">↩</a></li>
<li id="fn74"><a href="#fnref74">↩</a></li>
<li id="fn75"><a href="#fnref75">↩</a></li>
<li id="fn76"><a href="#fnref76">↩</a></li>
</ol>
</section>
</hr></body>
</html>
