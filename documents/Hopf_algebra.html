<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="76">Hopf algebra</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hopf algebra</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>Hopf algebra</strong>, named after <a href="Heinz_Hopf" title="wikilink">Heinz Hopf</a>, is a structure that is simultaneously an (<a href="unital_algebra" title="wikilink">unital</a> associative) <a href="Associative_algebra" title="wikilink">algebra</a> and a (counital coassociative) <a class="uri" href="coalgebra" title="wikilink">coalgebra</a>, with these structures' compatibility making it a <a class="uri" href="bialgebra" title="wikilink">bialgebra</a>, and that moreover is equipped with an <a class="uri" href="antiautomorphism" title="wikilink">antiautomorphism</a> satisfying a certain property. The <a href="representation_theory" title="wikilink">representation theory</a> of a Hopf algebra is particularly nice, since the existence of compatible comultiplication, counit, and antipode allows for the construction of tensor products of representations, trivial representations, and dual representations.</p>

<p>Hopf algebras occur naturally in <a href="algebraic_topology" title="wikilink">algebraic topology</a>, where they originated and are related to the <a class="uri" href="H-space" title="wikilink">H-space</a> concept, in <a href="group_scheme" title="wikilink">group scheme</a> theory, in <a href="group_theory" title="wikilink">group theory</a> (via the concept of a <a href="group_ring" title="wikilink">group ring</a>), and in numerous other places, making them probably the most familiar type of <a class="uri" href="bialgebra" title="wikilink">bialgebra</a>. Hopf algebras are also studied in their own right, with much work on specific classes of examples on the one hand and classification problems on the other.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Formally, a Hopf algebra is a (associative and coassociative) <a class="uri" href="bialgebra" title="wikilink">bialgebra</a> <em>H</em> over a <a href="field_(mathematics)" title="wikilink">field</a> <em>K</em> together with a <a href="linear_transformation" title="wikilink"><em>K</em>-linear</a> map <em>S</em>: <em>H</em> → <em>H</em> (called the <strong>antipode</strong>) such that the following diagram <a href="commutative_diagram" title="wikilink">commutes</a>:</p>
<div style="text-align: center;">
<figure><b>(Figure)</b>
<figcaption>antipode commutative diagram</figcaption>
</figure>
</div>

<p>Here Δ is the comultiplication of the bialgebra, ∇ its multiplication, η its unit and ε its counit. In the sumless <a href="Sweedler_notation" title="wikilink">Sweedler notation</a>, this property can also be expressed as</p>

<p>

<math display="block" id="Hopf_algebra:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>c</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>2</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>c</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>ϵ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mtext>for all</mtext>
      <mi>c</mi>
     </mrow>
     <mo>∈</mo>
     <mi>H</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>S</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>S</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>ϵ</ci>
       <ci>c</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <mtext>for all</mtext>
      <ci>c</ci>
     </apply>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(c_{(1)})c_{(2)}=c_{(1)}S(c_{(2)})=\epsilon(c)1\qquad\mbox{ for all }c\in H.
  </annotation>
 </semantics>
</math>

</p>

<p>As for <a href="associative_algebra" title="wikilink">algebras</a>, one can replace the underlying field <em>K</em> with a <a href="commutative_ring" title="wikilink">commutative ring</a> <em>R</em> in the above definition.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The definition of Hopf algebra is <a href="Dual_(category_theory)" title="wikilink">self-dual</a> (as reflected in the symmetry of the above diagram), so if one can define a <a href="Dual_space" title="wikilink">dual</a> of <em>H</em> (which is always possible if <em>H</em> is finite-dimensional), then it is automatically a Hopf algebra.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="properties-of-the-antipode">Properties of the antipode</h3>

<p>The antipode <em>S</em> is sometimes required to have a <em>K</em>-linear inverse, which is automatic in the finite-dimensional case, or if <em>H</em> is <a class="uri" href="commutative" title="wikilink">commutative</a> or <a class="uri" href="cocommutative" title="wikilink">cocommutative</a> (or more generally <a href="Quasitriangular_Hopf_algebra" title="wikilink">quasitriangular</a>).</p>

<p>In general, <em>S</em> is an <a class="uri" href="antihomomorphism" title="wikilink">antihomomorphism</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> so <em>S</em><sup>2</sup> is a <a class="uri" href="homomorphism" title="wikilink">homomorphism</a>, which is therefore an automorphism if <em>S</em> was invertible (as may be required).</p>

<p>If <em>S</em><sup>2</sup> = id<sub><em>H</em></sub>, then the Hopf algebra is said to be <strong>involutive</strong> (and the underlying algebra with involution is a <a class="uri" href="*-algebra" title="wikilink">*-algebra</a>). If <em>H</em> is finite-dimensional semisimple over a field of characteristic zero, commutative, or cocommutative, then it is involutive.</p>

<p>If a bialgebra <em>B</em> admits an antipode <em>S</em>, then <em>S</em> is unique ("a bialgebra admits at most 1 Hopf algebra structure").<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The antipode is an analog to the inversion map on a group that sends <em>g</em> to <em>g</em><sup>−1</sup>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="hopf-subalgebras">Hopf subalgebras</h3>

<p>A subalgebra <em>A</em> of a Hopf algebra <em>H</em> is a Hopf subalgebra if it is a subcoalgebra of <em>H</em> and the antipode <em>S</em> maps <em>A</em> into <em>A</em>. In other words, a Hopf subalgebra A is a Hopf algebra in its own right when the multiplication, comultiplication, counit and antipode of <em>H</em> is restricted to <em>A</em> (and additionally the identity 1 of <em>H</em> is required to be in A). The Nichols–Zoeller freeness theorem established (in 1989) that the natural <em>A</em>-module <em>H</em> is free of finite rank if <em>H</em> is finite-dimensional: a generalization of <a href="Lagrange's_theorem_(group_theory)" title="wikilink">Lagrange's theorem for subgroups</a>. As a corollary of this and integral theory, a Hopf subalgebra of a semisimple finite-dimensional Hopf algebra is automatically semisimple.</p>

<p>A Hopf subalgebra <em>A</em> is said to be right normal in a Hopf algebra <em>H</em> if it satisfies the condition of stability, <em>ad<sub>r</sub></em>(<em>h</em>)(<em>A</em>) ⊆ <em>A</em> for all <em>h</em> in <em>H</em>, where the right adjoint mapping <em>ad<sub>r</sub></em> is defined by <em>ad<sub>r</sub></em>(<em>h</em>)(<em>a</em>) = <em>S</em>(<em>h</em><sub>(1)</sub>)<em>ah</em><sub>(2)</sub> for all <em>a</em> in <em>A</em>, <em>h</em> in <em>H</em>. Similarly, a Hopf subalgebra <em>A</em> is left normal in <em>H</em> if it is stable under the left adjoint mapping defined by <em>ad<sub>l</sub></em>(<em>h</em>)(<em>a</em>) = <em>h</em><sub>(1)</sub><em>aS</em>(<em>h</em><sub>(2)</sub>). The two conditions of normality are equivalent if the antipode <em>S</em> is bijective, in which case <em>A</em> is said to be a normal Hopf subalgebra.</p>

<p>A normal Hopf subalgebra <em>A</em> in <em>H</em> satisfies the condition (of equality of subsets of H): <em>HA</em><sup>+</sup> = <em>A</em><sup>+</sup><em>H</em> where <em>A</em><sup>+</sup> denotes the kernel of the counit on <em>K</em>. This normality condition implies that <em>HA</em><sup>+</sup> is a Hopf ideal of <em>H</em> (i.e. an algebra ideal in the kernel of the counit, a coalgebra coideal and stable under the antipode). As a consequence one has a quotient Hopf algebra <em>H</em>/<em>HA</em><sup>+</sup> and epimorphism <em>H</em> → <em>H</em>/<em>A</em><sup>+</sup><em>H</em>, a theory analogous to that of normal subgroups and quotient groups in <a href="group_theory" title="wikilink">group theory</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="hopf-orders">Hopf orders</h3>

<p>A <strong>Hopf order</strong> <em>O</em> over an <a href="integral_domain" title="wikilink">integral domain</a> <em>R</em> with <a href="field_of_fractions" title="wikilink">field of fractions</a> <em>K</em> is an <a href="Order_(ring_theory)" title="wikilink">order</a> in a Hopf algebra <em>H</em> over <em>K</em> which is closed under the algebra and coalgebra operations: in particular, the comultiplication Δ maps <em>O</em> to <em>O</em>⊗<em>O</em>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="group-like-elements">Group-like elements</h3>

<p>A <strong>group-like element</strong> is an element <em>x</em> such that Δ(<em>x</em>) = <em>x</em>⊗<em>x</em>. The group-like elements form a group with inverse given by the antipode.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> A <strong><a href="primitive_element_(co-algebra)" title="wikilink">primitive element</a></strong> <em>x</em> satisfies Δ(<em>x</em>) = <em>x</em>⊗1 + 1⊗<em>x</em>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="representation-theory">Representation theory</h2>

<p>Let <em>A</em> be a Hopf algebra, and let <em>M</em> and <em>N</em> be <em>A</em>-modules. Then, <em>M</em> ⊗ <em>N</em> is also an <em>A</em>-module, with</p>

<p>

<math display="block" id="Hopf_algebra:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>⊗</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>⊗</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>a</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>⊗</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mi>m</mi>
      </mrow>
      <mo>⊗</mo>
      <msub>
       <mi>a</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>a</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(m\otimes n):=\Delta(a)(m\otimes n)=(a_{1}\otimes a_{2})(m\otimes n)=(a_{1}m%
\otimes a_{2}n)
  </annotation>
 </semantics>
</math>

 for <em>m</em> ∈ <em>M</em>, <em>n</em> ∈ <em>N</em> and Δ(<em>a</em>) = (<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>). Furthermore, we can define the trivial representation as the base field <em>K</em> with</p>

<p>

<math display="block" id="Hopf_algebra:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mi>ϵ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ϵ</ci>
     <ci>a</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(m):=\epsilon(a)m
  </annotation>
 </semantics>
</math>

 for <em>m</em> ∈ <em>K</em>. Finally, the dual representation of <em>A</em> can be defined: if <em>M</em> is an <em>A</em>-module and <em>M*</em> is its dual space, then</p>

<p>

<math display="block" id="Hopf_algebra:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>f</ci>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>a</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (af)(m):=f(S(a)m)
  </annotation>
 </semantics>
</math>

 where <em>f</em> ∈ <em>M*</em> and <em>m</em> ∈ <em>M</em>.</p>

<p>The relationship between Δ, ε, and <em>S</em> ensure that certain natural homomorphisms of vector spaces are indeed homomorphisms of <em>A</em>-modules. For instance, the natural isomorphisms of vector spaces <em>M</em> → <em>M</em> ⊗ <em>K</em> and <em>M</em> → <em>K</em> ⊗ <em>M</em> are also isomorphisms of <em>A</em>-modules. Also, the map of vector spaces <em>M*</em> ⊗ <em>M</em> → <em>K</em> with <em>f</em> ⊗ <em>m</em> → <em>f</em>(<em>m</em>) is also a homomorphism of <em>A</em>-modules. However, the map <em>M</em> ⊗ <em>M*</em> → <em>K</em> is not necessarily a homomorphism of <em>A</em>-modules.</p>
<h2 id="examples">Examples</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>Depending on</p></th>
<th style="text-align: left;">
<p>Comultiplication</p></th>
<th style="text-align: left;">
<p>Counit</p></th>
<th style="text-align: left;">
<p>Antipode</p></th>
<th style="text-align: left;">
<p>Commutative</p></th>
<th style="text-align: left;">
<p>Cocommutative</p></th>
<th style="text-align: left;">
<p>Remarks</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="group_ring" title="wikilink">group algebra</a> <em>KG</em></p></td>
<td style="text-align: left;">
<p><a href="group_(mathematics)" title="wikilink">group</a> <em>G</em></p></td>
<td style="text-align: left;">
<p>Δ(<em>g</em>) = <em>g</em> ⊗ <em>g</em> for all <em>g</em> in <em>G</em></p></td>
<td style="text-align: left;">
<p>ε(<em>g</em>) = 1 for all <em>g</em> in <em>G</em></p></td>
<td style="text-align: left;">
<p><em>S</em>(<em>g</em>) = <em>g</em><sup>−1</sup> for all <em>g</em> in <em>G</em></p></td>
<td style="text-align: left;">
<p>if and only if <em>G</em> is abelian</p></td>
<td style="text-align: left;">
<p>yes</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>functions <em>f</em> from a finite<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> group to <em>K</em>, <em>K<sup>G</sup></em> (with pointwise addition and multiplication)</p></td>
<td style="text-align: left;">
<p>finite group <em>G</em></p></td>
<td style="text-align: left;">
<p>Δ(<em>f</em>)(<em>x</em>,<em>y</em>) = <em>f</em>(<em>xy</em>)</p></td>
<td style="text-align: left;">
<p>ε(<em>f</em>) = <em>f</em>(1<sub><em>G</em></sub>)</p></td>
<td style="text-align: left;">
<p><em>S</em>(<em>f</em>)(<em>x</em>) = <em>f</em>(<em>x</em><sup>−1</sup>)</p></td>
<td style="text-align: left;">
<p>yes</p></td>
<td style="text-align: left;">
<p>if and only if <em>G</em> is commutative</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Representative_function" title="wikilink">Representative functions</a> on a compact group</p></td>
<td style="text-align: left;">
<p>compact group <em>G</em></p></td>
<td style="text-align: left;">
<p>Δ(<em>f</em>)(<em>x</em>,<em>y</em>) = <em>f</em>(<em>xy</em>)</p></td>
<td style="text-align: left;">
<p>ε(<em>f</em>) = <em>f</em>(1<sub><em>G</em></sub>)</p></td>
<td style="text-align: left;">
<p><em>S</em>(<em>f</em>)(<em>x</em>) = <em>f</em>(<em>x</em><sup>−1</sup>)</p></td>
<td style="text-align: left;">
<p>yes</p></td>
<td style="text-align: left;">
<p>if and only if <em>G</em> is commutative</p></td>
<td style="text-align: left;">
<p>Conversely, every commutative involutive <a href="reduced_algebra" title="wikilink">reduced</a> Hopf algebra over <strong>C</strong> with a finite Haar integral arises in this way, giving one formulation of <a href="Tannaka–Krein_duality" title="wikilink">Tannaka–Krein duality</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Regular_function" title="wikilink">Regular functions</a> on an <a href="algebraic_group" title="wikilink">algebraic group</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Δ(<em>f</em>)(<em>x</em>,<em>y</em>) = <em>f</em>(<em>xy</em>)</p></td>
<td style="text-align: left;">
<p>ε(<em>f</em>) = <em>f</em>(1<sub><em>G</em></sub>)</p></td>
<td style="text-align: left;">
<p><em>S</em>(<em>f</em>)(<em>x</em>) = <em>f</em>(<em>x</em><sup>−1</sup>)</p></td>
<td style="text-align: left;">
<p>yes</p></td>
<td style="text-align: left;">
<p>if and only if <em>G</em> is commutative</p></td>
<td style="text-align: left;">
<p>Conversely, every commutative Hopf algebra over a field arises from a <a href="group_scheme" title="wikilink">group scheme</a> in this way, giving an <a href="equivalence_(category_theory)" title="wikilink">antiequivalence</a> of categories.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Tensor_algebra" title="wikilink">Tensor algebra</a> T(<em>V</em>)</p></td>
<td style="text-align: left;">
<p><a href="vector_space" title="wikilink">vector space</a> <em>V</em></p></td>
<td style="text-align: left;">
<p>Δ(<em>x</em>) = <em>x</em> ⊗ 1 + 1 ⊗ <em>x</em>, <em>x</em> in <em>V</em> , Δ(1) = 1 ⊗ 1</p></td>
<td style="text-align: left;">
<p>ε(<em>x</em>) = 0</p></td>
<td style="text-align: left;">
<p><em>S</em>(<em>x</em>) = −<em>x</em> for all <em>x</em> in <em>T<sup>1</sup>(V)</em> (and extended to higher tensor powers)</p></td>
<td style="text-align: left;">
<p>no</p></td>
<td style="text-align: left;">
<p>yes</p></td>
<td style="text-align: left;">
<p><a href="symmetric_algebra" title="wikilink">symmetric algebra</a> and <a href="exterior_algebra" title="wikilink">exterior algebra</a> (which are quotients of the tensor algebra) are also Hopf algebras with this definition of the comultiplication, counit and antipode</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Universal_enveloping_algebra" title="wikilink">Universal enveloping algebra</a> U(g)</p></td>
<td style="text-align: left;">
<p><a href="Lie_algebra" title="wikilink">Lie algebra</a> <em>g</em></p></td>
<td style="text-align: left;">
<p>Δ(<em>x</em>) = <em>x</em> ⊗ 1 + 1 ⊗ <em>x</em> for every <em>x</em> in <em>g</em> (this rule is compatible with <a href="commutator" title="wikilink">commutators</a> and can therefore be uniquely extended to all of <em>U</em>)</p></td>
<td style="text-align: left;">
<p>ε(<em>x</em>) = 0 for all <em>x</em> in <em>g</em> (again, extended to <em>U</em>)</p></td>
<td style="text-align: left;">
<p><em>S</em>(<em>x</em>) = −<em>x</em></p></td>
<td style="text-align: left;">
<p>if and only if <em>g</em> is abelian</p></td>
<td style="text-align: left;">
<p>yes</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Sweedler's_Hopf_algebra" title="wikilink">Sweedler's Hopf algebra</a> <em>H</em>=<em>K</em>[<em>c</em>, <em>x</em>]/<em>c<sup>2</sup></em> = 1, <em>x</em><sup>2</sup> = 0 and <em>xc</em> = −<em>cx</em>.</p></td>
<td style="text-align: left;">
<p><em>K</em> is a field with <a href="Field_characteristic" title="wikilink">characteristic</a> different from 2</p></td>
<td style="text-align: left;">
<p>Δ(<em>c</em>) = <em>c</em> ⊗ <em>c</em>, Δ(<em>x</em>) = <em>c</em> ⊗ <em>x</em> + <em>x</em> ⊗ 1, Δ(1) = 1 ⊗ 1</p></td>
<td style="text-align: left;">
<p>ε(<em>c</em>) = 1 and ε(<em>x</em>) = 0</p></td>
<td style="text-align: left;">
<p><em>S</em>(<em>c</em>) = <em>c<sup>−1</sup> = c</em> and <em>S(x)</em> = −<em>cx</em></p></td>
<td style="text-align: left;">
<p>no</p></td>
<td style="text-align: left;">
<p>no</p></td>
<td style="text-align: left;">
<p>The underlying <a href="vector_space" title="wikilink">vector space</a> is generated by <em>{1, c, x, cx}</em> and thus has dimension 4. This is the smallest example of a Hopf algebra that is both non-commutative and non-cocommutative.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="ring_of_symmetric_functions" title="wikilink">ring of symmetric functions</a><ref>See</ref></p>

<p><code>   Michiel Hazewinkel, </code><em><code>Symmetric</code> <code>Functions,</code> <code>Noncommutative</code> <code>Symmetric</code> <code>Functions,</code> <code>and</code> <code>Quasisymmetric</code> <code>Functions</code></em><code>, Acta Applicandae Mathematica, January 2003, Volume 75, Issue 1-3, pp 55–83</code><code> </code></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>| in terms of complete homogeneous symmetric functions <em>h</em><sub><em>k</em></sub> (<em>k</em> ≥ 1)

<math display="block" id="Hopf_algebra:4">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>h</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>⊗</mo>
     <msub>
      <mi>h</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>h</mi>
      <mn>1</mn>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mi>h</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>h</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mi>h</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>k</mi>
     </msub>
     <mo>⊗</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(h_{k})=1\otimes h_{k}+h_{1}\otimes h_{k-1}+\cdots+h_{k-1}\otimes h_{1}+%
h_{k}\otimes 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>| 

<math display="inline" id="Hopf_algebra:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϵ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>h</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϵ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon(h_{k})=0
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>| 

<math display="inline" id="Hopf_algebra:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>h</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>k</mi>
    </msup>
    <msub>
     <mi>e</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(h_{k})=(-1)^{k}e_{k}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>| yes</p></td>
<td style="text-align: left;">
<p>yes</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>Note that functions on a finite group can be identified with the group ring, though these are more naturally thought of as dual – the group ring consists of <em>finite</em> sums of elements, and thus pairs with functions on the group by evaluating the function on the summed elements.</p>
<h2 id="cohomology-of-lie-groups">Cohomology of Lie groups</h2>

<p>The cohomology algebra of a Lie group is a Hopf algebra: the multiplication is provided by the cup-product, and the comultiplication</p>

<p>

<math display="block" id="Hopf_algebra:7">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>H</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>G</mi>
      <mo>×</mo>
      <mi>G</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>H</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>G</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <msup>
      <mi>H</mi>
      <mo>*</mo>
     </msup>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <times></times>
      </apply>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <times></times>
      </apply>
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>G</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>H</ci>
         <times></times>
        </apply>
        <ci>G</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>H</ci>
        <times></times>
       </apply>
      </apply>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{*}(G)\rightarrow H^{*}(G\times G)\cong H^{*}(G)\otimes H^{*}(G)
  </annotation>
 </semantics>
</math>

 by the group multiplication <em>G</em> × <em>G</em> → <em>G</em>. This observation was actually a source of the notion of Hopf algebra. Using this structure, Hopf proved a structure theorem for the cohomology algebra of Lie groups.</p>

<p><strong>Theorem (Hopf)</strong><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Let <em>A</em> be a finite-dimensional, <a href="Graded-commutative" title="wikilink">graded commutative</a>, graded cocommutative Hopf algebra over a field of characteristic 0. Then <em>A</em> (as an algebra) is a free exterior algebra with generators of odd degree.</p>
<h2 id="quantum-groups-and-non-commutative-geometry">Quantum groups and non-commutative geometry</h2>

<p>All examples above are either commutative (i.e. the multiplication is <a class="uri" href="commutative" title="wikilink">commutative</a>) or co-commutative (i.e.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Δ = <em>T</em> ∘ Δ where the <em>twist map</em><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> <em>T</em>: <em>H</em> ⊗ <em>H</em> → <em>H</em> ⊗ <em>H</em> is defined by <em>T</em>(<em>x</em> ⊗ <em>y</em>) = <em>y</em> ⊗ <em>x</em>). Other interesting Hopf algebras are certain "deformations" or "<a href="quantization_(physics)" title="wikilink">quantizations</a>" of those from example 3 which are neither commutative nor co-commutative. These Hopf algebras are often called <em><a href="quantum_groups" title="wikilink">quantum groups</a></em>, a term that is so far only loosely defined. They are important in <a href="noncommutative_geometry" title="wikilink">noncommutative geometry</a>, the idea being the following: a standard algebraic group is well described by its standard Hopf algebra of regular functions; we can then think of the deformed version of this Hopf algebra as describing a certain "non-standard" or "quantized" algebraic group (which is not an algebraic group at all). While there does not seem to be a direct way to define or manipulate these non-standard objects, one can still work with their Hopf algebras, and indeed one <em>identifies</em> them with their Hopf algebras. Hence the name "quantum group".</p>
<h2 id="related-concepts">Related concepts</h2>

<p><a href="Graded_algebra" title="wikilink">Graded</a> Hopf algebras are often used in <a href="algebraic_topology" title="wikilink">algebraic topology</a>: they are the natural algebraic structure on the direct sum of all <a href="homology_(mathematics)" title="wikilink">homology</a> or <a class="uri" href="cohomology" title="wikilink">cohomology</a> groups of an <a class="uri" href="H-space" title="wikilink">H-space</a>.</p>

<p><a href="Locally_compact_quantum_group" title="wikilink">Locally compact quantum groups</a> generalize Hopf algebras and carry a <a href="topological_space" title="wikilink">topology</a>. The algebra of all <a href="continuous_function" title="wikilink">continuous functions</a> on a <a href="Lie_group" title="wikilink">Lie group</a> is a locally compact quantum group.</p>

<p><a href="Quasi-Hopf_algebra" title="wikilink">Quasi-Hopf algebras</a> are generalizations of Hopf algebras, where coassociativity only holds up to a twist. They have been used in the study of the <a href="Knizhnik–Zamolodchikov_equations" title="wikilink">Knizhnik–Zamolodchikov equations</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p><a href="Multiplier_Hopf_algebra" title="wikilink">Multiplier Hopf algebras</a> introduced by Alfons Van Daele in 1994<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> are generalizations of <a href="Hopf_algebras" title="wikilink">Hopf algebras</a> where comultiplication from an algebra (with or without unit) to the <a href="multiplier_algebra" title="wikilink">multiplier algebra</a> of tensor product algebra of the algebra with itself.</p>

<p><a href="Hopf_group-(co)algebra" title="wikilink">Hopf group-(co)algebras</a> introduced by V. G. Turaev in 2000 are also generalizations of Hopf algebras.</p>
<h3 id="weak-hopf-algebras">Weak Hopf algebras</h3>

<p><a href="Weak_Hopf_algebra" title="wikilink">Weak Hopf algebras</a>, or quantum groupoids, are generalizations of Hopf algebras. Like Hopf algebras, weak Hopf algebras form a self-dual class of algebras; i.e., if <em>H</em> is a (weak) Hopf algebra, so is <em>H</em>*, the dual space of linear forms on <em>H</em> (with respect to the algebra-coalgebra structure obtained from the natural pairing with <em>H</em> and its coalgebra-algebra structure). A weak Hopf algebra <em>H</em> is usually taken to be a</p>
<ul>
<li>finite-dimensional algebra and coalgebra with coproduct Δ: <em>H</em> → <em>H</em> ⊗ <em>H</em> and counit ε: <em>H</em> → <em>k</em> satisfying all the axioms of Hopf algebra except possibly Δ(1) ≠ 1 ⊗ 1 or ε(<em>ab</em>) ≠ ε(<em>a</em>)ε(<em>b</em>) for some <em>a,b</em> in <em>H</em>. Instead one requires the following:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hopf_algebra:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊗</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>⊗</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>⊗</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊗</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mo>⊗</mo>
      <mtext>Id</mtext>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <cn type="integer">1</cn>
        <ci>normal-Δ</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <cn type="integer">1</cn>
        <ci>normal-Δ</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>normal-Δ</ci>
       <mtext>Id</mtext>
      </apply>
      <ci>normal-Δ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Delta(1)\otimes 1)(1\otimes\Delta(1))=(1\otimes\Delta(1))(\Delta(1)\otimes 1%
)=(\Delta\otimes\mbox{Id})\Delta(1)
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Hopf_algebra:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϵ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>ϵ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <msub>
        <mi>b</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ϵ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>b</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mi>c</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>ϵ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <msub>
        <mi>b</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>2</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ϵ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>b</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </msub>
       <mi>c</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ϵ</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <apply>
      <sum></sum>
      <apply>
       <times></times>
       <ci>ϵ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>ϵ</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <sum></sum>
      <apply>
       <times></times>
       <ci>ϵ</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>ϵ</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon(abc)=\sum\epsilon(ab_{(1)})\epsilon(b_{(2)}c)=\sum\epsilon(ab_{(2)})%
\epsilon(b_{(1)}c)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>for all <em>a</em>, <em>b</em>, and <em>c</em> in <em>H</em>.
</dd>
</dl>
<ul>
<li><em>H</em> has a weakened antipode <em>S</em>: <em>H</em> → <em>H</em> satisfying the axioms:</li>
</ul>
<ol>
<li>

<math display="inline" id="Hopf_algebra:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mn>1</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mi>ϵ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <msub>
       <mn>1</mn>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>2</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </apply>
     <ci>ϵ</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(a_{(1)})a_{(2)}=1_{(1)}\epsilon(a1_{(2)})
  </annotation>
 </semantics>
</math>

 for all <em>a</em> in <em>H</em> (the right-hand side is the interesting projection usually denoted by Π<sup><em>R</em></sup>(<em>a</em>) or ε<sub><em>s</em></sub>(<em>a</em>) with image a separable subalgebra denoted by <em>H<sup>R</sup></em> or <em>H<sub>s</sub></em>);</li>
<li>

<math display="inline" id="Hopf_algebra:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>2</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ϵ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mn>1</mn>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mn>1</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>ϵ</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{(1)}S(a_{(2)})=\epsilon(1_{(1)}a)1_{(2)}
  </annotation>
 </semantics>
</math>

 for all <em>a</em> in <em>H</em> (another interesting projection usually denoted by Π<sup><em>R</em></sup>(<em>a</em>) or ε<sub><em>t</em></sub>(<em>a</em>) with image a separable algebra <em>H<sup>L</sup></em> or <em>H<sub>t</sub></em>, anti-isomorphic to <em>H<sup>L</sup></em> via <em>S</em>);</li>
<li>

<math display="inline" id="Hopf_algebra:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>3</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(a_{(1)})a_{(2)}S(a_{(3)})=S(a)
  </annotation>
 </semantics>
</math>

 for all <em>a</em> in <em>H</em>.</li>
</ol>
<dl>
<dd>Note that if Δ(1) = 1 ⊗ 1, these conditions reduce to the two usual conditions on the antipode of a Hopf algebra.
</dd>
</dl>

<p>The axioms are partly chosen so that the category of <em>H</em>-modules is a <a href="rigid_category" title="wikilink">rigid monoidal category</a>. The unit <em>H</em>-module is the separable algebra <em>H<sup>L</sup></em> mentioned above.</p>

<p>For example, a finite <a class="uri" href="groupoid" title="wikilink">groupoid</a> algebra is a weak Hopf algebra. In particular, the groupoid algebra on [n] with one pair of invertible arrows <em>e<sub>ij</sub></em> and <em>e<sub>ji</sub></em> between <em>i</em> and <em>j</em> in [<em>n</em>] is isomorphic to the algebra <em>H</em> of <em>n</em> x <em>n</em> matrices. The weak Hopf algebra structure on this particular <em>H</em> is given by coproduct Δ(<em>e<sub>ij</sub></em>) = <em>e<sub>ij</sub></em> ⊗ <em>e<sub>ij</sub></em>, counit ε(<em>e<sub>ij</sub></em>) = 1 and antipode <em>S</em>(<em>e<sub>ij</sub></em>) = <em>e<sub>ji</sub></em>. The separable subalgebras <em>H<sup>L</sup></em> and <em>H<sup>R</sup></em> coincide and are non-central commutative algebras in this particular case (the subalgebra of diagonal matrices).</p>

<p>Early theoretical contributions to weak Hopf algebras are to be found in<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> as well as<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h3 id="hopf-algebroids">Hopf algebroids</h3>

<p>See <a href="Hopf_algebroid" title="wikilink">Hopf algebroid</a></p>
<h2 id="analogy-with-groups">Analogy with groups</h2>

<p>Groups can be axiomatized by the same diagrams (equivalently, operations) as a Hopf algebra, where <em>G</em> is taken to be a set instead of a module. In this case:</p>
<ul>
<li>the field <em>K</em> is replaced by the 1-point set</li>
<li>there is a natural counit (map to 1 point)</li>
<li>there is a natural comultiplication (the diagonal map)</li>
<li>the unit is the identity element of the group</li>
<li>the multiplication is the multiplication in the group</li>
<li>the antipode is the inverse</li>
</ul>

<p>In this philosophy, a group can be thought of as a Hopf algebra over the "<a href="field_with_one_element" title="wikilink">field with one element</a>".<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Quasitriangular_Hopf_algebra" title="wikilink">Quasitriangular Hopf algebra</a></li>
<li><a href="Algebra/set_analogy" title="wikilink">Algebra/set analogy</a></li>
<li><a href="Representation_theory_of_Hopf_algebras" title="wikilink">Representation theory of Hopf algebras</a></li>
<li><a href="Ribbon_Hopf_algebra" title="wikilink">Ribbon Hopf algebra</a></li>
<li><a class="uri" href="Superalgebra" title="wikilink">Superalgebra</a></li>
<li><a href="Supergroup_(physics)" title="wikilink">Supergroup</a></li>
<li><a href="Anyonic_Lie_algebra" title="wikilink">Anyonic Lie algebra</a></li>
<li><a href="Sweedler's_Hopf_algebra" title="wikilink">Sweedler's Hopf algebra</a></li>
<li><a href="Hopf_algebra_of_permutations" title="wikilink">Hopf algebra of permutations</a></li>
<li><a href="Milnor–Moore_theorem" title="wikilink">Milnor–Moore theorem</a></li>
</ul>
<h2 id="notes-and-references">Notes and references</h2>
<h3 id="notes">Notes</h3>
<h3 id="references">References</h3>
<ul>
<li>

<p>.</p></li>
<li>Pierre Cartier, <a href="http://preprints.ihes.fr/2006/M/M-06-40.pdf"><em>A primer of Hopf algebras</em></a>, IHES preprint, September 2006, 81 pages</li>
<li></li>
<li>H. Hopf, Uber die Topologie der Gruppen-Mannigfaltigkeiten und ihrer Verallgemeinerungen, Ann. of Math. 42 (1941), 22–52. Reprinted in Selecta Heinz Hopf, pp. 119–151, Springer, Berlin (1964). , </li>
<li></li>
<li>

<p>.</p></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Hopf_algebras" title="wikilink"> </a> <a href="Category:Monoidal_categories" title="wikilink">Category:Monoidal categories</a> <a href="Category:Representation_theory" title="wikilink">Category:Representation theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Underwood (2011) p.55<a href="#fnref1">↩</a></li>
<li id="fn2">Underwood (2011) p.62<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://www.mathematik.uni-muenchen.de/~pareigis/Vorlesungen/98SS/Quantum_Groups/LN2_1.PDF">Quantum groups lecture notes</a><a href="#fnref5">↩</a></li>
<li id="fn6">Montgomery (1993) p.36<a href="#fnref6">↩</a></li>
<li id="fn7">Underwood (2011) p.82<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">The finiteness of <em>G</em> implies that <em>K<sup>G</sup></em> ⊗ <em>K<sup>G</sup></em> is naturally isomorphic to <em>K</em><sup><em>G</em>x<em>G</em></sup>. This is used in the above formula for the comultiplication. For infinite groups <em>G</em>, <em>K<sup>G</sup></em> ⊗ <em>K<sup>G</sup></em> is a proper subset of <em>K</em><sup><em>G</em>x<em>G</em></sup>. In this case the space of functions with finite <a href="support_(mathematics)" title="wikilink">support</a> can be endowed with a Hopf algebra structure.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13">, section 2.3<a href="#fnref13">↩</a></li>
<li id="fn14">Hopf, 1941.<a href="#fnref14">↩</a></li>
<li id="fn15">Underwood (2011) p.57<a href="#fnref15">↩</a></li>
<li id="fn16">Underwood (2011) p.36<a href="#fnref16">↩</a></li>
<li id="fn17">Montgomery (1993) p. 203<a href="#fnref17">↩</a></li>
<li id="fn18">Alfons Van Daele. <em><a href="http://www.ams.org/tran/1994-342-02/S0002-9947-1994-1220906-5/S0002-9947-1994-1220906-5.pdf">Multiplier Hopf algebras</a></em>, Transactions of the American Mathematical Society 342(2) (1994) 917–932<a href="#fnref18">↩</a></li>
<li id="fn19">Gabriella Böhm, Florian Nill, Kornel Szlachanyi. J. Algebra 221 (1999), 385–438<a href="#fnref19">↩</a></li>
<li id="fn20">Dmitri Nikshych, Leonid Vainerman, in: New direction in Hopf algebras, S. Montgomery and H.-J. Schneider, eds., M.S.R.I. Publications, vol. 43, Cambridge, 2002, 211–262.<a href="#fnref20">↩</a></li>
<li id="fn21"><a href="http://sbseminar.wordpress.com/2007/10/07/group-hopf-algebra/">Group = Hopf algebra « Secret Blogging Seminar</a>, <a href="http://www.youtube.com/watch?v=p3kkm5dYH-w">Group objects and Hopf algebras</a>, video of Simon Willerton.<a href="#fnref21">↩</a></li>
</ol>
</section>
</body>
</html>
