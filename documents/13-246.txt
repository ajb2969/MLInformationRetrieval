   FOSD Program Cubes      FOSD Program Cubes   A program in Feature Oriented Software Development (FOSD) is a composition of functions (program transformations): a base program (modeled by a nullary function) is composed with increments in program functionality, called features (which are unary functions), to produce a complex program. A software product line (SPL) is a family of related programs. Suppose product line PL has F 0 as a base program, and F 1 ..F n as features that could be added to F 0 . Different compositions of these functions/transformations yield different programs. For this discussion, let + denote function composition. A program P in PL might have the following expression:       P  =    F  8   +   F  4   +   F  2   +   F  1   +   F  0        P     subscript  F  8    subscript  F  4    subscript  F  2    subscript  F  1    subscript  F  0      P=F_{8}+F_{4}+F_{2}+F_{1}+F_{0}     That is, P extends program F 0 with features F 1 , F 2 , F 4 , and F 8 in this order.  We can recast P in terms of a projection and contraction of a 1-dimensional array. Let F i = [F 0 .. F n ] denote the array of transformations that define PL. A projection of F i eliminates unneeded transformations, yielding a shorter array (call it) G i . A contraction of G i composes each transformation of G i in a specific order, to yield a scalar expression. The expression for P becomes:       P  =    âˆ‘   i  =   (  0  ,  1  ,  2  ,  4  ,  8  )      ð…  i        P    subscript     i   0  1  2  4  8      subscript  ð…  i      P=\sum_{i=(0,1,2,4,8)}\mathbf{F}_{i}     where the index values accomplish projection and summation is array contraction. This idea generalizes to n-dimensional arrays that model multi-dimensional product lines.  Multi-Dimensional Product Lines  (Figure)  A 2-D Product Line (or Kube)   A multi-dimensional product line is described by multiple interacting sets of features. 1  2  3  4 As an elementary 2D example, it is easy to create a product line of calculators, where variants offer different sets of operations. Another variation might offer different presentation front ends to calculators, one with no GUI, another with a Java GUI, a third with a web GUI. These variations interact: each GUI representation references a specific calculator operation, so each GUI feature cannot be designed independently of its calculator feature. Such a design leads to a matrix: columns represent increments in calculator functionality, and rows represent different presentation front-ends. Such a matrix M is shown to the right: columns allow one to pair basic calculator functionality (base) with optional logarithmic/exponentiation (lx) and trigonometric (tg) features. Rows allow one to pair core functionality with no front-end (core), with optional GUI (gui) and web-based (web) front-ends.  An element M ij implements the interaction of column feature i and row feature j. For example, the element labeled cb is a base program that implements the core functionality of a calculator. Element gb adds code that displays the core functionality as a GUI; element wb adds code that displays the core functionality via the web. Similarly, element ct adds trigonometric code to the core calculator functionality; elements gt and wt add code to display the trigonometric functionality as a GUI and web front-ends.  A calculator is uniquely specified by two sequences of features: one sequence defining the calculator functionality, the other the front-end. For example, calculator C that offers both base and trig functionality in a web format is defined by the expression:       C  =    M   c  b    +   M   c  t    +   M   w  b    +   M   w  t         C     subscript  M    c  b     subscript  M    c  t     subscript  M    w  b     subscript  M    w  t       C=M_{cb}+M_{ct}+M_{wb}+M_{wt}      Note: Each dimension is a collection of base programs and features. Not all of their compositions are meaningful. A feature model defines the legal combinations of features. Thus, each dimension would have its own feature model . It is possible that selected features along one dimension may preclude or require features along other dimensions. In any case, these feature models define the legal combinations of features in a multi-dimensional product line.   Kubes  In general, a kube is an n-dimensional array. The rank of a kube is its dimensionality. A scalar is a kube of rank 0, a vector is a kube of rank 1, and a matrix is rank 2. Following tensor notation: the number of indices a kube has designates its rank. A scalar S is rank 0 (it has no indices), V k is a vector (rank 1), M ij is a matrix (rank 2), C ijk is a cube (rank 3).  Program Cubes or program kubes are n-dimensional arrays of functions (program transformations) that represent n-dimensional product lines. The values along each axis of a kube denote either a base program or a feature that could elaborate a base program. The rank of a product line is the rank of its kube.   Note: program kubes are inspired by tensors and data cubes in databases. The primary difference is that data cube elements are numerical values that are added during kube contraction; program kube elements are transformations that are composed. Both use tensor notations and terminology, although kubes satisfy few algebraic properties of tensors.   A program in an n-dimensional SPL is uniquely specified by n sequences of features S 1 ..S n , one per dimension. The design of a program is a scalar (expression) that is formed by (1) projecting the kube of its unneeded elements, and (2) contracting the resultant kube to a scalar:       P  =    âˆ‘    i  1   =   S  1   ,   i  2   =   S  2   ,  .  .   i  n   =   S  n      K    i  1    i  2   .  .   i  n          P    subscript    fragments   subscript  i  1     subscript  S  1   normal-,   subscript  i  2     subscript  S  2   normal-,  normal-.  normal-.   subscript  i  n     subscript  S  n      subscript  K   fragments   subscript  i  1    subscript  i  2   normal-.  normal-.   subscript  i  n        P=\sum_{i_{1}=S_{1},i_{2}=S_{2},..i_{n}=S_{n}}K_{i_{1}i_{2}..i_{n}}     Program synthesis is evaluating the scalar expression to produce program P.  An interesting property of kube design is that the order in which dimensions are contracted does not matterâ€”any permutation of dimensions during contraction will result in a different scalar expression (i.e. a different program design), but all expressions produce the same value (program). For example, another expression (design) to produce calculator C contracts dimensions in the opposite order from its original specification:      C  =    M   c  b    +   M   w  b    +   M   c  t    +   M   w  t         C     subscript  M    c  b     subscript  M    w  b     subscript  M    c  t     subscript  M    w  t       C=M_{cb}+M_{wb}+M_{ct}+M_{wt}     Or more generally:       P  =    âˆ‘    i  n   =   S  n   ,  .  .   i  2   =   S  2   ,   i  1   =   S  1      K    i  1    i  2   .  .   i  n          P    subscript    fragments   subscript  i  n     subscript  S  n   normal-,  normal-.  normal-.   subscript  i  2     subscript  S  2   normal-,   subscript  i  1     subscript  S  1      subscript  K   fragments   subscript  i  1    subscript  i  2   normal-.  normal-.   subscript  i  n        P=\sum_{i_{n}=S_{n},..i_{2}=S_{2},i_{1}=S_{1}}K_{i_{1}i_{2}..i_{n}}      Note: Underlying kube designs is a commuting diagram , such that there are an exponential number of paths from the empty program 0 to program P. Each path denotes a particular contraction of a kube, and corresponds to a unique incremental design of P. Included among these paths are kube aggregations that contract kubes using different dimensional orders.   The significance of program kubes is that it provides a structured way in which to express and build multi-dimensional models of SPLs. Further, it provides scalable specifications. If each dimension has k values, an n-kube specification of a program requires O(kn) terms, as opposed to O(k n ) kube elements that would otherwise have to be identified and then composed. In general, kubes provide a compact way to specify complex programs.  Applications  The expression problem '' ( EP ''; a.k.a. the extensibility problem ) is a fundamental problem in programming languages aimed at type systems that can add new classes and methods to a program in a type-safe manner. 5 6 7 8 It is also a fundamental problem in multi-dimensional SPL design. The expression problem is an example of an SPL of rank 2. The following applications either explain/illustrate the expression problem or show how it scales to product lines of large programs. EP is really a SPL of ~30 line programs; the applications below show how these ideas scale to programs of >30K lines (a 10 3 increase in size).   Expression Problem  Illustration of Small Expression Problem  Extensible IDEs  Multi-Dimensional Separation of Concerns  Calculator Product Line   Also, FOSD metamodels can be viewed as special cases of program kubes.  See also   Feature Oriented Programming â€”basic overview  FOSD Metamodels â€”product lines of product lines  FOSD Feature Algebras â€”operations from which FOSD features (0-ary and 1-ary) functions are defined  FOSD Feature Interactions â€”general concepts for feature interactions   References    "  Category:Feature-oriented programming     â†©  â†©  â†©  â†©  â†©  â†©  â†©  â†©     