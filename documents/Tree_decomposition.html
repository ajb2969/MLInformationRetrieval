<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="503">Tree decomposition</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Tree decomposition</h1>
<hr/>

<p> In <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>tree decomposition</strong> is a mapping of a <a href="graph_(mathematics)" title="wikilink">graph</a> into a <a href="tree_(graph_theory)" title="wikilink">tree</a> that can be used to define the <a class="uri" href="treewidth" title="wikilink">treewidth</a> of the graph and speed up solving certain computational problems on the graph.</p>

<p>In <a href="machine_learning" title="wikilink">machine learning</a>, tree decompositions are also called <strong>junction trees</strong>, <strong>clique trees</strong>, or <strong>join trees</strong>; they play an important role in problems like <a href="belief_propagation" title="wikilink">probabilistic inference</a>, <a href="constraint_satisfaction" title="wikilink">constraint satisfaction</a>, <a href="query_optimization" title="wikilink">query optimization</a>, and <a href="matrix_decomposition" title="wikilink">matrix decomposition</a>.</p>

<p>The concept of tree decompositions was originally introduced by . Later it was rediscovered by  and has since been studied by many other authors.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="definition">Definition</h2>

<p>Intuitively, a tree decomposition represents the vertices of a given graph <em>G</em> as subtrees of a tree, in such a way that vertices in the given graph are adjacent only when the corresponding subtrees intersect. Thus, <em>G</em> forms a <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">subgraph</a> of the <a href="intersection_graph" title="wikilink">intersection graph</a> of the subtrees. The full intersection graph is a <a href="chordal_graph" title="wikilink">chordal graph</a>.</p>

<p>Each subtree associates a graph vertex with a set of tree nodes. To define this formally, we represent each tree node as the set of vertices associated with it. Thus, given a graph <em>G</em> = (<em>V</em>, <em>E</em>), a tree decomposition is a pair (<em>X</em>, <em>T</em>), where <em>X</em> = {<em>X</em><sub>1</sub>, ..., <em>X</em><sub><em>n</em></sub>} is a family of subsets of <em>V</em>, and <em>T</em> is a tree whose nodes are the subsets <em>X</em><sub><em>i</em></sub>, satisfying the following properties:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<ol>
<li>The union of all sets <em>X</em><sub><em>i</em></sub> equals <em>V</em>. That is, each graph vertex is associated with at least one tree node.</li>
<li>For every edge (<em>v</em>, <em>w</em>) in the graph, there is a subset <em>X</em><sub><em>i</em></sub> that contains both <em>v</em> and <em>w</em>. That is, vertices are adjacent in the graph only when the corresponding subtrees have a node in common.</li>
<li>If <em>X</em><sub><em>i</em></sub> and <em>X</em><sub><em>j</em></sub> both contain a vertex <em>v</em>, then all nodes <em>X</em><sub><em>k</em></sub> of the tree in the (unique) path between <em>X</em><sub><em>i</em></sub> and <em>X</em><sub><em>j</em></sub> contain <em>v</em> as well. That is, the nodes associated with vertex <em>v</em> form a connected subset of <em>T</em>. This is also known as coherence, or the <em>running intersection property</em>. It can be stated equivalently that if 

<math display="inline" id="Tree_decomposition:0">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Tree_decomposition:1">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{j}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tree_decomposition:2">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k}
  </annotation>
 </semantics>
</math>

 are nodes, and 

<math display="inline" id="Tree_decomposition:3">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k}
  </annotation>
 </semantics>
</math>

 is on the path from 

<math display="inline" id="Tree_decomposition:4">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>


 to 

<math display="inline" id="Tree_decomposition:5">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{j}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Tree_decomposition:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo>∩</mo>
    <msub>
     <mi>X</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>⊆</mo>
   <msub>
    <mi>X</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}\cap X_{j}\subseteq X_{k}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>The tree decomposition of a graph is far from unique; for example, a trivial tree decomposition contains all vertices of the graph in its single root node.</p>

<p>A tree decomposition in which the underlying tree is a <a href="path_graph" title="wikilink">path graph</a> is called a path decomposition, and the width parameter derived from these special types of tree decompositions is known as <a class="uri" href="pathwidth" title="wikilink">pathwidth</a>.</p>

<p>A tree decomposition (<em>X</em>, <em>T</em> = (<em>I</em>, <em>F</em>)) of treewidth <em>k</em> is <em>smooth</em>, if for all 

<math display="inline" id="Tree_decomposition:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <mi>I</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <ci>i</ci>
     <ci>I</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in I:|X_{i}|=k+1
  </annotation>
 </semantics>
</math>

, and for all 

<math display="inline" id="Tree_decomposition:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>F</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <msub>
       <mi>X</mi>
       <mi>i</mi>
      </msub>
      <mo>∩</mo>
      <msub>
       <mi>X</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
     <ci>F</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <abs></abs>
      <apply>
       <intersect></intersect>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,j)\in F:|X_{i}\cap X_{j}|=k
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="treewidth">Treewidth</h2>

<p>The <em>width</em> of a tree decomposition is the size of its largest set <em>X</em><sub><em>i</em></sub> minus one. The <a class="uri" href="treewidth" title="wikilink">treewidth</a> tw(<em>G</em>) of a graph <em>G</em> is the minimum width among all possible tree decompositions of <em>G</em>. In this definition, the size of the largest set is diminished by one in order to make the treewidth of a tree equal to one. Treewidth may also be defined from other structures than tree decompositions, including <a href="chordal_graph" title="wikilink">chordal graphs</a>, <a href="bramble_(graph_theory)" title="wikilink">brambles</a>, and <a href="haven_(graph_theory)" title="wikilink">havens</a>.</p>

<p>It is NP-complete to determine whether a given graph <em>G</em> has treewidth at most a given variable <em>k</em>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> However, when <em>k</em> is any fixed constant, the graphs with treewidth <em>k</em> can be recognized, and a width <em>k</em> tree decomposition constructed for them, in linear time.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The time dependence of this algorithm on <em>k</em> is exponential.</p>
<h2 id="dynamic-programming">Dynamic programming</h2>

<p>At the beginning of the 1970s, it was observed that a large class of combinatorial optimization problems defined on graphs could be efficiently solved by non serial <a href="dynamic_programming" title="wikilink">dynamic programming</a> as long as the graph had a bounded <em>dimension</em>, a parameter related to treewidth. Later, several authors independently observed at the end of the 1980s<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> that many algorithmic problems that are <a href="NP-completeness" title="wikilink">NP-complete</a> for arbitrary graphs may be solved efficiently by <a href="dynamic_programming" title="wikilink">dynamic programming</a> for graphs of bounded treewidth, using the tree-decompositions of these graphs.</p>

<p>As an example, consider the problem of finding the <a href="maximum_independent_set" title="wikilink">maximum independent set</a> in a graph of treewidth <em>k</em>. To solve this problem, first choose one of the nodes of the tree decomposition to be the root, arbitrarily. For a node <em>X<sub>i</sub></em> of the tree decomposition, let <em>D<sub>i</sub></em> be the union of the sets <em>X<sub>j</sub></em> descending from <em>X<sub>i</sub></em>. For an independent set <em>S</em> ⊂ <em>X<sub>i</sub></em>, let <em>A</em>(<em>S</em>,<em>i</em>) denote the size of the largest independent subset <em>I</em> of <em>D<sub>i</sub></em> such that <em>I</em> ∩ <em>X<sub>i</sub></em> = <em>S</em>. Similarly, for an adjacent pair of nodes <em>X<sub>i</sub></em> and <em>X<sub>j</sub></em>, with <em>X<sub>i</sub></em> farther from the root of the tree than <em>X<sub>j</sub></em>, and an independent set <em>S</em> ⊂ <em>X<sub>i</sub></em> ∩ <em>X<sub>j</sub></em>, let <em>B</em>(<em>S</em>,<em>i</em>,<em>j</em>) denote the size of the largest independent subset <em>I</em> of <em>D<sub>i</sub></em> such that <em>I</em> ∩ <em>X<sub>i</sub></em> ∩ <em>X<sub>j</sub></em> = <em>S</em>. We may calculate these <em>A</em> and <em>B</em> values by a bottom-up traversal of the tree:</p>

<p>

<math display="block" id="Tree_decomposition:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>S</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mi>B</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>S</mi>
          <mo>∩</mo>
          <msub>
           <mi>X</mi>
           <mi>j</mi>
          </msub>
         </mrow>
         <mo>,</mo>
         <mi>j</mi>
         <mo>,</mo>
         <mi>i</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mi>S</mi>
         <mo>∩</mo>
         <msub>
          <mi>X</mi>
          <mi>j</mi>
         </msub>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <interval closure="open">
      <ci>S</ci>
      <ci>i</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <abs></abs>
      <ci>S</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>B</ci>
        <vector>
         <apply>
          <intersect></intersect>
          <ci>S</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <ci>j</ci>
         <ci>i</ci>
        </vector>
       </apply>
       <apply>
        <abs></abs>
        <apply>
         <intersect></intersect>
         <ci>S</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(S,i)=|S|+\sum_{j}\left(B(S\cap X_{j},j,i)-|S\cap X_{j}|\right)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Tree_decomposition:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mi>max</mi>
      <mstyle scriptlevel="+1">
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mrow>
           <msup>
            <mi>S</mi>
            <mo>′</mo>
           </msup>
           <mo>⊂</mo>
           <msub>
            <mi>X</mi>
            <mi>i</mi>
           </msub>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mrow>
           <mi>S</mi>
           <mo>=</mo>
           <mrow>
            <msup>
             <mi>S</mi>
             <mo>′</mo>
            </msup>
            <mo>∩</mo>
            <msub>
             <mi>X</mi>
             <mi>j</mi>
            </msub>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
      </mstyle>
     </munder>
     <mi>A</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>B</ci>
     <vector>
      <ci>S</ci>
      <ci>i</ci>
      <ci>j</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <ci>STACKED</ci>
        <apply>
         <subset></subset>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>S</ci>
          <ci>normal-′</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <eq></eq>
         <ci>S</ci>
         <apply>
          <intersect></intersect>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>S</ci>
           <ci>normal-′</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>A</ci>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>i</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(S,i,j)=\max_{S^{\prime}\subset X_{i}\atop S=S^{\prime}\cap X_{j}}A(S^{\prime%
},i)
  </annotation>
 </semantics>
</math>

 where the sum in the calculation of 

<math display="inline" id="Tree_decomposition:11">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>i</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(S,i)
  </annotation>
 </semantics>
</math>

 is over the children of node 

<math display="inline" id="Tree_decomposition:12">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>At each node or edge, there are at most 2<sup><em>k</em></sup> sets <em>S</em> for which we need to calculate these values, so if <em>k</em> is a constant then the whole calculation takes constant time per edge or node. The size of the maximum independent set is the largest value stored at the root node, and the maximum independent set itself can be found (as is standard in dynamic programming algorithms) by backtracking through these stored values starting from this largest value. Thus, in graphs of bounded treewidth, the maximum independent set problem may be solved in linear time. Similar algorithms apply to many other graph problems.</p>

<p>This dynamic programming approach is used in <a href="machine_learning" title="wikilink">machine learning</a> via the <a href="junction_tree_algorithm" title="wikilink">junction tree algorithm</a> for <a href="belief_propagation" title="wikilink">belief propagation</a> in graphs of bounded treewidth. It also plays a key role in algorithms for computing the treewidth and constructing tree decompositions: typically, such algorithms have a first step that <a href="approximation_algorithm" title="wikilink">approximates</a> the treewidth, constructing a tree decomposition with this approximate width, and then a second step that performs dynamic programming in the approximate tree decomposition to compute the exact value of the treewidth.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bramble_(graph_theory)" title="wikilink">Brambles</a> and <a href="Haven_(graph_theory)" title="wikilink">havens</a>, two kinds of structures that can be used as an alternative to tree decomposition in defining the treewidth of a graph</li>
<li><a class="uri" href="Branch-decomposition" title="wikilink">Branch-decomposition</a>, a closely related structure whose width is within a constant factor of treewidth</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Trees_(graph_theory)" title="wikilink">Category:Trees (graph theory)</a> <a href="Category:Graph_minor_theory" title="wikilink">Category:Graph minor theory</a> <a href="Category:Graph_theory_objects" title="wikilink">Category:Graph theory objects</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"> pp.354–355<a href="#fnref1">↩</a></li>
<li id="fn2"> section 12.3<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">; ; .<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
</ol>
</section>
</body>
</html>
