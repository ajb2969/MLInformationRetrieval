<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1881">Contextual image classification</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Contextual image classification</h1>
<hr/>

<p><strong>Contextual image classification</strong>, a topic of <a href="pattern_recognition" title="wikilink">pattern recognition</a> in <a href="computer_vision" title="wikilink">computer vision</a>, is an approach of <a href="Classification_in_machine_learning" title="wikilink">classification</a> based on contextual information in images. "Contextual" means this approach is focusing on the relationship of the nearby pixels, which is also called neighbourhood. The goal of this approach is to classify the images by using the contextual information.</p>
<h2 id="introduction">Introduction</h2>

<p>Similar as <a href="Natural_language_processing" title="wikilink">processing language</a>, a single word may have multiple meanings unless the context is provided, and the patterns within the sentences are the only informative segments we care about. For images, the principle is same. Find out the patterns and associate proper meanings to them.</p>

<p>As the image illustrated below, if only a small portion of the image is shown, it is very difficult to tell what the image is about. </p>

<p>Even try another portion of the image, it is still difficult to classify the image. </p>

<p>However, if we increase the contextual of the image, then it makes more sense to recognize. </p>

<p>As the full images shows below, almost everyone can classify it easily. </p>

<p>During the procedure of <a href="Segmentation_(image_processing)" title="wikilink">segmentation</a>, the methods which do not use the contextual information are sensitive to noise and variations, thus the result of segmentation will contain a great deal of misclassified regions, and often these regions are small (e.g., one pixel).</p>

<p>Compared to other techniques, this approach is robust to noise and substantial variations for it takes the continuity of the segments into account.</p>

<p>Several methods of this approach will be described below.</p>
<h2 id="applications">Applications</h2>
<h3 id="functioning-as-a-post-processing-filter-to-a-labelled-image">Functioning as a post-processing filter to a labelled image</h3>

<p>This approach is very effective against small regions caused by noise. And these small regions are usually formed by few pixels or one pixel. The most probable label is assigned to these regions. However, there is a drawback of this method. The small regions also can be formed by correct regions rather than noise, and in this case the method is actually making the classification worse. This approach is widely used in <a href="remote_sensing" title="wikilink">remote sensing</a> applications.</p>
<h3 id="improving-the-post-processing-classification">Improving the post-processing classification</h3>

<p>This is a two-stage classification process:</p>
<ol>
<li>For each pixel, label the pixel and form a new feature vector for it.</li>
<li>Use the new feature vector and combine the contextual information to assign the final label to the</li>
</ol>
<h3 id="merging-the-pixels-in-earlier-stages">Merging the pixels in earlier stages</h3>

<p>Instead of using single pixels, the neighbour pixels can be merged into homogeneous regions benefiting from contextual information. And provide these regions to classifier.</p>
<h3 id="acquiring-pixel-feature-from-neighbourhood">Acquiring pixel feature from neighbourhood</h3>

<p>The original spectral data can be enriched by adding the contextual information carried by the neighbour pixels, or even replaced in some occasions. This kind of pre-processing methods are widely used in textured image recognition. The typical approaches include mean values, variances, texture description, etc.</p>
<h3 id="combining-spectral-and-spatial-information">Combining spectral and spatial information</h3>

<p>The classifier uses the grey level and pixel neighbourhood (contextual information) to assign labels to pixels. In such case the information is a combination of spectral and spatial information.</p>
<h3 id="powered-by-the-bayes-minimum-error-classifier">Powered by the Bayes minimum error classifier</h3>

<p>Contextual classification of image data is based on the Bayes minimum error classifier (also known as a <a href="naive_Bayes_classifier" title="wikilink">naive Bayes classifier</a>).</p>

<p><strong>Present the pixel</strong>:</p>
<ul>
<li>A pixel is denoted as 

<math display="inline" id="Contextual_image_classification:0">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

.</li>
<li>The neighbourhood of each pixel 

<math display="inline" id="Contextual_image_classification:1">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 is a vector and denoted as 

<math display="inline" id="Contextual_image_classification:2">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(x_{0})
  </annotation>
 </semantics>
</math>

.
<ul>
<li>The values in the neighbourhood vector is denoted as 

<math display="inline" id="Contextual_image_classification:3">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i})
  </annotation>
 </semantics>
</math>


.</li>
<li>Each pixel is presented by the vector</li>
</ul></li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Contextual_image_classification:4">
 <semantics>
  <mrow>
   <mi>ξ</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ξ</ci>
    <vector>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi=\left(f(x_{0}),f(x_{1}),\ldots,f(x_{k})\right)
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Contextual_image_classification:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>∈</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">;</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>k</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\in N(x_{0});\quad i=1,\ldots,k
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>The labels (classification) of pixels in the neighbourhood 

<math display="inline" id="Contextual_image_classification:6">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(x_{0})
  </annotation>
 </semantics>
</math>

 are presented as a vector</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Contextual_image_classification:7">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>θ</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>θ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>θ</mi>
     <mi>k</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>η</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta=\left(\theta_{0},\theta_{1},\ldots,\theta_{k}\right)
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Contextual_image_classification:8">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo>{</mo>
    <msub>
     <mi>ω</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>ω</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>ω</mi>
     <mi>k</mi>
    </msub>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}\in\left\{\omega_{0},\omega_{1},\ldots,\omega_{k}\right\}
  </annotation>
 </semantics>
</math>



</dd>
<dd>

<math display="inline" id="Contextual_image_classification:9">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{s}
  </annotation>
 </semantics>
</math>

 here denotes the assigned class.
</dd>
</dl>
</dd>
</dl>
<ul>
<li>A vector presents the labels in the neighbourhood 

<math display="inline" id="Contextual_image_classification:10">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(x_{0})
  </annotation>
 </semantics>
</math>

 without the pixel 

<math display="inline" id="Contextual_image_classification:11">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Contextual_image_classification:12">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>η</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>θ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>θ</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>θ</mi>
     <mi>k</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>η</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\eta}=\left(\theta_{1},\theta_{2},\ldots,\theta_{k}\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p><strong>The neighbourhood</strong>: Size of the neighbourhood. There is no limitation of the size, but it is considered to be relatively small for each pixel 

<math display="inline" id="Contextual_image_classification:13">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>


. A reasonable size of neighbourhood would be 

<math display="inline" id="Contextual_image_classification:14">
 <semantics>
  <mrow>
   <mn>3</mn>
   <mo>×</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">3</cn>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3\times 3
  </annotation>
 </semantics>
</math>

 of 4-<a href="Connectedness" title="wikilink">connectivity</a> or 8-connectivity (

<math display="inline" id="Contextual_image_classification:15">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 is marked as red and placed in the centre).</p>

<p>Image:Square_4_connectivity.svg|<a href="4-connected_graph" title="wikilink">4-connectivity</a> neighbourhood,  Image:Square_8_connectivity.svg|<a class="uri" href="8-connectivity" title="wikilink">8-connectivity</a> neighbourhood</p>

<p><strong>The calculation</strong>:</p>

<p>Apply the minimum error classification on a pixel 

<math display="inline" id="Contextual_image_classification:16">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

, if the probability of a class 

<math display="inline" id="Contextual_image_classification:17">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{r}
  </annotation>
 </semantics>
</math>

 being presenting the pixel 

<math display="inline" id="Contextual_image_classification:18">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>


 is the highest among all, then assign 

<math display="inline" id="Contextual_image_classification:19">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{r}
  </annotation>
 </semantics>
</math>

 as its class.</p>

<p>

<math display="block" id="Contextual_image_classification:20">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>ω</mi>
    <mi>r</mi>
   </msub>
   <mtext>if</mtext>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>r</mi>
    </msub>
    <mo>∣</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mi>max</mi>
    <mrow>
     <mi>s</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mn>2</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>R</mi>
     </mrow>
    </mrow>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>s</mi>
    </msub>
    <mo>∣</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">0</cn>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>r</ci>
    </apply>
    <ci></ci>
    <mtext>if</mtext>
    <ci></ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>r</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <apply>
      <eq></eq>
      <ci>s</ci>
      <list>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
       <ci>normal-…</ci>
       <ci>R</ci>
      </list>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}=\omega_{r}\quad\text{ if }\quad P(\omega_{r}\mid f(x_{0}))=\max_{s=%
1,2,\ldots,R}P(\omega_{s}\mid f(x_{0}))
  </annotation>
 </semantics>
</math>

</p>

<p>The contextual classification rule is described as below, it uses the feature vector 

<math display="inline" id="Contextual_image_classification:21">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 rather than 

<math display="inline" id="Contextual_image_classification:22">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Contextual_image_classification:23">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>ω</mi>
    <mi>r</mi>
   </msub>
   <mtext>if</mtext>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>r</mi>
    </msub>
    <mo>∣</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mi>max</mi>
    <mrow>
     <mi>s</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mn>2</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>R</mi>
     </mrow>
    </mrow>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>s</mi>
    </msub>
    <mo>∣</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">0</cn>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>r</ci>
    </apply>
    <ci></ci>
    <mtext>if</mtext>
    <ci></ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>r</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">ξ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <apply>
      <eq></eq>
      <ci>s</ci>
      <list>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
       <ci>normal-…</ci>
       <ci>R</ci>
      </list>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">ξ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}=\omega_{r}\quad\text{ if }\quad P(\omega_{r}\mid\xi)=\max_{s=1,2,%
\ldots,R}P(\omega_{s}\mid\xi)
  </annotation>
 </semantics>
</math>

</p>

<p>Use the Bayes formula to calculate the posteriori probability 

<math display="inline" id="Contextual_image_classification:24">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>s</mi>
    </msub>
    <mo>∣</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">ξ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\omega_{s}\mid\xi)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Contextual_image_classification:25">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>s</mi>
    </msub>
    <mo>∣</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ξ</mi>
      <mo>∣</mo>
      <msub>
       <mi>ω</mi>
       <mi>s</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ω</mi>
       <mi>s</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo>(</mo>
      <mi>ξ</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">ξ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">ξ</csymbol>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>s</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>s</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>ξ</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\omega_{s}\mid\xi)=\frac{p(\xi\mid\omega_{s})P(\omega_{s})}{p\left(\xi\right)}
  </annotation>
 </semantics>
</math>

</p>

<p>The amount of vectors is the same as the number of pixels in the image. For the classifier uses a vector corresponding to each pixel 

<math display="inline" id="Contextual_image_classification:26">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

, and the vector is generated from the pixel's neighbourhood.</p>

<p><strong>The basic steps of contextual image classification</strong>:</p>
<ol>
<li>Calculate the feature vector 

<math display="inline" id="Contextual_image_classification:27">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 for each pixel.</li>
<li>Calculate the parameters of probability distribution 

<math display="inline" id="Contextual_image_classification:28">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ξ</mi>
    <mo>∣</mo>
    <msub>
     <mi>ω</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ξ</csymbol>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\xi\mid\omega_{s})
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Contextual_image_classification:29">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\omega_{s})
  </annotation>
 </semantics>
</math>

</li>
<li>Calculate the posterior probabilities 

<math display="inline" id="Contextual_image_classification:30">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>r</mi>
    </msub>
    <mo>∣</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>r</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">ξ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\omega_{r}\mid\xi)
  </annotation>
 </semantics>
</math>

 and all labels 

<math display="inline" id="Contextual_image_classification:31">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}
  </annotation>
 </semantics>
</math>

. Get the image classification result.</li>
</ol>
<h2 id="algorithms">Algorithms</h2>
<h3 id="template-matching">Template matching</h3>

<p>The <a href="template_matching" title="wikilink">template matching</a> is a "brute force" implementation of this approach.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The concept is first create a set of templates, and then look for small parts in the image match with a template.</p>

<p>This method is computationally high and inefficient. It keeps an entire templates list during the whole process and the number of combinations is extremely high. For a 

<math display="inline" id="Contextual_image_classification:32">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times n
  </annotation>
 </semantics>
</math>

 pixel image, there could be a maximum of 

<math display="inline" id="Contextual_image_classification:33">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>m</mi>
    <mo>×</mo>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m\times n}
  </annotation>
 </semantics>
</math>


 combinations, which leads to high computation. This method is a top down method and often called <a href="Lookup_table" title="wikilink">table look-up</a> or <a href="Data_dictionary" title="wikilink">dictionary look-up</a>.</p>
<h3 id="lower-order-markov-chain">Lower-order Markov chain</h3>

<p>The <a href="Markov_chain" title="wikilink">Markov chain</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> also can be applied in pattern recognition. The pixels in an image can be recognised as a set of random variables, then use the lower order Markov chain to find the relationship among the pixels. The image is treated as a virtual line, and the method uses conditional probability.</p>
<h3 id="hilbert-space-filling-curves">Hilbert space-filling curves</h3>

<p>The <a href="Hilbert_curve" title="wikilink">Hilbert curve</a> runs in a unique pattern through the whole image, it traverses every pixel without visits any of them twice and keeps a continuous curve. It is fast and efficient.</p>
<h3 id="markov-meshes">Markov meshes</h3>

<p>The lower-order Markov chain and Hilbert space-filling curves mentioned above are treating the image as a line structure. The Markov meshes however will take the two dimensional information into account.</p>
<h3 id="dependency-tree">Dependency tree</h3>

<p>The <a href="Chow–Liu_tree" title="wikilink">dependency tree</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> is a method using tree dependency to approximate probability distributions.</p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.inf.ed.ac.uk/teaching/courses/av/index.html">Advanced Vision homepage</a></li>
<li><a href="http://www.bic.mni.mcgill.ca/~mallar/CS-644B/Intro.html">The Use of Context in Pattern Recognition</a></li>
<li><a href="http://css.engineering.uiowa.edu/~dip/LECTURE/Understanding4.html">Image Analysis and Understanding: contextual image classification</a></li>
</ul>

<p>"</p>

<p><a href="Category:Computer_vision" title="wikilink">Category:Computer vision</a> <a href="Category:Applications_of_computer_vision" title="wikilink">Category:Applications of computer vision</a> <a href="Category:Image_processing" title="wikilink">Category:Image processing</a> <a href="Category:Artificial_intelligence" title="wikilink">Category:Artificial intelligence</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">G.T. Toussaint, "The Use of Context in Pattern Recognition," Pattern Recognition, vol. 10, 1977, pp. 189–204.<a href="#fnref1">↩</a></li>
<li id="fn2">K. Abend, T.J. Harley, and L.N. Kanal, "Classification of Binary Random Patterns," IEEE Transactions on Information Theory, vol. 11, no. 4, October 1965, pp. 538–544.<a href="#fnref2">↩</a></li>
<li id="fn3">C.K. Chow and C.N. Liu, "Approximating Discrete Probability Distributions with Dependence Trees," IEEE Transaction on Information Theory, vol.14, no. 3, May 1965, pp. 462–467.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
