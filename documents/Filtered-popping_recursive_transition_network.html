<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1053">Filtered-popping recursive transition network</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Filtered-popping recursive transition network</h1>
<hr>A '''filtered-popping recursive transition network''' ('''FPRTN'''),<ref name="sastre09jb">Javier M. Sastre, [http://dx.doi.org/10.1007/978-3-642-02979-0_28 "Efficient parsing using filtered-popping recursive transition networks"], ''Lecture Notes in Artificial Intelligence'', '''5642''':241-244, 2009</ref> or simply '''filtered-popping network''' ('''FPN'''), is a [[recursive transition network]] ([[Recursive transition network|RTN]]
<p>)<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> extended with a map of states to keys where returning from a <a class="uri" href="subroutine" title="wikilink">subroutine</a> jump requires the acceptor and return states to be mapped to the same key. <a href="Recursive_transition_network" title="wikilink">RTNs</a> are <a href="finite-state_machines" title="wikilink">finite-state machines</a> that can be seen as <a href="finite-state_automata" title="wikilink">finite-state automata</a> extended with a <a href="stack_(data_structure)" title="wikilink">stack</a> of return states; as well as consuming transitions and 

<math display="inline" id="Filtered-popping_recursive_transition_network:0">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

-transitions, <a href="Recursive_transition_network" title="wikilink">RTNs</a> may define call transitions. These transitions perform a <a class="uri" href="subroutine" title="wikilink">subroutine</a> jump by pushing the transition's target state onto the stack and bringing the machine to the called state. Each time an acceptor state is reached, the return state at the top of the stack is popped out, provided that the stack is not empty, and the machine is brought to this state.</p>

<p>Throughout this article we refer to filtered-popping recursive transition networks as <em>FPNs</em>, though this acronym is ambiguous (e.g.: <a href="fuzzy_Petri_nets" title="wikilink">fuzzy Petri nets</a>). <em>Filtered-popping networks</em> and <em>FPRTNs</em> are unambiguous alternatives.</p>
<h2 id="formal-definition">Formal Definition</h2>

<p>A FPN is a structure 

<math display="inline" id="Filtered-popping_recursive_transition_network:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>Q</mi>
   <mo>,</mo>
   <mi>K</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo>,</mo>
   <mi>δ</mi>
   <mo>,</mo>
   <mi>κ</mi>
   <mo>,</mo>
   <msub>
    <mi>Q</mi>
    <mi>I</mi>
   </msub>
   <mo>,</mo>
   <mi>F</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>Q</ci>
    <ci>K</ci>
    <ci>normal-Σ</ci>
    <ci>δ</ci>
    <ci>κ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>I</ci>
    </apply>
    <ci>F</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q,K,\Sigma,\delta,\kappa,Q_{I},F)
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li>

<math display="inline" id="Filtered-popping_recursive_transition_network:2">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is a finite set of states,</li>
<li>

<math display="inline" id="Filtered-popping_recursive_transition_network:3">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>


 is a finite set of keys,</li>
<li>

<math display="inline" id="Filtered-popping_recursive_transition_network:4">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 is a finite input alphabet,</li>
<li>

<math display="inline" id="Filtered-popping_recursive_transition_network:5">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Σ</mi>
       <mo>∪</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mi>ε</mi>
        <mo stretchy="false">}</mo>
       </mrow>
       <mo>∪</mo>
       <mi>Q</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>δ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <union></union>
       <ci>normal-Σ</ci>
       <set>
        <ci>ε</ci>
       </set>
       <ci>Q</ci>
      </apply>
     </apply>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta:Q\times(\Sigma\cup\{\varepsilon\}\cup Q)\to Q
  </annotation>
 </semantics>
</math>

 is a partial transition function, 

<math display="inline" id="Filtered-popping_recursive_transition_network:6">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

 being the empty symbol,</li>
<li>

<math display="inline" id="Filtered-popping_recursive_transition_network:7">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mo>:</mo>
   <mrow>
    <mi>Q</mi>
    <mo>→</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>κ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>Q</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa:Q\to K
  </annotation>
 </semantics>
</math>

 is a map of states to keys,</li>
<li>

<math display="inline" id="Filtered-popping_recursive_transition_network:8">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>I</mi>
   </msub>
   <mo>⊆</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>I</ci>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{I}\subseteq Q
  </annotation>
 </semantics>
</math>


 is the set of initial states, and</li>
<li>

<math display="inline" id="Filtered-popping_recursive_transition_network:9">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>⊆</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>F</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\subseteq Q
  </annotation>
 </semantics>
</math>

 is the set of acceptance states.</li>
</ul>
<h2 id="transitions">Transitions</h2>

<p>Transitions represent the possibility of bringing the FPN from a source state 

<math display="inline" id="Filtered-popping_recursive_transition_network:10">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{s}
  </annotation>
 </semantics>
</math>

 to a target state 

<math display="inline" id="Filtered-popping_recursive_transition_network:11">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{t}
  </annotation>
 </semantics>
</math>

 by possibly performing an additional action. Depending on this action, we distinguish the following types of <em>explicitly</em>-defined transitions:</p>
<ul>
<li><strong>

<math display="inline" id="Filtered-popping_recursive_transition_network:12">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

-transitions</strong> are transitions of the form 

<math display="inline" id="Filtered-popping_recursive_transition_network:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>q</mi>
      <mi>s</mi>
     </msub>
     <mo>,</mo>
     <mi>ε</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <msub>
    <mi>q</mi>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>s</ci>
      </apply>
      <ci>ε</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(q_{s},\varepsilon)\to q_{t}
  </annotation>
 </semantics>
</math>


 and perform no additional action,</li>
<li><strong>consuming transitions</strong> are transitions of the form 

<math display="inline" id="Filtered-popping_recursive_transition_network:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>q</mi>
      <mi>s</mi>
     </msub>
     <mo>,</mo>
     <mi>σ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <msub>
    <mi>q</mi>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>s</ci>
      </apply>
      <ci>σ</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(q_{s},\sigma)\to q_{t}
  </annotation>
 </semantics>
</math>

 and consume an input symbol 

<math display="inline" id="Filtered-popping_recursive_transition_network:15">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, and</li>
<li><strong>call transitions</strong> are transitions of the form 

<math display="inline" id="Filtered-popping_recursive_transition_network:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>q</mi>
      <mi>s</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>q</mi>
      <mi>c</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <msub>
    <mi>q</mi>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>c</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(q_{s},q_{c})\to q_{t}
  </annotation>
 </semantics>
</math>

 and perform a <a class="uri" href="subroutine" title="wikilink">subroutine</a> jump to called state 

<math display="inline" id="Filtered-popping_recursive_transition_network:17">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{c}
  </annotation>
 </semantics>
</math>

 before reaching 

<math display="inline" id="Filtered-popping_recursive_transition_network:18">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{t}
  </annotation>
 </semantics>
</math>


.</li>
</ul>

<p>The behaviour of call transitions is governed by two kinds of <em>implicitly</em>-defined transitions:</p>
<ul>
<li>for each call transition 

<math display="inline" id="Filtered-popping_recursive_transition_network:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>q</mi>
      <mi>s</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>q</mi>
      <mi>c</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <msub>
    <mi>q</mi>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>c</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(q_{s},q_{c})\to q_{t}
  </annotation>
 </semantics>
</math>

 the FPN implicitly defines a <strong>push transition</strong> that brings the machine from 

<math display="inline" id="Filtered-popping_recursive_transition_network:20">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{s}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Filtered-popping_recursive_transition_network:21">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{c}
  </annotation>
 </semantics>
</math>

 by pushing 

<math display="inline" id="Filtered-popping_recursive_transition_network:22">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{t}
  </annotation>
 </semantics>
</math>

 onto the <a href="stack_(data_structure)" title="wikilink">stack</a>, and</li>
<li>for each pair of states 

<math display="inline" id="Filtered-popping_recursive_transition_network:23">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>q</mi>
     <mi>f</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>q</mi>
     <mi>r</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>F</mi>
    <mo>×</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <ci>r</ci>
     </apply>
    </interval>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q_{f},q_{r})\in F\times Q
  </annotation>
 </semantics>
</math>


 the FPN implicitly defines a <strong>pop transition</strong> that brings the machine from 

<math display="inline" id="Filtered-popping_recursive_transition_network:24">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{f}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Filtered-popping_recursive_transition_network:25">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{r}
  </annotation>
 </semantics>
</math>

 by popping 

<math display="inline" id="Filtered-popping_recursive_transition_network:26">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{r}
  </annotation>
 </semantics>
</math>

 from the stack <a class="uri" href="iff" title="wikilink">iff</a> 

<math display="inline" id="Filtered-popping_recursive_transition_network:27">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{r}
  </annotation>
 </semantics>
</math>

 is the state at the top of the stack and 

<math display="inline" id="Filtered-popping_recursive_transition_network:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>κ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>q</mi>
      <mi>f</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>κ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>q</mi>
      <mi>r</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>κ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>κ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa(q_{f})=\kappa(q_{r})
  </annotation>
 </semantics>
</math>


.</li>
</ul>

<p>Push transitions initialize <a class="uri" href="subroutine" title="wikilink">subroutine</a> jumps and pop transitions are equivalent to <a href="return_statements" title="wikilink">return statements</a>.</p>
<h2 id="purpose">Purpose</h2>

<p>A (<a href="natural_language" title="wikilink">natural language</a>) text can be enriched with meta-information by the application of a <a href="RTN_with_output" title="wikilink">RTN with output</a>; for instance, a RTN inserting <a class="uri" href="XML" title="wikilink">XML</a> tags can be used for transforming a <a href="plain_text" title="wikilink">plain text</a> into a structured XML document. A RTN with output representing a <a href="natural_language" title="wikilink">natural language</a> <a class="uri" href="grammar" title="wikilink">grammar</a> would delimit and add the syntactic structure of each text sentence (see <a class="uri" href="parsing" title="wikilink">parsing</a>). Other RTNs with output could simply mark text segments containing relevant information (see <a href="information_extraction" title="wikilink">information extraction</a>). The application of a RTN with output representing an <a href="ambiguous_grammar" title="wikilink">ambiguous grammar</a> results in a set of possible translations or interpretations of the input. Computing this set has an exponential <a href="worst-case_cost" title="wikilink">worst-case cost</a>, even for an <a href="Earley_parser" title="wikilink">Earley parser</a> for RTNs with output,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> due to cases in which the number of translations increases exponentially <a href="wikt:WRT" title="wikilink">w.r.t.</a> the input length; for instance, the number of interpretations of a <a href="natural_language" title="wikilink">natural language</a> sentence increases exponentially w.r.t. the number of unresolved <a href="prepositional_phrase" title="wikilink">prepositional phrase</a> attachments:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<ul>
<li>in sentence <em>the girl saw the monkey with the telescope</em>, it is unknown whether the girl used the telescope or the monkey was holding it (2<sup>1</sup> interpretations),</li>
<li>in sentence <em>the girl saw the monkey with the telescope in the garden</em>, it is also unknown whether the monkey was in the garden or the action took place in the garden (2<sup>2</sup> interpretations),</li>
<li>in sentence <em>the girl saw the monkey with the telescope in the garden under the tree</em>, it is unknown as well whether the monkey was under the tree or the action took place under the tree (2<sup>3</sup> interpretations),</li>
<li>etc.</li>
</ul>

<p>FPNs serve as a compact representation of this set of translations, allowing to compute it in cubic time by means of an Earley-like parser.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> FPN states correspond to execution states (see <a href="instruction_steps" title="wikilink">instruction steps</a>) of an Earley-parser for <a class="uri" href="RTNs" title="wikilink">RTNs</a> <em>without</em> output, and FPN transitions correspond to possible translations of input symbols. The 

<math display="inline" id="Filtered-popping_recursive_transition_network:29">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

 map of the resulting FPN gives the correspondence between the represented output segments and the recognized input segments: given a recognized input sequence 

<math display="inline" id="Filtered-popping_recursive_transition_network:30">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>σ</mi>
    <mi>l</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{1}\ldots\sigma_{l}
  </annotation>
 </semantics>
</math>

 and a FPN path 

<math display="inline" id="Filtered-popping_recursive_transition_network:31">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 starting at a state 

<math display="inline" id="Filtered-popping_recursive_transition_network:32">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 and ending at a state 

<math display="inline" id="Filtered-popping_recursive_transition_network:33">
 <semantics>
  <msup>
   <mi>q</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{\prime}
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Filtered-popping_recursive_transition_network:34">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 represents a possible translation of input segment 

<math display="inline" id="Filtered-popping_recursive_transition_network:35">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mrow>
     <mrow>
      <mi>κ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>q</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>σ</mi>
    <mrow>
     <mi>κ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>q</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>κ</ci>
       <ci>q</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <apply>
      <times></times>
      <ci>κ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{\kappa(q)+1}\ldots\sigma_{\kappa(q^{\prime})}
  </annotation>
 </semantics>
</math>

. The filtered-popping feature is required in order to avoid FPN paths to represent translations of <em>disconnected</em> or <em>overlapping</em> input segments: a FPN call may contain several translation paths from the called state to an acceptor state, where the input segments they correspond to share the same start point but do not necessarily have the same length. Only return states corresponding to the same input point than the acceptor state finishing the call are <em>valid</em> return states.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Natural_language_processing" title="wikilink">Category:Natural language processing</a> <a href="Category:Computational_linguistics" title="wikilink">Category:Computational linguistics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">William A. Woods, <a href="http://doi.acm.org/10.1145/355598.362773">"Transition network grammars for natural language analysis"</a>, <em>Communications of the ACM</em>, <em>ACM Press</em>, <strong>13</strong>:10:591-606, 1970<a href="#fnref1">↩</a></li>
<li id="fn2">Javier M. Sastre &amp; Mikel L. Forcada, <a href="http://dx.doi.org/10.1007/978-3-642-04235-5_17">"Efficient parsing using recursive transition networks with output"</a>, <em>Lecture Notes in Computer Science</em>, <strong>5603</strong>:192-204, 2009<a href="#fnref2">↩</a></li>
<li id="fn3">Adwait Ratnaparkhi, <a href="http://www.aclweb.org/anthology/P/P98/P98-2177.pdf">"<em>Statistical models for unsupervised prepositional phrase attachment</em>"</a>, ACL-36: Proceedings of the 36th Annual Meeting of the Association for Computational Linguistics and 17th International Conference on Computational Linguistics, pp. 1079-1085, 1998<a href="#fnref3">↩</a></li>
<li id="fn4">Miriam Butt, <a href="http://ling.uni-konstanz.de/pages/home/butt/main/material/chunk.pdf">"<em>Chunk/Shallow parsing</em>"</a>, lecture notes, 2002<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
</ol>
</section>
</hr></body>
</html>
