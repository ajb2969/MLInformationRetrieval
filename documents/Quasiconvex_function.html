<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="573">Quasiconvex function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quasiconvex function</h1>
<hr/>

<p> </p>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>quasiconvex function</strong> is a <a href="real_number" title="wikilink">real</a>-valued <a href="function_(mathematics)" title="wikilink">function</a> defined on an <a href="interval_(mathematics)" title="wikilink">interval</a> or on a <a href="convex_set" title="wikilink">convex subset</a> of a real <a href="vector_space" title="wikilink">vector space</a> such that the <a href="inverse_image" title="wikilink">inverse image</a> of any set of the form 

<math display="inline" id="Quasiconvex_function:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>-</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>,</mo>
   <mi>a</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <minus></minus>
     <infinity></infinity>
    </apply>
    <ci>a</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (-\infty,a)
  </annotation>
 </semantics>
</math>

 is a <a href="convex_set" title="wikilink">convex set</a>. Informally, along any stretch of the curve the highest point is one of the endpoints. The negative of a quasiconvex function is said to be <strong>quasiconcave</strong>.</p>

<p>All <a href="convex_function" title="wikilink">convex functions</a> are also quasiconvex, but not all quasiconvex functions are convex, so quasiconvexity is a generalization of convexity. Quasiconvexity and quasiconcavity extend to functions with multiple <a href="argument_of_a_function" title="wikilink">arguments</a> the notion of <a href="Unimodality#Unimodal_function" title="wikilink">unimodality</a> of functions with a single real argument.</p>
<h2 id="definition-and-properties">Definition and properties</h2>

<p>A function 

<math display="inline" id="Quasiconvex_function:1">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>S</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:S\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 defined on a convex subset <em>S</em> of a real vector space is quasiconvex if for all 

<math display="inline" id="Quasiconvex_function:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
   </mrow>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>x</ci>
     <ci>y</ci>
    </list>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y\in S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quasiconvex_function:3">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>λ</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\in[0,1]
  </annotation>
 </semantics>
</math>

 we have</p>

<p>

<math display="block" id="Quasiconvex_function:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>λ</mi>
        <mi>x</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mi>λ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>y</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi>max</mi>
     <mrow>
      <mo maxsize="120%" minsize="120%">{</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo maxsize="120%" minsize="120%">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>λ</ci>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <max></max>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\lambda x+(1-\lambda)y)\leq\max\big\{f(x),f(y)\big\}.
  </annotation>
 </semantics>
</math>

</p>

<p>In words, if <em>f</em> is such that it is always true that a point directly between two other points does not give a higher value of the function than both of the other points do, then <em>f</em> is quasiconvex. Note that the points <em>x</em> and <em>y</em>, and the point directly between them, can be points on a line or more generally points in <em>n</em>-dimensional space.</p>
<figure><b>(Figure)</b>
<figcaption>A quasilinear function is both quasiconvex and quasiconcave.</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>The graph of a function that is both concave and quasi-convex on the nonnegative real numbers.</figcaption>
</figure>

<p>An alternative way (see introduction) of defining a quasi-convex function 

<math display="inline" id="Quasiconvex_function:5">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is to require that each sub-levelset 

<math display="inline" id="Quasiconvex_function:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mi>α</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>≤</mo>
     <mi>α</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>α</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{\alpha}(f)=\{x|f(x)\leq\alpha\}
  </annotation>
 </semantics>
</math>

 is a convex set.</p>

<p>If furthermore</p>

<p>

<math display="block" id="Quasiconvex_function:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>λ</mi>
       <mi>x</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>λ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo maxsize="120%" minsize="120%">{</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo maxsize="120%" minsize="120%">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>λ</ci>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <max></max>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\lambda x+(1-\lambda)y)<\max\big\{f(x),f(y)\big\}
  </annotation>
 </semantics>
</math>

</p>

<p>for all 

<math display="inline" id="Quasiconvex_function:8">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quasiconvex_function:9">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>λ</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\in(0,1)
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Quasiconvex_function:10">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is <strong>strictly quasiconvex</strong>. That is, strict quasiconvexity requires that a point directly between two other points must give a lower value of the function than one of the other points does.</p>

<p>A <strong>quasiconcave function</strong> is a function whose negative is quasiconvex, and a <strong>strictly quasiconcave function</strong> is a function whose negative is strictly quasiconvex. Equivalently a function 

<math display="inline" id="Quasiconvex_function:11">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is quasiconcave if</p>

<p>

<math display="block" id="Quasiconvex_function:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>λ</mi>
        <mi>x</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mi>λ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>y</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mi>min</mi>
     <mrow>
      <mo maxsize="120%" minsize="120%">{</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo maxsize="120%" minsize="120%">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>λ</ci>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <min></min>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\lambda x+(1-\lambda)y)\geq\min\big\{f(x),f(y)\big\}.
  </annotation>
 </semantics>
</math>

</p>

<p>and strictly quasiconcave if</p>

<p>

<math display="block" id="Quasiconvex_function:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>λ</mi>
       <mi>x</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>λ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo maxsize="120%" minsize="120%">{</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo maxsize="120%" minsize="120%">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>λ</ci>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <min></min>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\lambda x+(1-\lambda)y)>\min\big\{f(x),f(y)\big\}
  </annotation>
 </semantics>
</math>

</p>

<p>A (strictly) quasiconvex function has (strictly) convex <a href="lower_contour_set" title="wikilink">lower contour sets</a>, while a (strictly) quasiconcave function has (strictly) convex <a href="upper_contour_set" title="wikilink">upper contour sets</a>.</p>

<p>A function that is both quasiconvex and quasiconcave is <strong>quasilinear</strong>.</p>

<p>A particular case of quasi-concavity, if 

<math display="inline" id="Quasiconvex_function:14">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊂</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subset\mathbb{R}
  </annotation>
 </semantics>
</math>

, is <a href="Unimodality#Unimodal_function" title="wikilink">unimodality</a>, in which there is a locally maximal value.</p>
<h2 id="applications">Applications</h2>

<p>Quasiconvex functions have applications in <a href="mathematical_analysis" title="wikilink">mathematical analysis</a>, in <a href="mathematical_optimization" title="wikilink">mathematical optimization</a>, and in <a href="game_theory" title="wikilink">game theory</a> and <a class="uri" href="economics" title="wikilink">economics</a>.</p>
<h3 id="mathematical-optimization">Mathematical optimization</h3>

<p>In <a href="nonlinear_programming" title="wikilink">nonlinear optimization</a>, quasiconvex programming studies <a href="iterative_method" title="wikilink">iterative methods</a> that converge to a minimum (if one exists) for quasiconvex functions. Quasiconvex programming is a generalization of <a href="convex_programming" title="wikilink">convex programming</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Quasiconvex programming is used in the solution of "surrogate" <a href="dual_problem" title="wikilink">dual problems</a>, whose biduals provide quasiconvex closures of the primal problem, which therefore provide tighter bounds than do the convex closures provided by <a href="Lagrangian_function" title="wikilink">Lagrangian</a> <a href="Lagrange_duality" title="wikilink">dual problems</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In <a href="Computational_complexity_theory" title="wikilink">theory</a>, quasiconvex programming and convex programming problems can be solved in reasonable amount of time, where the number of iterations grows like a polynomial in the dimension of the problem (and in the reciprocal of the approximation error tolerated);<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> however, such theoretically "efficient" methods use "divergent-series" <a href="gradient_descent#Stepsize_rules" title="wikilink">stepsize rules</a>, which were first developed for classical <a href="subgradient_method" title="wikilink">subgradient methods</a>. Classical subgradient methods using divergent-series rules are much slower than modern methods of convex minimization, such as subgradient projection methods, <a href="bundle_method" title="wikilink">bundle methods</a> of descent, and nonsmooth <a href="filter_method" title="wikilink">filter methods</a>.</p>
<h3 id="economics-and-partial-differential-equations-minimax-theorems">Economics and partial differential equations: Minimax theorems</h3>

<p>In <a class="uri" href="microeconomics" title="wikilink">microeconomics</a>, quasiconcave <a href="utility_function" title="wikilink">utility functions</a> imply that consumers have <a href="convex_preferences" title="wikilink">convex preferences</a>. Quasiconvex functions are important also in <a href="game_theory" title="wikilink">game theory</a>, <a href="industrial_organization" title="wikilink">industrial organization</a>, and <a href="general_equilibrium_theory" title="wikilink">general equilibrium theory</a>, particularly for applications of <a href="Sion's_minimax_theorem" title="wikilink">Sion's minimax theorem</a>. Generalizing a <a href="minimax_theorem" title="wikilink">minimax theorem</a> of <a href="John_von_Neumann" title="wikilink">John von Neumann</a>, Sion's theorem is also used in the theory of <a href="partial_differential_equation" title="wikilink">partial differential equations</a>.</p>
<h2 id="preservation-of-quasiconvexity">Preservation of quasiconvexity</h2>
<h3 id="operations-preserving-quasiconvexity">Operations preserving quasiconvexity</h3>
<ul>
<li>non-negative weighted maximum of quasiconvex functions (i.e. 

<math display="inline" id="Quasiconvex_function:15">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo>{</mo>
     <mrow>
      <msub>
       <mi>w</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>f</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>w</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>f</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <max></max>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=\max\left\{w_{1}f_{1},\ldots,w_{n}f_{n}\right\}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Quasiconvex_function:16">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}
  </annotation>
 </semantics>
</math>

 non-negative)</li>
<li>composition with a non-decreasing function (i.e. 

<math display="inline" id="Quasiconvex_function:17">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:\mathbb{R}^{n}\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 quasiconvex, 

<math display="inline" id="Quasiconvex_function:18">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℝ</mi>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℝ</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h:\mathbb{R}\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 non-decreasing, then 

<math display="inline" id="Quasiconvex_function:19">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mo>∘</mo>
    <mi>g</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <compose></compose>
     <ci>h</ci>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=h\circ g
  </annotation>
 </semantics>
</math>

 is quasiconvex)</li>
<li>minimization (i.e. 

<math display="inline" id="Quasiconvex_function:20">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>

 quasiconvex, 

<math display="inline" id="Quasiconvex_function:21">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 convex set, then 

<math display="inline" id="Quasiconvex_function:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>inf</mo>
     <mrow>
      <mi>y</mi>
      <mo>∈</mo>
      <mi>C</mi>
     </mrow>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">infimum</csymbol>
      <apply>
       <in></in>
       <ci>y</ci>
       <ci>C</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)=\inf_{y\in C}f(x,y)
  </annotation>
 </semantics>
</math>

 is quasiconvex)</li>
</ul>
<h3 id="operations-not-preserving-quasiconvexity">Operations not preserving quasiconvexity</h3>
<ul>
<li>The sum of quasiconvex functions defined on <em>the same domain</em> need not be quasiconvex: In other words, if 

<math display="inline" id="Quasiconvex_function:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x),g(x)
  </annotation>
 </semantics>
</math>

 are quasiconvex, then 

<math display="inline" id="Quasiconvex_function:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>+</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f+g)(x)=f(x)+g(x)
  </annotation>
 </semantics>
</math>

 need not be quasiconvex.</li>
<li>The sum of quasiconvex functions defined on <em>different</em> domains (i.e. if 

<math display="inline" id="Quasiconvex_function:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>y</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x),g(y)
  </annotation>
 </semantics>
</math>

 are quasiconvex, 

<math display="inline" id="Quasiconvex_function:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x,y)=f(x)+g(y)
  </annotation>
 </semantics>
</math>

) need not be quasiconvex. Such functions are called "additively decomposed" in economics and "separable" in <a href="mathematical_optimization" title="wikilink">mathematical optimization</a>.</li>
</ul>
<h2 id="examples">Examples</h2>
<ul>
<li>Every convex function is quasiconvex.</li>
<li>A concave function can be quasiconvex function. For example 

<math display="inline" id="Quasiconvex_function:27">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>↦</mo>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>x</ci>
    <apply>
     <log></log>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mapsto\log(x)
  </annotation>
 </semantics>
</math>

 is concave, and it is quasiconvex.</li>
<li>Any <a href="monotonic_function" title="wikilink">monotonic function</a> is both quasiconvex and quasiconcave. More generally, a function which decreases up to a point and increases from that point on is quasiconvex (compare <a class="uri" href="unimodality" title="wikilink">unimodality</a>).</li>
<li>The <a href="floor_function" title="wikilink">floor function</a> 

<math display="inline" id="Quasiconvex_function:28">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">⌊</mo>
    <mi>x</mi>
    <mo stretchy="false">⌋</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>x</ci>
    <apply>
     <floor></floor>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mapsto\lfloor x\rfloor
  </annotation>
 </semantics>
</math>

 is an example of a quasiconvex function that is neither convex nor continuous.</li>
<li>If 

<math display="inline" id="Quasiconvex_function:29">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>↦</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mapsto f(x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quasiconvex_function:30">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>↦</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\mapsto g(y)
  </annotation>
 </semantics>
</math>

 are positive convex decreasing functions, then 

<math display="inline" id="Quasiconvex_function:31">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
     <ci>g</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)\mapsto f(x)g(y)
  </annotation>
 </semantics>
</math>

 is quasiconvex.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Convex_function" title="wikilink">Convex function</a></li>
<li><a href="Concave_function" title="wikilink">Concave function</a></li>
<li><a class="uri" href="Pseudoconvexity" title="wikilink">Pseudoconvexity</a> in the sense of several complex variables (not generalized convexity)</li>
<li><a href="Pseudoconvex_function" title="wikilink">Pseudoconvex function</a></li>
<li><a href="Invex_function" title="wikilink">Invex function</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li>Avriel, M., Diewert, W.E., Schaible, S. and Zang, I., <em>Generalized Concavity</em>, Plenum Press, 1988.</li>
<li></li>
<li>Singer, Ivan <em>Abstract convex analysis</em>. Canadian Mathematical Society Series of Monographs and Advanced Texts. A Wiley-Interscience Publication. John Wiley &amp; Sons, Inc., New York, 1997. xxii+491 pp. ISBN 0-471-16015-6</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://projecteuclid.org/euclid.pjm/1103040253">SION, M., "On general minimax theorems", Pacific J. Math. 8 (1958), 171-176.</a></li>
<li><a href="http://glossary.computing.society.informs.org/second.php">Mathematical programming glossary</a></li>
<li><a href="http://homepages.nyu.edu/~caw1/UMath/Handouts/ums11h22convexsetsandfunctions.pdf">Concave and Quasi-Concave Functions</a> - by Charles Wilson, <a class="uri" href="NYU" title="wikilink">NYU</a> Department of Economics</li>
<li><a href="http://www.economics.utoronto.ca/osborne/MathTutorial/QCC.HTM">Quasiconcavity and quasiconvexity</a> - by Martin J. Osborne, <a href="University_of_Toronto" title="wikilink">University of Toronto</a> Department of Economics</li>
</ul>

<p>"</p>

<p><a href="Category:Real_analysis" title="wikilink">Category:Real analysis</a> <a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Types_of_functions" title="wikilink">Category:Types of functions</a> <a href="Category:Convex_analysis" title="wikilink">Category:Convex analysis</a> <a href="Category:Generalized_convexity" title="wikilink">Category:Generalized convexity</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">: <a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"> Kiwiel acknowledges that <a href="Yuri_Nesterov_(mathematician)" title="wikilink">Yuri Nesterov</a> first established that quasiconvex minimization problems can be solved efficiently.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
