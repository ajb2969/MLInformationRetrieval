   Least mean squares filter      Least mean squares filter   Least mean squares (LMS) algorithms are a class of adaptive filter used to mimic a desired filter by finding the filter coefficients that relate to producing the least mean squares of the error signal (difference between the desired and the actual signal). It is a stochastic gradient descent method in that the filter is only adapted based on the error at the current time. It was invented in 1960 by Stanford University professor Bernard Widrow and his first Ph.D. student, Ted Hoff .  Problem formulation  (Figure)  LMS filter   Relationship to the least mean squares filter  The realization of the causal Wiener filter looks a lot like the solution to the least squares estimate, except in the signal processing domain. The least squares solution, for input matrix   𝐗   𝐗   \scriptstyle\mathbf{X}   and output vector   𝐲   𝐲   \scriptstyle\mathbf{y}   is        𝜷  ^   =     (    𝐗  𝐓   𝐗   )    -  1     𝐗  𝐓   𝒚    .       bold-^  𝜷      superscript     superscript  𝐗  𝐓   𝐗     1     superscript  𝐗  𝐓   𝒚     \boldsymbol{\hat{\beta}}=(\mathbf{X}^{\mathbf{T}}\mathbf{X})^{-1}\mathbf{X}^{%
 \mathbf{T}}\boldsymbol{y}.     The FIR least mean squares filter is related to the Wiener filter, but minimizing the error criterion of the former does not rely on cross-correlations or auto-correlations. Its solution converges to the Wiener filter solution. Most linear adaptive filtering problems can be formulated using the block diagram above. That is, an unknown system    𝐡   (  n  )       𝐡  n    \mathbf{h}(n)   is to be identified and the adaptive filter attempts to adapt the filter     𝐡  ^    (  n  )        normal-^  𝐡   n    \hat{\mathbf{h}}(n)   to make it as close as possible to    𝐡   (  n  )       𝐡  n    \mathbf{h}(n)   , while using only observable signals    x   (  n  )       x  n    x(n)   ,    d   (  n  )       d  n    d(n)   and    e   (  n  )       e  n    e(n)   ; but    y   (  n  )       y  n    y(n)   ,    v   (  n  )       v  n    v(n)   and    h   (  n  )       h  n    h(n)   are not directly observable. Its solution is closely related to the Wiener filter .  Definition of symbols     n   n   n   is the number of the current input sample     p   p   p   is the number of filter taps       {  ⋅  }   H     superscript   normal-⋅   H    \{\cdot\}^{H}   ( Hermitian transpose or conjugate transpose )       𝐱   (  n  )    =    [   x   (  n  )    ,   x   (   n  -  1   )    ,  …  ,   x   (    n  -  p   +  1   )    ]   T         𝐱  n    superscript     x  n     x    n  1    normal-…    x      n  p   1     T     \mathbf{x}(n)=\left[x(n),x(n-1),\dots,x(n-p+1)\right]^{T}           𝐡   (  n  )    =    [    h  0    (  n  )    ,    h  1    (  n  )    ,  …  ,    h   p  -  1     (  n  )    ]   T    ,    𝐡   (  n  )    ∈   ℂ  p       formulae-sequence      𝐡  n    superscript      subscript  h  0   n      subscript  h  1   n   normal-…     subscript  h    p  1    n    T        𝐡  n    superscript  ℂ  p      \mathbf{h}(n)=\left[h_{0}(n),h_{1}(n),\dots,h_{p-1}(n)\right]^{T},\quad\mathbf%
 {h}(n)\in\mathbb{C}^{p}          y   (  n  )    =      𝐡  H    (  n  )    ⋅  𝐱    (  n  )          y  n      normal-⋅     superscript  𝐡  H   n   𝐱   n     y(n)=\mathbf{h}^{H}(n)\cdot\mathbf{x}(n)          d   (  n  )    =    y   (  n  )    +   ν   (  n  )           d  n       y  n     ν  n      d(n)=y(n)+\nu(n)          𝐡  ^    (  n  )        normal-^  𝐡   n    \hat{\mathbf{h}}(n)   estimated filter; interpret as the estimation of the filter coefficients after   n   n   n   samples       e   (  n  )    =    d   (  n  )    -    y  ^    (  n  )     =    d   (  n  )    -       𝐡  ^   H    (  n  )    ⋅  𝐱    (  n  )             e  n       d  n      normal-^  y   n             d  n      normal-⋅     superscript   normal-^  𝐡   H   n   𝐱   n       e(n)=d(n)-\hat{y}(n)=d(n)-\hat{\mathbf{h}}^{H}(n)\cdot\mathbf{x}(n)     Idea  The basic idea behind LMS filter is to approach the optimum filter weights    (    R   -  1    P   )       superscript  R    1    P    (R^{-1}P)   , by updating the filter weights in a manner to converge to the optimum filter weight. The algorithm starts by assuming a small weights (zero in most cases), and at each step, by finding the gradient of the mean square error, the weights are updated. That is, if the MSE-gradient is positive, it implies, the error would keep increasing positively, if the same weight is used for further iterations, which means we need to reduce the weights. In the same way, if the gradient is negative, we need to increase the weights. So, the basic weight update equation is :       W   n  +  1    =    W  n   -   μ   ∇  ε    [  n  ]          subscript  W    n  1       subscript  W  n     μ   normal-∇  ε    delimited-[]  n       W_{n+1}=W_{n}-\mu\nabla\varepsilon[n]   ,  where   ε   ε   \varepsilon   represents the mean-square error. The negative sign indicates that, we need to change the weights in a direction opposite to that of the gradient slope.  The mean-square error, as a function of filter weights is a quadratic function which means it has only one extrema, that minimises the mean-square error, which is the optimal weight. The LMS thus, approaches towards this optimal weights by ascending/descending down the mean-square-error vs filter weight curve.  Derivation  The idea behind LMS filters is to use steepest descent to find filter weights    𝐡   (  n  )       𝐡  n    \mathbf{h}(n)   which minimize a cost function . We start by defining the cost function as       C   (  n  )    =   E   {    |   e   (  n  )    |   2   }          C  n     E    superscript      e  n    2       C(n)=E\left\{|e(n)|^{2}\right\}   where    e   (  n  )       e  n    e(n)   is the error at the current sample n and    E   {  ⋅  }       E   normal-⋅     E\{\cdot\}   denotes the expected value .  This cost function (    C   (  n  )       C  n    C(n)   ) is the mean square error, and it is minimized by the LMS. This is where the LMS gets its name. Applying steepest descent means to take the partial derivatives with respect to the individual entries of the filter coefficient (weight) vector         ∇    𝐡  ^   H    C    (  n  )    =     ∇    𝐡  ^   H    E    {   e   (  n  )    e  *    (  n  )    }    =   2  E   {      ∇    𝐡  ^   H     (   e   (  n  )    )     e  *     (  n  )    }              subscript  normal-∇   superscript   normal-^  𝐡   H    C   n       subscript  normal-∇   superscript   normal-^  𝐡   H    E      e  n   superscript  e    n            2  E        subscript  normal-∇   superscript   normal-^  𝐡   H      e  n     superscript  e     n        \nabla_{\hat{\mathbf{h}}^{H}}C(n)=\nabla_{\hat{\mathbf{h}}^{H}}E\left\{e(n)\,e%
 ^{*}(n)\right\}=2E\left\{\nabla_{\hat{\mathbf{h}}^{H}}(e(n))\,e^{*}(n)\right\}   where   ∇   normal-∇   \nabla   is the gradient operator        ∇    𝐡  ^   H     (   e   (  n  )    )    =    ∇    𝐡  ^   H     (    d   (  n  )    -      𝐡  ^   H   ⋅  𝐱    (  n  )     )    =   -   𝐱   (  n  )             subscript  normal-∇   superscript   normal-^  𝐡   H      e  n      subscript  normal-∇   superscript   normal-^  𝐡   H        d  n      normal-⋅   superscript   normal-^  𝐡   H   𝐱   n              𝐱  n       \nabla_{\hat{\mathbf{h}}^{H}}(e(n))=\nabla_{\hat{\mathbf{h}}^{H}}\left(d(n)-%
 \hat{\mathbf{h}}^{H}\cdot\mathbf{x}(n)\right)=-\mathbf{x}(n)           ∇  C    (  n  )    =   -   2  E   {   𝐱   (  n  )    e  *    (  n  )    }            normal-∇  C   n       2  E     𝐱  n   superscript  e    n        \nabla C(n)=-2E\left\{\mathbf{x}(n)\,e^{*}(n)\right\}   Now,     ∇  C    (  n  )        normal-∇  C   n    \nabla C(n)   is a vector which points towards the steepest ascent of the cost function. To find the minimum of the cost function we need to take a step in the opposite direction of     ∇  C    (  n  )        normal-∇  C   n    \nabla C(n)   . To express that in mathematical terms        𝐡  ^    (   n  +  1   )    =     𝐡  ^    (  n  )    -    μ  2    ∇  C    (  n  )     =     𝐡  ^    (  n  )    +    μ   E   {   𝐱   (  n  )    e  *    (  n  )    }              normal-^  𝐡     n  1         normal-^  𝐡   n       μ  2    normal-∇  C   n              normal-^  𝐡   n     μ  E     𝐱  n   superscript  e    n         \hat{\mathbf{h}}(n+1)=\hat{\mathbf{h}}(n)-\frac{\mu}{2}\nabla C(n)=\hat{%
 \mathbf{h}}(n)+\mu\,E\left\{\mathbf{x}(n)\,e^{*}(n)\right\}   where    μ  2      μ  2    \frac{\mu}{2}   is the step size(adaptation constant). That means we have found a sequential update algorithm which minimizes the cost function. Unfortunately, this algorithm is not realizable until we know    E   {   𝐱   (  n  )    e  *    (  n  )    }       E     𝐱  n   superscript  e    n      E\left\{\mathbf{x}(n)\,e^{*}(n)\right\}   .  Generally, the expectation above is not computed. Instead, to run the LMS in an online (updating after each new sample is received) environment, we use an instantaneous estimate of that expectation. See below.  Simplifications  For most systems the expectation function    E   {   𝐱   (  n  )    e  *    (  n  )    }       E     𝐱  n   superscript  e    n      {E}\left\{\mathbf{x}(n)\,e^{*}(n)\right\}   must be approximated. This can be done with the following unbiased estimator        E  ^    {   𝐱   (  n  )    e  *    (  n  )    }    =    1  N     ∑   i  =  0    N  -  1     𝐱   (   n  -  i   )    e  *    (   n  -  i   )             normal-^  E      𝐱  n   superscript  e    n         1  N     superscript   subscript     i  0      N  1      𝐱    n  i    superscript  e      n  i        \hat{E}\left\{\mathbf{x}(n)\,e^{*}(n)\right\}=\frac{1}{N}\sum_{i=0}^{N-1}%
 \mathbf{x}(n-i)\,e^{*}(n-i)   where   N   N   N   indicates the number of samples we use for that estimate. The simplest case is    N  =  1      N  1    N=1           E  ^    {   𝐱   (  n  )    e  *    (  n  )    }    =   𝐱   (  n  )    e  *    (  n  )           normal-^  E      𝐱  n   superscript  e    n       𝐱  n   superscript  e    n     \hat{E}\left\{\mathbf{x}(n)\,e^{*}(n)\right\}=\mathbf{x}(n)\,e^{*}(n)   For that simple case the update algorithm follows as        𝐡  ^    (   n  +  1   )    =     𝐡  ^    (  n  )    +   μ  𝐱   (  n  )    e  *    (  n  )            normal-^  𝐡     n  1         normal-^  𝐡   n     μ  𝐱  n   superscript  e    n      \hat{\mathbf{h}}(n+1)=\hat{\mathbf{h}}(n)+\mu\mathbf{x}(n)\,e^{*}(n)   Indeed this constitutes the update algorithm for the LMS filter.  LMS algorithm summary  The LMS algorithm for a   p   p   p   th order algorithm can be summarized as      Parameters:       p  =       p  absent    p=   filter order          μ  =       μ  absent    \mu=   step size     Initialisation:         𝐡  ^    (  0  )    =   zeros   (  p  )           normal-^  𝐡   0    zeros  p     \hat{\mathbf{h}}(0)=\operatorname{zeros}(p)        Computation:   For    n  =   0  ,  1  ,  2  ,  …       n   0  1  2  normal-…     n=0,1,2,...              𝐱   (  n  )    =    [   x   (  n  )    ,   x   (   n  -  1   )    ,  …  ,   x   (    n  -  p   +  1   )    ]   T         𝐱  n    superscript     x  n     x    n  1    normal-…    x      n  p   1     T     \mathbf{x}(n)=\left[x(n),x(n-1),\dots,x(n-p+1)\right]^{T}              e   (  n  )    =    d   (  n  )    -     𝐡  ^   H    (  n  )   𝐱   (  n  )           e  n       d  n      superscript   normal-^  𝐡   H   n  𝐱  n      e(n)=d(n)-\hat{\mathbf{h}}^{H}(n)\mathbf{x}(n)               𝐡  ^    (   n  +  1   )    =     𝐡  ^    (  n  )    +    μ    e  *    (  n  )   𝐱   (  n  )            normal-^  𝐡     n  1         normal-^  𝐡   n     μ   superscript  e    n  𝐱  n      \hat{\mathbf{h}}(n+1)=\hat{\mathbf{h}}(n)+\mu\,e^{*}(n)\mathbf{x}(n)        Convergence and stability in the mean  As the LMS algorithm does not use the exact values of the expectations, the weights would never reach the optimal weights in the absolute sense, but a convergence is possible in mean. That is, even though the weights may change by small amounts, it changes about the optimal weights. However, if the variance with which the weights change, is large, convergence in mean would be misleading. This problem may occur, if the value of step-size   μ   μ   \mu   is not chosen properly.  If   μ   μ   \mu   is chosen to be large, the amount with which the weights change depends heavily on the gradient estimate, and so the weights may change by a large value so that gradient which was negative at the first instant may now become positive. And at the second instant, the weight may change in the opposite direction by a large amount because of the negative gradient and would thus keep oscillating with a large variance about the optimal weights. On the other hand if   μ   μ   \mu   is chosen to be too small, time to converge to the optimal weights will be too large.  Thus, an upper bound on   μ   μ   \mu   is needed which is given as    0  <  μ  <   2   λ  max          0  μ         2   subscript  λ  max       0<\mu<\frac{2}{\lambda_{\mathrm{max}}}     where    λ  max     subscript  λ     \lambda_{\max}   is the greatest eigenvalue of the autocorrelation matrix    𝐑  =   E   {   𝐱   (  n  )    𝐱  H    (  n  )    }        𝐑    E     𝐱  n   superscript  𝐱  H   n       {\mathbf{R}}=E\{{\mathbf{x}}(n){\mathbf{x}^{H}}(n)\}   . If this condition is not fulfilled, the algorithm becomes unstable and     h  ^    (  n  )        normal-^  h   n    \hat{h}(n)   diverges.  Maximum convergence speed is achieved when       μ  =   2    λ  max   +   λ  min      ,      μ    2     subscript  λ  max    subscript  λ  min       \mu=\frac{2}{\lambda_{\mathrm{max}}+\lambda_{\mathrm{min}}},   where    λ  min     subscript  λ     \lambda_{\min}   is the smallest eigenvalue of R. Given that   μ   μ   \mu   is less than or equal to this optimum, the convergence speed is determined by    λ  min     subscript  λ     \lambda_{\min}   , with a larger value yielding faster convergence. This means that faster convergence can be achieved when    λ  max     subscript  λ     \lambda_{\max}   is close to    λ  min     subscript  λ     \lambda_{\min}   , that is, the maximum achievable convergence speed depends on the eigenvalue spread of   𝐑   𝐑   {\mathbf{R}}   .  A white noise signal has autocorrelation matrix    𝐑  =    σ  2   𝐈       𝐑     superscript  σ  2   𝐈     {\mathbf{R}}=\sigma^{2}{\mathbf{I}}   where    σ  2     superscript  σ  2    \sigma^{2}   is the variance of the signal. In this case all eigenvalues are equal, and the eigenvalue spread is the minimum over all possible matrices. The common interpretation of this result is therefore that the LMS converges quickly for white input signals, and slowly for colored input signals, such as processes with low-pass or high-pass characteristics.  It is important to note that the above upperbound on   μ   μ   \mu   only enforces stability in the mean, but the coefficients of     h  ^    (  n  )        normal-^  h   n    \hat{h}(n)   can still grow infinitely large, i.e. divergence of the coefficients is still possible. A more practical bound is       0  <  μ  <   2   tr   [  𝐑  ]      ,        0  μ         2    tr   delimited-[]  𝐑        0<\mu<\frac{2}{\mathrm{tr}\left[{\mathbf{R}}\right]},   where    tr   [  𝐑  ]       tr   delimited-[]  𝐑     \mathrm{tr}[{\mathbf{R}}]   denotes the trace of   𝐑   𝐑   {\mathbf{R}}   . This bound guarantees that the coefficients of     h  ^    (  n  )        normal-^  h   n    \hat{h}(n)   do not diverge (in practice, the value of   μ   μ   \mu   should not be chosen close to this upper bound, since it is somewhat optimistic due to approximations and assumptions made in the derivation of the bound).  Normalised least mean squares filter (NLMS)  The main drawback of the "pure" LMS algorithm is that it is sensitive to the scaling of its input    x   (  n  )       x  n    x(n)   . This makes it very hard (if not impossible) to choose a learning rate   μ   μ   \mu   that guarantees stability of the algorithm (Haykin 2002). The Normalised least mean squares filter (NLMS) is a variant of the LMS algorithm that solves this problem by normalising with the power of the input. The NLMS algorithm can be summarised as:      Parameters:       p  =       p  absent    p=   filter order          μ  =       μ  absent    \mu=   step size     Initialization:         𝐡  ^    (  0  )    =   zeros   (  p  )           normal-^  𝐡   0    zeros  p     \hat{\mathbf{h}}(0)=\operatorname{zeros}(p)        Computation:   For    n  =   0  ,  1  ,  2  ,  …       n   0  1  2  normal-…     n=0,1,2,...              𝐱   (  n  )    =    [   x   (  n  )    ,   x   (   n  -  1   )    ,  …  ,   x   (    n  -  p   +  1   )    ]   T         𝐱  n    superscript     x  n     x    n  1    normal-…    x      n  p   1     T     \mathbf{x}(n)=\left[x(n),x(n-1),\dots,x(n-p+1)\right]^{T}              e   (  n  )    =    d   (  n  )    -     𝐡  ^   H    (  n  )   𝐱   (  n  )           e  n       d  n      superscript   normal-^  𝐡   H   n  𝐱  n      e(n)=d(n)-\hat{\mathbf{h}}^{H}(n)\mathbf{x}(n)               𝐡  ^    (   n  +  1   )    =     𝐡  ^    (  n  )    +     μ    e  *    (  n  )   𝐱   (  n  )      𝐱  H    (  n  )   𝐱   (  n  )             normal-^  𝐡     n  1         normal-^  𝐡   n       μ   superscript  e    n  𝐱  n      superscript  𝐱  H   n  𝐱  n       \hat{\mathbf{h}}(n+1)=\hat{\mathbf{h}}(n)+\frac{\mu\,e^{*}(n)\mathbf{x}(n)}{%
 \mathbf{x}^{H}(n)\mathbf{x}(n)}        Optimal learning rate  It can be shown that if there is no interference (     v   (  n  )    =  0        v  n   0    v(n)=0   ), then the optimal learning rate for the NLMS algorithm is       μ   o  p  t    =  1       subscript  μ    o  p  t    1    \mu_{opt}=1   and is independent of the input    x   (  n  )       x  n    x(n)   and the real (unknown) impulse response    𝐡   (  n  )       𝐡  n    \mathbf{h}(n)   . In the general case with interference (     v   (  n  )    ≠  0        v  n   0    v(n)\neq 0   ), the optimal learning rate is       μ   o  p  t    =    E   [    |    y   (  n  )    -    y  ^    (  n  )     |   2   ]     E   [    |   e   (  n  )    |   2   ]          subscript  μ    o  p  t        E   delimited-[]   superscript        y  n      normal-^  y   n     2       E   delimited-[]   superscript      e  n    2        \mu_{opt}=\frac{E\left[\left|y(n)-\hat{y}(n)\right|^{2}\right]}{E\left[|e(n)|^%
 {2}\right]}     The results above assume that the signals    v   (  n  )       v  n    v(n)   and    x   (  n  )       x  n    x(n)   are uncorrelated to each other, which is generally the case in practice.  Proof  Let the filter misalignment be defined as     Λ   (  n  )    =    |    𝐡   (  n  )    -    𝐡  ^    (  n  )     |   2         normal-Λ  n    superscript        𝐡  n      normal-^  𝐡   n     2     \Lambda(n)=\left|\mathbf{h}(n)-\hat{\mathbf{h}}(n)\right|^{2}   , we can derive the expected misalignment for the next sample as:       E   [   Λ   (   n  +  1   )    ]    =   E   [    |      𝐡  ^    (  n  )    +     μ    e  *    (  n  )   𝐱   (  n  )      𝐱  H    (  n  )   𝐱   (  n  )      -   𝐡   (  n  )     |   2   ]          E   delimited-[]    normal-Λ    n  1        E   delimited-[]   superscript           normal-^  𝐡   n       μ   superscript  e    n  𝐱  n      superscript  𝐱  H   n  𝐱  n       𝐡  n     2       E\left[\Lambda(n+1)\right]=E\left[\left|\hat{\mathbf{h}}(n)+\frac{\mu\,e^{*}(n%
 )\mathbf{x}(n)}{\mathbf{x}^{H}(n)\mathbf{x}(n)}-\mathbf{h}(n)\right|^{2}\right]          E   [   Λ   (   n  +  1   )    ]    =   E   [    |      𝐡  ^    (  n  )    +     μ    (      v  *    (  n  )    +    y  *    (  n  )     -     y  ^   *    (  n  )     )   𝐱   (  n  )      𝐱  H    (  n  )   𝐱   (  n  )      -   𝐡   (  n  )     |   2   ]          E   delimited-[]    normal-Λ    n  1        E   delimited-[]   superscript           normal-^  𝐡   n       μ         superscript  v    n      superscript  y    n       superscript   normal-^  y     n    𝐱  n      superscript  𝐱  H   n  𝐱  n       𝐡  n     2       E\left[\Lambda(n+1)\right]=E\left[\left|\hat{\mathbf{h}}(n)+\frac{\mu\,\left(v%
 ^{*}(n)+y^{*}(n)-\hat{y}^{*}(n)\right)\mathbf{x}(n)}{\mathbf{x}^{H}(n)\mathbf{%
 x}(n)}-\mathbf{h}(n)\right|^{2}\right]     Let    δ  =     𝐡  ^    (  n  )    -   𝐡   (  n  )         δ       normal-^  𝐡   n     𝐡  n      \mathbf{\delta}=\hat{\mathbf{h}}(n)-\mathbf{h}(n)   and     r   (  n  )    =     y  ^    (  n  )    -   y   (  n  )           r  n        normal-^  y   n     y  n      r(n)=\hat{y}(n)-y(n)          E   [   Λ   (   n  +  1   )    ]    =   E   [    |    δ   (  n  )    -     μ    (    v   (  n  )    +   r   (  n  )     )   𝐱   (  n  )      𝐱  H    (  n  )   𝐱   (  n  )      |   2   ]          E   delimited-[]    normal-Λ    n  1        E   delimited-[]   superscript        δ  n       μ      v  n     r  n    𝐱  n      superscript  𝐱  H   n  𝐱  n      2       E\left[\Lambda(n+1)\right]=E\left[\left|\mathbf{\delta}(n)-\frac{\mu\,\left(v(%
 n)+r(n)\right)\mathbf{x}(n)}{\mathbf{x}^{H}(n)\mathbf{x}(n)}\right|^{2}\right]          E   [   Λ   (   n  +  1   )    ]    =   E   [     (    δ   (  n  )    -     μ    (    v   (  n  )    +   r   (  n  )     )   𝐱   (  n  )      𝐱  H    (  n  )   𝐱   (  n  )      )   H    (    δ   (  n  )    -     μ    (    v   (  n  )    +   r   (  n  )     )   𝐱   (  n  )      𝐱  H    (  n  )   𝐱   (  n  )      )    ]          E   delimited-[]    normal-Λ    n  1        E   delimited-[]     superscript      δ  n       μ      v  n     r  n    𝐱  n      superscript  𝐱  H   n  𝐱  n     H       δ  n       μ      v  n     r  n    𝐱  n      superscript  𝐱  H   n  𝐱  n          E\left[\Lambda(n+1)\right]=E\left[\left(\mathbf{\delta}(n)-\frac{\mu\,\left(v(%
 n)+r(n)\right)\mathbf{x}(n)}{\mathbf{x}^{H}(n)\mathbf{x}(n)}\right)^{H}\left(%
 \mathbf{\delta}(n)-\frac{\mu\,\left(v(n)+r(n)\right)\mathbf{x}(n)}{\mathbf{x}^%
 {H}(n)\mathbf{x}(n)}\right)\right]     Assuming independence, we have:       E   [   Λ   (   n  +  1   )    ]    =     Λ   (  n  )    +   E   [     (     μ    (    v   (  n  )    -   r   (  n  )     )   𝐱   (  n  )      𝐱  H    (  n  )   𝐱   (  n  )     )   H    (     μ    (    v   (  n  )    -   r   (  n  )     )   𝐱   (  n  )      𝐱  H    (  n  )   𝐱   (  n  )     )    ]     -   2  E   [    μ    |   r   (  n  )    |   2      𝐱  H    (  n  )   𝐱   (  n  )     ]           E   delimited-[]    normal-Λ    n  1            normal-Λ  n     E   delimited-[]     superscript      μ      v  n     r  n    𝐱  n      superscript  𝐱  H   n  𝐱  n    H       μ      v  n     r  n    𝐱  n      superscript  𝐱  H   n  𝐱  n          2  E   delimited-[]      μ   superscript      r  n    2       superscript  𝐱  H   n  𝐱  n         E\left[\Lambda(n+1)\right]=\Lambda(n)+E\left[\left(\frac{\mu\,\left(v(n)-r(n)%
 \right)\mathbf{x}(n)}{\mathbf{x}^{H}(n)\mathbf{x}(n)}\right)^{H}\left(\frac{%
 \mu\,\left(v(n)-r(n)\right)\mathbf{x}(n)}{\mathbf{x}^{H}(n)\mathbf{x}(n)}%
 \right)\right]-2E\left[\frac{\mu|r(n)|^{2}}{\mathbf{x}^{H}(n)\mathbf{x}(n)}\right]          E   [   Λ   (   n  +  1   )    ]    =     Λ   (  n  )    +     μ  2   E   [    |   e   (  n  )    |   2   ]      𝐱  H    (  n  )   𝐱   (  n  )      -    2  μ  E   [    |   r   (  n  )    |   2   ]      𝐱  H    (  n  )   𝐱   (  n  )            E   delimited-[]    normal-Λ    n  1            normal-Λ  n        superscript  μ  2   E   delimited-[]   superscript      e  n    2        superscript  𝐱  H   n  𝐱  n         2  μ  E   delimited-[]   superscript      r  n    2        superscript  𝐱  H   n  𝐱  n       E\left[\Lambda(n+1)\right]=\Lambda(n)+\frac{\mu^{2}E\left[|e(n)|^{2}\right]}{%
 \mathbf{x}^{H}(n)\mathbf{x}(n)}-\frac{2\mu E\left[|r(n)|^{2}\right]}{\mathbf{x%
 }^{H}(n)\mathbf{x}(n)}     The optimal learning rate is found at      d  E   [   Λ   (   n  +  1   )    ]     d  μ    =  0          d  E   delimited-[]    normal-Λ    n  1        d  μ    0    \frac{dE\left[\Lambda(n+1)\right]}{d\mu}=0   , which leads to:        2  μ  E   [    |   e   (  n  )    |   2   ]    -   2  E   [    |   r   (  n  )    |   2   ]     =  0          2  μ  E   delimited-[]   superscript      e  n    2       2  E   delimited-[]   superscript      r  n    2      0    2\mu E\left[|e(n)|^{2}\right]-2E\left[|r(n)|^{2}\right]=0         μ  =    E   [    |   r   (  n  )    |   2   ]     E   [    |   e   (  n  )    |   2   ]         μ      E   delimited-[]   superscript      r  n    2       E   delimited-[]   superscript      e  n    2        \mu=\frac{E\left[|r(n)|^{2}\right]}{E\left[|e(n)|^{2}\right]}     See also   Recursive least squares  For statistical techniques relevant to LMS filter see Least squares .  Similarities between Wiener and LMS  Multidelay block frequency domain adaptive filter  Zero forcing equalizer  Kernel adaptive filter   References   Monson H. Hayes: Statistical Digital Signal Processing and Modeling, Wiley, 1996, ISBN 0-471-59431-8  Simon Haykin: Adaptive Filter Theory, Prentice Hall, 2002, ISBN 0-13-048434-2  Simon S. Haykin, Bernard Widrow (Editor): Least-Mean-Square Adaptive Filters, Wiley, 2003, ISBN 0-471-21570-8  Bernard Widrow, Samuel D. Stearns: Adaptive Signal Processing, Prentice Hall, 1985, ISBN 0-13-004029-0  Weifeng Liu, Jose Principe and Simon Haykin: Kernel Adaptive Filtering: A Comprehensive Introduction, John Wiley, 2010, ISBN 0-470-44753-2  Paulo S.R. Diniz: Adaptive Filtering: Algorithms and Practical Implementation, Kluwer Academic Publishers, 1997, ISBN 0-7923-9912-9   External links   LMS Algorithm in Adaptive Antenna Arrays www.antenna-theory.com  LMS Noise cancellation demo www.advsolned.com   "  Category:Digital signal processing  Category:Filter theory  Category:Stochastic algorithms   