<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1222">Type theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Type theory</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <a class="uri" href="logic" title="wikilink">logic</a>, and <a href="computer_science" title="wikilink">computer science</a>, a <strong>type theory</strong> is any of a class of <a href="formal_system" title="wikilink">formal systems</a>, some of which can serve as alternatives to <a href="set_theory" title="wikilink">set theory</a> as a foundation for all mathematics. In type theory, every "term" has a "type" and operations are restricted to terms of a certain type.</p>

<p>Type theory is closely related to (and in some cases overlaps with) <a href="type_system" title="wikilink">type systems</a>, which are a <a href="programming_language" title="wikilink">programming language</a> feature used to reduce <a href="bug_(computer_programming)" title="wikilink">bugs</a>. The types of type theory were created to avoid paradoxes in a variety of formal <a href="mathematical_logic" title="wikilink">logics</a> and <a href="rewrite_system" title="wikilink">rewrite systems</a> and sometimes "type theory" is used to refer to this broader application.</p>

<p>Two well-known type theories that can serve as mathematical foundations are <a href="Alonzo_Church" title="wikilink">Alonzo Church</a>'s <a href="typed_lambda_calculus" title="wikilink">typed λ-calculi</a> and <a href="Per_Martin-Löf" title="wikilink">Per Martin-Löf</a>'s <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a>.</p>
<h2 id="history">History</h2>

<p>The types of type theory were invented by <a href="Bertrand_Russell" title="wikilink">Bertrand Russell</a> in response to his discovery that <a href="Gottlob_Frege" title="wikilink">Gottlob Frege</a>'s version of <a href="naive_set_theory" title="wikilink">naive set theory</a> was afflicted with <a href="Russell's_paradox" title="wikilink">Russell's paradox</a>. This theory of types features prominently in <a href="Alfred_North_Whitehead" title="wikilink">Whitehead</a> and <a href="Bertrand_Russell" title="wikilink">Russell</a>'s <em><a href="Principia_Mathematica" title="wikilink">Principia Mathematica</a></em>. It avoids Russell's paradox by first creating a hierarchy of types, then assigning each mathematical (and possibly other) entity to a type. Objects of a given type are built exclusively from objects of preceding types (those lower in the hierarchy), thus preventing loops.</p>

<p>The common usage of "type theory" is when those types are used with a <a href="term_rewrite_system" title="wikilink">term rewrite system</a>. The most famous early example is <a href="Alonzo_Church" title="wikilink">Alonzo Church</a>'s <a href="lambda_calculus" title="wikilink">lambda calculus</a>. <em>Church's Theory of Types</em><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> helped the formal system avoid the <a href="Kleene–Rosser_paradox" title="wikilink">Kleene–Rosser paradox</a> that afflicted the original untyped lambda calculus. Church demonstrated that it could serve as a foundation of mathematics and it was referred to as a <a href="higher-order_logic" title="wikilink">higher-order logic</a>.</p>

<p>Some other type theories include <a href="Per_Martin-Löf" title="wikilink">Per Martin-Löf</a>'s <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a>, which has been the foundation used in some areas of <a href="Constructivism_(mathematics)" title="wikilink">constructive mathematics</a> and for the proof assistant <a href="Agda_(programming_language)" title="wikilink">Agda</a>. <a href="Thierry_Coquand" title="wikilink">Thierry Coquand</a>'s <a href="calculus_of_constructions" title="wikilink">calculus of constructions</a> and its derivatives are the foundation used by <a class="uri" href="Coq" title="wikilink">Coq</a> and others. The field is an area of active research, as demonstrated by <a href="homotopy_type_theory" title="wikilink">homotopy type theory</a>.</p>
<h2 id="basic-concepts">Basic concepts</h2>

<p>In a system of type theory, each <strong><a href="term_(logic)" title="wikilink">term</a></strong> has a <strong>type</strong> and operations are restricted to terms of a certain type. A <a href="Judgment_(mathematical_logic)" title="wikilink">typing judgment</a> 

<math display="inline" id="Type_theory:0">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>:</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>M</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M:A
  </annotation>
 </semantics>
</math>

 describes that the term 

<math display="inline" id="Type_theory:1">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Type_theory:2">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. For example, 

<math display="inline" id="Type_theory:3">
 <semantics>
  <mi>nat</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>nat</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{nat}
  </annotation>
 </semantics>
</math>


 may be a type representing the natural numbers and 

<math display="inline" id="Type_theory:4">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0,1,2,...
  </annotation>
 </semantics>
</math>

 may be inhabitants of that type. The judgement that 

<math display="inline" id="Type_theory:5">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Type_theory:6">
 <semantics>
  <mi>nat</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>nat</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{nat}
  </annotation>
 </semantics>
</math>

 is written as 

<math display="inline" id="Type_theory:7">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>:</mo>
   <mi>nat</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <cn type="integer">2</cn>
    <ci>nat</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2:\mathrm{nat}
  </annotation>
 </semantics>
</math>

.</p>

<p>A function in type theory is denoted with an arrow 

<math display="inline" id="Type_theory:8">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>


. The function 

<math display="inline" id="Type_theory:9">
 <semantics>
  <mi>addOne</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>addOne</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{addOne}
  </annotation>
 </semantics>
</math>

 (commonly called <a href="Successor_function" title="wikilink">successor</a>), has the judgement 

<math display="inline" id="Type_theory:10">
 <semantics>
  <mrow>
   <mi>addOne</mi>
   <mo>:</mo>
   <mrow>
    <mi>nat</mi>
    <mo>→</mo>
    <mi>nat</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>addOne</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>nat</ci>
     <ci>nat</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{addOne}:\mathrm{nat}\to\mathrm{nat}
  </annotation>
 </semantics>
</math>

. Calling or "<a href="apply" title="wikilink">applying</a>" a function to an argument is usually written without parentheses, so 

<math display="inline" id="Type_theory:11">
 <semantics>
  <mrow>
   <mi>addOne</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>addOne</ci>
    <cn type="float">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{addOne}\ 2
  </annotation>
 </semantics>
</math>

 instead of 

<math display="inline" id="Type_theory:12">
 <semantics>
  <mrow>
   <mi>addOne</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>addOne</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{addOne}(2)
  </annotation>
 </semantics>
</math>

. (This allows for consistent <a class="uri" href="currying" title="wikilink">currying</a>.)</p>

<p>Type theories also contain rules for rewriting terms. These are called <strong>conversion rules</strong> or, if the rule only works in one direction, a <strong>reduction rule</strong>. For example, 

<math display="inline" id="Type_theory:13">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">2</cn>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2+1
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Type_theory:14">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>

 are syntactically different terms, but the first reduces to the latter. This reduction is denoted as 

<math display="inline" id="Type_theory:15">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>↠</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↠</ci>
    <apply>
     <plus></plus>
     <cn type="integer">2</cn>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2+1\twoheadrightarrow 3
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="difference-from-set-theory">Difference from set theory</h2>

<p>There are many different set theories and many different systems of type theory, so what follows are generalizations.</p>
<ul>
<li>Set theory is built on top of logic. It requires a separate system like Frege's underneath it. In type theory, concepts like "and" and "or" can be encoded as types in the type theory itself.</li>
<li>In set theory, an element can belong to multiple sets, either to a subset or superset. In type theory, terms (generally) belong to only one type. (Where a subset would be used, type theory creates a new type, called a <a href="Intuitionistic_type_theory#.CE.A3-types" title="wikilink">dependent sum type</a>, with new terms. Union is similarly achieved by a new <a href="Tagged_union" title="wikilink">sum type</a> and new terms.)</li>
<li>In set theory, sets can contain unrelated elements, e.g., apples and real numbers. In type theory, types that combine unrelated types do so by creating new terms.</li>
<li>Set theory usually encodes numbers as sets. (0 is the empty set, 1 is a set containing the empty set, etc.) Type theory can encode numbers as functions using <a href="Church_encoding" title="wikilink">Church encoding</a> or more naturally as <a href="Intuitionistic_type_theory#Inductive_types" title="wikilink">inductive types</a>, which are a type with well-behaved constant terms.</li>
<li>Set theory allows <a href="Set-builder_notation" title="wikilink">set builder notation</a>.</li>
<li>Type theory has a simple connection to constructive mathematics through the <a href="BHK_interpretation" title="wikilink">BHK interpretation</a>.</li>
</ul>
<h2 id="optional-features">Optional features</h2>
<h3 id="normalization">Normalization</h3>

<p>The term 

<math display="inline" id="Type_theory:16">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">2</cn>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2+1
  </annotation>
 </semantics>
</math>

 reduces to 

<math display="inline" id="Type_theory:17">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Type_theory:18">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>


 cannot be reduced further, it is called a <strong>normal form</strong>. A system of type theory is said to be <strong><a href="Normalization_property_(abstract_rewriting)" title="wikilink">strongly normalizing</a></strong> if all terms have a normal form and any order of reductions reaches it. <strong>Weakly normalizing</strong> systems have a normal form but some orders of reductions may loop forever and never reach it.</p>

<p>For a normalizing system, some borrow the word <strong>element</strong> from set theory and use it to refer to all closed terms that can reduce to the same normal form. A <strong>closed term</strong> is one without parameters. (A term like 

<math display="inline" id="Type_theory:19">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+1
  </annotation>
 </semantics>
</math>

 with its parameter 

<math display="inline" id="Type_theory:20">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is called an <strong>open term</strong>.) Thus, 

<math display="inline" id="Type_theory:21">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">2</cn>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2+1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Type_theory:22">
 <semantics>
  <mrow>
   <mn>3</mn>
   <mo>+</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">3</cn>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3+0
  </annotation>
 </semantics>
</math>

 may be different terms but they're both from the element 

<math display="inline" id="Type_theory:23">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>


.</p>

<p>A similar idea that works for open and closed terms is convertibility. Two terms are <strong>convertible</strong> if there exists a term that they both reduce to. For example, 

<math display="inline" id="Type_theory:24">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">2</cn>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2+1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Type_theory:25">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+2
  </annotation>
 </semantics>
</math>

 are convertible. As are 

<math display="inline" id="Type_theory:26">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>+</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+(1+1)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Type_theory:27">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>+</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+2
  </annotation>
 </semantics>
</math>

. However, 

<math display="inline" id="Type_theory:28">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+1
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Type_theory:29">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+x
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Type_theory:30">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is a free variable) are not because both are in normal form and they are not the same. <a href="Confluence_(abstract_rewriting)" title="wikilink">Confluent</a> and weakly normalizing systems can test if two terms are convertible by checking if they both reduce to the same normal form.</p>
<h3 id="dependent-types">Dependent types</h3>

<p>A <strong>dependent type</strong> is a type that depends on a term or on another type. Thus, the type returned by a function may depend upon the argument to the function.</p>

<p>For example, a list of 

<math display="inline" id="Type_theory:31">
 <semantics>
  <mi>nat</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>nat</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{nat}
  </annotation>
 </semantics>
</math>

s of length 4 may be a different type than a list of 

<math display="inline" id="Type_theory:32">
 <semantics>
  <mi>nat</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>nat</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{nat}
  </annotation>
 </semantics>
</math>

s of length 5. In a type theory with dependent types, it is possible to define a function that take a parameter "n" and returns a list containing "n" zeros. Calling the function with 4 would produce a term with a different type than if the function was called with 5.</p>

<p>Dependent types play a central role in <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a> and in the design of <a href="functional_programming_languages" title="wikilink">functional programming languages</a> like <a href="Idris_(programming_language)" title="wikilink">Idris</a>, <a href="ATS_(programming_language)" title="wikilink">ATS</a>, <a href="Agda_(theorem_prover)" title="wikilink">Agda</a> and <a href="Epigram_(programming_language)" title="wikilink">Epigram</a>.</p>
<h3 id="equality-types-or-identity-types">Equality types (or "identity types")</h3>

<p>Many systems of type theory have a type that represents equality of types and terms. This type is different from convertibility, and is often denoted <strong>propositional equality</strong>.</p>

<p>In intuitionistic type theory, the equality type is known as 

<math display="inline" id="Type_theory:33">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>


 for identity. There is a type 

<math display="inline" id="Type_theory:34">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>I</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>A</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>a</mi>
   </mpadded>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>A</ci>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\ A\ a\ b
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Type_theory:35">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is a type and 

<math display="inline" id="Type_theory:36">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Type_theory:37">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 are both terms of type 

<math display="inline" id="Type_theory:38">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


. A term of type 

<math display="inline" id="Type_theory:39">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>I</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>A</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>a</mi>
   </mpadded>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>A</ci>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\ A\ a\ b
  </annotation>
 </semantics>
</math>

 is interpreted as meaning that 

<math display="inline" id="Type_theory:40">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is equal to 

<math display="inline" id="Type_theory:41">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

.</p>

<p>In practice, it is possible to build a type 

<math display="inline" id="Type_theory:42">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>I</mi>
   </mpadded>
   <mi>nat</mi>
   <mn>3 4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>nat</ci>
    <cn type="float">3 4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\ \mathrm{nat}\ 3\ 4
  </annotation>
 </semantics>
</math>

 but there will not exist a term of that type. In intuitionistic type theory, new terms of equality start with reflexivity. If 

<math display="inline" id="Type_theory:43">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>


 is a term of type 

<math display="inline" id="Type_theory:44">
 <semantics>
  <mi>nat</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>nat</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{nat}
  </annotation>
 </semantics>
</math>

, then there exists a term of type 

<math display="inline" id="Type_theory:45">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>I</mi>
   </mpadded>
   <mi>nat</mi>
   <mn>3 3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>nat</ci>
    <cn type="float">3 3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\ \mathrm{nat}\ 3\ 3
  </annotation>
 </semantics>
</math>

. More complicated equalities can be created by creating a reflexive term and then doing a reduction on one side. So if 

<math display="inline" id="Type_theory:46">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">2</cn>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2+1
  </annotation>
 </semantics>
</math>

 is a term of type 

<math display="inline" id="Type_theory:47">
 <semantics>
  <mi>nat</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>nat</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{nat}
  </annotation>
 </semantics>
</math>

, then there is a term of type 

<math display="inline" id="Type_theory:48">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>I</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>nat</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>2</mn>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>2</mn>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>nat</ci>
    <apply>
     <plus></plus>
     <cn type="integer">2</cn>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">2</cn>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\ \mathrm{nat}\ (2+1)\ (2+1)
  </annotation>
 </semantics>
</math>


 and, by reduction, generate a term of type 

<math display="inline" id="Type_theory:49">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>I</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>nat</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>2</mn>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>nat</ci>
    <apply>
     <plus></plus>
     <cn type="integer">2</cn>
     <cn type="integer">1</cn>
    </apply>
    <cn type="float">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\ \mathrm{nat}\ (2+1)\ 3
  </annotation>
 </semantics>
</math>

. Thus, in this system, the equality type denotes that two values of the same type are convertible by reductions.</p>

<p>Having a type for equality is important because it can be manipulated inside the system. There is usually no judgement to say two terms are <em>not</em> equal; instead, as in the <a href="Brouwer–Heyting–Kolmogorov_interpretation" title="wikilink">Brouwer–Heyting–Kolmogorov interpretation</a>, we map 

<math display="inline" id="Type_theory:50">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>a</mi>
     <mo>=</mo>
     <mi>b</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <eq></eq>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(a=b)
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Type_theory:51">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>=</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <eq></eq>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a=b)\to\bot
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Type_theory:52">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

 is the <a href="bottom_type" title="wikilink">bottom type</a> having no values. There exists a term with type 

<math display="inline" id="Type_theory:53">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>I</mi>
     </mpadded>
     <mi>nat</mi>
     <mn>3 4</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>nat</ci>
     <cn type="float">3 4</cn>
    </apply>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I\ \mathrm{nat}\ 3\ 4)\to\bot
  </annotation>
 </semantics>
</math>


, but not one of type 

<math display="inline" id="Type_theory:54">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>I</mi>
     </mpadded>
     <mi>nat</mi>
     <mn>3 3</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>nat</ci>
     <cn type="float">3 3</cn>
    </apply>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I\ \mathrm{nat}\ 3\ 3)\to\bot
  </annotation>
 </semantics>
</math>

.</p>

<p><a href="Homotopy_type_theory" title="wikilink">Homotopy type theory</a> differs from <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a> mostly by its handling of the equality type.</p>
<h3 id="inductive-types">Inductive types</h3>

<p>A system of type theory requires some basic terms and types to operate on. Some systems build them out of functions using <a href="Church_encoding" title="wikilink">Church encoding</a>. Other systems have <strong>inductive types</strong>: a set of base types and a set of <a href="type_constructor" title="wikilink">type constructors</a> that generate types with well-behaved properties. For example, <a href="Structural_induction" title="wikilink">certain recursive functions</a> called on inductive types are guaranteed to terminate.</p>

<p><strong>Coinductive type</strong> are infinite data types created by giving a function that generates the next element(s). See <a class="uri" href="Coinduction" title="wikilink">Coinduction</a> and <a class="uri" href="Corecursion" title="wikilink">Corecursion</a>.</p>

<p>'''<a href="Induction-Induction_(type_theory)" title="wikilink">Induction induction</a> ''' is a feature for declaring an inductive type and a family of types that depends on the inductive type.</p>

<p><strong><a href="Induction-recursion_(type_theory)" title="wikilink">Induction recursion</a></strong> allows a wider range of well-behaved types but requires that the type and the recursive functions that operate on them be defined at the same time.</p>
<h3 id="universe-types">Universe types</h3>

<p>Types were created to prevent paradoxes, such as <a href="Russell's_paradox" title="wikilink">Russell's paradox</a>. However, the motives that lead to those paradoxes – being able to say things about all types – still exist. So many type theories have a "universe type", which contains all other types.</p>

<p>In systems where you might want to say something about universe types, there is a hierarchy of universe types, each containing the one below it in the hierarchy. The hierarchy is defined as being infinite, but statements must only refer to a finite number of universe levels.</p>

<p>Type universes are particularly tricky in type theory. The initial proposal of intuitionistic type theory suffered from <a href="Girard's_paradox" title="wikilink">Girard's paradox</a>.</p>
<h3 id="computational-component">Computational component</h3>

<p>Many systems of type theory, such as the <a href="simply-typed_lambda_calculus" title="wikilink">simply-typed lambda calculus</a>, <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a>, and the <a href="calculus_of_constructions" title="wikilink">calculus of constructions</a>, are also programming languages. That is, they are said to have a "computational component". The computation is the reduction of terms of the language using <a href="rewriting" title="wikilink">rewriting rules</a>.</p>

<p>A system of type theory that has a well-behaved computational component also has a simple connection to constructive mathematics through the <a href="BHK_interpretation" title="wikilink">BHK interpretation</a>.</p>

<p>Non-constructive mathematics in these systems is possible by adding operators on continuations such as <a href="Call/cc#Relation_to_non-constructive_logic" title="wikilink">call with current continuation</a>. However, these operators tend to break desirable properties such as <a href="canonicity_(type_theory)" title="wikilink">canonicity</a> and <a class="uri" href="parametricity" title="wikilink">parametricity</a>.</p>
<h2 id="systems-of-type-theory">Systems of type theory</h2>
<h3 id="major">Major</h3>
<ul>
<li><a href="Simply_typed_lambda_calculus" title="wikilink">Simply typed lambda calculus</a> which is a <a href="higher-order_logic" title="wikilink">higher-order logic</a></li>
<li><a href="Intuitionistic_type_theory" title="wikilink">Intuitionistic type theory</a></li>
<li><a href="System_F" title="wikilink">System F</a></li>
<li><a href="Logical_framework" title="wikilink">LF</a> is often used to define other type theories</li>
<li><a href="Calculus_of_constructions" title="wikilink">Calculus of constructions</a> and its derivatives</li>
</ul>
<h3 id="minor">Minor</h3>
<ul>
<li><a class="uri" href="Automath" title="wikilink">Automath</a></li>
<li>some forms of <a href="combinatory_logic" title="wikilink">combinatory logic</a></li>
<li><a href="ST_type_theory" title="wikilink">ST type theory</a></li>
<li>others defined in the <a href="lambda_cube" title="wikilink">lambda cube</a></li>
<li>others under the name <a href="typed_lambda_calculus" title="wikilink">typed lambda calculus</a></li>
<li>others under the name <a href="pure_type_system" title="wikilink">pure type system</a></li>
</ul>
<h3 id="active">Active</h3>
<ul>
<li><a href="Homotopy_type_theory" title="wikilink">Homotopy type theory</a> is being researched</li>
</ul>
<h2 id="practical-impact">Practical impact</h2>
<h3 id="programming-languages">Programming languages</h3>

<p>There is extensive overlap and interaction between the fields of type theory and type systems. Type systems are a programming language feature designed to identify bugs. Any static program analysis, such as the type checking algorithms in the semantic analysis phase of <a class="uri" href="compiler" title="wikilink">compiler</a>, has a connection to type theory.</p>

<p>A prime example is <a href="Agda_(programming_language)" title="wikilink">Agda</a>, a programming language which uses <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a> for its type system. The programming language <a href="ML_(programming_language)" title="wikilink">ML</a> was developed for manipulating type theories (see <a href="Logic_for_Computable_Functions" title="wikilink">LCF</a>) and its own type system was heavily influenced by them.</p>
<h3 id="mathematical-foundations">Mathematical foundations</h3>

<p>The first computer proof assistant, called <a class="uri" href="Automath" title="wikilink">Automath</a>, used type theory to encode mathematics on a computer. Martin-Löf specifically developed <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a> to encode <em>all</em> mathematics - to serve as a new foundation for mathematics. There is current research into mathematical foundations using <a href="homotopy_type_theory" title="wikilink">homotopy type theory</a>.</p>

<p>Mathematicians working in <a href="category_theory" title="wikilink">category theory</a> already had difficulty working with the widely accepted foundation of <a href="Zermelo–Fraenkel_set_theory" title="wikilink">Zermelo–Fraenkel set theory</a>. This led to proposals such as Lawvere's <a href="Elementary_Theory_of_the_Category_of_Sets" title="wikilink">Elementary Theory of the Category of Sets</a> (ETCS).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Homotopy type theory continues in this line using type theory. Researchers are exploring connections between dependent types (especially the identity type) and <a href="algebraic_topology" title="wikilink">algebraic topology</a> (specifically <a class="uri" href="homotopy" title="wikilink">homotopy</a>).</p>
<h3 id="proof-assistants">Proof assistants</h3>

<p>Much of the current research into type theory is driven by <a href="Automated_proof_checking" title="wikilink">proof checkers</a>, interactive <a href="proof_assistant" title="wikilink">proof assistants</a>, and <a href="Automated_theorem_proving" title="wikilink">automated theorem provers</a>. Most of these systems use a type theory as the mathematical foundation for encoding proofs. This is not surprising, given the close connection between type theory and programming languages.</p>
<ul>
<li><a href="Logical_framework" title="wikilink">LF</a> is used by <a class="uri" href="Twelf" title="wikilink">Twelf</a>, often to define other type theories</li>
<li>Multiple type theories falling under <a href="higher-order_logic" title="wikilink">higher-order logic</a> are used by the <a href="HOL_(proof_assistant)" title="wikilink">HOL family of provers</a> and <a href="Prototype_Verification_System" title="wikilink">PVS</a></li>
<li><a href="Intuitionistic_type_theory" title="wikilink">Intuitionistic type theory</a> is used by <a href="Agda_(programming_language)" title="wikilink">Agda</a> which is both a programming language and proof assistant.</li>
<li>Computational Type Theory is used by <a class="uri" href="NuPRL" title="wikilink">NuPRL</a></li>
<li>The <a href="calculus_of_constructions" title="wikilink">calculus of constructions</a> and its derivatives are used by <a class="uri" href="Coq" title="wikilink">Coq</a> and <a class="uri" href="Matita" title="wikilink">Matita</a>.</li>
</ul>

<p>Multiple type theories are supported by <a href="LEGO_(proof_assistant)" title="wikilink">LEGO</a> and <a href="Isabelle_(proof_assistant)" title="wikilink">Isabelle</a>. Isabelle also supports foundations besides type theories, such as <a href="Zermelo–Fraenkel_set_theory" title="wikilink">ZFC</a>. <a href="Mizar_system" title="wikilink">Mizar</a> is an example of a proof system that only supports set theory.</p>
<h3 id="linguistics">Linguistics</h3>

<p>Type theory is also widely in use in <a href="formal_semantics_(linguistics)" title="wikilink">formal theories of semantics</a> of <a href="natural_language" title="wikilink">natural languages</a>, especially <a href="Montague_grammar" title="wikilink">Montague grammar</a> and its descendants. In particular, <a href="categorial_grammar" title="wikilink">categorial grammars</a> and <a href="pregroup_grammar" title="wikilink">pregroup grammars</a> make extensive use of type constructors to define the types (<em>noun</em>, <em>verb</em>, etc.) of words.</p>

<p>The most common construction takes the basic types 

<math display="inline" id="Type_theory:55">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Type_theory:56">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 for individuals and <a href="truth-value" title="wikilink">truth-values</a>, respectively, and defines the set of types recursively as follows:</p>
<ul>
<li>if 

<math display="inline" id="Type_theory:57">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Type_theory:58">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>


 are types, then so is 

<math display="inline" id="Type_theory:59">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a,b\rangle
  </annotation>
 </semantics>
</math>

.</li>
<li>Nothing except the basic types, and what can be constructed from them by means of the previous clause are types.</li>
</ul>

<p>A complex type 

<math display="inline" id="Type_theory:60">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a,b\rangle
  </annotation>
 </semantics>
</math>

 is the type of <a href="Function_(mathematics)" title="wikilink">functions</a> from entities of type 

<math display="inline" id="Type_theory:61">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 to entities of type 

<math display="inline" id="Type_theory:62">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. Thus one has types like 

<math display="inline" id="Type_theory:63">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>e</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>e</ci>
    <ci>t</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle e,t\rangle
  </annotation>
 </semantics>
</math>


 which are interpreted as elements of the set of functions from entities to truth-values, i.e. <a href="indicator_function" title="wikilink">indicator functions</a> of sets of entities. An expression of type 

<math display="inline" id="Type_theory:64">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <list>
     <ci>e</ci>
     <ci>t</ci>
    </list>
    <ci>t</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\langle e,t\rangle,t\rangle
  </annotation>
 </semantics>
</math>

 is a function from sets of entities to truth-values, i.e. a (indicator function of a) set of sets. This latter type is standardly taken to be the type of <a href="Generalized_quantifier" title="wikilink">natural language quantifiers</a>, like '' everybody'' or '' nobody'' (Montague 1973, Barwise and Cooper 1981).</p>
<h3 id="social-sciences">Social sciences</h3>

<p><a href="Gregory_Bateson" title="wikilink">Gregory Bateson</a> introduced a theory of logical types into the social sciences; his notions of <a href="double_bind" title="wikilink">double bind</a> and <a href="logical_levels" title="wikilink">logical levels</a> are based on Russell's theory of types.</p>
<h2 id="relation-to-category-theory">Relation to category theory</h2>

<p>Although the initial motivation for <a href="category_theory" title="wikilink">category theory</a> was far removed from foundationalism, the two fields turned out to have deep connections. As <a href="John_Lane_Bell" title="wikilink">John Lane Bell</a> writes: "In fact categories can <em>themselves</em> be viewed as type theories of a certain kind; this fact alone indicates that type theory is much more closely related to category theory than it is to set theory." In brief, a category can be viewed as a type theory by regarding its objects as types (or sorts), i.e. "Roughly speaking, a category may be thought of as a type theory shorn of its syntax." A number of significant results follow in this way:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ul>
<li><a href="Cartesian_closed_category" title="wikilink">cartesian closed categories</a> correspond to the typed λ-calculus (<a class="uri" href="Lambek" title="wikilink">Lambek</a>, 1970)</li>
<li><a href="C-monoid" title="wikilink">C-monoids</a> (categories with products and exponentials and a single, nonterminal object) correspond to the untyped λ-calculus (observed independently by Lambek and <a href="Dana_Scott" title="wikilink">Dana Scott</a> around 1980)</li>
<li><a href="Locally_cartesian_closed_category" title="wikilink">locally cartesian closed categories</a> correspond to <a href="Martin-Löf_type_theory" title="wikilink">Martin-Löf type theories</a> (Seely, 1984)</li>
</ul>

<p>The interplay, known as <a href="categorical_logic" title="wikilink">categorical logic</a>, has been a subject of active research since then; see the monograph of Jacobs (1999) for instance.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Data_type" title="wikilink">Data type</a> for concrete types of data in programming</li>
<li><a href="Domain_theory" title="wikilink">Domain theory</a></li>
<li><a href="Type_(model_theory)" title="wikilink">Type (model theory)</a></li>
<li><a href="Type_system" title="wikilink">Type system</a> for a more practical discussion of type systems for programming languages</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>W. Farmer, <em>The seven virtues of simple type theory</em>, Journal of Applied Logic, Vol. 6, No. 3. (September 2008), pp. 267–286.</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="Robert_Lee_Constable" title="wikilink">Constable, Robert L.</a>, 2002, "<a href="http://www.nuprl.org/documents/Constable/naive.pdf">Naïve Computational Type Theory,</a>" in H. Schwichtenberg and R. Steinbruggen (eds.), <em>Proof and System-Reliability</em>: 213–259. Intended as a type theory counterpart of <a href="Paul_Halmos" title="wikilink">Paul Halmos</a>'s (1960) <em><a href="Naive_Set_Theory_(book)" title="wikilink">Naïve Set Theory</a></em></li>
<li></li>
<li>

<p>Covers type theory in depth, including polymorphic and dependent type extensions. Gives <a href="categorical_semantics" title="wikilink">categorical semantics</a>.</p></li>
<li>

<p>Provides a historical survey of the developments of the theory of types with a focus on the decline of the theory as a foundation of mathematics over the four decades following the publication of the second edition of 'Principia Mathematica'.</p></li>
<li>Cardelli, Luca, 1997, "<a href="http://citeseer.ist.psu.edu/cardelli97type.html">Type Systems,</a>" in Allen B. Tucker, ed., <em>The Computer Science and Engineering Handbook</em>. CRC Press: 2208–2236.</li>
<li>Thompson, Simon, 1991. <em><a href="http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/">Type Theory and Functional Programming</a></em>. Addison–Wesley. ISBN 0-201-41667-0.</li>
<li><a href="J._Roger_Hindley" title="wikilink">J. Roger Hindley</a>, <em>Basic Simple Type Theory</em>, Cambridge University Press, 2008, ISBN 0-521-05422-2 (also 1995, 1997). A good introduction to simple type theory for computer scientists; the system described is not exactly Church's STT though. <a href="http://www.iwu.edu/~htiede/papers/pdf/jolli-review.pdf">Book review</a></li>
<li><a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>: <a href="http://plato.stanford.edu/entries/type-theory/">Type Theory</a>" – by <a href="Thierry_Coquand" title="wikilink">Thierry Coquand</a>.</li>
<li>Fairouz D. Kamareddine, Twan Laan, Rob P. Nederpelt, <em>A modern perspective on type theory: from its origins until today</em>, Springer, 2004, ISBN 1-4020-2334-0</li>
<li>José Ferreirós, José Ferreirós Domínguez, <em>Labyrinth of thought: a history of set theory and its role in modern mathematics</em>, Edition 2, Springer, 2007, ISBN 3-7643-8349-6, chapter X "Logic and Type Theory in the Interwar Period"</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://lists.seas.upenn.edu/mailman/listinfo/types-list">The TYPES Forum</a> — moderated e-mail forum focusing on type theory in computer science, operating since 1987.</li>
<li><a href="ftp://ftp.cs.cornell.edu/pub/nuprl/doc/book.ps.gz">The Nuprl Book</a>: "<a href="http://www.cs.cornell.edu/Info/Projects/NuPrl/book/node31.html">Introduction to Type Theory.</a>"</li>
<li><a href="http://www.cs.chalmers.se/Cs/Research/Logic/Types/tutorials.html">Types Project lecture notes</a> of summer schools 2005–2008
<ul>
<li>The <a href="http://www.cs.chalmers.se/Cs/Research/Logic/TypesSS05/program.html">2005 summer school</a> has introductory lectures</li>
</ul></li>
</ul>

<p>"</p>

<p><a href="Category:Type_theory" title="wikilink"> </a> <a href="Category:Systems_of_formal_logic" title="wikilink">Category:Systems of formal logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Alonzo_Church" title="wikilink">Alonzo Church</a>, <a href="http://www.jstor.org/stable/2266170"><em>A formulation of the simple theory of types</em></a>, The Journal of Symbolic Logic 5(2):56–68 (1940)<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
