   SUBCLU      SUBCLU   SUBCLU is an algorithm for clustering high-dimensional data by Karin Kailing, Hans-Peter Kriegel and Peer Kröger. 1 It is a subspace clustering algorithm that builds on the density-based clustering algorithm DBSCAN . SUBCLU can find clusters in axis-parallel subspaces, and uses a bottom-up , greedy strategy to remain efficient.  Approach  SUBCLU uses a monotonicity criteria: if a cluster is found in a subspace   S   S   S   , then each subspace    T  ⊆  S      T  S    T\subseteq S   also contains a cluster. However, a cluster    C  ⊆   D  B       C    D  B     C\subseteq DB   in subspace   S   S   S   is not necessarily a cluster in    T  ⊆  S      T  S    T\subseteq S   , since clusters are required to be maximal, and more objects might be contained in the cluster in   T   T   T   that contains   C   C   C   . However, a density-connected set in a subspace   S   S   S   is also a density-connected set in    T  ⊆  S      T  S    T\subseteq S   .  This downward-closure property is utilized by SUBCLU in a way similar to the Apriori algorithm : first, all 1-dimensional subspaces are clustered. All clusters in a higher-dimensional subspace will be subsets of the clusters detected in this first clustering. SUBCLU hence recursively produces    k  +  1      k  1    k+1   -dimensional candidate subspaces by combining   k   k   k   -dimensional subspaces with clusters sharing    k  -  1      k  1    k-1   attributes. After pruning irrelevant candidates, DBSCAN is applied to the candidate subspace to find out if it still contains clusters. If it does, the candidate subspace is used for the next combination of subspaces. In order to improve the runtime of DBSCAN , only the points known to belong to clusters in one   k   k   k   -dimensional subspace (which is chosen to contain as little clusters as possible) are considered. Due to the downward-closure property, other point cannot be part of a    k  +  1      k  1    k+1   -dimensional cluster anyway.  Pseudocode  SUBCLU takes two parameters,   ϵ   ϵ   \epsilon\!\,   and    M  i  n  P  t  s      M  i  n  P  t  s    MinPts   , which serve the same role as in DBSCAN . In a first step, DBSCAN is used to find 1D-clusters in each subspace spanned by a single attribute:      S  U  B  C  L  U   (   D  B   ,   e  p  s   ,   M  i  n  P  t  s   )       S  U  B  C  L  U     D  B     e  p  s     M  i  n  P  t  s      \!\,SUBCLU(DB,eps,MinPts)          S  1   :=  ∅     assign   subscript  S  1      S_{1}:=\emptyset          C  1   :=  ∅     assign   subscript  C  1      C_{1}:=\emptyset          f  o   r   e  a  c   h   a   ∈   A  t  t  r  i  b  u  t  e  s         f  o  r  e  a  c  h  a     A  t  t  r  i  b  u  t  e  s     for\,each\,a\in Attributes            C   {  a  }    =   D  B  S  C  A  N   (   D  B   ,   {  a  }   ,   e  p  s   ,   M  i  n  P  t  s   )         superscript  C   a      D  B  S  C  A  N     D  B    a     e  p  s     M  i  n  P  t  s       C^{\{a\}}=DBSCAN(DB,\{a\},eps,MinPts)\!\,         i  f   (   C   {  a  }    ≠  ∅  )      fragments  i  f   fragments  normal-(   superscript  C   a      normal-)     if(C^{\{a\}}\neq\emptyset)         S  1   :=    S  1   ∪   {  a  }       assign   subscript  S  1      subscript  S  1    a      S_{1}:=S_{1}\cup\{a\}          C  1   :=    C  1   ∪   C   {  a  }        assign   subscript  C  1      subscript  C  1    superscript  C   a       C_{1}:=C_{1}\cup C^{\{a\}}          e  n   d   i  f      e  n  d  i  f    end\,if           e  n   d   f  o  r      e  n  d  f  o  r    end\,for      In a second step,    k  +  1      k  1    k+1   -dimensional clusters are built from   k   k   k   -dimensional ones:      k  :=  1     assign  k  1    k:=1\!\,         w  h  i  l  e   (   C  k   ≠  ∅  )      fragments  w  h  i  l  e   fragments  normal-(   subscript  C  k     normal-)     while(C_{k}\neq\emptyset)            C  a  n  d   S   k  +  1     :=   G  e  n  e  r  a  t  e  C  a  n  d  i  d  a  t  e  S  u  b  s  p  a  c  e  s   (   S  k   )       assign    C  a  n  d   subscript  S    k  1       G  e  n  e  r  a  t  e  C  a  n  d  i  d  a  t  e  S  u  b  s  p  a  c  e  s   subscript  S  k      CandS_{k+1}:=GenerateCandidateSubspaces(S_{k})\!\,          f  o   r   e  a  c   h   c  a  n  d   ∈   C  a  n  d   S   k  +  1           f  o  r  e  a  c  h  c  a  n  d     C  a  n  d   subscript  S    k  1       for\,each\,cand\in CandS_{k+1}         b  e  s  t  S  u  b  s  p  a  c  e   :=    min   s  ∈    S  k   ∧  s   ⊂   c  a  n  d       ∑    C  i   ∈   C  s      |   C  i   |        assign    b  e  s  t  S  u  b  s  p  a  c  e      subscript       s     subscript  S  k   s          c  a  n  d        subscript      subscript  C  i    superscript  C  s        subscript  C  i        bestSubspace:=\min_{s\in S_{k}\wedge s\subset cand}\sum_{C_{i}\in C^{s}}|C_{i}|          C   c  a  n  d    :=  ∅     assign   superscript  C    c  a  n  d       C^{cand}:=\emptyset          f  o   r   e  a  c   h   c  l  u  s  t  e   r   c  l   ∈   C   b  e  s  t  S  u  b  s  p  a  c  e          f  o  r  e  a  c  h  c  l  u  s  t  e  r  c  l    superscript  C    b  e  s  t  S  u  b  s  p  a  c  e      for\,each\,cluster\,cl\in C^{bestSubspace}            C   c  a  n  d    :=    C   c  a  n  d    ∪   D  B  S  C  A  N   (   c  l   ,   c  a  n  d   ,   e  p  s   ,   M  i  n  P  t  s   )        assign   superscript  C    c  a  n  d       superscript  C    c  a  n  d      D  B  S  C  A  N     c  l     c  a  n  d     e  p  s     M  i  n  P  t  s        C^{cand}:=C^{cand}\cup DBSCAN(cl,cand,eps,MinPts)         i   f    (   C   c  a  n  d    ≠  ∅  )      fragments  i  f   fragments  normal-(   superscript  C    c  a  n  d      normal-)     if\,(C^{cand}\neq\emptyset)         S   k  +  1    :=    S   k  +  1    ∪   c  a  n  d       assign   subscript  S    k  1       subscript  S    k  1      c  a  n  d      S_{k+1}:=S_{k+1}\cup cand          C   k  +  1    :=    C   k  +  1    ∪   C   c  a  n  d        assign   subscript  C    k  1       subscript  C    k  1     superscript  C    c  a  n  d       C_{k+1}:=C_{k+1}\cup C^{cand}          e  n   d   i  f      e  n  d  i  f    end\,if           e  n   d   f  o  r      e  n  d  f  o  r    end\,for           e  n   d   f  o  r      e  n  d  f  o  r    end\,for         k  :=   k  +  1      assign  k    k  1     k:=k+1\!\,           e  n   d   w  h  i  l  e      e  n  d  w  h  i  l  e    end\,while          e  n  d      e  n  d    end\!\,     The set    S  k     subscript  S  k    S_{k}   contains all the   k   k   k   -dimensional subspaces that are known to contain clusters. The set    C  k     subscript  C  k    C_{k}   contains the sets of clusters found in the subspaces. The    b  e  s  t  S  u  b  s  p  a  c  e      b  e  s  t  S  u  b  s  p  a  c  e    bestSubspace   is chosen to minimize the runs of DBSCAN (and the number of points that need to be considered in each run) for finding the clusters in the candidate subspaces.  Candidate subspaces are generated much alike the Apriori algorithm generates the frequent itemset candidates: Pairs of the   k   k   k   -dimensional subspaces are compared, and if they differ in one attribute only, they form a    k  +  1      k  1    k+1   -dimensional candidate. However, a number of irrelevant candidates are found as well; they contain a   k   k   k   -dimensional subspace that does not contain a cluster. Hence, these candidates are removed in a second step:      G  e  n  e  r  a  t  e  C  a  n  d  i  d  a  t  e  S  u  b  s  p  a  c  e  s   (   S  k   )       G  e  n  e  r  a  t  e  C  a  n  d  i  d  a  t  e  S  u  b  s  p  a  c  e  s   subscript  S  k     \,\!GenerateCandidateSubspaces(S_{k})          C  a  n  d   S   k  +  1     :=  ∅     assign    C  a  n  d   subscript  S    k  1        CandS_{k+1}:=\emptyset          f  o   r   e  a  c   h    s  1    ∈   S  k         f  o  r  e  a  c  h   subscript  s  1     subscript  S  k     for\,each\,s_{1}\in S_{k}            f  o   r   e  a  c   h    s  2    ∈   S  k         f  o  r  e  a  c  h   subscript  s  2     subscript  S  k     for\,each\,s_{2}\in S_{k}        i   f    (     s  1    a  n   d     s  2     𝑑𝑖𝑓𝑓𝑒𝑟   i   n   e  x  a  c  t  e  l   y   o  n   e   a  t  t  r  i  b  u  t  e   )       i  f     subscript  s  1   a  n  d   subscript  s  2   𝑑𝑖𝑓𝑓𝑒𝑟  i  n  e  x  a  c  t  e  l  y  o  n  e  a  t  t  r  i  b  u  t  e     if\,(s_{1}\,and\,s_{2}\,\,\mathit{differ}\,\,in\,\,exactely\,\,one\,\,attribute)            C  a  n  d   S   k  +  1     :=    C  a  n  d   S   k  +  1     ∪   {    s  1   ∪   s  2    }       assign    C  a  n  d   subscript  S    k  1         C  a  n  d   subscript  S    k  1         subscript  s  1    subscript  s  2        CandS_{k+1}:=CandS_{k+1}\cup\{s_{1}\cup s_{2}\}           e  n   d   i  f      e  n  d  i  f    end\,if           e  n   d   f  o  r      e  n  d  f  o  r    end\,for           e  n   d   f  o  r      e  n  d  f  o  r    end\,for       // Pruning of irrelevant candidate subspaces        f  o   r   e  a  c   h   c  a  n  d   ∈   C  a  n  d   S   k  +  1           f  o  r  e  a  c  h  c  a  n  d     C  a  n  d   subscript  S    k  1       for\,each\,cand\in CandS_{k+1}          f  o   r   e  a  c   h   k   -   e  l  e  m  e  n   t   s    ⊂   c  a  n  d           f  o  r  e  a  c  h  k     e  l  e  m  e  n  t  s      c  a  n  d     for\,each\,k-element\,s\subset cand           i   f    (  s  ∉   S  k   )      fragments  i  f   fragments  normal-(  s    subscript  S  k   normal-)     if\,(s\not\in S_{k})         C  a  n  d   S   k  +  1     =    C  a  n  d   S   k  +  1     ∖   {   c  a  n  d   }          C  a  n  d   subscript  S    k  1         C  a  n  d   subscript  S    k  1        c  a  n  d       CandS_{k+1}=CandS_{k+1}\setminus\{cand\}          e  n   d   i  f      e  n  d  i  f    end\,if           e  n   d   f  o  r      e  n  d  f  o  r    end\,for           e  n   d   f  o  r      e  n  d  f  o  r    end\,for          e  n  d      e  n  d    end\,\!     Availability  An example implementation of SUBCLU is available in the ELKI framework .  References    "  Category:Data clustering algorithms     Karin Kailing, Hans-Peter Kriegel and Peer Kröger. Density-Connected Subspace Clustering for High-Dimensional Data . In: Proc. SIAM Int. Conf. on Data Mining (SDM'04) , pp. 246-257, 2004. ↩     