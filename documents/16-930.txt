   Sakai‚ÄìKasahara scheme      Sakai‚ÄìKasahara scheme  The '''Sakai‚ÄìKasahara scheme''', also known as the Sakai-Kasahara Key Encryption algorithm ('''SAKKE'''), is an [[Identity based encryption]] system proposed by Ryuichi Sakai and Masao Kasahara in 2003. {{cite journal|last1=Sakai|first1=Ryuichi|l ast2=Kasahara|first2=Masao|title=ID Based cryptosystems with pairing on elliptic curve|journal=Cryptography ePrint Archive|year=2003|volume=2003/054|url= https://eprint.iacr.org/2003/054.pdf }} Alongside the Boneh-Franklin scheme, this is one of a small number of commercially implemented identity-based encryption schemes. It is an application of pairings over elliptic curves and finite fields . A security proof for the algorithm was produced in 2005 by Chen and Cheng. 1 SAKKE is described in IETF  RFC 6508. 2  As an specific method for identity-based encryption (IBE), the primary use case is to allow anyone to encrypt a message to a user when the sender only knows the public identity (e.g. email address) of the user. In this way, this scheme removes the requirement for users to share public certificates for the purpose of encryption.  Description of Scheme  The Sakai‚ÄìKasahara scheme allows the encryption of a message   ùïÑ   ùïÑ   \mathbb{M}   to an receiver with a specific identity,    I  U     subscript  I  U    \textstyle I_{U}   . Only the entity with the private key,    K  U     subscript  K  U    \textstyle K_{U}   , associated to the identity,    I  U     subscript  I  U    \textstyle I_{U}   , will be capable of decrypting the message.  As part of the scheme, both the sender and receiver must trust a Private Key Generator (PKG), also known as a Key Management Server (KMS). The purpose of the PKG is to create the receiver's private key,    K  U     subscript  K  U    \textstyle K_{U}   , associated to the receiver's identity,    I  U     subscript  I  U    \textstyle I_{U}   . The PKG must securely deliver the identity-specific private key to the receiver, and PKG-specific public parameter,   Z   Z   \textstyle Z   , to all parties. These distribution processes are not considered as part of the definition of this cryptographic scheme.  Preliminaries  The scheme uses two multiplicative groups   E   E   \textstyle E   and   G   G   \textstyle G   . It is assumed:   The Diffie-Hellman problem is hard in   E   E   \textstyle E   . Meaning that given two members of the group   P   P   \textstyle P   and   Q   Q   \textstyle Q   , it is hard to find   x   x   \textstyle x   such that     [  x  ]   .   P  =  Q      formulae-sequence   delimited-[]  x     P  Q     \textstyle[x].P=Q   .  The Diffie-Hellman problem is hard in   G   G   \textstyle G   . Meaning that given two members of the group   g   g   g   and   t   t   t   , it is hard to find   x   x   \textstyle x   such that     g  x   =  t       superscript  g  x   t    \textstyle g^{x}=t   .  There is a bilinear map, a Tate-Lichtenbaum pairing ,    e   (  ,  )      fragments  e   fragments  normal-(  normal-,  normal-)     \textstyle e(,)   from E to G. This means that for   P   P   \textstyle P   a member of   E   E   \textstyle E   and for    g  =   e   (  P  ,  P  )        g    e   P  P      \textstyle g=e(P,P)   a member of   G   G   \textstyle G   :         e   (  P  ,   [  x  ]   .  P  )   =  e   (   [  x  ]   .  P  ,  P  )   =  e    (  P  ,  P  )   x   =   g  x      fragments  e   fragments  normal-(  P  normal-,   fragments  normal-[  x  normal-]   normal-.  P  normal-)    e   fragments  normal-(   fragments  normal-[  x  normal-]   normal-.  P  normal-,  P  normal-)    e   superscript   fragments  normal-(  P  normal-,  P  normal-)   x     superscript  g  x     \textstyle e(P,[x].P)=e([x].P,P)=e(P,P)^{x}=g^{x}        Frequently,   E   E   \textstyle E   is a supersingular elliptic curve , such as    E  :    y  2   =    x  3   -   3  x        normal-:  E     superscript  y  2      superscript  x  3     3  x       \textstyle E:y^{2}=x^{3}-3x   (over a finite field of prime order   p   p   \textstyle p   ). A generator   P   P   \textstyle P   of prime order   q   q   \textstyle q   is chosen in   E   E   \textstyle E   . The group   G   G   \textstyle G   is the image due to the pairing of the group generated by   P   P   \textstyle P   (in the extension field of degree 2 of the finite field of order p).  Two hash functions are also required,    H  1     subscript  H  1    \textstyle H_{1}   and    H  2     subscript  H  2    \textstyle H_{2}   .    H  1     subscript  H  1    \textstyle H_{1}   outputs a positive integer,   x   x   \textstyle x   , such that   n   n   \textstyle n   outputs   n   n   \textstyle n   bits, where   ùïÑ   ùïÑ   \mathbb{M}   is the length of the message   z   z   \textstyle z   .  Key Generation  The PKG has a master secret   E   E   \textstyle E   where    K  U     subscript  K  U    \textstyle K_{U}   which is a point on    I   D  U       I   subscript  D  U     \textstyle ID_{U}   . The PKG generates the private key,      K  U   =   [   1   z  +    H  1    (   I   D  U    )      ]    .  P     formulae-sequence     subscript  K  U    delimited-[]    1    z     subscript  H  1     I   subscript  D  U         P    \textstyle K_{U}=[\frac{1}{z+H_{1}(ID_{U})}].P   , for the user with identity   ùïÑ   ùïÑ   \mathbb{M}   as follows:        I   D  U       I   subscript  D  U     \textstyle ID_{U}        Encryption  To encrypt a non-repeating message   Z   Z   \textstyle Z   , the sender requires receiver's identity,     i  d   =    H  1    (   I   D  U    )          i  d      subscript  H  1     I   subscript  D  U       \textstyle id=H_{1}(ID_{U})   and the public PGK value   r   r   \textstyle r   . The sender performs the following operation.   Create    r  =   H  1    (  ùïÑ  |  |  i  d  )      fragments  r    subscript  H  1    fragments  normal-(  M  normal-|  normal-|  i  d  normal-)     \textstyle r=H_{1}(\mathbb{M}||id)     The sender generates   R   R   \textstyle R   using   E   E   \textstyle E     Generate the point    R  =   [  r  ]   .   (   [  i  d  ]   .  P  +  Z  )      fragments  R    fragments  normal-[  r  normal-]   normal-.   fragments  normal-(   fragments  normal-[  i  d  normal-]   normal-.  P   Z  normal-)     \textstyle R=[r].([id].P+Z)   in    S  =   ùïÑ  ‚äï    H  2    (   g  r   )         S   direct-sum  ùïÑ     subscript  H  2    superscript  g  r       \textstyle S=\mathbb{M}\oplus H_{2}(g^{r})   :       (  R  ,  S  )     R  S    \textstyle(R,S)        Create the masked message:       I   D  U       I   subscript  D  U     \textstyle ID_{U}        The encrypted output is    K  U     subscript  K  U    \textstyle K_{U}      Note that messages may not repeat, as a repeated message to the same identity results in a repeated ciphertext. There is an extension to the protocol should messages potentially repeat.  Decryption  To decrypt a message encrypted to   Z   Z   \textstyle Z   , the receiver requires the private key,     i  d   =    H  1    (   I   D  U    )          i  d      subscript  H  1     I   subscript  D  U       \textstyle id=H_{1}(ID_{U})   from the PKG and the public value    (  R  ,  S  )     R  S    \textstyle(R,S)   . The decryption procedure is as follows:   Compute    w  =   e   (  R  ,   K  U   )        w    e   R   subscript  K  U       \textstyle w=e(R,K_{U})     Receive the encrypted message    ùïÑ  =   S  ‚äï    H  2    (  w  )         ùïÑ   direct-sum  S     subscript  H  2   w      \textstyle\mathbb{M}=S\oplus H_{2}(w)   .  Compute:       r  =   H  1    (  ùïÑ  |  |  i  d  )      fragments  r    subscript  H  1    fragments  normal-(  M  normal-|  normal-|  i  d  normal-)     \textstyle r=H_{1}(\mathbb{M}||id)        Extract the message:        [  r  ]   .   (   [  i  d  ]   .  P  +  Z  )   ‚â°  R     fragments   fragments  normal-[  r  normal-]   normal-.   fragments  normal-(   fragments  normal-[  i  d  normal-]   normal-.  P   Z  normal-)    R    \textstyle[r].([id].P+Z)\equiv R        To verify the message, compute    w  =  e   (  R  ,   K  U   )   =  e   (   [  r  ]   .   (   [  i  d  ]   .  P  +  Z  )   ,   K  U   )   =  e   (   [  r  ]   .   (   [  i  d  ]   .  P  +   [  z  ]   .  P  )   ,   K  U   )   =  e   (   [  r   (  i  d  +  z  )   ]   .  P  ,   K  U   )      fragments  w   e   fragments  normal-(  R  normal-,   subscript  K  U   normal-)    e   fragments  normal-(   fragments  normal-[  r  normal-]   normal-.   fragments  normal-(   fragments  normal-[  i  d  normal-]   normal-.  P   Z  normal-)   normal-,   subscript  K  U   normal-)    e   fragments  normal-(   fragments  normal-[  r  normal-]   normal-.   fragments  normal-(   fragments  normal-[  i  d  normal-]   normal-.  P    fragments  normal-[  z  normal-]   normal-.  P  normal-)   normal-,   subscript  K  U   normal-)    e   fragments  normal-(   fragments  normal-[  r   fragments  normal-(  i  d   z  normal-)   normal-]   normal-.  P  normal-,   subscript  K  U   normal-)     \textstyle w=e(R,K_{U})=e([r].([id].P+Z),K_{U})=e([r].([id].P+[z].P),K_{U})=e(%
 [r(id+z)].P,K_{U})   , and only accept the message if:       w  =  e   (   [  r   (  i  d  +  z  )   ]   .  P  ,   K  U   )   =  e   (   [  r   (  i  d  +  z  )   ]   .  P  ,   [    1   (    i  d   +  z   )     ]   .  P  )   =  e    (  P  ,  P  )     r   (    i  d   +  z   )     (    i  d   +  z   )     =   g  r      fragments  w   e   fragments  normal-(   fragments  normal-[  r   fragments  normal-(  i  d   z  normal-)   normal-]   normal-.  P  normal-,   subscript  K  U   normal-)    e   fragments  normal-(   fragments  normal-[  r   fragments  normal-(  i  d   z  normal-)   normal-]   normal-.  P  normal-,   fragments  normal-[    1      i  d   z    normal-]   normal-.  P  normal-)    e   superscript   fragments  normal-(  P  normal-,  P  normal-)       r      i  d   z        i  d   z       superscript  g  r     \textstyle w=e([r(id+z)].P,K_{U})=e([r(id+z)].P,[\frac{1}{(id+z)}].P)=e(P,P)^{%
 \frac{r(id+z)}{(id+z)}}=g^{r}         Demonstration of Algorithmic Correctness  The following equations demonstrate the correctness of the algorithm:       S  ‚äï    H  2    (  w  )     =    (   ùïÑ  ‚äï    H  2    (   g  r   )     )   ‚äï    H  2    (  w  )     =  ùïÑ         direct-sum  S     subscript  H  2   w     direct-sum   direct-sum  ùïÑ     subscript  H  2    superscript  g  r        subscript  H  2   w         ùïÑ     \textstyle S\oplus H_{2}(w)=(\mathbb{M}\oplus H_{2}(g^{r}))\oplus H_{2}(w)=%
 \mathbb{M}   By the bilinear property of the map:  $$\textstyle w = e([r(id+z)].P,K_U)= e([r(id+z)].P,[\frac{1}{(id+z)}].P) = e(P,P)^{\frac{r(id+z)}{(id+z)}} = g^r$$ As a result:  $$\textstyle  S \oplus H_2(w) = (\mathbb{M} \oplus H_2(g^r)) \oplus H_2(w) = \mathbb{M}$$  Standardisation  There are two standards relating to this protocol:   Initial standardisation of scheme was begun by IEEE in 2006. 3  The scheme was standardised by the IETF in 2012 within RFC 6508. The scheme is used as part of the MIKEY-SAKKE protocol, defined in RFC 6509.   Cryptographic Libraries and Implementations  The scheme is part of the MIRACL cryptographic library.  See also   ID-based encryption   References  "  Category:Public-key encryption schemes  Category:Pairing-based cryptography  Category:Identity-based cryptography  Category:Elliptic curve cryptography     ‚Ü©  ‚Ü©  ‚Ü©     