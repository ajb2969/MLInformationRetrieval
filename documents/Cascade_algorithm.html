<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1726">Cascade algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cascade algorithm</h1>
<hr/>

<p>In the <a href="mathematics" title="wikilink">mathematical</a> topic of <a class="uri" href="wavelet" title="wikilink">wavelet</a> theory, the <strong>cascade algorithm</strong> is a <a href="numerical_method" title="wikilink">numerical method</a> for calculating function values of the basic <a href="Wavelet#Scaling_function" title="wikilink">scaling</a> and <a class="uri" href="wavelet" title="wikilink">wavelet</a> functions of a <a href="discrete_wavelet_transform" title="wikilink">discrete wavelet transform</a> using an iterative algorithm. It starts from values on a coarse sequence of sampling points and produces values for successively more densely spaced sequences of sampling points. Because it applies the same operation over and over to the output of the previous application, it is known as the <em>cascade algorithm</em>.</p>
<h2 id="successive-approximation">Successive approximation</h2>

<p>The iterative algorithm generates successive approximations to ψ(<em>t</em>) or φ(<em>t</em>) from {<em>h</em>} and {<em>g</em>} filter coefficients. If the algorithm converges to a fixed point, then that fixed point is the basic scaling function or wavelet.</p>

<p>The iterations are defined by</p>

<p>

<math display="block" id="Cascade_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <msqrt>
      <mn>2</mn>
     </msqrt>
     <msup>
      <mi>φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mi>t</mi>
       </mrow>
       <mo>-</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>φ</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>t</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi^{(k+1)}(t)=\sum_{n=0}^{N-1}h[n]\sqrt{2}\varphi^{(k)}(2t-n)
  </annotation>
 </semantics>
</math>

</p>

<p>For the <em>k</em>th iteration, where an initial φ<sup>(0)</sup>(<em>t</em>) must be given.</p>

<p>The frequency domain estimates of the basic scaling function is given by</p>

<p>

<math display="block" id="Cascade_algorithm:1">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mfrac>
    <mi>H</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mi>ω</mi>
      <mn>2</mn>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <msup>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mi>ω</mi>
      <mn>2</mn>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Φ</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>ω</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>H</ci>
     <apply>
      <divide></divide>
      <ci>ω</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>ω</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi^{(k+1)}(\omega)=\frac{1}{\sqrt{2}}H\left(\frac{\omega}{2}\right)\Phi^{(k)%
}\left(\frac{\omega}{2}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>and the limit can be viewed as an infinite product in the form</p>

<p>

<math display="block" id="Cascade_algorithm:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi mathvariant="normal">∞</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <msqrt>
        <mn>2</mn>
       </msqrt>
      </mfrac>
      <mi>H</mi>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mi>ω</mi>
        <msup>
         <mn>2</mn>
         <mi>k</mi>
        </msup>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <msup>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">∞</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Φ</ci>
      <infinity></infinity>
     </apply>
     <ci>ω</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>H</ci>
      <apply>
       <divide></divide>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Φ</ci>
       <infinity></infinity>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi^{(\infty)}(\omega)=\prod_{k=1}^{\infty}\frac{1}{\sqrt{2}}H\left(\frac{%
\omega}{2^{k}}\right)\Phi^{(\infty)}(0).
  </annotation>
 </semantics>
</math>

</p>

<p>If such a limit exists, the spectrum of the scaling function is</p>

<p>

<math display="block" id="Cascade_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mfrac>
     <mi>H</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mi>ω</mi>
       <msup>
        <mn>2</mn>
        <mi>k</mi>
       </msup>
      </mfrac>
      <mo>)</mo>
     </mrow>
     <msup>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi mathvariant="normal">∞</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>H</ci>
      <apply>
       <divide></divide>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Φ</ci>
       <infinity></infinity>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(\omega)=\prod_{k=1}^{\infty}\frac{1}{\sqrt{2}}H\left(\frac{\omega}{2^{k}}%
\right)\Phi^{(\infty)}(0)
  </annotation>
 </semantics>
</math>

</p>

<p>The limit does not depends on the initial shape assume for φ<sup>(0)</sup>(<em>t</em>). This algorithm converges reliably to φ(<em>t</em>), even if it is discontinuous.</p>

<p>From this scaling function, the wavelet can be generated from</p>

<p>

<math display="block" id="Cascade_algorithm:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ψ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <msqrt>
       <mn>2</mn>
      </msqrt>
      <msup>
       <mi>φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>t</mi>
        </mrow>
        <mo>-</mo>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>t</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi(t)=\sum_{n=-\infty}^{\infty}g[n]{\sqrt{2}}\varphi^{(k)}(2t-n).
  </annotation>
 </semantics>
</math>

</p>

<p>Plots of the function at each iteration is shown in Figure 1.</p>

<p>Successive approximation can also be derived in the frequency domain.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="C._Sidney_Burrus" title="wikilink">C.S. Burrus</a>, R.A. Gopinath, H. Guo, <em>Introduction to Wavelets and Wavelet Transforms: A Primer</em>, Prentice-Hall, 1988, ISBN 0-13-489600-9.</li>
<li><a class="uri" href="http://cnx.org/content/m10486/latest/">http://cnx.org/content/m10486/latest/</a></li>
<li><a class="uri" href="http://cm.bell-labs.com/cm/ms/who/wim/cascade/index.html">http://cm.bell-labs.com/cm/ms/who/wim/cascade/index.html</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Wavelets" title="wikilink">Category:Wavelets</a></p>
</body>
</html>
