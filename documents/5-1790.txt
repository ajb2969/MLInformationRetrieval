   Otsu's method      Otsu's method  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     In computer vision and image processing , Otsu's method , named after , is used to automatically perform clustering-based image thresholding , 1 or, the reduction of a graylevel image to a binary image. The algorithm assumes that the image contains two classes of pixels following bi-modal histogram (foreground pixels and background pixels), it then calculates the optimum threshold separating the two classes so that their combined spread (intra-class variance ) is minimal, or equivalently (because the sum of pairwise squared distances is constant), so that their inter-class variance is maximal. 2 Consequently, Otsu's method is roughly a one-dimensional, discrete analog of Fisher's Discriminant Analysis .  The extension of the original method to multi-level thresholding is referred to as the Multi Otsu method . 3  Method  In Otsu's method we exhaustively search for the threshold that minimizes the intra-class variance (the variance within the class), defined as a weighted sum of variances of the two classes:        σ  w  2    (  t  )    =     ω  1    (  t  )    σ  1  2    (  t  )    +    ω  2    (  t  )    σ  2  2    (  t  )            subscript   superscript  σ  2   w   t        subscript  ω  1   t   subscript   superscript  σ  2   1   t      subscript  ω  2   t   subscript   superscript  σ  2   2   t      \sigma^{2}_{w}(t)=\omega_{1}(t)\sigma^{2}_{1}(t)+\omega_{2}(t)\sigma^{2}_{2}(t)   Weights    ω  i     subscript  ω  i    \omega_{i}   are the probabilities of the two classes separated by a threshold   t   t   t   and    σ  i  2     subscript   superscript  σ  2   i    \sigma^{2}_{i}   are variances of these classes.  Otsu shows that minimizing the intra-class variance is the same as maximizing inter-class variance: 4        σ  b  2    (  t  )    =    σ  2   -    σ  w  2    (  t  )     =    ω  1    (  t  )    ω  2    (  t  )     [     μ  1    (  t  )    -    μ  2    (  t  )     ]   2             subscript   superscript  σ  2   b   t      superscript  σ  2      subscript   superscript  σ  2   w   t            subscript  ω  1   t   subscript  ω  2   t   superscript   delimited-[]       subscript  μ  1   t      subscript  μ  2   t     2       \sigma^{2}_{b}(t)=\sigma^{2}-\sigma^{2}_{w}(t)=\omega_{1}(t)\omega_{2}(t)\left%
 [\mu_{1}(t)-\mu_{2}(t)\right]^{2}     which is expressed in terms of class probabilities    ω  i     subscript  ω  i    \omega_{i}   and class means    μ  i     subscript  μ  i    \mu_{i}   .  The class probability     ω  1    (  t  )        subscript  ω  1   t    \omega_{1}(t)   is computed from the histogram as   t   t   t   :        ω  1    (  t  )    =    Σ  0  t   p   (  i  )           subscript  ω  1   t      superscript   subscript  normal-Σ  0   t   p  i     \omega_{1}(t)=\Sigma_{0}^{t}p(i)     while the class mean     μ  1    (  t  )        subscript  μ  1   t    \mu_{1}(t)   is:        μ  1    (  t  )    =    [    Σ  0  t   p   (  i  )   x   (  i  )    ]   /   ω  1           subscript  μ  1   t      delimited-[]     superscript   subscript  normal-Σ  0   t   p  i  x  i     subscript  ω  1      \mu_{1}(t)=\left[\Sigma_{0}^{t}p(i)\,x(i)\right]/\omega_{1}     where    x   (  i  )       x  i    x(i)   is the value at the center of the   i   i   i   th histogram bin. Similarly, you can compute     ω  2    (  t  )        subscript  ω  2   t    \omega_{2}(t)   and    μ  2     subscript  μ  2    \mu_{2}   on the right-hand side of the histogram for bins greater than   t   t   t   .  The class probabilities and class means can be computed iteratively. This idea yields an effective algorithm.  The Otsu method produces a threshold on the 0:1 scale. This threshold applies to the dynamic range of pixel intensities present in the image. For example, were the image to only contain pixel intensities in the range of 155 to 255, an Otsu threshold of 0.75 would map to a grayscale threshold value of 230 (not 191 as it would if the image contained pixels in the full range of 0-255). Common photographic images will tend to contain a full range of pixel intensities, making it a moot point, but other applications could be sensitive to the distinction. 5  Algorithm   Compute histogram and probabilities of each intensity level  Set up initial     ω  i    (  0  )        subscript  ω  i   0    \omega_{i}(0)   and     μ  i    (  0  )        subscript  μ  i   0    \mu_{i}(0)     Step through all possible thresholds    t  =   1  …       t    1  normal-…     t=1\ldots   maximum intensity  Update    ω  i     subscript  ω  i    \omega_{i}   and    μ  i     subscript  μ  i    \mu_{i}     Compute     σ  b  2    (  t  )        subscript   superscript  σ  2   b   t    \sigma^{2}_{b}(t)      Desired threshold corresponds to the maximum     σ  b  2    (  t  )        subscript   superscript  σ  2   b   t    \sigma^{2}_{b}(t)     You can compute two maxima (and two corresponding thresholds).     σ   b  1   2    (  t  )        subscript   superscript  σ  2     b  1    t    \sigma^{2}_{b1}(t)   is the greater max and     σ   b  2   2    (  t  )        subscript   superscript  σ  2     b  2    t    \sigma^{2}_{b2}(t)   is the greater or equal maximum  Desired threshold =      threshold  1   +   threshold  2    2         subscript  threshold  1    subscript  threshold  2    2    \frac{\text{threshold}_{1}+\text{threshold}_{2}}{2}      JavaScript implementation  NB: The input argument total is the number of pixels in the given image. The input argument histogram is a 256-element histogram of a grayscale image different gray-levels (typical for 8-bit images). This function outputs the threshold for the image.  function  otsu (histogram , total) {  var sum =  0 ;  for ( var i =  1 ; i <  256 ;  ++ i)
         sum += i * histogram[i] ;  var sumB =  0 ;  var wB =  0 ;  var wF =  0 ;  var mB ;  var mF ;  var max =  0.0 ;  var between =  0.0 ;  var threshold1 =  0.0 ;  var threshold2 =  0.0 ;  for ( var i =  0 ; i <  256 ;  ++ i) { wB += histogram[i] ;  if (wB ==  0 ) continue ; wF = total - wB ;  if (wF ==  0 ) break ; sumB += i * histogram[i] ; mB = sumB / wB ; mF = (sum - sumB) / wF ; between = wB * wF * (mB - mF) * (mB - mF) ;  if ( between >= max ) { threshold1 = i ;  if ( between > max ) { threshold2 = i ;  } max = between ;  }  }  return ( threshold1 + threshold2 ) / 2.0 ;  }  For more please refer to this link #REDIRECT 1  References  External links   Lecture notes on thresholding - covers the Otsu method.  A plugin for ImageJ using Otsu's method to do the threshold.  A full explanation of Otsu's method with a working example and Java implementation.  Implementation of Otsu's method in ITK  Otsu Thresholding in C# A straightforward C# implementation with explanation.  Otsu's method using MATLAB   "  Category:Image segmentation     ↩  ↩  ↩   ↩    