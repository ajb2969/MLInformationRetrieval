<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="250">G.711</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>G.711</h1>
<hr>'''G.711''' is an [[ITU-T]] standard for audio [[companding]]. It is p

<p>rimarily used in <a class="uri" href="telephony" title="wikilink">telephony</a>. The standard was released for usage in 1972. Its formal name is <em>Pulse code modulation (<a href="Pulse-code_modulation" title="wikilink">PCM</a>) of voice frequencies</em>. It is a required standard in many technologies, for example in <a class="uri" href="H.320" title="wikilink">H.320</a> and <a class="uri" href="H.323" title="wikilink">H.323</a> specifications. It can also be used for <a class="uri" href="fax" title="wikilink">fax</a> communication over IP networks (as defined in <a class="uri" href="T.38" title="wikilink">T.38</a> specification). G.711, also known as Pulse Code Modulation (PCM), is a very commonly used waveform codec. G.711 is a <a class="uri" href="narrowband" title="wikilink">narrowband</a> audio codec that provides toll-quality audio at 64 kbit/s. G.711 passes audio signals in the range of 300–3400 Hz and samples them at the rate of 8,000 samples per second, with the tolerance on that rate 50 parts per million (ppm). Non-uniform (logarithmic) quantization with 8 bits is used to represent each sample, resulting in a 64 kbit/s bit rate. There are two slightly different versions; μ-law, which is used primarily in North America, and A-law, which is in use in most other countries outside North America.</p>

<p>Two enhancements to G.711 have been published: <strong>G.711.0</strong> utilizes <a href="lossless_data_compression" title="wikilink">lossless data compression</a> to reduce the bandwidth usage and <strong>G.711.1</strong> increases audio quality by increasing bandwidth.</p>
<h2 id="features">Features</h2>
<ul>
<li>Sampling frequency 8 kHz</li>
<li>64 kbit/s bitrate (8 kHz sampling frequency x 8 bits per sample)</li>
<li>Typical algorithmic delay is 0.125 ms, with no look-ahead delay</li>
<li>G.711 is a <a class="uri" href="waveform" title="wikilink">waveform</a> <a href="speech_coder" title="wikilink">speech coder</a></li>
<li>G.711 Appendix I defines a <a href="Packet_Loss_Concealment" title="wikilink">Packet Loss Concealment</a> (PLC) algorithm to help hide transmission losses in a packetized network</li>
<li>G.711 Appendix II defines a <a href="Discontinuous_Transmission" title="wikilink">Discontinuous Transmission</a> (DTX) algorithm which uses <a href="Voice_Activity_Detection" title="wikilink">Voice Activity Detection</a> (VAD) and <a href="Comfort_noise" title="wikilink">Comfort Noise Generation</a> (CNG) to reduce bandwidth usage during silence periods</li>
<li><a class="uri" href="PSQM" title="wikilink">PSQM</a> testing under ideal conditions yields <a href="Mean_Opinion_Score" title="wikilink">Mean Opinion Scores</a> of 4.45 for G.711 μ-law, 4.45 for G.711 A-law</li>
<li><a class="uri" href="PSQM" title="wikilink">PSQM</a> testing under network stress yields <a href="Mean_Opinion_Score" title="wikilink">Mean Opinion Scores</a> of 4.13 for G.711 μ-law, 4.11 for G.711 A-law</li>
</ul>
<h2 id="types">Types</h2>

<p>G.711 defines two main <a class="uri" href="companding" title="wikilink">companding</a> algorithms, the <a href="µ-law_algorithm" title="wikilink">µ-law algorithm</a> and <a href="A-law_algorithm" title="wikilink">A-law algorithm</a>. Both are <a href="logarithmic_scale" title="wikilink">logarithmic</a>, but A-law was specifically designed to be simpler for a computer to process. The standard also defines a sequence of repeating code values which defines the power level of 0 <a href="Decibel" title="wikilink">dB</a>.</p>

<p>The µ-law and A-law algorithms encode 14-bit and 13-bit signed linear PCM samples (respectively) to logarithmic 8-bit samples. Thus, the G.711 <a class="uri" href="encoder" title="wikilink">encoder</a> will create a 64 kbit/s bitstream for a signal sampled at 8 kHz.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>G.711 μ-law tends to give more resolution to higher range signals while G.711 A-law provides more quantization levels at lower signal levels.</p>
<h3 id="a-law">A-Law</h3>

<p>A-law encoding thus takes a 13-bit signed linear audio sample as input and converts it to an 8 bit value as follows:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>Linear input code<br/>
<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p></th>
<th style="text-align: left;">

<p>Compressed code<br/>
XOR 01010101</p></th>
<th style="text-align: left;">

<p>Linear output code<br/>
<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p><code>s0000000abcdx</code></p></td>
<td style="text-align: left;">

<p><code>
<math display="inline" id="G.711:0">
<semantics>
<mover accent="true">
<mi>s</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{s}
  </annotation>
</semantics>
</math>

000abcd</code></p></td>
<td style="text-align: left;">

<p><code>s0000000abcd1</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><code>s0000001abcdx</code></p></td>
<td style="text-align: left;">

<p><code>
<math display="inline" id="G.711:1">
<semantics>
<mover accent="true">
<mi>s</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{s}
  </annotation>
</semantics>
</math>

001abcd</code></p></td>
<td style="text-align: left;">

<p><code>s0000001abcd1</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><code>s000001abcdxx</code></p></td>
<td style="text-align: left;">

<p><code>
<math display="inline" id="G.711:2">
<semantics>
<mover accent="true">
<mi>s</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{s}
  </annotation>
</semantics>
</math>

010abcd</code></p></td>
<td style="text-align: left;">

<p><code>s000001abcd10</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><code>s00001abcdxxx</code></p></td>
<td style="text-align: left;">

<p><code>
<math display="inline" id="G.711:3">
<semantics>
<mover accent="true">
<mi>s</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{s}
  </annotation>
</semantics>
</math>

011abcd</code></p></td>
<td style="text-align: left;">

<p><code>s00001abcd100</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><code>s0001abcdxxxx</code></p></td>
<td style="text-align: left;">

<p><code>
<math display="inline" id="G.711:4">
<semantics>
<mover accent="true">
<mi>s</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{s}
  </annotation>
</semantics>
</math>

100abcd</code></p></td>
<td style="text-align: left;">

<p><code>s0001abcd1000</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><code>s001abcdxxxxx</code></p></td>
<td style="text-align: left;">

<p><code>
<math display="inline" id="G.711:5">
<semantics>
<mover accent="true">
<mi>s</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{s}
  </annotation>
</semantics>
</math>

101abcd</code></p></td>
<td style="text-align: left;">

<p><code>s001abcd10000</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><code>s01abcdxxxxxx</code></p></td>
<td style="text-align: left;">

<p><code>
<math display="inline" id="G.711:6">
<semantics>
<mover accent="true">
<mi>s</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{s}
  </annotation>
</semantics>
</math>

110abcd</code></p></td>
<td style="text-align: left;">

<p><code>s01abcd100000</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><code>s1abcdxxxxxxx</code></p></td>
<td style="text-align: left;">

<p><code>
<math display="inline" id="G.711:7">
<semantics>
<mover accent="true">
<mi>s</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{s}
  </annotation>
</semantics>
</math>

111abcd</code></p></td>
<td style="text-align: left;">

<p><code>s1abcd1000000</code></p></td>
</tr>
</tbody>
</table>
<references group="note/">

<p>Where  is the sign bit, <code>
<math display="inline" id="G.711:8">
<semantics>
<mover accent="true">
<mi>s</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{s}
  </annotation>
</semantics>
</math>
</code> is its inverse (i.e. positive values are encoded with <a href="most_significant_bit" title="wikilink">MSB</a> = 

<math display="inline" id="G.711:9">
<semantics>
<mover accent="true">
<mi>s</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{s}
  </annotation>
</semantics>
</math>

 = 1), and bits marked  are discarded. Note that the first column of the table uses different representation of negative values than the third column. So for example, input decimal value −21 is represented in binary after bit inversion as 1000000010100, which maps to 00001010 (according to the first row of the table). When decoding, this maps back to 1000000010101, which is interpreted as output value −21 in decimal. Input value +52 (0000000110100 in binary) maps to 10011010 (according to the second row), which maps back to 0000000110101 (+53 in decimal).</p>

<p>This can be seen as a <a href="floating_point" title="wikilink">floating point</a> number with 4 bits of <a href="Significand" title="wikilink">mantissa</a>
<math display="inline" id="G.711:10">
<semantics>
<mi>m</mi>
<annotation-xml encoding="MathML-Content">
<ci>m</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   m
  </annotation>
</semantics>
</math>

, 3 bits of <a class="uri" href="exponent" title="wikilink">exponent</a>
<math display="inline" id="G.711:11">
<semantics>
<mi>e</mi>
<annotation-xml encoding="MathML-Content">
<ci>e</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   e
  </annotation>
</semantics>
</math>

 and 1 sign bit 

<math display="inline" id="G.711:12">
<semantics>
<mi>s</mi>
<annotation-xml encoding="MathML-Content">
<ci>s</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   s
  </annotation>
</semantics>
</math>

 formatted as <code>
<math display="inline" id="G.711:13">
<semantics>
<mover accent="true">
<mi>s</mi>
<mo>¯</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-¯</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{s}
  </annotation>
</semantics>
</math>

eeemmmm</code> with the decoded linear value 

<math display="inline" id="G.711:14">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

 given by formula</p>

<p>
<math display="block" id="G.711:15">
<semantics>
<mrow>
<mrow>
<mi>y</mi>
<mo>=</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>s</mi>
</msup>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mn>16</mn>
<mo>⋅</mo>
<mrow>
<mi>min</mi>
<mrow>
<mo stretchy="false">{</mo>
<mi>e</mi>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
</mrow>
<mo>+</mo>
<mi>m</mi>
<mo>+</mo>
<mn>0.5</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<msup>
<mn>2</mn>
<mrow>
<mi>max</mi>
<mrow>
<mo stretchy="false">{</mo>
<mi>e</mi>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
</msup>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>y</ci>
<apply>
<ci>normal-⋅</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<ci>s</ci>
</apply>
<apply>
<plus></plus>
<apply>
<ci>normal-⋅</ci>
<cn type="integer">16</cn>
<apply>
<min></min>
<ci>e</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>m</ci>
<cn type="float">0.5</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<max></max>
<ci>e</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y=(-1)^{s}\cdot(16\cdot\min\{e,1\}+m+0.5)\cdot 2^{\max\{e,1\}},
  </annotation>
</semantics>
</math>

 which is a 13-bit signed integer in the range ±1 to ±(2

<math display="inline" id="G.711:16">
<semantics>
<msup>
<mi></mi>
<mn>12</mn>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<cn type="integer">12</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   {}^{12}
  </annotation>
</semantics>
</math>

 − 2

<math display="inline" id="G.711:17">
<semantics>
<msup>
<mi></mi>
<mn>6</mn>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<cn type="integer">6</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   {}^{6}
  </annotation>
</semantics>
</math>

). Note that no compressed code decodes to zero due to the addition of 0.5 (half of a quantization step).</p>

<p>In addition, the standard specifies that all resulting even bits (<a href="least_significant_bit" title="wikilink">LSB</a> is even) are inverted before the octet is transmitted. This is to provide plenty of 0/1 transitions to facilitate the <a href="clock_recovery" title="wikilink">clock recovery</a> process in the PCM receivers. Thus, a silent A-law encoded PCM channel has the 8 bit samples coded 0xD5 instead of 0x80 in the octets.</p>

<p>When data is sent over E0 (<a class="uri" href="G.703" title="wikilink">G.703</a>), MSB (sign) is sent first and LSB is sent last.</p>

<p>ITU-T STL<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> defines the algorithm for decoding as follows (it puts the decoded values in the 13 most significant bits of the 16-bit output data type).</p>
<pre><code>void            alaw_expand(lseg, logbuf, linbuf)
  long            lseg;
  short          *linbuf;
  short          *logbuf;
{
  short           ix, mant, iexp;
  long            n;

  for (n = 0; n &lt; lseg; n++)
  {
    ix = logbuf[n] ^ (0x0055);  /* re-toggle toggled bits */

    ix &amp;= (0x007F);     /* remove sign bit */
    iexp = ix &gt;&gt; 4;     /* extract exponent */
    mant = ix &amp; (0x000F);   /* now get mantissa */
    if (iexp &gt; 0)
      mant = mant + 16;     /* add leading '1', if exponent &gt; 0 */

    mant = (mant &lt;&lt; 4) + (0x0008);  /* now mantissa left justified and */
    /* 1/2 quantization step added */
    if (iexp &gt; 1)       /* now left shift according exponent */
      mant = mant &lt;&lt; (iexp - 1);

    linbuf[n] = logbuf[n] &gt; 127 /* invert, if negative sample */
      ? mant
      : -mant;
  }
}</code></pre>

<p>See also "ITU-T Software Tool Library 2009 User's manual" that can be found at.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="μ-law">μ-Law</h3>

<p>μ-law (sometimes referred to as ulaw, G.711Mu, or G.711μ) encoding takes a 14-bit signed linear audio sample in <a href="two's_complement" title="wikilink">two's complement</a> representation as input, inverts all bits after the sign bit if the value is negative, adds 33 (binary 100001) and converts it to an 8 bit value as follows:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>Linear input value<br/>
<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p></th>
<th style="text-align: left;">

<p>Compressed code<br/>
XOR 11111111</p></th>
<th style="text-align: left;">

<p>Linear output value<br/>
<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p><code>s00000001abcdx</code></p></td>
<td style="text-align: left;">

<p><code>s000abcd</code></p></td>
<td style="text-align: left;">

<p><code>s00000001abcd1</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><code>s0000001abcdxx</code></p></td>
<td style="text-align: left;">

<p><code>s001abcd</code></p></td>
<td style="text-align: left;">

<p><code>s0000001abcd10</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><code>s000001abcdxxx</code></p></td>
<td style="text-align: left;">

<p><code>s010abcd</code></p></td>
<td style="text-align: left;">

<p><code>s000001abcd100</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><code>s00001abcdxxxx</code></p></td>
<td style="text-align: left;">

<p><code>s011abcd</code></p></td>
<td style="text-align: left;">

<p><code>s00001abcd1000</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><code>s0001abcdxxxxx</code></p></td>
<td style="text-align: left;">

<p><code>s100abcd</code></p></td>
<td style="text-align: left;">

<p><code>s0001abcd10000</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><code>s001abcdxxxxxx</code></p></td>
<td style="text-align: left;">

<p><code>s101abcd</code></p></td>
<td style="text-align: left;">

<p><code>s001abcd100000</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><code>s01abcdxxxxxxx</code></p></td>
<td style="text-align: left;">

<p><code>s110abcd</code></p></td>
<td style="text-align: left;">

<p><code>s01abcd1000000</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><code>s1abcdxxxxxxxx</code></p></td>
<td style="text-align: left;">

<p><code>s111abcd</code></p></td>
<td style="text-align: left;">

<p><code>s1abcd10000000</code></p></td>
</tr>
</tbody>
</table>
<references group="note/">

<p>Where  is the sign bit, and bits marked  are discarded.</p>

<p>In addition, the standard specifies that all result bits are inverted before the octet is transmitted. Thus, a silent μ-law encoded PCM channel has the 8 bit samples coded 0xFF instead of 0x00 in the octets.</p>

<p>Adding 33 is necessary so that all values fall into a compression group and it is subtracted back when decoding. This addition means that an overflow would occur for values outside the ±8159 range, so such values are clipped during encoding to avoid it.</p>

<p>Breaking the encoded value formatted as <code>seeemmmm</code> into 4 bits of mantissa 

<math display="inline" id="G.711:18">
<semantics>
<mi>m</mi>
<annotation-xml encoding="MathML-Content">
<ci>m</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   m
  </annotation>
</semantics>
</math>

, 3 bits of exponent 

<math display="inline" id="G.711:19">
<semantics>
<mi>e</mi>
<annotation-xml encoding="MathML-Content">
<ci>e</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   e
  </annotation>
</semantics>
</math>

 and 1 sign bit 

<math display="inline" id="G.711:20">
<semantics>
<mi>s</mi>
<annotation-xml encoding="MathML-Content">
<ci>s</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   s
  </annotation>
</semantics>
</math>

, the decoded linear value 

<math display="inline" id="G.711:21">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

 is given by formula</p>

<p>
<math display="block" id="G.711:22">
<semantics>
<mrow>
<mrow>
<mi>y</mi>
<mo>=</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>s</mi>
</msup>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>16.5</mn>
<mo>+</mo>
<mi>m</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<msup>
<mn>2</mn>
<mrow>
<mi>e</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
<mo>-</mo>
<mn>33</mn>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>y</ci>
<apply>
<ci>normal-⋅</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<minus></minus>
<apply>
<ci>normal-⋅</ci>
<apply>
<plus></plus>
<cn type="float">16.5</cn>
<ci>m</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<plus></plus>
<ci>e</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<cn type="integer">33</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y=(-1)^{s}\cdot[(16.5+m)\cdot 2^{e+1}-33],
  </annotation>
</semantics>
</math>

 which is a 14-bit signed integer in the range ±0 to ±8031.</p>

<p>Note that 0 is encoded as 0xFF, and −1 is encoded as 0x7F, but when decoded back the result is 0 in both cases.</p>
<h2 id="g.711.0">G.711.0</h2>

<p>G.711.0, also known as G.711 LLC, utilizes <a href="lossless_data_compression" title="wikilink">lossless data compression</a> to reduce the bandwidth usage by as much as 50 percent.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The <em>Lossless compression of G.711 pulse code modulation</em> standard was approved by ITU-T in September 2009.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="g.711.1">G.711.1</h2>

<p>G.711.1 is an extension to G.711, published as ITU-T Recommendation G.711.1 in March 2008. Its formal name is <em>Wideband embedded extension for G.711 pulse code modulation</em>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>G.711.1, allows the addition of <a class="uri" href="narrowband" title="wikilink">narrowband</a> and/or <a class="uri" href="wideband" title="wikilink">wideband</a> (16000 samples/s) enhancements, each at 25% of the bitrate of the (included) base G.711 bitstream, leading to data rates of 64, 80 or 96 kbit/s.</p>

<p>G.711.1 is compatible with G.711 at 64 kbit/s,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> hence an efficient deployment in existing G.711-based voice over IP (<a class="uri" href="VoIP" title="wikilink">VoIP</a>) infrastructures is foreseen. The G.711.1 coder can encode signals at 16 kHz with a bandwidth of 50–7000 Hz at 80 and 96 kbit/s, and for 8-kHz sampling the output may produce signals with a bandwidth ranging from 50 up to 4000 Hz, operating at 64 and 80 kbit/s.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>The G.711.1 encoder creates an embedded bitstream structured in three layers corresponding to three available bit rates: 64, 80 and 96 kbit/s. The bitstream does not contain any information on which layers are contained, an implementation would require outband signalling on which layers are available. The three G.711.1 layers are: log companded pulse code modulation (PCM) of the lower band including noise feedback, embedded PCM extension with adaptive bit allocation for enhancing the quality of the base layer in the lower band, and weighted vector quantization coding of the higher band based on <a href="modified_discrete_cosine_transform" title="wikilink">modified discrete cosine transformation</a> (MDCT).<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Two extensions for G.711.1 are planned in 2010: superwideband extension (bandwidth to 14000 Hz) and lossless bitstream compression.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="licensing">Licensing</h2>

<p>Since G.711 was released in 1972 its patents have long since expired, so it is freely available.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="List_of_codecs" title="wikilink">List of codecs</a></li>
<li><a href="Comparison_of_audio_coding_formats" title="wikilink">Comparison of audio coding formats</a></li>
<li><a href="RTP_audio_video_profile" title="wikilink">RTP audio video profile</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li>[<a class="uri" href="http://www.itu.int/rec/dologin_pub.asp?lang=e&amp;id">http://www.itu.int/rec/dologin_pub.asp?lang=e&amp;id;</a>;=T-REC-G.711-198811-I!!PDF-E&amp;type;=items ITU-T Recommendation G.711] - (STD.ITU-T RECMN G.711-ENGL 1989)</li>
<li>[<a class="uri" href="http://www.itu.int/rec/recommendation.asp?type=folders">http://www.itu.int/rec/recommendation.asp?type=folders</a>〈=e&amp;parent;=T-REC-G.711 ITU-T G.711 page]</li>
<li><a href="http://www.itu.int/rec/T-REC-G.191/en">ITU-T G.191 software tools for speech and audio coding, including G.711 C code</a></li>
<li><a href="http://www.codeproject.com/csharp/g711audio.asp">Code Project C# implementation of G.711 with source code</a></li>
<li><a href="http://tools.ietf.org/html/rfc3551#page-28">RFC 3551 - RTP Profile for Audio and Video Conferences with Minimal Control</a> - G.711 - PCMA and PCMU definition.</li>
<li><a href="http://tools.ietf.org/html/rfc4856#page-21">RFC 4856 - Registration of Media Type audio/PCMA and audio/PCMU</a></li>
<li>RFC 5391 - RTP Payload Format for ITU-T Recommendation G.711.1 (PCMA-WB and PCMU-WB)</li>
</ul>

<p>"</p>
</references>

<p></p>
</references>

<p></p>

<p><a href="Category:Audio_codecs" title="wikilink">Category:Audio codecs</a> <a href="Category:Speech_codecs" title="wikilink">Category:Speech codecs</a> <a href="Category:ITU-T_recommendations" title="wikilink">Category:ITU-T recommendations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.itu.int/rec/T-REC-G.711/">G.711 : Pulse code modulation (PCM) of voice frequencies; ITU-T Recommendation (11/1988)</a>, Retrieved on 2009-07-08<a href="#fnref1">↩</a></li>
<li id="fn2">This value is produced by taking the <a href="two's_complement" title="wikilink">two's complement</a> representation of the input value, and inverting all bits after the sign bit if the value is negative.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="Signed_magnitude" title="wikilink">Signed magnitude</a> representation<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://www.itu.int/rec/T-REC-G.191-201003-I/en">G.191 : Software tools for speech and audio coding standardization</a>. Function  in file . Itu.int. Retrieved on 2013-09-18.<a href="#fnref4">↩</a></li>
<li id="fn5">[<a class="uri" href="http://www.itu.int/rec/T-REC-G.191/recommendation.asp?lang=en&amp;parent">http://www.itu.int/rec/T-REC-G.191/recommendation.asp?lang=en&amp;parent;</a>;=T-REC-G.191-200911-I G.191 : ITU-T Software Tool Library 2009 User's manual]. Itu.int (2010-07-23). Retrieved on 2013-09-18.<a href="#fnref5">↩</a></li>
<li id="fn6">This value is produced by taking the <a href="two's_complement" title="wikilink">two's complement</a> representation of the input value, inverting all bits after the sign bit if the value is negative, and adding 33.<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="Signed_magnitude" title="wikilink">Signed magnitude</a> representation. Final result is produced by decreasing the magnitude of this value by 33.<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12">ITU-T (2008) <a href="http://www.itu.int/rec/T-REC-G.711.1/en">G.711.1 : Wideband embedded extension for G.711 pulse code modulation</a> Retrieved on 2009-06-19<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
</ol>
</section>
</hr></body>
</html>
