<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1910">Calculus of constructions</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Calculus of constructions</h1>
<hr/>

<p>The <strong>Calculus of Constructions</strong> (<strong>CoC</strong>) is a <a href="type_theory" title="wikilink">type theory</a> created by <a href="Thierry_Coquand" title="wikilink">Thierry Coquand</a>. It can serve as both a typed programming language and as <a href="Constructivism_(mathematics)" title="wikilink">constructive</a> <a href="Foundations_of_mathematics" title="wikilink">foundation for mathematics</a>. For this second reason, the CoC and its variants have been the basis for <a class="uri" href="Coq" title="wikilink">Coq</a> and other <a href="proof_assistant" title="wikilink">proof assistants</a>.</p>

<p>Some of its variants include the <a href="calculus_of_inductive_constructions" title="wikilink">calculus of inductive constructions</a> (which adds <a href="Intuitionistic_type_theory#Inductive_types" title="wikilink">inductive types</a>), the calculus of (co)inductive constructions (which adds <a class="uri" href="coinduction" title="wikilink">coinduction</a>), and the predicative calculus of inductive constructions (which removes some <a class="uri" href="impredicativity" title="wikilink">impredicativity</a>).</p>
<h2 id="general-traits">General traits</h2>

<p>The CoC is a higher-order <a href="typed_lambda_calculus" title="wikilink">typed lambda calculus</a>, initially developed by <a href="Thierry_Coquand" title="wikilink">Thierry Coquand</a>. It is well known for being at the top of <a href="Henk_Barendregt" title="wikilink">Barendregt</a>'s <a href="lambda_cube" title="wikilink">lambda cube</a>. It is possible within CoC to define functions from, say, integers to types, types to types as well as functions from integers to integers.</p>

<p>The CoC is <a href="normalization_property_(lambda-calculus)" title="wikilink">strongly normalizing</a>, although, by <a href="Gödel's_incompleteness_theorem" title="wikilink">Gödel's incompleteness theorem</a>, it is impossible to prove this property within the CoC since it implies inconsistency.</p>
<h2 id="usage">Usage</h2>

<p>The CoC has developed alongside the <a class="uri" href="Coq" title="wikilink">Coq</a> <a href="proof_assistant" title="wikilink">proof assistant</a>. As features were added (or possible liabilities removed) to the theory, they became available in Coq.</p>

<p>Variants of the CoC are used in other proof assistants, such as <a class="uri" href="Matita" title="wikilink">Matita</a>.</p>
<h2 id="the-basics-of-the-calculus-of-constructions">The basics of the calculus of constructions</h2>

<p>The Calculus of Constructions can be considered an extension of the <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a>. The Curry–Howard isomorphism associates a term in the <a href="Typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a> with each natural-deduction proof in <a href="intuitionistic_logic" title="wikilink">intuitionistic propositional logic</a>. The Calculus of Constructions extends this isomorphism to proofs in the full intuitionistic predicate calculus, which includes proofs of quantified statements (which we will also call "propositions").</p>
<h3 id="terms">Terms</h3>

<p>A <em>term</em> in the calculus of constructions is constructed using the following rules:</p>
<ul>
<li><strong>T</strong> is a term (also called <em>Type</em>)</li>
<li><strong>P</strong> is a term (also called <em>Prop</em>, the type of all propositions)</li>
<li>Variables (<em>x</em>, <em>y</em>, ...) are terms</li>
<li>If 

<math display="inline" id="Calculus_of_constructions:0">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Calculus_of_constructions:1">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 are terms, then so are
<ul>
<li>

<math display="inline" id="Calculus_of_constructions:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>A</mi>
    </mpadded>
    <mi>B</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A~{}B)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Calculus_of_constructions:3">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>:</mo>
   <mi>A</mi>
   <mo>.</mo>
   <mi>B</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">B</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{\lambda}x:A.B)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Calculus_of_constructions:4">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>:</mo>
   <mi>A</mi>
   <mo>.</mo>
   <mi>B</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">B</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x:A.B)
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
</ul>

<p>The calculus of constructions has five kinds of objects:</p>
<ol>
<li><em>proofs</em>, which are terms whose types are <em>propositions</em></li>
<li><em>propositions</em>, which are also known as <em>small types</em></li>
<li><em>predicates</em>, which are functions that return propositions</li>
<li><em>large types</em>, which are the types of predicates. (<strong>P</strong> is an example of a large type)</li>
<li><strong>T</strong> itself, which is the type of large types.</li>
</ol>
<h3 id="judgments">Judgments</h3>

<p>The calculus of constructions allows proving <strong>typing judgments</strong>:</p>

<p>

<math display="block" id="Calculus_of_constructions:5">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
   <mo>⊢</mo>
   <mi>t</mi>
   <mo>:</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </list>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <share href="#.cmml">
     </share>
     <ci>t</ci>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}:A_{1},x_{2}:A_{2},\ldots\vdash t:B
  </annotation>
 </semantics>
</math>

</p>

<p>Which can be read as the implication</p>
<dl>
<dd>If variables 

<math display="inline" id="Calculus_of_constructions:6">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},x_{2},\ldots
  </annotation>
 </semantics>
</math>

 have types 

<math display="inline" id="Calculus_of_constructions:7">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>A</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1},A_{2},\ldots
  </annotation>
 </semantics>
</math>

, then term 

<math display="inline" id="Calculus_of_constructions:8">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Calculus_of_constructions:9">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>The valid judgments for the calculus of constructions are derivable from a set of inference rules. In the following, we use 

<math display="inline" id="Calculus_of_constructions:10">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 to mean a sequence of type assignments 

<math display="inline" id="Calculus_of_constructions:11">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </list>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}:A_{1},x_{2}:A_{2},\ldots
  </annotation>
 </semantics>
</math>

, and we use <strong>K</strong> to mean either <strong>P</strong> or <strong>T</strong>. We shall write 

<math display="inline" id="Calculus_of_constructions:12">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>:</mo>
   <mi>B</mi>
   <mo>:</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A:B:C
  </annotation>
 </semantics>
</math>

 to mean "

<math display="inline" id="Calculus_of_constructions:13">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Calculus_of_constructions:14">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Calculus_of_constructions:15">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Calculus_of_constructions:16">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

". We shall write 

<math display="inline" id="Calculus_of_constructions:17">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">B</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(x:=N)
  </annotation>
 </semantics>
</math>

 to mean the result of substituting the term 

<math display="inline" id="Calculus_of_constructions:18">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 for the variable 

<math display="inline" id="Calculus_of_constructions:19">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in the term 

<math display="inline" id="Calculus_of_constructions:20">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

.</p>

<p>An inference rule is written in the form</p>

<p>

<math display="block" id="Calculus_of_constructions:21">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mi>A</mi>
    <mo>:</mo>
    <mi>B</mi>
   </mrow>
   <mrow>
    <msup>
     <mi mathvariant="normal">Γ</mi>
     <mo>′</mo>
    </msup>
    <mo>⊢</mo>
    <mi>C</mi>
    <mo>:</mo>
    <mi>D</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Γ</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>C</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Gamma\vdash A:B}\over{\Gamma^{\prime}\vdash C:D}
  </annotation>
 </semantics>
</math>

</p>

<p>which means</p>
<dl>
<dd>If 

<math display="inline" id="Calculus_of_constructions:22">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mi>A</mi>
   <mo>:</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash A:B
  </annotation>
 </semantics>
</math>

 is a valid judgment, then so is 

<math display="inline" id="Calculus_of_constructions:23">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Γ</mi>
    <mo>′</mo>
   </msup>
   <mo>⊢</mo>
   <mi>C</mi>
   <mo>:</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Γ</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>C</ci>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma^{\prime}\vdash C:D
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<h3 id="inference-rules-for-the-calculus-of-constructions">Inference rules for the calculus of constructions</h3>

<p><strong>1</strong>. 

<math display="inline" id="Calculus_of_constructions:24">
 <semantics>
  <mfrac>
   <mi></mi>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mi>P</mi>
    <mo>:</mo>
    <mi>T</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <ci>P</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{}\over{}\Gamma\vdash P:T}
  </annotation>
 </semantics>
</math>

</p>

<p><strong>2</strong>. 

<math display="inline" id="Calculus_of_constructions:25">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mi>A</mi>
    <mo>:</mo>
    <mi>K</mi>
   </mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <mo>,</mo>
     <mi>x</mi>
    </mrow>
    <mo>:</mo>
    <mi>A</mi>
    <mo>⊢</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mi>A</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <ci>K</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-:</ci>
      <list>
       <ci>normal-Γ</ci>
       <ci>x</ci>
      </list>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <share href="#.cmml">
      </share>
      <ci>x</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Gamma\vdash A:K\over{\Gamma,x:A\vdash x:A}}
  </annotation>
 </semantics>
</math>

</p>

<p><strong>3</strong>. 

<math display="inline" id="Calculus_of_constructions:26">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <mo>,</mo>
     <mi>x</mi>
    </mrow>
    <mo>:</mo>
    <mi>A</mi>
    <mo>⊢</mo>
    <mi>t</mi>
    <mo>:</mo>
    <mi>B</mi>
    <mo>:</mo>
    <mi>K</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>:</mo>
     <mi>A</mi>
     <mo>.</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mi>A</mi>
     <mo>.</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <mi>K</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <and></and>
     <apply>
      <ci>normal-:</ci>
      <list>
       <ci>normal-Γ</ci>
       <ci>x</ci>
      </list>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <share href="#.cmml">
      </share>
      <ci>t</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <ci>B</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <ci>K</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Γ</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-:</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-:</ci>
     <csymbol cd="unknown">K</csymbol>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Gamma,x:A\vdash t:B:K\over{\Gamma\vdash(\lambda x:A.t):(\forall x:A.B):K}}
  </annotation>
 </semantics>
</math>

</p>

<p><strong>4</strong>. 

<math display="inline" id="Calculus_of_constructions:27">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mi>M</mi>
    <mo>:</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mi>A</mi>
     <mo>.</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mi>N</mi>
    <mo>:</mo>
    <mi>A</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mi>M</mi>
    <mi>N</mi>
    <mo>:</mo>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>:=</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Γ</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-:</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>italic-</ci>
     <csymbol cd="unknown">Γ</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">A</csymbol>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Γ</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <csymbol cd="unknown">M</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">B</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Gamma\vdash M:(\forall x:A.B)\qquad\qquad\Gamma\vdash N:A\over{\Gamma\vdash
MN%
:B(x:=N)}}
  </annotation>
 </semantics>
</math>

</p>

<p><strong>5</strong>. 

<math display="inline" id="Calculus_of_constructions:28">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mi>M</mi>
    <mo>:</mo>
    <mi>A</mi>
    <mi>A</mi>
    <msub>
     <mo>=</mo>
     <mi>β</mi>
    </msub>
    <mi>B</mi>
    <mi>B</mi>
    <mo>:</mo>
    <mi>K</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mi>M</mi>
    <mo>:</mo>
    <mi>B</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Γ</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>italic-</ci>
     <csymbol cd="unknown">A</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <eq></eq>
      <ci>β</ci>
     </apply>
     <csymbol cd="unknown">B</csymbol>
     <ci>italic-</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">K</csymbol>
    </cerror>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\Gamma\vdash M:A\qquad\qquad A=_{\beta}B\qquad\qquad B:K\over{\Gamma\vdash M:%
B}}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="defining-logical-operators">Defining logical operators</h3>

<p>The calculus of constructions has very few basic operators: the only logical operator for forming propositions is 

<math display="inline" id="Calculus_of_constructions:29">
 <semantics>
  <mo>∀</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall
  </annotation>
 </semantics>
</math>

. However, this one operator is sufficient to define all the other logical operators:</p>

<p>

<math display="block" id="Calculus_of_constructions:30">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mi>A</mi>
      <mo>⇒</mo>
      <mi>B</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>≡</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
      <mo>:</mo>
      <mi>A</mi>
      <mo>.</mo>
      <mi>B</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>∉</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mi>A</mi>
      <mo>∧</mo>
      <mi>B</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>≡</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo>∀</mo>
      <mi>C</mi>
      <mo>:</mo>
      <mi>P</mi>
      <mo>.</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>⇒</mo>
       <mi>B</mi>
       <mo>⇒</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>⇒</mo>
      <mi>C</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mi>A</mi>
      <mo>∨</mo>
      <mi>B</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>≡</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo>∀</mo>
      <mi>C</mi>
      <mo>:</mo>
      <mi>P</mi>
      <mo>.</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>⇒</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>⇒</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo>⇒</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>⇒</mo>
      <mi>C</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>A</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>≡</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo>∀</mo>
      <mi>C</mi>
      <mo>:</mo>
      <mi>P</mi>
      <mo>.</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>⇒</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mo>∃</mo>
      <mi>x</mi>
      <mo>:</mo>
      <mi>A</mi>
      <mo>.</mo>
      <mi>B</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>≡</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo>∀</mo>
      <mi>C</mi>
      <mo>:</mo>
      <mi>P</mi>
      <mo>.</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>∀</mo>
       <mi>x</mi>
       <mo>:</mo>
       <mi>A</mi>
       <mo>.</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>⇒</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>⇒</mo>
      <mi>C</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <ci>normal-⇒</ci>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <equivalent></equivalent>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">B</csymbol>
     </cerror>
     <apply>
      <notin></notin>
      <ci>x</ci>
      <ci>B</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <and></and>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <equivalent></equivalent>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-⇒</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-⇒</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⇒</ci>
      <csymbol cd="unknown">C</csymbol>
     </cerror>
     <csymbol cd="latexml">absent</csymbol>
    </matrixrow>
    <matrixrow>
     <apply>
      <or></or>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <equivalent></equivalent>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-⇒</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⇒</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-⇒</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⇒</ci>
      <csymbol cd="unknown">C</csymbol>
     </cerror>
     <csymbol cd="latexml">absent</csymbol>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
     </apply>
     <equivalent></equivalent>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-⇒</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <csymbol cd="latexml">absent</csymbol>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <exists></exists>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">B</csymbol>
     </cerror>
     <equivalent></equivalent>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-:</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-.</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">B</csymbol>
        <ci>normal-⇒</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⇒</ci>
      <csymbol cd="unknown">C</csymbol>
     </cerror>
     <csymbol cd="latexml">absent</csymbol>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}A\Rightarrow B&\equiv&\forall x:A.B&(x\notin B)\\
A\wedge B&\equiv&\forall C:P.(A\Rightarrow B\Rightarrow C)\Rightarrow C&\\
A\vee B&\equiv&\forall C:P.(A\Rightarrow C)\Rightarrow(B\Rightarrow C)%
\Rightarrow C&\\
\neg A&\equiv&\forall C:P.(A\Rightarrow C)&\\
\exists x:A.B&\equiv&\forall C:P.(\forall x:A.(B\Rightarrow C))\Rightarrow C&%
\end{matrix}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="defining-data-types">Defining data types</h3>

<p>The basic data types used in computer science can be defined within the Calculus of Constructions:</p>
<dl>
<dt>Booleans 

<math display="block" id="Calculus_of_constructions:31">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>A</mi>
   <mo>:</mo>
   <mi>P</mi>
   <mo>.</mo>
   <mi>A</mi>
   <mo>⇒</mo>
   <mi>A</mi>
   <mo>⇒</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A:P.A\Rightarrow A\Rightarrow A
  </annotation>
 </semantics>
</math>

<br/>
Naturals :<math>\forall A:P .</math></dt>
</dl>

<p>(A \Rightarrow A) \Rightarrow (A \Rightarrow A)</p>
<dl>
<dt>Product 

<math display="inline" id="Calculus_of_constructions:32">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>×</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\times B
  </annotation>
 </semantics>
</math>

 

<math display="block" id="Calculus_of_constructions:33">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∧</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\wedge B
  </annotation>
 </semantics>
</math>

<br/>
Disjoint union 

<math display="inline" id="Calculus_of_constructions:34">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>+</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A+B
  </annotation>
 </semantics>
</math>

 

<math display="block" id="Calculus_of_constructions:35">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∨</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\vee B
  </annotation>
 </semantics>
</math>

</dt>
</dl>

<p>Note that Booleans and Naturals are defined in the same way as in <a href="Church_encoding" title="wikilink">Church encoding</a>. However additional problems raise from propositional extensionality and proof irrelevance <a href="http://coq.inria.fr/stdlib/Coq.Logic.ClassicalFacts.html">1</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lambda_calculus" title="wikilink">Lambda calculus</a></li>
<li><a href="Typed_lambda_calculus" title="wikilink">Typed lambda calculus</a></li>
<li><a href="Lambda_cube" title="wikilink">Lambda cube</a></li>
<li><a href="System_F" title="wikilink">System F</a></li>
<li><a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a></li>
<li><a href="Intuitionistic_logic" title="wikilink">Intuitionistic logic</a></li>
<li><a href="Intuitionistic_type_theory" title="wikilink">Intuitionistic type theory</a></li>
<li><a href="Homotopy_type_theory" title="wikilink">Homotopy type theory</a></li>
</ul>
<h3 id="theorists">Theorists</h3>
<ul>
<li><a href="Thierry_Coquand" title="wikilink">Coquand, Thierry</a></li>
<li><a href="Jean-Yves_Girard" title="wikilink">Girard, Jean-Yves</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>Also available freely accessible online:  Note terminology is rather different. For instance, (

<math display="inline" id="Calculus_of_constructions:36">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>:</mo>
   <mi>A</mi>
   <mo>.</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">B</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x:A.B
  </annotation>
 </semantics>
</math>

) is written [<em>x</em> : <em>A</em>] <em>B</em>.</li>
<li></li>
<li></li>
<li>

<p>— An application of the CoC</p></li>
</ul>

<p>"</p>

<p><a href="Category:Dependently_typed_programming" title="wikilink">Category:Dependently typed programming</a> <a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a></p>
</body>
</html>
