<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="302">Pseudoforest</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Pseudoforest</h1>
<hr/>

<p><a href="File:Pseudoforest.svg" title="wikilink">thumb|upright=1.2|A 1-forest (a maximal pseudoforest), formed by three 1-trees</a> In <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>pseudoforest</strong> is an <a href="undirected_graph" title="wikilink">undirected graph</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in which every <a href="Connected_component_(graph_theory)" title="wikilink">connected component</a> has at most one <a href="Cycle_(graph_theory)" title="wikilink">cycle</a>. That is, it is a system of <a href="Vertex_(graph_theory)" title="wikilink">vertices</a> and <a href="Edge_(graph_theory)" title="wikilink">edges</a> connecting pairs of vertices, such that no two cycles of consecutive edges share any vertex with each other, nor can any two cycles be connected to each other by a path of consecutive edges. A <strong>pseudotree</strong> is a connected pseudoforest.</p>

<p>The names are justified by analogy to the more commonly studied <a href="Tree_(graph_theory)" title="wikilink">trees</a> and <a href="Forest_(graph_theory)" title="wikilink">forests</a>. (A tree is a connected graph with no cycles; a forest is a disjoint union of trees.) Gabow and Tarjan<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> attribute the study of pseudoforests to Dantzig's 1963 book on <a href="linear_programming" title="wikilink">linear programming</a>, in which pseudoforests arise in the solution of certain <a href="Flow_network" title="wikilink">network flow</a> problems.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Pseudoforests also form graph-theoretic models of functions and occur in several <a href="algorithm" title="wikilink">algorithmic</a> problems. Pseudoforests are <a href="sparse_graph" title="wikilink">sparse graphs</a> – they have very few edges relative to their number of vertices – and their <a class="uri" href="matroid" title="wikilink">matroid</a> structure allows several other families of sparse graphs to be decomposed as unions of forests and pseudoforests. The name "pseudoforest" comes from .</p>
<h2 id="definitions-and-structure">Definitions and structure</h2>

<p>We define an undirected graph to be a set of <a href="vertex_(graph_theory)" title="wikilink">vertices</a> and <a href="edge_(graph_theory)" title="wikilink">edges</a> such that each edge has two vertices (which may coincide) as endpoints. That is, we allow multiple edges (edges with the same pair of endpoints) and loops (edges whose two endpoints are the same vertex).<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">subgraph</a> of a graph is the graph formed by any subsets of its vertices and edges such that each edge in the edge subset has both endpoints in the vertex subset. A <a href="connected_component_(graph_theory)" title="wikilink">connected component</a> of an undirected graph is the subgraph consisting of the vertices and edges that can be reached by following edges from a single given starting vertex. A graph is connected if every vertex or edge is reachable from every other vertex or edge. A <a href="cycle_(graph_theory)" title="wikilink">cycle</a> in an undirected graph is a connected subgraph in which each vertex is incident to exactly two edges, or is a loop.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p> A pseudoforest is an undirected graph in which each connected component contains at most one cycle.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Equivalently, it is an undirected graph in which each connected component has no more edges than vertices.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The components that have no cycles are just <a href="tree_(graph_theory)" title="wikilink">trees</a>, while the components that have a single cycle within them are called <strong>1-trees</strong> or <strong>unicyclic graphs</strong>. That is, a 1-tree is a connected graph containing exactly one cycle. A pseudoforest with a single connected component (usually called a <strong>pseudotree</strong>, although some authors define a pseudotree to be a 1-tree) is either a tree or a 1-tree; in general a pseudoforest may have multiple connected components as long as all of them are trees or 1-trees.</p>

<p>If one removes from a 1-tree one of the edges in its cycle, the result is a tree. Reversing this process, if one augments a tree by connecting any two of its vertices by a new edge, the result is a 1-tree; the path in the tree connecting the two endpoints of the added edge, together with the added edge itself, form the 1-tree's unique cycle. If one augments a 1-tree by adding an edge that connects one of its vertices to a newly added vertex, the result is again a 1-tree, with one more vertex; an alternative method for constructing 1-trees is to start with a single cycle and then repeat this augmentation operation any number of times. The edges of any 1-tree can be partitioned in a unique way into two subgraphs, one of which is a cycle and the other of which is a forest, such that each tree of the forest contains exactly one vertex of the cycle.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Certain more specific types of pseudoforests have also been studied.</p>
<dl>
<dd>A <strong>1-forest</strong>, sometimes called a <strong>maximal pseudoforest</strong>, is a pseudoforest to which no more edges can be added without causing some component of the graph to contain multiple cycles. If a pseudoforest contains a tree as one of its components, it cannot be a 1-forest, for one can add either an edge connecting two vertices within that tree, forming a single cycle, or an edge connecting that tree to some other component. Thus, the 1-forests are exactly the pseudoforests in which every component is a 1-tree.
</dd>
</dl>
<dl>
<dd>The <strong>spanning pseudoforests</strong> of an undirected graph <em>G</em> are the pseudoforest <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">subgraphs</a> of <em>G</em> that have all the vertices of <em>G</em>. Such a pseudoforest need not have any edges, since for example the subgraph that has all the vertices of <em>G</em> and no edges is a pseudoforest (whose components are trees consisting of a single vertex).
</dd>
</dl>
<dl>
<dd>The <strong>maximal pseudoforests of</strong> <em>G</em> are the pseudoforest subgraphs of <em>G</em> that are not contained within any larger pseudoforest of <em>G</em>. A maximal pseudoforest of <em>G</em> is always a spanning pseudoforest, but not conversely. If <em>G</em> has no connected components that are trees, then its maximal pseudoforests are 1-forests, but if <em>G</em> does have a tree component, its maximal pseudoforests are not 1-forests. Stated precisely, in any graph <em>G</em> its maximal pseudoforests consist of every tree component of <em>G</em>, together with one or more disjoint 1-trees covering the remaining vertices of <em>G</em>.
</dd>
</dl>
<h2 id="directed-pseudoforests">Directed pseudoforests</h2>

<p>Versions of these definitions are also used for <a href="directed_graph" title="wikilink">directed graphs</a>. Like an undirected graph, a directed graph consists of vertices and edges, but each edge is directed from one of its endpoints to the other endpoint. A <strong>directed pseudoforest</strong> is a directed graph in which each vertex has at most one outgoing edge; that is, it has <a class="uri" href="outdegree" title="wikilink">outdegree</a> at most one. A <strong>directed 1-forest</strong> – most commonly called a <strong>functional graph</strong> (see <a href="#Graphs_of_functions" title="wikilink">below</a>), sometimes <strong>maximal directed pseudoforest</strong> – is a directed graph in which each vertex has outdegree exactly one.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> If <em>D</em> is a directed pseudoforest, the undirected graph formed by removing the direction from each edge of <em>D</em> is an undirected pseudoforest.</p>
<h2 id="number-of-edges">Number of edges</h2>

<p>Every pseudoforest on a set of <em>n</em> vertices has at most <em>n</em> edges, and every maximal pseudoforest on a set of <em>n</em> vertices has exactly <em>n</em> edges. Conversely, if a graph <em>G</em> has the property that, for every subset <em>S</em> of its vertices, the number of edges in the <a href="induced_subgraph" title="wikilink">induced subgraph</a> of <em>S</em> is at most the number of vertices in <em>S</em>, then <em>G</em> is a pseudoforest. 1-trees can be defined as connected graphs with equally many vertices and edges.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>Moving from individual graphs to graph families, if a family of graphs has the property that every subgraph of a graph in the family is also in the family, and every graph in the family has at most as many edges as vertices, then the family contains only pseudoforests. For instance, every subgraph of a <a class="uri" href="thrackle" title="wikilink">thrackle</a> (a graph <a href="graph_drawing" title="wikilink">drawn</a> so that every pair of edges has one point of intersection) is also a thrackle, so <a href="Conway's_thrackle_conjecture" title="wikilink">Conway's conjecture</a> that every thrackle has at most as many edges as vertices can be restated as saying that every thrackle is a pseudoforest. A more precise characterization is that, if the conjecture is true, then the thrackles are exactly the pseudoforests with no four-vertex cycle and at most one odd cycle.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>Streinu and Theran<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> generalize the <a href="sparse_graph" title="wikilink">sparsity</a> conditions defining pseudoforests: they define a graph as being (<em>k</em>,<em>l</em>)-sparse if every nonempty subgraph with <em>n</em> vertices has at most <em>kn</em> − <em>l</em> edges, and (<em>k</em>,<em>l</em>)-tight if it is (<em>k</em>,<em>l</em>)-sparse and has exactly <em>kn</em> − <em>l</em> edges. Thus, the pseudoforests are the (1,0)-sparse graphs, and the maximal pseudoforests are the (1,0)-tight graphs. Several other important families of graphs may be defined from other values of <em>k</em> and <em>l</em>, and when <em>l</em> ≤ <em>k</em> the (<em>k</em>,<em>l</em>)-sparse graphs may be characterized as the graphs formed as the edge-disjoint union of <em>l</em> forests and <em>k</em> − <em>l</em> pseudoforests.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Almost every sufficiently sparse <a href="random_graph" title="wikilink">random graph</a> is pseudoforest.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> That is, if <em>c</em> is a constant with 0 <em>c</em>(<em>n</em>) is the probability that choosing uniformly at random among the <em>n</em>-vertex graphs with <em>cn</em> edges results in a pseudoforest, then P<sub><em>c</em></sub>(<em>n</em>) tends to one in the limit for large <em>n</em>. However, for <em>c</em> &gt; 1/2, almost every random graph with <em>cn</em> edges has a large component that is not unicyclic.</p>
<h2 id="enumeration">Enumeration</h2>

<p>A graph is <em>simple</em> if it has no self-loops and no multiple edges with the same endpoints. The number of simple 1-trees with <em>n</em> labelled vertices is<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>

<math display="block" id="Pseudoforest:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mfrac>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mi>k</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mi>k</mi>
      </mfrac>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mrow>
          <msub>
           <mi>n</mi>
           <mn>1</mn>
          </msub>
          <mo>+</mo>
          <mi mathvariant="normal">⋯</mi>
          <mo>+</mo>
          <msub>
           <mi>n</mi>
           <mi>k</mi>
          </msub>
         </mrow>
         <mo>=</mo>
         <mi>n</mi>
        </mrow>
       </munder>
       <mrow>
        <mfrac>
         <mrow>
          <mi>n</mi>
          <mo lspace="0pt" rspace="3.5pt">!</mo>
         </mrow>
         <mrow>
          <mrow>
           <msub>
            <mi>n</mi>
            <mn>1</mn>
           </msub>
           <mo lspace="0pt" rspace="3.5pt">!</mo>
          </mrow>
          <mi mathvariant="normal">⋯</mi>
          <mrow>
           <msub>
            <mi>n</mi>
            <mi>k</mi>
           </msub>
           <mo lspace="0pt" rspace="3.5pt">!</mo>
          </mrow>
         </mrow>
        </mfrac>
        <mrow>
         <mo>(</mo>
         <mtable columnspacing="0.4em" rowspacing="0.2ex">
          <mtr>
           <mtd>
            <mrow>
             <mrow>
              <mo>(</mo>
              <mstyle displaystyle="false">
               <mstyle scriptlevel="+1">
                <mtable columnspacing="0.4em" rowspacing="0.2ex">
                 <mtr>
                  <mtd>
                   <msub>
                    <mi>n</mi>
                    <mn>1</mn>
                   </msub>
                  </mtd>
                 </mtr>
                 <mtr>
                  <mtd>
                   <mn>2</mn>
                  </mtd>
                 </mtr>
                </mtable>
               </mstyle>
              </mstyle>
              <mo>)</mo>
             </mrow>
             <mo>+</mo>
             <mi mathvariant="normal">⋯</mi>
             <mo>+</mo>
             <mrow>
              <mo>(</mo>
              <mstyle displaystyle="false">
               <mstyle scriptlevel="+1">
                <mtable columnspacing="0.4em" rowspacing="0.2ex">
                 <mtr>
                  <mtd>
                   <msub>
                    <mi>n</mi>
                    <mi>k</mi>
                   </msub>
                  </mtd>
                 </mtr>
                 <mtr>
                  <mtd>
                   <mn>2</mn>
                  </mtd>
                 </mtr>
                </mtable>
               </mstyle>
              </mstyle>
              <mo>)</mo>
             </mrow>
            </mrow>
           </mtd>
          </mtr>
          <mtr>
           <mtd>
            <mi>n</mi>
           </mtd>
          </mtr>
         </mtable>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>normal-⋯</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <factorial></factorial>
          <ci>n</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <factorial></factorial>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>n</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>normal-⋯</ci>
          <apply>
           <factorial></factorial>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>n</ci>
            <ci>k</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="latexml">binomial</csymbol>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="latexml">binomial</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>n</ci>
            <cn type="integer">1</cn>
           </apply>
           <cn type="integer">2</cn>
          </apply>
          <ci>normal-⋯</ci>
          <apply>
           <csymbol cd="latexml">binomial</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>n</ci>
            <ci>k</ci>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\sum_{k=1}^{n}\frac{(-1)^{k-1}}{k}\sum_{n_{1}+\cdots+n_{k}=n}\frac{n!}{n_{1}!%
\cdots n_{k}!}{\left({{{\left({{n_{1}}\atop{2}}\right)}+\cdots+{\left({{n_{k}}%
\atop{2}}\right)}}\atop{n}}\right)}.
  </annotation>
 </semantics>
</math>

 The values for <em>n</em> up to 18 can be found in sequence  of the <a href="On-Line_Encyclopedia_of_Integer_Sequences" title="wikilink">On-Line Encyclopedia of Integer Sequences</a>.</p>

<p>The number of maximal directed pseudoforests on <em>n</em> vertices, allowing self-loops, is <em>n<sup>n</sup></em>, because for each vertex there are <em>n</em> possible endpoints for the outgoing edge. <a href="André_Joyal" title="wikilink">André Joyal</a> used this fact to provide a <a href="bijective_proof" title="wikilink">bijective proof</a> of <a href="Cayley's_formula" title="wikilink">Cayley's formula</a>, that the number of undirected trees on <em>n</em> nodes is <em>n</em><sup><em>n</em> − 2</sup>, by finding a bijection between maximal directed pseudoforests and undirected trees with two distinguished nodes.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> If self-loops are not allowed, the number of maximal directed pseudoforests is instead (<em>n</em> − 1)<sup><em>n</em></sup>.</p>
<h2 id="graphs-of-functions">Graphs of functions</h2>

<p><a href="Image:Functional_graph.svg" title="wikilink">thumb|upright=1.5|A function from the set {0,1,2,3,4,5,6,7,8} to itself, and the corresponding functional graph</a> Directed pseudoforests and <a href="endofunction" title="wikilink">endofunctions</a> are in some sense mathematically equivalent. Any function ƒ from a set <em>X</em> to itself (that is, an <a class="uri" href="endomorphism" title="wikilink">endomorphism</a> of <em>X</em>) can be interpreted as defining a directed pseudoforest which has an edge from <em>x</em> to <em>y</em> whenever ƒ(<em>x</em>) = <em>y</em>. The resulting directed pseudoforest is maximal, and may include <a href="Loop_(graph_theory)" title="wikilink">self-loops</a> whenever some value <em>x</em> has ƒ(<em>x</em>) = <em>x</em>. Alternatively, omitting the self-loops produces a non-maximal pseudoforest. In the other direction, any maximal directed pseudoforest determines a function ƒ such that ƒ(<em>x</em>) is the target of the edge that goes out from <em>x</em>, and any non-maximal directed pseudoforest can be made maximal by adding self-loops and then converted into a function in the same way. For this reason, maximal directed pseudoforests are sometimes called <strong>functional graphs</strong>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Viewing a function as a functional graph provides a convenient language for describing properties that are not as easily described from the function-theoretic point of view; this technique is especially applicable to problems involving <a href="iterated_function" title="wikilink">iterated functions</a>, which correspond to <a href="path_(graph_theory)" title="wikilink">paths</a> in functional graphs.</p>

<p><a href="Cycle_detection" title="wikilink">Cycle detection</a>, the problem of following a path in a functional graph to find a cycle in it, has applications in <a class="uri" href="cryptography" title="wikilink">cryptography</a> and <a href="computational_number_theory" title="wikilink">computational number theory</a>, as part of <a href="Pollard's_rho_algorithm" title="wikilink">Pollard's rho algorithm</a> for <a href="integer_factorization" title="wikilink">integer factorization</a> and as a method for finding collisions in <a href="cryptographic_hash_function" title="wikilink">cryptographic hash functions</a>. In these applications, ƒ is expected to behave randomly; <a href="Philippe_Flajolet" title="wikilink">Flajolet</a> and <a href="Andrew_Odlyzko" title="wikilink">Odlyzko</a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> study the graph-theoretic properties of the functional graphs arising from randomly chosen mappings. In particular, a form of the <a href="birthday_paradox" title="wikilink">birthday paradox</a> implies that, in a random functional graph with <em>n</em> vertices, the path starting from a randomly selected vertex will typically loop back on itself to form a cycle within O(√<em>n</em>) steps. <a href="Sergei_Konyagin" title="wikilink">Konyagin</a> et. al. have made analytical and computational progress on graph statistics.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Martin, <a href="Andrew_Odlyzko" title="wikilink">Odlyzko</a>, and <a href="Stephen_Wolfram" title="wikilink">Wolfram</a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> investigate pseudoforests that model the dynamics of <a href="cellular_automaton" title="wikilink">cellular automata</a>. These functional graphs, which they call <em>state transition diagrams</em>, have one vertex for each possible configuration that the ensemble of cells of the automaton can be in, and an edge connecting each configuration to the configuration that follows it according to the automaton's rule. One can infer properties of the automaton from the structure of these diagrams, such as the number of components, length of limiting cycles, depth of the trees connecting non-limiting states to these cycles, or symmetries of the diagram. For instance, any vertex with no incoming edge corresponds to a <a href="Garden_of_Eden_pattern" title="wikilink">Garden of Eden pattern</a> and a vertex with a self-loop corresponds to a <a href="Still_life_(cellular_automaton)" title="wikilink">still life pattern</a>.</p>

<p>Another early application of functional graphs is in the <em>trains</em> used to study <a href="Steiner_system" title="wikilink">Steiner triple systems</a>.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> The train of a triple system is a functional graph having a vertex for each possible triple of symbols; each triple <em>pqr</em> is mapped by ƒ to <em>stu</em>, where <em>pqs</em>, <em>prt</em>, and <em>qru</em> are the triples that belong to the triple system and contain the pairs <em>pq</em>, <em>pr</em>, and <em>qr</em> respectively. Trains have been shown to be a powerful invariant of triple systems although somewhat cumbersome to compute.</p>
<h2 id="bicircular-matroid">Bicircular matroid</h2>

<p>A <a class="uri" href="matroid" title="wikilink">matroid</a> is a mathematical structure in which certain sets of elements are defined to be <a href="independence_system" title="wikilink">independent</a>, in such a way that the independent sets satisfy properties modeled after the properties of <a href="linear_independence" title="wikilink">linear independence</a> in a <a href="vector_space" title="wikilink">vector space</a>. One of the standard examples of a matroid is the <a href="graphic_matroid" title="wikilink">graphic matroid</a> in which the independent sets are the sets of edges in forests of a graph; the matroid structure of forests is important in algorithms for computing the <a href="minimum_spanning_tree" title="wikilink">minimum spanning tree</a> of the graph. Analogously, we may define matroids from pseudoforests.</p>

<p>For any graph <em>G</em> = (<em>V</em>,<em>E</em>), we may define a matroid on the edges of <em>G</em>, in which a set of edges is independent if and only if it forms a pseudoforest; this matroid is known as the <strong><a href="bicircular_matroid" title="wikilink">bicircular matroid</a></strong> (or <strong>bicycle matroid</strong>) of <em>G</em>.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> The smallest dependent sets for this matroid are the minimal connected subgraphs of <em>G</em> that have more than one cycle, and these subgraphs are sometimes called bicycles. There are three possible types of bicycle: a <a href="theta_graph" title="wikilink">theta graph</a> has two vertices that are connected by three internally disjoint paths, a figure 8 graph consists of two cycles sharing a single vertex, and a handcuff graph is formed by two disjoint cycles connected by a path.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> A graph is a pseudoforest if and only if it does not contain a bicycle as a subgraph. <a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h2 id="forbidden-minors">Forbidden minors</h2>

<p> Forming a <a href="Minor_(graph_theory)" title="wikilink">minor</a> of a pseudoforest by contracting some of its edges and deleting others produces another pseudoforest. Therefore, the family of pseudoforests is <a href="Closure_(mathematics)" title="wikilink">closed</a> under minors, and the <a href="Robertson–Seymour_theorem" title="wikilink">Robertson–Seymour theorem</a> implies that pseudoforests can be characterized in terms of a finite set of <a href="forbidden_minor" title="wikilink">forbidden minors</a>, analogously to <a href="Wagner's_theorem" title="wikilink">Wagner's theorem</a> characterizing the <a href="planar_graph" title="wikilink">planar graphs</a> as the graphs having neither the <a href="complete_graph" title="wikilink">complete graph</a> K<sub>5</sub> nor the <a href="complete_bipartite_graph" title="wikilink">complete bipartite graph</a> K<sub>3,3</sub> as minors. As discussed above, any non-pseudoforest graph contains as a subgraph a handcuff, figure 8, or theta graph; any handcuff or figure 8 graph may be contracted to form a <em><a href="butterfly_graph" title="wikilink">butterfly graph</a></em> (five-vertex figure 8), and any theta graph may be contracted to form a <em><a href="diamond_graph" title="wikilink">diamond graph</a></em> (four-vertex theta graph),<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> so any non-pseudoforest contains either a butterfly or a diamond as a minor, and these are the only minor-minimal non-pseudoforest graphs. Thus, a graph is a pseudoforest if and only if it does not have the butterfly or the diamond as a minor. If one forbids only the diamond but not the butterfly, the resulting larger graph family consists of the <a href="cactus_graph" title="wikilink">cactus graphs</a> and disjoint unions of multiple cactus graphs.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>More simply, if <a href="multigraph" title="wikilink">multigraphs</a> with <a href="self-loop" title="wikilink">self-loops</a> are considered, there is only one forbidden minor, a vertex with two loops.</p>
<h2 id="algorithms">Algorithms</h2>

<p>An early algorithmic use of pseudoforests involves the <em>network simplex</em> algorithm and its application to generalized flow problems modeling the conversion between <a href="commodity" title="wikilink">commodities</a> of different types.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> In these problems, one is given as input a <a href="flow_network" title="wikilink">flow network</a> in which the vertices model each commodity and the edges model allowable conversions between one commodity and another. Each edge is marked with a <em>capacity</em> (how much of a commodity can be converted per unit time), a <em>flow multiplier</em> (the conversion rate between commodities), and a <em>cost</em> (how much loss or, if negative, profit is incurred per unit of conversion). The task is to determine how much of each commodity to convert via each edge of the flow network, in order to minimize cost or maximize profit, while obeying the capacity constraints and not allowing commodities of any type to accumulate unused. This type of problem can be formulated as a <a href="linear_program" title="wikilink">linear program</a>, and solved using the <a href="simplex_algorithm" title="wikilink">simplex algorithm</a>. The intermediate solutions arising from this algorithm, as well as the eventual optimal solution, have a special structure: each edge in the input network is either unused or used to its full capacity, except for a subset of the edges, forming a spanning pseudoforest of the input network, for which the flow amounts may lie between zero and the full capacity. In this application, unicyclic graphs are also sometimes called <em>augmented trees</em> and maximal pseudoforests are also sometimes called <em>augmented forests</em>.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>

<p>The <em>minimum spanning pseudoforest problem</em> involves finding a spanning pseudoforest of minimum weight in a larger edge-weighted graph <em>G</em>. Due to the matroid structure of pseudoforests, minimum-weight maximal pseudoforests may be found by <a href="greedy_algorithm" title="wikilink">greedy algorithms</a> similar to those for the <a href="minimum_spanning_tree" title="wikilink">minimum spanning tree</a> problem. However, Gabow and Tarjan found a more efficient linear-time approach in this case.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>

<p>The <strong>pseudoarboricity</strong> of a graph <em>G</em> is defined by analogy to the <a class="uri" href="arboricity" title="wikilink">arboricity</a> as the minimum number of pseudoforests into which its edges can be partitioned; equivalently, it is the minimum <em>k</em> such that <em>G</em> is (<em>k</em>,0)-sparse, or the minimum <em>k</em> such that the edges of <em>G</em> can be oriented to form a directed graph with outdegree at most <em>k</em>. Due to the matroid structure of pseudoforests, the pseudoarboricity may be computed in polynomial time.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>

<p>A <a href="random_graph" title="wikilink">random</a> <a href="bipartite_graph" title="wikilink">bipartite graph</a> with <em>n</em> vertices on each side of its bipartition, and with <em>cn</em> edges chosen independently at random from each of the <em>n</em><sup>2</sup> possible pairs of vertices, is a pseudoforest with high probability whenever <em>c</em> is a constant strictly less than one. This fact plays a key role in the analysis of <a href="cuckoo_hashing" title="wikilink">cuckoo hashing</a>, a data structure for looking up key-value pairs by looking in one of two hash tables at locations determined from the key: one can form a graph, the "cuckoo graph", whose vertices correspond to hash table locations and whose edges link the two locations at which one of the keys might be found, and the cuckoo hashing algorithm succeeds in finding locations for all of its keys if and only if the cuckoo graph is a pseudoforest.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>

<p>Pseudoforests also play a key role in <a href="parallel_algorithm" title="wikilink">parallel algorithms</a> for <a href="graph_coloring" title="wikilink">graph coloring</a> and related problems.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Matroid_theory" title="wikilink">Category:Matroid theory</a> <a href="Category:Graph_families" title="wikilink">Category:Graph families</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">The kind of undirected graph considered here is often called a <a class="uri" href="multigraph" title="wikilink">multigraph</a> or pseudograph, to distinguish it from a <a href="simple_graph" title="wikilink">simple graph</a>.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">The kind of undirected graph considered here is often called a <a class="uri" href="multigraph" title="wikilink">multigraph</a> or <a class="uri" href="pseudograph" title="wikilink">pseudograph</a>, to distinguish it from a <a href="simple_graph" title="wikilink">simple graph</a>.<a href="#fnref4">↩</a></li>
<li id="fn5">See the linked articles and the references therein for these definitions.<a href="#fnref5">↩</a></li>
<li id="fn6">This is the definition used, e.g., by .<a href="#fnref6">↩</a></li>
<li id="fn7">This is the definition in .<a href="#fnref7">↩</a></li>
<li id="fn8">See, e.g., the proof of Lemma 4 in .<a href="#fnref8">↩</a></li>
<li id="fn9"> instead use the opposite definition, in which each vertex has indegree one; the resulting graphs, which they call <em>unicycular</em>, are the <a href="transpose_graph" title="wikilink">transposes</a> of the graphs considered here.<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11">; .<a href="#fnref11">↩</a></li>
<li id="fn12">.<a href="#fnref12">↩</a></li>
<li id="fn13">.<a href="#fnref13">↩</a></li>
<li id="fn14">. See especially Corollary 24, p.120, for a bound on the number of vertices belonging to unicyclic components in a random graph, and Corollary 19, p.113, for a bound on the number of distinct labeled unicyclic graphs.<a href="#fnref14">↩</a></li>
<li id="fn15">; see  in the <a href="On-Line_Encyclopedia_of_Integer_Sequences" title="wikilink">On-Line Encyclopedia of Integer Sequences</a>.<a href="#fnref15">↩</a></li>
<li id="fn16">.<a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18">.<a href="#fnref18">↩</a></li>
<li id="fn19">.<a href="#fnref19">↩</a></li>
<li id="fn20">.<a href="#fnref20">↩</a></li>
<li id="fn21">; ; .<a href="#fnref21">↩</a></li>
<li id="fn22">.<a href="#fnref22">↩</a></li>
<li id="fn23">.<a href="#fnref23">↩</a></li>
<li id="fn24"><a href="http://www.math.binghamton.edu/zaslav/Bsg/glossary.html">Glossary of Signed and Gain Graphs and Allied Areas</a><a href="#fnref24">↩</a></li>
<li id="fn25"></li>
<li id="fn26">For this terminology, see the <a href="http://www.graphclasses.org/smallgraphs.html">list of small graphs</a> from the <a href="http://www.graphclasses.org/">Information System on Graph Class Inclusions</a>. However, <em>butterfly graph</em> may also refer to a different family of graphs related to <a href="hypercube_graph" title="wikilink">hypercubes</a>, and the five-vertex figure 8 is sometimes instead called a <em>bowtie graph</em>.<a href="#fnref26">↩</a></li>
<li id="fn27">.<a href="#fnref27">↩</a></li>
<li id="fn28"></li>
<li id="fn29">.<a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32">. See also the faster approximation schemes of .<a href="#fnref32">↩</a></li>
<li id="fn33">.<a href="#fnref33">↩</a></li>
<li id="fn34">; .<a href="#fnref34">↩</a></li>
</ol>
</section>
</body>
</html>
