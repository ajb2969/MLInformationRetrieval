   Constrained optimization      Constrained optimization   In mathematical optimization , constrained optimization (in some contexts called constraint optimization ) is the process of optimizing an objective function with respect to some variables in the presence of constraints on those variables. The objective function is either a cost function or energy function which is to be minimized , or a reward function or utility function , which is to be maximized . Constraints can be either hard constraints which set conditions for the variables that are required to be satisfied, or soft constraints which have some variable values that are penalized in the objective function if, and based on the extent that, the conditions on the variables are not satisfied.  General form  A general constrained minimization problem may be written as follows:        min      f   (  ùê±  )           subject   to         g  i    (  ùê±  )    =   c  i        for  i   =   1  ,  ‚Ä¶  ,  n  Equality constraints             h  j    (  ùê±  )    ‚âß   d  j        for  j   =   1  ,  ‚Ä¶  ,  m  Inequality constraints            missing-subexpression     f  ùê±    missing-subexpression       subject  to    missing-subexpression        subscript  g  i   ùê±    subscript  c  i        for  i    1  normal-‚Ä¶  n  Equality constraints       missing-subexpression    missing-subexpression        subscript  h  j   ùê±    subscript  d  j        for  j    1  normal-‚Ä¶  m  Inequality constraints       \begin{array}[]{rcll}\min&&f(\mathbf{x})&\\
 \mathrm{subject~{}to}&&g_{i}(\mathbf{x})=c_{i}&\text{for }i=1,\ldots,n\quad%
 \text{Equality constraints}\\
 &&h_{j}(\mathbf{x})\geqq d_{j}&\text{for }j=1,\ldots,m\quad\text{Inequality %
 constraints}\end{array}     where       g  i    (  ùê±  )    =     c  i     for   i   =  1   ,   ‚Ä¶  ,  n      formulae-sequence         subscript  g  i   ùê±      subscript  c  i   for  i        1     normal-‚Ä¶  n     g_{i}(\mathbf{x})=c_{i}~{}\mathrm{for~{}}i=1,\ldots,n   and       h  j    (  ùê±  )    ‚â•     d  j     for   j   =  1   ,   ‚Ä¶  ,  m      formulae-sequence         subscript  h  j   ùê±      subscript  d  j   for  j        1     normal-‚Ä¶  m     h_{j}(\mathbf{x})\geq d_{j}~{}\mathrm{for~{}}j=1,\ldots,m   are constraints that are required to be satisfied; these are called hard constraints .  In some problems, often called constraint optimization problems , the objective function is actually the sum of cost functions, each of which penalizes the extent (if any) to which a soft constraint (a constraint which is preferred but not required to be satisfied) is violated.  Solution methods  Many unconstrained optimization algorithms can be adapted to the constrained case, often via the use of a penalty method . However, search steps taken by the unconstrained method may be unacceptable for the constrained problem, leading to a lack of convergence. This is referred to as the Maratos effect. 1  Equality constraints  If the constrained problem has only equality constraints, the method of Lagrange multipliers can be used to convert it into an unconstrained problem whose number of variables is the original number of variables plus the original number of equality constraints. Alternatively, if the constraints are all equality constraints and are all linear, they can be solved for some of the variables in terms of the others, and the former can be substituted out of the objective function, leaving an unconstrained problem in a smaller number of variables.  Inequality constraints  With inequality constraints, the problem can be characterized in terms of the Geometric Optimality conditions , Fritz John conditions and Karush‚ÄìKuhn‚ÄìTucker conditions , in which simple problems may be solvable.  Linear programming  If the objective function and all of the hard constraints are linear, then the problem is a linear programming problem. This can be solved by the simplex method , which usually works in polynomial time in the problem size but is not guaranteed to, or by interior point methods which are guaranteed to work in polynomial time.  Quadratic programming  If all the hard constraints are linear but the objective function is quadratic, the problem is a quadratic programming problem. It can still be solved in polynomial time by the ellipsoid method if the objective function is convex ; otherwise the problem is NP hard .  Constraint optimization problems  Branch and bound  Constraint optimization can be solved by branch and bound algorithms. These are backtracking algorithms storing the cost of the best solution found during execution and use it for avoiding part of the search. More precisely, whenever the algorithm encounters a partial solution that cannot be extended to form a solution of better cost than the stored best cost, the algorithm backtracks, instead of trying to extend this solution.  Assuming that cost is to be maximized, the efficiency of these algorithms depends on how the cost that can be obtained from extending a partial solution is evaluated. Indeed, if the algorithm can backtrack from a partial solution, part of the search is skipped. The lower the estimated cost, the better the algorithm, as a lower estimated cost is more likely to be lower than the best cost of solution found so far.  On the other hand, this estimated cost cannot be lower than the effective cost that can be obtained by extending the solution, as otherwise the algorithm could backtrack while a solution better than the best found so far exists. As a result, the algorithm requires an upper bound on the cost that can be obtained from extending a partial solution, and this upper bound should be as small as possible.  A variation of this approach called Hansen's method uses interval methods . 2 It inherently implements rectangular constraints.  First-choice bounding functions  One way for evaluating this upper bound for a partial solution is to consider each soft constraint separately. For each soft constraint, the maximal possible value for any assignment to the unassigned variables is assumed. The sum of these values is an upper bound because the soft constraints cannot assume a higher value. It is exact because the maximal values of soft constraints may derive from different evaluations: a soft constraint may be maximal for    x  =  a      x  a    x=a   while another constraint is maximal for    x  =  b      x  b    x=b   .  Russian doll search  This method 3 runs a branch-and-bound algorithm on   n   n   n   problems, where   n   n   n   is the number of variables. Each such problem is the subproblem obtained by dropping a sequence of variables     x  1   ,  ‚Ä¶  ,   x  i       subscript  x  1   normal-‚Ä¶   subscript  x  i     x_{1},\ldots,x_{i}   from the original problem, along with the constraints containing them. After the problem on variables     x   i  +  1    ,  ‚Ä¶  ,   x  n       subscript  x    i  1    normal-‚Ä¶   subscript  x  n     x_{i+1},\ldots,x_{n}   is solved, its optimal cost can be used as an upper bound while solving the other problems,  In particular, the cost estimate of a solution having     x   i  +  1    ,  ‚Ä¶  ,   x  n       subscript  x    i  1    normal-‚Ä¶   subscript  x  n     x_{i+1},\ldots,x_{n}   as unassigned variables is added to the cost that derives from the evaluated variables. Virtually, this corresponds on ignoring the evaluated variables and solving the problem on the unassigned ones, except that the latter problem has already been solved. More precisely, the cost of soft constraints containing both assigned and unassigned variables is estimated as above (or using an arbitrary other method); the cost of soft constraints containing only unassigned variables is instead estimated using the optimal solution of the corresponding problem, which is already known at this point.  There is similarity between the Russian Doll Search method and Dynamic Programming . Like Dynamic Programming,Russian Doll Search solves sub-problems in order to solve the whole problem. But, whereas Dynamic Programming directly combines the results obtained on sub-problems to get the result of the whole problem, Russian Doll Search only uses them as bounds during its search.  Bucket elimination  The bucket elimination algorithm can be adapted for constraint optimization. A given variable can be indeed removed from the problem by replacing all soft constraints containing it with a new soft constraint. The cost of this new constraint is computed assuming a maximal value for every value of the removed variable. Formally, if   x   x   x   is the variable to be removed,     C  1   ,  ‚Ä¶  ,   C  n       subscript  C  1   normal-‚Ä¶   subscript  C  n     C_{1},\ldots,C_{n}   are the soft constraints containing it, and     y  1   ,  ‚Ä¶  ,   y  m       subscript  y  1   normal-‚Ä¶   subscript  y  m     y_{1},\ldots,y_{m}   are their variables except   x   x   x   , the new soft constraint is defined by:      C   (   y  1   =   a  1   ,  ‚Ä¶  ,   y  n   =   a  n   )   =   max  a    ‚àë  i    C  i    (  x  =  a  ,   y  1   =   a  1   ,  ‚Ä¶  ,   y  n   =   a  n   )      fragments  C   fragments  normal-(   subscript  y  1     subscript  a  1   normal-,  normal-‚Ä¶  normal-,   subscript  y  n     subscript  a  n   normal-)     subscript   a    subscript   i    subscript  C  i    fragments  normal-(  x   a  normal-,   subscript  y  1     subscript  a  1   normal-,  normal-‚Ä¶  normal-,   subscript  y  n     subscript  a  n   normal-)     C(y_{1}=a_{1},\ldots,y_{n}=a_{n})=\max_{a}\sum_{i}C_{i}(x=a,y_{1}=a_{1},\ldots%
 ,y_{n}=a_{n})     Bucket elimination works with an (arbitrary) ordering of the variables. Every variable is associated a bucket of constraints; the bucket of a variable contains all constraints having the variable has the highest in the order. Bucket elimination proceed from the last variable to the first. For each variable, all constraints of the bucket are replaced as above to remove the variable. The resulting constraint is then placed in the appropriate bucket.  See also   Integer programming  Distributed constraint optimization  Penalty method   References     "  Category:Mathematical optimization  Category:Constraint programming     Wenyu Sun; Ya-Xiang Yua (2010). Optimization Theory and Methods: Nonlinear Programming , Springer, ISBN 978-1441937650. p. 541 ‚Ü©  ‚Ü©  Verfaillie, G√©rard, Michel Lema√Ætre, and Thomas Schiex. "Russian doll search for solving constraint optimization problems." AAAI/IAAI, Vol. 1. 1996. ‚Ü©     