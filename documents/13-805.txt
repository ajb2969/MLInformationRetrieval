   Distributed source coding      Distributed source coding  '''Distributed source coding''' ('''DSC''') is an important problem in [[information theory]] and [[comm unication]]. DSC problems regard the compression of multiple correlated information sources that do not communicate with each other. 1 By modeling the correlation between multiple sources at the decoder side together with channel codes , DSC is able to shift the computational complexity from encoder side to decoder side, therefore provide appropriate frameworks for applications with complexity-constrained sender, such as sensor networks and video/multimedia compression (see distributed video coding 2 ). One of the main properties of distributed source coding is that the computational burden in encoders is shifted to the joint decoder.  History  In 1973, David Slepian and Jack Keil Wolf proposed the information theoretical lossless compression bound on distributed compression of two correlated i.i.d. sources X and Y. 3 After that, this bound was extended to cases with more than two sources by Thomas M. Cover in 1975, 4 while the theoretical results in the lossy compression case are presented by Aaron D. Wyner and Jacob Ziv in 1976. 5  Although the theorems on DSC were proposed on 1970s, it was after about 30 years that attempts were started for practical techniques, based on the idea that DSC is closely related to channel coding proposed in 1974 by Aaron D. Wyner . 6 The asymmetric DSC problem was addressed by S. S. Pradhan and K. Ramchandran in 1999, which focused on statistically dependent binary and Gaussian sources and used scalar and trellis coset constructions to solve the problem. 7 They further extended the work into the symmetric DSC case. 8  Syndrome decoding technology was first used in distributed source coding by the DISCUS system of SS Pradhan and K Ramachandran (Distributed Source Coding Using Syndromes). 9 They compress binary block data from one source into syndromes and transmit data from the other source uncompressed as side information . This kind of DSC scheme achieves asymmetric compression rates per source and results in asymmetric DSC. This asymmetric DSC scheme can be easily extended to the case of more than two correlated information sources. There are also some DSC schemes that use parity bits rather than syndrome bits.  The correlation between two sources in DSC has been modeled as a virtual channel which is usually referred as a binary symmetric channel . 10 11  Starting from DISCUS , DSC has attracted significant research activity and more sophisticated channel coding techniques have been adopted into DSC frameworks, such as Turbo Code , LDPC Code, and so on.  Similar to the previous lossless coding framework based on Slepianâ€“Wolf theorem, efforts have been taken on lossy cases based on the Wynerâ€“Ziv theorem. Theoretical results on quantizer designs was provided by R. Zamir and S. Shamai, 12 while different frameworks have been proposed based on this result, including a nested lattice quantizer and a trellis-coded quantizer.  Moreover, DSC has been used in video compression for applications which require low complexity video encoding, such as sensor networks, multiview video camcorders, and so on. 13  With deterministic and probabilistic discussions of correlation model of two correlated information sources, DSC schemes with more general compressed rates have been developed. 14 15 16 In these non-asymmetric schemes, both of two correlated sources are compressed.  Under a certain deterministic assumption of correlation between information sources, a DSC framework in which any number of information sources can be compressed in a distributed way has been demonstrated by X. Cao and M. Kuijper. 17 This method performs non-asymmetric compression with flexible rates for each source, achieving the same overall compression rate as repeatedly applying asymmetric DSC for more than two sources. Then, by investigating the unique connection between syndromes and complementary codewords of linear codes, they have translated the major steps of DSC joint decoding into syndrome decoding followed by channel encoding via a linear block code and also via its complement code, 18 which theoretically illustrated a method of assembling a DSC joint decoder from linear code encoders and decoders.  Theoretical bounds  The information theoretical lossless compression bound on DSC (the Slepianâ€“Wolf bound ) was first purposed by David Slepian and Jack Keil Wolf in terms of entropies of correlated information sources in 1973. 19 They also showed that two isolated sources can compress data as efficiently as if they were communicating with each other. This bound has been extended to the case of more than two correlated sources by Thomas M. Cover in 1975. 20  Similar results were obtained in 1976 by Aaron D. Wyner and Jacob Ziv with regard to lossy coding of joint Gaussian sources. 21  Slepianâ€“Wolf bound  Distributed Coding is the coding of two or more dependent sources with separate encoders and joint decoder. Given two statistically dependent i.i.d. finite-alphabet random sequences X and Y, Slepianâ€“Wolf theorem includes theoretical bound for the lossless coding rate for distributed coding of the two sources as below: 22       R  X   â‰¥  H   (  X  |  Y  )   ,     fragments   subscript  R  X    H   fragments  normal-(  X  normal-|  Y  normal-)   normal-,    R_{X}\geq H(X|Y),\,          R  Y   â‰¥  H   (  Y  |  X  )   ,     fragments   subscript  R  Y    H   fragments  normal-(  Y  normal-|  X  normal-)   normal-,    R_{Y}\geq H(Y|X),\,            R  X   +   R  Y    â‰¥   H   (  X  ,  Y  )     .         subscript  R  X    subscript  R  Y      H   X  Y      R_{X}+R_{Y}\geq H(X,Y).\,     If both the encoder and decoder of the two sources are independent, the lowest rate we can achieve for lossless compression is    H   (  X  )       H  X    H(X)   and    H   (  Y  )       H  Y    H(Y)   for   X   X   X   and   Y   Y   Y   respectively, where    H   (  X  )       H  X    H(X)   and    H   (  Y  )       H  Y    H(Y)   are the entropies of   X   X   X   and   Y   Y   Y   . However, with joint decoding, if vanishing error probability for long sequences is accepted, the Slepianâ€“Wolf theorem shows that much better compression rate can be achieved. As long as the total rate of   X   X   X   and   Y   Y   Y   is larger than their joint entropy    H   (  X  ,  Y  )       H   X  Y     H(X,Y)   and none of the sources is encoded with a rate larger than its entropy, distributed coding can achieve arbitrarily small error probability for long sequences.  A special case of distributed coding is compression with decoder side information, where source   Y   Y   Y   is available at the decoder side but not accessible at the encoder side. This can be treated as the condition that     R  Y   =   H   (  Y  )         subscript  R  Y     H  Y     R_{Y}=H(Y)   has already been used to encode   Y   Y   Y   , while we intend to use    H   (  X  |  Y  )      fragments  H   fragments  normal-(  X  normal-|  Y  normal-)     H(X|Y)   to encode   X   X   X   . The whole system is operating in an asymmetric way (compression rate for the two sources are asymmetric).  Wynerâ€“Ziv bound  Shortly after Slepianâ€“Wolf theorem on lossless distributed compression was published, the extension to lossy compression with decoder side information was proposed as Wynerâ€“Ziv theorem. 23 Similarly to lossless case, two statistically dependent i.i.d. sources   X   X   X   and   Y   Y   Y   are given, where   Y   Y   Y   is available at the decoder side but not accessible at the encoder side. Instead of lossless compression in Slepianâ€“Wolf theorem, Wynerâ€“Ziv theorem looked into the lossy compression case.  Wynerâ€“Ziv theorem presents the achievable lower bound for the bit rate of   X   X   X   at given distortion   D   D   D   . It was found that for Gaussian memoryless sources and mean-squared error distortion, the lower bound for the bit rate of   X   X   X   remain the same no matter whether side information is available at the encoder or not.  Virtual channel  Deterministic model  Probabilistic model  Asymmetric DSC vs. symmetric DSC  Asymmetric DSC means that, different bitrates are used in coding the input sources, while same bitrate is used in symmetric DSC. Taking a DSC design with two sources for example, in this example   X   X   X   and   Y   Y   Y   are two discrete, memoryless, uniformly distributed sources which generate set of variables   ğ±   ğ±   \mathbf{x}   and   ğ²   ğ²   \mathbf{y}   of length 7 bits and the Hamming distance between   ğ±   ğ±   \mathbf{x}   and   ğ²   ğ²   \mathbf{y}   is at most one. The Slepianâ€“Wolf bound for them is:        R  X   +   R  Y    â‰¥  10         subscript  R  X    subscript  R  Y    10    R_{X}+R_{Y}\geq 10          R  X   â‰¥  5       subscript  R  X   5    R_{X}\geq 5          R  Y   â‰¥  5       subscript  R  Y   5    R_{Y}\geq 5     This means, the theoretical bound is      R  X   +   R  Y    =  10         subscript  R  X    subscript  R  Y    10    R_{X}+R_{Y}=10   and symmetric DSC means 5 bits for each source. Other pairs with      R  X   +   R  Y    =  10         subscript  R  X    subscript  R  Y    10    R_{X}+R_{Y}=10   are asymmetric cases with different bit rate distributions between   X   X   X   and   Y   Y   Y   , where     R  X   =  3       subscript  R  X   3    R_{X}=3   ,     R  Y   =  7       subscript  R  Y   7    R_{Y}=7   and     R  Y   =  3       subscript  R  Y   3    R_{Y}=3   ,     R  X   =  7       subscript  R  X   7    R_{X}=7   represent two extreme cases called decoding with side information.  Practical distributed source coding  Slepianâ€“Wolf coding â€“ lossless distributed coding  It was understood that Slepianâ€“Wolf coding is closely related to channel coding in 1974, 24 and after about 30 years, practical DSC started to be implemented by different channel codes. The motivation behind the use of channel codes is from two sources case, the correlation between input sources can be modeled as a virtual channel which has input as source   X   X   X   and output as source   Y   Y   Y   . The DISCUS system proposed by S. S. Pradhan and K. Ramchandran in 1999 implemented DSC with syndrome decoding , which worked for asymmetric case and was further extended to symmetric case. 25 26  The basic framework of syndrome based DSC is that, for each source, its input space is partitioned into several cosets according to the particular channel coding method used. Every input of each source gets an output indicating which coset the input belongs to, and the joint decoder can decode all inputs by received coset indices and dependence between sources. The design of channel codes should consider the correlation between input sources.  A group of codes can be used to generate coset partitions, 27 such as trellis codes and lattice codes. Pradhan and Ramchandran designed rules for construction of sub-codes for each source, and presented result of trellis-based coset constructions in DSC, which is based on convolution code and set-partitioning rules as in Trellis modulation , as well as lattice code based DSC. 28 29 After this, embedded trellis code was proposed for asymmetric coding as an improvement over their results. 30  After DISCUS system was proposed, more sophisticated channel codes have been adapted to the DSC system, such as Turbo Code , LDPC Code and Iterative Channel Code. The encoders of these codes are usually simple and easy to implement, while the decoders have much higher computational complexity and are able to get good performance by utilizing source statistics. With sophisticated channel codes which have performance approaching the capacity of the correlation channel, corresponding DSC system can approach the Slepianâ€“Wolf bound.  Although most research focused on DSC with two dependent sources, Slepianâ€“Wolf coding has been extended to more than two input sources case, and sub-codes generation methods from one channel code was proposed by V. Stankovic, A. D. Liveris, etc. given particular correlation models. 31  General theorem of Slepianâ€“Wolf coding with syndromes for two sources  Theorem : Any pair of correlated uniformly distributed sources,     X  ,  Y   âˆˆ    {  0  ,  1  }   n        X  Y    superscript   0  1   n     X,Y\in\left\{0,1\right\}^{n}   , with      ğ  ğ‡    (  X  ,  Y  )    â‰¤  t         subscript  ğ  ğ‡    X  Y    t    \mathbf{d_{H}}(X,Y)\leq t   , can be compressed separately at a rate pair    (   R  1   ,   R  2   )      subscript  R  1    subscript  R  2     (R_{1},R_{2})   such that       R  1   ,   R  2    â‰¥   n  -  k    ,     R  1   +   R  2    â‰¥    2  n   -  k       formulae-sequence      subscript  R  1    subscript  R  2      n  k         subscript  R  1    subscript  R  2        2  n   k      R_{1},R_{2}\geq n-k,R_{1}+R_{2}\geq 2n-k   , where    R  1     subscript  R  1    R_{1}   and    R  2     subscript  R  2    R_{2}   are integers, and    k  â‰¤   n  -   log   (    âˆ‘   i  =  0   t    (      n      i      )    )         k    n      superscript   subscript     i  0    t    binomial  n  i        k\leq n-\log(\sum_{i=0}^{t}{n\choose i})   . This can be achieved using an    (  n  ,  k  ,    2  t   +  1   )     n  k      2  t   1     (n,k,2t+1)   binary linear code.  Proof : The Hamming bound for an    (  n  ,  k  ,    2  t   +  1   )     n  k      2  t   1     (n,k,2t+1)   binary linear code is    k  â‰¤   n  -   log   (    âˆ‘   i  =  0   t    (      n      i      )    )         k    n      superscript   subscript     i  0    t    binomial  n  i        k\leq n-\log(\sum_{i=0}^{t}{n\choose i})   , and we have Hamming code achieving this bound, therefore we have such a binary linear code   ğ‚   ğ‚   \mathbf{C}   with    k  Ã—  n      k  n    k\times n   generator matrix   ğ†   ğ†   \mathbf{G}   . Next we will show how to construct syndrome encoding based on this linear code.  Let      R  1   +   R  2    =    2  n   -  k          subscript  R  1    subscript  R  2        2  n   k     R_{1}+R_{2}=2n-k   and    ğ†  ğŸ     subscript  ğ†  1    \mathbf{G_{1}}   be formed by taking first    (   n  -   R  1    )      n   subscript  R  1     (n-R_{1})   rows from   ğ†   ğ†   \mathbf{G}   , while    ğ†  ğŸ     subscript  ğ†  2    \mathbf{G_{2}}   is formed using the remaining    (   n  -   R  2    )      n   subscript  R  2     (n-R_{2})   rows of   ğ†   ğ†   \mathbf{G}   .    ğ‚  ğŸ     subscript  ğ‚  1    \mathbf{C_{1}}   and    ğ‚  ğŸ     subscript  ğ‚  2    \mathbf{C_{2}}   are the subcodes of the Hamming code generated by    ğ†  ğŸ     subscript  ğ†  1    \mathbf{G_{1}}   and    ğ†  ğŸ     subscript  ğ†  2    \mathbf{G_{2}}   respectively, with    ğ‡  ğŸ     subscript  ğ‡  1    \mathbf{H_{1}}   and    ğ‡  ğŸ     subscript  ğ‡  2    \mathbf{H_{2}}   as their parity check matrices.  For a pair of input    (  ğ±  ,  ğ²  )     ğ±  ğ²    \mathbf{(x,y)}   , the encoder is given by     ğ¬  ğŸ   =    ğ‡  ğŸ   ğ±        subscript  ğ¬  1      subscript  ğ‡  1   ğ±     \mathbf{s_{1}}=\mathbf{H_{1}}\mathbf{x}   and     ğ¬  ğŸ   =    ğ‡  ğŸ   ğ²        subscript  ğ¬  2      subscript  ğ‡  2   ğ²     \mathbf{s_{2}}=\mathbf{H_{2}}\mathbf{y}   . That means, we can represent   ğ±   ğ±   \mathbf{x}   and   ğ²   ğ²   \mathbf{y}   as    ğ±  =     ğ®  ğŸ    ğ†  ğŸ    +   ğœ  ğ¬ğŸ        ğ±       subscript  ğ®  1    subscript  ğ†  1     subscript  ğœ  ğ¬ğŸ      \mathbf{x=u_{1}G_{1}+c_{s1}}   ,    ğ²  =     ğ®  ğŸ    ğ†  ğŸ    +   ğœ  ğ¬ğŸ        ğ²       subscript  ğ®  2    subscript  ğ†  2     subscript  ğœ  ğ¬ğŸ      \mathbf{y=u_{2}G_{2}+c_{s2}}   , where     ğœ  ğ¬ğŸ   ,   ğœ  ğ¬ğŸ       subscript  ğœ  ğ¬ğŸ    subscript  ğœ  ğ¬ğŸ     \mathbf{c_{s1},c_{s2}}   are the representatives of the cosets of    ğ¬ğŸ  ,  ğ¬ğŸ     ğ¬ğŸ  ğ¬ğŸ    \mathbf{s1,s2}   with regard to     ğ‚  ğŸ   ,   ğ‚  ğŸ       subscript  ğ‚  1    subscript  ğ‚  2     \mathbf{C_{1},C_{2}}   respectively. Since we have    ğ²  =   ğ±  +  ğ       ğ²    ğ±  ğ     \mathbf{y=x+e}   with     w   (  ğ  )    â‰¤  t        w  ğ   t    w(\mathbf{e})\leq t   . We can get     ğ±  +  ğ²   =   ğ®ğ†  +   ğœ  ğ¬    =  ğ          ğ±  ğ²     ğ®ğ†   subscript  ğœ  ğ¬         ğ     \mathbf{x+y=uG+c_{s}=e}   , where    ğ®  =   [   ğ®  ğŸ   ,   ğ®  ğŸ   ]       ğ®    subscript  ğ®  1    subscript  ğ®  2      \mathbf{u=\left[u_{1},u_{2}\right]}   ,     ğœ  ğ¬   =    ğœ  ğ¬ğŸ   +   ğœ  ğ¬ğŸ         subscript  ğœ  ğ¬      subscript  ğœ  ğ¬ğŸ    subscript  ğœ  ğ¬ğŸ      \mathbf{c_{s}=c_{s1}+c_{s2}}   .  Suppose there are two different input pairs with the same syndromes, that means there are two different strings      ğ®  ğŸ   ,   ğ®  ğŸ    âˆˆ    {  0  ,  1  }   k         superscript  ğ®  1    superscript  ğ®  2     superscript   0  1   k     \mathbf{u^{1},u^{2}}\in\left\{0,1\right\}^{k}   , such that       ğ®  ğŸ   ğ†   +   ğœ  ğ¬    =  ğ           superscript  ğ®  1   ğ†    subscript  ğœ  ğ¬    ğ    \mathbf{u^{1}G+c_{s}=e}   and       ğ®  ğŸ   ğ†   +   ğœ  ğ¬    =  ğ           superscript  ğ®  2   ğ†    subscript  ğœ  ğ¬    ğ    \mathbf{u^{2}G+c_{s}=e}   . Thus we will have      (    ğ®  ğŸ   -   ğ®  ğŸ    )   ğ†   =  ğŸ           superscript  ğ®  1    superscript  ğ®  2    ğ†   0    \mathbf{(u^{1}-u^{2})G=0}   . Because minimum Hamming weight of the code   ğ‚   ğ‚   \mathbf{C}   is     2  t   +  1        2  t   1    2t+1   , the distance between     ğ®  ğŸ   ğ†       subscript  ğ®  1   ğ†    \mathbf{u_{1}G}   and     ğ®  ğŸ   ğ†       subscript  ğ®  2   ğ†    \mathbf{u_{2}G}   is     â‰¥    2  t   +  1       absent      2  t   1     \geq 2t+1   . On the other hand, according to     w   (  ğ  )    â‰¤  t        w  ğ   t    w(\mathbf{e})\leq t   together with       ğ®  ğŸ   ğ†   +   ğœ  ğ¬    =  ğ           superscript  ğ®  1   ğ†    subscript  ğœ  ğ¬    ğ    \mathbf{u^{1}G+c_{s}=e}   and       ğ®  ğŸ   ğ†   +   ğœ  ğ¬    =  ğ           superscript  ğ®  2   ğ†    subscript  ğœ  ğ¬    ğ    \mathbf{u^{2}G+c_{s}=e}   , we will have      d  H    (    ğ®  ğŸ   ğ†   ,   ğœ  ğ¬   )    â‰¤  t         subscript  d  H       superscript  ğ®  1   ğ†    subscript  ğœ  ğ¬     t    d_{H}(\mathbf{u^{1}G,c_{s}})\leq t   and      d  H    (    ğ®  ğŸ   ğ†   ,   ğœ  ğ¬   )    â‰¤  t         subscript  d  H       superscript  ğ®  2   ğ†    subscript  ğœ  ğ¬     t    d_{H}(\mathbf{u^{2}G,c_{s}})\leq t   , which contradict with      d  H    (    ğ®  ğŸ   ğ†   ,    ğ®  ğŸ   ğ†   )    â‰¥    2  t   +  1          subscript  d  H       superscript  ğ®  1   ğ†      superscript  ğ®  2   ğ†         2  t   1     d_{H}(\mathbf{u^{1}G,u^{2}G})\geq 2t+1   . Therefore, we cannot have more than one input pairs with the same syndromes.  Therefore, we can successfully compress the two dependent sources with constructed subcodes from an    (  n  ,  k  ,    2  t   +  1   )     n  k      2  t   1     (n,k,2t+1)   binary linear code, with rate pair    (   R  1   ,   R  2   )      subscript  R  1    subscript  R  2     (R_{1},R_{2})   such that       R  1   ,   R  2    â‰¥   n  -  k    ,     R  1   +   R  2    â‰¥    2  n   -  k       formulae-sequence      subscript  R  1    subscript  R  2      n  k         subscript  R  1    subscript  R  2        2  n   k      R_{1},R_{2}\geq n-k,R_{1}+R_{2}\geq 2n-k   , where    R  1     subscript  R  1    R_{1}   and    R  2     subscript  R  2    R_{2}   are integers, and    k  â‰¤   n  -   log   (    âˆ‘   i  =  0   t    (      n      i      )    )         k    n      superscript   subscript     i  0    t    binomial  n  i        k\leq n-\log(\sum_{i=0}^{t}{n\choose i})   . Log indicates Log 2 .  Slepianâ€“Wolf coding example  Take the same example as in the previous Asymmetric DSC vs. Symmetric DSC part, this part presents the corresponding DSC schemes with coset codes and syndromes including asymmetric case and symmetric case. The Slepianâ€“Wolf bound for DSC design is shown in the previous part.  Asymmetric case (     R  X   =  3       subscript  R  X   3    R_{X}=3   ,     R  Y   =  7       subscript  R  Y   7    R_{Y}=7   )  In this case, the length of an input variable   ğ²   ğ²   \mathbf{y}   from source   Y   Y   Y   is 7 bits, therefore it can be sent lossless with 7 bits independent of any other bits. Based on the knowledge that   ğ±   ğ±   \mathbf{x}   and   ğ²   ğ²   \mathbf{y}   have Hamming distance at most one, for input   ğ±   ğ±   \mathbf{x}   from source   X   X   X   , since the receiver already has   ğ²   ğ²   \mathbf{y}   , the only possible   ğ±   ğ±   \mathbf{x}   are those with at most 1 distance from   ğ²   ğ²   \mathbf{y}   . If we model the correlation between two sources as a virtual channel, which has input   ğ±   ğ±   \mathbf{x}   and output   ğ²   ğ²   \mathbf{y}   , as long as we get   ğ²   ğ²   \mathbf{y}   , all we need to successfully "decode"   ğ±   ğ±   \mathbf{x}   is "parity bits" with particular error correction ability, taking the difference between   ğ±   ğ±   \mathbf{x}   and   ğ²   ğ²   \mathbf{y}   as channel error. We can also model the problem with cosets partition. That is, we want to find a channel code, which is able to partition the space of input   X   X   X   into several cosets, where each coset has a unique syndrome associated with it. With a given coset and   ğ²   ğ²   \mathbf{y}   , there is only one   ğ±   ğ±   \mathbf{x}   that is possible to be the input given the correlation between two sources.  In this example, we can use the    (  7  ,  4  ,  3  )     7  4  3    (7,4,3)   binary Hamming Code    ğ‚   ğ‚   \mathbf{C}   , with parity check matrix   ğ‡   ğ‡   \mathbf{H}   . For an input   ğ±   ğ±   \mathbf{x}   from source   X   X   X   , only the syndrome given by    ğ¬  =  ğ‡ğ±      ğ¬  ğ‡ğ±    \mathbf{s}=\mathbf{H}\mathbf{x}   is transmitted, which is 3 bits. With received   ğ²   ğ²   \mathbf{y}   and   ğ¬   ğ¬   \mathbf{s}   , suppose there are two inputs    ğ±  ğŸ     subscript  ğ±  1    \mathbf{x_{1}}   and    ğ±  ğŸ     subscript  ğ±  2    \mathbf{x_{2}}   with same syndrome   ğ¬   ğ¬   \mathbf{s}   . That means     ğ‡ğ±  ğŸ   =   ğ‡ğ±  ğŸ        subscript  ğ‡ğ±  1    subscript  ğ‡ğ±  2     \mathbf{H}\mathbf{x_{1}}=\mathbf{H}\mathbf{x_{2}}   , which is     ğ‡   (    ğ±  ğŸ   -   ğ±  ğŸ    )    =  0        ğ‡     subscript  ğ±  1    subscript  ğ±  2     0    \mathbf{H}(\mathbf{x_{1}}-\mathbf{x_{2}})=0   . Since the minimum Hamming weight of    (  7  ,  4  ,  3  )     7  4  3    (7,4,3)   Hamming Code is 3,      d  H    (   ğ±  ğŸ   ,   ğ±  ğŸ   )    â‰¥  3         subscript  d  H     subscript  ğ±  1    subscript  ğ±  2     3    d_{H}(\mathbf{x_{1}},\mathbf{x_{2}})\geq 3   . Therefore the input   ğ±   ğ±   \mathbf{x}   can be recovered since      d  H    (  ğ±  ,  ğ²  )    â‰¤  1         subscript  d  H    ğ±  ğ²    1    d_{H}(\mathbf{x},\mathbf{y})\leq 1   .  Similarly, the bits distribution with     R  X   =  7       subscript  R  X   7    R_{X}=7   ,     R  Y   =  3       subscript  R  Y   3    R_{Y}=3   can be achieved by reversing the roles of   X   X   X   and   Y   Y   Y   .  Symmetric case  In symmetric case, what we want is equal bitrate for the two sources: 5 bits each with separate encoder and joint decoder. We still use linear codes for this system, as we used for asymmetric case. The basic idea is similar, but in this case, we need to do coset partition for both sources, while for a pair of received syndromes (corresponds to one coset), only one pair of input variables are possible given the correlation between two sources.  Suppose we have a pair of linear code     ğ‚  ğŸ     subscript  ğ‚  1    \mathbf{C_{1}}   and    ğ‚  ğŸ     subscript  ğ‚  2    \mathbf{C_{2}}   and an encoder-decoder pair based on linear codes which can achieve symmetric coding. The encoder output is given by     ğ¬  ğŸ   =    ğ‡  ğŸ   ğ±        subscript  ğ¬  1      subscript  ğ‡  1   ğ±     \mathbf{s_{1}}=\mathbf{H_{1}}\mathbf{x}   and     ğ¬  ğŸ   =    ğ‡  ğŸ   ğ²        subscript  ğ¬  2      subscript  ğ‡  2   ğ²     \mathbf{s_{2}}=\mathbf{H_{2}}\mathbf{y}   . If there exists two pair of valid inputs     ğ±  ğŸ   ,   ğ²  ğŸ       subscript  ğ±  1    subscript  ğ²  1     \mathbf{x_{1}},\mathbf{y_{1}}   and     ğ±  ğŸ   ,   ğ²  ğŸ       subscript  ğ±  2    subscript  ğ²  2     \mathbf{x_{2}},\mathbf{y_{2}}   generating the same syndromes, i.e.      ğ‡  ğŸ    ğ±  ğŸ    =    ğ‡  ğŸ    ğ±  ğŸ           subscript  ğ‡  1    subscript  ğ±  1       subscript  ğ‡  1    subscript  ğ±  2      \mathbf{H_{1}}\mathbf{x_{1}}=\mathbf{H_{1}}\mathbf{x_{2}}   and      ğ‡  ğŸ    ğ²  ğŸ    =    ğ‡  ğŸ    ğ²  ğŸ           subscript  ğ‡  1    subscript  ğ²  1       subscript  ğ‡  1    subscript  ğ²  2      \mathbf{H_{1}}\mathbf{y_{1}}=\mathbf{H_{1}}\mathbf{y_{2}}   , we can get following(    w   (  )       w     w()   represents Hamming weight):       ğ²  ğŸ   =    ğ±  ğŸ   +   ğ  ğŸ         subscript  ğ²  1      subscript  ğ±  1    subscript  ğ  1      \mathbf{y_{1}}=\mathbf{x_{1}}+\mathbf{e_{1}}   , where     w   (   ğ  ğŸ   )    â‰¤  1        w   subscript  ğ  1    1    w(\mathbf{e_{1}})\leq 1        ğ²  ğŸ   =    ğ±  ğŸ   +   ğ  ğŸ         subscript  ğ²  2      subscript  ğ±  2    subscript  ğ  2      \mathbf{y_{2}}=\mathbf{x_{2}}+\mathbf{e_{2}}   , where     w   (   ğ  ğŸ   )    â‰¤  1        w   subscript  ğ  2    1    w(\mathbf{e_{2}})\leq 1     Thus      ğ±  ğŸ   +   ğ±  ğŸ    âˆˆ   ğ‚  ğŸ          subscript  ğ±  1    subscript  ğ±  2     subscript  ğ‚  1     \mathbf{x_{1}}+\mathbf{x_{2}}\in\mathbf{C_{1}}         ğ²  ğŸ   +   ğ²  ğŸ    =    ğ±  ğŸ   +   ğ±  ğŸ   +   ğ  ğŸ‘    âˆˆ   ğ‚  ğŸ            subscript  ğ²  1    subscript  ğ²  2       subscript  ğ±  1    subscript  ğ±  2    subscript  ğ  3          subscript  ğ‚  2      \mathbf{y_{1}}+\mathbf{y_{2}}=\mathbf{x_{1}}+\mathbf{x_{2}}+\mathbf{e_{3}}\in%
 \mathbf{C_{2}}     where     ğ  ğŸ‘   =    ğ  ğŸ   +   ğ  ğŸ         subscript  ğ  3      subscript  ğ  2    subscript  ğ  1      \mathbf{e_{3}}=\mathbf{e_{2}}+\mathbf{e_{1}}   and     w   (   ğ  ğŸ‘   )    â‰¤  2        w   subscript  ğ  3    2    w(\mathbf{e_{3}})\leq 2   . That means, as long as we have the minimum distance between the two codes larger than   3   3   3   , we can achieve error-free decoding.  The two codes    ğ‚  ğŸ     subscript  ğ‚  1    \mathbf{C_{1}}   and    ğ‚  ğŸ     subscript  ğ‚  2    \mathbf{C_{2}}   can be constructed as subcodes of the    (  7  ,  4  ,  3  )     7  4  3    (7,4,3)   Hamming code and thus has minimum distance of   3   3   3   . Given the generator matrix    ğ†   ğ†   \mathbf{G}   of the original Hamming code, the generator matrix    ğ†  ğŸ     subscript  ğ†  1    \mathbf{G_{1}}   for    ğ‚  ğŸ     subscript  ğ‚  1    \mathbf{C_{1}}   is constructed by taking any two rows from   ğ†   ğ†   \mathbf{G}   , and    ğ†  ğŸ     subscript  ğ†  2    \mathbf{G_{2}}   is constructed by the remaining two rows of   ğ†   ğ†   \mathbf{G}   . The corresponding    (   5  Ã—  7   )      5  7    (5\times 7)    parity-check matrix for each sub-code can be generated according to the generator matrix and used to generate syndrome bits.  Wynerâ€“Ziv coding â€“ lossy distributed coding  In general, a Wynerâ€“Ziv coding scheme is obtained by adding a quantizer and a de-quantizer to the Slepianâ€“Wolf coding scheme. Therefore, a Wynerâ€“Ziv coder design could focus on the quantizer and corresponding reconstruction method design. Several quantizer designs have been proposed, such as a nested lattice quantizer, 32 trellis code quantizer 33 and Lloyd quantization method. 34  Large scale distributed quantization  Unfortunately, the above approaches do not scale (in design or operational complexity requirements) to sensor networks of large sizes, a scenario where distributed compression is most helpful. If there are N sources transmitting at R bits each (with some distributed coding scheme), the number of possible reconstructions scales    2   N  R      superscript  2    N  R     2^{NR}   . Even for moderate values of N and R (say N=10, R = 2), prior design schemes become impractical. Recently, an approach, 35 using ideas borrowed from Fusion Coding of Correlated Sources, has been proposed where design and operational complexity are traded against decoder performance. This has allowed distributed quantizer design for network sizes reaching 60 sources, with substantial gains over traditional approaches.  The central idea is the presence of a bit-subset selector which maintains a certain subset of the received (NR bits, in the above example) bits for each source. Let   â„¬   â„¬   \mathcal{B}   be the set of all subsets of the NR bits i.e.      â„¬  =   2   {  1  ,  â€¦  ,   N  R   }        â„¬   superscript  2   1  normal-â€¦    N  R       \mathcal{B}=2^{\{1,...,NR\}}     Then, we define the bit-subset selector mapping to be     ğ’®  :    {  1  ,  â€¦  ,  N  }   â†’  â„¬      normal-:  ğ’®   normal-â†’   1  normal-â€¦  N   â„¬     \mathcal{S}:\{1,...,N\}\rightarrow\mathcal{B}     Note that each choice of the bit-subset selector imposes a storage requirement (C) that is exponential in the cardinality of the set of chosen bits.     C  =    âˆ‘   n  =  1   N    2   |   ğ’®   (  n  )    |         C    superscript   subscript     n  1    N    superscript  2      ğ’®  n        C=\sum_{n=1}^{N}2^{|\mathcal{S}(n)|}     This allows a judicious choice of bits that minimize the distortion, given the constraints on decoder storage. Additional limitations on the set of allowable subsets are still needed. The effective cost function that needs to be minimized is a weighted sum of distortion and decoder storage     J  =   D  +   Î»  C        J    D    Î»  C      J=D+\lambda C     The system design is performed by iteratively (and incrementally) optimizing the encoders, decoder and bit-subset selector till convergence.  Non-asymmetric DSC  Non-asymmetric DSC for more than two sources  The syndrome approach can still be used for more than two sources. Let us consider   a   a   a   binary sources of length-   n   n   n         ğ±  1   ,   ğ±  2   ,  â‹¯  ,   ğ±  a    âˆˆ    {  0  ,  1  }   n         subscript  ğ±  1    subscript  ğ±  2   normal-â‹¯   subscript  ğ±  a     superscript   0  1   n     \mathbf{x}_{1},\mathbf{x}_{2},\cdots,\mathbf{x}_{a}\in\{0,1\}^{n}   . Let     ğ‡  1   ,   ğ‡  2   ,  â‹¯  ,   ğ‡  s       subscript  ğ‡  1    subscript  ğ‡  2   normal-â‹¯   subscript  ğ‡  s     \mathbf{H}_{1},\mathbf{H}_{2},\cdots,\mathbf{H}_{s}   be the corresponding coding matrices of sizes      m  1   Ã—  n   ,    m  2   Ã—  n   ,  â‹¯  ,    m  a   Ã—  n         subscript  m  1   n      subscript  m  2   n   normal-â‹¯     subscript  m  a   n     m_{1}\times n,m_{2}\times n,\cdots,m_{a}\times n   . Then the input binary sources are compressed into      ğ¬  1   =    ğ‡  1    ğ±  1     ,     ğ¬  2   =     ğ‡  2    ğ±  2    ,  â‹¯    ,    ğ¬  a   =    ğ‡  a    ğ±  a         formulae-sequence     subscript  ğ¬  1      subscript  ğ‡  1    subscript  ğ±  1      formulae-sequence     subscript  ğ¬  2       subscript  ğ‡  2    subscript  ğ±  2    normal-â‹¯       subscript  ğ¬  a      subscript  ğ‡  a    subscript  ğ±  a        \mathbf{s}_{1}=\mathbf{H}_{1}\mathbf{x}_{1},\mathbf{s}_{2}=\mathbf{H}_{2}%
 \mathbf{x}_{2},\cdots,\mathbf{s}_{a}=\mathbf{H}_{a}\mathbf{x}_{a}   of total    m  =    m  1   +   m  2   +   â‹¯   m  a         m     subscript  m  1    subscript  m  2     normal-â‹¯   subscript  m  a       m=m_{1}+m_{2}+\cdots m_{a}   bits. Apparently, two source tuples cannot be recovered at the same time if they share the same syndrome. In other words, if all source tuples of interest have different syndromes, then one can recover them losslessly.  General theoretical result does not seem to exist. However, for a restricted kind of source so-called Hamming source 36 that only has at most one source different from the rest and at most one bit location not all identical, practical lossless DSC is shown to exist in some cases. For the case when there are more than two sources, the number of source tuple in a Hamming source is     2  n    (    a  n   +  1   )        superscript  2  n       a  n   1     2^{n}(an+1)   . Therefore, a packing bound that     2  m   â‰¥    2  n    (    a  n   +  1   )         superscript  2  m      superscript  2  n       a  n   1      2^{m}\geq 2^{n}(an+1)   obviously has to satisfy. When the packing bound is satisfied with equality, we may call such code to be perfect (an analogous of perfect code in error correcting code). 37  A simplest set of    a  ,  n  ,  m     a  n  m    a,n,m   to satisfy the packing bound with equality is     a  =  3   ,    n  =  5   ,   m  =  9       formulae-sequence    a  3    formulae-sequence    n  5     m  9      a=3,n=5,m=9   . However, it turns out that such syndrome code does not exist. 38 The simplest (perfect) syndrome code with more than two sources have    n  =  21      n  21    n=21   and    m  =  27      m  27    m=27   . Let        ğ  1   =   (     1â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„1â€„0â€„1â€„1â€„0â€„0â€„0â€„0      0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„0â€„1â€„1â€„1      0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„1â€„0â€„1â€„0â€„1â€„1      0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„0      0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„1      0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„0â€„1     )    ,       subscript  ğ  1     1â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„1â€„0â€„1â€„1â€„0â€„0â€„0â€„0    0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„0â€„1â€„1â€„1    0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„1â€„0â€„1â€„0â€„1â€„1    0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„0    0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„1    0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„0â€„1      \mathbf{Q}_{1}=\begin{pmatrix}1\;0\;0\;0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;1\;0\;1\;%
 1\;0\;0\;0\;0\\
 0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;0\;0\;1\;0\;0\;0\;0\;0\;1\;1\;1\\
 0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;0\;0\;1\;1\;1\;0\;1\;0\;1\;1\\
 0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;0\;1\;0\;0\;1\;1\;1\;1\;0\\
 0\;0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;1\;0\;1\;1\;0\;1\;1\;1\;1\\
 0\;0\;0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;1\;0\;0\;1\;1\;0\;1\end{pmatrix},         ğ  2   =   (     0â€„0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1      1â€„0â€„0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„1â€„1â€„1â€„0â€„0â€„0      0â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„1      1â€„0â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„1â€„1â€„1      0â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1      0â€„0â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1â€„1â€„0â€„1â€„0â€„1â€„1â€„1â€„0     )    ,       subscript  ğ  2     0â€„0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1    1â€„0â€„0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„1â€„1â€„1â€„0â€„0â€„0    0â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„1    1â€„0â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„1â€„1â€„1    0â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1    0â€„0â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1â€„1â€„0â€„1â€„0â€„1â€„1â€„1â€„0      \mathbf{Q}_{2}=\begin{pmatrix}0\;0\;0\;1\;0\;1\;1\;0\;1\;1\;1\;1\;0\;1\;0\;0\;%
 0\;1\;1\;1\;1\\
 1\;0\;0\;0\;1\;0\;1\;1\;0\;1\;1\;1\;1\;0\;1\;1\;1\;1\;0\;0\;0\\
 0\;1\;0\;0\;0\;1\;1\;1\;1\;0\;1\;1\;1\;0\;0\;0\;0\;0\;1\;0\;1\\
 1\;0\;1\;0\;0\;0\;1\;1\;1\;1\;0\;1\;0\;1\;1\;1\;0\;0\;1\;1\;1\\
 0\;1\;0\;1\;0\;0\;1\;1\;1\;1\;1\;0\;0\;0\;1\;0\;1\;1\;0\;1\;1\\
 0\;0\;1\;0\;1\;0\;0\;1\;1\;1\;1\;1\;1\;1\;0\;1\;0\;1\;1\;1\;0\end{pmatrix},         ğ  3   =   (     1â€„0â€„0â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1      1â€„1â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1â€„1      0â€„1â€„1â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1â€„0â€„1â€„1â€„1â€„0      1â€„0â€„1â€„1â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„0â€„1      0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„0â€„1â€„0â€„0      0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„0â€„0â€„1â€„1     )    ,       subscript  ğ  3     1â€„0â€„0â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1    1â€„1â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1â€„1    0â€„1â€„1â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1â€„0â€„1â€„1â€„1â€„0    1â€„0â€„1â€„1â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„0â€„1    0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„0â€„1â€„0â€„0    0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„0â€„0â€„1â€„1      \mathbf{Q}_{3}=\begin{pmatrix}1\;0\;0\;1\;0\;1\;0\;0\;1\;1\;1\;0\;1\;0\;0\;1\;%
 1\;1\;1\;1\;1\\
 1\;1\;0\;0\;1\;0\;0\;0\;0\;1\;1\;1\;0\;0\;1\;1\;1\;1\;1\;1\;1\\
 0\;1\;1\;0\;0\;1\;1\;0\;0\;0\;1\;1\;1\;1\;1\;1\;0\;1\;1\;1\;0\\
 1\;0\;1\;1\;0\;0\;1\;1\;0\;0\;0\;1\;0\;0\;1\;1\;1\;1\;0\;0\;1\\
 0\;1\;0\;1\;1\;0\;1\;1\;1\;0\;0\;0\;1\;0\;0\;1\;1\;0\;1\;0\;0\\
 0\;0\;1\;0\;1\;1\;0\;1\;1\;1\;0\;0\;1\;1\;1\;1\;0\;0\;0\;1\;1\end{pmatrix},       ğ†  =   [  ğŸ  |   ğˆ  9   ]      fragments  G    fragments  normal-[  0  normal-|   subscript  ğˆ  9   normal-]     \mathbf{G}=[\mathbf{0}|\mathbf{I}_{9}]   , and    ğ†  =   (      ğ†  1        ğ†  2        ğ†  3      )       ğ†     subscript  ğ†  1      subscript  ğ†  2      subscript  ğ†  3       \mathbf{G}=\begin{pmatrix}\mathbf{G}_{1}\\
 \mathbf{G}_{2}\\
 \mathbf{G}_{3}\end{pmatrix}   such that     ğ†  1   ,   ğ†  2   ,   ğ†  3       subscript  ğ†  1    subscript  ğ†  2    subscript  ğ†  3     \mathbf{G}_{1},\mathbf{G}_{2},\mathbf{G}_{3}   are any partition of   ğ†   ğ†   \mathbf{G}   .        ğ‡  1   =   (      ğ†  1        ğ  1      )    ,     ğ‡  2   =   (      ğ†  2        ğ  2      )    ,    ğ‡  3   =   (      ğ†  3        ğ  3      )        formulae-sequence     subscript  ğ‡  1      subscript  ğ†  1      subscript  ğ  1       formulae-sequence     subscript  ğ‡  2      subscript  ğ†  2      subscript  ğ  2         subscript  ğ‡  3      subscript  ğ†  3      subscript  ğ  3         \mathbf{H}_{1}=\begin{pmatrix}\mathbf{G}_{1}\\
 \mathbf{Q}_{1}\end{pmatrix},\mathbf{H}_{2}=\begin{pmatrix}\mathbf{G}_{2}\\
 \mathbf{Q}_{2}\end{pmatrix},\mathbf{H}_{3}=\begin{pmatrix}\mathbf{G}_{3}\\
 \mathbf{Q}_{3}\end{pmatrix}   can compress a Hamming source (i.e., sources that have no more than one bit different will all have different syndromes). 39 For example, for the symmetric case, a possible set of coding matrices are      ğ‡  1   =   (     0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0      0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0      0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1      1â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„1â€„0â€„1â€„1â€„0â€„0â€„0â€„0      0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„0â€„1â€„1â€„1      0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„1â€„0â€„1â€„0â€„1â€„1      0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„0      0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„1      0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„0â€„1     )    ,       subscript  ğ‡  1     0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0    0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0    0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1    1â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„1â€„0â€„1â€„1â€„0â€„0â€„0â€„0    0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„0â€„1â€„1â€„1    0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„1â€„0â€„1â€„0â€„1â€„1    0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„0    0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„1    0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„0â€„1      \mathbf{H}_{1}=\begin{pmatrix}0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;%
 0\;0\;1\;0\;0\\
 0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;0\\
 0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\\
 1\;0\;0\;0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;1\;0\;1\;1\;0\;0\;0\;0\\
 0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;0\;0\;1\;0\;0\;0\;0\;0\;1\;1\;1\\
 0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;0\;0\;1\;1\;1\;0\;1\;0\;1\;1\\
 0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;0\;1\;0\;0\;1\;1\;1\;1\;0\\
 0\;0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;1\;0\;1\;1\;0\;1\;1\;1\;1\\
 0\;0\;0\;0\;0\;1\;0\;0\;0\;0\;1\;1\;0\;0\;1\;0\;0\;1\;1\;0\;1\end{pmatrix},         ğ‡  2   =   (     0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„0      0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0      0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0      0â€„0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1      1â€„0â€„0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„1â€„1â€„1â€„0â€„0â€„0      0â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„1      1â€„0â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„1â€„1â€„1      0â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1      0â€„0â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1â€„1â€„0â€„1â€„0â€„1â€„1â€„1â€„0     )    ,       subscript  ğ‡  2     0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„0    0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0    0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0    0â€„0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1    1â€„0â€„0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„1â€„1â€„1â€„0â€„0â€„0    0â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„1    1â€„0â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„1â€„1â€„1    0â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1    0â€„0â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1â€„1â€„0â€„1â€„0â€„1â€„1â€„1â€„0      \mathbf{H}_{2}=\begin{pmatrix}0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;%
 0\;0\;0\;0\;0\\
 0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;0\;0\;0\;0\\
 0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;0\;0\;0\\
 0\;0\;0\;1\;0\;1\;1\;0\;1\;1\;1\;1\;0\;1\;0\;0\;0\;1\;1\;1\;1\\
 1\;0\;0\;0\;1\;0\;1\;1\;0\;1\;1\;1\;1\;0\;1\;1\;1\;1\;0\;0\;0\\
 0\;1\;0\;0\;0\;1\;1\;1\;1\;0\;1\;1\;1\;0\;0\;0\;0\;0\;1\;0\;1\\
 1\;0\;1\;0\;0\;0\;1\;1\;1\;1\;0\;1\;0\;1\;1\;1\;0\;0\;1\;1\;1\\
 0\;1\;0\;1\;0\;0\;1\;1\;1\;1\;1\;0\;0\;0\;1\;0\;1\;1\;0\;1\;1\\
 0\;0\;1\;0\;1\;0\;0\;1\;1\;1\;1\;1\;1\;1\;0\;1\;0\;1\;1\;1\;0\end{pmatrix},         ğ‡  3   =   (     0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0      0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„0â€„0â€„0      0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„0â€„0      1â€„0â€„0â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1      1â€„1â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1â€„1      0â€„1â€„1â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1â€„0â€„1â€„1â€„1â€„0      1â€„0â€„1â€„1â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„0â€„1      0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„0â€„1â€„0â€„0      0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„0â€„0â€„1â€„1     )    .       subscript  ğ‡  3     0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0    0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„0â€„0â€„0    0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„0â€„0    1â€„0â€„0â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1    1â€„1â€„0â€„0â€„1â€„0â€„0â€„0â€„0â€„1â€„1â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1â€„1    0â€„1â€„1â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„1â€„1â€„1â€„1â€„1â€„1â€„0â€„1â€„1â€„1â€„0    1â€„0â€„1â€„1â€„0â€„0â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„0â€„1    0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„0â€„1â€„0â€„0â€„1â€„1â€„0â€„1â€„0â€„0    0â€„0â€„1â€„0â€„1â€„1â€„0â€„1â€„1â€„1â€„0â€„0â€„1â€„1â€„1â€„1â€„0â€„0â€„0â€„1â€„1      \mathbf{H}_{3}=\begin{pmatrix}0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;0\;0\;0\;%
 0\;0\;0\;0\;0\\
 0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;0\;0\;0\;0\;0\;0\;0\\
 0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;1\;0\;0\;0\;0\;0\;0\\
 1\;0\;0\;1\;0\;1\;0\;0\;1\;1\;1\;0\;1\;0\;0\;1\;1\;1\;1\;1\;1\\
 1\;1\;0\;0\;1\;0\;0\;0\;0\;1\;1\;1\;0\;0\;1\;1\;1\;1\;1\;1\;1\\
 0\;1\;1\;0\;0\;1\;1\;0\;0\;0\;1\;1\;1\;1\;1\;1\;0\;1\;1\;1\;0\\
 1\;0\;1\;1\;0\;0\;1\;1\;0\;0\;0\;1\;0\;0\;1\;1\;1\;1\;0\;0\;1\\
 0\;1\;0\;1\;1\;0\;1\;1\;1\;0\;0\;0\;1\;0\;0\;1\;1\;0\;1\;0\;0\\
 0\;0\;1\;0\;1\;1\;0\;1\;1\;1\;0\;0\;1\;1\;1\;1\;0\;0\;0\;1\;1\end{pmatrix}.     See also   Linear code  Syndrome decoding  Low-density parity-check code  Turbo Code   References  "  Category:Information theory  Category:Coding theory  Category:Wireless sensor network  Category:Data transmission     "Distributed source coding for sensor networks" by Z. Xiong, A.D. Liveris, and S. Cheng â†©  [ http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?tp =&arnumber;=1657820&isnumber;=34703 "Distributed video coding in wireless sensor networks" by Puri, R. Majumdar, A. Ishwar, P. Ramchandran, K. ] â†©  "Noiseless coding of correlated information sources" by D. Slepian and J. Wolf â†©  "A proof of the data compression theorem of Slepian and Wolf for ergodic sources" by T. Cover â†©  [ http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?tp =&arnumber;=1055508 "The rate-distortion function for source coding with side information at the decoder" by A. Wyner and J. Ziv] â†©  "Recent results in Shannon theory" by A. D. Wyner â†©  [ http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?tp =&arnumber;=1055508 "Distributed source coding using syndromes (DISCUS): design and construction" by S. S. Pradhan and K. Ramchandran] â†©  "Distributed source coding: symmetric rates and applications to sensor networks" by S. S. Pradhan and K. Ramchandran â†©   "Distributed code constructions for the entire Slepianâ€“Wolf rate region for arbitrarily correlated sources" by Schonberg, D. Ramchandran, K. Pradhan, S.S. â†©  "Generalized coset codes for distributed binning" by Pradhan, S.S. Ramchandran, K. â†©  "Nested linear/lattice codes for Wynerâ€“Ziv encoding" by R. Zamir and S. Shamai â†©  "Distributed Video Coding" by B. Girod, etc. â†©  "On code design for the Slepianâ€“Wolf problem and lossless multiterminal networks" by Stankovic, V. Liveris, A.D. Zixiang Xiong Georghiades, C.N. â†©  "A general and optimal framework to achieve the entire rate region for Slepianâ€“Wolf coding" by P. Tan and J. Li â†©  "Distributed source coding using short to moderate length rate-compatible LDPC codes: the entire Slepianâ€“Wolf rate region" by Sartipi, M. Fekri, F. â†©  [ http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?isnumber=4895364&arnumber; ;=4895396&count;=299&index;=31 "A distributed source coding framework for multiple sources" by Xiaomin Cao and Kuijper, M.] â†©  1 "Distributed Source Coding via Linear Block Codes: A General Framework for Multiple Sources" by Xiaomin Cao and Kuijper, M. â†©          "Coset codes. I. Introduction and geometrical classification" by G. D. Forney â†©    "Design of trellis codes for source coding with side information at the decoder" by X. Wang and M. Orchard â†©  "Design of Slepianâ€“Wolf codes by channel code partitioning" by V. Stankovic, A. D. Liveris, Z. Xiong and C. N. Georghiades â†©  "Nested quantization and Slepianâ€“Wolf coding: a Wynerâ€“Ziv coding paradigm for i.i.d. sources" by Z. Xiong, A. D. Liveris, S. Cheng and Z. Liu â†©  "Wynerâ€“Ziv coding based on TCQ and LDPC codes" by Y. Yang, S. Cheng, Z. Xiong and W. Zhao â†©  "Design of optimal quantizers for distributed source coding" by D. Rebollo-Monedero, R. Zhang and B. Girod â†©  "Towards large scale distributed source coding" by S. Ramaswamy, K. Viswanatha, A. Saxena and K. Rose â†©  "Hamming Codes for Multiple Sources" by R. Ma and S. Cheng â†©   "The Non-existence of Length-5 Slepianâ€“Wolf Codes of Three Sources" by S. Cheng and R. Ma â†©      