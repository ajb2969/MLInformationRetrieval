<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="430">Polar decomposition</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Polar decomposition</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, particularly in <a href="linear_algebra" title="wikilink">linear algebra</a> and <a href="functional_analysis" title="wikilink">functional analysis</a>, the <strong>polar decomposition</strong> of a <a href="matrix_(mathematics)" title="wikilink">matrix</a> or <a href="linear_operator" title="wikilink">linear operator</a> is a <a href="matrix_decomposition" title="wikilink">factorization</a> analogous to the <a href="Complex_number#Polar_form" title="wikilink">polar form</a> of a nonzero <a href="complex_number" title="wikilink">complex number</a> <em>z</em> as 

<math display="inline" id="Polar_decomposition:0">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <mpadded width="+1.7pt">
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>i</mi>
       <mi>θ</mi>
      </mrow>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>r</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=re^{i\theta}\,
  </annotation>
 </semantics>
</math>

 where <em>r</em> is the <a href="absolute_value#Complex_numbers" title="wikilink">absolute value</a> of <em>z</em> (a <a href="Positive_number" title="wikilink">positive</a> <a href="real_number" title="wikilink">real number</a>), and 

<math display="inline" id="Polar_decomposition:1">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mi>i</mi>
    <mi>θ</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{i\theta}
  </annotation>
 </semantics>
</math>

 is an element of the <a href="circle_group" title="wikilink">circle group</a>.</p>
<h2 id="matrix-polar-decomposition">Matrix polar decomposition</h2>

<p>The <strong>polar decomposition</strong> of a square complex matrix <em>A</em> is a <a href="matrix_decomposition" title="wikilink">matrix decomposition</a> of the form</p>

<p>

<math display="block" id="Polar_decomposition:2">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <mpadded width="+1.7pt">
     <mi>P</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=UP\,
  </annotation>
 </semantics>
</math>

 where <em>U</em> is a <a href="unitary_matrix" title="wikilink">unitary matrix</a> and <em>P</em> is a <a href="positive-semidefinite_matrix" title="wikilink">positive-semidefinite</a> <a href="Hermitian_matrix" title="wikilink">Hermitian matrix</a>. Intuitively, the polar decomposition separates <em>A</em> into a component that stretches the space along a set of orthogonal axes, represented by <em>P</em>, and a rotation (with possible reflection) represented by <em>U</em>. The decomposition of the <a href="complex_conjugate" title="wikilink">complex conjugate</a> of 

<math display="inline" id="Polar_decomposition:3">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is given by 

<math display="inline" id="Polar_decomposition:4">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>A</mi>
    <mo>¯</mo>
   </mover>
   <mo>=</mo>
   <mover accent="true">
    <mi>U</mi>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{A}=\overline{U}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Polar_decomposition:5">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{P}
  </annotation>
 </semantics>
</math>

.</p>

<p>This decomposition always exists; and so long as <em>A</em> is <a href="invertible_matrix" title="wikilink">invertible</a>, it is unique, with <em>P</em> <a href="positive-definite_matrix" title="wikilink">positive-definite</a>. Note that</p>

<p>

<math display="block" id="Polar_decomposition:6">
 <semantics>
  <mrow>
   <mrow>
    <mo movablelimits="false">det</mo>
    <mi>A</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo movablelimits="false">det</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>U</mi>
     </mpadded>
     <mrow>
      <mo movablelimits="false">det</mo>
      <mi>P</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>i</mi>
      <mi>θ</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <determinant></determinant>
      <ci>A</ci>
     </apply>
     <apply>
      <determinant></determinant>
      <apply>
       <times></times>
       <ci>U</ci>
       <apply>
        <determinant></determinant>
        <ci>P</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>r</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>θ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \det A=\det U\,\det P=re^{i\theta}
  </annotation>
 </semantics>
</math>

 gives the corresponding polar decomposition of the <a class="uri" href="determinant" title="wikilink">determinant</a> of <em>A</em>, since 

<math display="inline" id="Polar_decomposition:7">
 <semantics>
  <mrow>
   <mrow>
    <mo>det</mo>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo>det</mo>
     <mi>A</mi>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <determinant></determinant>
      <ci>P</ci>
     </apply>
     <ci>r</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <abs></abs>
      <apply>
       <determinant></determinant>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \det P=r=|\det A|
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Polar_decomposition:8">
 <semantics>
  <mrow>
   <mrow>
    <mo>det</mo>
    <mi>U</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mi>i</mi>
     <mi>θ</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <determinant></determinant>
     <ci>U</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \det U=e^{i\theta}
  </annotation>
 </semantics>
</math>

.</p>

<p>The matrix <em>P</em> is always unique, even if <em>A</em> is singular, and given by</p>

<p>

<math display="block" id="Polar_decomposition:9">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <msup>
      <mi>A</mi>
      <mo>*</mo>
     </msup>
     <mi>A</mi>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <root></root>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <times></times>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\sqrt{A^{*}A}
  </annotation>
 </semantics>
</math>

 where <em>A</em>* denotes the <a href="conjugate_transpose" title="wikilink">conjugate transpose</a> of <em>A</em>. This expression is meaningful since a positive-semidefinite Hermitian matrix has a unique positive-semidefinite <a href="Square_root_of_a_matrix" title="wikilink">square root</a>. If <em>A</em> is invertible, then the matrix <em>U</em> is given by</p>

<p>

<math display="block" id="Polar_decomposition:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mo>=</mo>
    <mrow>
     <mi>A</mi>
     <msup>
      <mi>P</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=AP^{-1}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>In terms of the <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> of <em>A</em>, ''A = W Σ V<sup>*''</sup>, one has</p>

<p>

<math display="block" id="Polar_decomposition:11">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mi mathvariant="normal">Σ</mi>
    <mpadded width="+1.7pt">
     <msup>
      <mi>V</mi>
      <mo>*</mo>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>normal-Σ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=V\Sigma V^{*}\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Polar_decomposition:12">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mi>W</mi>
    <mpadded width="+1.7pt">
     <msup>
      <mi>V</mi>
      <mo>*</mo>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <times></times>
     <ci>W</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=WV^{*}\,
  </annotation>
 </semantics>
</math>

 confirming that <em>P</em> is positive-definite and <em>U</em> is unitary. Thus, the existence of the SVD is equivalent to the existence of polar decomposition.</p>

<p>One can also decompose <em>A</em> in the form</p>

<p>

<math display="block" id="Polar_decomposition:13">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>P</mi>
     <mo>′</mo>
    </msup>
    <mpadded width="+1.7pt">
     <mi>U</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=P^{\prime}U\,
  </annotation>
 </semantics>
</math>

 Here <em>U</em> is the same as before and <em>P</em>′ is given by</p>

<p>

<math display="block" id="Polar_decomposition:14">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>P</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>U</mi>
     <mi>P</mi>
     <msup>
      <mi>U</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <mi>A</mi>
      <msup>
       <mi>A</mi>
       <mo>*</mo>
      </msup>
     </mrow>
    </msqrt>
    <mo>=</mo>
    <mrow>
     <mi>W</mi>
     <mi mathvariant="normal">Σ</mi>
     <msup>
      <mi>W</mi>
      <mo>*</mo>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>U</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>W</ci>
      <ci>normal-Σ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>W</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}=UPU^{-1}=\sqrt{AA^{*}}=W\Sigma W^{*}.
  </annotation>
 </semantics>
</math>

 This is known as the left polar decomposition, whereas the previous decomposition is known as the right polar decomposition. Left polar decomposition is also known as reverse polar decomposition.</p>

<p>The matrix <em>A</em> is <a href="normal_matrix" title="wikilink">normal</a> if and only if <em>P</em>′ = <em>P</em>. Then <em>UΣ = ΣU</em>, and it is possible to diagonalise <em>U</em> with a unitary similarity matrix <em>S</em> that commutes with <em>Σ</em>, giving <em>S U S*</em> = <em>Φ<sup>−1</sup></em>, where <em>Φ</em> is a diagonal unitary matrix of phases <em>e<sup>iφ</sup></em>. Putting <em>Q = V S<sup>*</sup></em>, one can then re-write the polar decomposition as</p>

<p>

<math display="block" id="Polar_decomposition:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Q</mi>
       <mi mathvariant="normal">Φ</mi>
       <msup>
        <mi>Q</mi>
        <mo>*</mo>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Q</mi>
       <mi mathvariant="normal">Σ</mi>
       <msup>
        <mi>Q</mi>
        <mo>*</mo>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>normal-Φ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Q</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>normal-Σ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Q</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=(Q\Phi Q^{*})(Q\Sigma Q^{*}),\,
  </annotation>
 </semantics>
</math>

</p>

<p>so <em>A</em> then thus also has a <a href="spectral_decomposition" title="wikilink">spectral decomposition</a></p>

<p>

<math display="block" id="Polar_decomposition:16">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <mi mathvariant="normal">Λ</mi>
    <mpadded width="+1.7pt">
     <msup>
      <mi>Q</mi>
      <mo>*</mo>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>normal-Λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=Q\Lambda Q^{*}\,
  </annotation>
 </semantics>
</math>

 with complex eigenvalues such that <em>ΛΛ<sup>*</sup> = Σ<sup>2</sup></em> and a unitary matrix of complex eigenvectors <em>Q</em>.</p>
<h2 id="bounded-operators-on-hilbert-space">Bounded operators on Hilbert space</h2>

<p>The <strong>polar decomposition</strong> of any <a href="bounded_linear_operator" title="wikilink">bounded linear operator</a> <em>A</em> between complex <a href="Hilbert_space" title="wikilink">Hilbert spaces</a> is a canonical factorization as the product of a <a href="partial_isometry" title="wikilink">partial isometry</a> and a non-negative operator.</p>

<p>The polar decomposition for matrices generalizes as follows: if <em>A</em> is a bounded linear operator then there is a unique factorization of <em>A</em> as a product <em>A</em> = <em>UP</em> where <em>U</em> is a partial isometry, <em>P</em> is a non-negative self-adjoint operator and the initial space of <em>U</em> is the closure of the range of <em>P</em>.</p>

<p>The operator <em>U</em> must be weakened to a partial isometry, rather than unitary, because of the following issues. If <em>A</em> is the <a href="shift_operator" title="wikilink">one-sided shift</a> on <em>l</em><sup>2</sup>(<strong>N</strong>), then |<em>A</em>| = {<em>A*A</em>}<sup>½</sup> = <em>I</em>. So if <em>A</em> = <em>U</em> |<em>A</em>|, <em>U</em> must be <em>A</em>, which is not unitary.</p>

<p>The existence of a polar decomposition is a consequence of <a href="Douglas'_lemma" title="wikilink">Douglas' lemma</a>:</p>
<dl>
<dd><strong>Lemma</strong> If <em>A</em>, <em>B</em> are bounded operators on a Hilbert space <em>H</em>, and <em>A*A</em> ≤ <em>B*B</em>, then there exists a contraction <em>C</em> such that <em>A = CB</em>. Furthermore, <em>C</em> is unique if <em>Ker</em>(<em>B*</em>) ⊂ <em>Ker</em>(<em>C</em>).
</dd>
</dl>

<p>The operator <em>C</em> can be defined by <em>C(Bh)</em> := <em>Ah</em> for all <em>h</em> in <em>H</em>, extended by continuity to the closure of <em>Ran</em>(<em>B</em>), and by zero on the orthogonal complement to all of <em>H</em>. The lemma then follows since <em>A*A</em> ≤ <em>B*B</em> implies <em>Ker</em>(<em>A</em>) ⊂ <em>Ker</em>(<em>B</em>).</p>

<p>In particular. If <em>A*A</em> = <em>B*B</em>, then <em>C</em> is a partial isometry, which is unique if <em>Ker</em>(<em>B*</em>) ⊂ <em>Ker</em>(<em>C</em>). In general, for any bounded operator <em>A</em>,</p>

<p>

<math display="block" id="Polar_decomposition:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>A</mi>
      <mo>*</mo>
     </msup>
     <mi>A</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>A</mi>
         <mo>*</mo>
        </msup>
        <mi>A</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>A</mi>
         <mo>*</mo>
        </msup>
        <mi>A</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <times></times>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <times></times>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <times></times>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{*}A=(A^{*}A)^{\frac{1}{2}}(A^{*}A)^{\frac{1}{2}},
  </annotation>
 </semantics>
</math>

</p>

<p>where (<em>A*A</em>)<sup>½</sup> is the unique positive square root of <em>A*A</em> given by the usual <a href="functional_calculus" title="wikilink">functional calculus</a>. So by the lemma, we have</p>

<p>

<math display="block" id="Polar_decomposition:18">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>A</mi>
        <mo>*</mo>
       </msup>
       <mi>A</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <times></times>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=U(A^{*}A)^{\frac{1}{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>for some partial isometry <em>U</em>, which is unique if <em>Ker</em>(<em>A*</em>) ⊂ <em>Ker</em>(<em>U</em>). Take <em>P</em> to be (<em>A*A</em>)<sup>½</sup> and one obtains the polar decomposition <em>A</em> = <em>UP</em>. Notice that an analogous argument can be used to show ''A = P'U' '', where ''P' '' is positive and ''U' '' a partial isometry.</p>

<p>When <em>H</em> is finite-dimensional, <em>U</em> can be extended to a unitary operator; this is not true in general (see example above). Alternatively, the polar decomposition can be shown using the operator version of <a href="singular_value_decomposition#Bounded_operators_on_Hilbert_spaces" title="wikilink">singular value decomposition</a>.</p>

<p>By property of the <a href="continuous_functional_calculus" title="wikilink">continuous functional calculus</a>, <em>|A|</em> is in the <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a> generated by <em>A</em>. A similar but weaker statement holds for the partial isometry: <em>U</em> is in the <a href="von_Neumann_algebra" title="wikilink">von Neumann algebra</a> generated by <em>A</em>. If <em>A</em> is invertible, the polar part <em>U</em> will be in the <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a> as well.</p>
<h2 id="unbounded-operators">Unbounded operators</h2>

<p>If <em>A</em> is a closed, densely defined <a href="unbounded_operator" title="wikilink">unbounded operator</a> between complex Hilbert spaces then it still has a (unique) <strong>polar decomposition</strong></p>

<p>

<math display="block" id="Polar_decomposition:19">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>A</mi>
     <mo rspace="4.2pt" stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=U|A|\,
  </annotation>
 </semantics>
</math>

</p>

<p>where |<em>A</em>| is a (possibly unbounded) non-negative self adjoint operator with the same domain as <em>A</em>, and <em>U</em> is a partial isometry vanishing on the orthogonal complement of the range <em>Ran</em>(|<em>A</em>|).</p>

<p>The proof uses the same lemma as above, which goes through for unbounded operators in general. If <em>Dom</em>(<em>A*A</em>) = <em>Dom</em>(<em>B*B</em>) and <em>A*Ah</em> = <em>B*Bh</em> for all <em>h</em> ∈ <em>Dom</em>(<em>A*A</em>), then there exists a partial isometry <em>U</em> such that <em>A</em> = <em>UB</em>. <em>U</em> is unique if <em>Ran</em>(<em>B</em>)<sup>⊥</sup>⊂ <em>Ker</em>(<em>U</em>). The operator <em>A</em> being closed and densely defined ensures that the operator <em>A*A</em> is self-adjoint (with dense domain) and therefore allows one to define (<em>A*A</em>)<sup>½</sup>. Applying the lemma gives polar decomposition.</p>

<p>If an unbounded operator <em>A</em> is <a href="affiliated_operator" title="wikilink">affiliated</a> to a von Neumann algebra <strong>M</strong>, and <em>A</em> = <em>UP</em> is its polar decomposition, then <em>U</em> is in <strong>M</strong> and so is the spectral projection of <em>P</em>, 1<sub><em>B</em></sub>(<em>P</em>), for any Borel set <em>B</em> in [0, ∞).</p>
<h2 id="quaternion-polar-decomposition">Quaternion polar decomposition</h2>

<p>The polar decomposition of <a href="quaternion" title="wikilink">quaternions</a> <strong>H</strong> depends on the sphere 

<math display="inline" id="Polar_decomposition:20">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mi>i</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>y</mi>
      <mi>j</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>z</mi>
      <mi>k</mi>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>H</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mi>y</mi>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mi>z</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <times></times>
       <ci>z</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <ci>H</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{xi+yj+zk\in H:x^{2}+y^{2}+z^{2}=1\}
  </annotation>
 </semantics>
</math>

 of <a href="quaternion#Square_roots_of_−1" title="wikilink">square roots of minus one</a>. Given any <em>r</em> on this sphere, and an angle –π e^{ar} = \cos (a) + r\ \sin (a)  is on the <a class="uri" href="3-sphere" title="wikilink">3-sphere</a> of <strong>H</strong>. For <em>a</em> = 0 and <em>a</em> = π, the versor is 1 or −1 regardless of which <em>r</em> is selected. The <a href="norm_(mathematics)" title="wikilink">norm</a> <em>t</em> of a quaternion <em>q</em> is the <a href="Euclidean_distance" title="wikilink">Euclidean distance</a> from the origin to <em>q</em>. When a quaternion is not just a real number, then there is a <em>unique</em> polar decomposition 

<math display="inline" id="Polar_decomposition:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mo>=</mo>
    <mrow>
     <mi>t</mi>
     <mpadded width="-1.7pt">
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>a</mi>
        <mi>r</mi>
       </mrow>
      </msup>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>q</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=te^{ar}\!.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="alternative-planar-decompositions">Alternative planar decompositions</h2>

<p>In the <a href="Cartesian_plane" title="wikilink">Cartesian plane</a>, alternative planar <a href="ring_(mathematics)" title="wikilink">ring</a> decompositions arise as follows:</p>
<ul>
<li>If <em>x</em> ≠ 0, <em>z</em> = <em>x</em> ( 1 + (<em>y</em>/<em>x</em>) ε) is a polar decomposition of a <a href="dual_number" title="wikilink">dual number</a> <em>z</em> = <em>x</em> + <em>y</em> ε, where ε<sup>2</sup> = 0, <em>i.e.</em> ε is <a class="uri" href="nilpotent" title="wikilink">nilpotent</a>. In this polar decomposition, the unit circle has been replaced by the line <em>x</em> = 1, the polar angle by the <a class="uri" href="slope" title="wikilink">slope</a> <em>y/x</em>, and the radius <em>x</em> is negative in the left half-plane.</li>
</ul>
<ul>
<li>If <em>x</em><sup>2</sup> ≠ <em>y</em><sup>2</sup>, then the <a href="unit_hyperbola" title="wikilink">unit hyperbola</a> <em>x</em><sup>2</sup> − <em>y</em><sup>2</sup> = 1 and its conjugate <em>x</em><sup>2</sup> − <em>y</em><sup>2</sup> = −1 can be used to form a polar decomposition based on the branch of the unit hyperbola through (1,0). This branch is parametrized by the <a href="hyperbolic_angle" title="wikilink">hyperbolic angle</a> <em>a</em> and is written</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Polar_decomposition:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>cosh</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>j</mi>
     </mpadded>
     <mrow>
      <mi>sinh</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>j</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mi>a</mi>
     <mi>j</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <cosh></cosh>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>j</ci>
       <apply>
        <sinh></sinh>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <exp></exp>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cosh(a)+j\ \sinh(a)=\exp(aj)=e^{aj}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>where <em>j</em> <sup>2</sup> = +1 and the arithmetic<ref>Sobczyk, G.(1995) "Hyperbolic Number Plane", <em><a href="College_Mathematics_Journal" title="wikilink">College Mathematics Journal</a> 26:268–80</em></ref> of <a href="split-complex_number" title="wikilink">split-complex numbers</a> is used. The branch through (−1,0) is traced by −e''<sup><em>a j</em></sup>. Since the operation of multiplying by j reflects a point across the line <em>y</em> = <em>x</em>, the second hyperbola has branches traced by <em>je</em><sup><em>a j</em></sup> or −<em>je</em><sup><em>a j</em></sup>. Therefore a point in one of the quadrants has a polar decomposition in one of the forms:

<p>

<math display="block" id="Polar_decomposition:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>r</mi>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>a</mi>
       <mi>j</mi>
      </mrow>
     </msup>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>r</mi>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>a</mi>
        <mi>j</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>r</mi>
     <mi>j</mi>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>a</mi>
       <mi>j</mi>
      </mrow>
     </msup>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>r</mi>
      <mi>j</mi>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>a</mi>
        <mi>j</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mi>r</mi>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <list>
     <apply>
      <times></times>
      <ci>r</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>j</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>j</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>r</ci>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   re^{aj},-re^{aj},rje^{aj},-rje^{aj},\quad r>0
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>The set { 1, −1, j, −j } has products that make it isomorphic to the <a href="Klein_four-group" title="wikilink">Klein four-group</a>. Evidently polar decomposition in this case involves an element from that group.
</dd>
</dl>
<h2 id="numerical-determination-of-the-matrix-polar-decomposition">Numerical determination of the matrix polar decomposition</h2>

<p>To compute an approximation of the polar decomposition <em>A</em>=<em>UP</em>, usually the unitary factor <em>U</em> is approximated.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The iteration is based on <a href="Heron's_method" title="wikilink">Heron's method</a> for the square root of <em>1</em> and computes, starting from 

<math display="inline" id="Polar_decomposition:24">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{0}=A
  </annotation>
 </semantics>
</math>

, the sequence</p>

<p>

<math display="block" id="Polar_decomposition:25">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mi>U</mi>
       <mi>k</mi>
      </msub>
      <mo>+</mo>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msubsup>
         <mi>U</mi>
         <mi>k</mi>
         <mo>*</mo>
        </msubsup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <ci>k</ci>
        </apply>
        <times></times>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{k+1}=\frac{1}{2}\left(U_{k}+(U_{k}^{*})^{-1}\right)
  </annotation>
 </semantics>
</math>

, <em>k</em>=0,1,2,... The combination of inversion and Hermite conjugation is chosen so that in the singular value decomposition, the unitary factors remain the same and the iteration reduces to Heron's method on the singular values.</p>

<p>This basic iteration may be refined to speed up the process:</p>
<ul>
<li>Every step or in regular intervals, the range of the singular values of 

<math display="inline" id="Polar_decomposition:26">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{k}
  </annotation>
 </semantics>
</math>

 is estimated and then the matrix is rescaled to 

<math display="inline" id="Polar_decomposition:27">
 <semantics>
  <mrow>
   <msub>
    <mi>γ</mi>
    <mi>k</mi>
   </msub>
   <msub>
    <mi>U</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{k}U_{k}
  </annotation>
 </semantics>
</math>

 to center the singular values around <em>1</em>. The scaling factor 

<math display="inline" id="Polar_decomposition:28">
 <semantics>
  <msub>
   <mi>γ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>γ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{k}
  </annotation>
 </semantics>
</math>

 is computed using matrix norms of the matrix and its inverse. Examples of such scale estimates are:</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p><code> \gamma_k=\sqrt[4\;]{\frac{</code><br/>
<code>   \|U_k^{-1}\|_1\,\|U_k^{-1}\|_\infty</code><br/>
<code>    }{</code><br/>
<code>   \|U_k\|_1\,\|U_k\|_\infty</code><br/>
<code>  } }</code></p>

<p></p>
<dl>
<dd>using the row-sum and column-sum <a href="Induced_norm" title="wikilink">matrix norms</a> or
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p><code> \gamma_k=\sqrt{\frac{\|U_k^{-1}\|_F}{\|U_k\|_F}}</code></p>

<p></p>
<dl>
<dd>using the <a href="Frobenius_norm" title="wikilink">Frobenius norm</a>. Including the scale factor, the iteration is now
</dd>
<dd>

<math display="inline" id="Polar_decomposition:29">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>γ</mi>
        <mi>k</mi>
       </msub>
       <msub>
        <mi>U</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <msub>
         <mi>γ</mi>
         <mi>k</mi>
        </msub>
       </mfrac>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msubsup>
          <mi>U</mi>
          <mi>k</mi>
          <mo>*</mo>
         </msubsup>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>γ</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>U</ci>
          <ci>k</ci>
         </apply>
         <times></times>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{k+1}=\frac{1}{2}\left(\gamma_{k}U_{k}+\frac{1}{\gamma_{k}}(U_{k}^{*})^{-1}\right)
  </annotation>
 </semantics>
</math>

, <em>k</em>=0,1,2,...
</dd>
</dl>
<ul>
<li>The <a href="QR_decomposition" title="wikilink">QR decomposition</a> can be used in a preparation step to reduce a singular matrix <em>A</em> to a smaller regular matrix, and inside every step to speed up the computation of the inverse.</li>
</ul>
<ul>
<li>Heron' method for computing roots of 

<math display="inline" id="Polar_decomposition:30">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}-1=0
  </annotation>
 </semantics>
</math>

 can be replaced by higher order methods, for instance based on <a href="Halley's_method" title="wikilink">Halley's method</a> of third order, resulting in</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Polar_decomposition:31">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>k</mi>
    </msub>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>I</mi>
       <mo>+</mo>
       <mrow>
        <mpadded width="+1.7pt">
         <mn>3</mn>
        </mpadded>
        <msubsup>
         <mi>U</mi>
         <mi>k</mi>
         <mo>*</mo>
        </msubsup>
        <msub>
         <mi>U</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mpadded width="+1.7pt">
        <mn>3</mn>
       </mpadded>
       <mi>I</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msubsup>
        <mi>U</mi>
        <mi>k</mi>
        <mo>*</mo>
       </msubsup>
       <msub>
        <mi>U</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>I</ci>
       <apply>
        <times></times>
        <cn type="integer">3</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>U</ci>
          <ci>k</ci>
         </apply>
         <times></times>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>I</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <ci>k</ci>
        </apply>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{k+1}=U_{k}\left(I+3\,U_{k}^{*}U_{k}\right)^{-1}\left(3\,I+U_{k}^{*}U_{k}\right)
  </annotation>
 </semantics>
</math>

, <em>k</em>=0,1,2,...
</dd>
</dl>
</dd>
<dd>This iteration can again be combined with rescaling. This particular formula has the benefit that it also applicable to singular or rectangular matrices <em>A</em>.
</dd>
</dl>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Cartan_decomposition" title="wikilink">Cartan decomposition</a></li>
<li><a href="Matrix_decomposition#Algebraic_polar_decomposition" title="wikilink">Algebraic polar decomposition</a></li>
</ul>
<h2 id="references">References</h2>
<references>

<p><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
</references>
<h2 id="literature">Literature</h2>
<ul>
<li><a href="John_B._Conway" title="wikilink">Conway, J.B.</a>: A Course in Functional Analysis. <a href="Graduate_Texts_in_Mathematics" title="wikilink">Graduate Texts in Mathematics</a>. New York: Springer 1990</li>
<li><a href="Ronald_G._Douglas" title="wikilink">Douglas, R.G.</a>: On Majorization, Factorization, and Range Inclusion of Operators on Hilbert Space. <a href="Proceedings_of_the_American_Mathematical_Society" title="wikilink">Proc. Amer. Math. Soc.</a> <strong>17</strong>, 413-415 (1966)</li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.continuummechanics.org/cm/polardecomposition.html">Polar Decomposition</a> on <a href="http://www.continuummechanics.org/">www.continuummechanics.org</a></li>
</ul>

<p>"</p>

<p><a href="Category:Lie_groups" title="wikilink">Category:Lie groups</a> <a href="Category:Operator_theory" title="wikilink">Category:Operator theory</a> <a href="Category:Matrix_theory" title="wikilink">Category:Matrix theory</a> <a href="Category:Matrix_decompositions" title="wikilink">Category:Matrix decompositions</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
