<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="993">Double hashing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Double hashing</h1>
<hr/>

<p><strong>Double hashing</strong> is a <a href="computer_programming" title="wikilink">computer programming</a> technique used in <a href="hash_table" title="wikilink">hash tables</a> to resolve <a href="hash_collision" title="wikilink">hash collisions</a>, cases when two different values to be searched for produce the same hash key. It is a popular <a href="hash_collision" title="wikilink">collision</a>-resolution technique in <a href="open_addressing" title="wikilink">open-addressed</a> hash tables. Double hashing is implemented in many popular <a href="library_(computing)" title="wikilink">libraries</a>.</p>

<p>Like <a href="linear_probing" title="wikilink">linear probing</a>, it uses one hash value as a starting point and then repeatedly steps forward an interval until the desired value is located, an empty location is reached, or the entire table has been searched; but this interval is decided using a second, independent hash function (hence the name double hashing). Unlike <a href="linear_probing" title="wikilink">linear probing</a> and <a href="quadratic_probing" title="wikilink">quadratic probing</a>, the interval depends on the data, so that even values mapping to the same location have different bucket sequences; this minimizes repeated collisions and the effects of clustering.</p>

<p>Given two randomly, uniformly, and independently selected hash functions 

<math display="inline" id="Double_hashing:0">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Double_hashing:1">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}
  </annotation>
 </semantics>
</math>

, the <em>i</em>th location in the bucket sequence for value <em>k</em> in a hash table 

<math display="inline" id="Double_hashing:2">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is

<math display="block" id="Double_hashing:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>h</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mo>⋅</mo>
         <msub>
          <mi>h</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>T</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>k</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>i</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(i,k)=(h_{1}(k)+i\cdot h_{2}(k))\mod|T|.
  </annotation>
 </semantics>
</math>

 Generally, 

<math display="inline" id="Double_hashing:4">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Double_hashing:5">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}
  </annotation>
 </semantics>
</math>

 are selected from a set of <a href="universal_hash" title="wikilink">universal hash</a> functions.</p>
<h2 id="classical-applied-data-structure">Classical applied data structure</h2>

<p>Double hashing with open addressing is a classical data structure on a table 

<math display="inline" id="Double_hashing:6">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Double_hashing:7">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 be the number of elements stored in 

<math display="inline" id="Double_hashing:8">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Double_hashing:9">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

's load factor is 

<math display="inline" id="Double_hashing:10">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mfrac>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>T</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <apply>
      <abs></abs>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=\frac{n}{|T|}
  </annotation>
 </semantics>
</math>

.</p>

<p>Double hashing approximates uniform open address hashing. That is, start by randomly, uniformly and independently selecting two <a href="universal_hash" title="wikilink">universal hash</a> functions 

<math display="inline" id="Double_hashing:11">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Double_hashing:12">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}
  </annotation>
 </semantics>
</math>

 to build a double hashing table 

<math display="inline" id="Double_hashing:13">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</p>

<p>All elements are put in 

<math display="inline" id="Double_hashing:14">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 by double hashing using 

<math display="inline" id="Double_hashing:15">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Double_hashing:16">
 <semantics>
  <msub>
   <mi>h</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}
  </annotation>
 </semantics>
</math>

. Given a key 

<math display="inline" id="Double_hashing:17">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, determining the 

<math display="inline" id="Double_hashing:18">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>i</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i+1)
  </annotation>
 </semantics>
</math>

-st hash location is computed by:</p>

<p>

<math display="inline" id="Double_hashing:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>h</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mo>⋅</mo>
         <msub>
          <mi>h</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>k</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>T</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>k</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>i</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(i,k)=(h_{1}(k)+i\cdot h_{2}(k))\mod|T|.
  </annotation>
 </semantics>
</math>

</p>

<p>Let 

<math display="inline" id="Double_hashing:20">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 have fixed load factor 

<math display="inline" id="Double_hashing:21">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>:</mo>
   <mrow>
    <mn>1</mn>
    <mo>></mo>
    <mi>α</mi>
    <mo>></mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>α</ci>
    <apply>
     <and></and>
     <apply>
      <gt></gt>
      <cn type="integer">1</cn>
      <ci>α</ci>
     </apply>
     <apply>
      <gt></gt>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha:1>\alpha>0
  </annotation>
 </semantics>
</math>

. Bradford and <a href="Michael_N._Katehakis" title="wikilink">Katehakis</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> showed the expected number of probes for an unsuccessful search in 

<math display="inline" id="Double_hashing:22">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, still using these initially chosen hash functions, is 

<math display="inline" id="Double_hashing:23">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>α</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{1-\alpha}
  </annotation>
 </semantics>
</math>

 regardless of the distribution of the inputs. More precisely, these two uniformly, randomly and independently chosen hash functions are chosen from a set of <a href="universal_hash" title="wikilink">universal hash</a> functions where pair-wise independence suffices.</p>

<p>Previous results include: Guibas and Szemerédi<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> showed 

<math display="inline" id="Double_hashing:24">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>α</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{1-\alpha}
  </annotation>
 </semantics>
</math>

 holds for unsuccessful search for load factors 

<math display="inline" id="Double_hashing:25">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo><</mo>
   <mn>0.319</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>α</ci>
    <cn type="float">0.319</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha<0.319
  </annotation>
 </semantics>
</math>

. Also, Lueker and Molodowitch<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> showed this held assuming ideal randomized functions. Schmidt and Siegel<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> showed this with 

<math display="inline" id="Double_hashing:26">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-wise independent and uniform functions (for 

<math display="inline" id="Double_hashing:27">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>c</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=c\log n
  </annotation>
 </semantics>
</math>

, and suitable constant 

<math display="inline" id="Double_hashing:28">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

).</p>
<h2 id="implementation-details-for-caching">Implementation details for caching</h2>

<p>Linear probing and, to a lesser extent, quadratic probing are able to take advantage of the data cache by accessing locations that are close together. Double hashing has, on average, larger intervals and is not able to achieve this advantage.</p>

<p>Like all other forms of open addressing, double hashing becomes linear as the hash table approaches maximum capacity. The only solution to this is to rehash to a larger size, as with all other open addressing schemes.</p>

<p>On top of that, it is possible for the secondary hash function to evaluate to zero. For example, if we choose k=5 with the following function:</p>

<p>

<math display="inline" id="Double_hashing:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>5</mn>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
      <mn>7</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">5</cn>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <ci>k</ci>
      <cn type="integer">7</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}(k)=5-(k\mod 7)
  </annotation>
 </semantics>
</math>

</p>

<p>The resulting sequence will always remain at the initial hash value. One possible solution is to change the secondary hash function to:</p>

<p>

<math display="inline" id="Double_hashing:30">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
      <mn>7</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <ci>k</ci>
      <cn type="integer">7</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{2}(k)=(k\mod 7)+1
  </annotation>
 </semantics>
</math>

</p>

<p>This ensures that the secondary hash function will always be non zero.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Hash_table#Collision_resolution" title="wikilink">Hash_table#Collision_resolution</a></li>
<li><a href="Hash_function" title="wikilink">Hash function</a></li>
<li><a href="Linear_probing" title="wikilink">Linear probing</a></li>
<li><a href="Cuckoo_hashing" title="wikilink">Cuckoo hashing</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.siam.org/meetings/alenex05/papers/13gheileman.pdf">How Caching Affects Hashing</a> by Gregory L. Heileman and Wenbin Luo 2005.</li>
<li><a href="http://www.cs.pitt.edu/~kirk/cs1501/animations/Hashing.html">Hash Table Animation</a></li>
<li><a href="https://github.com/attractivechaos/klib">klib</a> a C library that includes double hashing functionality.</li>
</ul>

<p>"</p>

<p><a href="Category:Search_algorithms" title="wikilink">Category:Search algorithms</a> <a class="uri" href="Category:Hashing" title="wikilink">Category:Hashing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">P. G. Bradford and M. Katehakis: <em>A Probabilistic Study on Combinatorial Expanders and Hashing</em>, SIAM Journal on Computing 2007 (37:1), 83-111. <a class="uri" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.91.2647">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.91.2647</a><a href="#fnref1">↩</a></li>
<li id="fn2">L. Guibas and E. Szemerédi: <em>The Analysis of Double Hashing</em>, Journal of Computer and System Sciences, 1978, 16, 226-274.<a href="#fnref2">↩</a></li>
<li id="fn3">G. S. Lueker and M. Molodowitch: <em>More Analysis of Double Hashing</em>, Combinatorica, 1993, 13(1), 83-96.<a href="#fnref3">↩</a></li>
<li id="fn4">J. P. Schmidt and A. Siegel: <em>Double Hashing is Computable and Randomizable with Universal Hash Functions</em>, manuscript.<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
