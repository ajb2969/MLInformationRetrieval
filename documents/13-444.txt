   Decision tree model      Decision tree model   In computational complexity and communication complexity theories the decision tree model is the model of computation or communication in which an algorithm or communication process is considered to be basically a decision tree , i.e., a sequence of branching operations based on comparisons of some quantities, the comparisons being assigned the unit computational cost.  The branching operations are called "tests" or "queries". In this setting the algorithm in question may be viewed as a computation of a Boolean function     f  :     {  0  ,  1  }   n   →   {  0  ,  1  }       normal-:  f   normal-→   superscript   0  1   n    0  1      f:\{0,1\}^{n}\rightarrow\{0,1\}   where the input is a series of queries and the output is the final decision. Every query is dependent on previous queries.  Several variants of decision tree models have been introduced, depending on the complexity of the operations allowed in the computation of a single comparison and the way of branching.  Decision trees models are instrumental in establishing lower bounds for computational complexity for certain classes of computational problems and algorithms: the lower bound for worst-case computational complexity is proportional to the largest depth among the decision trees for all possible inputs for a given computational problem. The computation complexity of a problem or an algorithm expressed in terms of the decision tree model is called decision tree complexity or query complexity .  Classification by query computational complexity  Simple decision tree  The model in which every decision is based on the comparison of two numbers within constant time is called simply a decision tree model. It was introduced to establish computational complexity of sorting and searching. 1  The simplest illustration of this lower bound technique is for the problem of finding the smallest number among n numbers using only comparisons. In this case the decision tree model is a binary tree . Algorithms for this searching problem may result in n different outcomes (since any of the n given numbers may turn out to be the smallest one). It is known that the depth of a binary tree with n  leaves is at least    log  n      n    \log n   , which gives a lower bound of    Ω   (   log  n   )       normal-Ω    n     \Omega(\log n)   for the searching problem.  However this lower bound is known to be slack, since the following simple argument shows that at least n - 1 comparisons are needed: Before the smallest number can be determined, every number except the smallest must "lose" (compare greater) in at least one comparison.  Along the same lines the lower bound of    Ω   (   n   log  n    )       normal-Ω    n    n      \Omega(n\log n)   for sorting may be proved. In this case, the existence of numerous comparison-sorting algorithms having this time complexity, such as mergesort and heapsort , demonstrates that the bound is tight.  Linear decision tree  Linear decision trees, just like the simple decision trees, make a branching decision based on a set of values as input. As opposed to binary decision trees, linear decision trees have three output branches. A linear function    f   (   x  1   ,  …  ,   x  i   )       f    subscript  x  1   normal-…   subscript  x  i      f(x_{1},\dots,x_{i})   is being tested and branching decisions are made based on the sign of the function (negative, positive, or 0).  Geometrically,    f   (  x  )       f  x    f(x)   defines a hyperplane in R n . A set of input values reaching any particular nodes represents the intersection of the half-planes defined by the nodes.  Algebraic decision tree  Algebraic decision trees are a generalization of linear decision trees to allow test functions to be polynomials of degree d . Geometrically, the space is divided into semi-algebraic sets (a generalization of hyperplane). The evaluation of the complexity is more difficult.  Classification by query computational model  Deterministic decision tree  If the output of a decision tree is    f   (  x  )       f  x    f(x)   , for all    x  ∈    {  0  ,  1  }   n       x   superscript   0  1   n     x\in\{0,1\}^{n}   , the decision tree is said to "compute"   f   f   f   . The depth of a tree is the maximum number of queries that can happen before a leaf is reached and a result obtained.     D   (  f  )       D  f    D(f)    , the deterministic decision tree complexity of   f   f   f   is the smallest depth among all deterministic decision trees that compute   f   f   f   .  Randomized decision tree  One way to define a randomized decision tree is to add additional nodes to the tree, each controlled by a probability    p  i     subscript  p  i    p_{i}   . Another equivalent definition is to select a whole decision tree at the beginning from a set of decision trees based on a probability distribution. Based on this second definition, the complexity of the randomized tree is defined as the greatest depth among all the trees associated with probabilities greater than 0.      R  2    (  f  )        subscript  R  2   f    R_{2}(f)    is defined as the complexity of the lowest-depth randomized decision tree whose result is    f   (  x  )       f  x    f(x)   with probability at least    2  /  3      2  3    2/3   for all    x  ∈    {  0  ,  1  }   n       x   superscript   0  1   n     x\in\{0,1\}^{n}   (i.e., with bounded 2-sided error).       R  2    (  f  )        subscript  R  2   f    R_{2}(f)    is known as the Monte Carlo randomized decision-tree complexity, because the result is allowed to be incorrect with bounded two-sided error. The Las Vegas decision-tree complexity      R  0    (  f  )        subscript  R  0   f    R_{0}(f)    measures the expected depth of a decision tree that must be correct (i.e., has zero-error). There is also a one-sided bounded-error version known as      R  1    (  f  )        subscript  R  1   f    R_{1}(f)    .  Nondeterministic decision tree  The nondeterministic decision tree complexity of a function is known more commonly as the certificate complexity of that function. It measures the number of input bits that a nondeterministic algorithm would need to look at in order to evaluate the function with certainty.  Quantum decision tree  The quantum decision tree complexity      Q  2    (  f  )        subscript  Q  2   f    Q_{2}(f)    is the depth of the lowest-depth quantum decision tree that gives the result    f   (  x  )       f  x    f(x)   with probability at least    2  /  3      2  3    2/3   for all    x  ∈    {  0  ,  1  }   n       x   superscript   0  1   n     x\in\{0,1\}^{n}   . Another quantity,      Q  E    (  f  )        subscript  Q  E   f    Q_{E}(f)    , is defined as the depth of the lowest-depth quantum decision tree that gives the result    f   (  x  )       f  x    f(x)   with probability 1 in all cases (i.e. computes   f   f   f   exactly).     Q  2    (  f  )        subscript  Q  2   f    Q_{2}(f)   and     Q  E    (  f  )        subscript  Q  E   f    Q_{E}(f)   are more commonly known as quantum query complexities , because the direct definition of a quantum decision tree is more complicated than in the classical case. Similar to the randomized case, we define     Q  0    (  f  )        subscript  Q  0   f    Q_{0}(f)   and     Q  1    (  f  )        subscript  Q  1   f    Q_{1}(f)   .  Relationship between different models  It follows immediately from the definitions that for all   n   n   n   -bit Boolean functions   f   f   f   ,      Q  2    (  f  )    ≤    R  2    (  f  )    ≤    R  1    (  f  )    ≤    R  0    (  f  )    ≤   D   (  f  )    ≤  n           subscript  Q  2   f      subscript  R  2   f           subscript  R  1   f           subscript  R  0   f          D  f        n     Q_{2}(f)\leq R_{2}(f)\leq R_{1}(f)\leq R_{0}(f)\leq D(f)\leq n   , and      Q  2    (  f  )    ≤    Q  E    (  f  )    ≤   D   (  f  )    ≤  n           subscript  Q  2   f      subscript  Q  E   f          D  f        n     Q_{2}(f)\leq Q_{E}(f)\leq D(f)\leq n   .  Blum and Impagliazzo, 2 Hartmanis and Hemachandra, 3 and Tardos 4 independently discovered that     D   (  f  )    ≤    R  0     (  f  )   2          D  f      subscript  R  0    superscript  f  2      D(f)\leq R_{0}(f)^{2}   . Noam Nisan found that the Monte Carlo randomized decision tree complexity is also polynomially related to deterministic decision tree complexity     D   (  f  )    =   O   (    R  2     (  f  )   3    )          D  f     O     subscript  R  2    superscript  f  3       D(f)=O(R_{2}(f)^{3})   . 5 (Nisan also showed that     D   (  f  )    =   O   (    R  1     (  f  )   2    )          D  f     O     subscript  R  1    superscript  f  2       D(f)=O(R_{1}(f)^{2})   .) A corollary of this result is that      R  0    (  f  )    =   O   (    R  2     (  f  )   3    )           subscript  R  0   f     O     subscript  R  2    superscript  f  3       R_{0}(f)=O(R_{2}(f)^{3})   . This inequality may be loose, however; no example is known of even a super-linear separation between     R  0    (  f  )        subscript  R  0   f    R_{0}(f)   and     R  2    (  f  )        subscript  R  2   f    R_{2}(f)   . 6  The quantum decision tree complexity     Q  2    (  f  )        subscript  Q  2   f    Q_{2}(f)   is also polynomially related to    D   (  f  )       D  f    D(f)   . Midrijanis showed that     D   (  f  )    =   O   (    Q  E     (  f  )   3    )          D  f     O     subscript  Q  E    superscript  f  3       D(f)=O(Q_{E}(f)^{3})   , 7 8 improving a quartic bound due to Beals et al. 9 Beals et al. also showed that     D   (  f  )    =   O   (    Q  2     (  f  )   6    )          D  f     O     subscript  Q  2    superscript  f  6       D(f)=O(Q_{2}(f)^{6})   , and this is still the best known bound. However, the largest known gap between deterministic and quantum query complexities is only quadratic. A quadratic gap is achieved for the OR function ;     D   (   O   R  n    )    =  n        D    O   subscript  R  n     n    D(OR_{n})=n   while      Q  2    (   O   R  n    )    =   Θ   (   n   )           subscript  Q  2     O   subscript  R  n       normal-Θ    n      Q_{2}(OR_{n})=\Theta(\sqrt{n})   .  It is important to note that these polynomial relationships are valid only for total Boolean functions. For partial Boolean functions , that have a domain a subset of     {  0  ,  1  }   n     superscript   0  1   n    \{0,1\}^{n}   , an exponential separation between     Q  E    (  f  )        subscript  Q  E   f    Q_{E}(f)   and    D   (  f  )       D  f    D(f)   is possible; the first example of such a problem was discovered by Deutsch and Jozsa . The same example also gives an exponential separation between     R  2    (  f  )        subscript  R  2   f    R_{2}(f)   and    D   (  f  )       D  f    D(f)   .  These relationships can be summarized by the following inequalities, which are true up to constant factors: 10        D   (  f  )    ≤    R  0     (  f  )   2          D  f      subscript  R  0    superscript  f  2      D(f)\leq R_{0}(f)^{2}    11 12 13       D   (  f  )    ≤    R  1    (  f  )    R  2    (  f  )          D  f      subscript  R  1   f   subscript  R  2   f     D(f)\leq R_{1}(f)R_{2}(f)    14       D   (  f  )    ≤    R  2     (  f  )   3          D  f      subscript  R  2    superscript  f  3      D(f)\leq R_{2}(f)^{3}    15        R  0    (  f  )    ≤    R  2     (  f  )   2    log  N           subscript  R  0   f      subscript  R  2    superscript  f  2     N      R_{0}(f)\leq R_{2}(f)^{2}\log N    16       D   (  f  )    ≤    Q  2     (  f  )   6          D  f      subscript  Q  2    superscript  f  6      D(f)\leq Q_{2}(f)^{6}    17       D   (  f  )    ≤    Q  E     (  f  )   2    Q  2     (  f  )   2          D  f      subscript  Q  E    superscript  f  2    subscript  Q  2    superscript  f  2      D(f)\leq Q_{E}(f)^{2}Q_{2}(f)^{2}    18       D   (  f  )    ≤    Q  1     (  f  )   2    Q  2     (  f  )   2          D  f      subscript  Q  1    superscript  f  2    subscript  Q  2    superscript  f  2      D(f)\leq Q_{1}(f)^{2}Q_{2}(f)^{2}    19        R  0    (  f  )    ≤    Q  1    (  f  )    Q  2     (  f  )   2    log  N           subscript  R  0   f      subscript  Q  1   f   subscript  Q  2    superscript  f  2     N      R_{0}(f)\leq Q_{1}(f)Q_{2}(f)^{2}\log N    20       D   (  f  )    ≤    Q  1    (  f  )    Q  2     (  f  )   2          D  f      subscript  Q  1   f   subscript  Q  2    superscript  f  2      D(f)\leq Q_{1}(f)Q_{2}(f)^{2}    21   See also   Minimum spanning tree#Decision trees   References  Surveys     "  Category:Computational complexity theory  Category:Models of computation  Category:Decision trees     "Data structures and algorithms, by Alfred V. Aho , John E. Hopcroft , Jeffrey D. Ullman ↩  ↩  ↩  ↩  ↩  (ps format) ↩  ↩  ↩  ↩           H. Buhrman, R. Cleve, R. de Wolf, and Ch. Zalka. Bounds for Small-Error and Zero-Error Quantum Algorithms. In 40th IEEE Symposium on Foundations of Computer Science (FOCS'99), pp.358-368. cs.CC/9904019, 1999. ↩  S. Aaronson. Quantum Certificate Complexity. IEEE Conference on Computational Complexity, pp. 171-178, 2003. ↩      