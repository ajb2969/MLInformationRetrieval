<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="814">Commutation theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Commutation theorem</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>commutation theorem</strong> explicitly identifies the <a class="uri" href="commutant" title="wikilink">commutant</a> of a specific <a href="von_Neumann_algebra" title="wikilink">von Neumann algebra</a> acting on a <a href="Hilbert_space" title="wikilink">Hilbert space</a> in the presence of a <a href="Von_Neumann_algebra#Weights,_states,_and_traces" title="wikilink">trace</a>. The first such result was proved by <a href="F.J._Murray" title="wikilink">F.J. Murray</a> and <a href="John_von_Neumann" title="wikilink">John von Neumann</a> in the 1930s and applies to the von Neumann algebra generated by a <a href="discrete_group" title="wikilink">discrete group</a> or by the <a href="dynamical_system" title="wikilink">dynamical system</a> associated with a <a href="ergodic_theory" title="wikilink">measurable transformation</a> preserving a <a href="probability_measure" title="wikilink">probability measure</a>. Another important application is in the theory of <a href="unitary_representation" title="wikilink">unitary representations</a> of <a href="Haar_measure" title="wikilink">unimodular</a> <a href="locally_compact_group" title="wikilink">locally compact groups</a>, where the theory has been applied to the <a href="regular_representation" title="wikilink">regular representation</a> and other closely related representations. In particular this framework led to an abstract version of the <a href="Plancherel_theorem" title="wikilink">Plancherel theorem</a> for unimodular locally compact groups due to <a href="Irving_Segal" title="wikilink">Irving Segal</a> and Forrest Stinespring and an abstract <a href="Plancherel_theorem_for_spherical_functions" title="wikilink">Plancherel theorem for spherical functions</a> associated with a <a href="Gelfand_pair" title="wikilink">Gelfand pair</a> due to <a href="Roger_Godement" title="wikilink">Roger Godement</a>. Their work was put in final form in the 1950s by <a href="Jacques_Dixmier" title="wikilink">Jacques Dixmier</a> as part of the theory of <strong>Hilbert algebras</strong>. It was not until the late 1960s, prompted partly by results in <a href="algebraic_quantum_field_theory" title="wikilink">algebraic quantum field theory</a> and <a href="quantum_statistical_mechanics" title="wikilink">quantum statistical mechanics</a> due to the school of <a href="Rudolf_Haag" title="wikilink">Rudolf Haag</a>, that the more general non-tracial <a href="Tomita–Takesaki_theory" title="wikilink">Tomita–Takesaki theory</a> was developed, heralding a new era in the theory of von Neumann algebras.</p>
<h2 id="commutation-theorem-for-finite-traces">Commutation theorem for finite traces</h2>

<p>Let <em>H</em> be a <a href="Hilbert_space" title="wikilink">Hilbert space</a> and <em>M</em> a <a href="von_Neumann_algebra" title="wikilink">von Neumann algebra</a> on <em>H</em> with a unit vector Ω such that</p>
<ul>
<li><em>M</em> Ω is dense in <em>H</em></li>
<li><em>M</em> ' Ω is dense in <em>H</em>, where <em>M</em> ' denotes the <a class="uri" href="commutant" title="wikilink">commutant</a> of <em>M</em></li>
<li>(<em>ab</em>Ω, Ω) = (<em>ba</em>Ω, Ω) for all <em>a</em>, <em>b</em> in <em>M</em>.</li>
</ul>

<p>The vector Ω is called a <em>cyclic-separating trace vector</em>. It is called a trace vector because the last condition means that the <a href="matrix_coefficient" title="wikilink">matrix coefficient</a> corresponding to Ω defines a tracial <a href="state_(functional_analysis)" title="wikilink">state</a> on <em>M</em>. It is called cyclic since Ω generates <em>H</em> as a topological <em>M</em>-module. It is called separating because if <em>a</em>Ω = 0 for <em>a</em> in <em>M</em>, then <em>aM</em>'Ω= (0), and hence <em>a</em> = 0.</p>

<p>It follows that the map</p>

<p>

<math display="block" id="Commutation_theorem:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mi>a</mi>
    <mi mathvariant="normal">Ω</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mo>*</mo>
    </msup>
    <mi mathvariant="normal">Ω</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>J</ci>
     <ci>a</ci>
     <ci>normal-Ω</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <times></times>
     </apply>
     <ci>normal-Ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ja\Omega=a^{*}\Omega
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>a</em> in <em>M</em> defines a conjugate-linear isometry of <em>H</em> with square the identity <em>J</em><sup>2</sup> = <em>I</em>. The operator <em>J</em> is usually called the <strong>modular conjugation operator</strong>.</p>

<p>It is immediately verified that <em>JMJ</em> and <em>M</em> commute on the subspace <em>M</em> Ω, so that</p>

<p>

<math display="block" id="Commutation_theorem:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>J</mi>
     <mi>M</mi>
     <mi>J</mi>
    </mrow>
    <mo>⊆</mo>
    <msup>
     <mi>M</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>J</ci>
     <ci>M</ci>
     <ci>J</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   JMJ\subseteq M^{\prime}.
  </annotation>
 </semantics>
</math>

</p>

<p>The <strong>commutation theorem</strong> of Murray and von Neumann states that</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Commutation_theorem:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mi>M</mi>
    <mi>J</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>M</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>J</ci>
     <ci>M</ci>
     <ci>J</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   JMJ=M^{\prime}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>One of the easiest ways to see this<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is to introduce <em>K</em>, the closure of the real subspace <em>M</em><sub>sa</sub> Ω, where <em>M</em><sub>sa</sub> denotes the self-adjoint elements in <em>M</em>. It follows that</p>

<p>

<math display="block" id="Commutation_theorem:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mo>=</mo>
    <mrow>
     <mi>K</mi>
     <mo>⊕</mo>
     <mrow>
      <mi>i</mi>
      <mi>K</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>K</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=K\oplus iK,
  </annotation>
 </semantics>
</math>

</p>

<p>an orthogonal direct sum for the real part of inner product. This is just the real orthogonal decomposition for the ±1 eigenspaces of <em>J</em>. On the other hand for <em>a</em> in <em>M</em><sub>sa</sub> and <em>b</em> in <em>M</em>'<sub>sa</sub>, the inner product (<em>ab</em>Ω, Ω) is real, because <em>ab</em> is self-adjoint. Hence <em>K</em> is unaltered if <em>M</em> is replaced by <em>M</em> '.</p>

<p>In particular Ω is a trace vector for <em>M</em>' and <em>J</em> is unaltered if <em>M</em> is replaced by <em>M</em> '. So the opposite inclusion</p>

<p>

<math display="block" id="Commutation_theorem:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <msup>
     <mi>M</mi>
     <mo>′</mo>
    </msup>
    <mi>J</mi>
   </mrow>
   <mo>⊆</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>J</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>J</ci>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   JM^{\prime}J\subseteq M
  </annotation>
 </semantics>
</math>

</p>

<p>follows by reversing the roles of <em>M</em> and <em>M</em>'.</p>
<h3 id="examples">Examples</h3>
<ul>
<li>One of the simplest cases of the commutation theorem, where it can easily be seen directly, is that of a <a href="finite_group" title="wikilink">finite group</a> Γ acting on the finite-dimensional <a href="inner_product_space" title="wikilink">inner product space</a> 

<math display="inline" id="Commutation_theorem:5">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">ℓ</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Γ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-ℓ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell^{2}(\Gamma)
  </annotation>
 </semantics>
</math>

 by the left and right <a href="regular_representation" title="wikilink">regular representations</a> λ and ρ. These <a href="unitary_representation" title="wikilink">unitary representations</a> are given by the formulas</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutation_theorem:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>λ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>g</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>g</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="5.9pt">,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ρ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>g</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mi>g</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>g</ci>
       <ci>f</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <ci>g</ci>
       <ci>f</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>g</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda(g)f)(x)=f(g^{-1}x),\,\,(\rho(g)f)(x)=f(xg)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>for <em>f</em> in 

<math display="inline" id="Commutation_theorem:7">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">ℓ</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Γ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-ℓ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell^{2}(\Gamma)
  </annotation>
 </semantics>
</math>

 and the commutation theorem implies that
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutation_theorem:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">Γ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>′′</mi>
      </msup>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>ρ</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">Γ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>′</mo>
      </msup>
     </mrow>
    </mrow>
    <mo rspace="5.9pt">,</mo>
    <mrow>
     <mrow>
      <mi>ρ</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">Γ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>′′</mi>
      </msup>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>λ</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">Γ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>′</mo>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Γ</ci>
       <ci>′′</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Γ</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Γ</ci>
       <ci>′′</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Γ</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(\Gamma)^{\prime\prime}=\rho(\Gamma)^{\prime},\,\,\rho(\Gamma)^{\prime%
\prime}=\lambda(\Gamma)^{\prime}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>The operator <em>J</em> is given by the formula
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutation_theorem:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>J</mi>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mover accent="true">
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>g</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>¯</mo>
    </mover>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>J</ci>
     <ci>f</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Jf(g)=\overline{f(g^{-1})}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>Exactly the same results remain true if Γ is allowed to be any <a class="uri" href="countable" title="wikilink">countable</a> <a href="discrete_group" title="wikilink">discrete group</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The von Neumann algebra λ(Γ)' ' is usually called the <strong><em>group von Neumann algebra</em></strong> of Γ.
</dd>
</dl>
<ul>
<li>Another important example is provided by a <a href="probability_space" title="wikilink">probability space</a> (<em>X</em>, μ). The <a href="Abelian_von_Neumann_algebra" title="wikilink">Abelian von Neumann algebra</a> <em>A</em> = <em>L</em><sup>∞</sup>(<em>X</em>, μ) acts by <a href="multiplication_operator" title="wikilink">multiplication operators</a> on <em>H</em> = <em>L</em><sup>2</sup>(<em>X</em>, μ) and the constant function 1 is a cyclic-separating trace vector. It follows that</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutation_theorem:10">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>A</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mi>A</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}=A,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>so that <em>A</em> is a <strong><em>maximal Abelian subalgebra</em></strong> of <em>B</em>(<em>H</em>), the von Neumann algebra of all <a href="bounded_operator" title="wikilink">bounded operators</a> on <em>H</em>.
</dd>
</dl>
<ul>
<li>The third class of examples combines the above two. Coming from <a href="ergodic_theory" title="wikilink">ergodic theory</a>, it was one of von Neumann's original motivations for studying von Neumann algebras. Let (<em>X</em>, μ) be a probability space and let Γ be a countable discrete group of measure-preserving transformations of (<em>X</em>, μ). The group therefore acts unitarily on the Hilbert space <em>H</em> = <em>L</em><sup>2</sup>(<em>X</em>, μ) according to the formula</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutation_theorem:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>U</mi>
      <mi>g</mi>
     </msub>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>g</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>g</ci>
     </apply>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{g}f(x)=f(g^{-1}x),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>for <em>f</em> in <em>H</em> and normalises the Abelian von Neumann algebra <em>A</em> = <em>L</em><sup>∞</sup>(<em>X</em>, μ). Let
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutation_theorem:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>H</mi>
      <mo>⊗</mo>
      <msup>
       <mi mathvariant="normal">ℓ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Γ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>H</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-ℓ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-Γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}=H\otimes\ell^{2}(\Gamma),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>a <a href="tensor_product" title="wikilink">tensor product</a> of Hilbert spaces.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The <strong><em>group–measure space construction</em></strong> or <a href="crossed_product" title="wikilink">crossed product</a> von Neumann algebra
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Commutation_theorem:13">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>⋊</mo>
    <mi mathvariant="normal">Γ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <csymbol cd="latexml">right-normal-factor-semidirect-product</csymbol>
     <ci>A</ci>
     <ci>normal-Γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=A\rtimes\Gamma
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>is defined to be the von Neumann algebra on <em>H</em><sub>1</sub> generated by the algebra 

<math display="inline" id="Commutation_theorem:14">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊗</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>A</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\otimes I
  </annotation>
 </semantics>
</math>

 and the normalising operators 

<math display="inline" id="Commutation_theorem:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>g</mi>
    </msub>
    <mo>⊗</mo>
    <mi>λ</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>g</ci>
     </apply>
     <ci>λ</ci>
    </apply>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{g}\otimes\lambda(g)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>
</dd>
</dl>
<dl>
<dd>The vector 

<math display="inline" id="Commutation_theorem:16">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>⊗</mo>
    <msub>
     <mi>δ</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ω</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=1\otimes\delta_{1}
  </annotation>
 </semantics>
</math>

 is a cyclic-separating trace vector. Moreover the modular conjugation operator <em>J</em> and commutant <em>M</em> ' can be explicitly identified.
</dd>
</dl>

<p>One of the most important cases of the group–measure space construction is when Γ is the group of integers <strong>Z</strong>, i.e. the case of a single invertible measurable transformation <em>T</em>. Here <em>T</em> must preserve the probability measure μ. Semifinite traces are required to handle the case when <em>T</em> (or more generally Γ) only preserves an infinite <a href="equivalence_of_measures" title="wikilink">equivalent</a> measure; and the full force of the <a href="Tomita–Takesaki_theory" title="wikilink">Tomita–Takesaki theory</a> is required when there is no invariant measure in the equivalence class, even though the equivalence class of the measure is preserved by <em>T</em> (or Γ).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="commutation-theorem-for-semifinite-traces">Commutation theorem for semifinite traces</h2>

<p>Let <em>M</em> be a von Neumann algebra and <em>M</em><sub>+</sub> the set of <a href="positive_operator" title="wikilink">positive operators</a> in <em>M</em>. By definition,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> a <strong>semifinite trace</strong> (or sometimes just <strong>trace</strong>) on <em>M</em> is a functional τ from <em>M</em><sub>+</sub> into [0,∞] such that</p>
<ol>
<li>

<math display="inline" id="Commutation_theorem:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>λ</mi>
       <mi>a</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>μ</mi>
       <mi>b</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>λ</mi>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>μ</mi>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>τ</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>μ</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>τ</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>τ</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(\lambda a+\mu b)=\lambda\tau(a)+\mu\tau(b)
  </annotation>
 </semantics>
</math>

 for <em>a</em>, <em>b</em> in <em>M</em><sub>+</sub> and λ, μ ≥ 0 (<em></em>);</li>
<li>

<math display="inline" id="Commutation_theorem:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>u</mi>
      <mi>a</mi>
      <msup>
       <mi>u</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>τ</ci>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>τ</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(uau^{*})=\tau(a)
  </annotation>
 </semantics>
</math>

 for <em>a</em> in <em>M</em><sub>+</sub> and <em>u</em> a <a href="unitary_operator" title="wikilink">unitary operator</a> in <em>M</em> (<em>unitary invariance</em>);</li>
<li>τ is completely additive on orthogonal families of projections in <em>M</em> (<em>normality</em>);</li>
<li>each projection in <em>M</em> is as orthogonal direct sum of projections with finite trace (<em>semifiniteness</em>).</li>
</ol>

<p>If in addition τ is non-zero on every non-zero projection, then τ is called a <strong>faithful trace</strong>.</p>

<p>If τ is a faithul trace on <em>M</em>, let <em>H</em> = <em>L</em><sup>2</sup>(<em>M</em>, τ) be the Hilbert space completion of the inner product space</p>

<p>

<math display="block" id="Commutation_theorem:19">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>a</mi>
     <mo>∈</mo>
     <mi>M</mi>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>τ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>a</mi>
         <mo>*</mo>
        </msup>
        <mi>a</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo><</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>a</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <lt></lt>
      <apply>
       <times></times>
       <ci>τ</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <times></times>
        </apply>
        <ci>a</ci>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0}=\{a\in M|\tau(a^{*}a)<\infty\}
  </annotation>
 </semantics>
</math>

</p>

<p>with respect to the inner product</p>

<p>

<math display="block" id="Commutation_theorem:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>b</mi>
        <mo>*</mo>
       </msup>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>a</ci>
     <ci>b</ci>
    </interval>
    <apply>
     <times></times>
     <ci>τ</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <times></times>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)=\tau(b^{*}a).
  </annotation>
 </semantics>
</math>

</p>

<p>The von Neumann algebra <em>M</em> acts by left multiplication on <em>H</em> and can be identified with its image. Let</p>

<p>

<math display="block" id="Commutation_theorem:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>a</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>J</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ja=a^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>a</em> in <em>M</em><sub>0</sub>. The operator <em>J</em> is again called the <em>modular conjugation operator</em> and extends to a conjugate-linear isometry of <em>H</em> satisfying <em>J</em><sup>2</sup> = I. The commutation theorem of Murray and von Neumann</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Commutation_theorem:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mi>M</mi>
    <mi>J</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>M</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>J</ci>
     <ci>M</ci>
     <ci>J</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   JMJ=M^{\prime}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>is again valid in this case. This result can be proved directly by a variety of methods,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> but follows immediately from the result for finite traces, by repeated use of the following elementary fact:</p>
<dl>
<dd><em>If</em> <em>M</em><sub>1</sub> 

<math display="inline" id="Commutation_theorem:23">
 <semantics>
  <mo>⊇</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">superset-of-or-equals</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \supseteq
  </annotation>
 </semantics>
</math>

 <em>M</em><sub>2</sub> <em>are two von Neumann algebras such that</em> <em>p</em><sub><em>n</em></sub> <em>M</em><sub>1</sub> = <em>p</em><sub><em>n</em></sub> <em>M</em><sub>2</sub> <em>for a family of projections</em> <em>p</em><sub><em>n</em></sub> <em>in the commutant of</em> <em>M</em><sub>1</sub> <em>increasing to</em> <em>I</em> <em>in the <a href="strong_operator_topology" title="wikilink">strong operator topology</a>, then</em> <em>M</em><sub>1</sub> = <em>M</em><sub>2</sub>.
</dd>
</dl>
<h2 id="hilbert-algebras">Hilbert algebras</h2>

<p>The theory of Hilbert algebras was introduced by Godement (under the name "unitary algebras"), Segal and Dixmier to formalize the classical method of defining the trace for <a href="trace_class_operator" title="wikilink">trace class operators</a> starting from <a href="Hilbert–Schmidt_operator" title="wikilink">Hilbert–Schmidt operators</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Applications in the <a href="Unitary_representation" title="wikilink">representation theory of groups</a> naturally lead to examples of Hilbert algebras. Every von Neumann algebra endowed with a semifinite trace has a canonical "completed"<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> or "full" Hilbert algebra associated with it; and conversely a completed Hilbert algebra of exactly this form can be canonically associated with every Hilbert algebra. The theory of Hilbert algebras can be used to deduce the commutation theorems of Murray and von Neumann; equally well the main results on Hilbert algebras can also be deduced directly from the commutation theorems for traces. The theory of Hilbert algebras was generalised by Takesaki<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> as a tool for proving commutation theorems for semifinite weights in <a href="Tomita–Takesaki_theory" title="wikilink">Tomita–Takesaki theory</a>; they can be dispensed with when dealing with states.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="definition">Definition</h3>

<p>A <strong>Hilbert algebra</strong><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> is an algebra 

<math display="inline" id="Commutation_theorem:24">
 <semantics>
  <mi>𝔄</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔄</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{A}
  </annotation>
 </semantics>
</math>

 with involution <em>x</em>→<em>x</em>* and an inner product (,) such that</p>
<ol>
<li>(<em>a</em>,<em>b</em>)=(<em>b</em>*,<em>a</em>*) for <em>a</em>, <em>b</em> in 

<math display="inline" id="Commutation_theorem:25">
 <semantics>
  <mi>𝔄</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔄</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{A}
  </annotation>
 </semantics>
</math>

;</li>
<li>left multiplication by a fixed <em>a</em> in 

<math display="inline" id="Commutation_theorem:26">
 <semantics>
  <mi>𝔄</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔄</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{A}
  </annotation>
 </semantics>
</math>

 is a bounded operator;</li>
<li><ul>
<li>is the adjoint, in other words (<em>xy</em>,<em>z</em>) = (<em>y</em>, <em>x</em>*<em>z</em>);</li>
</ul></li>
<li>the linear span of all products <em>xy</em> is dense in 

<math display="inline" id="Commutation_theorem:27">
 <semantics>
  <mi>𝔄</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔄</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{A}
  </annotation>
 </semantics>
</math>

.</li>
</ol>
<h3 id="examples-1">Examples</h3>
<ul>
<li>The Hilbert–Schmidt operators on an infinite-dimensional Hilbert space form a Hilbert algebra with inner product (<em>a</em>,<em>b</em>) = Tr (<em>b</em>*<em>a</em>).</li>
<li>If (<em>X</em>, μ) is an infinite measure space, the algebra <em>L</em><sup>∞</sup> (<em>X</em>) 

<math display="inline" id="Commutation_theorem:28">
 <semantics>
  <mo>∩</mo>
  <annotation-xml encoding="MathML-Content">
   <intersect></intersect>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cap
  </annotation>
 </semantics>
</math>

 <em>L</em><sup>2</sup>(<em>X</em>) is a Hilbert algebra with the usual inner product from <em>L</em><sup>2</sup>(<em>X</em>).</li>
<li>If <em>M</em> is a von Neumann algebra with faithful semifinite trace τ, then the *-subalgebra <em>M</em><sub>0</sub> defined above is a Hilbert algebra with inner product (<em>a</em>, '' b<em>) = τ(</em>b<em>*</em>a'').</li>
<li>If <em>G</em> is a <a href="Haar_measure" title="wikilink">unimodular</a> <a href="locally_compact_group" title="wikilink">locally compact group</a>, the convolution algebra <em>L</em><sup>1</sup>(<em>G</em>)

<math display="inline" id="Commutation_theorem:29">
 <semantics>
  <mo>∩</mo>
  <annotation-xml encoding="MathML-Content">
   <intersect></intersect>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cap
  </annotation>
 </semantics>
</math>

<em>L</em><sup>2</sup>(<em>G</em>) is a Hilbert algebra with the usual inner product from <em>L</em><sup>2</sup>(<em>G</em>).</li>
<li>If (<em>G</em>, <em>K</em>) is a <a href="Gelfand_pair" title="wikilink">Gelfand pair</a>, the convolution algebra <em>L</em><sup>1</sup>(<em>K</em>\<em>G</em>/<em>K</em>)

<math display="inline" id="Commutation_theorem:30">
 <semantics>
  <mo>∩</mo>
  <annotation-xml encoding="MathML-Content">
   <intersect></intersect>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cap
  </annotation>
 </semantics>
</math>

<em>L</em><sup>2</sup>(<em>K</em>\<em>G</em>/<em>K</em>) is a Hilbert algebra with the usual inner product from <em>L</em><sup>2</sup>(<em>G</em>); here <em>L</em><sup><em>p</em></sup>(<em>K</em>\<em>G</em>/<em>K</em>) denotes the closed subspace of <em>K</em>-biinvariant functions in <em>L</em><sup><em>p</em></sup>(<em>G</em>).</li>
<li>Any dense *-subalgebra of a Hilbert algebra is also a Hilbert algebra.</li>
</ul>
<h3 id="properties">Properties</h3>

<p>Let <em>H</em> be the Hilbert space completion of 

<math display="inline" id="Commutation_theorem:31">
 <semantics>
  <mi>𝔄</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔄</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{A}
  </annotation>
 </semantics>
</math>

 with respect to the inner product and let <em>J</em> denote the extension of the involution to a conjugate-linear involution of <em>H</em>. Define a representation λ and an anti-representation ρ of 

<math display="inline" id="Commutation_theorem:32">
 <semantics>
  <mi>𝔄</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔄</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{A}
  </annotation>
 </semantics>
</math>

 on itself by left and right multiplication:</p>

<p>

<math display="block" id="Commutation_theorem:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>x</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo rspace="5.9pt">,</mo>
    <mrow>
     <mrow>
      <mi>ρ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>x</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>x</mi>
      <mi>a</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(a)x=ax,\,\,\rho(a)x=xa.
  </annotation>
 </semantics>
</math>

</p>

<p>These actions extend continuously to actions on <em>H</em>. In this case the commutation theorem for Hilbert algebras states that</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Commutation_theorem:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝔄</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>′′</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ρ</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝔄</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝔄</ci>
      <ci>′′</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝔄</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(\mathfrak{A})^{\prime\prime}=\rho(\mathfrak{A})^{\prime}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>Moreover if</p>

<p>

<math display="block" id="Commutation_theorem:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝔄</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>′′</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝔄</ci>
      <ci>′′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\lambda(\mathfrak{A})^{\prime\prime},
  </annotation>
 </semantics>
</math>

</p>

<p>the von Neumann algebra generated by the operators λ(<em>a</em>), then</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Commutation_theorem:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mi>M</mi>
    <mi>J</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>M</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>J</ci>
     <ci>M</ci>
     <ci>J</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   JMJ=M^{\prime}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>These results were proved independently by  and .</p>

<p>The proof relies on the notion of "bounded elements" in the Hilbert space completion <em>H</em>.</p>

<p>An element of <em>x</em> in <em>H</em> is said to be <strong>bounded</strong> (relative to 

<math display="inline" id="Commutation_theorem:37">
 <semantics>
  <mi>𝔄</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔄</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{A}
  </annotation>
 </semantics>
</math>

) if the map <em>a</em> → <em>xa</em> of 

<math display="inline" id="Commutation_theorem:38">
 <semantics>
  <mi>𝔄</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔄</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{A}
  </annotation>
 </semantics>
</math>

 into <em>H</em> extends to a bounded operator on <em>H</em>, denoted by λ(<em>x</em>). In this case it is straightforward to prove that:<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<ul>
<li><em>Jx</em> is also a bounded element, denoted <em>x</em>*, and λ(<em>x</em>*) = λ(<em>x</em>)*;</li>
<li><em>a</em> → <em>ax</em> is given by the bounded operator ρ(<em>x</em>) = <em>J</em>λ(<em>x</em>*)<em>J</em> on <em>H</em>;</li>
<li><em>M</em> ' is generated by the ρ(<em>x</em>)'s with <em>x</em> bounded;</li>
<li>λ(<em>x</em>) and ρ(<em>y</em>) commute for <em>x</em>, <em>y</em> bounded.</li>
</ul>

<p>The commutation theorem follows immediately from the last assertion. In particular</p>
<ul>
<li><em>M</em> = λ(

<math display="inline" id="Commutation_theorem:39">
 <semantics>
  <mi>𝔅</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{B}
  </annotation>
 </semantics>
</math>

)".</li>
</ul>

<p>The space of all bounded elements 

<math display="inline" id="Commutation_theorem:40">
 <semantics>
  <mi>𝔅</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{B}
  </annotation>
 </semantics>
</math>

 forms a Hilbert algebra containing 

<math display="inline" id="Commutation_theorem:41">
 <semantics>
  <mi>𝔄</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔄</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{A}
  </annotation>
 </semantics>
</math>

 as a dense *-subalgebra. It is said to be <strong>completed</strong> or <strong>full</strong> because any element in <em>H</em> bounded relative to 

<math display="inline" id="Commutation_theorem:42">
 <semantics>
  <mi>𝔅</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{B}
  </annotation>
 </semantics>
</math>

must actually already lie in 

<math display="inline" id="Commutation_theorem:43">
 <semantics>
  <mi>𝔅</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{B}
  </annotation>
 </semantics>
</math>

. The functional τ on <em>M</em><sub>+</sub> defined by</p>

<p>

<math display="block" id="Commutation_theorem:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>τ</ci>
     <ci>x</ci>
    </apply>
    <interval closure="open">
     <ci>a</ci>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(x)=(a,a)
  </annotation>
 </semantics>
</math>

</p>

<p>if <em>x</em> =λ(a)*λ(a) and ∞ otherwise, yields a faithful semifinite trace on <em>M</em> with</p>

<p>

<math display="block" id="Commutation_theorem:45">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>M</mi>
     <mn>0</mn>
    </msub>
    <mo>=</mo>
    <mi>𝔅</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>𝔅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0}=\mathfrak{B}.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong><em>There is a one-one correspondence between von Neumann algebras on H with faithful semifinite trace and full Hilbert algebras with Hilbert space completion H.</em></strong></p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="von_Neumann_algebra" title="wikilink">von Neumann algebra</a></li>
<li><a href="Affiliated_operator" title="wikilink">Affiliated operator</a></li>
<li><a href="Tomita–Takesaki_theory" title="wikilink">Tomita–Takesaki theory</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>(English translation)</p></li>
<li></li>
<li>

<p>(English translation)</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>(Section 5)</p></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Von_Neumann_algebras" title="wikilink">Category:Von Neumann algebras</a> <a href="Category:Representation_theory_of_groups" title="wikilink">Category:Representation theory of groups</a> <a href="Category:Ergodic_theory" title="wikilink">Category:Ergodic theory</a> <a href="Category:Theorems_in_functional_analysis" title="wikilink">Category:Theorems in functional analysis</a> <a href="Category:Theorems_in_representation_theory" title="wikilink">Category:Theorems in representation theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><em>H</em><sub>1</sub> can be identified with the space of square integrable functions on <em>X</em> x Γ with respect to the <a href="product_measure" title="wikilink">product measure</a>.<a href="#fnref3">↩</a></li>
<li id="fn4">It should not be confused with the von Neumann algebra on <em>H</em> generated by <em>A</em> and the operators <em>U</em><sub><em>g</em></sub>.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">Dixmier uses the adjectives <em>achevée</em> or <em>maximale</em>.<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16">, Appendix A54–A61.<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
</ol>
</section>
</body>
</html>
