   Vector clock      Vector clock   Vector clocks is an algorithm for generating a partial ordering of events in a distributed system and detecting causality violations. Just as in Lamport timestamps , interprocess messages contain the state of the sending process's logical clock . A vector clock of a system of N processes is an array /vector of N logical clocks, one clock per process; a local "smallest possible values" copy of the global clock-array is kept in each process, with the following rules for clock updates:   Initially all clocks are zero.  Each time a process experiences an internal event, it increments its own logical clock in the vector by one.  Each time a process prepares to send a message, it sends its entire vector along with the message being sent.  Each time a process receives a message, it increments its own logical clock in the vector by one and updates each element in its vector by taking the maximum of the value in its own vector clock and the value in the vector in the received message (for every element).   The vector clocks algorithm was independently developed by Colin Fidge and Friedemann Mattern in 1988. 1 2  Partial ordering property  Vector clocks allow for the partial causal ordering of events. Defining the following:       V  C   (  x  )       V  C  x    VC(x)   denotes the vector clock of event   x   x   x   , and    V  C    (  x  )   z       V  C   subscript  x  z     VC(x)_{z}   denotes the component of that clock for process   z   z   z   .      V  C   (  x  )   <  V  C   (  y  )   ⇔  ∀  z   [  V  C    (  x  )   z   ≤  V  C    (  y  )   z   ]   and  ∃   z  ′    [  V  C    (  x  )    z  ′    <  V  C    (  y  )    z  ′    ]      fragments  V  C   fragments  normal-(  x  normal-)    V  C   fragments  normal-(  y  normal-)   iff  for-all  z   fragments  normal-[  V  C   subscript   fragments  normal-(  x  normal-)   z    V  C   subscript   fragments  normal-(  y  normal-)   z   normal-]   and    superscript  z  normal-′    fragments  normal-[  V  C   subscript   fragments  normal-(  x  normal-)    superscript  z  normal-′     V  C   subscript   fragments  normal-(  y  normal-)    superscript  z  normal-′    normal-]     VC(x)     In English    V  C   (  x  )       V  C  x    VC(x)   is less than    V  C   (  y  )       V  C  y    VC(y)   , if and only if    V  C    (  x  )   z       V  C   subscript  x  z     VC(x)_{z}   is less than or equal to    V  C    (  y  )   z       V  C   subscript  y  z     VC(y)_{z}   for all process indices   z   z   z   , and at least one of those relationships is strictly smaller (that is,     V  C    (  x  )    z  ′     <   V  C    (  y  )    z  ′           V  C   subscript  x   superscript  z  normal-′       V  C   subscript  y   superscript  z  normal-′       VC(x)_{z^{\prime}}   ).       x  →   y      normal-→  x  y    x\to y\;   denotes that event   x   x   x   happened before event   y   y   y   . It is defined as: if    x  →   y      normal-→  x  y    x\to y\;   , then     V  C   (  x  )    <   V  C   (  y  )          V  C  x     V  C  y     VC(x)      Properties:   If     V  C   (  a  )    <   V  C   (  b  )          V  C  a     V  C  b     VC(a)   , then    a  →   b      normal-→  a  b    a\to b\;     Antisymmetry : if     V  C   (  a  )    <   V  C   (  b  )          V  C  a     V  C  b     VC(a)   , then ¬     V  C   (  b  )    <   V  C   (  a  )          V  C  b     V  C  a     VC(b)     Transitivity : if     V  C   (  a  )    <   V  C   (  b  )          V  C  a     V  C  b     VC(a)   and     V  C   (  b  )    <   V  C   (  c  )          V  C  b     V  C  c     VC(b)   , then     V  C   (  a  )    <   V  C   (  c  )          V  C  a     V  C  c     VC(a)   or if    a  →   b      normal-→  a  b    a\to b\;   and    b  →   c      normal-→  b  c    b\to c\;   , then    a  →   c      normal-→  a  c    a\to c\;      Relation with other orders:   Let    R  T   (  x  )       R  T  x    RT(x)   be the real time when event   x   x   x   occurs. If     V  C   (  a  )    <   V  C   (  b  )          V  C  a     V  C  b     VC(a)   , then     R  T   (  a  )    <   R  T   (  b  )          R  T  a     R  T  b     RT(a)     Let    C   (  x  )       C  x    C(x)   be the Lamport timestamp of event   x   x   x   . If     V  C   (  a  )    <   V  C   (  b  )          V  C  a     V  C  b     VC(a)   , then     C   (  a  )    <   C   (  b  )          C  a     C  b     C(a)      Other mechanisms   Almeida et al. , introduced in 2008 Interval Tree Clocks. 3 This mechanism generalizes Vector Clocks and allows operation in dynamic environments when the identities and number of processes in the computation is not known in advance. You can find an implementation of ITC named itc4j here .    Torres-Rojas and Ahamad, developed in 1999 Plausible Clocks, 4 a mechanism that takes less space than vector clocks but that, in some cases, will totally order events that are causally concurrent.   See also   Lamport timestamps  Matrix clocks  Version vector   References  External links   Explanation of Vector clocks  Timestamp-based vector clock implementation in Erlang  Vector clock implementation in Objective-C  Vector clock implementation in Erlang  Why Vector Clocks are Hard  Riak Vector Clocks   "  Category:Distributed algorithms     ↩  ↩  ↩  ↩     