   Currying      Currying   In mathematics and computer science , currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument ( partial application ). It was introduced by Moses Schönfinkel 1 2 3 and later developed by Haskell Curry . 4 5  Uncurrying is the dual transformation to currying, and can be seen as a form of defunctionalization . It takes a function f ( x ) which returns another function g ( y ) as a result, and yields a new function  which takes a number of additional parameters and applies them to the function returned by function f . The process can be iterated if necessary.  Motivation  There are analytical techniques that can only be applied to functions with a single argument. Practical functions frequently take more arguments than this. Frege showed that it was sufficient to provide solutions for the single argument case, as it was possible to transform a function with multiple arguments into a chain of single-argument functions instead. This transformation is the process now known as currying. 6  Currying is similar to the process of calculating a function of multiple variables for some given values on paper.  For example, given the function     f   (  x  ,  y  )    =   y  /  x         f   x  y      y  x     f(x,y)=y/x   :   To evaluate    f   (  2  ,  3  )       f   2  3     f(2,3)   , first replace   x   x   x   with   2   2   2       Since the result is a function of   y   y   y   , this new function    g   (  y  )       g  y    g(y)   can be defined as     g   (  y  )    =   f   (  2  ,  y  )    =   y  /  2           g  y     f   2  y           y  2      g(y)=f(2,y)=y/2       Next, replace the   y   y   y   argument with   3   3   3   , producing     g   (  3  )    =   f   (  2  ,  3  )    =   3  /  2           g  3     f   2  3           3  2      g(3)=f(2,3)=3/2      On paper, using classical notation, this is usually done all in one step. However, each argument can be replaced sequentially as well. Each replacement results in a function taking exactly one argument. This produces a chain of functions as in lambda calculus , and multi-argument functions are usually represented in curried form.  Some programming languages almost always use curried functions to achieve multiple arguments; notable examples are ML and Haskell , where in both cases all functions have exactly one argument.  If we let f be a function       f   (  x  ,  y  )    =   y  x         f   x  y      y  x     f(x,y)=\frac{y}{x}   then the function h where       h   (  x  )    =  y  ↦   f   (  x  ,  y  )            h  x   y    maps-to      f   x  y       h(x)=y\mapsto f(x,y)   is a curried version of   f   f   f   . Here,    y  ↦  z     maps-to  y  z    \scriptstyle y\mapsto z   is a function that maps an argument y to result z . In particular,       g   (  y  )    =   h   (  2  )    =  y  ↦   f   (  2  ,  y  )            g  y     h  2        y    maps-to      f   2  y       g(y)=h(2)=y\mapsto f(2,y)   is the curried equivalent of the example above. Note, however, that currying, while similar, is not the same operation as partial function application .  Definition  Given a function   f   f   \scriptstyle f   of type    f  :    (   X  ×  Y   )   →  Z      normal-:  f   normal-→    X  Y   Z     \scriptstyle f\colon(X\times Y)\to Z   , currying it makes a function    curry   (  f  )   :  X  →   (  Y  →  Z  )      fragments  curry   fragments  normal-(  f  normal-)   normal-:  X  normal-→   fragments  normal-(  Y  normal-→  Z  normal-)     \scriptstyle\text{curry}(f)\colon X\to(Y\to Z)   . That is,    curry   (  f  )       curry  f    \scriptstyle\text{curry}(f)   takes an argument of type   X   X   \scriptstyle X   and returns a function of type    Y  →  Z     normal-→  Y  Z    \scriptstyle Y\to Z   . Uncurrying is the reverse transformation, and is most easily understood in terms of its right adjoint, apply .  The → operator is often considered right-associative , so the curried function type    X  →   (  Y  →  Z  )      fragments  X  normal-→   fragments  normal-(  Y  normal-→  Z  normal-)     \scriptstyle X\to(Y\to Z)   is often written as    X  →  Y  →  Z       normal-→  X  Y    normal-→    Z     \scriptstyle X\to Y\to Z   . Conversely, function application is considered to be left-associative, so that     f    ⟨  x  ,  y  ⟩       f   x  y     \scriptstyle f\;\langle x,y\rangle   is equivalent to    curry   (  f  )    x   y      curry  f  x  y    \scriptstyle\text{curry}(f)\;x\;y   .  Curried functions may be used in any language that supports closures ; however, uncurried functions are generally preferred for efficiency reasons, since the overhead of partial application and closure creation can then be avoided for most function calls.  Mathematical view  In theoretical computer science , currying provides a way to study functions with multiple arguments in very simple theoretical models such as the lambda calculus in which functions only take a single argument.  In a set-theoretic paradigm, currying is the natural correspondence between the set    A   B  ×  C      superscript  A    B  C     \scriptstyle A^{B\times C}   of functions from    B  ×  C      B  C    \scriptstyle B\times C   to   A   A   A   , and the set     (   A  C   )   B     superscript   superscript  A  C   B    \scriptstyle\left(A^{C}\right)^{B}   of functions from   B   B   \scriptstyle B   to the set of functions from   C   C   \scriptstyle C   to   A   A   \scriptstyle A   . In category theory , currying can be found in the universal property of an exponential object , which gives rise to the following adjunction in cartesian closed categories : There is a natural  isomorphism between the morphisms from a binary product     f  :    (   X  ×  Y   )   →  Z      normal-:  f   normal-→    X  Y   Z     \scriptstyle f\colon(X\times Y)\to Z   and the morphisms to an exponential object    g  :   X  →   Z  Y       normal-:  g   normal-→  X   superscript  Z  Y      \scriptstyle g\colon X\to Z^{Y}   . In other words, currying is the statement that product and Hom are adjoint functors ; that is, there is a natural transformation :        hom   (   A  ×  B   ,  C  )    ≅   hom   (  A  ,   C  B   )     .       hom    A  B   C    hom  A   superscript  C  B      \hom(A\times B,C)\cong\hom(A,C^{B}).     This is the key property of being a Cartesian closed category , and more generally, a closed monoidal category . 7 The latter, though more rarely discussed, is interesting, as it is the suitable setting for quantum computation , 8 whereas the former is sufficient for classical logic. The difference is that the Cartesian product can be interpreted simply as a pair of items (or a list), whereas the tensor product , used to define a monoidal category , is suitable for describing entangled quantum states . 9  Under the Curry–Howard correspondence , the existence of currying and uncurrying is equivalent to the logical theorem     (  A  and  B  )   →  C  ⇔  A  →   (  B  →  C  )      fragments   fragments  normal-(  A  and  B  normal-)   normal-→  C  normal-⇔  A  normal-→   fragments  normal-(  B  normal-→  C  normal-)     \scriptstyle(A\and B)\to C\Leftrightarrow A\to(B\to C)   , as tuples ( product type ) corresponds to conjunction in logic, and function type corresponds to implication.  Curry is a continuous function in the Scott topology . 10  Naming  The name "currying", coined by Christopher Strachey in 1967, is a reference to logician Haskell Curry . The alternative name "Schönfinkelisation" has been proposed as a reference to Moses Schönfinkel . 11 In the mathematical context, the principle can be traced back to work in 1893 by Frege .  Contrast with partial function application  Currying and partial function application are often conflated. 12 One of the significant differences between the two is that a call to a partially applied function returns the result right away, not another function down the currying chain; this distinction can be illustrated clearly for functions whose arity is greater than two. 13  Given a function of type    f  :    (   X  ×  Y  ×  Z   )   →  N      normal-:  f   normal-→    X  Y  Z   N     \scriptstyle f\colon(X\times Y\times Z)\to N   , currying produces    curry   (  f  )   :  X  →   (  Y  →   (  Z  →  N  )   )      fragments  curry   fragments  normal-(  f  normal-)   normal-:  X  normal-→   fragments  normal-(  Y  normal-→   fragments  normal-(  Z  normal-→  N  normal-)   normal-)     \scriptstyle\text{curry}(f)\colon X\to(Y\to(Z\to N))   . That is, while an evaluation of the first function might be represented as    f   (  1  ,  2  ,  3  )       f   1  2  3     \scriptstyle f(1,2,3)   , evaluation of the curried function would be represented as     f  curried    (  1  )    (  2  )    (  3  )        subscript  f  curried   1  2  3    \scriptstyle f_{\text{curried}}(1)(2)(3)   , applying each argument in turn to a single-argument function returned by the previous invocation. Note that after calling     f  curried    (  1  )        subscript  f  curried   1    \scriptstyle f_{\text{curried}}(1)   , we are left with a function that takes a single argument and returns another function, not a function that takes two arguments.  In contrast, partial function application refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. Given the definition of   f   f   \scriptstyle f   above, we might fix (or 'bind') the first argument, producing a function of type     partial   (  f  )    :    (   Y  ×  Z   )   →  N      normal-:    partial  f    normal-→    Y  Z   N     \scriptstyle\text{partial}(f)\colon(Y\times Z)\to N   . Evaluation of this function might be represented as     f  partial    (  2  ,  3  )        subscript  f  partial    2  3     \scriptstyle f_{\text{partial}}(2,3)   . Note that the result of partial function application in this case is a function that takes two arguments.  Intuitively, partial function application says "if you fix the first arguments of the function, you get a function of the remaining arguments". For example, if function div stands for the division operation x / y , then div with the parameter x fixed at 1 (i.e., div 1) is another function: the same as the function inv that returns the multiplicative inverse of its argument, defined by inv ( y ) = 1/ y .  The practical motivation for partial application is that very often the functions obtained by supplying some but not all of the arguments to a function are useful; for example, many languages have a function or operator similar to plus_one . Partial application makes it easy to define these functions, for example by creating a function that represents the addition operator with 1 bound as its first argument.  See also   Lazy evaluation  Closure (computer science)  s mn theorem  Closed monoidal category   Notes  References      External links   Currying Schonfinkelling at the Portland Pattern Repository  Currying != Generalized Partial Application! - post at Lambda-the-Ultimate.org   "  Category:Higher-order functions  Category:Functional programming  Category:Lambda calculus  Category:Articles with example Java code     (Reprinted lecture notes from 1967.) ↩  ↩  Kenneth Slonneger and Barry L. Kurtz. Formal Syntax and Semantics of Programming Languages . p. 144. ↩  Henk Barendregt, Erik Barendsen, " Introduction to Lambda Calculus ", March 2000, page 8. ↩  ↩  Frequently Asked Questions for comp.lang.functional: Currying by Graham Hutton ↩  ↩  Samson Abramsky and Bob Coecke, "A Categorical Semantics for Quantum Protocols", " 1 . ↩  John c. Baez and Mike Stay, " Physics, Topology, Logic and Computation: A Rosetta Stone ", (2009) ArXiv 0903.0340 in New Structures for Physics , ed. Bob Coecke, Lecture Notes in Physics vol. 813 , Springer, Berlin, 2011, pp. 95-174. ↩   (See theorems 1.2.13, 1.2.14) ↩  I. Heim and A. Kratzer (1998). Semantics in Generative Grammar . Blackwell. ↩  Partial Function Application is not Currying ↩  Functional Programming in 5 Minutes ↩     