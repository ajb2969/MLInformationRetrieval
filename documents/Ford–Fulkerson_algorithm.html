<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1718">Ford–Fulkerson algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ford–Fulkerson algorithm</h1>
<hr>The '''Ford–Fulkerson method''' or '''Ford–Fulkerson algorithm''' ('''FFA''') is an [[algorithm]] that co<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</hr></body></html>
<body>

<p>mputes the <a href="maximum_flow_problem" title="wikilink">maximum flow</a> in a <a href="flow_network" title="wikilink">flow network</a>. It is called a "method" instead of an "algorithm" as the approach to finding augmenting paths in a residual graph is not fully specificied<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> or it is specified in several implementations with different running times.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It was published in 1956 by <a href="L._R._Ford,_Jr." title="wikilink">L. R. Ford, Jr.</a> and <a href="D._R._Fulkerson" title="wikilink">D. R. Fulkerson</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The name "Ford–Fulkerson" is often also used for the <a href="Edmonds–Karp_algorithm" title="wikilink">Edmonds–Karp algorithm</a>, which is a specialization of Ford–Fulkerson.</p>

<p>The idea behind the algorithm is as follows: as long as there is a path from the source (start node) to the sink (end node), with available capacity on all edges in the path, we send flow along one of the paths. Then we find another path, and so on. A path with available capacity is called an <a href="augmenting_path" title="wikilink">augmenting path</a>.</p>
<h2 id="algorithm">Algorithm</h2>

<p>Let 

<math display="inline" id="Ford–Fulkerson_algorithm:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(V,E)
  </annotation>
 </semantics>
</math>

 be a graph, and for each edge from 

<math display="inline" id="Ford–Fulkerson_algorithm:1">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Ford–Fulkerson_algorithm:2">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Ford–Fulkerson_algorithm:3">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(u,v)
  </annotation>
 </semantics>
</math>

 be the capacity and 

<math display="inline" id="Ford–Fulkerson_algorithm:4">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(u,v)
  </annotation>
 </semantics>
</math>

 be the flow. We want to find the maximum flow from the source 

<math display="inline" id="Ford–Fulkerson_algorithm:5">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to the sink 

<math display="inline" id="Ford–Fulkerson_algorithm:6">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. After every step in the algorithm the following is maintained:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Capacity constraints</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>E</mi>
    </mpadded>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall(u,v)\in E\ f(u,v)\leq c(u,v)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>The flow along an edge can not exceed its capacity.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>Skew symmetry</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:8">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>E</mi>
    </mpadded>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>v</ci>
        <ci>u</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall(u,v)\in E\ f(u,v)=-f(v,u)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>The net flow from 

<math display="inline" id="Ford–Fulkerson_algorithm:9">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Ford–Fulkerson_algorithm:10">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 must be the opposite of the net flow from 

<math display="inline" id="Ford–Fulkerson_algorithm:11">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Ford–Fulkerson_algorithm:12">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 (see example).</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Flow conservation</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>u</mi>
    </mrow>
    <mo>∈</mo>
    <mi>V</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>u</mi>
    <mo>≠</mo>
    <mrow>
     <mi>s</mi>
     <mtext>and</mtext>
     <mi>u</mi>
    </mrow>
    <mo>≠</mo>
    <mi>t</mi>
    <mo>⇒</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>w</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>u</ci>
     </apply>
     <ci>V</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <neq></neq>
      <ci>u</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <mtext>and</mtext>
       <ci>u</ci>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <share href="#.cmml">
      </share>
      <ci>t</ci>
     </apply>
     <apply>
      <ci>normal-⇒</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>w</ci>
         <ci>V</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <interval closure="open">
         <ci>u</ci>
         <ci>w</ci>
        </interval>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall u\in V:u\neq s\text{ and }u\neq t\Rightarrow\sum_{w\in V}f(u,w)=0
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>That is, unless 

<math display="inline" id="Ford–Fulkerson_algorithm:14">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Ford–Fulkerson_algorithm:15">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Ford–Fulkerson_algorithm:16">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. The net flow to a node is zero, except for the source, which "produces" flow, and the sink, which "consumes" flow.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>Value(f)</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>s</ci>
        <ci>u</ci>
       </interval>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>s</ci>
       <ci>u</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>v</ci>
        <ci>t</ci>
       </interval>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>v</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{(s,u)\in E}f(s,u)=\sum_{(v,t)\in E}f(v,t)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>That is, the flow leaving from 

<math display="inline" id="Ford–Fulkerson_algorithm:18">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 must be equal to the flow arriving at 

<math display="inline" id="Ford–Fulkerson_algorithm:19">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

.</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>
</dd>
</dl>

<p>This means that the flow through the network is a <em>legal flow</em> after each round in the algorithm. We define the <strong>residual network</strong> 

<math display="inline" id="Ford–Fulkerson_algorithm:20">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>f</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <msub>
     <mi>E</mi>
     <mi>f</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>f</ci>
    </apply>
    <interval closure="open">
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>f</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}(V,E_{f})
  </annotation>
 </semantics>
</math>

 to be the network with capacity 

<math display="inline" id="Ford–Fulkerson_algorithm:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{f}(u,v)=c(u,v)-f(u,v)
  </annotation>
 </semantics>
</math>

 and no flow. Notice that it can happen that a flow from 

<math display="inline" id="Ford–Fulkerson_algorithm:22">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Ford–Fulkerson_algorithm:23">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 is allowed in the residual network, though disallowed in the original network: if 

<math display="inline" id="Ford–Fulkerson_algorithm:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(u,v)>0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ford–Fulkerson_algorithm:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>v</ci>
      <ci>u</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(v,u)=0
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Ford–Fulkerson_algorithm:26">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <ci>v</ci>
       <ci>u</ci>
      </interval>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>v</ci>
        <ci>u</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>v</ci>
        <ci>u</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{f}(v,u)=c(v,u)-f(v,u)=f(u,v)>0
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Algorithm</strong> Ford–Fulkerson</p>
<dl>
<dd><strong>Inputs</strong> Given a Network 

<math display="inline" id="Ford–Fulkerson_algorithm:27">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 with flow capacity 

<math display="inline" id="Ford–Fulkerson_algorithm:28">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, a source node 

<math display="inline" id="Ford–Fulkerson_algorithm:29">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, and a sink node 

<math display="inline" id="Ford–Fulkerson_algorithm:30">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>


</dd>
<dd><strong>Output</strong> Compute a flow 

<math display="inline" id="Ford–Fulkerson_algorithm:31">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Ford–Fulkerson_algorithm:32">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Ford–Fulkerson_algorithm:33">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 of maximum value
<ol>
<li>

<math display="inline" id="Ford–Fulkerson_algorithm:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(u,v)\leftarrow 0
  </annotation>
 </semantics>
</math>

 for all edges 

<math display="inline" id="Ford–Fulkerson_algorithm:35">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>u</ci>
    <ci>v</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)
  </annotation>
 </semantics>
</math>

</li>
<li>While there is a path 

<math display="inline" id="Ford–Fulkerson_algorithm:36">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Ford–Fulkerson_algorithm:37">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Ford–Fulkerson_algorithm:38">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Ford–Fulkerson_algorithm:39">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Ford–Fulkerson_algorithm:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{f}(u,v)>0
  </annotation>
 </semantics>
</math>

 for all edges 

<math display="inline" id="Ford–Fulkerson_algorithm:41">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)\in p
  </annotation>
 </semantics>
</math>

:
<ol>
<li>Find 

<math display="inline" id="Ford–Fulkerson_algorithm:42">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>c</mi>
        <mi>f</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo>,</mo>
        <mi>v</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo>,</mo>
        <mi>v</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∈</mo>
       <mi>p</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>f</ci>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <min></min>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>f</ci>
       </apply>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
      </apply>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{f}(p)=\min\{c_{f}(u,v):(u,v)\in p\}
  </annotation>
 </semantics>
</math>

</li>
<li>For each edge 

<math display="inline" id="Ford–Fulkerson_algorithm:43">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)\in p
  </annotation>
 </semantics>
</math>


<ol>
<li>

<math display="inline" id="Ford–Fulkerson_algorithm:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>f</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>f</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(u,v)\leftarrow f(u,v)+c_{f}(p)
  </annotation>
 </semantics>
</math>

 (<em>Send flow along the path</em>)</li>
<li>

<math display="inline" id="Ford–Fulkerson_algorithm:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>f</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>v</ci>
      <ci>u</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>v</ci>
       <ci>u</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>f</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(v,u)\leftarrow f(v,u)-c_{f}(p)
  </annotation>
 </semantics>
</math>

 (<em>The flow might be "returned" later</em>)</li>
</ol></li>
</ol></li>
</ol>
</dd>
</dl>

<p>The path in step 2 can be found with for example a <a href="breadth-first_search" title="wikilink">breadth-first search</a> or a <a href="depth-first_search" title="wikilink">depth-first search</a> in 

<math display="inline" id="Ford–Fulkerson_algorithm:46">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>f</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <msub>
     <mi>E</mi>
     <mi>f</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>f</ci>
    </apply>
    <interval closure="open">
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>f</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}(V,E_{f})
  </annotation>
 </semantics>
</math>

. If you use the former, the algorithm is called <a href="Edmonds–Karp_algorithm" title="wikilink">Edmonds–Karp</a>.</p>

<p>When no more paths in step 2 can be found, 

<math display="inline" id="Ford–Fulkerson_algorithm:47">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 will not be able to reach 

<math display="inline" id="Ford–Fulkerson_algorithm:48">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 in the residual network. If 

<math display="inline" id="Ford–Fulkerson_algorithm:49">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is the set of nodes reachable by 

<math display="inline" id="Ford–Fulkerson_algorithm:50">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 in the residual network, then the total capacity in the original network of edges from 

<math display="inline" id="Ford–Fulkerson_algorithm:51">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 to the remainder of 

<math display="inline" id="Ford–Fulkerson_algorithm:52">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is on the one hand equal to the total flow we found from 

<math display="inline" id="Ford–Fulkerson_algorithm:53">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Ford–Fulkerson_algorithm:54">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, and on the other hand serves as an upper bound for all such flows. This proves that the flow we found is maximal. See also <a href="Max-flow_min-cut_theorem" title="wikilink">Max-flow Min-cut theorem</a>.</p>

<p>If the graph 

<math display="inline" id="Ford–Fulkerson_algorithm:55">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(V,E)
  </annotation>
 </semantics>
</math>

 has multiple sources and sinks, we act as follows: Suppose that 

<math display="inline" id="Ford–Fulkerson_algorithm:56">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>t</mi>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>t</mi>
     <mtext>is a sink</mtext>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>t</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <mtext>is a sink</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\{t|t\text{ is a sink}\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ford–Fulkerson_algorithm:57">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>s</mi>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>s</mi>
     <mtext>is a source</mtext>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>s</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <mtext>is a source</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{s|s\text{ is a source}\}
  </annotation>
 </semantics>
</math>

. Add a new source 

<math display="inline" id="Ford–Fulkerson_algorithm:58">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{*}
  </annotation>
 </semantics>
</math>

 with an edge 

<math display="inline" id="Ford–Fulkerson_algorithm:59">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>s</mi>
    <mo>*</mo>
   </msup>
   <mo>,</mo>
   <mi>s</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <times></times>
    </apply>
    <ci>s</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s^{*},s)
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Ford–Fulkerson_algorithm:60">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{*}
  </annotation>
 </semantics>
</math>

 to every node 

<math display="inline" id="Ford–Fulkerson_algorithm:61">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in S
  </annotation>
 </semantics>
</math>

, with capacity 

<math display="inline" id="Ford–Fulkerson_algorithm:62">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>s</mi>
     <mo>*</mo>
    </msup>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+2.8pt">
    <msub>
     <mi>d</mi>
     <mi>s</mi>
    </msub>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>d</mi>
     <mi>s</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
    </msub>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <times></times>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>s</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>s</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>s</ci>
        <ci>u</ci>
       </interval>
       <ci>E</ci>
      </apply>
     </apply>
     <csymbol cd="unknown">c</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(s^{*},s)=d_{s}\;(d_{s}=\sum_{(s,u)\in E}c(s,u))
  </annotation>
 </semantics>
</math>

. And add a new sink 

<math display="inline" id="Ford–Fulkerson_algorithm:63">
 <semantics>
  <msup>
   <mi>t</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>t</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{*}
  </annotation>
 </semantics>
</math>

 with an edge 

<math display="inline" id="Ford–Fulkerson_algorithm:64">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>t</mi>
   <mo>,</mo>
   <msup>
    <mi>t</mi>
    <mo>*</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <times></times>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (t,t^{*})
  </annotation>
 </semantics>
</math>

 from every node 

<math display="inline" id="Ford–Fulkerson_algorithm:65">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>t</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\in T
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Ford–Fulkerson_algorithm:66">
 <semantics>
  <msup>
   <mi>t</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>t</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{*}
  </annotation>
 </semantics>
</math>

, with capacity 

<math display="inline" id="Ford–Fulkerson_algorithm:67">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>,</mo>
    <msup>
     <mi>t</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+2.8pt">
    <msub>
     <mi>d</mi>
     <mi>t</mi>
    </msub>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>d</mi>
     <mi>t</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
    </msub>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <times></times>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>t</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>v</ci>
        <ci>t</ci>
       </interval>
       <ci>E</ci>
      </apply>
     </apply>
     <csymbol cd="unknown">c</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(t,t^{*})=d_{t}\;(d_{t}=\sum_{(v,t)\in E}c(v,t))
  </annotation>
 </semantics>
</math>

. Then apply the Ford–Fulkerson algorithm.</p>

<p>Also, if a node 

<math display="inline" id="Ford–Fulkerson_algorithm:68">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 has capacity constraint 

<math display="inline" id="Ford–Fulkerson_algorithm:69">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>u</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{u}
  </annotation>
 </semantics>
</math>

, we replace this node with two nodes 

<math display="inline" id="Ford–Fulkerson_algorithm:70">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>u</mi>
    <mrow>
     <mi>o</mi>
     <mi>u</mi>
     <mi>t</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{in},u_{out}
  </annotation>
 </semantics>
</math>

, and an edge 

<math display="inline" id="Ford–Fulkerson_algorithm:71">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>u</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>u</mi>
    <mrow>
     <mi>o</mi>
     <mi>u</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u_{in},u_{out})
  </annotation>
 </semantics>
</math>

, with capacity 

<math display="inline" id="Ford–Fulkerson_algorithm:72">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>u</mi>
      <mrow>
       <mi>i</mi>
       <mi>n</mi>
      </mrow>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>u</mi>
      <mrow>
       <mi>o</mi>
       <mi>u</mi>
       <mi>t</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>d</mi>
    <mi>u</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>u</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(u_{in},u_{out})=d_{u}
  </annotation>
 </semantics>
</math>

. Then apply the Ford–Fulkerson algorithm.</p>
<h2 id="complexity">Complexity</h2>

<p>By adding the flow augmenting path to the flow already established in the graph, the maximum flow will be reached when no more flow augmenting paths can be found in the graph. However, there is no certainty that this situation will ever be reached, so the best that can be guaranteed is that the answer will be correct if the algorithm terminates. In the case that the algorithm runs forever, the flow might not even converge towards the maximum flow. However, this situation only occurs with irrational flow values. When the capacities are integers, the runtime of Ford–Fulkerson is bounded by 

<math display="inline" id="Ford–Fulkerson_algorithm:73">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <mi>f</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(Ef)
  </annotation>
 </semantics>
</math>

 (see <a href="big_O_notation" title="wikilink">big O notation</a>), where 

<math display="inline" id="Ford–Fulkerson_algorithm:74">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is the number of edges in the graph and 

<math display="inline" id="Ford–Fulkerson_algorithm:75">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the maximum flow in the graph. This is because each augmenting path can be found in 

<math display="inline" id="Ford–Fulkerson_algorithm:76">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(E)
  </annotation>
 </semantics>
</math>

 time and increases the flow by an integer amount of at least 

<math display="inline" id="Ford–Fulkerson_algorithm:77">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

.</p>

<p>A variation of the Ford–Fulkerson algorithm with guaranteed termination and a runtime independent of the maximum flow value is the <a href="Edmonds–Karp_algorithm" title="wikilink">Edmonds–Karp algorithm</a>, which runs in 

<math display="inline" id="Ford–Fulkerson_algorithm:78">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <msup>
      <mi>E</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(VE^{2})
  </annotation>
 </semantics>
</math>

 time.</p>
<h2 id="integral-example">Integral example</h2>

<p>The following example shows the first steps of Ford–Fulkerson in a flow network with 4 nodes, source 

<math display="inline" id="Ford–Fulkerson_algorithm:79">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and sink 

<math display="inline" id="Ford–Fulkerson_algorithm:80">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. This example shows the worst-case behaviour of the algorithm. In each step, only a flow of 

<math display="inline" id="Ford–Fulkerson_algorithm:81">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 is sent across the network. If breadth-first-search were used instead, only two steps would be needed.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Path</p></th>
<th style="text-align: left;">
<p>Capacity</p></th>
<th style="text-align: left;">
<p>Resulting flow network</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Initial flow network</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Ford-Fulkerson example 0.svg</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:82">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>,</mo>
   <mi>B</mi>
   <mo>,</mo>
   <mi>C</mi>
   <mo>,</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>A</ci>
    <ci>B</ci>
    <ci>C</ci>
    <ci>D</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,B,C,D
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:83">
 <semantics>
  <mrow>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>f</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>f</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo>,</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>f</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo>,</mo>
       <mi>D</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <min></min>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <ci>A</ci>
       <ci>B</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <ci>B</ci>
       <ci>C</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <ci>C</ci>
       <ci>D</ci>
      </interval>
     </apply>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min(c_{f}(A,B),c_{f}(B,C),c_{f}(C,D))=
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Ford–Fulkerson_algorithm:84">
 <semantics>
  <mrow>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>c</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo>,</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo>,</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>c</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>,</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>,</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>c</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>C</mi>
        <mo>,</mo>
        <mi>D</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>C</mi>
        <mo>,</mo>
        <mi>D</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <min></min>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>A</ci>
        <ci>B</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>A</ci>
        <ci>B</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>B</ci>
        <ci>C</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>B</ci>
        <ci>C</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>C</ci>
        <ci>D</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>C</ci>
        <ci>D</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min(c(A,B)-f(A,B),c(B,C)-f(B,C),c(C,D)-f(C,D))=
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Ford–Fulkerson_algorithm:85">
 <semantics>
  <mrow>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1000</mn>
      <mo>-</mo>
      <mn>0</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mn>0</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mn>1000</mn>
      <mo>-</mo>
      <mn>0</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <min></min>
     <apply>
      <minus></minus>
      <cn type="integer">1000</cn>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1000</cn>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min(1000-0,1-0,1000-0)=1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Ford-Fulkerson example 1.svg</figcaption>
</figure></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:86">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>,</mo>
   <mi>C</mi>
   <mo>,</mo>
   <mi>B</mi>
   <mo>,</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>A</ci>
    <ci>C</ci>
    <ci>B</ci>
    <ci>D</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,C,B,D
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:87">
 <semantics>
  <mrow>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>f</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>f</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo>,</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>f</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo>,</mo>
       <mi>D</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <min></min>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <ci>A</ci>
       <ci>C</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <ci>C</ci>
       <ci>B</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <ci>B</ci>
       <ci>D</ci>
      </interval>
     </apply>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min(c_{f}(A,C),c_{f}(C,B),c_{f}(B,D))=
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Ford–Fulkerson_algorithm:88">
 <semantics>
  <mrow>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>c</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo>,</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo>,</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>c</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>C</mi>
        <mo>,</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>C</mi>
        <mo>,</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>c</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>,</mo>
        <mi>D</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>,</mo>
        <mi>D</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <min></min>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>A</ci>
        <ci>C</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>A</ci>
        <ci>C</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>C</ci>
        <ci>B</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>C</ci>
        <ci>B</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>B</ci>
        <ci>D</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>B</ci>
        <ci>D</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min(c(A,C)-f(A,C),c(C,B)-f(C,B),c(B,D)-f(B,D))=
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Ford–Fulkerson_algorithm:89">
 <semantics>
  <mrow>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1000</mn>
      <mo>-</mo>
      <mn>0</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mn>0</mn>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mn>1000</mn>
      <mo>-</mo>
      <mn>0</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <min></min>
     <apply>
      <minus></minus>
      <cn type="integer">1000</cn>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1000</cn>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min(1000-0,0-(-1),1000-0)=1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Ford-Fulkerson example 2.svg</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>After 1998 more steps …</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Final flow network</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Ford-Fulkerson example final.svg</figcaption>
</figure></td>
</tr>
</tbody>
</table>

<p>Notice how flow is "pushed back" from 

<math display="inline" id="Ford–Fulkerson_algorithm:90">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Ford–Fulkerson_algorithm:91">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 when finding the path 

<math display="inline" id="Ford–Fulkerson_algorithm:92">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>,</mo>
   <mi>C</mi>
   <mo>,</mo>
   <mi>B</mi>
   <mo>,</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>A</ci>
    <ci>C</ci>
    <ci>B</ci>
    <ci>D</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,C,B,D
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="non-terminating-example">Non-terminating example</h2>
<figure><b>(Figure)</b>
<figcaption>Ford-Fulkerson forever.svg</figcaption>
</figure>

<p>Consider the flow network shown on the right, with source 

<math display="inline" id="Ford–Fulkerson_algorithm:93">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, sink 

<math display="inline" id="Ford–Fulkerson_algorithm:94">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, capacities of edges 

<math display="inline" id="Ford–Fulkerson_algorithm:95">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Ford–Fulkerson_algorithm:96">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ford–Fulkerson_algorithm:97">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{3}
  </annotation>
 </semantics>
</math>

 respectively 

<math display="inline" id="Ford–Fulkerson_algorithm:98">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Ford–Fulkerson_algorithm:99">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msqrt>
       <mn>5</mn>
      </msqrt>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <root></root>
       <cn type="integer">5</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=(\sqrt{5}-1)/2
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ford–Fulkerson_algorithm:100">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 and the capacity of all other edges some integer 

<math display="inline" id="Ford–Fulkerson_algorithm:101">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\geq 2
  </annotation>
 </semantics>
</math>

. The constant 

<math display="inline" id="Ford–Fulkerson_algorithm:102">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 was chosen so, that 

<math display="inline" id="Ford–Fulkerson_algorithm:103">
 <semantics>
  <mrow>
   <msup>
    <mi>r</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>r</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{2}=1-r
  </annotation>
 </semantics>
</math>

. We use augmenting paths according to the following table, where 

<math display="inline" id="Ford–Fulkerson_algorithm:104">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <set>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>t</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}=\{s,v_{4},v_{3},v_{2},v_{1},t\}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Ford–Fulkerson_algorithm:105">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>4</mn>
    </msub>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
    <set>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>t</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{2}=\{s,v_{2},v_{3},v_{4},t\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ford–Fulkerson_algorithm:106">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>s</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">3</cn>
    </apply>
    <set>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>t</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{3}=\{s,v_{1},v_{2},v_{3},t\}
  </annotation>
 </semantics>
</math>

.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Step</p></th>
<th style="text-align: left;">
<p>Augmenting path</p></th>
<th style="text-align: left;">
<p>Sent flow</p></th>
<th style="text-align: left;">
<p>Residual capacities</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:107">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:108">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:109">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{3}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:110">
 <semantics>
  <mrow>
   <msup>
    <mi>r</mi>
    <mn>0</mn>
   </msup>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{0}=1
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:111">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>s</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>t</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{s,v_{2},v_{3},t\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:112">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:113">
 <semantics>
  <msup>
   <mi>r</mi>
   <mn>0</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{0}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:114">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:115">
 <semantics>
  <msup>
   <mi>r</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:116">
 <semantics>
  <msup>
   <mi>r</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:117">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:118">
 <semantics>
  <msup>
   <mi>r</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:119">
 <semantics>
  <msup>
   <mi>r</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:120">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:121">
 <semantics>
  <msup>
   <mi>r</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:122">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:123">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{3}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:124">
 <semantics>
  <msup>
   <mi>r</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Ford–Fulkerson_algorithm:125">
 <semantics>
  <msup>
   <mi>r</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Note that after step 1 as well as after step 5, the residual capacities of edges 

<math display="inline" id="Ford–Fulkerson_algorithm:126">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Ford–Fulkerson_algorithm:127">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ford–Fulkerson_algorithm:128">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{3}
  </annotation>
 </semantics>
</math>

 are in the form 

<math display="inline" id="Ford–Fulkerson_algorithm:129">
 <semantics>
  <msup>
   <mi>r</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{n}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Ford–Fulkerson_algorithm:130">
 <semantics>
  <msup>
   <mi>r</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{n+1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ford–Fulkerson_algorithm:131">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

, respectively, for some 

<math display="inline" id="Ford–Fulkerson_algorithm:132">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N}
  </annotation>
 </semantics>
</math>

. This means that we can use augmenting paths 

<math display="inline" id="Ford–Fulkerson_algorithm:133">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Ford–Fulkerson_algorithm:134">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{2}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Ford–Fulkerson_algorithm:135">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ford–Fulkerson_algorithm:136">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{3}
  </annotation>
 </semantics>
</math>

 infinitely many times and residual capacities of these edges will always be in the same form. Total flow in the network after step 5 is 

<math display="inline" id="Ford–Fulkerson_algorithm:137">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>r</mi>
       <mn>1</mn>
      </msup>
      <mo>+</mo>
      <msup>
       <mi>r</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+2(r^{1}+r^{2})
  </annotation>
 </semantics>
</math>

. If we continue to use augmenting paths as above, the total flow converges to 

<math display="inline" id="Ford–Fulkerson_algorithm:138">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <msup>
       <mi>r</mi>
       <mi>i</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>3</mn>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>r</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>r</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">3</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle 1+2\sum_{i=1}^{\infty}r^{i}=3+2r
  </annotation>
 </semantics>
</math>

, while the maximum flow is 

<math display="inline" id="Ford–Fulkerson_algorithm:139">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>M</mi>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>M</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2M+1
  </annotation>
 </semantics>
</math>

. In this case, the algorithm never terminates and the flow doesn't even converge to the maximum flow.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> </p>
<h2 id="python-implementation">Python implementation</h2>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Edge(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, u, v, w):
        <span class="va">self</span>.source <span class="op">=</span> u
        <span class="va">self</span>.sink <span class="op">=</span> v  
        <span class="va">self</span>.capacity <span class="op">=</span> w
    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">return</span> <span class="st">"</span><span class="sc">%s</span><span class="st">-&gt;</span><span class="sc">%s</span><span class="st">:</span><span class="sc">%s</span><span class="st">"</span> <span class="op">%</span> (<span class="va">self</span>.source, <span class="va">self</span>.sink, <span class="va">self</span>.capacity)

<span class="kw">class</span> FlowNetwork(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):
        <span class="va">self</span>.adj <span class="op">=</span> {}
        <span class="va">self</span>.flow <span class="op">=</span> {}
 
    <span class="kw">def</span> add_vertex(<span class="va">self</span>, vertex):
        <span class="va">self</span>.adj[vertex] <span class="op">=</span> []
 
    <span class="kw">def</span> get_edges(<span class="va">self</span>, v):
        <span class="cf">return</span> <span class="va">self</span>.adj[v]
 
    <span class="kw">def</span> add_edge(<span class="va">self</span>, u, v, w<span class="op">=</span><span class="dv">0</span>):
        <span class="cf">if</span> u <span class="op">==</span> v:
            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"u == v"</span>)
        edge <span class="op">=</span> Edge(u,v,w)
        redge <span class="op">=</span> Edge(v,u,<span class="dv">0</span>)
        edge.redge <span class="op">=</span> redge
        redge.redge <span class="op">=</span> edge
        <span class="va">self</span>.adj[u].append(edge)
        <span class="va">self</span>.adj[v].append(redge)
        <span class="va">self</span>.flow[edge] <span class="op">=</span> <span class="dv">0</span>
        <span class="va">self</span>.flow[redge] <span class="op">=</span> <span class="dv">0</span>
 
    <span class="kw">def</span> find_path(<span class="va">self</span>, source, sink, path):
        <span class="cf">if</span> source <span class="op">==</span> sink:
            <span class="cf">return</span> path
        <span class="cf">for</span> edge <span class="op">in</span> <span class="va">self</span>.get_edges(source):
            residual <span class="op">=</span> edge.capacity <span class="op">-</span> <span class="va">self</span>.flow[edge]
            <span class="cf">if</span> residual <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">and</span> edge <span class="op">not</span> <span class="op">in</span> path:
                result <span class="op">=</span> <span class="va">self</span>.find_path( edge.sink, sink, path <span class="op">+</span> [edge]) 
                <span class="cf">if</span> result <span class="op">!=</span> <span class="va">None</span>:
                    <span class="cf">return</span> result
 
    <span class="kw">def</span> max_flow(<span class="va">self</span>, source, sink):
        path <span class="op">=</span> <span class="va">self</span>.find_path(source, sink, [])
        <span class="cf">while</span> path <span class="op">!=</span> <span class="va">None</span>:
            residuals <span class="op">=</span> [edge.capacity <span class="op">-</span> <span class="va">self</span>.flow[edge] <span class="cf">for</span> edge <span class="op">in</span> path]
            flow <span class="op">=</span> <span class="bu">min</span>(residuals)
            <span class="cf">for</span> edge <span class="op">in</span> path:
                <span class="va">self</span>.flow[edge] <span class="op">+=</span> flow
                <span class="va">self</span>.flow[edge.redge] <span class="op">-=</span> flow
            path <span class="op">=</span> <span class="va">self</span>.find_path(source, sink, [])
        <span class="cf">return</span> <span class="bu">sum</span>(<span class="va">self</span>.flow[edge] <span class="cf">for</span> edge <span class="op">in</span> <span class="va">self</span>.get_edges(source))</code></pre></div>
<h3 id="usage-example">Usage example</h3>

<p>For the example flow network in <a href="maximum_flow_problem" title="wikilink">maximum flow problem</a> we do the following:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> g <span class="op">=</span> FlowNetwork()
<span class="op">&gt;&gt;&gt;</span> [g.add_vertex(v) <span class="cf">for</span> v <span class="op">in</span> <span class="st">"sopqrt"</span>]
[<span class="va">None</span>, <span class="va">None</span>, <span class="va">None</span>, <span class="va">None</span>, <span class="va">None</span>, <span class="va">None</span>]
<span class="op">&gt;&gt;&gt;</span>
<span class="op">&gt;&gt;&gt;</span> g.add_edge(<span class="st">'s'</span>,<span class="st">'o'</span>,<span class="dv">3</span>)
<span class="op">&gt;&gt;&gt;</span> g.add_edge(<span class="st">'s'</span>,<span class="st">'p'</span>,<span class="dv">3</span>)
<span class="op">&gt;&gt;&gt;</span> g.add_edge(<span class="st">'o'</span>,<span class="st">'p'</span>,<span class="dv">2</span>)
<span class="op">&gt;&gt;&gt;</span> g.add_edge(<span class="st">'o'</span>,<span class="st">'q'</span>,<span class="dv">3</span>)
<span class="op">&gt;&gt;&gt;</span> g.add_edge(<span class="st">'p'</span>,<span class="st">'r'</span>,<span class="dv">2</span>)
<span class="op">&gt;&gt;&gt;</span> g.add_edge(<span class="st">'r'</span>,<span class="st">'t'</span>,<span class="dv">3</span>)
<span class="op">&gt;&gt;&gt;</span> g.add_edge(<span class="st">'q'</span>,<span class="st">'r'</span>,<span class="dv">4</span>)
<span class="op">&gt;&gt;&gt;</span> g.add_edge(<span class="st">'q'</span>,<span class="st">'t'</span>,<span class="dv">2</span>)
<span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span> (g.max_flow(<span class="st">'s'</span>,<span class="st">'t'</span>))
<span class="dv">5</span></code></pre></div>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Approximate_max-flow_min-cut_theorem" title="wikilink">Approximate max-flow min-cut theorem</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>[<a class="uri" href="http://community.topcoder.com/tc?module=Static&amp;d1">http://community.topcoder.com/tc?module=Static&amp;d1;</a>;=tutorials&amp;d2;=maxFlow A tutorial explaining the Ford–Flukerson method to solve the max-flow problem]</li>
<li><a href="http://www.cs.pitt.edu/~kirk/cs1501/animations/Network.html">Another Java animation</a></li>
<li><a href="http://rrusin.blogspot.com/2011/03/implementing-graph-editor-in-javafx.html">Java Web Start application</a></li>
</ul>

<p>"</p>

<p><a href="Category:Network_flow" title="wikilink">Category:Network flow</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>

