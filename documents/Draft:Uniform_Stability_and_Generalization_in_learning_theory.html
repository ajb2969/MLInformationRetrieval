<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1439">Draft:Uniform Stability and Generalization in learning theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Draft:Uniform Stability and Generalization in learning theory</h1>
<hr/>
<hr/>

<p>--<a href="User:Brandojazz" title="wikilink">Brandojazz</a> (<a href="User_talk:Brandojazz" title="wikilink">talk</a>) 01:57, 8 December 2014 (UTC)</p>
<h1 id="uniform-stability-and-generalization-in-learning-theory">Uniform Stability and Generalization in learning theory</h1>

<p>The notion of <a href="Stability_(learning_theory)" title="wikilink">stability</a> is one which captures how much a predictive function changes when the training set is changed slightly. When an algorithm is uniformly stable, intuitively, it means that the algorithm is resistant, in the "worst case", to a change in the training set. In other words, for all training sets and any changes to this training set, the predictive accuracy should not change in a noticeable way. Hence, since the algorithm didn't change that much, then its error shouldn't change (too much) either.</p>

<p>In this article we will show that if a learning algorithm 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:0">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is uniformly stable in a precise sense, then it will generalize. i.e. the error in the training set will be a true reflection of the quality of our predictions on unseen data points. In other words, if the algorithm is resistant to small perturbations in the training set as defined by uniform stability, then we can mathematically show that the learning algorithm will be able to make good predictions on sample points that are inside our training set as well as samples that are not.</p>
<h2 id="motivation">Motivation</h2>

<p>Why would someone want their learning algorithm to be stable in any sense? One can intuitively motivate the concept of stability with the analogy of a scientific theory, where the power of our predictor lies in the predictive power of the scientific theory. If we had a good scientific theory and thus a good predictor, then it should have been able to see general trends in the data that inspired this theory. In other words, small changes to the data that inspired this theory, should not affect the theory as a whole to much, because the theory was able to extract the general trends effectively in a predictive manner. If it was a good theory in the first place, then small changes in the training data should not affect its success to predict unseen data samples. Similarly, if we have a learning algorithm that is able to generalize on unseen data points, then if the algorithm was "good" at learning from the data it had, then small perturbations on that data should not affect its predictive power too much. This intuitive idea can actually be made mathematically rigorous with uniform stability. If a learning algorithm is (uniformly) stable then, from the previous argument, it makes sense that it should have good predictive power on data it has already seen and data it has not yet seen. i.e. if the learning algorithm is stable, it should be able to generalize.</p>
<h1 id="preliminary-definitions">Preliminary definitions</h1>

<p>This article can be heavy in notation and its important to clarify that. The notation has already been established in <a href="Stability_(learning_theory)#Preliminary_definitions" title="wikilink">the following wikipedia article.</a> Please refer to that for details on the notation.</p>
<h1 id="formal-definition-of-uniform-stability">Formal Definition of Uniform Stability</h1>

<p>An algorithm 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:1">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 has <a href="Stability_(learning_theory)#Uniform_Stability" title="wikilink">uniform stability</a> β with respect to the loss function V if the following holds:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>S</mi>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mi>Z</mi>
     <mi>m</mi>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>i</mi>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>m</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mo>sup</mo>
       <mrow>
        <mi>z</mi>
        <mo>∈</mo>
        <mi>Z</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mrow>
         <mi>V</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>f</mi>
           <mi>S</mi>
          </msub>
          <mo>,</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>V</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>f</mi>
           <msup>
            <mi>S</mi>
            <mi>i</mi>
           </msup>
          </msub>
          <mo>,</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo>≤</mo>
     <mi>β</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Z</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>i</ci>
      </apply>
      <set>
       <cn type="integer">1</cn>
       <ci>normal-…</ci>
       <ci>m</ci>
      </set>
     </apply>
     <apply>
      <leq></leq>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">supremum</csymbol>
        <apply>
         <in></in>
         <ci>z</ci>
         <ci>Z</ci>
        </apply>
       </apply>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>V</ci>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <ci>S</ci>
           </apply>
           <ci>z</ci>
          </interval>
         </apply>
         <apply>
          <times></times>
          <ci>V</ci>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <ci>i</ci>
            </apply>
           </apply>
           <ci>z</ci>
          </interval>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>β</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall S\in Z^{m},\forall i\in\{1,...,m\},\sup_{z\in Z}|V(f_{S},z)-V(f_{S^{i}%
},z)|\leq\beta
  </annotation>
 </semantics>
</math>

</p>

<p>A probabilistic version of uniform stability β is:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:3">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>S</mi>
   <mo>∈</mo>
   <msup>
    <mi>Z</mi>
    <mi>m</mi>
   </msup>
   <mo>,</mo>
   <mo>∀</mo>
   <mi>i</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>m</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>,</mo>
   <msub>
    <mi>ℙ</mi>
    <mi>S</mi>
   </msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mo>sup</mo>
     <mrow>
      <mi>z</mi>
      <mo>∈</mo>
      <mi>Z</mi>
     </mrow>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mi>S</mi>
     </msub>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <msup>
       <mi>S</mi>
       <mi>i</mi>
      </msup>
     </msub>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mo>≤</mo>
    <mi>β</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>≥</mo>
   <mn>1</mn>
   <mo>-</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Z</ci>
     <ci>m</ci>
    </apply>
    <ci>normal-,</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <in></in>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℙ</ci>
     <ci>S</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <in></in>
       <ci>z</ci>
       <ci>Z</ci>
      </apply>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <minus></minus>
     <csymbol cd="unknown">V</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>S</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <leq></leq>
     <csymbol cd="unknown">β</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <geq></geq>
    <cn type="integer">1</cn>
    <minus></minus>
    <csymbol cd="unknown">δ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall S\in Z^{m},\forall i\in\{1,...,m\},\mathbb{P}_{S}\{\sup_{z\in Z}|V(f_{%
S},z)-V(f_{S^{i}},z)|\leq\beta\}\geq 1-\delta
  </annotation>
 </semantics>
</math>

</p>
<h1 id="final-results-of-uniform-stability-and-generalization">Final Results of Uniform Stability and Generalization</h1>

<p>If a learning algorithm 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:4">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is uniformly stable and also has a bounded loss function, then with confidence 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:5">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\delta
  </annotation>
 </semantics>
</math>

 the difference between the empirical risk and the generalization error will be upper bounded as follows:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi>β</mi>
     <mi>n</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
        <msub>
         <mi>β</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo>+</mo>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msqrt>
      <mfrac>
       <mrow>
        <mi>l</mi>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mfrac>
          <mn>2</mn>
          <mi>δ</mi>
         </mfrac>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </mfrac>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>l</ci>
         <ci>n</ci>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>δ</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I[f_{S}]-I_{S}[f_{S}]\leq\beta_{n}+(2n\beta_{n}+M)\sqrt{\frac{ln(\frac{2}{%
\delta})}{2n}}
  </annotation>
 </semantics>
</math>

</p>

<p>Specifically, if one has a uniformly stable learning algorithm with 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:7">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{n}=O\left(\frac{1}{n}\right)
  </annotation>
 </semantics>
</math>

, then the upper bound becomes:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mi>n</mi>
      </msqrt>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I[f_{S}]-I_{S}[f_{S}]\leq O\left(\frac{1}{\sqrt{n}}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>which clearly approaches zero as n approaches infinity. Therefore, the empirical risk is equal to the generalization error for sufficiently large and thus, the empirical risk is a good proxy for the generalization error. In this case, we say that the learning algorithm generalizes.</p>
<h3 id="remarks">Remarks</h3>
<h4 id="why-minimizing-the-empirical-risk-is-a-good-idea-for-large-training-sets">Why minimizing the empirical risk is a good idea for large training sets</h4>

<p>Notice that this result is basically saying that for sufficiently large n, the empirical risk and the generalization error are approximately equal. Therefore, this means that given enough training data, finding a predictor that minimizes the empirical risk will actually also minimize the generalization error. Therefore, for a stable learning algorithm, minimizing the empirical risk is actually a good procedure for minimizing generalization (since the two are approximately equal for sufficiently large n).</p>

<p>Unfortunately, this is obviously an asymptotic bound and therefore, large values of n are needed. However, this result does justify why minimizing the empirical risk for large training sets might be a good idea.</p>
<h4 id="justification-for-bounded-loss-function">Justification for bounded loss function</h4>

<p>One immediate argument that one could hold against such a theoretical result is an argument against the bounded loss function. In reality, we never choose a bounded loss function. For example, the squared loss, is not bounded for all values on the real line. However, the important argument made to justify such an argument is that in reality, we will never actually expect to observe every value of the real line. Within a realistic domain of values that any reasonable training set might have, we will observe finite bounded numbers 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:9">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

. Therefore, since we don't expect to get any value of the real line, we approximately have a bounded loss function.</p>
<h2 id="example-of-a-uniformly-stable">Example of a Uniformly Stable</h2>
<h3 id="tikhonov-regularization">Tikhonov Regularization</h3>

<p>Recall tikhonov regularization to be:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:10">
 <semantics>
  <mrow>
   <msubsup>
    <mi>f</mi>
    <mi>S</mi>
    <mi>λ</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mi>r</mi>
    <mi>g</mi>
    <mrow>
     <msub>
      <mi>min</mi>
      <mrow>
       <mi>f</mi>
       <mo>∈</mo>
       <mi class="ltx_font_mathcaligraphic">ℋ</mi>
      </mrow>
     </msub>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mi>n</mi>
        </mfrac>
        <mrow>
         <msubsup>
          <mo largeop="true" symmetric="true">∑</mo>
          <mrow>
           <mi>i</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
          <mi>n</mi>
         </msubsup>
         <mrow>
          <mi>V</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>f</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <msub>
              <mi>x</mi>
              <mi>i</mi>
             </msub>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>,</mo>
           <msub>
            <mi>y</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>λ</mi>
        <msubsup>
         <mrow>
          <mo fence="true">||</mo>
          <mi>f</mi>
          <mo fence="true">||</mo>
         </mrow>
         <msup>
          <mi>ℝ</mi>
          <mi>k</mi>
         </msup>
         <mn>2</mn>
        </msubsup>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>λ</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>r</ci>
     <ci>g</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <min></min>
       <apply>
        <in></in>
        <ci>f</ci>
        <ci>ℋ</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>n</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <sum></sum>
           <ci>n</ci>
          </apply>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>V</ci>
          <interval closure="open">
           <apply>
            <times></times>
            <ci>f</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>y</ci>
            <ci>i</ci>
           </apply>
          </interval>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>λ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="latexml">norm</csymbol>
           <ci>f</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ℝ</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\lambda}_{S}=arg\min_{f\in\mathcal{H}}\left(\frac{1}{n}\sum^{n}_{i=1}V(f(x_%
{i}),y_{i})+\lambda||f||^{2}_{\mathbb{R}^{k}}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>it can be shown that tikhonov regularization is uniformly stable. If that is true then tikhonov regularization is proved to generalize.</p>

<p>To prove that Tikhonov regularization is stable we only need to show these three statements to be true:</p>

<p>1) we assume that the loss is Lipschitz continuous

<math display="block" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <msup>
        <mi>y</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mn>2</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <msup>
        <mi>y</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>L</mi>
    <msub>
     <mrow>
      <mo fence="true">||</mo>
      <mrow>
       <msub>
        <mi>f</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>f</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo fence="true">||</mo>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>V</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>i</ci>
         </apply>
         <ci>x</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <ci>normal-′</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>V</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>x</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <ci>normal-′</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V(f_{i}(x),y^{\prime})-V(f_{2}(x),y^{\prime})|\leq L||f_{1}-f_{2}||_{\infty}
  </annotation>
 </semantics>
</math>

</p>

<p>2) we need that the hypothesis class to be over reproducing kernel Hilbert spaces (RKHS)

<math display="block" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:12">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <mi>f</mi>
      <mo>-</mo>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msub>
   <mo>≤</mo>
   <mrow>
    <mi>κ</mi>
    <msub>
     <mrow>
      <mo fence="true">||</mo>
      <mrow>
       <mi>f</mi>
       <mo>-</mo>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
      </mrow>
      <mo fence="true">||</mo>
     </mrow>
     <msup>
      <mi>ℝ</mi>
      <mi>K</mi>
     </msup>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <times></times>
     <ci>κ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>K</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||f-f^{\prime}||_{\infty}\leq\kappa||f-f^{\prime}||_{\mathbb{R}^{K}}
  </annotation>
 </semantics>
</math>

 for any 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>,</mo>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
    </list>
    <ci>ℋ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f,f^{\prime}\in\mathcal{H}
  </annotation>
 </semantics>
</math>

</p>

<p>3) finally we need the following lemma to hold

<math display="block" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:14">
 <semantics>
  <mrow>
   <msubsup>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <msubsup>
       <mi>f</mi>
       <mi>S</mi>
       <mi>λ</mi>
      </msubsup>
      <mo>-</mo>
      <msubsup>
       <mi>f</mi>
       <msup>
        <mi>S</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>z</mi>
        </mrow>
       </msup>
       <mi>λ</mi>
      </msubsup>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>K</mi>
    </msup>
    <mn>2</mn>
   </msubsup>
   <mo>≤</mo>
   <mfrac>
    <mrow>
     <mi>L</mi>
     <msub>
      <mrow>
       <mo fence="true">||</mo>
       <mrow>
        <msubsup>
         <mi>f</mi>
         <mi>S</mi>
         <mi>λ</mi>
        </msubsup>
        <mo>-</mo>
        <msubsup>
         <mi>f</mi>
         <msup>
          <mi>S</mi>
          <mrow>
           <mi>i</mi>
           <mo>,</mo>
           <mi>z</mi>
          </mrow>
         </msup>
         <mi>λ</mi>
        </msubsup>
       </mrow>
       <mo fence="true">||</mo>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msub>
    </mrow>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>f</ci>
          <ci>λ</ci>
         </apply>
         <ci>S</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>f</ci>
          <ci>λ</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>S</ci>
          <list>
           <ci>i</ci>
           <ci>z</ci>
          </list>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>K</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>f</ci>
           <ci>λ</ci>
          </apply>
          <ci>S</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>f</ci>
           <ci>λ</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>S</ci>
           <list>
            <ci>i</ci>
            <ci>z</ci>
           </list>
          </apply>
         </apply>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||f^{\lambda}_{S}-f^{\lambda}_{S^{i,z}}||^{2}_{\mathbb{R}^{K}}\leq\frac{L||f^{%
\lambda}_{S}-f^{\lambda}_{S^{i,z}}||_{\infty}}{\lambda n}
  </annotation>
 </semantics>
</math>

</p>

<p>If the above holds and the loss function is upper bounded by M, then the generalization bound has the following form:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>I</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <msubsup>
        <mi>f</mi>
        <mi>S</mi>
        <mi>λ</mi>
       </msubsup>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>I</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <msubsup>
        <mi>f</mi>
        <mi>S</mi>
        <mi>λ</mi>
       </msubsup>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msup>
       <mi>L</mi>
       <mn>2</mn>
      </msup>
      <msup>
       <mi>κ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mrow>
      <mi>λ</mi>
      <mi>n</mi>
     </mrow>
    </mfrac>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mfrac>
        <mrow>
         <mn>2</mn>
         <msup>
          <mi>L</mi>
          <mn>2</mn>
         </msup>
         <msup>
          <mi>κ</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mrow>
         <mi>λ</mi>
         <mi>n</mi>
        </mrow>
       </mfrac>
       <mo>+</mo>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msqrt>
      <mfrac>
       <mrow>
        <mn>2</mn>
        <mi>l</mi>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mfrac>
          <mn>2</mn>
          <mi>δ</mi>
         </mfrac>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mi>n</mi>
      </mfrac>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>I</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>f</ci>
          <ci>λ</ci>
         </apply>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>f</ci>
          <ci>λ</ci>
         </apply>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>κ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>L</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>κ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>λ</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>l</ci>
         <ci>n</ci>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>δ</ci>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |I[f^{\lambda}_{S}]-I_{S}[f^{\lambda}_{S}]|\leq\frac{L^{2}\kappa^{2}}{\lambda n%
}+(\frac{2L^{2}\kappa^{2}}{\lambda n}+M)\sqrt{\frac{2ln(\frac{2}{\delta})}{n}}
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, with confidence 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:16">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\delta
  </annotation>
 </semantics>
</math>

, tikhonov regularization generalizes as n goes to infinity.</p>
<h4 id="remarks-on-bound">Remarks on Bound</h4>

<p>Notice that keeping 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:17">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 fixed as n increases, the generalization tightens as 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:18">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\frac{1}{\sqrt{n}}\right)
  </annotation>
 </semantics>
</math>

. However, fixing 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:19">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 keeps our hypothesis spaced fixed. However, as we get more data, we want 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:20">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 to get smaller. However, if 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:21">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 gets smaller too quickly, then the bounds have the potential to become vacuous.</p>
<h2 id="statement">Statement</h2>

<p>If a learning algorithm 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:22">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is uniformly stable, then as the number of training points approaches infinity the empirical risk approaches the generalization error with high probability i.e.</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>n</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>f</mi>
      <mi>S</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{n\to\infty}I_{S}[f_{S}]=I[f_{S}]
  </annotation>
 </semantics>
</math>

</p>

<p>with high probability.</p>

<p>Therefore, our goal will be to show that if uniform stability holds for 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:24">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

, then the difference between the empirical error and the generalization error will go to zero with high probability i.e.:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:25">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>I</mi>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>f</mi>
      <mi>S</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>-</mo>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>f</mi>
      <mi>S</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mo>≤</mo>
    <mi>ϵ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≥</mo>
   <mn>1</mn>
   <mo>-</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>S</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
      <ci>normal-]</ci>
     </cerror>
     <minus></minus>
     <csymbol cd="unknown">I</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-|</ci>
     <leq></leq>
     <csymbol cd="unknown">ϵ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <geq></geq>
    <cn type="integer">1</cn>
    <minus></minus>
    <csymbol cd="unknown">δ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr[|I_{S}[f_{S}]-I[f_{S}]|\leq\epsilon(n)]\geq 1-\delta
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:26">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϵ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon(n)
  </annotation>
 </semantics>
</math>

 will be an upper bound that approaches zero as n approaches infinity.</p>
<h3 id="proof">Proof</h3>

<p>Let's begin the proof by using the fact that our learning algorithm is uniformly stable. If the learning algorithm

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:27">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is uniformly stable, then using McDiarmid's inequality, and setting the generalization error to be the functional yields:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:28">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>Z</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>,</mo>
   <mo>∀</mo>
   <mi>i</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>,</mo>
   <msub>
    <mo>sup</mo>
    <mrow>
     <mi>z</mi>
     <mo>∈</mo>
     <mi>Z</mi>
    </mrow>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>f</mi>
     <mi>S</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>-</mo>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>f</mi>
     <msup>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>z</mi>
      </mrow>
     </msup>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mo>≤</mo>
   <mi>β</mi>
   <mo>⟹</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">|</mo>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>f</mi>
      <mi>S</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>𝔼</mi>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mo>≥</mo>
    <mi>ϵ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <mn>2</mn>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <msup>
         <mi>ϵ</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
      <mrow>
       <mi>n</mi>
       <msup>
        <mi>β</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Z</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-,</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <in></in>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <in></in>
      <ci>z</ci>
      <ci>Z</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">I</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>S</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">I</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <list>
        <ci>i</ci>
        <ci>z</ci>
       </list>
      </apply>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-|</ci>
    <leq></leq>
    <csymbol cd="unknown">β</csymbol>
    <implies></implies>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-|</ci>
     <csymbol cd="unknown">I</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
      <ci>normal-]</ci>
     </cerror>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <ci>S</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">I</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-|</ci>
     <geq></geq>
     <csymbol cd="unknown">ϵ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ϵ</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>β</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall(S,z)\in Z^{n+1},\forall i\in\{1,...,n\},\sup_{z\in Z}|I[f_{S}]-I[f_{S^%
{i,z}}]|\leq\beta\implies P(|I[f_{S}]-\mathbb{E}_{S}[I[f_{S}]]|\geq\epsilon)%
\leq 2e^{\left(\frac{-2\epsilon^{2}}{n\beta^{2}}\right)}
  </annotation>
 </semantics>
</math>

</p>

<p>Which says that the generalization error will be close to the expected generalization error over training sets with high probability. If we change the above probabilistic statement to its confidence form and demand to have 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:29">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\delta
  </annotation>
 </semantics>
</math>

 confidence that 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:30">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>f</mi>
     <mi>S</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I[f_{S}]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:31">
 <semantics>
  <mrow>
   <msub>
    <mi>𝔼</mi>
    <mi>S</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔼</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{S}[I[f_{S}]]
  </annotation>
 </semantics>
</math>

 are close, then after the bound equal to 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:32">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 and some lines of algebra, its easy to verify that 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:33">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 must be at most:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:34">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mi>β</mi>
    <msqrt>
     <mfrac>
      <mrow>
       <mi>l</mi>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mfrac>
         <mn>2</mn>
         <mi>δ</mi>
        </mfrac>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
      </mrow>
     </mfrac>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϵ</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>β</ci>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>l</ci>
        <ci>n</ci>
        <apply>
         <divide></divide>
         <cn type="integer">2</cn>
         <ci>δ</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon=n\beta\sqrt{\frac{ln(\frac{2}{\delta})}{2n}}
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, we have with confidence 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:35">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\delta
  </annotation>
 </semantics>
</math>

 that:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>I</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>f</mi>
        <mi>S</mi>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>𝔼</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>I</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <msub>
          <mi>f</mi>
          <mi>S</mi>
         </msub>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>n</mi>
    <mi>β</mi>
    <msqrt>
     <mfrac>
      <mrow>
       <mi>l</mi>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mfrac>
         <mn>2</mn>
         <mi>δ</mi>
        </mfrac>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
      </mrow>
     </mfrac>
    </msqrt>
   </mrow>
   <mo>⟹</mo>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>f</mi>
      <mi>S</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>f</mi>
         <mi>S</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <mi>β</mi>
     <msqrt>
      <mfrac>
       <mrow>
        <mi>l</mi>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mfrac>
          <mn>2</mn>
          <mi>δ</mi>
         </mfrac>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </mfrac>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>I</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>S</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝔼</ci>
         <ci>S</ci>
        </apply>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <times></times>
          <ci>I</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <ci>S</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>β</ci>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>l</ci>
         <ci>n</ci>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>δ</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <implies></implies>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>I</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>S</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>β</ci>
       <apply>
        <root></root>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>l</ci>
          <ci>n</ci>
          <apply>
           <divide></divide>
           <cn type="integer">2</cn>
           <ci>δ</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |I[f_{S}]-\mathbb{E}_{S}[I[f_{S}]]|\leq n\beta\sqrt{\frac{ln(\frac{2}{\delta})%
}{2n}}\implies I[f_{S}]\leq\mathbb{E}_{S}[I[f_{S}]]+n\beta\sqrt{\frac{ln(\frac%
{2}{\delta})}{2n}}
  </annotation>
 </semantics>
</math>

</p>

<p>The above statement is an upper bound on the generalization error, which can be turned into the desired bound (i.e. one bounding the difference of the empirical risk and generalization error) easily by subtracting the empirical risk 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:37">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>S</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>f</mi>
     <mi>S</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{S}[f_{S}]
  </annotation>
 </semantics>
</math>

 from both sides of the inequality yielding:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>𝔼</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>I</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <msub>
          <mi>f</mi>
          <mi>S</mi>
         </msub>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>I</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>f</mi>
        <mi>S</mi>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <mi>β</mi>
     <msqrt>
      <mfrac>
       <mrow>
        <mi>l</mi>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mfrac>
          <mn>2</mn>
          <mi>δ</mi>
         </mfrac>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </mfrac>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>I</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>S</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>β</ci>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>l</ci>
         <ci>n</ci>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>δ</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I[f_{S}]-I_{S}[f_{S}]\leq\mathbb{E}_{S}[I[f_{S}]]-I_{S}[f_{S}]+n\beta\sqrt{%
\frac{ln(\frac{2}{\delta})}{2n}}
  </annotation>
 </semantics>
</math>

</p>

<p>the LHS is exactly what we need to conclude the proof, however we need to finish upper bounding the RHS, specifically we need to upper bound 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:39">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>I</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>f</mi>
        <mi>S</mi>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <msub>
     <mi>I</mi>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>f</mi>
      <mi>S</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>I</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{S}[I[f_{S}]]-I_{S}[f_{S}]
  </annotation>
 </semantics>
</math>

 to conclude the proof.</p>

<p>The upper bound for 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>I</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>f</mi>
        <mi>S</mi>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <msub>
     <mi>I</mi>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>f</mi>
      <mi>S</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>I</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{S}[I[f_{S}]]-I_{S}[f_{S}]
  </annotation>
 </semantics>
</math>

 is exactly:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>f</mi>
         <mi>S</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>β</mi>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mi>β</mi>
       </mrow>
       <mo>+</mo>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msqrt>
      <mfrac>
       <mrow>
        <mi>l</mi>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mfrac>
          <mn>2</mn>
          <mi>δ</mi>
         </mfrac>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </mfrac>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>I</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>S</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>β</ci>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>β</ci>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>l</ci>
         <ci>n</ci>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>δ</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{S}[I[f_{S}]]-I_{S}[f_{S}]\leq\beta+(n\beta+M)\sqrt{\frac{ln(\frac{%
2}{\delta})}{2n}}
  </annotation>
 </semantics>
</math>

</p>

<p>where M is the upper bound on the loss function 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:42">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <interval closure="open">
     <ci>f</ci>
     <ci>z</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(f,z)
  </annotation>
 </semantics>
</math>

.</p>

<p>If that is true then the proof concludes that:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>β</mi>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
        <mi>β</mi>
       </mrow>
       <mo>+</mo>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msqrt>
      <mfrac>
       <mrow>
        <mi>l</mi>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mfrac>
          <mn>2</mn>
          <mi>δ</mi>
         </mfrac>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </mfrac>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>β</ci>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
        <ci>β</ci>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>l</ci>
         <ci>n</ci>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>δ</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I[f_{S}]-I_{S}[f_{S}]\leq\beta+(2n\beta+M)\sqrt{\frac{ln(\frac{2}{\delta})}{2n}}
  </annotation>
 </semantics>
</math>

</p>

<p>Which gives the desired upper bound and as long as the upper bound decreases as n increases, then the generalization error and empirical risk can be made arbitrarily close.</p>

<p>We will finish the proof by proving what we need in the following lemma:</p>
<h4 id="lemma">Lemma</h4>

<p>For a bounded loss function 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:44">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <interval closure="open">
     <ci>f</ci>
     <ci>z</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(f,z)
  </annotation>
 </semantics>
</math>

 (with upper bound M) and a uniformly stable learning algorithm the following upper bound holds with confidence 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:45">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\delta
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>f</mi>
         <mi>S</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>β</mi>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mi>β</mi>
       </mrow>
       <mo>+</mo>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msqrt>
      <mfrac>
       <mrow>
        <mi>l</mi>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mfrac>
          <mn>2</mn>
          <mi>δ</mi>
         </mfrac>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </mfrac>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>I</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>S</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>β</ci>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>β</ci>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>l</ci>
         <ci>n</ci>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>δ</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{S}[I[f_{S}]]-I_{S}[f_{S}]\leq\beta+(n\beta+M)\sqrt{\frac{ln(\frac{%
2}{\delta})}{2n}}
  </annotation>
 </semantics>
</math>

</p>
<h5 id="proof-1">Proof</h5>

<p>Notice that the above statement is the difference of 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:47">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>S</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>f</mi>
     <mi>S</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{S}[f_{S}]
  </annotation>
 </semantics>
</math>

 and the expected value of a different quanity. This suggests that setting 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:48">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>S</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>f</mi>
     <mi>S</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{S}[f_{S}]
  </annotation>
 </semantics>
</math>

 to be the functional in McDiarmids inequality might be good first step to yield the above result. Thus, we wull use McDiarmid's inequality and let the functional F in McDiarmid's be 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:49">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>S</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>f</mi>
     <mi>S</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{S}[f_{S}]
  </annotation>
 </semantics>
</math>

. If that is our choice of functional then we must show the following first</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mo>sup</mo>
      <mrow>
       <mi>S</mi>
       <mo>,</mo>
       <mi>z</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>I</mi>
         <mi>S</mi>
        </msub>
        <mrow>
         <mo stretchy="false">[</mo>
         <msub>
          <mi>f</mi>
          <mi>S</mi>
         </msub>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>I</mi>
         <msup>
          <mi>S</mi>
          <mrow>
           <mi>i</mi>
           <mo>,</mo>
           <mi>z</mi>
          </mrow>
         </msup>
        </msub>
        <mrow>
         <mo stretchy="false">[</mo>
         <msub>
          <mi>f</mi>
          <msup>
           <mi>S</mi>
           <mrow>
            <mi>i</mi>
            <mo>,</mo>
            <mi>z</mi>
           </mrow>
          </msup>
         </msub>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <msub>
    <mi>c</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <list>
        <ci>S</ci>
        <ci>z</ci>
       </list>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>S</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>S</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>S</ci>
           <list>
            <ci>i</ci>
            <ci>z</ci>
           </list>
          </apply>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>S</ci>
            <list>
             <ci>i</ci>
             <ci>z</ci>
            </list>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i,\sup_{S,z}|I_{S}[f_{S}]-I_{S^{i,z}}[f_{S^{i,z}}]|\leq c_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>if we want the probabilistic upper bound on 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:51">
 <semantics>
  <mrow>
   <msub>
    <mi>𝔼</mi>
    <mi>S</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔼</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{S}[I_{S}[f_{S}]]
  </annotation>
 </semantics>
</math>

 to hold.</p>

<p>Let's search for the upper bound 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:52">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}
  </annotation>
 </semantics>
</math>

 by considering the LHS of the above inequality and expanding it:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mo>sup</mo>
      <mrow>
       <mi>S</mi>
       <mo>,</mo>
       <mi>z</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>I</mi>
         <mi>S</mi>
        </msub>
        <mrow>
         <mo stretchy="false">[</mo>
         <msub>
          <mi>f</mi>
          <mi>S</mi>
         </msub>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>I</mi>
         <msup>
          <mi>S</mi>
          <mrow>
           <mi>i</mi>
           <mo>,</mo>
           <mi>z</mi>
          </mrow>
         </msup>
        </msub>
        <mrow>
         <mo stretchy="false">[</mo>
         <msubsup>
          <mi>f</mi>
          <mi>S</mi>
          <mrow>
           <mi>i</mi>
           <mo>,</mo>
           <mi>z</mi>
          </mrow>
         </msubsup>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mi>n</mi>
      </mfrac>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </msubsup>
       <mrow>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>f</mi>
          <mi>s</mi>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>z</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mi>n</mi>
        </mfrac>
        <mrow>
         <msub>
          <mo largeop="true" symmetric="true">∑</mo>
          <mrow>
           <mi>j</mi>
           <mo>≠</mo>
           <mi>i</mi>
          </mrow>
         </msub>
         <mrow>
          <mi>V</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>f</mi>
            <msup>
             <mi>S</mi>
             <mrow>
              <mi>i</mi>
              <mo>,</mo>
              <mi>z</mi>
             </mrow>
            </msup>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>z</mi>
            <mi>j</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mi>n</mi>
        </mfrac>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>f</mi>
          <msup>
           <mi>S</mi>
           <mrow>
            <mi>i</mi>
            <mo>,</mo>
            <mi>z</mi>
           </mrow>
          </msup>
         </msub>
         <mo>,</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <list>
        <ci>S</ci>
        <ci>z</ci>
       </list>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>S</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>S</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>S</ci>
           <list>
            <ci>i</ci>
            <ci>z</ci>
           </list>
          </apply>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <ci>S</ci>
           </apply>
           <list>
            <ci>i</ci>
            <ci>z</ci>
           </list>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </list>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>n</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <sum></sum>
          <ci>n</ci>
         </apply>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>V</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>s</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>z</ci>
           <ci>i</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>n</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <neq></neq>
           <ci>j</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>V</ci>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <list>
              <ci>i</ci>
              <ci>z</ci>
             </list>
            </apply>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>z</ci>
            <ci>j</ci>
           </apply>
          </interval>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>n</ci>
        </apply>
        <ci>V</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>S</ci>
           <list>
            <ci>i</ci>
            <ci>z</ci>
           </list>
          </apply>
         </apply>
         <ci>z</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i,\sup_{S,z}|I_{S}[f_{S}]-I_{S^{i,z}}[f_{S}^{i,z}]|=|\frac{1}{n}\sum^{%
n}_{i=1}V(f_{s},z_{i})-(\frac{1}{n}\sum_{j\neq i}V(f_{S^{i,z}},z_{j})+\frac{1}%
{n}V(f_{S^{i,z}},z))|
  </annotation>
 </semantics>
</math>

</p>

<p>by triangle inequality and pairing up the samples points 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:54">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mi>i</mi>
   </msub>
   <mo>≠</mo>
   <msub>
    <mi>z</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{i}\neq z_{j}
  </annotation>
 </semantics>
</math>

 in the summations we get:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:55">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>≠</mo>
        <mi>i</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mrow>
         <mi>V</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>f</mi>
           <mi>S</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>z</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>V</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>f</mi>
           <msup>
            <mi>S</mi>
            <mrow>
             <mi>i</mi>
             <mo>,</mo>
             <mi>z</mi>
            </mrow>
           </msup>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>z</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mrow>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>f</mi>
          <mi>S</mi>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>z</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>f</mi>
          <msup>
           <mi>S</mi>
           <mrow>
            <mi>i</mi>
            <mo>,</mo>
            <mi>z</mi>
           </mrow>
          </msup>
         </msub>
         <mo>,</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <neq></neq>
         <ci>j</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>V</ci>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <ci>S</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>z</ci>
            <ci>j</ci>
           </apply>
          </interval>
         </apply>
         <apply>
          <times></times>
          <ci>V</ci>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <list>
              <ci>i</ci>
              <ci>z</ci>
             </list>
            </apply>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>z</ci>
            <ci>j</ci>
           </apply>
          </interval>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>V</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>S</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>z</ci>
           <ci>i</ci>
          </apply>
         </interval>
        </apply>
        <apply>
         <times></times>
         <ci>V</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>S</ci>
            <list>
             <ci>i</ci>
             <ci>z</ci>
            </list>
           </apply>
          </apply>
          <ci>z</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq\frac{1}{n}\sum_{j\neq i}|V(f_{S},z_{j})-V(f_{S^{i,z}},z_{j})|+\frac{1}{n}%
|V(f_{S},z_{i})-V(f_{S^{i,z}},z)|
  </annotation>
 </semantics>
</math>

</p>

<p>We divided the terms that way because the first term 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mi>S</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>z</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <msup>
       <mi>S</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>z</mi>
       </mrow>
      </msup>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>z</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>V</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>j</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>S</ci>
        <list>
         <ci>i</ci>
         <ci>z</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>j</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(f_{S},z_{j})-V(f_{S^{i,z}},z_{j})
  </annotation>
 </semantics>
</math>

 can be upper bounded by 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:57">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 because of the stability of our learning algorithm. Thus,</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:58">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>z</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>f</mi>
       <msup>
        <mi>S</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>z</mi>
        </mrow>
       </msup>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>z</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>V</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>j</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <list>
          <ci>i</ci>
          <ci>z</ci>
         </list>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>j</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(f_{S},z_{j})-V(f_{S^{i,z}},z_{j})\leq\beta
  </annotation>
 </semantics>
</math>

</p>

<p>and the second term can only be bounded by the the upper bound of the loss function (because we are evaluating the loss at two different points with different training points):</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:59">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>z</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>f</mi>
       <msup>
        <mi>S</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>z</mi>
        </mrow>
       </msup>
      </msub>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>V</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <list>
          <ci>i</ci>
          <ci>z</ci>
         </list>
        </apply>
       </apply>
       <ci>z</ci>
      </interval>
     </apply>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(f_{S},z_{i})-V(f_{S^{i,z}},z)\leq M
  </annotation>
 </semantics>
</math>

</p>

<p>Combining both terms yields the desired upper bound (to use McDirmad's afterwards):</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:60">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </mfrac>
     <mi>β</mi>
    </mrow>
    <mo>+</mo>
    <mfrac>
     <mi>M</mi>
     <mi>n</mi>
    </mfrac>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>β</mi>
    <mo>+</mo>
    <mfrac>
     <mi>M</mi>
     <mi>n</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>n</ci>
       </apply>
       <ci>β</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>M</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <ci>β</ci>
      <apply>
       <divide></divide>
       <ci>M</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq\frac{n-1}{n}\beta+\frac{M}{n}\leq\beta+\frac{M}{n}
  </annotation>
 </semantics>
</math>

</p>

<p>With this last result we can apply McDiarmid's inequality and the constants 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:61">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}
  </annotation>
 </semantics>
</math>

 at the beginning of the lemma are 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>β</mi>
    <mo>+</mo>
    <mfrac>
     <mi>M</mi>
     <mi>n</mi>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>∀</mo>
    <mi>i</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <plus></plus>
     <ci>β</ci>
     <apply>
      <divide></divide>
      <ci>M</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>i</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta+\frac{M}{n},\forall i
  </annotation>
 </semantics>
</math>

. Thus we have:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:63">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>i</mi>
   <mo>,</mo>
   <msub>
    <mo>sup</mo>
    <mrow>
     <mi>S</mi>
     <mo>,</mo>
     <mi>z</mi>
    </mrow>
   </msub>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>I</mi>
    <mi>S</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>f</mi>
     <mi>S</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>-</mo>
   <msub>
    <mi>I</mi>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>z</mi>
     </mrow>
    </msup>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <msubsup>
     <mi>f</mi>
     <mi>S</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>z</mi>
     </mrow>
    </msubsup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mo>≤</mo>
   <mi>β</mi>
   <mo>+</mo>
   <mfrac>
    <mi>M</mi>
    <mi>n</mi>
   </mfrac>
   <mo>⟹</mo>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>I</mi>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>f</mi>
      <mi>S</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>𝔼</mi>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>I</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mo>≥</mo>
    <mi>ϵ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≤</mo>
   <mn>2</mn>
   <msup>
    <mi>e</mi>
    <mfrac>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
       <msup>
        <mi>ϵ</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>n</mi>
         <mi>β</mi>
        </mrow>
        <mo>+</mo>
        <mi>M</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mfrac>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">supremum</csymbol>
     <list>
      <ci>S</ci>
      <ci>z</ci>
     </list>
    </apply>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>S</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>S</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <list>
       <ci>i</ci>
       <ci>z</ci>
      </list>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
      <list>
       <ci>i</ci>
       <ci>z</ci>
      </list>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-|</ci>
    <leq></leq>
    <csymbol cd="unknown">β</csymbol>
    <plus></plus>
    <apply>
     <divide></divide>
     <ci>M</ci>
     <ci>n</ci>
    </apply>
    <implies></implies>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>S</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
      <ci>normal-]</ci>
     </cerror>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <ci>S</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>S</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-|</ci>
     <geq></geq>
     <csymbol cd="unknown">ϵ</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <leq></leq>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ϵ</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>β</ci>
        </apply>
        <ci>M</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i,\sup_{S,z}|I_{S}[f_{S}]-I_{S^{{i,z}}}[f_{S}^{i,z}]|\leq\beta+\frac{M%
}{n}\implies Pr[|I_{S}[f_{S}]-\mathbb{E}_{S}[I_{S}[f_{S}]]|\geq\epsilon]\leq 2%
e^{\frac{-2n\epsilon^{2}}{(n\beta+M)^{2}}}
  </annotation>
 </semantics>
</math>

</p>

<p>Switching the above bound to its confidence form and requiring it to have confidence 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:64">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\delta
  </annotation>
 </semantics>
</math>

 yields 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:65">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 to be:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:66">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>n</mi>
       <mi>β</mi>
      </mrow>
      <mo>+</mo>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msqrt>
     <mfrac>
      <mrow>
       <mi>l</mi>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mfrac>
         <mn>2</mn>
         <mi>δ</mi>
        </mfrac>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
      </mrow>
     </mfrac>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϵ</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>β</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>l</ci>
        <ci>n</ci>
        <apply>
         <divide></divide>
         <cn type="integer">2</cn>
         <ci>δ</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon=(n\beta+M)\sqrt{\frac{ln(\frac{2}{\delta})}{2n}}
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, from the probabilistic bound implied by McDiarmid's inequality we have:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:67">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>I</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>f</mi>
        <mi>S</mi>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>𝔼</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>I</mi>
         <mi>S</mi>
        </msub>
        <mrow>
         <mo stretchy="false">[</mo>
         <msub>
          <mi>f</mi>
          <mi>S</mi>
         </msub>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>n</mi>
       <mi>β</mi>
      </mrow>
      <mo>+</mo>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msqrt>
     <mfrac>
      <mrow>
       <mi>l</mi>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mfrac>
         <mn>2</mn>
         <mi>δ</mi>
        </mfrac>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
      </mrow>
     </mfrac>
    </msqrt>
   </mrow>
   <mo>⟹</mo>
   <mrow>
    <msub>
     <mi>I</mi>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>f</mi>
      <mi>S</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msub>
        <mi>I</mi>
        <mi>S</mi>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>f</mi>
         <mi>S</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mi>β</mi>
       </mrow>
       <mo>+</mo>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msqrt>
      <mfrac>
       <mrow>
        <mi>l</mi>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mfrac>
          <mn>2</mn>
          <mi>δ</mi>
         </mfrac>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </mfrac>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <ci>S</ci>
        </apply>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>S</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝔼</ci>
         <ci>S</ci>
        </apply>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>I</ci>
           <ci>S</ci>
          </apply>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <ci>S</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>β</ci>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>l</ci>
         <ci>n</ci>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>δ</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <implies></implies>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>S</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>S</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>β</ci>
        </apply>
        <ci>M</ci>
       </apply>
       <apply>
        <root></root>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>l</ci>
          <ci>n</ci>
          <apply>
           <divide></divide>
           <cn type="integer">2</cn>
           <ci>δ</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |I_{S}[f_{S}]-\mathbb{E}_{S}[I_{S}[f_{S}]]|\leq(n\beta+M)\sqrt{\frac{ln(\frac{%
2}{\delta})}{2n}}\implies I_{S}[f_{S}]\leq\mathbb{E}_{S}[I_{S}[f_{S}]]+(n\beta%
+M)\sqrt{\frac{ln(\frac{2}{\delta})}{2n}}
  </annotation>
 </semantics>
</math>

</p>

<p>Which isn't exactly what we wanted to prove by the lemma. However we can subtract 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:68">
 <semantics>
  <mrow>
   <msub>
    <mi>𝔼</mi>
    <mi>S</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔼</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{S}[I[f_{S}]]
  </annotation>
 </semantics>
</math>

 from both sides of the inequality to get it in the form of the original lemma statement. Doing that yields:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:69">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>f</mi>
         <mi>S</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>𝔼</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>I</mi>
         <mi>S</mi>
        </msub>
        <mrow>
         <mo stretchy="false">[</mo>
         <msub>
          <mi>f</mi>
          <mi>S</mi>
         </msub>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>𝔼</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>I</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <msub>
          <mi>f</mi>
          <mi>S</mi>
         </msub>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mi>β</mi>
       </mrow>
       <mo>+</mo>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msqrt>
      <mfrac>
       <mrow>
        <mi>l</mi>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mfrac>
          <mn>2</mn>
          <mi>δ</mi>
         </mfrac>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </mfrac>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>I</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>S</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>S</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>S</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>I</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>S</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>β</ci>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>l</ci>
         <ci>n</ci>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>δ</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{S}[f_{S}]-\mathbb{E}_{S}[I[f_{S}]]\leq\mathbb{E}_{S}[I_{S}[f_{S}]]-\mathbb{%
E}_{S}[I[f_{S}]]+(n\beta+M)\sqrt{\frac{ln(\frac{2}{\delta})}{2n}}
  </annotation>
 </semantics>
</math>

</p>

<p>Which will conclude the proof of the lemma if we can upper bound 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:70">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mi>I</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>f</mi>
        <mi>S</mi>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>I</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>f</mi>
        <mi>S</mi>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>I</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{S}[I_{S}[f_{S}]]-\mathbb{E}_{S}[I[f_{S}]]
  </annotation>
 </semantics>
</math>

.</p>

<p>Which is actually simple to show its upper bounded is 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:71">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

. First notice that:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:72">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msub>
        <mi>I</mi>
        <mi>S</mi>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>f</mi>
         <mi>S</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>f</mi>
         <mi>S</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>z</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msub>
        <mi>𝔼</mi>
        <mi>S</mi>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <msub>
          <mi>I</mi>
          <mi>S</mi>
         </msub>
         <mrow>
          <mo stretchy="false">[</mo>
          <msub>
           <mi>f</mi>
           <mi>S</mi>
          </msub>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>f</mi>
         <mi>S</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>z</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msub>
        <mi>𝔼</mi>
        <mi>S</mi>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mfrac>
          <mn>1</mn>
          <mi>n</mi>
         </mfrac>
         <mrow>
          <msubsup>
           <mo largeop="true" symmetric="true">∑</mo>
           <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi>n</mi>
          </msubsup>
          <mrow>
           <mi>V</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>f</mi>
            <mo>,</mo>
            <msub>
             <mi>z</mi>
             <mi>i</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msub>
        <mi>𝔼</mi>
        <mi>z</mi>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>V</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>f</mi>
           <mi>S</mi>
          </msub>
          <mo>,</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>S</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>S</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>I</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>S</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>z</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝔼</ci>
          <ci>S</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>I</ci>
            <ci>S</ci>
           </apply>
           <apply>
            <csymbol cd="latexml">delimited-[]</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>f</ci>
             <ci>S</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>I</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>S</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>z</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝔼</ci>
          <ci>S</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <times></times>
           <apply>
            <divide></divide>
            <cn type="integer">1</cn>
            <ci>n</ci>
           </apply>
           <apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <sum></sum>
              <ci>n</ci>
             </apply>
             <apply>
              <eq></eq>
              <ci>i</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <apply>
             <times></times>
             <ci>V</ci>
             <interval closure="open">
              <ci>f</ci>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>z</ci>
               <ci>i</ci>
              </apply>
             </interval>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝔼</ci>
          <ci>z</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <times></times>
           <ci>V</ci>
           <interval closure="open">
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>f</ci>
             <ci>S</ci>
            </apply>
            <ci>z</ci>
           </interval>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{S}[I_{S}[f_{S}]]-\mathbb{E}_{S}[I[f_{S}]]=\mathbb{E}_{z}[\mathbb{E%
}_{S}[I_{S}[f_{S}]]]-\mathbb{E}_{S}[I[f_{S}]]=\mathbb{E}_{z}[\mathbb{E}_{S}[%
\frac{1}{n}\sum^{n}_{i=1}V(f,z_{i})]]-\mathbb{E}_{S}[\mathbb{E}_{z}[V(f_{S},z)]]
  </annotation>
 </semantics>
</math>

</p>

<p>Then by linearity of expectation and some simple algebra we have:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:73">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mi>z</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mi>𝔼</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <mfrac>
          <mn>1</mn>
          <mi>n</mi>
         </mfrac>
         <mrow>
          <msubsup>
           <mo largeop="true" symmetric="true">∑</mo>
           <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi>n</mi>
          </msubsup>
          <mrow>
           <mi>V</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>f</mi>
            <mo>,</mo>
            <msub>
             <mi>z</mi>
             <mi>i</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>V</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>f</mi>
           <mi>S</mi>
          </msub>
          <mo>,</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝔼</mi>
     <mi>z</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mi>𝔼</mi>
       <mi>S</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mi>n</mi>
        </mfrac>
        <mrow>
         <msubsup>
          <mo largeop="true" symmetric="true">∑</mo>
          <mrow>
           <mi>i</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
          <mi>n</mi>
         </msubsup>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mrow>
            <mi>V</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <msub>
              <mi>f</mi>
              <msup>
               <mi>S</mi>
               <mrow>
                <mi>i</mi>
                <mo>,</mo>
                <mi>z</mi>
               </mrow>
              </msup>
             </msub>
             <mo>,</mo>
             <mi>z</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>-</mo>
           <mrow>
            <mi>V</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <msub>
              <mi>f</mi>
              <mi>S</mi>
             </msub>
             <mo>,</mo>
             <mi>z</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <ci>n</ci>
          </apply>
          <apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <sum></sum>
             <ci>n</ci>
            </apply>
            <apply>
             <eq></eq>
             <ci>i</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <apply>
            <times></times>
            <ci>V</ci>
            <interval closure="open">
             <ci>f</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>z</ci>
              <ci>i</ci>
             </apply>
            </interval>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>V</ci>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <ci>S</ci>
           </apply>
           <ci>z</ci>
          </interval>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔼</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <ci>n</ci>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <sum></sum>
            <ci>n</ci>
           </apply>
           <apply>
            <eq></eq>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <ci>V</ci>
            <interval closure="open">
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>f</ci>
              <apply>
               <csymbol cd="ambiguous">superscript</csymbol>
               <ci>S</ci>
               <list>
                <ci>i</ci>
                <ci>z</ci>
               </list>
              </apply>
             </apply>
             <ci>z</ci>
            </interval>
           </apply>
           <apply>
            <times></times>
            <ci>V</ci>
            <interval closure="open">
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>f</ci>
              <ci>S</ci>
             </apply>
             <ci>z</ci>
            </interval>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{z}[\mathbb{E}_{S}[\frac{1}{n}\sum^{n}_{i=1}V(f,z_{i})-V(f_{S},z)]]%
=\mathbb{E}_{z}[\mathbb{E}_{S}[\frac{1}{n}\sum^{n}_{i=1}\left(V(f_{S^{i,z}},z)%
-V(f_{S},z))\right]]
  </annotation>
 </semantics>
</math>

</p>

<p>Then by stability we know that each term 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:74">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>f</mi>
       <msup>
        <mi>S</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>z</mi>
        </mrow>
       </msup>
      </msub>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>V</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <list>
          <ci>i</ci>
          <ci>z</ci>
         </list>
        </apply>
       </apply>
       <ci>z</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
       <ci>z</ci>
      </interval>
     </apply>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(f_{S^{i,z}},z)-V(f_{S},z)\leq\beta
  </annotation>
 </semantics>
</math>

. Thus:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:75">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msub>
        <mi>I</mi>
        <mi>S</mi>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>f</mi>
         <mi>S</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>f</mi>
         <mi>S</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <ci>S</ci>
        </apply>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>S</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>I</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>S</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{S}[I_{S}[f_{S}]]-\mathbb{E}_{S}[I[f_{S}]]\leq\beta
  </annotation>
 </semantics>
</math>

</p>

<p>Which concludes the proof of the lemma and shows that with confidence 

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:76">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\delta
  </annotation>
 </semantics>
</math>

 we have:</p>

<p>

<math display="inline" id="Draft:Uniform_Stability_and_Generalization_in_learning_theory:77">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>𝔼</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>f</mi>
         <mi>S</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>f</mi>
       <mi>S</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>β</mi>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mi>β</mi>
       </mrow>
       <mo>+</mo>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msqrt>
      <mfrac>
       <mrow>
        <mi>l</mi>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mfrac>
          <mn>2</mn>
          <mi>δ</mi>
         </mfrac>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </mfrac>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔼</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>I</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>S</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>β</ci>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>β</ci>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>l</ci>
         <ci>n</ci>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>δ</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}_{S}[I[f_{S}]]-I_{S}[f_{S}]\leq\beta+(n\beta+M)\sqrt{\frac{ln(\frac{%
2}{\delta})}{2n}}
  </annotation>
 </semantics>
</math>

</p>
<h1 id="references">References</h1>

<p><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>"</p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Lorenzo Rosasco, Tomaso Poggio: "Class slides on Stability": <a class="uri" href="http://www.mit.edu/~9.520/fall14/slides/class15/class15_stability.pdf">http://www.mit.edu/~9.520/fall14/slides/class15/class15_stability.pdf</a><a href="#fnref1">↩</a></li>
<li id="fn2">Lorenzo Rosasco, Tomaso Poggio: "Class slides on Stability of Tikhonov ": <a class="uri" href="http://www.mit.edu/~9.520/fall14/slides/class16/class16_stability.pdf">http://www.mit.edu/~9.520/fall14/slides/class16/class16_stability.pdf</a><a href="#fnref2">↩</a></li>
<li id="fn3">Lorenzo Rosasco, Tomaso Poggio: "9.520: Statistical Learning Theory and Applications Fall 2014": <a class="uri" href="http://www.mit.edu/~9.520/fall14/">http://www.mit.edu/~9.520/fall14/</a><a href="#fnref3">↩</a></li>
<li id="fn4">Rosasco, Lorenzo (2014). Consistency, Learnability and Regularization. Lecture Notes for MIT Course 9.520.<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
