   Hamming(7,4)      Hamming(7,4)   In coding theory , Hamming(7,4) is a linear error-correcting code that encodes four bits of data into seven bits by adding three parity bits . It is a member of a larger family of Hamming codes , but the term Hamming code often refers to this specific code that Richard W. Hamming introduced in 1950. At the time, Hamming worked at Bell Telephone Laboratories and was frustrated with the error-prone punched card reader, which is why he started working on error-correcting codes. 1  The Hamming code adds three additional check bits to every four data bits of the message. Hamming's (7,4) algorithm can correct any single-bit error, or detect all single-bit and two-bit errors. In other words, the minimal Hamming distance between any two correct codewords is 3, and received words can be correctly decoded if they are at a distance of at most one from the codeword that was transmitted by the sender. This means that for transmission medium situations where burst errors do not occur, Hamming's (7,4) code is effective (as the medium would have to be extremely noisy for two out of seven bits to be flipped).  Goal  The goal of Hamming codes is to create a set of parity bits that overlap such that a single-bit error (the bit is logically flipped in value) in a data bit or a parity bit can be detected and corrected. While multiple overlaps can be created, the general method is presented in Hamming codes .        Bit #   1   2   3   4   5   6   7       Transmitted bit       p  1     subscript  p  1    p_{1}          p  2     subscript  p  2    p_{2}          d  1     subscript  d  1    d_{1}          p  3     subscript  p  3    p_{3}          d  2     subscript  d  2    d_{2}          d  3     subscript  d  3    d_{3}          d  4     subscript  d  4    d_{4}            p  1     subscript  p  1    p_{1}                   p  2     subscript  p  2    p_{2}                   p  3     subscript  p  3    p_{3}                 This table describes which parity bits cover which transmitted bits in the encoded word. For example, p 2 provides an even parity for bits 2, 3, 6, and 7. It also details which transmitted by which parity bit by reading the column. For example, d 1 is covered by p 1 and p 2 but not p 3 This table will have a striking resemblance to the parity-check matrix ( H ) in the next section.  Furthermore, if the parity columns in the above table were removed             d  1     subscript  d  1    d_{1}          d  2     subscript  d  2    d_{2}          d  3     subscript  d  3    d_{3}          d  4     subscript  d  4    d_{4}              p  1     subscript  p  1    p_{1}                p  2     subscript  p  2    p_{2}                p  3     subscript  p  3    p_{3}              then resemblance to rows 1, 2, and 4 of the code generator matrix ( G ) below will also be evident.  So, by picking the parity bit coverage correctly, all errors with a Hamming distance of 1 can be detected and corrected, which is the point of using a Hamming code.  Hamming matrices  Hamming codes can be computed in linear algebra terms through matrices because Hamming codes are linear codes . For the purposes of Hamming codes, two Hamming matrices can be defined: the code generator matrix  G and the parity-check matrix  H :        𝐆  :=   (     1    1    0    1      1    0    1    1      1    0    0    0      0    1    1    1      0    1    0    0      0    0    1    0      0    0    0    1     )    ,   𝐇  :=   (     1    0    1    0    1    0    1      0    1    1    0    0    1    1      0    0    0    1    1    1    1     )     .     formulae-sequence   assign  𝐆    1  1  0  1    1  0  1  1    1  0  0  0    0  1  1  1    0  1  0  0    0  0  1  0    0  0  0  1      assign  𝐇    1  0  1  0  1  0  1    0  1  1  0  0  1  1    0  0  0  1  1  1  1       \mathbf{G}:=\begin{pmatrix}1&1&0&1\\
 1&0&1&1\\
 1&0&0&0\\
 0&1&1&1\\
 0&1&0&0\\
 0&0&1&0\\
 0&0&0&1\\
 \end{pmatrix},\qquad\mathbf{H}:=\begin{pmatrix}1&0&1&0&1&0&1\\
 0&1&1&0&0&1&1\\
 0&0&0&1&1&1&1\\
 \end{pmatrix}.     As mentioned above, rows 1, 2, and 4 of G should look familiar as they map the data bits to their parity bits:   p 1 covers d 1 , d 2 , d 4  p 2 covers d 1 , d 3 , d 4  p 3 covers d 2 , d 3 , d 4   The remaining rows (3, 5, 6, 7) map the data to their position in encoded form and there is only 1 in that row so it is an identical copy. In fact, these four rows are linearly independent and form the identity matrix (by design, not coincidence).  Also as mentioned above, the three rows of H should be familiar. These rows are used to compute the syndrome vector at the receiving end and if the syndrome vector is the null vector (all zeros) then the received word is error-free; if non-zero then the value indicates which bit has been flipped.  The four data bits — assembled as a vector p — is pre-multiplied by G (i.e., Gp ) and taken modulo 2 to yield the encoded value that is transmitted. The original 4 data bits are converted to seven bits (hence the name "Hamming(7,4)") with three parity bits added to ensure even parity using the above data bit coverages. The first table above shows the mapping between each data and parity bit into its final bit position (1 through 7) but this can also be presented in a Venn diagram . The first diagram in this article shows three circles (one for each parity bit) and encloses data bits that each parity bit covers. The second diagram (shown to the right) is identical but, instead, the bit positions are marked.  For the remainder of this section, the following 4 bits (shown as a column vector) will be used as a running example:      𝐩  =   (      d  1        d  2        d  3        d  4      )   =   (     1      0      1      1     )         𝐩     subscript  d  1      subscript  d  2      subscript  d  3      subscript  d  4            1    0    1    1       \mathbf{p}=\begin{pmatrix}d_{1}\\
 d_{2}\\
 d_{3}\\
 d_{4}\\
 \end{pmatrix}=\begin{pmatrix}1\\
 0\\
 1\\
 1\end{pmatrix}     Channel coding  (Figure)  Mapping in the example x . The parity of the red, green, and blue circles are even.   Suppose we want to transmit this data ( 1011 ) over a noisy  communications channel . Specifically, a binary symmetric channel meaning that error corruption does not favor either zero or one (it is symmetric in causing errors). Furthermore, all source vectors are assumed to be equiprobable. We take the product of G and p , with entries modulo 2, to determine the transmitted codeword x :      𝐱  =  𝐆𝐩  =    (     1    1    0    1      1    0    1    1      1    0    0    0      0    1    1    1      0    1    0    0      0    0    1    0      0    0    0    1     )    (     1      0      1      1     )    =   (     2      3      1      2      0      1      1     )   =   (     0      1      1      0      0      1      1     )         𝐱  𝐆𝐩           1  1  0  1    1  0  1  1    1  0  0  0    0  1  1  1    0  1  0  0    0  0  1  0    0  0  0  1      1    0    1    1            2    3    1    2    0    1    1           0    1    1    0    0    1    1       \mathbf{x}=\mathbf{G}\mathbf{p}=\begin{pmatrix}1&1&0&1\\
 1&0&1&1\\
 1&0&0&0\\
 0&1&1&1\\
 0&1&0&0\\
 0&0&1&0\\
 0&0&0&1\\
 \end{pmatrix}\begin{pmatrix}1\\
 0\\
 1\\
 1\end{pmatrix}=\begin{pmatrix}2\\
 3\\
 1\\
 2\\
 0\\
 1\\
 1\end{pmatrix}=\begin{pmatrix}0\\
 1\\
 1\\
 0\\
 0\\
 1\\
 1\end{pmatrix}     This means that 0110011 would be transmitted instead of transmitting 1011 .  Programmers concerned about multiplication should observe that each row of the result is the least significant bit of the Population Count of set bits resulting from the row and column being Bitwise ANDed together rather than multiplied.  In the diagram to the right, the seven bits of the encoded word are inserted into their respective locations; from inspection it is clear that the parity of the red, green, and blue circles are even:   red circle has two 1's  green circle has two 1's  blue circle has four 1's   What will be shown shortly is that if, during transmission, a bit is flipped then the parity of two or all three circles will be incorrect and the errored bit can be determined (even if one of the parity bits) by knowing that the parity of all three of these circles should be even.  Parity check  If no error occurs during transmission, then the received codeword r is identical to the transmitted codeword x :      𝐫  =  𝐱      𝐫  𝐱    \mathbf{r}=\mathbf{x}     The receiver multiplies H and r to obtain the syndrome vector z , which indicates whether an error has occurred, and if so, for which codeword bit. Performing this multiplication (again, entries modulo 2):      𝐳  =  𝐇𝐫  =    (     1    0    1    0    1    0    1      0    1    1    0    0    1    1      0    0    0    1    1    1    1     )    (     0      1      1      0      0      1      1     )    =   (     2      4      2     )   =   (     0      0      0     )         𝐳  𝐇𝐫           1  0  1  0  1  0  1    0  1  1  0  0  1  1    0  0  0  1  1  1  1      0    1    1    0    0    1    1            2    4    2           0    0    0       \mathbf{z}=\mathbf{H}\mathbf{r}=\begin{pmatrix}1&0&1&0&1&0&1\\
 0&1&1&0&0&1&1\\
 0&0&0&1&1&1&1\\
 \end{pmatrix}\begin{pmatrix}0\\
 1\\
 1\\
 0\\
 0\\
 1\\
 1\end{pmatrix}=\begin{pmatrix}2\\
 4\\
 2\end{pmatrix}=\begin{pmatrix}0\\
 0\\
 0\end{pmatrix}     Since the syndrome z is the null vector , the receiver can conclude that no error has occurred. This conclusion is based on the observation that when the data vector is multiplied by G , a change of basis occurs into a vector subspace that is the kernel of H . As long as nothing happens during transmission, r will remain in the kernel of H and the multiplication will yield the null vector.  Error correction  Otherwise, suppose a single bit error has occurred. Mathematically, we can write      𝐫  =   𝐱  +   𝐞  i        𝐫    𝐱   subscript  𝐞  i      \mathbf{r}=\mathbf{x}+\mathbf{e}_{i}     modulo 2, where e i is the    i   t  h      subscript  i    t  h     i_{th}    unit vector , that is, a zero vector with a 1 in the    i   t  h      superscript  i    t  h     i^{th}   , counting from 1.       𝐞  2   =   (     0      1      0      0      0      0      0     )        subscript  𝐞  2     0    1    0    0    0    0    0      \mathbf{e}_{2}=\begin{pmatrix}0\\
 1\\
 0\\
 0\\
 0\\
 0\\
 0\end{pmatrix}     Thus the above expression signifies a single bit error in the    i   t  h      superscript  i    t  h     i^{th}   place.  Now, if we multiply this vector by H :      𝐇𝐫  =   𝐇   (   𝐱  +   𝐞  i    )    =   𝐇𝐱  +   𝐇𝐞  i          𝐇𝐫    𝐇    𝐱   subscript  𝐞  i            𝐇𝐱   subscript  𝐇𝐞  i       \mathbf{Hr}=\mathbf{H}\left(\mathbf{x}+\mathbf{e}_{i}\right)=\mathbf{Hx}+%
 \mathbf{He}_{i}     Since x is the transmitted data, it is without error, and as a result, the product of H and x is zero. Thus       𝐇𝐱  +   𝐇𝐞  i    =   𝟎  +   𝐇𝐞  i    =   𝐇𝐞  i           𝐇𝐱   subscript  𝐇𝐞  i      0   subscript  𝐇𝐞  i          subscript  𝐇𝐞  i      \mathbf{Hx}+\mathbf{He}_{i}=\mathbf{0}+\mathbf{He}_{i}=\mathbf{He}_{i}     Now, the product of H with the    i   t  h      superscript  i    t  h     i^{th}   standard basis vector picks out that column of H , we know the error occurs in the place where this column of H occurs.  For example, suppose we have introduced a bit error on bit #5      𝐫  =   𝐱  +   𝐞  5    =    (     0      1      1      0      0      1      1     )   +   (     0      0      0      0      1      0      0     )    =   (     0      1      1      0      1      1      1     )         𝐫    𝐱   subscript  𝐞  5             0    1    1    0    0    1    1      0    0    0    0    1    0    0            0    1    1    0    1    1    1       \mathbf{r}=\mathbf{x}+\mathbf{e}_{5}=\begin{pmatrix}0\\
 1\\
 1\\
 0\\
 0\\
 1\\
 1\end{pmatrix}+\begin{pmatrix}0\\
 0\\
 0\\
 0\\
 1\\
 0\\
 0\end{pmatrix}=\begin{pmatrix}0\\
 1\\
 1\\
 0\\
 1\\
 1\\
 1\end{pmatrix}     The diagram to the right shows the bit error (shown in blue text) and the bad parity created (shown in red text) in the red and green circles. The bit error can be detected by computing the parity of the red, green, and blue circles. If a bad parity is detected then the data bit that overlaps only the bad parity circles is the bit with the error. In the above example, the red and green circles have bad parity so the bit corresponding to the intersection of red and green but not blue indicates the errored bit.  Now,      𝐳  =  𝐇𝐫  =    (     1    0    1    0    1    0    1      0    1    1    0    0    1    1      0    0    0    1    1    1    1     )    (     0      1      1      0      1      1      1     )    =   (     3      4      3     )   =   (     1      0      1     )         𝐳  𝐇𝐫           1  0  1  0  1  0  1    0  1  1  0  0  1  1    0  0  0  1  1  1  1      0    1    1    0    1    1    1            3    4    3           1    0    1       \mathbf{z}=\mathbf{Hr}=\begin{pmatrix}1&0&1&0&1&0&1\\
 0&1&1&0&0&1&1\\
 0&0&0&1&1&1&1\\
 \end{pmatrix}\begin{pmatrix}0\\
 1\\
 1\\
 0\\
 1\\
 1\\
 1\end{pmatrix}=\begin{pmatrix}3\\
 4\\
 3\end{pmatrix}=\begin{pmatrix}1\\
 0\\
 1\end{pmatrix}     which corresponds to the fifth column of H . Furthermore, the general algorithm used ( see Hamming code#General algorithm ) was intentional in its construction so that the syndrome of 101 corresponds to the binary value of 5, which indicates the fifth bit was corrupted. Thus, an error has been detected in bit 5, and can be corrected (simply flip or negate its value):       𝐫  corrected   =   (     0      1      1      0       1  ¯       1      1     )   =   (     0      1      1      0      0      1      1     )          subscript  𝐫  corrected     0    1    1    0     normal-¯  1     1    1           0    1    1    0    0    1    1       \mathbf{r}_{\text{corrected}}=\begin{pmatrix}0\\
 1\\
 1\\
 0\\
 \overline{1}\\
 1\\
 1\end{pmatrix}=\begin{pmatrix}0\\
 1\\
 1\\
 0\\
 0\\
 1\\
 1\end{pmatrix}     This corrected received value indeed, now, matches the transmitted value x from above.  Decoding  Once the received vector has been determined to be error-free or corrected if an error occurred (assuming only zero or one bit errors are possible) then the received data needs to be decoded back into the original four bits.  First, define a matrix R :      𝐑  =   (     0    0    1    0    0    0    0      0    0    0    0    1    0    0      0    0    0    0    0    1    0      0    0    0    0    0    0    1     )       𝐑    0  0  1  0  0  0  0    0  0  0  0  1  0  0    0  0  0  0  0  1  0    0  0  0  0  0  0  1      \mathbf{R}=\begin{pmatrix}0&0&1&0&0&0&0\\
 0&0&0&0&1&0&0\\
 0&0&0&0&0&1&0\\
 0&0&0&0&0&0&1\\
 \end{pmatrix}     Then the received value, p r , is equal to Rr . Using the running example from above       𝐩  𝐫   =    (     0    0    1    0    0    0    0      0    0    0    0    1    0    0      0    0    0    0    0    1    0      0    0    0    0    0    0    1     )    (     0      1      1      0      0      1      1     )    =   (     1      0      1      1     )          subscript  𝐩  𝐫       0  0  1  0  0  0  0    0  0  0  0  1  0  0    0  0  0  0  0  1  0    0  0  0  0  0  0  1      0    1    1    0    0    1    1            1    0    1    1       \mathbf{p_{r}}=\begin{pmatrix}0&0&1&0&0&0&0\\
 0&0&0&0&1&0&0\\
 0&0&0&0&0&1&0\\
 0&0&0&0&0&0&1\\
 \end{pmatrix}\begin{pmatrix}0\\
 1\\
 1\\
 0\\
 0\\
 1\\
 1\end{pmatrix}=\begin{pmatrix}1\\
 0\\
 1\\
 1\end{pmatrix}     Multiple bit errors  (Figure)  A bit error on bit 4 & 5 are introduced (shown in blue text) with a bad parity only in the green circle (shown in red text)   It is not difficult to show that only single bit errors can be corrected using this scheme. Alternatively, Hamming codes can be used to detect single and double bit errors, by merely noting that the product of H is nonzero whenever errors have occurred. In the diagram to the right, bits 4 and 5 were flipped. This yields only one circle (green) with an invalid parity but the errors are not recoverable.  However, the Hamming (7,4) and similar Hamming codes cannot distinguish between single-bit errors and two-bit errors. That is, two-bit errors appear the same as one-bit errors. If error correction is performed on a two-bit error the result will be incorrect.  All codewords  Since the source is only 4 bits then there are only 16 possible transmitted words. Included is the eight-bit value if an extra parity bit is used ( see Hamming(7,4) code with an additional parity bit ). (The data bits are shown in blue; the parity bits are shown in red; and the extra parity bit shown in green.)      Data     (    \color   b  l  u  e   d  1    ,    \color   b  l  u  e   d  2    ,    \color   b  l  u  e   d  3    ,    \color   b  l  u  e   d  4    )       \color  b  l  u  e   subscript  d  1      \color  b  l  u  e   subscript  d  2      \color  b  l  u  e   subscript  d  3      \color  b  l  u  e   subscript  d  4      ({\color{blue}d_{1}},{\color{blue}d_{2}},{\color{blue}d_{3}},{\color{blue}d_{4%
 }})      Hamming(7,4)   Hamming(7,4) with extra parity bit (Hamming(8,4))       Transmitted     (    \color   r  e  d   p  1    ,    \color   r  e  d   p  2    ,    \color   b  l  u  e   d  1    ,    \color   r  e  d   p  3    ,    \color   b  l  u  e   d  2    ,    \color   b  l  u  e   d  3    ,    \color   b  l  u  e   d  4    )       \color  r  e  d   subscript  p  1      \color  r  e  d   subscript  p  2      \color  b  l  u  e   subscript  d  1      \color  r  e  d   subscript  p  3      \color  b  l  u  e   subscript  d  2      \color  b  l  u  e   subscript  d  3      \color  b  l  u  e   subscript  d  4      ({\color{red}p_{1}},{\color{red}p_{2}},{\color{blue}d_{1}},{\color{red}p_{3}},%
 {\color{blue}d_{2}},{\color{blue}d_{3}},{\color{blue}d_{4}})      Diagram   Transmitted     (    \color   r  e  d   p  1    ,    \color   r  e  d   p  2    ,    \color   b  l  u  e   d  1    ,    \color   r  e  d   p  3    ,    \color   b  l  u  e   d  2    ,    \color   b  l  u  e   d  3    ,    \color   b  l  u  e   d  4    ,    \color   g  r  e  e  n   p  4    )       \color  r  e  d   subscript  p  1      \color  r  e  d   subscript  p  2      \color  b  l  u  e   subscript  d  1      \color  r  e  d   subscript  p  3      \color  b  l  u  e   subscript  d  2      \color  b  l  u  e   subscript  d  3      \color  b  l  u  e   subscript  d  4      \color  g  r  e  e  n   subscript  p  4      ({\color{red}p_{1}},{\color{red}p_{2}},{\color{blue}d_{1}},{\color{red}p_{3}},%
 {\color{blue}d_{2}},{\color{blue}d_{3}},{\color{blue}d_{4}},{\color{green}p_{4%
 }})        0000   00 0 0 000  (Figure)  Hamming code for 0000 becomes 0000000      1000   11 1 0 000  (Figure)  Hamming code for 1000 becomes 1000011      0100   10 0 1 100  (Figure)  Hamming code for 0100 becomes 0100101      1100   01 1 1 100  (Figure)  Hamming code for 1100 becomes 1100110      0010   01 0 1 010  (Figure)  Hamming code for 0010 becomes 0010110      1010   10 1 1 010  (Figure)  Hamming code for 1010 becomes 1010101      0110   11 0 0 110  (Figure)  Hamming code for 0110 becomes 0110011      1110   00 1 0 110  (Figure)  Hamming code for 1110 becomes 1110000      0001   11 0 1 001  (Figure)  Hamming code for 0001 becomes 0001111      1001   00 1 1 001  (Figure)  Hamming code for 1001 becomes 1001100      0101   01 0 0 101  (Figure)  Hamming code for 0101 becomes 0101010      1101   10 1 0 101  (Figure)  Hamming code for 1101 becomes 1101001      0011   10 0 0 011  (Figure)  Hamming code for 0011 becomes 0011001      1011   01 1 0 011  (Figure)  Hamming code for 1011 becomes 1011010      0111   00 0 1 111  (Figure)  Hamming code for 0111 becomes 0111100      1111   11 1 1 111  (Figure)  Hamming code for 1111 becomes 1111111      References  External links   A programming problem about the Hamming Code(7,4)   "  Category:Coding theory  Category:Error detection and correction  Category:Computer arithmetic     ↩     