<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="417">Latin hypercube sampling</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Latin hypercube sampling</h1>
<hr/>

<p><strong>Latin hypercube sampling</strong> (<strong>LHS</strong>) is a <a href="statistics" title="wikilink">statistical</a> method for generating a sample of plausible collections of parameter values from a <a href="multidimensional_distribution" title="wikilink">multidimensional distribution</a>. The <a href="Sampling_(statistics)" title="wikilink">sampling method</a> is often used to construct <a href="computer_experiment" title="wikilink">computer experiments</a>.</p>

<p>The LHS was described by McKay in 1979.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> An independently equivalent technique has been proposed by <a href=":lv:Vilnis_Egl%C4%81js" title="wikilink">Eglājs</a> in 1977.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It was further elaborated by <a href="Ronald_L._Iman" title="wikilink">Ronald L. Iman</a> and coauthors in 1981.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Detailed computer codes and manuals were later published.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>In the context of statistical sampling, a square grid containing sample positions is a <a href="Latin_square" title="wikilink">Latin square</a> if (and only if) there is only one sample in each row and each column. A <strong>Latin <a class="uri" href="hypercube" title="wikilink">hypercube</a></strong> is the generalisation of this concept to an arbitrary number of dimensions, whereby each sample is the only one in each axis-aligned <a class="uri" href="hyperplane" title="wikilink">hyperplane</a> containing it.</p>

<p>When sampling a function of 

<math display="inline" id="Latin_hypercube_sampling:0">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 variables, the range of each variable is divided into 

<math display="inline" id="Latin_hypercube_sampling:1">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 equally probable intervals. 

<math display="inline" id="Latin_hypercube_sampling:2">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 sample points are then placed to satisfy the Latin hypercube requirements; note that this forces the number of divisions, 

<math display="inline" id="Latin_hypercube_sampling:3">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, to be equal for each variable. Also note that this sampling scheme does not require more samples for more dimensions (variables); this independence is one of the main advantages of this sampling scheme. Another advantage is that random samples can be taken one at a time, remembering which samples were taken so far.</p>

<p>The maximum number of combinations for a Latin Hypercube of 

<math display="inline" id="Latin_hypercube_sampling:4">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 divisions and 

<math display="inline" id="Latin_hypercube_sampling:5">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 variables (i.e., dimensions) can be computed with the following formula:</p>

<p>

<math display="inline" id="Latin_hypercube_sampling:6">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∏</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>M</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>M</mi>
        <mo>-</mo>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>M</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>M</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <factorial></factorial>
      <ci>M</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\prod_{n=0}^{M-1}(M-n)\right)^{N-1}=(M!)^{N-1}
  </annotation>
 </semantics>
</math>

</p>

<p>For example, a Latin hypercube of 

<math display="inline" id="Latin_hypercube_sampling:7">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=4
  </annotation>
 </semantics>
</math>

 divisions with 

<math display="inline" id="Latin_hypercube_sampling:8">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=2
  </annotation>
 </semantics>
</math>

 variables (i.e., a square) will have 24 possible combinations. A Latin hypercube of 

<math display="inline" id="Latin_hypercube_sampling:9">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=4
  </annotation>
 </semantics>
</math>

 divisions with 

<math display="inline" id="Latin_hypercube_sampling:10">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=3
  </annotation>
 </semantics>
</math>

 variables (i.e., a cube) will have 576 possible combinations.</p>

<p><strong>Orthogonal sampling</strong> adds the requirement that the entire sample space must be sampled evenly. Although more efficient, orthogonal sampling strategy is more difficult to implement since all random samples must be generated simultaneously.</p>
<figure><b>(Figure)</b>
<figcaption>LHSsampling.png</figcaption>
</figure>

<p>In two dimensions the difference between random sampling, Latin Hypercube sampling and orthogonal sampling can be explained as follows:</p>
<ol>
<li>In <strong>random sampling</strong> new sample points are generated without taking into account the previously generated sample points. One does not necessarily need to know beforehand how many sample points are needed.</li>
<li>In <strong>Latin Hypercube sampling</strong> one must first decide how many sample points to use and for each sample point remember in which row and column the sample point was taken.</li>
<li>In <strong>Orthogonal sampling</strong>, the sample space is divided into equally probable subspaces. All sample points are then chosen simultaneously making sure that the total ensemble of sample points is a Latin Hypercube sample and that each subspace is sampled with the same density.</li>
</ol>

<p>Thus, orthogonal sampling ensures that the ensemble of random numbers is a very good representative of the real variability, LHS ensures that the ensemble of random numbers is representative of the real variability whereas traditional random sampling (sometimes called brute force) is just an ensemble of random numbers without any guarantees.</p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Sampling_techniques" title="wikilink">Category:Sampling techniques</a> <a href="Category:Latin_squares" title="wikilink">Category:Latin squares</a> <a href="Category:Design_of_experiments" title="wikilink">Category:Design of experiments</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
