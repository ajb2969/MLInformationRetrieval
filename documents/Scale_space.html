<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1276">Scale space</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Scale space</h1>
<hr/>

<p><strong>Scale-space</strong> theory is a framework for <a href="Multiscale_mathematics" title="wikilink">multi-scale</a> <a href="Signal_(information_theory)" title="wikilink">signal</a> <a href="Knowledge_representation" title="wikilink">representation</a> developed by the <a href="computer_vision" title="wikilink">computer vision</a>, <a href="image_processing" title="wikilink">image processing</a> and <a href="signal_processing" title="wikilink">signal processing</a> communities with complementary motivations from <a class="uri" href="physics" title="wikilink">physics</a> and <a href="biological_vision" title="wikilink">biological vision</a>. It is a formal theory for handling image structures at different <a href="Scale_(ratio)" title="wikilink">scales</a>, by representing an image as a one-parameter family of smoothed images, the <strong>scale-space representation</strong>, parametrized by the size of the smoothing <a href="convolution_kernel" title="wikilink">kernel</a> used for suppressing fine-scale structures.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The parameter 

<math display="inline" id="Scale_space:0">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 in this family is referred to as the <em>scale parameter</em>, with the interpretation that image structures of spatial size smaller than about 

<math display="inline" id="Scale_space:1">
 <semantics>
  <msqrt>
   <mi>t</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{t}
  </annotation>
 </semantics>
</math>

 have largely been smoothed away in the scale-space level at scale 

<math display="inline" id="Scale_space:2">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

.</p>

<p>The main type of scale space is the <em>linear (Gaussian) scale space</em>, which has wide applicability as well as the attractive property of being possible to derive from a small set of <em><a href="scale-space_axioms" title="wikilink">scale-space axioms</a></em>. The corresponding scale-space framework encompasses a theory for Gaussian derivative operators, which can be used as a basis for expressing a large class of visual operations for computerized systems that process visual information. This framework also allows visual operations to be made <em><a href="scale_invariant" title="wikilink">scale invariant</a></em>, which is necessary for dealing with the size variations that may occur in image data, because real-world objects may be of different sizes and in addition the distance between the object and the camera may be unknown and may vary depending on the circumstances.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="definition">Definition</h2>

<p>The notion of scale space applies to signals of arbitrary numbers of variables. The most common case in the literature applies to two-dimensional images, which is what is presented here. For a given image 

<math display="inline" id="Scale_space:3">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>


, its linear (Gaussian) <em>scale-space representation</em> is a family of derived signals 

<math display="inline" id="Scale_space:4">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>;</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y;t)
  </annotation>
 </semantics>
</math>

 defined by the <a class="uri" href="convolution" title="wikilink">convolution</a> of 

<math display="inline" id="Scale_space:5">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>

 with the two-dimensional <a href="Gaussian_kernel" title="wikilink">Gaussian kernel</a></p>

<p>

<math display="block" id="Scale_space:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>;</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>t</mi>
     </mrow>
    </mfrac>
    <mpadded width="+1.7pt">
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msup>
            <mi>x</mi>
            <mn>2</mn>
           </msup>
           <mo>+</mo>
           <msup>
            <mi>y</mi>
            <mn>2</mn>
           </msup>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
        <mi>t</mi>
       </mrow>
      </mrow>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>y</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y;t)=\frac{1}{2\pi t}e^{-(x^{2}+y^{2})/2t}\,
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Scale_space:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>⋅</mo>
      <mo>,</mo>
      <mo>⋅</mo>
      <mo>;</mo>
      <mi>t</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mo>⋅</mo>
        <mo>,</mo>
        <mo>⋅</mo>
        <mo>;</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>*</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>⋅</mo>
      <mo>,</mo>
      <mo>⋅</mo>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <vector>
      <ci>normal-⋅</ci>
      <ci>normal-⋅</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>g</ci>
       <vector>
        <ci>normal-⋅</ci>
        <ci>normal-⋅</ci>
        <ci>t</ci>
       </vector>
      </apply>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <ci>normal-⋅</ci>
      <ci>normal-⋅</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(\cdot,\cdot;t)\ =g(\cdot,\cdot;t)*f(\cdot,\cdot),
  </annotation>
 </semantics>
</math>

</p>

<p>where the semicolon in the argument of 

<math display="inline" id="Scale_space:8">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


 implies that the convolution is performed only over the variables 

<math display="inline" id="Scale_space:9">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>

, while the scale parameter 

<math display="inline" id="Scale_space:10">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 after the semicolon just indicates which scale level is being defined. This definition of 

<math display="inline" id="Scale_space:11">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 works for a continuum of scales 

<math display="inline" id="Scale_space:12">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\geq 0
  </annotation>
 </semantics>
</math>

, but typically only a finite discrete set of levels in the scale-space representation would be actually considered.</p>

<p>The scale parameteter 

<math display="inline" id="Scale_space:13">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <msup>
    <mi>σ</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=\sigma^{2}
  </annotation>
 </semantics>
</math>


 is the <a class="uri" href="variance" title="wikilink">variance</a> of the Gaussian filter and as a limit for 

<math display="inline" id="Scale_space:14">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0
  </annotation>
 </semantics>
</math>

 the filter 

<math display="inline" id="Scale_space:15">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 becomes an impulse function such that 

<math display="inline" id="Scale_space:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>;</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y;0)=f(x,y),
  </annotation>
 </semantics>
</math>

 that is, the scale-space representation at scale level 

<math display="inline" id="Scale_space:17">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0
  </annotation>
 </semantics>
</math>

 is the image 

<math display="inline" id="Scale_space:18">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


 itself. As 

<math display="inline" id="Scale_space:19">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 increases, 

<math display="inline" id="Scale_space:20">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is the result of smoothing 

<math display="inline" id="Scale_space:21">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 with a larger and larger filter, thereby removing more and more of the details which the image contains. Since the standard deviation of the filter is 

<math display="inline" id="Scale_space:22">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>=</mo>
   <msqrt>
    <mi>t</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>σ</ci>
    <apply>
     <root></root>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma=\sqrt{t}
  </annotation>
 </semantics>
</math>

, details which are significantly smaller than this value are to a large extent removed from the image at scale parameter 

<math display="inline" id="Scale_space:23">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>


, see the following figure and <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> for graphical illustrations.</p>

<p>Image:Scalespace0.png|Scale-space representation 

<math display="inline" id="Scale_space:24">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>;</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y;t)
  </annotation>
 </semantics>
</math>

 at scale 

<math display="inline" id="Scale_space:25">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=0
  </annotation>
 </semantics>
</math>

, corresponding to the original image 

<math display="inline" id="Scale_space:26">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 Image:Scalespace1.png|Scale-space representation 

<math display="inline" id="Scale_space:27">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>;</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y;t)
  </annotation>
 </semantics>
</math>

 at scale 

<math display="inline" id="Scale_space:28">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=1
  </annotation>
 </semantics>
</math>


 Image:Scalespace2.png|Scale-space representation 

<math display="inline" id="Scale_space:29">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>;</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y;t)
  </annotation>
 </semantics>
</math>

 at scale 

<math display="inline" id="Scale_space:30">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=4
  </annotation>
 </semantics>
</math>

 Image:Scalespace3.png|Scale-space representation 

<math display="inline" id="Scale_space:31">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>;</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y;t)
  </annotation>
 </semantics>
</math>

 at scale 

<math display="inline" id="Scale_space:32">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>16</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">16</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=16
  </annotation>
 </semantics>
</math>

 Image:Scalespace4.png|Scale-space representation 

<math display="inline" id="Scale_space:33">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>;</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y;t)
  </annotation>
 </semantics>
</math>


 at scale 

<math display="inline" id="Scale_space:34">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>64</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">64</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=64
  </annotation>
 </semantics>
</math>

 Image:Scalespace5.png|Scale-space representation 

<math display="inline" id="Scale_space:35">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>;</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y;t)
  </annotation>
 </semantics>
</math>

 at scale 

<math display="inline" id="Scale_space:36">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>256</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">256</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=256
  </annotation>
 </semantics>
</math>

</p>
<h3 id="why-a-gaussian-filter">Why a Gaussian filter?</h3>

<p>When faced with the task of generating a multi-scale representation one may ask: could any filter <em>g</em> of low-pass type and with a parameter <em>t</em> which determines its width be used to generate a scale space? The answer is no, as it is of crucial importance that the smoothing filter does not introduce new spurious structures at coarse scales that do not correspond to simplifications of corresponding structures at finer scales. In the scale-space literature, a number of different ways have been expressed to formulate this criterion in precise mathematical terms.</p>

<p>The conclusion from several different axiomatic derivations that have been presented is that the Gaussian scale space constitutes the <em>canonical</em> way to generate a linear scale space, based on the essential requirement that new structures must not be created when going from a fine scale to any coarser scale.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> Conditions, referred to as <em><a href="scale-space_axioms" title="wikilink">scale-space axioms</a></em>, that have been used for deriving the uniqueness of the Gaussian kernel include <a class="uri" href="linearity" title="wikilink">linearity</a>, <a href="shift_invariance" title="wikilink">shift invariance</a>, <a class="uri" href="semi-group" title="wikilink">semi-group</a> structure, non-enhancement of <a href="local_extrema" title="wikilink">local extrema</a>, <a href="scale_invariance" title="wikilink">scale invariance</a> and <a href="rotational_invariance" title="wikilink">rotational invariance</a>. In the paper <a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a>by M. Felsberg, the uniqueness claimed in the seminal work by Iijima (1962) has been criticized, and the alternative linear scale-space Laplace kernel has been proposed.</p>
<h3 id="alternative-definition">Alternative definition</h3>

<p><em>Equivalently</em>, the scale-space family can be defined as the solution of the <a href="diffusion_equation" title="wikilink">diffusion equation</a> (for example in terms of the <a href="heat_equation" title="wikilink">heat equation</a>),</p>

<p>

<math display="block" id="Scale_space:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∂</mo>
      <mi>t</mi>
     </msub>
     <mi>L</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <msup>
       <mo>∇</mo>
       <mn>2</mn>
      </msup>
      <mi>L</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>t</ci>
     </apply>
     <ci>L</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-∇</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{t}L=\frac{1}{2}\nabla^{2}L,
  </annotation>
 </semantics>
</math>

</p>

<p>with initial condition 

<math display="inline" id="Scale_space:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>;</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y;0)=f(x,y)
  </annotation>
 </semantics>
</math>


. This formulation of the scale-space representation <em>L</em> means that it is possible to interpret the intensity values of the image <em>f</em> as a "temperature distribution" in the image plane and that the process which generates the scale-space representation as a function of <em>t</em> corresponds to heat diffusion in the image plane over time <em>t</em> (assuming the thermal conductivity of the material equal to the arbitrarily chosen constant ½). Although this connection may appear superficial for a reader not familiar with <a href="differential_equation" title="wikilink">differential equations</a>, it is indeed the case that the main scale-space formulation in terms of non-enhancement of local extrema is expressed in terms of a sign condition on <a href="partial_derivative" title="wikilink">partial derivatives</a> in the 2+1-D volume generated by the scale space, thus within the framework of <a href="partial_differential_equation" title="wikilink">partial differential equations</a>. Furthermore, a detailed analysis of the discrete case shows that the diffusion equation provides a unifying link between continuous and discrete scale spaces, which also generalizes to nonlinear scale spaces, for example, using <a href="anisotropic_diffusion" title="wikilink">anisotropic diffusion</a>. Hence, one may say that the primary way to generate a scale space is by the diffusion equation, and that the Gaussian kernel arises as the <a href="Green's_function" title="wikilink">Green's function</a> of this specific partial differential equation.</p>
<h2 id="motivations">Motivations</h2>

<p>The motivation for generating a scale-space representation of a given data set originates from the basic observation that real-world objects are composed of different structures at different <a href="Scale_(ratio)" title="wikilink">scales</a>. This implies that real-world objects, in contrast to idealized mathematical entities such as <a href="Point_(geometry)" title="wikilink">points</a> or <a href="Line_(geometry)" title="wikilink">lines</a>, may appear in different ways depending on the scale of observation. For example, the concept of a "tree" is appropriate at the scale of meters, while concepts such as leaves and molecules are more appropriate at finer scales. For a <a href="computer_vision" title="wikilink">computer vision</a> system analysing an unknown scene, there is no way to know a priori what <a href="Scale_(ratio)" title="wikilink">scales</a> are appropriate for describing the interesting structures in the image data. Hence, the only reasonable approach is to consider descriptions at multiple scales in order to be able to capture the unknown scale variations that may occur. Taken to the limit, a scale-space representation considers representations at all scales.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>Another motivation to the scale-space concept originates from the process of performing a physical measurement on real-world data. In order to extract any information from a measurement process, one has to apply <em>operators of non-infinitesimal size</em> to the data. In many branches of computer science and applied mathematics, the size of the measurement operator is disregarded in the theoretical modelling of a problem. The scale-space theory on the other hand explicitly incorporates the need for a non-infinitesimal size of the image operators as an integral part of any measurement as well as any other operation that depends on a real-world measurement.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>

<p>There is a close link between scale-space theory and biological vision. Many scale-space operations show a high degree of similarity with receptive field profiles recorded from the mammalian retina and the first stages in the visual cortex. In these respects, the scale-space framework can be seen as a theoretically well-founded paradigm for early vision, which in addition has been thoroughly tested by algorithms and experiments.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h2 id="gaussian-derivatives">Gaussian derivatives</h2>

<p>At any scale in scale space, we can apply local derivative operators to the scale-space representation:</p>

<p>

<math display="block" id="Scale_space:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mrow>
       <msup>
        <mi>x</mi>
        <mi>m</mi>
       </msup>
       <msup>
        <mi>y</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>;</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msub>
        <mo>∂</mo>
        <mrow>
         <msup>
          <mi>x</mi>
          <mi>m</mi>
         </msup>
         <msup>
          <mi>y</mi>
          <mi>n</mi>
         </msup>
        </mrow>
       </msub>
       <mi>L</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>;</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <ci>L</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{x^{m}y^{n}}(x,y;t)=\left(\partial_{x^{m}y^{n}}L\right)(x,y;t).
  </annotation>
 </semantics>
</math>

</p>

<p>Due to the commutative property between the derivative operator and the Gaussian smoothing operator, such <em>scale-space derivatives</em> can equivalently be computed by convolving the original image with Gaussian derivative operators. For this reason they are often also referred to as <em>Gaussian derivatives</em>:</p>

<p>

<math display="block" id="Scale_space:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mrow>
       <msup>
        <mi>x</mi>
        <mi>m</mi>
       </msup>
       <msup>
        <mi>y</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>⋅</mo>
      <mo>,</mo>
      <mo>⋅</mo>
      <mo>;</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mo>∂</mo>
         <mrow>
          <msup>
           <mi>x</mi>
           <mi>m</mi>
          </msup>
          <msup>
           <mi>y</mi>
           <mi>n</mi>
          </msup>
         </mrow>
        </msub>
        <mi>g</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mo>⋅</mo>
        <mo>,</mo>
        <mo>⋅</mo>
        <mo rspace="4.2pt">;</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>*</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>⋅</mo>
      <mo>,</mo>
      <mo>⋅</mo>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <vector>
      <ci>normal-⋅</ci>
      <ci>normal-⋅</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <partialdiff></partialdiff>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <ci>m</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>y</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <ci>g</ci>
       </apply>
       <vector>
        <ci>normal-⋅</ci>
        <ci>normal-⋅</ci>
        <ci>t</ci>
       </vector>
      </apply>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <ci>normal-⋅</ci>
      <ci>normal-⋅</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{x^{m}y^{n}}(\cdot,\cdot;t)=\partial_{x^{m}y^{n}}g(\cdot,\cdot;\,t)*f(\cdot,%
\cdot).
  </annotation>
 </semantics>
</math>

</p>

<p>Interestingly, the uniqueness of the Gaussian derivative operators as local operations derived from a scale-space representation can be obtained by similar axiomatic derivations as are used for deriving the uniqueness of the Gaussian kernel for scale-space smoothing.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h3 id="visual-front-end">Visual front end</h3>

<p>These Gaussian derivative operators can in turn be combined by linear or non-linear operators into a larger variety of different types of feature detectors, which in many cases can be well modelled by <a href="differential_geometry" title="wikilink">differential geometry</a>. Specifically, invariance (or more appropriately <em>covariance</em>) to local geometric transformations, such as rotations or local affine transformations, can be obtained by considering differential invariants under the appropriate class of transformations or alternatively by normalizing the Gaussian derivative operators to a locally determined coordinate frame determined from e.g. a preferred orientation in the image domain or by applying a preferred local affine transformation to a local image patch (see the article on <a href="affine_shape_adaptation" title="wikilink">affine shape adaptation</a> for further details).</p>

<p>When Gaussian derivative operators and differential invariants are used in this way as basic feature detectors at multiple scales, the uncommitted first stages of visual processing are often referred to as a <em>visual front-end</em>. This overall framework has been applied to a large variety of problems in computer vision, including <a href="feature_detection" title="wikilink">feature detection</a>, <a href="Statistical_classification" title="wikilink">feature classification</a>, <a href="scale-space_segmentation" title="wikilink">image segmentation</a>, <a href="image_registration" title="wikilink">image matching</a>, <a href="motion_estimation" title="wikilink">motion estimation</a>, computation of <a class="uri" href="shape" title="wikilink">shape</a> cues and <a href="object_recognition" title="wikilink">object recognition</a>. The set of Gaussian derivative operators up to a certain order is often referred to as the <em><a class="uri" href="N-jet" title="wikilink">N-jet</a></em> and constitutes a basic type of feature within the scale-space framework.</p>
<h2 id="detector-examples">Detector examples</h2>

<p>Following the idea of expressing visual operation in terms of differential invariants computed at multiple scales using Gaussian derivative operators, we can express an <a href="edge_detection" title="wikilink">edge detector</a> from the set of points that satisfy the requirement that the gradient magnitude</p>

<p>

<math display="block" id="Scale_space:41">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>v</mi>
   </msub>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <msubsup>
      <mi>L</mi>
      <mi>x</mi>
      <mn>2</mn>
     </msubsup>
     <mo>+</mo>
     <msubsup>
      <mi>L</mi>
      <mi>y</mi>
      <mn>2</mn>
     </msubsup>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <root></root>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>y</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{v}=\sqrt{L_{x}^{2}+L_{y}^{2}}
  </annotation>
 </semantics>
</math>

 should assume a local maximum in the gradient direction</p>

<p>

<math display="block" id="Scale_space:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>L</mi>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>L</mi>
       <mi>x</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>L</mi>
       <mi>y</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-∇</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>y</ci>
      </apply>
     </interval>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla L=(L_{x},L_{y})^{T}.
  </annotation>
 </semantics>
</math>

 By working out the differential geometry, it can be shown <a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> that this <a href="edge_detection#Differential_edge_detection" title="wikilink">differential edge detector</a> can equivalently be expressed from the zero-crossings of the second-order differential invariant</p>

<p>

<math display="block" id="Scale_space:43">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>L</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>v</mi>
    <mn>2</mn>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>L</mi>
       <mi>x</mi>
       <mn>2</mn>
      </msubsup>
     </mpadded>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>2</mn>
     </mpadded>
     <mpadded width="+1.7pt">
      <msub>
       <mi>L</mi>
       <mi>x</mi>
      </msub>
     </mpadded>
     <mpadded width="+1.7pt">
      <msub>
       <mi>L</mi>
       <mi>y</mi>
      </msub>
     </mpadded>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>x</mi>
       <mi>y</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>L</mi>
       <mi>y</mi>
       <mn>2</mn>
      </msubsup>
     </mpadded>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>y</mi>
       <mi>y</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>L</ci>
       </apply>
       <ci>v</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>y</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>y</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\tilde{L}}_{v}^{2}=L_{x}^{2}\,L_{xx}+2\,L_{x}\,L_{y}\,L_{xy}+L_{y}^{2}\,L_{yy%
}=0
  </annotation>
 </semantics>
</math>

</p>

<p>that satisfy the following sign condition on a third-order differential invariant:</p>

<p>

<math display="block" id="Scale_space:44">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>L</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>v</mi>
    <mn>3</mn>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>L</mi>
       <mi>x</mi>
       <mn>3</mn>
      </msubsup>
     </mpadded>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
       <mi>x</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>3</mn>
     </mpadded>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>L</mi>
       <mi>x</mi>
       <mn>2</mn>
      </msubsup>
     </mpadded>
     <mpadded width="+1.7pt">
      <msub>
       <mi>L</mi>
       <mi>y</mi>
      </msub>
     </mpadded>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
       <mi>y</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>3</mn>
     </mpadded>
     <mpadded width="+1.7pt">
      <msub>
       <mi>L</mi>
       <mi>x</mi>
      </msub>
     </mpadded>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>L</mi>
       <mi>y</mi>
       <mn>2</mn>
      </msubsup>
     </mpadded>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>x</mi>
       <mi>y</mi>
       <mi>y</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>L</mi>
       <mi>y</mi>
       <mn>3</mn>
      </msubsup>
     </mpadded>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>y</mi>
       <mi>y</mi>
       <mi>y</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo><</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>L</ci>
       </apply>
       <ci>v</ci>
      </apply>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>x</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>x</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>y</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>y</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>y</ci>
        </apply>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <times></times>
         <ci>y</ci>
         <ci>y</ci>
         <ci>y</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\tilde{L}}_{v}^{3}=L_{x}^{3}\,L_{xxx}+3\,L_{x}^{2}\,L_{y}\,L_{xxy}+3\,L_{x}\,%
L_{y}^{2}\,L_{xyy}+L_{y}^{3}\,L_{yyy}<0.
  </annotation>
 </semantics>
</math>

</p>

<p>Similarly, multi-scale <a href="blob_detection" title="wikilink">blob detectors</a> at any given fixed scale<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> can be obtained from local maxima and local minima of either the <a class="uri" href="Laplacian" title="wikilink">Laplacian</a> operator (also referred to as the <a href="Laplacian_of_Gaussian" title="wikilink">Laplacian of Gaussian</a>)</p>

<p>

<math display="block" id="Scale_space:45">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mo>∇</mo>
     <mn>2</mn>
    </msup>
    <mi>L</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>L</mi>
     <mrow>
      <mi>x</mi>
      <mi>x</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>y</mi>
       <mi>y</mi>
      </mrow>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-∇</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>L</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla^{2}L=L_{xx}+L_{yy}\,
  </annotation>
 </semantics>
</math>

</p>

<p>or <a href="blob_detection#The_determinant_of_the_Hessian" title="wikilink">the determinant of the Hessian matrix</a></p>

<p>

<math display="block" id="Scale_space:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>det</mo>
      <mrow>
       <mi>H</mi>
       <mi>L</mi>
      </mrow>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>;</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>L</mi>
        <mrow>
         <mi>x</mi>
         <mi>x</mi>
        </mrow>
       </msub>
       <msub>
        <mi>L</mi>
        <mrow>
         <mi>y</mi>
         <mi>y</mi>
        </mrow>
       </msub>
      </mrow>
      <mo>-</mo>
      <msubsup>
       <mi>L</mi>
       <mrow>
        <mi>x</mi>
        <mi>y</mi>
       </mrow>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>det</ci>
      <apply>
       <times></times>
       <ci>H</ci>
       <ci>L</ci>
      </apply>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{det}HL(x,y;t)=(L_{xx}L_{yy}-L_{xy}^{2}).
  </annotation>
 </semantics>
</math>

 In an analogous fashion, corner detectors and ridge and valley detectors can be expressed as local maxima, minima or zero-crossings of multi-scale differential invariants defined from Gaussian derivatives. The algebraic expressions for the corner and ridge detection operators are, however, somewhat more complex and the reader is referred to the articles on <a href="corner_detection" title="wikilink">corner detection</a> and <a href="ridge_detection" title="wikilink">ridge detection</a> for further details.</p>

<p>Scale-space operations have also been frequently used for expressing coarse-to-fine methods, in particular for tasks such as <a href="image_registration" title="wikilink">image matching</a> and for <a href="scale-space_segmentation" title="wikilink">multi-scale image segmentation</a>.</p>
<h2 id="scale-selection">Scale selection</h2>

<p>The theory presented so far describes a well-founded framework for <em>representing</em> image structures at multiple scales. In many cases it is, however, also necessary to select locally appropriate scales for further analysis. This need for <em>scale selection</em> originates from two major reasons; (i) real-world objects may have different size, and this size may be unknown to the vision system, and (ii) the distance between the object and the camera can vary, and this distance information may also be unknown <em>a priori</em>. A highly useful property of scale-space representation is that image representations can be made invariant to scales, by performing automatic local scale selection<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a><a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a><a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> based on local <a href="Maxima_and_minima" title="wikilink">maxima</a> (or <a class="uri" href="minima" title="wikilink">minima</a>) over scales of normalized <a href="derivative" title="wikilink">derivatives</a></p>

<p>

<math display="block" id="Scale_space:47">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mrow>
      <msup>
       <mi>ξ</mi>
       <mi>m</mi>
      </msup>
      <msup>
       <mi>η</mi>
       <mi>n</mi>
      </msup>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>;</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>t</mi>
     <mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>m</mi>
         <mo>+</mo>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>γ</mi>
      </mrow>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <msub>
     <mi>L</mi>
     <mrow>
      <msup>
       <mi>x</mi>
       <mi>m</mi>
      </msup>
      <msup>
       <mi>y</mi>
       <mi>n</mi>
      </msup>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>;</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ξ</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>η</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <plus></plus>
         <ci>m</ci>
         <ci>n</ci>
        </apply>
        <ci>γ</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\xi^{m}\eta^{n}}(x,y;t)=t^{(m+n)\gamma/2}L_{x^{m}y^{n}}(x,y;t)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Scale_space:48">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>γ</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\in[0,1]
  </annotation>
 </semantics>
</math>


 is a parameter that is related to the dimensionality of the image feature. This algebraic expression for <em>scale normalized Gaussian derivative operators</em> originates from the introduction of <em>

<math display="inline" id="Scale_space:49">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

-normalized derivatives</em> according to</p>

<p>

<math display="block" id="Scale_space:50">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∂</mo>
     <mi>ξ</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>t</mi>
      <mrow>
       <mi>γ</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <msub>
      <mo>∂</mo>
      <mi>x</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <ci>ξ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <ci>γ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{\xi}=t^{\gamma/2}\partial_{x}\quad
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Scale_space:51">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo lspace="12.5pt">∂</mo>
     <mi>η</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>t</mi>
      <mrow>
       <mi>γ</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <msub>
      <mo>∂</mo>
      <mi>y</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <ci>η</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <ci>γ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad\partial_{\eta}=t^{\gamma/2}\partial_{y}.
  </annotation>
 </semantics>
</math>

 It can be theoretically shown that a scale selection module working according to this principle will satisfy the following <em>scale invariance property</em>: if for a certain type of image feature a local maximum is assumed in a certain image at a certain scale 

<math display="inline" id="Scale_space:52">
 <semantics>
  <msub>
   <mi>t</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{0}
  </annotation>
 </semantics>
</math>

, then under a rescaling of the image by a scale factor 

<math display="inline" id="Scale_space:53">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>


 the local maximum over scales in the rescaled image will be transformed to the scale level 

<math display="inline" id="Scale_space:54">
 <semantics>
  <mrow>
   <msup>
    <mi>s</mi>
    <mn>2</mn>
   </msup>
   <msub>
    <mi>t</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{2}t_{0}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="scale-invariant-feature-detection">Scale invariant feature detection</h3>

<p>Following this approach of gamma-normalized derivatives, it can be shown that different types of <em>scale adaptive and scale invariant <a href="feature_detection" title="wikilink">feature detectors</a></em><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a><a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> can be expressed for tasks such as <a href="blob_detection" title="wikilink">blob detection</a>, <a href="corner_detection" title="wikilink">corner detection</a>, <a href="ridge_detection" title="wikilink">ridge detection</a> and <a href="edge_detection" title="wikilink">edge detection</a> (see the specific articles on these topics for in-depth descriptions of how these scale-invariant feature detectors are formulated). Furthermore, the scale levels obtained from automatic scale selection can be used for determining regions of interest for subsequent <a href="affine_shape_adaptation" title="wikilink">affine shape adaptation</a><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> to obtain affine invariant interest points<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a><a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> or for determining scale levels for computing associated <a href="image_descriptors" title="wikilink">image descriptors</a>, such as locally scale adapted <a href="N-jet" title="wikilink">N-jets</a>.</p>

<p>Recent work has shown that also more complex operations, such as scale-invariant <a href="object_recognition" title="wikilink">object recognition</a> can be performed in this way, by computing local image descriptors (N-jets or local histograms of gradient directions) at scale-adapted interest points obtained from scale-space extrema of the normalized <a class="uri" href="Laplacian" title="wikilink">Laplacian</a> operator (see also <a href="scale-invariant_feature_transform" title="wikilink">scale-invariant feature transform</a><a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a>) or the determinant of the Hessian (see also <a class="uri" href="SURF" title="wikilink">SURF</a>);<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> see also the Scholarpedia article on the <a href="http://www.scholarpedia.org/article/Scale_Invariant_Feature_Transform">scale-invariant feature transform</a><a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> for a more general outlook of object recognition approaches based on receptive field responses<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a><a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a><a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a><a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a> in terms Gaussian derivative operators or approximations thereof.</p>
<h2 id="related-multi-scale-representations">Related multi-scale representations</h2>

<p>An image <a href="Pyramid_(image_processing)" title="wikilink">pyramid</a> is a discrete representation in which a scale space is sampled in both space and scale. For scale invariance, the scale factors should be sampled exponentially, for example as integer powers of 2 or root 2. When properly constructed, the ratio of the sample rates in space and scale are held constant so that the impulse response is identical in all levels of the pyramid.<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a><a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a><a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> Fast, O(N), algorithms exist for computing a scale invariant image pyramid in which the image or signal is repeatedly smoothed then subsampled. Values for scale space between pyramid samples can easily be estimated using interpolation within and between scales and allowing for scale and position estimates with sub resolution accuracy.<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a></p>

<p>In a scale-space representation, the existence of a continuous scale parameter makes it possible to track zero crossings over scales leading to so-called <em>deep structure</em>. For features defined as <a href="zero-crossing" title="wikilink">zero-crossings</a> of <a href="differential_invariant" title="wikilink">differential invariants</a>, the <a href="implicit_function_theorem" title="wikilink">implicit function theorem</a> directly defines <a href="trajectory" title="wikilink">trajectories</a> across scales,<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a><a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> and at those scales where <a href="wikt:bifurcation" title="wikilink">bifurcations</a> occur, the local behaviour can be modelled by <a href="singularity_theory" title="wikilink">singularity theory</a>.<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a><a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a><a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a><a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a></p>

<p>Extensions of linear scale-space theory concern the formulation of non-linear scale-space concepts more committed to specific purposes.<a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a><a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a> These <em><a href="non-linear_scale-space" title="wikilink">non-linear scale-spaces</a></em> often start from the equivalent diffusion formulation of the scale-space concept, which is subsequently extended in a non-linear fashion. A large number of evolution equations have been formulated in this way, motivated by different specific requirements (see the abovementioned book references for further information). It should be noted, however, that not all of these non-linear scale-spaces satisfy similar "nice" theoretical requirements as the linear Gaussian scale-space concept. Hence, unexpected artifacts may sometimes occur and one should be very careful of not using the term "scale-space" for just any type of one-parameter family of images.</p>

<p>A <a href="first-order_extension" title="wikilink">first-order extension</a> of the <a href="isotropic_Gaussian_scale_space" title="wikilink">isotropic Gaussian scale space</a> is provided by the <em>affine (Gaussian) scale space</em>.<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a> One motivation for this extension originates from the common need for computing image descriptors subject for real-world objects that are viewed under a <a href="perspective_camera_model" title="wikilink">perspective camera model</a>. To handle such non-linear deformations locally, <a href="partial_invariance" title="wikilink">partial invariance</a> (or more correctly <a class="uri" href="covariance" title="wikilink">covariance</a>) to local <a href="affine_deformation" title="wikilink">affine deformations</a> can be achieved by considering affine Gaussian kernels with their shapes determined by the local image structure,<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a> see the article on <a href="affine_shape_adaptation" title="wikilink">affine shape adaptation</a> for theory and algorithms. Indeed, this affine scale space can also be expressed from a non-isotropic extension of the linear (isotropic) diffusion equation, while still being within the class of linear <a href="partial_differential_equation" title="wikilink">partial differential equations</a>.</p>

<p>There exists a more general extension of the Gaussian scale-space model to affine and spatio-temporal scale-spaces.<a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a><a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a> In addition to variabilities over scale, which original scale-space theory was designed to handle, this <em>generalized scale-space theory</em> also comprises other types of variabilities caused by geometric transformations in the image formation process, including variations in viewing direction approximated by local affine transformations, and relative motions between objects in the world and the observer, approximated by local Galilean transformations. This generalized scale-space theory leads to predictions about receptive field profiles in good qualitative agreement with receptive field profiles measured by cell recordings in biological vision.<a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a><a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a></p>

<p>There are strong relations between scale-space theory and <a href="wavelets" title="wikilink">wavelet theory</a>, although these two notions of multi-scale representation have been developed from somewhat different premises. There has also been work on other <a href="multi-scale_approaches" title="wikilink">multi-scale approaches</a>, such as pyramids and a variety of other kernels, that do not exploit or require the same requirements as true scale-space descriptions do.</p>
<h2 id="biological-vision">Biological vision</h2>

<p>There are interesting relations between scale-space representation and biological vision. Neurophysiological studies have shown that there are <a href="receptive_field" title="wikilink">receptive field</a> profiles in the mammalian <a class="uri" href="retina" title="wikilink">retina</a> and <a href="visual_cortex" title="wikilink">visual cortex</a>, which can be well modelled by linear Gaussian derivative operators, in some cases also complemented by a non-isotropic affine scale-space model, a spatio-temporal scale-space model and/or non-linear combinations of such linear operators.<a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a><a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a><a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a><a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a><a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a></p>
<h2 id="implementation-issues">Implementation issues</h2>

<p>When implementing scale-space smoothing in practice there are a number of different approaches that can be taken in terms of continuous or discrete Gaussian smoothing, implementation in the Fourier domain, in terms of pyramids based on binomial filters that approximate the Gaussian or using recursive filters. More details about this are given in a separate article on <a href="scale_space_implementation" title="wikilink">scale space implementation</a>.</p>
<h2 id="see-also">See also</h2>

<p>Complementary articles on specific subtopics of scale space:</p>
<ul>
<li><a href="scale-space_axioms" title="wikilink">scale-space axioms</a></li>
<li><a href="scale_space_implementation" title="wikilink">scale space implementation</a></li>
<li><a href="scale-space_segmentation" title="wikilink">scale-space segmentation</a></li>
<li><a href="multi-scale_approaches" title="wikilink">multi-scale approaches</a></li>
</ul>

<p>Multi-scale feature detection within the scale-space framework:</p>
<ul>
<li><a href="edge_detection" title="wikilink">edge detection</a></li>
<li><a href="blob_detection" title="wikilink">blob detection</a></li>
<li><a href="corner_detection" title="wikilink">corner detection</a></li>
<li><a href="ridge_detection" title="wikilink">ridge detection</a></li>
<li><a href="affine_shape_adaptation" title="wikilink">affine shape adaptation</a></li>
<li><a href="interest_point_detection" title="wikilink">interest point detection</a></li>
</ul>

<p>The Gaussian function and other smoothing or multi-scale approaches:</p>
<ul>
<li><a href="Gaussian_function" title="wikilink">Gaussian function</a></li>
<li><a href="Gaussian_filter" title="wikilink">Gaussian filter</a></li>
<li><a href="multi-scale_approaches" title="wikilink">multi-scale approaches</a></li>
<li><a class="uri" href="wavelets" title="wikilink">wavelets</a></li>
<li><a href="anisotropic_diffusion" title="wikilink">anisotropic diffusion</a></li>
<li><a href="nonlinear_scale_space" title="wikilink">nonlinear scale space</a></li>
<li><a class="uri" href="smoothing" title="wikilink">smoothing</a></li>
<li><a href="pyramid_(image_processing)" title="wikilink">pyramid (image processing)</a></li>
<li><a href="mipmap" title="wikilink">mipmapping</a></li>
</ul>

<p>More general articles on feature detection, computer vision and image processing:</p>
<ul>
<li><a href="feature_detection_(computer_vision)" title="wikilink">feature detection (computer vision)</a></li>
<li><a href="computer_vision" title="wikilink">computer vision</a></li>
<li><a href="image_processing" title="wikilink">image processing</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://www.csc.kth.se/~tony/cern-review/cern-html/cern-html.html">Lindeberg, Tony, "Scale-space: A framework for handling image structures at multiple scales", In: Proc. CERN School of Computing, Egmond aan Zee, The Netherlands, 8-21 September, 1996</a> (online web tutorial)</li>
<li><a href="http://www.csc.kth.se/~tony/abstracts/Lin94-SI-abstract.html">Lindeberg, Tony: Scale-space theory: A basic tool for analysing structures at different scales, in J. of Applied Statistics, 21(2), pp. 224–270, 1994</a> (longer pdf tutorial on scale-space)</li>
<li><a href="http://www.csc.kth.se/cvap/abstracts/cvap222.html">Lindeberg, Tony, "Principles for automatic scale selection", In: B. Jähne (et al., eds.), Handbook on Computer Vision and Applications, volume 2, pp 239--274, Academic Press, Boston, USA, 1999.</a> (tutorial on approaches to automatic scale selection)</li>
<li><a href="http://www.encyclopediaofmath.org/index.php/Scale-space_theory">Lindeberg, Tony: "Scale-space theory" In: Encyclopedia of Mathematics, (</a><a href="Michiel_Hazewinkel" title="wikilink">Michiel Hazewinkel</a>, ed) Kluwer, 1997</li>
<li><a href="http://micro.magnet.fsu.edu/primer/java/scienceopticsu/powersof10/index.html">Powers of ten interactive Java tutorial at Molecular Expressions website</a></li>
<li><a href="http://cobalt056.bpe.es.osaka-u.ac.jp/ohzawa-lab/teaching/AA_RFtutorial.html">On-line resource with space-time receptive fields of visual neurons provided by Izumi Ohzawa at Osaka University</a></li>
<li>Web archive backup: <a href="http://web.archive.org/web/20070731095249/http://wagga.cs.umass.edu/~manmatha/cmpsci670/lecturespdf/lecture10.pdf">Lecture on scale-space at the University of Massachusetts</a> (pdf)</li>
<li><a href="http://operaomnia.interfree.it/thesis/thesis_italy_XX_ciclo_andrea_anzalone.html">Multiscale analysis for optimized vessel segmentation of fundus retina images</a> Ph.D Thesis</li>
<li><a href="http://www.mathworks.fr/matlabcentral/fileexchange/42927-find-peaks-using-scale-space-approach">Peak detection in 1D data using a scale-space approach</a> BSD-licensed MATLAB code</li>
</ul>

<p>"</p>

<p><a href="Category:Image_processing" title="wikilink">Category:Image processing</a> <a href="Category:Computer_vision" title="wikilink">Category:Computer vision</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23">The Monogenic Scale-Space: A Unifying Approach to Phase-Based Image Processing in Scale Space (2002)<a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39"></li>
<li id="fn40"></li>
<li id="fn41"></li>
<li id="fn42"></li>
<li id="fn43"></li>
<li id="fn44"></li>
<li id="fn45"></li>
<li id="fn46"></li>
<li id="fn47"></li>
<li id="fn48"></li>
<li id="fn49"></li>
<li id="fn50"></li>
<li id="fn51"></li>
<li id="fn52"></li>
<li id="fn53"></li>
<li id="fn54"></li>
<li id="fn55"></li>
<li id="fn56"></li>
<li id="fn57"></li>
<li id="fn58"></li>
<li id="fn59"></li>
<li id="fn60"></li>
<li id="fn61"></li>
<li id="fn62"></li>
<li id="fn63"></li>
<li id="fn64"></li>
<li id="fn65"></li>
<li id="fn66"><a href="http://www.csc.kth.se/~tony/abstracts/Lin10-GenGaussScSp.html">Lindeberg, T. Generalized Gaussian scale-space axiomatics comprising linear scale-space, affine scale-space and spatio-temporal scale-space, Journal of Mathematical Imaging and Vision, Volume 40, Number 1, 36-81, 2011.</a><a href="#fnref66">↩</a></li>
<li id="fn67"><a href="http://dx.doi.org/10.1016/B978-0-12-407701-0.00001-7">Lindeberg, T. Generalized axiomatic scale-space theory'', Advances in Imaging and Electron Physics, Elsevier, volume 178, pages 1-96, 2013.</a><a href="#fnref67">↩</a></li>
<li id="fn68"><a href="http://dx.doi.org/10.1007/s00422-013-0569-z">Lindeberg, T. A computational theory of visual receptive fields, Biological Cybernetics, 107(6): 589-635, 2013.</a><a href="#fnref68">↩</a></li>
<li id="fn69"><a href="http://dx.doi.org/10.1371/journal.pone.0066990">Lindeberg, T. Invariance of visual operations at the level of receptive fields, PLoS ONE 8(7):e66990, 2013</a><a href="#fnref69">↩</a></li>
<li id="fn70"></li>
<li id="fn71"></li>
<li id="fn72"></li>
<li id="fn73"></li>
<li id="fn74"></li>
</ol>
</section>
</body>
</html>
