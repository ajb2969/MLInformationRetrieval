<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1810">Low-rank approximation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Low-rank approximation</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In mathematics, <strong>low-rank approximation</strong> is a <a href="mathematical_optimization" title="wikilink">minimization</a> problem, in which the <a href="Loss_function" title="wikilink">cost function</a> measures the fit between a given matrix (the data) and an approximating matrix (the optimization variable), subject to a constraint that the approximating matrix has reduced <a href="rank_(linear_algebra)" title="wikilink">rank</a>. The problem is used for <a href="mathematical_model" title="wikilink">mathematical modeling</a> and <a href="data_compression" title="wikilink">data compression</a>. The rank constraint is related to a constraint on the complexity of a model that fits the data. In applications, often there are other constraints on the approximating matrix apart from the rank constraint, e.g., <a href="nonnegative_matrix_factorization" title="wikilink">non-negativity</a> and <a href="Hankel_matrix" title="wikilink">Hankel structure</a>.</p>

<p>Low-rank approximation is closely related to:</p>
<ul>
<li><a href="principal_component_analysis" title="wikilink">principal component analysis</a>,</li>
<li><a href="factor_analysis" title="wikilink">factor analysis</a>,</li>
<li><a href="total_least_squares" title="wikilink">total least squares</a>,</li>
<li><a href="latent_semantic_analysis" title="wikilink">latent semantic analysis</a>, and</li>
<li><a href="orthogonal_regression" title="wikilink">orthogonal regression</a>.</li>
</ul>
<h2 id="definition">Definition</h2>

<p>Given</p>
<ul>
<li>structure specification 

<math display="inline" id="Low-rank_approximation:0">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>‚Ñù</mi>
     <msub>
      <mi>n</mi>
      <mi>p</mi>
     </msub>
    </msup>
    <mo>‚Üí</mo>
    <msup>
     <mi>‚Ñù</mi>
     <mrow>
      <mi>m</mi>
      <mo>√ó</mo>
      <mi>n</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ùíÆ</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>‚Ñù</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>‚Ñù</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}:\mathbb{R}^{n_{p}}\to\mathbb{R}^{m\times n}
  </annotation>
 </semantics>
</math>

,</li>
<li>vector of structure parameters 

<math display="inline" id="Low-rank_approximation:1">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>‚àà</mo>
   <msup>
    <mi>‚Ñù</mi>
    <msub>
     <mi>n</mi>
     <mi>p</mi>
    </msub>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>‚Ñù</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\in\mathbb{R}^{n_{p}}
  </annotation>
 </semantics>
</math>

, and</li>
<li>desired rank 

<math display="inline" id="Low-rank_approximation:2">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

,</li>
</ul>

<p>

<math display="block" id="Low-rank_approximation:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>minimize</mtext>
     <mrow>
      <mtext>over</mtext>
      <mover accent="true">
       <mi>p</mi>
       <mo>^</mo>
      </mover>
     </mrow>
     <mrow>
      <mo>‚à•</mo>
      <mrow>
       <mi>p</mi>
       <mo>-</mo>
       <mover accent="true">
        <mi>p</mi>
        <mo>^</mo>
       </mover>
      </mrow>
      <mo>‚à•</mo>
     </mrow>
     <mtext>subject to</mtext>
     <mrow>
      <mo>rank</mo>
      <mrow>
       <mo maxsize="120%" minsize="120%">(</mo>
       <mrow>
        <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mover accent="true">
          <mi>p</mi>
          <mo>^</mo>
         </mover>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo maxsize="120%" minsize="120%">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>‚â§</mo>
    <mi>r</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <list>
     <mtext>minimize</mtext>
     <apply>
      <times></times>
      <mtext>over</mtext>
      <apply>
       <ci>normal-^</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>p</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
     <mtext>subject to</mtext>
     <apply>
      <ci>rank</ci>
      <apply>
       <times></times>
       <ci>ùíÆ</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </list>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{minimize}\quad\text{over }\widehat{p}\quad\|p-\widehat{p}\|\quad\text{%
subject to}\quad\operatorname{rank}\big(\mathcal{S}(\widehat{p})\big)\leq r.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="applications">Applications</h2>
<ul>
<li>Linear <a href="system_identification" title="wikilink">system identification</a>, in which case the approximating matrix is <a href="Hankel_matrix" title="wikilink">Hankel structured</a>.<ref name="sysid-aut"></ref></li>
</ul>

<p>I. Markovsky, Structured low-rank approximation and its applications, Automatica, Volume 44, Issue 4, April 2008, Pages 891‚Äì909. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<ul>
<li><a href="Machine_learning" title="wikilink">Machine learning</a>, in which case the approximating matrix is nonlinearly structured.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li><a href="Recommender_system" title="wikilink">Recommender system</a>, in which case the data matrix has <a href="missing_values" title="wikilink">missing values</a> and the approximation is <a href="categorical_data" title="wikilink">categorical</a>.</li>
<li>Distance <a href="matrix_completion" title="wikilink">matrix completion</a>, in which case there is a positive definiteness constraint.</li>
<li><a href="Natural_language_processing" title="wikilink">Natural language processing</a>, in which case the approximation is <a href="nonnegative_matrix" title="wikilink">nonnegative</a>.</li>
<li><a href="Computer_algebra" title="wikilink">Computer algebra</a>, in which case the approximation is <a href="Sylvester_matrix" title="wikilink">Sylvester structured</a>.</li>
</ul>
<h2 id="basic-low-rank-approximation-problem">Basic low-rank approximation problem</h2>

<p>The unstructured problem with fit measured by the <a href="Frobenius_norm" title="wikilink">Frobenius norm</a>, i.e.,</p>

<p>

<math display="block" id="Low-rank_approximation:4">
 <semantics>
  <mrow>
   <mrow>
    <mtext>minimize</mtext>
    <mrow>
     <mtext>over</mtext>
     <mover accent="true">
      <mi>D</mi>
      <mo>^</mo>
     </mover>
    </mrow>
    <msub>
     <mrow>
      <mo>‚à•</mo>
      <mrow>
       <mi>D</mi>
       <mo>-</mo>
       <mover accent="true">
        <mi>D</mi>
        <mo>^</mo>
       </mover>
      </mrow>
      <mo>‚à•</mo>
     </mrow>
     <mtext>F</mtext>
    </msub>
    <mtext>subject to</mtext>
    <mrow>
     <mo>rank</mo>
     <mrow>
      <mo maxsize="120%" minsize="120%">(</mo>
      <mover accent="true">
       <mi>D</mi>
       <mo>^</mo>
      </mover>
      <mo maxsize="120%" minsize="120%">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <list>
     <mtext>minimize</mtext>
     <apply>
      <times></times>
      <mtext>over</mtext>
      <apply>
       <ci>normal-^</ci>
       <ci>D</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>D</ci>
        <apply>
         <ci>normal-^</ci>
         <ci>D</ci>
        </apply>
       </apply>
      </apply>
      <mtext>F</mtext>
     </apply>
     <mtext>subject to</mtext>
     <apply>
      <ci>rank</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>D</ci>
      </apply>
     </apply>
    </list>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{minimize}\quad\text{over }\widehat{D}\quad\|D-\widehat{D}\|_{\text{F}}%
\quad\text{subject to}\quad\operatorname{rank}\big(\widehat{D}\big)\leq r
  </annotation>
 </semantics>
</math>

 has analytic solution in terms of the <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> of the data matrix. The result is referred to as the matrix approximation lemma or Eckart‚ÄìYoung‚ÄìMirsky theorem.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Let</p>

<p>

<math display="block" id="Low-rank_approximation:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mrow>
     <mi>U</mi>
     <mi mathvariant="normal">Œ£</mi>
     <msup>
      <mi>V</mi>
      <mo>‚ä§</mo>
     </msup>
    </mrow>
    <mo>‚àà</mo>
    <msup>
     <mi>‚Ñù</mi>
     <mrow>
      <mi>m</mi>
      <mo>√ó</mo>
      <mi>n</mi>
     </mrow>
    </msup>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>m</mi>
    <mo>‚â§</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <ci>D</ci>
      <apply>
       <times></times>
       <ci>U</ci>
       <ci>normal-Œ£</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>V</ci>
        <csymbol cd="latexml">top</csymbol>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>‚Ñù</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=U\Sigma V^{\top}\in\mathbb{R}^{m\times n},\quad m\leq n
  </annotation>
 </semantics>
</math>

 be the singular value decomposition of 

<math display="inline" id="Low-rank_approximation:6">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 and partition 

<math display="inline" id="Low-rank_approximation:7">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Low-rank_approximation:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Œ£</mi>
   <mo>=</mo>
   <mo>:</mo>
   <mo>diag</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>œÉ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>œÉ</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Œ£</csymbol>
    <eq></eq>
    <ci>normal-:</ci>
    <ci>diag</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œÉ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-‚Ä¶</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œÉ</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma=:\operatorname{diag}(\sigma_{1},\ldots,\sigma_{m})
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Low-rank_approximation:9">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 as follows:</p>

<p>

<math display="block" id="Low-rank_approximation:10">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mo>:</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>U</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>U</mi>
        <mn>2</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mi mathvariant="normal">Œ£</mi>
   <mo>=</mo>
   <mo>:</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi mathvariant="normal">Œ£</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi mathvariant="normal">Œ£</mi>
        <mn>2</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mtext>and</mtext>
   <mi>V</mi>
   <mo>=</mo>
   <mo>:</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>V</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>V</mi>
        <mn>2</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">U</csymbol>
    <eq></eq>
    <ci>normal-:</ci>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
    </matrix>
    <ci>normal-,</ci>
    <csymbol cd="unknown">Œ£</csymbol>
    <eq></eq>
    <ci>normal-:</ci>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Œ£</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Œ£</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
    </matrix>
    <ci>normal-,</ci>
    <mtext>and</mtext>
    <ci></ci>
    <csymbol cd="unknown">V</csymbol>
    <eq></eq>
    <ci>normal-:</ci>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
    </matrix>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=:\begin{bmatrix}U_{1}&U_{2}\end{bmatrix},\quad\Sigma=:\begin{bmatrix}\Sigma_%
{1}&0\\
0&\Sigma_{2}\end{bmatrix},\quad\text{and}\quad V=:\begin{bmatrix}V_{1}&V_{2}%
\end{bmatrix},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Low-rank_approximation:11">
 <semantics>
  <msub>
   <mi mathvariant="normal">Œ£</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Œ£</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{1}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Low-rank_approximation:12">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>√ó</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\times r
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Low-rank_approximation:13">
 <semantics>
  <msub>
   <mi>U</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{1}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Low-rank_approximation:14">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>√ó</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times r
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Low-rank_approximation:15">
 <semantics>
  <msub>
   <mi>V</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{1}
  </annotation>
 </semantics>
</math>


 is 

<math display="inline" id="Low-rank_approximation:16">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>√ó</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times r
  </annotation>
 </semantics>
</math>

. Then the rank-

<math display="inline" id="Low-rank_approximation:17">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 matrix, obtained from the truncated singular value decomposition</p>

<p>

<math display="block" id="Low-rank_approximation:18">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mover accent="true">
      <mi>D</mi>
      <mo>^</mo>
     </mover>
     <mo>*</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>U</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi mathvariant="normal">Œ£</mi>
      <mn>1</mn>
     </msub>
     <msubsup>
      <mi>V</mi>
      <mn>1</mn>
      <mo>‚ä§</mo>
     </msubsup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>D</ci>
     </apply>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Œ£</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">1</cn>
      </apply>
      <csymbol cd="latexml">top</csymbol>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{D}^{*}=U_{1}\Sigma_{1}V_{1}^{\top},
  </annotation>
 </semantics>
</math>

 is such that</p>

<p>

<math display="block" id="Low-rank_approximation:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo>‚à•</mo>
      <mrow>
       <mi>D</mi>
       <mo>-</mo>
       <msup>
        <mover accent="true">
         <mi>D</mi>
         <mo>^</mo>
        </mover>
        <mo>*</mo>
       </msup>
      </mrow>
      <mo>‚à•</mo>
     </mrow>
     <mtext>F</mtext>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder>
      <mi>min</mi>
      <mrow>
       <mrow>
        <mo>rank</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mover accent="true">
          <mi>D</mi>
          <mo>^</mo>
         </mover>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>‚â§</mo>
       <mi>r</mi>
      </mrow>
     </munder>
     <msub>
      <mrow>
       <mo>‚à•</mo>
       <mrow>
        <mi>D</mi>
        <mo>-</mo>
        <mover accent="true">
         <mi>D</mi>
         <mo>^</mo>
        </mover>
       </mrow>
       <mo>‚à•</mo>
      </mrow>
      <mtext>F</mtext>
     </msub>
    </mrow>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <msubsup>
       <mi>œÉ</mi>
       <mrow>
        <mi>r</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mn>2</mn>
      </msubsup>
      <mo>+</mo>
      <mi mathvariant="normal">‚ãØ</mi>
      <mo>+</mo>
      <msubsup>
       <mi>œÉ</mi>
       <mi>m</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
    </msqrt>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>D</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>D</ci>
         </apply>
         <times></times>
        </apply>
       </apply>
      </apply>
      <mtext>F</mtext>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <min></min>
       <apply>
        <leq></leq>
        <apply>
         <ci>rank</ci>
         <apply>
          <ci>normal-^</ci>
          <ci>D</ci>
         </apply>
        </apply>
        <ci>r</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <ci>D</ci>
         <apply>
          <ci>normal-^</ci>
          <ci>D</ci>
         </apply>
        </apply>
       </apply>
       <mtext>F</mtext>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <root></root>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>œÉ</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <plus></plus>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-‚ãØ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>œÉ</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|D-\widehat{D}^{*}\|_{\text{F}}=\min_{\operatorname{rank}(\widehat{D})\leq r}%
\|D-\widehat{D}\|_{\text{F}}=\sqrt{\sigma^{2}_{r+1}+\cdots+\sigma^{2}_{m}}.
  </annotation>
 </semantics>
</math>

 The minimizer 

<math display="inline" id="Low-rank_approximation:20">
 <semantics>
  <msup>
   <mover accent="true">
    <mi>D</mi>
    <mo>^</mo>
   </mover>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>D</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{D}^{*}
  </annotation>
 </semantics>
</math>


 is unique if and only if 

<math display="inline" id="Low-rank_approximation:21">
 <semantics>
  <mrow>
   <msub>
    <mi>œÉ</mi>
    <mrow>
     <mi>r</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>‚â†</mo>
   <msub>
    <mi>œÉ</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œÉ</ci>
     <apply>
      <plus></plus>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œÉ</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{r+1}\neq\sigma_{r}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="proof-of-eckartyoungmirsky-theorem">Proof of Eckart‚ÄìYoung‚ÄìMirsky theorem</h2>

<p>

<math display="block" id="Low-rank_approximation:22">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>U</mi>
     <mi>n</mi>
    </msub>
    <msub>
     <mi mathvariant="normal">Œ£</mi>
     <mi>n</mi>
    </msub>
    <msubsup>
     <mi>V</mi>
     <mi>n</mi>
     <mo>‚ä§</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Œ£</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <csymbol cd="latexml">top</csymbol>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=U_{n}\Sigma_{n}V^{\top}_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Low-rank_approximation:23">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{n}\quad
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Low-rank_approximation:24">
 <semantics>
  <msubsup>
   <mpadded lspace="10pt" width="+10pt">
    <mi>V</mi>
   </mpadded>
   <mi>n</mi>
   <mo>‚ä§</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <csymbol cd="latexml">top</csymbol>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad V^{\top}_{n}
  </annotation>
 </semantics>
</math>

 are orthogonal matrices, and 

<math display="inline" id="Low-rank_approximation:25">
 <semantics>
  <msub>
   <mi mathvariant="normal">Œ£</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Œ£</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{n}
  </annotation>
 </semantics>
</math>


 is a diagonal matrix with entries 

<math display="inline" id="Low-rank_approximation:26">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>œÉ</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>œÉ</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">‚ãØ</mi>
    <msub>
     <mi>œÉ</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œÉ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œÉ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-‚ãØ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œÉ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sigma_{1}\sigma_{2}\cdots\sigma_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>s.t 

<math display="inline" id="Low-rank_approximation:27">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>œÉ</mi>
     <mi>n</mi>
    </msub>
    <mo>‚â§</mo>
    <msub>
     <mi>œÉ</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>‚â§</mo>
    <mi mathvariant="normal">‚ãØ</mi>
    <mo>‚â§</mo>
    <msub>
     <mi>œÉ</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œÉ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œÉ</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>normal-‚ãØ</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œÉ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sigma_{n}\leq\sigma_{n-1}\leq\cdots\leq\sigma_{1})
  </annotation>
 </semantics>
</math>

.</p>

<p>We claim that the best approximation for 

<math display="inline" id="Low-rank_approximation:28">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 be given by</p>

<p>

<math display="block" id="Low-rank_approximation:29">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mi>k</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi mathvariant="normal">Œ£</mi>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </msubsup>
    <msub>
     <mi>u</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>œÉ</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Œ£</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œÉ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{k}=\Sigma^{k}_{i=1}u_{i}\sigma_{i}v_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>To Prove

<math display="block" id="Low-rank_approximation:30">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{k}\quad
  </annotation>
 </semantics>
</math>

 is indeed the Best approximation i.e. 

<math display="inline" id="Low-rank_approximation:31">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚à•</mo>
    <mrow>
     <mi>A</mi>
     <mo>-</mo>
     <msup>
      <mi>A</mi>
      <mi>k</mi>
     </msup>
    </mrow>
    <mo>‚à•</mo>
   </mrow>
   <mtext>is minimum</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <mtext>is minimum</mtext>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|A-A^{k}\|\quad\text{is minimum}
  </annotation>
 </semantics>
</math>

</p>

<p>Proof by Contradiction:</p>

<p>Let us suppose 

<math display="inline" id="Low-rank_approximation:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo lspace="12.5pt">‚àÉ</mo>
     <mi>B</mi>
     <mrow>
      <mtext>s.t.</mtext>
      <msubsup>
       <mrow>
        <mo>‚à•</mo>
        <mrow>
         <mi>A</mi>
         <mo>-</mo>
         <mi>B</mi>
        </mrow>
        <mo>‚à•</mo>
       </mrow>
       <mn>2</mn>
       <mn>2</mn>
      </msubsup>
     </mrow>
    </mrow>
    <mo><</mo>
    <msubsup>
     <mrow>
      <mo>‚à•</mo>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <msup>
        <mi>A</mi>
        <mi>k</mi>
       </msup>
      </mrow>
      <mo>‚à•</mo>
     </mrow>
     <mn>2</mn>
     <mn>2</mn>
    </msubsup>
   </mrow>
   <mrow>
    <mo>=</mo>
    <msubsup>
     <mi>œÉ</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <list>
      <exists></exists>
      <ci>B</ci>
      <apply>
       <times></times>
       <mtext>s.t.</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">norm</csymbol>
          <apply>
           <minus></minus>
           <ci>A</ci>
           <ci>B</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <ci>A</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>A</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <list>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>œÉ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad\exists\quad B\quad\text{s.t.}\|A-B\|^{2}_{2}<\|A-A^{k}\|^{2}_{2}\quad=%
\quad\sigma^{2}_{k+1}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Low-rank_approximation:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>rank</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>‚â§</mo>
    <mi>k</mi>
   </mrow>
   <mrow>
    <mtext>(Assuming in Low Rank Approximation, we are approximating via a matrix whose rank</mtext>
    <mo>‚â§</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <ci>rank</ci>
      <ci>B</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <leq></leq>
     <mtext>(Assuming in Low Rank Approximation, we are approximating via a matrix whose rank</mtext>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{rank}(B)\leq k\quad\text{(Assuming in Low Rank Approximation, we%
 are approximating via a matrix whose rank}\leq k
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Low-rank_approximation:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>dim</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>null</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo>rank</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>n</mi>
   <mo>‚Üí</mo>
   <mrow>
    <mi>dim</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>null</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi mathvariant="normal">B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â•</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <ci>dim</ci>
       <apply>
        <ci>null</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <ci>rank</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-‚Üí</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>dim</ci>
      <apply>
       <ci>null</ci>
       <ci>normal-B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dim}(\operatorname{null}(B))+\operatorname{rank}(B)=n\rightarrow%
\operatorname{dim(\operatorname{null}(B))}\geq n-k
  </annotation>
 </semantics>
</math>

</p>

<p>Let 

<math display="inline" id="Low-rank_approximation:35">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>‚àà</mo>
   <mrow>
    <mo>null</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>w</ci>
    <apply>
     <ci>null</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in\operatorname{null}(B)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Low-rank_approximation:36">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo>‚à•</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>-</mo>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>w</mi>
     </mrow>
     <mo>‚à•</mo>
    </mrow>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo>‚à•</mo>
     <mrow>
      <mi>A</mi>
      <mi>w</mi>
     </mrow>
     <mo>‚à•</mo>
    </mrow>
    <mn>2</mn>
   </msub>
   <mo><</mo>
   <msub>
    <mi>œÉ</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>A</ci>
         <ci>B</ci>
        </apply>
        <ci>w</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>w</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œÉ</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|(A-B)w\|_{2}=\|Aw\|_{2}<\sigma_{k+1}
  </annotation>
 </semantics>
</math>

</p>

<p>We know that 

<math display="inline" id="Low-rank_approximation:37">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àÉ</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists(k+1)\quad
  </annotation>
 </semantics>
</math>

 dimension space 

<math display="inline" id="Low-rank_approximation:38">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚ãØ</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-‚ãØ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v_{1},v_{2},\cdots,v_{n})\quad
  </annotation>
 </semantics>
</math>

<br/>
 s.t. 

<math display="inline" id="Low-rank_approximation:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mo>‚àà</mo>
    <mrow>
     <mo>span</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>v</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>v</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">‚ãØ</mi>
      <mo>,</mo>
      <msub>
       <mi>v</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mtext>and</mtext>
     <msub>
      <mrow>
       <mo>‚à•</mo>
       <mrow>
        <mi>A</mi>
        <mi>V</mi>
       </mrow>
       <mo>‚à•</mo>
      </mrow>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>‚â•</mo>
    <msub>
     <mi>œÉ</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>V</ci>
     <apply>
      <ci>span</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-‚ãØ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <mtext>and</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>V</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œÉ</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\in\operatorname{span}(v_{1},v_{2},\cdots,v_{n})\quad\text{and}\|AV\|_{2}\geq%
\sigma_{k+1}
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Low-rank_approximation:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>k</mi>
     </mrow>
     <mo>+</mo>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>></mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k+k+1>n\quad
  </annotation>
 </semantics>
</math>

 Hence a contradiction. So we get that 

<math display="inline" id="Low-rank_approximation:41">
 <semantics>
  <msup>
   <mi>A</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{k}
  </annotation>
 </semantics>
</math>

 is the best approximation.</p>
<h2 id="weighted-low-rank-approximation-problems">Weighted low-rank approximation problems</h2>

<p>The Frobenius norm weights uniformly all elements of the approximation error 

<math display="inline" id="Low-rank_approximation:42">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>-</mo>
   <mover accent="true">
    <mi>D</mi>
    <mo>^</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>D</ci>
    <apply>
     <ci>normal-^</ci>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D-\widehat{D}
  </annotation>
 </semantics>
</math>

. Prior knowledge about distribution of the errors can be taken into account by considering the weighted low-rank approximation problem</p>

<p>

<math display="block" id="Low-rank_approximation:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>minimize</mtext>
     <mrow>
      <mtext>over</mtext>
      <mover accent="true">
       <mi>D</mi>
       <mo>^</mo>
      </mover>
     </mrow>
     <mrow>
      <mrow>
       <mrow>
        <msup>
         <mo>vec</mo>
         <mo>‚ä§</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>D</mi>
          <mo>-</mo>
          <mover accent="true">
           <mi>D</mi>
           <mo>^</mo>
          </mover>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mi>W</mi>
      </mrow>
      <mrow>
       <mo>vec</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>D</mi>
         <mo>-</mo>
         <mover accent="true">
          <mi>D</mi>
          <mo>^</mo>
         </mover>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mtext>subject to</mtext>
     <mrow>
      <mo>rank</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>D</mi>
        <mo>^</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>‚â§</mo>
    <mi>r</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <list>
     <mtext>minimize</mtext>
     <apply>
      <times></times>
      <mtext>over</mtext>
      <apply>
       <ci>normal-^</ci>
       <ci>D</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>vec</ci>
         <csymbol cd="latexml">top</csymbol>
        </apply>
        <apply>
         <minus></minus>
         <ci>D</ci>
         <apply>
          <ci>normal-^</ci>
          <ci>D</ci>
         </apply>
        </apply>
       </apply>
       <ci>W</ci>
      </apply>
      <apply>
       <ci>vec</ci>
       <apply>
        <minus></minus>
        <ci>D</ci>
        <apply>
         <ci>normal-^</ci>
         <ci>D</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <mtext>subject to</mtext>
     <apply>
      <ci>rank</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>D</ci>
      </apply>
     </apply>
    </list>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{minimize}\quad\text{over }\widehat{D}\quad\operatorname{vec}^{\top}(D-%
\widehat{D})W\operatorname{vec}(D-\widehat{D})\quad\text{subject to}\quad%
\operatorname{rank}(\widehat{D})\leq r,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Low-rank_approximation:44">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mi>e</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <ci>e</ci>
    <ci>c</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   vec(A)
  </annotation>
 </semantics>
</math>

 <a href="vectorization_(mathematics)" title="wikilink">vectorizes</a> the matrix 

<math display="inline" id="Low-rank_approximation:45">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 column wise and 

<math display="inline" id="Low-rank_approximation:46">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 is a given positive (semi)definite weight matrix.</p>

<p>The general weighted low-rank approximation problem does not admit an analytic solution in terms of the singular value decomposition and is solved by local optimization methods, which provide no guarantee that a globally optimal solution is found.</p>
<h2 id="image-and-kernel-representations-of-the-rank-constraints">Image and kernel representations of the rank constraints</h2>

<p>Using the equivalences</p>

<p>

<math display="block" id="Low-rank_approximation:47">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>rank</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>D</mi>
       <mo>^</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>‚â§</mo>
    <mrow>
     <mi>r</mi>
     <mo>‚áî</mo>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mtext>there are</mtext>
     <mi>P</mi>
    </mrow>
    <mo>‚àà</mo>
    <mrow>
     <msup>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\R</mtext>
      </merror>
      <mrow>
       <mi>m</mi>
       <mo>√ó</mo>
       <mi>r</mi>
      </mrow>
     </msup>
     <mtext>and</mtext>
     <mi>L</mi>
    </mrow>
    <mo>‚àà</mo>
    <mrow>
     <msup>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\R</mtext>
      </merror>
      <mrow>
       <mi>r</mi>
       <mo>√ó</mo>
       <mi>n</mi>
      </mrow>
     </msup>
     <mtext>such that</mtext>
     <mover accent="true">
      <mi>D</mi>
      <mo>^</mo>
     </mover>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mi>L</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <ci>rank</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>D</ci>
      </apply>
     </apply>
     <list>
      <ci>r</ci>
      <csymbol cd="latexml">iff</csymbol>
     </list>
    </apply>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <mtext>there are</mtext>
       <ci>P</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <mtext>\R</mtext>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>r</ci>
        </apply>
       </apply>
       <mtext>and</mtext>
       <ci>L</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <mtext>\R</mtext>
        <apply>
         <times></times>
         <ci>r</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <mtext>such that</mtext>
       <apply>
        <ci>normal-^</ci>
        <ci>D</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>L</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{rank}(\widehat{D})\leq r\quad\iff\quad\text{there are }P\in\R^{m%
\times r}\text{ and }L\in\R^{r\times n}\text{ such that }\widehat{D}=PL
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Low-rank_approximation:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>rank</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>D</mi>
       <mo>^</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>‚â§</mo>
    <mrow>
     <mi>r</mi>
     <mo>‚áî</mo>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mtext>there is full row rank</mtext>
     <mi>R</mi>
    </mrow>
    <mo>‚àà</mo>
    <mrow>
     <msup>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\R</mtext>
      </merror>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mrow>
        <mi>r</mi>
        <mo>√ó</mo>
        <mi>m</mi>
       </mrow>
      </mrow>
     </msup>
     <mtext>such that</mtext>
     <mi>R</mi>
     <mover accent="true">
      <mi>D</mi>
      <mo>^</mo>
     </mover>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <ci>rank</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>D</ci>
      </apply>
     </apply>
     <list>
      <ci>r</ci>
      <csymbol cd="latexml">iff</csymbol>
     </list>
    </apply>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <mtext>there is full row rank</mtext>
       <ci>R</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <mtext>\R</mtext>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <apply>
          <times></times>
          <ci>r</ci>
          <ci>m</ci>
         </apply>
        </apply>
       </apply>
       <mtext>such that</mtext>
       <ci>R</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>D</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{rank}(\widehat{D})\leq r\quad\iff\quad\text{there is full row %
rank }R\in\R^{m-r\times m}\text{ such that }R\widehat{D}=0
  </annotation>
 </semantics>
</math>

 the weighted low-rank approximation problem becomes equivalent to the parameter optimization problems</p>

<p>

<math display="block" id="Low-rank_approximation:49">
 <semantics>
  <mrow>
   <mrow>
    <mtext>minimize</mtext>
    <mrow>
     <mtext>over</mtext>
     <mover accent="true">
      <mi>D</mi>
      <mo>^</mo>
     </mover>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>P</mi>
     <mtext>and</mtext>
     <mi>L</mi>
    </mrow>
    <mrow>
     <mrow>
      <mrow>
       <msup>
        <mo>vec</mo>
        <mo>‚ä§</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>D</mi>
         <mo>-</mo>
         <mover accent="true">
          <mi>D</mi>
          <mo>^</mo>
         </mover>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>W</mi>
     </mrow>
     <mrow>
      <mo>vec</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>D</mi>
        <mo>-</mo>
        <mover accent="true">
         <mi>D</mi>
         <mo>^</mo>
        </mover>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mtext>subject to</mtext>
    <mover accent="true">
     <mi>D</mi>
     <mo>^</mo>
    </mover>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <mtext>minimize</mtext>
     <apply>
      <times></times>
      <mtext>over</mtext>
      <apply>
       <ci>normal-^</ci>
       <ci>D</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <mtext>and</mtext>
      <ci>L</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>vec</ci>
         <csymbol cd="latexml">top</csymbol>
        </apply>
        <apply>
         <minus></minus>
         <ci>D</ci>
         <apply>
          <ci>normal-^</ci>
          <ci>D</ci>
         </apply>
        </apply>
       </apply>
       <ci>W</ci>
      </apply>
      <apply>
       <ci>vec</ci>
       <apply>
        <minus></minus>
        <ci>D</ci>
        <apply>
         <ci>normal-^</ci>
         <ci>D</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <mtext>subject to</mtext>
     <apply>
      <ci>normal-^</ci>
      <ci>D</ci>
     </apply>
    </list>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{minimize}\quad\text{over }\widehat{D},P\text{ and }L\quad\operatorname{%
vec}^{\top}(D-\widehat{D})W\operatorname{vec}(D-\widehat{D})\quad\text{subject%
 to}\quad\widehat{D}=PL
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Low-rank_approximation:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mtext>minimize</mtext>
      <mrow>
       <mtext>over</mtext>
       <mover accent="true">
        <mi>D</mi>
        <mo>^</mo>
       </mover>
       <mtext>and</mtext>
       <mi>R</mi>
      </mrow>
      <mrow>
       <mrow>
        <mrow>
         <msup>
          <mo>vec</mo>
          <mo>‚ä§</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>D</mi>
           <mo>-</mo>
           <mover accent="true">
            <mi>D</mi>
            <mo>^</mo>
           </mover>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mi>W</mi>
       </mrow>
       <mrow>
        <mo>vec</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>D</mi>
          <mo>-</mo>
          <mover accent="true">
           <mi>D</mi>
           <mo>^</mo>
          </mover>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mtext>subject to</mtext>
      <mrow>
       <mi>R</mi>
       <mover accent="true">
        <mi>D</mi>
        <mo>^</mo>
       </mover>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mrow>
     <mrow>
      <mtext>and</mtext>
      <mrow>
       <mi>R</mi>
       <msup>
        <mi>R</mi>
        <mo>‚ä§</mo>
       </msup>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>I</mi>
      <mi>r</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <mtext>minimize</mtext>
      <apply>
       <times></times>
       <mtext>over</mtext>
       <apply>
        <ci>normal-^</ci>
        <ci>D</ci>
       </apply>
       <mtext>and</mtext>
       <ci>R</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>vec</ci>
          <csymbol cd="latexml">top</csymbol>
         </apply>
         <apply>
          <minus></minus>
          <ci>D</ci>
          <apply>
           <ci>normal-^</ci>
           <ci>D</ci>
          </apply>
         </apply>
        </apply>
        <ci>W</ci>
       </apply>
       <apply>
        <ci>vec</ci>
        <apply>
         <minus></minus>
         <ci>D</ci>
         <apply>
          <ci>normal-^</ci>
          <ci>D</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <mtext>subject to</mtext>
      <apply>
       <times></times>
       <ci>R</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>D</ci>
       </apply>
      </apply>
     </list>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <list>
      <mtext>and</mtext>
      <apply>
       <times></times>
       <ci>R</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <csymbol cd="latexml">top</csymbol>
       </apply>
      </apply>
     </list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{minimize}\quad\text{over }\widehat{D}\text{ and }R\quad\operatorname{vec%
}^{\top}(D-\widehat{D})W\operatorname{vec}(D-\widehat{D})\quad\text{subject to%
}\quad R\widehat{D}=0\quad\text{and}\quad RR^{\top}=I_{r},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Low-rank_approximation:51">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{r}
  </annotation>
 </semantics>
</math>

 is the <a href="identity_matrix" title="wikilink">identity matrix</a> of size 

<math display="inline" id="Low-rank_approximation:52">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="alternating-projections-algorithm">Alternating projections algorithm</h2>

<p>The image representation of the rank constraint suggests a parameter optimization methods, in which the cost function is minimized alternatively over one of the variables (

<math display="inline" id="Low-rank_approximation:53">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Low-rank_approximation:54">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

) with the other one fixed. Although simultaneous minimization over both 

<math display="inline" id="Low-rank_approximation:55">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Low-rank_approximation:56">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is a difficult <a href="biconvex_optimization" title="wikilink">biconvex optimization</a> problem, minimization over one of the variables alone is a <a href="linear_least_squares_(mathematics)" title="wikilink">linear least squares</a> problem and can be solved globally and efficiently.</p>

<p>The resulting optimization algorithm (called alternating projections) is globally convergent with a linear convergence rate to a locally optimal solution of the weighted low-rank approximation problem. Starting value for the 

<math display="inline" id="Low-rank_approximation:57">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 (or 

<math display="inline" id="Low-rank_approximation:58">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

) parameter should be given. The iteration is stopped when a user defined convergence condition is satisfied.</p>

<p><a class="uri" href="Matlab" title="wikilink">Matlab</a> implementation of the alternating projections algorithm for weighted low-rank approximation:</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function [dh, f] = wlra_ap(d, w, p, tol, maxiter)
[m, n] = size(d); r = size(p, <span class="fl">2</span>); f = inf;
for i = <span class="fl">2</span>:maxiter
    <span class="co">% minimization over L</span>
    bp = kron(eye(n), p);
    vl = (bp' * w * bp) \ bp' * w * d(:);
    l  = reshape(vl, r, n);
    <span class="co">% minimization over P</span>
    bl = kron(l', eye(m));
    vp = (bl' * w * bl) \ bl' * w * d(:);
    p  = reshape(vp, m, r);
    <span class="co">% check exit condition</span>
    dh = p * l; dd = d - dh;
    f(i) = dd(:)' * w * dd(:);
    if abs(f(i - <span class="fl">1</span>) - f(i)) &lt; tol, break, end
end </code></pre></div>
<h2 id="variable-projections-algorithm">Variable projections algorithm</h2>

<p>The alternating projections algorithm exploits the fact that the low rank approximation problem, parameterized in the image form, is bilinear in the variables 

<math display="inline" id="Low-rank_approximation:59">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Low-rank_approximation:60">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. The bilinear nature of the problem is effectively used in an alternative approach, called variable projections.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Consider again the weighted low rank approximation problem, parameterized in the image form. Minimization with respect to the 

<math display="inline" id="Low-rank_approximation:61">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 variable (a linear least squares problem) leads to the closed form expression of the approximation error as a function of 

<math display="inline" id="Low-rank_approximation:62">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Low-rank_approximation:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>P</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <mrow>
       <mrow>
        <msup>
         <mo>vec</mo>
         <mo>‚ä§</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>D</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mo maxsize="160%" minsize="160%">(</mo>
        <mrow>
         <mi>W</mi>
         <mo>-</mo>
         <mrow>
          <mi>W</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>I</mi>
             <mi>n</mi>
            </msub>
            <mo>‚äó</mo>
            <mi>P</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <msup>
           <mrow>
            <mo maxsize="120%" minsize="120%">(</mo>
            <mrow>
             <msup>
              <mrow>
               <mo stretchy="false">(</mo>
               <mrow>
                <msub>
                 <mi>I</mi>
                 <mi>n</mi>
                </msub>
                <mo>‚äó</mo>
                <mi>P</mi>
               </mrow>
               <mo stretchy="false">)</mo>
              </mrow>
              <mo>‚ä§</mo>
             </msup>
             <mi>W</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mrow>
               <msub>
                <mi>I</mi>
                <mi>n</mi>
               </msub>
               <mo>‚äó</mo>
               <mi>P</mi>
              </mrow>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo maxsize="120%" minsize="120%">)</mo>
           </mrow>
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msup>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msub>
              <mi>I</mi>
              <mi>n</mi>
             </msub>
             <mo>‚äó</mo>
             <mi>P</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo>‚ä§</mo>
          </msup>
          <mi>W</mi>
         </mrow>
        </mrow>
        <mo maxsize="160%" minsize="160%">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo>vec</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>D</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msqrt>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <root></root>
     <apply>
      <times></times>
      <apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>vec</ci>
         <csymbol cd="latexml">top</csymbol>
        </apply>
        <ci>D</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>W</ci>
        <apply>
         <times></times>
         <ci>W</ci>
         <apply>
          <csymbol cd="latexml">tensor-product</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>I</ci>
           <ci>n</ci>
          </apply>
          <ci>P</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="latexml">tensor-product</csymbol>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>I</ci>
              <ci>n</ci>
             </apply>
             <ci>P</ci>
            </apply>
            <csymbol cd="latexml">top</csymbol>
           </apply>
           <ci>W</ci>
           <apply>
            <csymbol cd="latexml">tensor-product</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>I</ci>
             <ci>n</ci>
            </apply>
            <ci>P</ci>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="latexml">tensor-product</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>I</ci>
            <ci>n</ci>
           </apply>
           <ci>P</ci>
          </apply>
          <csymbol cd="latexml">top</csymbol>
         </apply>
         <ci>W</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>vec</ci>
       <ci>D</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(P)=\sqrt{\operatorname{vec}^{\top}(D)\Big(W-W(I_{n}\otimes P)\big((I_{n}%
\otimes P)^{\top}W(I_{n}\otimes P)\big)^{-1}(I_{n}\otimes P)^{\top}W\Big)%
\operatorname{vec}(D)}.
  </annotation>
 </semantics>
</math>

 The original problem is therefore equivalent to the <a href="Least_squares#Non-linear_least_squares" title="wikilink">nonlinear least squares problem</a> of minimizing 

<math display="inline" id="Low-rank_approximation:64">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(P)
  </annotation>
 </semantics>
</math>

 with respect to 

<math display="inline" id="Low-rank_approximation:65">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. For this purpose standard optimization methods, e.g. the <a href="Levenberg-Marquardt_algorithm" title="wikilink">Levenberg-Marquardt algorithm</a> can be used.</p>

<p><a class="uri" href="Matlab" title="wikilink">Matlab</a> implementation of the variable projections algorithm for weighted low-rank approximation:</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function [dh, f] = wlra_varpro(d, w, p, tol, maxiter)
prob = optimset(); prob.solver = <span class="st">'lsqnonlin'</span>;
prob.options = optimset(<span class="st">'MaxIter'</span>, maxiter, <span class="st">'TolFun'</span>, tol); 
prob.x0 = p; prob.objective = @(p) cost_fun(p, d, w);
[p, f ] = lsqnonlin(prob); 
[f, vl] = cost_fun(p, d, w); 
dh = p * reshape(vl, size(p, <span class="fl">2</span>), size(d, <span class="fl">2</span>));

function [f, vl] = cost_fun(p, d, w)
bp = kron(eye(size(d, <span class="fl">2</span>)), p);
vl = (bp' * w * bp) \ bp' * w * d(:);
f = d(:)' * w * (d(:) - bp * vl);</code></pre></div>

<p>The variable projections approach can be applied also to low rank approximation problems parameterized in the kernel form. The method is effective when the number of eliminated variables is much larger than the number of optimization variables left at the stage of the nonlinear least squares minimization. Such problems occur in system identification, parameterized in the kernel form, where the eliminated variables are the approximating trajectory and the remaining variables are the model parameters. In the context of <a href="LTI_system_theory" title="wikilink">linear time-invariant systems</a>, the elimination step is equivalent to <a href="Kalman_filter" title="wikilink">Kalman smoothing</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="CUR_matrix_approximation" title="wikilink">CUR matrix approximation</a> is made from the rows and columns of the original matrix</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>M. T. Chu, R. E. Funderlic, R. J. Plemmons, Structured low-rank approximation, Linear Algebra and its Applications, Volume 366, 1 June 2003, Pages 157‚Äì172 </li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="https://github.com/slra/slra">C++ package for structured-low rank approximation</a></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a> <a href="Category:Dimension_reduction" title="wikilink">Category:Dimension reduction</a> <a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">I. Markovsky, J. C. Willems, S. Van Huffel, B. De Moor, and R. Pintelon, Application of structured total least squares for system identification and model reduction. IEEE Transactions on Automatic Control, Volume 50, Number 10, 2005, pages 1490‚Äì1500.<a href="#fnref1">‚Ü©</a></li>
<li id="fn2">I. Markovsky, Low-Rank Approximation: Algorithms, Implementation, Applications, Springer, 2012, ISBN 978-1-4471-2226-5<a href="#fnref2">‚Ü©</a></li>
<li id="fn3">C. Eckart, G. Young, The approximation of one matrix by another of lower rank. Psychometrika, Volume 1, 1936, Pages 211‚Äì8. <a href="#fnref3">‚Ü©</a></li>
<li id="fn4">G. Golub and V. Pereyra, Separable nonlinear least squares: the variable projection method and its applications, Institute of Physics, Inverse Problems, Volume 19, 2003, Pages 1-26.<a href="#fnref4">‚Ü©</a></li>
</ol>
</section>
</body>

