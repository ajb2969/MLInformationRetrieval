<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1458">Light-front computational methods</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Light-front computational methods</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The light cone of special relativity. Light-front quantization uses light-front (or light-cone) coordinates to select an initial surface that is tangential to the light cone. Equal-time quantization uses an initial surface that is horizontal, labeled here as the "hypersurface of the present".</figcaption>
</figure>

<p>The <a href="light_front_quantization" title="wikilink">light front quantization</a><ref name="whitepaper">{{ cite journal | author=B. L. G. Bakker, A. Bassetto, S. J. Brodsky, W. Broniowski, S. Dalley, T. Frederico, S. D. Glazek, J. R. Hiller, et al. | title=Light-Front Quantum Chromodynamics: A framework for the analysis of hadron physics | journal=<a href="Nuclear_Physics_Proceedings_Supplement" title="wikilink">Nuclear Physics Proceedings Supplement</a> volume=251-252 | pages= 165–174 |year=2014 | arxiv=1309.6333 | doi= 10.1016/j.nuclphysbps.2014.05.004</ref></p>

<p><code>|bibcode=2014NuPhS.251..165B</code><br/>
<code>|volume=251-252}}</code></p>

<p><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> of <a href="Quantum_field_theory" title="wikilink">quantum field theories</a> provides a useful alternative to ordinary equal-time <a href="Quantization_(physics)" title="wikilink">quantization</a>. In particular, it can lead to a <a href="Special_relativity" title="wikilink">relativistic</a> description of <a href="Bound_state" title="wikilink">bound systems</a> in terms of <a href="Quantum_mechanics" title="wikilink">quantum-mechanical</a> <a href="wave_function" title="wikilink">wave functions</a>. The quantization is based on the choice of light-front coordinates,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> where 

<math display="inline" id="Light-front_computational_methods:0">
<semantics>
<mrow>
<msup>
<mi>x</mi>
<mo>+</mo>
</msup>
<mo>≡</mo>
<mrow>
<mrow>
<mi>c</mi>
<mi>t</mi>
</mrow>
<mo>+</mo>
<mi>z</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<plus></plus>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>c</ci>
<ci>t</ci>
</apply>
<ci>z</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x^{+}\equiv ct+z
  </annotation>
</semantics>
</math>

 plays the role of time and the corresponding spatial coordinate is 

<math display="inline" id="Light-front_computational_methods:1">
<semantics>
<mrow>
<msup>
<mi>x</mi>
<mo>-</mo>
</msup>
<mo>≡</mo>
<mrow>
<mrow>
<mi>c</mi>
<mi>t</mi>
</mrow>
<mo>-</mo>
<mi>z</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<minus></minus>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>c</ci>
<ci>t</ci>
</apply>
<ci>z</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x^{-}\equiv ct-z
  </annotation>
</semantics>
</math>

. Here, 

<math display="inline" id="Light-front_computational_methods:2">
<semantics>
<mi>t</mi>
<annotation-xml encoding="MathML-Content">
<ci>t</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   t
  </annotation>
</semantics>
</math>

 is the ordinary time, 

<math display="inline" id="Light-front_computational_methods:3">
<semantics>
<mi>z</mi>
<annotation-xml encoding="MathML-Content">
<ci>z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   z
  </annotation>
</semantics>
</math>

 is one <a href="Cartesian_coordinate_system" title="wikilink">Cartesian coordinate</a>, and 

<math display="inline" id="Light-front_computational_methods:4">
<semantics>
<mi>c</mi>
<annotation-xml encoding="MathML-Content">
<ci>c</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   c
  </annotation>
</semantics>
</math>

 is the speed of light. The other two Cartesian coordinates, 

<math display="inline" id="Light-front_computational_methods:5">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Light-front_computational_methods:6">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

, are untouched and often called transverse or perpendicular, denoted by symbols of the type 

<math display="inline" id="Light-front_computational_methods:7">
<semantics>
<mrow>
<msub>
<mover accent="true">
<mi>x</mi>
<mo stretchy="false">→</mo>
</mover>
<mo>⟂</mo>
</msub>
<mo>=</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-→</ci>
<ci>x</ci>
</apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \vec{x}_{\perp}=(x,y)
  </annotation>
</semantics>
</math>

. The choice of the <a href="frame_of_reference" title="wikilink">frame of reference</a> where the time 

<math display="inline" id="Light-front_computational_methods:8">
<semantics>
<mi>t</mi>
<annotation-xml encoding="MathML-Content">
<ci>t</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   t
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Light-front_computational_methods:9">
<semantics>
<mi>z</mi>
<annotation-xml encoding="MathML-Content">
<ci>z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   z
  </annotation>
</semantics>
</math>

-axis are defined can be left unspecified in an exactly soluble relativistic theory, but in practical calculations some choices may be more suitable than others.</p>

<p>The solution of the LFQCD Hamiltonian eigenvalue equation will utilize the available mathematical methods of quantum mechanics and contribute to the development of advanced computing techniques for large quantum systems, including <a href="Atomic_nucleus" title="wikilink">nuclei</a>. For example, in the discretized light-cone quantization method (DLCQ),<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <ref name="DLCQ3">{{ cite journal | author=T. Maskawa and K. Yamawaki | title=The Problem of 

<math display="inline" id="Light-front_computational_methods:10">
<semantics>
<mrow>
<msup>
<mi>P</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>P</ci>
<plus></plus>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P^{+}=0
  </annotation>
</semantics>
</math>

 Mode in the Null Plane Field Theory and Dirac's Method of Quantization |</ref></p>

<p><code>  journal=</code><a href="Progress_of_Theoretical_Physics" title="wikilink"><code>Progress</code> <code>of</code> <code>Theoretical</code> <code>Physics</code></a><code> | volume= 56 | pages= 270–283 | year=1976 |</code></p>

<p>doi= 10.1143/PTP.56.270}} <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <ref name="DLCQ5">{{ cite journal | author=K. Hornbostel, S. J. Brodsky, and H.-C. Pauli title=Light Cone Quantized QCD in (1+1)-Dimensions | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 41 | pages= 3814–3821 | year=1990 | doi= 10.1103/PhysRevD.41.3814</ref></p>

<p><code>| title=Light-cone-quantized QCD in 1+1 dimensions}}</code></p>

<p><ref name="DLCQ6">{{ cite journal | author=A. C. Tang, S. J. Brodsky, and H.-C. Pauli title=Discretized light cone quantization: Formalism for quantum electrodynamics | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 44 | pages= 1842–1865 | year=1991 | doi= 10.1103/PhysRevD.44.1842</ref></p>

<p><code>| title=Discretized light-cone quantization: Formalism for quantum electrodynamics}}</code></p>

<p>periodic conditions are introduced such that momenta are discretized and the size of the Fock space is limited without destroying Lorentz invariance. Solving a quantum field theory is then reduced to diagonalizing a large sparse <a href="Hermitian_matrix" title="wikilink">Hermitian matrix</a>. The DLCQ method has been successfully used to obtain the complete spectrum and light-front wave functions in numerous model quantum field theories such as QCD with one or two space dimensions for any number of <a href="Flavour_(particle_physics)" title="wikilink">flavors</a> and quark masses. An extension of this method to <a href="Supersymmetry" title="wikilink">supersymmetric theories</a>, SDLCQ,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <ref name="SDLCQ2">{{ cite journal | author=O. Lunin and S. Pinsky | title=SDLCQ: Supersymmetric discrete light cone quantization | journal=<a href="AIP_Conference_Proceedings" title="wikilink">AIP Conference Proceedings</a> | volume= 494 | page= 140 | year=1999 |</ref></p>

<p><code>  doi= 10.1063/1.1301663}}</code></p>

<p>takes advantage of the fact that the light-front Hamiltonian can be factorized as a product of raising and lowering <a href="ladder_operator" title="wikilink">ladder operators</a>. SDLCQ has provided new insights into a number of supersymmetric theories including direct numerical evidence<ref name="Hiller:2005vf">{{ cite journal | author= J. R. Hiller, S. S. Pinsky, N. Salwen and U. Trittmann |</ref></p>

<p><code>title=  Direct evidence for the Maldacena conjecture for N=(8,8) super </code></p>

<p>Yang-Mills theory in 1+1 dimensions |</p>

<p><code>  journal=</code><a href="Physics_Letters_B" title="wikilink"><code>Physics</code> <code>Letters</code> <code>B</code></a><code> | volume= 624 | pages= 105–114 | year=2005 |</code><br/>
<code>  doi= 10.1016/j.physletb.2005.08.003}}</code></p>

<p>for a supergravity/super-Yang—Mills duality conjectured by Maldacena.</p>

<p>It is convenient to work in a Fock basis 

<math display="inline" id="Light-front_computational_methods:11">
<semantics>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mrow>
<mi>n</mi>
<mo>:</mo>
<mrow>
<msubsup>
<mi>p</mi>
<mi>i</mi>
<mo>+</mo>
</msubsup>
<mo>,</mo>
<msub>
<mover accent="true">
<mi>p</mi>
<mo stretchy="false">→</mo>
</mover>
<mrow>
<mi></mi>
<mo>⟂</mo>
<mi>i</mi>
</mrow>
</msub>
</mrow>
</mrow>
<mo stretchy="false">⟩</mo>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<set>
<apply>
<csymbol cd="latexml">ket</csymbol>
<apply>
<ci>normal-:</ci>
<ci>n</ci>
<list>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<ci>i</ci>
</apply>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-→</ci>
<ci>p</ci>
</apply>
<apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
<csymbol cd="latexml">absent</csymbol>
<ci>i</ci>
</apply>
</apply>
</list>
</apply>
</apply>
</set>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{|n:p_{i}^{+},\vec{p}_{\perp i}\rangle\}
  </annotation>
</semantics>
</math>

 where the light-front momenta 

<math display="inline" id="Light-front_computational_methods:12">
<semantics>
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{P}^{+}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Light-front_computational_methods:13">
<semantics>
<msub>
<mover accent="true">
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo stretchy="false">→</mo>
</mover>
<mo>⟂</mo>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-→</ci>
<ci>𝒫</ci>
</apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \vec{\mathcal{P}}_{\perp}
  </annotation>
</semantics>
</math>

 are diagonal. The state 

<math display="inline" id="Light-front_computational_methods:14">
<semantics>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<munder accentunder="true">
<mi>P</mi>
<mo>¯</mo>
</munder>
<mo stretchy="false">⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">ket</csymbol>
<apply>
<ci>normal-¯</ci>
<ci>P</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |\underline{P}\rangle
  </annotation>
</semantics>
</math>

 is given by an expansion</p>

<p>
<math display="inline" id="Light-front_computational_methods:15">
<semantics>
<mrow>
<mrow>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<munder accentunder="true">
<mi>P</mi>
<mo>¯</mo>
</munder>
<mo stretchy="false">⟩</mo>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>n</mi>
</msub>
<mrow>
<mo largeop="true" symmetric="true">∫</mo>
<mrow>
<mpadded width="+1.7pt">
<msub>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>d</mi>
<mi>x</mi>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mi>n</mi>
</msub>
</mpadded>
<mpadded width="+1.7pt">
<msub>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<msup>
<mi>d</mi>
<mn>2</mn>
</msup>
<msub>
<mi>k</mi>
<mo>⟂</mo>
</msub>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mi>n</mi>
</msub>
</mpadded>
<msub>
<mi>ψ</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<msub>
<mover accent="true">
<mi>k</mi>
<mo stretchy="false">→</mo>
</mover>
<mo>⟂</mo>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mrow>
<mi>n</mi>
<mo>:</mo>
<mrow>
<mrow>
<mi>x</mi>
<msup>
<mi>P</mi>
<mo>+</mo>
</msup>
</mrow>
<mo>,</mo>
<mrow>
<mrow>
<mi>x</mi>
<msub>
<mover accent="true">
<mi>P</mi>
<mo stretchy="false">→</mo>
</mover>
<mo>⟂</mo>
</msub>
</mrow>
<mo>+</mo>
<msub>
<mover accent="true">
<mi>k</mi>
<mo stretchy="false">→</mo>
</mover>
<mo>⟂</mo>
</msub>
</mrow>
</mrow>
</mrow>
<mo rspace="4.2pt" stretchy="false">⟩</mo>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="latexml">ket</csymbol>
<apply>
<ci>normal-¯</ci>
<ci>P</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>n</ci>
</apply>
<apply>
<int></int>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<times></times>
<ci>d</ci>
<ci>x</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>d</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>n</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-→</ci>
<ci>k</ci>
</apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</interval>
<apply>
<csymbol cd="latexml">ket</csymbol>
<apply>
<ci>normal-:</ci>
<ci>n</ci>
<list>
<apply>
<times></times>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>P</ci>
<plus></plus>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-→</ci>
<ci>P</ci>
</apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-→</ci>
<ci>k</ci>
</apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</apply>
</list>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |\underline{P}\rangle=\sum_{n}\int[dx]_{n}\,[d^{2}k_{\perp}]_{n}\,\psi_{n}(x,%
\vec{k}_{\perp})|n:xP^{+},x\vec{P}_{\perp}+\vec{k}_{\perp}\rangle\,,
  </annotation>
</semantics>
</math>
</p>

<p>with</p>

<p>
<math display="inline" id="Light-front_computational_methods:16">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>d</mi>
<mi>x</mi>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mi>n</mi>
</msub>
<mo>=</mo>
<mrow>
<mn>4</mn>
<mi>π</mi>
<mi>δ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>n</mi>
</msubsup>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∏</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>n</mi>
</msubsup>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mi>d</mi>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
</mrow>
<mrow>
<mn>4</mn>
<mi>π</mi>
<msqrt>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
</msqrt>
</mrow>
</mfrac>
</mpadded>
</mrow>
</mrow>
</mrow>
<mo rspace="10.9pt">,</mo>
<mrow>
<msub>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<msup>
<mi>d</mi>
<mn>2</mn>
</msup>
<msub>
<mi>k</mi>
<mo>⟂</mo>
</msub>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mi>n</mi>
</msub>
<mo>=</mo>
<mrow>
<mn>4</mn>
<msup>
<mi>π</mi>
<mn>2</mn>
</msup>
<mi>δ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>n</mi>
</msubsup>
<msub>
<mover accent="true">
<mi>k</mi>
<mo stretchy="false">→</mo>
</mover>
<mrow>
<mi></mi>
<mo>⟂</mo>
<mi>i</mi>
</mrow>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∏</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>n</mi>
</msubsup>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<msup>
<mi>d</mi>
<mn>2</mn>
</msup>
<msub>
<mi>k</mi>
<mrow>
<mi></mi>
<mo>⟂</mo>
<mi>i</mi>
</mrow>
</msub>
</mrow>
<mrow>
<mn>4</mn>
<msup>
<mi>π</mi>
<mn>2</mn>
</msup>
</mrow>
</mfrac>
</mpadded>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<times></times>
<ci>d</ci>
<ci>x</ci>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<times></times>
<cn type="integer">4</cn>
<ci>π</ci>
<ci>δ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">product</csymbol>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>d</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">4</cn>
<ci>π</ci>
<apply>
<root></root>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>d</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<times></times>
<cn type="integer">4</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">2</cn>
</apply>
<ci>δ</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-→</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
<csymbol cd="latexml">absent</csymbol>
<ci>i</ci>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">product</csymbol>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>d</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
<csymbol cd="latexml">absent</csymbol>
<ci>i</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">4</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   [dx]_{n}=4\pi\delta(1-\sum_{i=1}^{n}x_{i})\prod_{i=1}^{n}\frac{dx_{i}}{4\pi%
\sqrt{x_{i}}}\,,\;\;\;[d^{2}k_{\perp}]_{n}=4\pi^{2}\delta(\sum_{i=1}^{n}\vec{k%
}_{\perp i})\prod_{i=1}^{n}\frac{d^{2}k_{\perp i}}{4\pi^{2}}\,.
  </annotation>
</semantics>
</math>
<math display="inline" id="Light-front_computational_methods:17">
<semantics>
<msub>
<mi>ψ</mi>
<mi>n</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{n}
  </annotation>
</semantics>
</math>

 is interpreted as the wave function of the contribution from states with 

<math display="inline" id="Light-front_computational_methods:18">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

 particles. The eigenvalue problem 

<math display="inline" id="Light-front_computational_methods:19">
<semantics>
<mrow>
<mrow>
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>-</mo>
</msup>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<munder accentunder="true">
<mi>P</mi>
<mo>¯</mo>
</munder>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mrow>
<msup>
<mi>M</mi>
<mn>2</mn>
</msup>
<mo>+</mo>
<msubsup>
<mi>P</mi>
<mo>⟂</mo>
<mn>2</mn>
</msubsup>
</mrow>
<msup>
<mi>P</mi>
<mo>+</mo>
</msup>
</mfrac>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<munder accentunder="true">
<mi>P</mi>
<mo>¯</mo>
</munder>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<minus></minus>
</apply>
<apply>
<csymbol cd="latexml">ket</csymbol>
<apply>
<ci>normal-¯</ci>
<ci>P</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>M</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>P</ci>
<plus></plus>
</apply>
</apply>
<apply>
<csymbol cd="latexml">ket</csymbol>
<apply>
<ci>normal-¯</ci>
<ci>P</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{P}^{-}|\underline{P}\rangle=\frac{M^{2}+P_{\perp}^{2}}{P^{+}}|%
\underline{P}\rangle
  </annotation>
</semantics>
</math>

 is a set of coupled integral equations for these wave functions. Although the notation as presented supports only one particle type, the generalization to more than one is trivial.</p>
<h2 id="discrete-light-cone-quantization">Discrete light-cone quantization</h2>

<p>A systematic approach to discretization of the eigenvalue problem is the DLCQ method originally suggested by Pauli and Brodsky.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> In essence it is the replacement of integrals by trapezoidal approximations, with equally-spaced intervals in the longitudinal and transverse momenta</p>

<p>
<math display="inline" id="Light-front_computational_methods:20">
<semantics>
<mrow>
<mrow>
<mrow>
<msup>
<mi>p</mi>
<mo>+</mo>
</msup>
<mo>→</mo>
<mrow>
<mfrac>
<mrow>
<mn>2</mn>
<mi>π</mi>
</mrow>
<mi>L</mi>
</mfrac>
<mpadded width="+1.7pt">
<mi>n</mi>
</mpadded>
</mrow>
</mrow>
<mo rspace="8.1pt">,</mo>
<mrow>
<msub>
<mover accent="true">
<mi>p</mi>
<mo stretchy="false">→</mo>
</mover>
<mo>⟂</mo>
</msub>
<mo>→</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mfrac>
<mi>π</mi>
<msub>
<mi>L</mi>
<mo>⟂</mo>
</msub>
</mfrac>
<msub>
<mi>n</mi>
<mi>x</mi>
</msub>
</mrow>
<mo>,</mo>
<mrow>
<mfrac>
<mi>π</mi>
<msub>
<mi>L</mi>
<mo>⟂</mo>
</msub>
</mfrac>
<msub>
<mi>n</mi>
<mi>y</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>p</ci>
<plus></plus>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
</apply>
<ci>L</ci>
</apply>
<ci>n</ci>
</apply>
</apply>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-→</ci>
<ci>p</ci>
</apply>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
<interval closure="open">
<apply>
<times></times>
<apply>
<divide></divide>
<ci>π</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>x</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<ci>π</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>y</ci>
</apply>
</apply>
</interval>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p^{+}\rightarrow\frac{2\pi}{L}n\,,\;\;\vec{p}_{\perp}\rightarrow(\frac{\pi}{L_%
{\perp}}n_{x},\frac{\pi}{L_{\perp}}n_{y}),
  </annotation>
</semantics>
</math>
</p>

<p>corresponding to <a href="periodic_boundary_conditions" title="wikilink">periodic boundary conditions</a> on the intervals 

<math display="inline" id="Light-front_computational_methods:21">
<semantics>
<msub>
<mi>L</mi>
<mo>⟂</mo>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L_{\perp}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Light-front_computational_methods:22">
<semantics>
<mrow>
<mi>L</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>L</ci>
<infinity></infinity>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L\rightarrow\infty
  </annotation>
</semantics>
</math>

 determine the resolution of the calculation. Because the plus component of momentum is always positive, the limit 

<math display="inline" id="Light-front_computational_methods:23">
<semantics>
<mrow>
<mi>K</mi>
<mo>≡</mo>
<mrow>
<mfrac>
<mi>L</mi>
<mrow>
<mn>2</mn>
<mi>π</mi>
</mrow>
</mfrac>
<msup>
<mi>P</mi>
<mo>+</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<ci>K</ci>
<apply>
<times></times>
<apply>
<divide></divide>
<ci>L</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>P</ci>
<plus></plus>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   K\equiv\frac{L}{2\pi}P^{+}
  </annotation>
</semantics>
</math>

 can be exchanged for a limit in terms of the integer {\em resolution} 

<math display="inline" id="Light-front_computational_methods:24">
<semantics>
<mrow>
<msub>
<mi>H</mi>
<mi>LC</mi>
</msub>
<mo>=</mo>
<mrow>
<msup>
<mi>P</mi>
<mo>+</mo>
</msup>
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>-</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>LC</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>P</ci>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<minus></minus>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{\rm LC}=P^{+}\mathcal{P}^{-}
  </annotation>
</semantics>
</math>

. The combination of momentum components that defines 

<math display="inline" id="Light-front_computational_methods:25">
<semantics>
<mi>L</mi>
<annotation-xml encoding="MathML-Content">
<ci>L</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   L
  </annotation>
</semantics>
</math>

 is then independent of 

<math display="inline" id="Light-front_computational_methods:26">
<semantics>
<mrow>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo>≡</mo>
<mrow>
<msubsup>
<mi>p</mi>
<mi>i</mi>
<mo>+</mo>
</msubsup>
<mo>/</mo>
<msup>
<mi>P</mi>
<mo>+</mo>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<ci>i</ci>
</apply>
<plus></plus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>P</ci>
<plus></plus>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{i}\equiv p_{i}^{+}/P^{+}
  </annotation>
</semantics>
</math>

. The longitudinal momentum fractions 

<math display="inline" id="Light-front_computational_methods:27">
<semantics>
<mrow>
<msub>
<mi>n</mi>
<mi>i</mi>
</msub>
<mo>/</mo>
<mi>K</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>i</ci>
</apply>
<ci>K</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n_{i}/K
  </annotation>
</semantics>
</math>

 become ratios of integers 

<math display="inline" id="Light-front_computational_methods:28">
<semantics>
<msub>
<mi>n</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n_{i}
  </annotation>
</semantics>
</math>

. Because the 

<math display="inline" id="Light-front_computational_methods:29">
<semantics>
<mi>K</mi>
<annotation-xml encoding="MathML-Content">
<ci>K</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   K
  </annotation>
</semantics>
</math>

 are all positive, DLCQ automatically limits the number of particles to be no more than 

<math display="inline" id="Light-front_computational_methods:30">
<semantics>
<msup>
<mi>Q</mi>
<mo>-</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Q</ci>
<minus></minus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q^{-}
  </annotation>
</semantics>
</math>

. When a limit on transverse momentum is supplied via a chosen cutoff, a finite matrix problem is obtained; however, the matrix may be too large for present numerical techniques. An explicit truncation in particle number, the light-cone equivalent of the Tamm—Dancoff approximation, can then be made. Large basis sizes require special techniques for matrix diagonalization; the one typically used is the <a href="Lanczos_algorithm" title="wikilink">Lanczos algorithm</a>. For the case of one space dimension, one can readily solve for the hadron spectrum of QCD for any quark masses and colors.</p>

<p>Most DLCQ calculations are done without zero modes. However, in principle, any DLCQ basis with periodic boundary conditions may include them as constrained modes, dependent on the other modes with nonzero momentum. The constraint comes from the spatial average of the <a href="Euler-Lagrange_equation" title="wikilink">Euler-Lagrange equation</a> for the field. This constraint equation can be difficult to solve, even for the simplest theories. However, an approximate solution can be found, consistent with the underlying approximations of the DLCQ method itself.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> This solution generates the effective zero-mode interactions for the light-front Hamiltonian.</p>

<p>Calculations in the massive sector that are done without zero modes will usually yield the correct answer. The neglect of zero modes merely worsens the convergence. One exception is that of cubic scalar theories, where the spectrum extends to minus infinity. A DLCQ calculation without zero modes will require careful extrapolation to detect this infinity, whereas a calculation that includes zero modes yields the correct result immediately. The zero modes are avoided if one uses antiperiodic boundary conditions.</p>
<h2 id="supersymmetric-discrete-light-cone-quantization">Supersymmetric discrete light-cone quantization</h2>

<p>The supersymmetric form of DLCQ (SDLCQ)<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> is specifically designed to maintain supersymmetry in the discrete approximation. Ordinary DLCQ violates supersymmetry by terms that do not survive the continuum limit. The SDLCQ construction discretizes the supercharge 

<math display="inline" id="Light-front_computational_methods:31">
<semantics>
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>-</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<minus></minus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{P}^{-}
  </annotation>
</semantics>
</math>

 and {\em defines} the Hamiltonian 

<math display="inline" id="Light-front_computational_methods:32">
<semantics>
<mrow>
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>-</mo>
</msup>
<mo>=</mo>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">{</mo>
<msup>
<mi>Q</mi>
<mo>-</mo>
</msup>
<mo>,</mo>
<msup>
<mi>Q</mi>
<mo>-</mo>
</msup>
<mo stretchy="false">}</mo>
</mrow>
<mo>/</mo>
<mn>2</mn>
</mrow>
<msqrt>
<mn>2</mn>
</msqrt>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<minus></minus>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<set>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Q</ci>
<minus></minus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Q</ci>
<minus></minus>
</apply>
</set>
<cn type="integer">2</cn>
</apply>
<apply>
<root></root>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{P}^{-}=\{Q^{-},Q^{-}\}/2\sqrt{2}
  </annotation>
</semantics>
</math>

 by the superalgebra relation 

<math display="inline" id="Light-front_computational_methods:33">
<semantics>
<mrow>
<mo stretchy="false">⟨</mo>
<mrow>
<msup>
<mi>T</mi>
<mrow>
<mi></mi>
<mo>+</mo>
<mo>+</mo>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>T</mi>
<mrow>
<mi></mi>
<mo>+</mo>
<mo>+</mo>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">delimited-⟨⟩</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>T</ci>
<apply>
<plus></plus>
<csymbol cd="latexml">absent</csymbol>
<plus></plus>
</apply>
</apply>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>T</ci>
<apply>
<plus></plus>
<csymbol cd="latexml">absent</csymbol>
<plus></plus>
</apply>
</apply>
<ci>y</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \langle T^{++}(x)T^{++}(y)\rangle
  </annotation>
</semantics>
</math>

. The range of transverse momentum is limited by a simple cutoff in the momentum value. Effects of zero modes are expected to cancel.</p>

<p>In addition to calculations of spectra, this technique can be used to calculate expectation values. One such quantity, a <a href="Correlation_function_(quantum_field_theory)" title="wikilink">correlator</a>
<math display="inline" id="Light-front_computational_methods:34">
<semantics>
<msup>
<mi>x</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x^{+}
  </annotation>
</semantics>
</math>

 of the <a href="stress_energy_tensor" title="wikilink">stress energy tensor</a>, has been computed as a test of a <a href="Maldacena_conjecture" title="wikilink">Maldacena conjecture</a>. A very efficient Lanczos-based method was developed for this calculation. The most recent results provide direct evidence for the conjecture.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="transverse-lattice">Transverse lattice</h2>

<p>The transverse lattice method<ref name="TransLattice1">{{ cite journal | author=W. A. Bardeen and R. B. Pearson |</ref></p>

<p><code>title= Local Gauge Invariance and the Bound State Nature of Hadrons |</code><br/>
<code> journal=</code><a href="Physical_Review_D" title="wikilink"><code>Physical</code> <code>Review</code> <code>D</code></a><code> | volume= 14 | pages= 547–551 | year=1976 |</code><br/>
<code> doi= 10.1103/PhysRevD.14.547}}</code><ref name="TransLattice2"><code>{{ cite journal | </code></ref></p>

<p>author=M. Burkardt and S. Dalley | title=The relativistic bound state problem in QCD: transverse lattice methods |</p>

<p><code>  journal=</code><a href="Progress_in_Particle_and_Nuclear_Physics" title="wikilink"><code>Progress</code> <code>in</code> <code>Particle</code> <code>and</code> <code>Nuclear</code> <code>Physics</code></a><code> | volume= 48 | pages= 317–362 | year=2002 |</code><br/>
<code>  doi= 10.1016/S0146-6410(02)00140-0}}</code></p>

<p>brings together two powerful ideas in quantum field theory: light-front Hamiltonian quantization and lattice gauge theory. Lattice gauge theory is a very popular means of regulating for calculation the gauge theories that describe all visible matter in the universe; in particular, it manifestly demonstrates the linear <a href="Color_confinement" title="wikilink">confinement</a> of QCD that holds quarks and gluons inside the protons and neutrons of the atomic nucleus. In general, to obtain solutions of a quantum field theory, with its continuously infinite degrees of freedom, one must put kinematical cutoffs or other restrictions on the space of quantum states. To remove the errors this introduces, one may then extrapolate these cutoffs, provided a continuum limit exists, and/or renormalize observables to account for degrees of freedom above the cutoff. For the purposes of Hamiltonian quantization, one must have a continuous time direction. In the case of light-front Hamiltonian quantization, in addition to continuous light-front time 

<math display="inline" id="Light-front_computational_methods:35">
<semantics>
<msup>
<mi>x</mi>
<mo>-</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<minus></minus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x^{-}
  </annotation>
</semantics>
</math>

, it is necessary to keep the 

<math display="inline" id="Light-front_computational_methods:36">
<semantics>
<msup>
<mi>p</mi>
<mo>-</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>p</ci>
<minus></minus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p^{-}
  </annotation>
</semantics>
</math>

 direction continuous if one wants to preserve the manifest Lorentz boost invariance in one direction and to include small light-front energies 

<math display="inline" id="Light-front_computational_methods:37">
<semantics>
<msub>
<mi>N</mi>
<mi>c</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>N</ci>
<ci>c</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   N_{c}
  </annotation>
</semantics>
</math>

. Therefore, at most one can impose a lattice cutoff on the remaining transverse spatial directions. Such a transverse lattice gauge theory was first suggested by Bardeen and Pearson in 1976.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>Most practical calculations performed with transverse lattice gauge theory have utilized one further ingredient: the color-dielectric expansion. A dielectric formulation is one in which the gauge group elements, whose generators are the gluon fields in the case of QCD, are replaced by collective (smeared, blocked, etc.) variables which represent an average over their fluctuations on short distance scales. These dielectric variables are massive, carry color, and form an effective gauge field theory with classical action minimized at zero field, meaning that color flux is expelled from the vacuum at the classical level. This maintains the triviality of the light-front vacuum structure, but arises only for a low momentum cutoff on the effective theory (corresponding to transverse lattice spacings of order 1/2 fm in QCD). As a result, the effective cutoff Hamiltonian is initially poorly constrained. The color-dielectric expansion, together with requirements of Lorentz symmetry restoration, has nevertheless been successfully used to organize the interactions in the Hamiltonian in a way suitable for practical solution. The most accurate spectrum of large-

<math display="inline" id="Light-front_computational_methods:38">
<semantics>
<msup>
<mi>x</mi>
<mo>-</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<minus></minus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x^{-}
  </annotation>
</semantics>
</math>
<a class="uri" href="glueballs" title="wikilink">glueballs</a> has been obtained in this way, and as well as <a class="uri" href="pion" title="wikilink">pion</a> light-front wave functions in agreement with a range of experimental data.</p>
<h2 id="basis-light-front-quantization">Basis Light-Front Quantization</h2>

<p>The basis light-front quantization (BLFQ) approach<ref name="Vary:2009gt">{{ cite journal | author= J. P. Vary, H. Honkanen, J. Li, P. Maris, S. J. Brodsky, A. Harindranath,</ref></p>

<p><code> G. F. de Teramond, and P. Sternberg |</code><br/>
<code>title= Hamiltonian light-front field theory in a basis function approach |</code><br/>
<code> journal=</code><a href="Physical_Review_C" title="wikilink"><code>Physical</code> <code>Review</code> <code>C</code></a><code> | volume= 81 | page= 035205 | year=2010 |</code><br/>
<code> doi= 10.1103/PhysRevC.81.035205}}</code></p>

<p>uses expansions in products of single-particle basis functions to represent the Fock-state wave functions. Typically, the longitudinal (

<math display="inline" id="Light-front_computational_methods:39">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

) dependence is represented in the DLCQ basis of <a href="plane_waves" title="wikilink">plane waves</a>, and the transverse dependence is represented by two-dimensional <a href="Harmonic_oscillator_(quantum)" title="wikilink">harmonic oscillator</a> functions. The latter are ideal for applications to confining cavities and are consistent with <a href="Light_front_holography" title="wikilink">light-front holographic QCD</a>.<ref name="deTeramond:2005su">{{ cite journal | author= G. F. de Teramond and S. J. Brodsky |</ref></p>

<p><code>title=  Hadronic spectrum of a holographic dual of QCD |</code><br/>
<code>  journal=</code><a href="Physical_Review_Letters" title="wikilink"><code>Physical</code> <code>Review</code> <code>Letters</code></a><code> | volume= 94 | page= 201601 | year=2005 |</code><br/>
<code>  doi= 10.1103/PhysRevLett.94.201601 | bibcode=2005PhRvL..94t1601D}}</code></p>

<p><ref name="deTeramond:2008ht">{{ cite journal | author= G. F. de Teramond and S. J. Brodsky |</ref></p>

<p><code>title=  Light-Front Holography: A First Approximation to QCD |</code><br/>
<code>  journal=</code><a href="Physical_Review_Letters" title="wikilink"><code>Physical</code> <code>Review</code> <code>Letters</code></a><code> | volume= 102 | page= 081601 | year=2009 |</code><br/>
<code>  doi= 10.1103/PhysRevLett.102.081601 | pmid=19257731}}</code></p>

<p><ref name="Brodsky:2011sk">{{ cite journal | author= S. J. Brodsky, F. -G. Cao and G. F. de Teramond |</ref></p>

<p><code>title=  AdS/QCD and Applications of Light-Front Holography |</code><br/>
<code>journal=  </code><a href="Communications_in_Theoretical_Physics" title="wikilink"><code>Communications</code> <code>in</code> <code>Theoretical</code> <code>Physics</code></a><code> | volume= 57 | pages= 641–664 | year=2012 |</code><br/>
<code>  doi= 10.1088/0253-6102/57/4/21 | bibcode=2012CoTPh..57..641S}}</code></p>

<p><ref name="Gutsche:2012wb">{{ cite journal | author= T. Gutsche, V. E. Lyubovitskij, I. Schmidt and A. Vega |</ref></p>

<p><code>title=  Nucleon resonances in AdS/QCD |</code><br/>
<code>  journal=</code><a href="Physical_Review_D" title="wikilink"><code>Physical</code> <code>Review</code> <code>D</code></a><code> | volume= 87 | page= 016017 | year=2013 |</code><br/>
<code>  doi= 10.1103/PhysRevD.87.016017 | bibcode=2013PhRvD..87a6017G}}</code></p>

<p><ref name="Gutsche:2012ez">{{ cite journal | author= T. Gutsche, V. E. Lyubovitskij, I. Schmidt and A. Vega | title= Chiral Symmetry Breaking and Meson Wave Functions in Soft-Wall AdS/QCD |</ref></p>

<p><code>  journal=</code><a href="Physical_Review_D" title="wikilink"><code>Physical</code> <code>Review</code> <code>D</code></a><code> | volume= 87 | page= 056001 | year=2013 |</code><br/>
<code>  doi= 10.1103/PhysRevD.87.056001 | bibcode=2013PhRvD..87e6001G}}</code></p>

<p>The use of products of single particle basis functions is also convenient for incorporation of <a class="uri" href="boson" title="wikilink">boson</a> and <a class="uri" href="fermion" title="wikilink">fermion</a> statistics, because the products are readily (anti)symmetrized. By employing two-dimensional basis functions with rotational symmetry about the longitudinal direction (where the harmonic oscillator functions serve as an example), one preserves the total angular momentum projection quantum number which facilitates determination of the total angular momentum of the mass eigenstates. For applications without an external cavity, where transverse momentum is conserved, a <a href="Lagrange_multiplier" title="wikilink">Lagrange multiplier</a> method is used to separate the relative transverse motion from the total system's motion.</p>

<p>The first application of BLFQ to QED solved for the electron in a two-dimensional transverse confining cavity and showed how the anomalous magnetic moment behaved as a function of the strength of the cavity.<ref name="Honkanen:2010rc">{{ cite journal | author= H. Honkanen, P. Maris, J. P. Vary and S. J. Brodsky |</ref></p>

<p><code>title= Electron in a transverse harmonic cavity |</code><br/>
<code> journal=</code><a href="Physical_Review_Letters" title="wikilink"><code>Physical</code> <code>Review</code> <code>Letters</code></a><code> | volume= 106 | page= 061603 | year=2011 |</code><br/>
<code> doi= 10.1103/PhysRevLett.106.061603 | bibcode=2011PhRvL.106f1603H}}</code></p>

<p>The second application of BLFQ to QED solved for the electron's anomalous magnetic moment in free space<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> and demonstrated agreement with the Schwinger moment in the appropriate limit.</p>

<p>The extension of BLFQ to the time-dependent regime, namely, time-dependent BLFQ (tBLFQ) is straightforward and is currently under active development. The goal of tBLFQ is to solve light-front field theory in real-time (with or without time-dependent background fields). The typical application areas include intense <a class="uri" href="lasers" title="wikilink">lasers</a> (see <a href="Light-front_quantization#Intense_lasers" title="wikilink">Light-front quantization#Intense lasers</a>}) and relativistic <a href="heavy-ion_collisions" title="wikilink">heavy-ion collisions</a>.</p>
<h2 id="light-front-coupled-cluster-method">Light-front coupled-cluster method</h2>

<p>The light-front coupled cluster (LFCC) method<ref name="LFCC">{{ cite journal | author= S. S. Chabysheva and J. R. Hiller | title= A Light-Front Coupled-Cluster Method for the Nonperturbative Solution of Quantum Field Theories |</ref></p>

<p><code>  journal=</code><a href="Physics_Letters_B" title="wikilink"><code>Physics</code> <code>Letters</code> <code>B</code></a><code> | volume= 711 | pages= 417–422 | year=2012 |</code><br/>
<code>  doi= 10.1016/j.physletb.2012.04.032</code><br/>
<code>| bibcode=2012PhLB..711..417C}}</code></p>

<p>is a particular form of truncation for the infinite coupled system of integral equations for light-front wave functions. The system of equations that comes from the field-theoretic Schrödinger equation also requires regularization, to make the integral operators finite. The traditional Fock-space truncation of the system, where the allowed number of particles is limited, typically disrupts the regularization by removing infinite parts that would otherwise cancel against parts that are retained. Although there are ways to circumvent this, they are not completely satisfactory.</p>

<p>The LFCC method avoids these difficulties by truncating the set of equations in a very different way. Instead of truncating the number of particles, it truncates the way in which wave functions are related to each other; the wave functions of higher Fock states are determined by the lower-state wave functions and the exponentiation of an operator 

<math display="inline" id="Light-front_computational_methods:40">
<semantics>
<mrow>
<msqrt>
<mi>Z</mi>
</msqrt>
<msup>
<mi>e</mi>
<mi>T</mi>
</msup>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mi>ϕ</mi>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<root></root>
<ci>Z</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>T</ci>
</apply>
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>ϕ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sqrt{Z}e^{T}|\phi\rangle
  </annotation>
</semantics>
</math>

. Specifically, the eigenstate is written in the form 

<math display="inline" id="Light-front_computational_methods:41">
<semantics>
<msqrt>
<mi>Z</mi>
</msqrt>
<annotation-xml encoding="MathML-Content">
<apply>
<root></root>
<ci>Z</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sqrt{Z}
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Light-front_computational_methods:42">
<semantics>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mi>ϕ</mi>
<mo stretchy="false">⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>ϕ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |\phi\rangle
  </annotation>
</semantics>
</math>

 is a normalization factor and 

<math display="inline" id="Light-front_computational_methods:43">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

 is a state with the minimal number of constituents. The operator 

<math display="inline" id="Light-front_computational_methods:44">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

 increases particle number and conserves all relevant quantum numbers, including light-front momentum. This is in principle exact but also still infinite, because 

<math display="inline" id="Light-front_computational_methods:45">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

 can have an infinite number of terms. Zero modes can be included by inclusion of their creation as terms in 

<math display="inline" id="Light-front_computational_methods:46">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

; this generates a nontrivial vacuum as a generalized <a href="coherent_state" title="wikilink">coherent state</a> of zero modes.</p>

<p>The truncation made is a truncation of 

<math display="inline" id="Light-front_computational_methods:47">
<semantics>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mi>ϕ</mi>
<mo stretchy="false">⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>ϕ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |\phi\rangle
  </annotation>
</semantics>
</math>

. The original eigenvalue problem becomes a finite-sized eigenvalue problem for the <a href="Quark_model" title="wikilink">valence state</a>
<math display="inline" id="Light-front_computational_methods:48">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

, combined with auxiliary equations for the terms retained in 

<math display="inline" id="Light-front_computational_methods:49">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>P</mi>
<mi>v</mi>
</msub>
<mover accent="true">
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>-</mo>
</msup>
<mo>¯</mo>
</mover>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mi>ϕ</mi>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mrow>
<msup>
<mi>M</mi>
<mn>2</mn>
</msup>
<mo>+</mo>
<msubsup>
<mi>P</mi>
<mo>⟂</mo>
<mn>2</mn>
</msubsup>
</mrow>
<msup>
<mi>P</mi>
<mo>+</mo>
</msup>
</mfrac>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mi>ϕ</mi>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
</mrow>
<mo rspace="13.7pt">,</mo>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<msub>
<mi>P</mi>
<mi>v</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mover accent="true">
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>-</mo>
</msup>
<mo>¯</mo>
</mover>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mi>ϕ</mi>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0.</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>v</ci>
</apply>
<apply>
<ci>normal-¯</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<minus></minus>
</apply>
</apply>
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>ϕ</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>M</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>P</ci>
<plus></plus>
</apply>
</apply>
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>ϕ</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>v</ci>
</apply>
</apply>
<apply>
<ci>normal-¯</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<minus></minus>
</apply>
</apply>
<apply>
<csymbol cd="latexml">ket</csymbol>
<ci>ϕ</ci>
</apply>
</apply>
<cn type="float">0.</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P_{v}\overline{\mathcal{P}^{-}}|\phi\rangle=\frac{M^{2}+P_{\perp}^{2}}{P^{+}}|%
\phi\rangle,\;\;\;\;(1-P_{v})\overline{\mathcal{P}^{-}}|\phi\rangle=0.
  </annotation>
</semantics>
</math>

:</p>

<p>
<math display="inline" id="Light-front_computational_methods:50">
<semantics>
<msub>
<mi>P</mi>
<mi>v</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>v</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P_{v}
  </annotation>
</semantics>
</math>
</p>

<p>Here 

<math display="inline" id="Light-front_computational_methods:51">
<semantics>
<mrow>
<mover accent="true">
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>-</mo>
</msup>
<mo>¯</mo>
</mover>
<mo>≡</mo>
<mrow>
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mi>T</mi>
</mrow>
</msup>
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>-</mo>
</msup>
<msup>
<mi>e</mi>
<mi>T</mi>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<equivalent></equivalent>
<apply>
<ci>normal-¯</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<minus></minus>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<ci>T</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<minus></minus>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>T</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{\mathcal{P}^{-}}\equiv e^{-T}\mathcal{P}^{-}e^{T}
  </annotation>
</semantics>
</math>

 is a projection onto the valence sector, and 

<math display="inline" id="Light-front_computational_methods:52">
<semantics>
<mrow>
<mn>1</mn>
<mo>-</mo>
<msub>
<mi>P</mi>
<mi>v</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>v</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1-P_{v}
  </annotation>
</semantics>
</math>

 is the LFCC effective Hamiltonian. The projection 

<math display="inline" id="Light-front_computational_methods:53">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

 is truncated to provide just enough auxiliary equations to determine the functions in the truncated 

<math display="inline" id="Light-front_computational_methods:54">
<semantics>
<mrow>
<mover accent="true">
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>-</mo>
</msup>
<mo>¯</mo>
</mover>
<mo>=</mo>
<mrow>
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>-</mo>
</msup>
<mo>+</mo>
<mrow>
<mo stretchy="false">[</mo>
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>-</mo>
</msup>
<mo>,</mo>
<mi>T</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo>+</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mo stretchy="false">[</mo>
<msup>
<mi class="ltx_font_mathcaligraphic">𝒫</mi>
<mo>-</mo>
</msup>
<mo>,</mo>
<mi>T</mi>
<mo stretchy="false">]</mo>
</mrow>
<mo>,</mo>
<mi>T</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>+</mo>
<mi mathvariant="normal">⋯</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ci>normal-¯</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<minus></minus>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<minus></minus>
</apply>
<interval closure="closed">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<minus></minus>
</apply>
<ci>T</ci>
</interval>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<interval closure="closed">
<interval closure="closed">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>𝒫</ci>
<minus></minus>
</apply>
<ci>T</ci>
</interval>
<ci>T</ci>
</interval>
</apply>
<ci>normal-⋯</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \overline{\mathcal{P}^{-}}=\mathcal{P}^{-}+[\mathcal{P}^{-},T]+\frac{1}{2}[[%
\mathcal{P}^{-},T],T]+\cdots
  </annotation>
</semantics>
</math>

 operator. The effective Hamiltonian is computed from its <a href="Baker-Hausdorff_lemma" title="wikilink">Baker--Hausdorff expansion</a>
<math display="inline" id="Light-front_computational_methods:55">
<semantics>
<mrow>
<mn>1</mn>
<mo>-</mo>
<msub>
<mi>P</mi>
<mi>v</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>v</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1-P_{v}
  </annotation>
</semantics>
</math>

, which can be terminated at the point where more particles are being created than are kept by the truncated projection 

<math display="inline" id="Light-front_computational_methods:56">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

. The use of the exponential of 

<math display="inline" id="Light-front_computational_methods:57">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

 rather than some other function is convenient, not only because of the Baker—Hausdorff expansion but more generally because it is invertible; in principle, other functions could be used and would also provide an exact representation until a truncation is made.</p>

<p>The truncation of 

<math display="inline" id="Light-front_computational_methods:58">
<semantics>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mrow>
<mi>q</mi>
<mover accent="true">
<mi>q</mi>
<mo stretchy="false">¯</mo>
</mover>
<mi>g</mi>
</mrow>
<mo stretchy="false">⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">ket</csymbol>
<apply>
<times></times>
<ci>q</ci>
<apply>
<ci>normal-¯</ci>
<ci>q</ci>
</apply>
<ci>g</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |q\bar{q}g\rangle
  </annotation>
</semantics>
</math>

 can be handled systematically. Terms can be classified by the number of annihilated constituents and the net increase in particle number. For example, in QCD the lowest-order contributions annihilate one particle and increase the total by one. These are one-gluon emission from a quark, quark pair creation from one gluon, and gluon pair creation from one gluon. Each involves a function of relative momentum for the transition from one to two particles. Higher order terms annihilate more particles and/or increase the total by more than one. These provide additional contributions to higher-order wave functions and even to low-order wave functions for more complicated valence states. For example, the wave function for the 

<math display="inline" id="Light-front_computational_methods:59">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

 Fock state of a meson can have a contribution from a term in 

<math display="inline" id="Light-front_computational_methods:60">
<semantics>
<mrow>
<mi>q</mi>
<mover accent="true">
<mi>q</mi>
<mo stretchy="false">¯</mo>
</mover>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>q</ci>
<apply>
<ci>normal-¯</ci>
<ci>q</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   q\bar{q}
  </annotation>
</semantics>
</math>

 that annihilates a 

<math display="inline" id="Light-front_computational_methods:61">
<semantics>
<mrow>
<mo fence="true" stretchy="false">|</mo>
<mrow>
<mi>q</mi>
<mover accent="true">
<mi>q</mi>
<mo stretchy="false">¯</mo>
</mover>
</mrow>
<mo stretchy="false">⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">ket</csymbol>
<apply>
<times></times>
<ci>q</ci>
<apply>
<ci>normal-¯</ci>
<ci>q</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |q\bar{q}\rangle
  </annotation>
</semantics>
</math>

 pair and creates a pair plus a gluon, when this acts on the meson valence state 

<math display="inline" id="Light-front_computational_methods:62">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

.</p>

<p>The mathematics of the LFCC method has its origin in the many-body <a href="coupled_cluster" title="wikilink">coupled cluster</a> method used in <a href="nuclear_physics" title="wikilink">nuclear physics</a> and <a href="quantum_chemistry" title="wikilink">quantum chemistry</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The physics is, however, quite different. The many-body method works with a state of a large number of particles and uses the exponentiation of 

<math display="inline" id="Light-front_computational_methods:63">
<semantics>
<msup>
<mi>e</mi>
<mi>T</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>T</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   e^{T}
  </annotation>
</semantics>
</math>

 to build in correlations of excitations to higher single-particle states; the particle number does not change. The LFCC method starts from a small number of constituents in a valence state and uses 

<math display="inline" id="Light-front_computational_methods:64">
<semantics>
<mrow>
<msub>
<mi>X</mi>
<mi>observable</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>observable</ci>
</apply>
<ci>μ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X_{\rm observable}(\mu)
  </annotation>
</semantics>
</math>

 to build states with more particles; the method of solution of the valence-state eigenvalue problem is left unspecified.</p>

<p>The computation of physical observables from matrix elements of operators requires some care. Direct computation would require an infinite sum over Fock space. One can instead borrow from the many-body coupled cluster method<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> a construction that computes expectation values from right and left eigenstates. This construction can be extended to include <a href="Off-diagonal#Matrices" title="wikilink">off-diagonal</a> matrix elements and gauge projections. Physical quantities can then be computed from the right and left LFCC eigenstates.</p>
<h2 id="renormalization-group">Renormalization group</h2>

<p>Renormalization concepts, especially the <a href="renormalization_group" title="wikilink">renormalization group</a> methods in quantum theories and <a href="statistical_mechanics" title="wikilink">statistical mechanics</a>, have a long history and a very broad scope. The concepts of renormalization that appear useful in theories quantized in the front form of dynamics are essentially of two types, as in other areas of theoretical physics. The two types of concepts are associated with two types of theoretical tasks involved in applications of a theory. One task is to calculate observables (values of operationally defined quantities) in a theory that is unambiguously defined. The other task is to define a theory unambiguously. This is explained below.</p>

<p>Since the front form of dynamics aims at explaining hadrons as bound states of quarks and gluons, and the binding mechanism is not describable using perturbation theory, the definition of a theory needed in this case cannot be limited to perturbative expansions. For example, it is not sufficient to construct a theory using regularization of loop integrals order-by-order and correspondingly redefining the masses, coupling constants, and field normalization constants also order-by-order. In other words, one needs to design the Minkowski space-time formulation of a relativistic theory that is not based on any a priori perturbative scheme. The front form of Hamiltonian dynamics is perceived by many researchers as the most suitable framework for this purpose among the known options.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> <a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>The desired definition of a relativistic theory involves calculations of as many observables as one must use in order to fix all the parameters that appear in the theory. The relationship between the parameters and observables may depend on the number of degrees of freedom that are included in the theory.</p>

<p>For example, consider <a href="virtual_particles" title="wikilink">virtual particles</a> in a candidate formulation of the theory. Formally, special relativity requires that the range of momenta of the particles is infinite because one can change the momentum of a particle by an arbitrary amount through a change of frame of reference. If the formulation is not to distinguish any inertial frame of reference, the particles must be allowed to carry any value of momentum. Since the quantum field modes corresponding to particles with different momenta form different degrees of freedom, the requirement of including infinitely many values of momentum means that one requires the theory to involve infinitely many degrees of freedom. But for mathematical reasons, being forced to use computers for sufficiently precise calculations, one has to work with a finite number of degrees of freedom. One must limit the momentum range by some cutoff.</p>

<p>Setting up a theory with a finite cutoff for mathematical reasons, one hopes that the cutoff can be made sufficiently large to avoid its appearance in observables of physical interest, but in local quantum field theories that are of interest in hadronic physics the situation is not that simple. Namely, particles of different momenta are coupled through the dynamics in a nontrivial way, and the calculations aiming at predicting observables yield results that depend on the cutoffs. Moreover, they do so in a diverging fashion.</p>

<p>There may be more cutoff parameters than just for momentum. For example, one may assume that the volume of space is limited, which would interfere with translation invariance of a theory, or assume that the number of virtual particles is limited, which would interfere with the assumption that every virtual particle may split into more virtual particles. All such restrictions lead to a set of cutoffs that becomes a part of a definition of a theory.</p>

<p>Consequently, every result of a calculation for any observable 

<math display="inline" id="Light-front_computational_methods:65">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

 characterized by its physical scale 

<math display="inline" id="Light-front_computational_methods:66">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

 has the form of a function of the set of parameters of the theory, 

<math display="inline" id="Light-front_computational_methods:67">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

, the set of cutoffs, say 

<math display="inline" id="Light-front_computational_methods:68">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

, and the scale 

<math display="inline" id="Light-front_computational_methods:69">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>X</mi>
<mi>observable</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>X</mi>
<mi>theory</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo>,</mo>
<mi mathvariant="normal">Λ</mi>
<mo>,</mo>
<mi>μ</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>observable</ci>
</apply>
<ci>μ</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>theory</ci>
</apply>
<vector>
<ci>p</ci>
<ci>normal-Λ</ci>
<ci>μ</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X_{\rm observable}(\mu)=X_{\rm theory}(p,\Lambda,\mu)\,.
  </annotation>
</semantics>
</math>

. Thus, the results take the form</p>

<p>
<math display="inline" id="Light-front_computational_methods:70">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>
</p>

<p>However, experiments provide values of observables that characterize natural processes irrespective of the cutoffs in a theory used to explain them. If the cutoffs do not describe properties of nature and are introduced merely for making a theory computable, one needs to understand how the dependence on 

<math display="inline" id="Light-front_computational_methods:71">
<semantics>
<mrow>
<msub>
<mi>X</mi>
<mi>theory</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo>,</mo>
<mi mathvariant="normal">Λ</mi>
<mo>,</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>theory</ci>
</apply>
<vector>
<ci>p</ci>
<ci>normal-Λ</ci>
<ci>μ</ci>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X_{\rm theory}(p,\Lambda,\mu)
  </annotation>
</semantics>
</math>

 may drop out from 

<math display="inline" id="Light-front_computational_methods:72">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

. The cutoffs may also reflect some natural features of a physical system at hand, such as in the model case of an ultraviolet cutoff on the wave vectors of sound waves in a crystal due to the spacing of atoms in the crystal lattice. The natural cutoffs may be of enormous size in comparison to the scale 

<math display="inline" id="Light-front_computational_methods:73">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>


. Then, one faces the question of how it happens in the theory that its results for observables at scale 

<math display="inline" id="Light-front_computational_methods:74">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

 are not also of the enormous size of the cutoff and, if they are not, then how they depend on the scale 

<math display="inline" id="Light-front_computational_methods:75">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

.</p>

<p>The two types of concepts of renormalization mentioned above are associated with the following two questions:</p>
<ul>
<li>How should the parameters 

<math display="inline" id="Light-front_computational_methods:76">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

 depend on the cutoffs 

<math display="inline" id="Light-front_computational_methods:77">
<semantics>
<mrow>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo>,</mo>
<mi mathvariant="normal">Λ</mi>
<mo>,</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>X</ci>
<vector>
<ci>p</ci>
<ci>normal-Λ</ci>
<ci>μ</ci>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X(p,\Lambda,\mu)
  </annotation>
</semantics>
</math>

 so that all observables 

<math display="inline" id="Light-front_computational_methods:78">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>


 of physical interest do not depend on 

<math display="inline" id="Light-front_computational_methods:79">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

, including the case where one removes the cutoffs by sending them formally to infinity?</li>
</ul>
<ul>
<li>What is the required set of parameters 

<math display="inline" id="Light-front_computational_methods:80">
<semantics>
<mrow>
<mi>X</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo>,</mo>
<mi mathvariant="normal">Λ</mi>
<mo>,</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>X</ci>
<vector>
<ci>p</ci>
<ci>normal-Λ</ci>
<ci>μ</ci>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X(p,\Lambda,\mu)
  </annotation>
</semantics>
</math>

?</li>
</ul>

<p>The renormalization group concept associated with the first question<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> <a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> predates the concept associated with the second question.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> <a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> <a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> <a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> Certainly, if one were in possession of a good answer to the second question, the first question could also be answered. In the absence of a good answer to the second question, one may wonder why any specific choice of parameters and their cutoff dependence could secure cutoff independence of all observables 

<math display="inline" id="Light-front_computational_methods:81">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

 with finite scales 

<math display="inline" id="Light-front_computational_methods:82">
<semantics>
<mrow>
<mi>p</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Λ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>p</ci>
<ci>normal-Λ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p(\Lambda)
  </annotation>
</semantics>
</math>

.</p>

<p>The renormalization group concept associated with the first question above relies on the circumstance that some finite set 

<math display="inline" id="Light-front_computational_methods:83">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>X</mi>
<mi>observable</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mo>lim</mo>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</msub>
<mrow>
<msub>
<mi>X</mi>
<mi>theory</mi>
</msub>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>p</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Λ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">Λ</mi>
<mo>,</mo>
<mi>μ</mi>
<mo rspace="4.2pt" stretchy="false">]</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>observable</ci>
</apply>
<ci>μ</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>normal-Λ</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>theory</ci>
</apply>
<list>
<apply>
<times></times>
<ci>p</ci>
<ci>normal-Λ</ci>
</apply>
<ci>normal-Λ</ci>
<ci>μ</ci>
</list>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   X_{\rm observable}(\mu)=\lim_{\Lambda\rightarrow\infty}X_{\rm theory}[p(%
\Lambda),\Lambda,\mu]\,.
  </annotation>
</semantics>
</math>

 yields the desired result,</p>

<p>
<math display="inline" id="Light-front_computational_methods:84">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>
</p>

<p>In this way of thinking, one can expect that in a theory with 

<math display="inline" id="Light-front_computational_methods:85">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

 parameters a calculation of 

<math display="inline" id="Light-front_computational_methods:86">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

 observables at some scale 

<math display="inline" id="Light-front_computational_methods:87">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

 is sufficient to fix all parameters as functions of 

<math display="inline" id="Light-front_computational_methods:88">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

. So, one may hope that there exists a collection of 

<math display="inline" id="Light-front_computational_methods:89">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

 effective parameters at scale 

<math display="inline" id="Light-front_computational_methods:90">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

, corresponding to 

<math display="inline" id="Light-front_computational_methods:91">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

 observables at scale 

<math display="inline" id="Light-front_computational_methods:92">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

, that are sufficient to parametrize the theory in such a way that predictions expressed in terms of these parameters are free from dependence on 

<math display="inline" id="Light-front_computational_methods:93">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

. Since the scale 

<math display="inline" id="Light-front_computational_methods:94">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

 is arbitrary, a whole family of such 

<math display="inline" id="Light-front_computational_methods:95">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

-parameter sets labeled by 

<math display="inline" id="Light-front_computational_methods:96">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

 should exist, and every member of that family corresponds to the same physics. Moving from one such family to another by changing one value of 

<math display="inline" id="Light-front_computational_methods:97">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

 to another is described as action of ``the renormalization group.'' The word group is justified because the group axioms are satisfied: two such changes form another such change, one can invert a change, etc.</p>

<p>The question remains, however, why fixing the cutoff dependence of 

<math display="inline" id="Light-front_computational_methods:98">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

 parameters 

<math display="inline" id="Light-front_computational_methods:99">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

 on 

<math display="inline" id="Light-front_computational_methods:100">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

, using 

<math display="inline" id="Light-front_computational_methods:101">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

 conditions that 

<math display="inline" id="Light-front_computational_methods:102">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

 selected observables do not depend on 

<math display="inline" id="Light-front_computational_methods:103">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

, is good enough to make all observables in the physical range of 

<math display="inline" id="Light-front_computational_methods:104">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

 not depend on 

<math display="inline" id="Light-front_computational_methods:105">
<semantics>
<mrow>
<mi>p</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Λ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>p</ci>
<ci>normal-Λ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p(\Lambda)
  </annotation>
</semantics>
</math>

. In some theories such a miracle may happen but in others it may not. The ones where it happens are called renormalizable, because one can normalize the parameters properly to obtain cutoff independent results.</p>

<p>Typically, the set 

<math display="inline" id="Light-front_computational_methods:106">
<semantics>
<mrow>
<mi>p</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Λ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>p</ci>
<ci>normal-Λ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p(\Lambda)
  </annotation>
</semantics>
</math>

 is established using perturbative calculations that are combined with models for description of nonperturbative effects. For example, perturbative QCD diagrams for quarks and gluons are combined with the parton models for description of binding of quarks and gluons into hadrons. The set of parameters 

<math display="inline" id="Light-front_computational_methods:107">
<semantics>
<mrow>
<mi>p</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Λ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>p</ci>
<ci>normal-Λ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p(\Lambda)
  </annotation>
</semantics>
</math>

 includes cutoff dependent masses, charges and field normalization constants. The predictive power of a theory set up this way relies on the circumstance that the required set of parameters is relatively small. The regularization is designed order-by-order so that as many formal symmetries as possible of a local theory are preserved and employed in calculations, as in the dimensional regularization of Feynman diagrams. The claim that the set of parameters 

<math display="inline" id="Light-front_computational_methods:108">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

 leads to finite, cutoff independent limits for all observables is qualified by the need to use some form of perturbation theory and inclusion of model assumptions concerning bound states.</p>

<p>The renormalization group concept associated with the second question above is conceived to explain how it may be so that the concept of renormalization group associated with the first question can make sense, instead of being at best a successful recipe to deal with divergences in perturbative calculations.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> Namely, to answer the second question, one designs a calculation (see below) that identifies the required set of parameters to define the theory, the starting point being some specific initial assumption, such as some local Lagrangian density which is a function of field variables and needs to be modified by including all the required parameters. Once the required set of parameters is known, one can establish a set of observables that are sufficient to define the cutoff dependence of the required set. The observables can have any finite scale 

<math display="inline" id="Light-front_computational_methods:109">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

, and one can use any scale 

<math display="inline" id="Light-front_computational_methods:110">
<semantics>
<mrow>
<mi>p</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Λ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>p</ci>
<ci>normal-Λ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p(\Lambda)
  </annotation>
</semantics>
</math>

 to define the parameters 

<math display="inline" id="Light-front_computational_methods:111">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

, up to their finite parts that must be fitted to experiment, including features such as the observed symmetries.</p>

<p>Thus, not only the possibility that a renormalization group of the first type may exist can be understood, but also the alternative situations are found where the set of required cutoff dependent parameters does not have to be finite. Predictive power of latter theories results from known relationships among the required parameters and options to establish all the relevant ones.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>

<p>The renormalization group concept of the second kind is associated with the nature of the mathematical computation used to discover the set of parameters 

<math display="inline" id="Light-front_computational_methods:112">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

. In its essence, the calculation starts with some specific form of a theory with cutoff 

<math display="inline" id="Light-front_computational_methods:113">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda/2
  </annotation>
</semantics>
</math>

 and derives a corresponding theory with a smaller cutoff, in the sense of more restrictive, say 

<math display="inline" id="Light-front_computational_methods:114">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

. After re-parameterization using the cutoff as a unit, one obtains a new theory of similar type but with new terms. This means that the starting theory with cutoff 

<math display="inline" id="Light-front_computational_methods:115">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

 should also contain such new terms for its form to be consistent with the presence of a cutoff. Eventually, one can find a set of terms that reproduces itself up to changes in the coefficients of the required terms. These coefficients evolve with the number of steps one makes, in each and every step reducing the cutoff by factor of two and rescaling variables. One could use other factors than two, but two is convenient.</p>

<p>In summary, one obtains a trajectory of a point in a space of dimension equal to the number of required parameters and motion along the trajectory is described by transformations that form new kind of a group. Different initial points might lead to different trajectories, but if the steps are self-similar and reduce to a multiple action of one and the same transformation, say 

<math display="inline" id="Light-front_computational_methods:116">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

, one may describe what happens in terms of the features of 

<math display="inline" id="Light-front_computational_methods:117">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

, called the renormalization group transformation. The transformation 

<math display="inline" id="Light-front_computational_methods:118">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

 may transform points in the parameter space making some of the parameters decrease, some grow, and some stay unchanged. It may have <a href="Fixed_point_(mathematics)" title="wikilink">fixed points</a>, <a href="limit_cycles" title="wikilink">limit cycles</a>, or even lead to <a href="chaotic_motion" title="wikilink">chaotic motion</a>.</p>

<p>Suppose that 

<math display="inline" id="Light-front_computational_methods:119">
<semantics>
<msup>
<mi>x</mi>
<mo>-</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<minus></minus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x^{-}
  </annotation>
</semantics>
</math>

 has a fixed point. If one starts the procedure at this point, an infinitely long sequence of reductions of the cutoff by factors of two changes nothing in the structure of the theory, except the scale of its cutoff. This means that the initial cutoff can be arbitrarily large. Such a theory may possess the symmetries of special relativity, since there is no price to pay for extending the cutoff as required when one wishes to make the Lorentz transformation that yields momenta which exceed the cutoff.</p>

<p>Both concepts of the renormalization group can be considered in quantum theories constructed using the front form of dynamics. The first concept allows one to play with a small set of parameters and seek consistency, which is a useful strategy in perturbation theory if one knows from other approaches what to expect. In particular, one may study new perturbative features that appear in the front form of dynamics, since it differs from the instant form. The main difference is that the front variables 

<math display="inline" id="Light-front_computational_methods:120">
<semantics>
<msup>
<mi>p</mi>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>p</ci>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p^{+}
  </annotation>
</semantics>
</math>

 (or 

<math display="inline" id="Light-front_computational_methods:121">
<semantics>
<msup>
<mi>x</mi>
<mo>⟂</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x^{\perp}
  </annotation>
</semantics>
</math>

) are considerably different from the transverse variables 

<math display="inline" id="Light-front_computational_methods:122">
<semantics>
<msup>
<mi>p</mi>
<mo>⟂</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>p</ci>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p^{\perp}
  </annotation>
</semantics>
</math>

 (or 

<math display="inline" id="Light-front_computational_methods:123">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

), so that there is no simple rotational symmetry among them.</p>

<p>One can also study sufficiently simplified models for which computers can be used to carry out calculations and see if a procedure suggested by perturbation theory may work beyond it. The second concept allows one to address the issue of defining a relativistic theory ab initio without limiting the definition to perturbative expansions. This option is particularly relevant to the issue of describing bound states in QCD. However, to address this issue one needs to overcome certain difficulties that the renormalization group procedures based on the idea of reduction of cutoffs are not capable of easily resolving. To avoid the difficulties, one can employ the similarity renormalization group procedure. Both the difficulties and similarity are explained in the next section.</p>
<h2 id="similarity-transformations">Similarity transformations</h2>

<p>A glimpse of the difficulties of the procedure of reducing a cutoff 

<math display="inline" id="Light-front_computational_methods:124">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda/2
  </annotation>
</semantics>
</math>

 to cutoff 

<math display="inline" id="Light-front_computational_methods:125">
<semantics>
<mi>H</mi>
<annotation-xml encoding="MathML-Content">
<ci>H</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   H
  </annotation>
</semantics>
</math>

 in the front form of Hamiltonian dynamics of strong interactions can be gained by considering the eigenvalue problem for the Hamiltonian 

<math display="inline" id="Light-front_computational_methods:126">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>H</mi>
<mi>ψ</mi>
</mrow>
<mo>=</mo>
<mrow>
<mi>E</mi>
<mi>ψ</mi>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>H</ci>
<ci>ψ</ci>
</apply>
<apply>
<times></times>
<ci>E</ci>
<ci>ψ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H\psi=E\psi,
  </annotation>
</semantics>
</math>

,</p>

<p>
<math display="inline" id="Light-front_computational_methods:127">
<semantics>
<mrow>
<mi>H</mi>
<mo>=</mo>
<mrow>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<mo>+</mo>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>H</ci>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H=H_{0}+H_{I}
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Light-front_computational_methods:128">
<semantics>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Light-front_computational_methods:129">
<semantics>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{I}
  </annotation>
</semantics>
</math>

 has a known spectrum and 

<math display="inline" id="Light-front_computational_methods:130">
<semantics>
<mi>ψ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ψ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi
  </annotation>
</semantics>
</math>

 describes the interactions. Let us assume that the eigenstate 

<math display="inline" id="Light-front_computational_methods:131">
<semantics>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}
  </annotation>
</semantics>
</math>

 can be written as a superposition of eigenstates of 

<math display="inline" id="Light-front_computational_methods:132">
<semantics>
<mi>P</mi>
<annotation-xml encoding="MathML-Content">
<ci>P</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   P
  </annotation>
</semantics>
</math>

 and let us introduce two projection operators, 

<math display="inline" id="Light-front_computational_methods:133">
<semantics>
<mi>Q</mi>
<annotation-xml encoding="MathML-Content">
<ci>Q</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Light-front_computational_methods:134">
<semantics>
<mi>P</mi>
<annotation-xml encoding="MathML-Content">
<ci>P</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   P
  </annotation>
</semantics>
</math>

, such that 

<math display="inline" id="Light-front_computational_methods:135">
<semantics>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}
  </annotation>
</semantics>
</math>

 projects on eigenstates of 

<math display="inline" id="Light-front_computational_methods:136">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda/2
  </annotation>
</semantics>
</math>

 with <a href="Eigenvalues_and_eigenvectors" title="wikilink">eigenvalues</a> smaller than 

<math display="inline" id="Light-front_computational_methods:137">
<semantics>
<mi>Q</mi>
<annotation-xml encoding="MathML-Content">
<ci>Q</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Light-front_computational_methods:138">
<semantics>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}
  </annotation>
</semantics>
</math>

 projects on eigenstates of 

<math display="inline" id="Light-front_computational_methods:139">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda/2
  </annotation>
</semantics>
</math>

 with eigenvalues between 

<math display="inline" id="Light-front_computational_methods:140">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Light-front_computational_methods:141">
<semantics>
<mi>H</mi>
<annotation-xml encoding="MathML-Content">
<ci>H</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   H
  </annotation>
</semantics>
</math>

. The result of projecting the eigenvalue problem for 

<math display="inline" id="Light-front_computational_methods:142">
<semantics>
<mi>P</mi>
<annotation-xml encoding="MathML-Content">
<ci>P</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   P
  </annotation>
</semantics>
</math>

 using 

<math display="inline" id="Light-front_computational_methods:143">
<semantics>
<mi>Q</mi>
<annotation-xml encoding="MathML-Content">
<ci>Q</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Light-front_computational_methods:144">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<mi>Q</mi>
<mi>ψ</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>Q</mi>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<mi>Q</mi>
<mi>ψ</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>Q</mi>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<mi>P</mi>
<mi>ψ</mi>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>E</mi>
<mi>Q</mi>
<mpadded width="+1.7pt">
<mi>ψ</mi>
</mpadded>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
<ci>Q</ci>
<ci>ψ</ci>
</apply>
<apply>
<times></times>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
<ci>Q</ci>
<ci>ψ</ci>
</apply>
<apply>
<times></times>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
<ci>P</ci>
<ci>ψ</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>E</ci>
<ci>Q</ci>
<ci>ψ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}Q\psi+QH_{I}Q\psi+QH_{I}P\psi=EQ\psi\,,
  </annotation>
</semantics>
</math>

 is a set of two coupled equations</p>

<p>
<math display="inline" id="Light-front_computational_methods:145">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<mi>P</mi>
<mi>ψ</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>P</mi>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<mi>Q</mi>
<mi>ψ</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>P</mi>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<mi>P</mi>
<mi>ψ</mi>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>E</mi>
<mi>P</mi>
<mpadded width="+1.7pt">
<mi>ψ</mi>
</mpadded>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
<ci>P</ci>
<ci>ψ</ci>
</apply>
<apply>
<times></times>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
<ci>Q</ci>
<ci>ψ</ci>
</apply>
<apply>
<times></times>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
<ci>P</ci>
<ci>ψ</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>E</ci>
<ci>P</ci>
<ci>ψ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}P\psi+PH_{I}Q\psi+PH_{I}P\psi=EP\psi\,.
  </annotation>
</semantics>
</math>
<math display="inline" id="Light-front_computational_methods:146">
<semantics>
<mrow>
<mi>Q</mi>
<mi>ψ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>Q</ci>
<ci>ψ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q\psi
  </annotation>
</semantics>
</math>
</p>

<p>The first equation can be used to evaluate 

<math display="inline" id="Light-front_computational_methods:147">
<semantics>
<mrow>
<mi>P</mi>
<mi>ψ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>P</ci>
<ci>ψ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P\psi
  </annotation>
</semantics>
</math>

 in terms of 

<math display="inline" id="Light-front_computational_methods:148">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>Q</mi>
<mi>ψ</mi>
</mrow>
<mo>=</mo>
<mrow>
<mpadded width="+5pt">
<mfrac>
<mn>1</mn>
<mrow>
<mi>E</mi>
<mo>-</mo>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<mo>-</mo>
<mrow>
<mi>Q</mi>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<mi>Q</mi>
</mrow>
</mrow>
</mfrac>
</mpadded>
<mi>Q</mi>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<mi>P</mi>
<mpadded width="+1.7pt">
<mi>ψ</mi>
</mpadded>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>Q</ci>
<ci>ψ</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<minus></minus>
<ci>E</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<times></times>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
<ci>Q</ci>
</apply>
</apply>
</apply>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
<ci>P</ci>
<ci>ψ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q\psi=\frac{1}{E-H_{0}-QH_{I}Q}\ QH_{I}P\psi\,.
  </annotation>
</semantics>
</math>

,</p>

<p>
<math display="inline" id="Light-front_computational_methods:149">
<semantics>
<mrow>
<mi>P</mi>
<mi>ψ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>P</ci>
<ci>ψ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P\psi
  </annotation>
</semantics>
</math>
</p>

<p>This expression allows one to write an equation for 

<math display="inline" id="Light-front_computational_methods:150">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>H</mi>
<mi>eff</mi>
</msub>
<mi>P</mi>
<mi>ψ</mi>
</mrow>
<mo>=</mo>
<mrow>
<mi>E</mi>
<mi>P</mi>
<mpadded width="+1.7pt">
<mi>ψ</mi>
</mpadded>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>eff</ci>
</apply>
<ci>P</ci>
<ci>ψ</ci>
</apply>
<apply>
<times></times>
<ci>E</ci>
<ci>P</ci>
<ci>ψ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{\rm eff}P\psi=EP\psi\,,
  </annotation>
</semantics>
</math>

 in the form</p>

<p>
<math display="inline" id="Light-front_computational_methods:151">
<semantics>
<mrow>
<mrow>
<msub>
<mi>H</mi>
<mi>eff</mi>
</msub>
<mo>=</mo>
<mrow>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<mo>+</mo>
<mrow>
<mi>P</mi>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<mi>P</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>P</mi>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<mi>Q</mi>
<mfrac>
<mn>1</mn>
<mrow>
<mi>E</mi>
<mo>-</mo>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<mo>-</mo>
<mrow>
<mi>Q</mi>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<mi>Q</mi>
</mrow>
</mrow>
</mfrac>
<mi>Q</mi>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<mi>P</mi>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>eff</ci>
</apply>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<times></times>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
<ci>P</ci>
</apply>
<apply>
<times></times>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
<ci>Q</ci>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<minus></minus>
<ci>E</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<times></times>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
<ci>Q</ci>
</apply>
</apply>
</apply>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
<ci>P</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{\rm eff}=H_{0}+PH_{I}P+PH_{I}Q\frac{1}{E-H_{0}-QH_{I}Q}QH_{I}P.
  </annotation>
</semantics>
</math>
</p>

<p>where</p>

<p>
<math display="inline" id="Light-front_computational_methods:152">
<semantics>
<mrow>
<mi>P</mi>
<mi>ψ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>P</ci>
<ci>ψ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   P\psi
  </annotation>
</semantics>
</math>
</p>

<p>The equation for 

<math display="inline" id="Light-front_computational_methods:153">
<semantics>
<msub>
<mi>H</mi>
<mi>eff</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>eff</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{\rm eff}
  </annotation>
</semantics>
</math>

 appears to resemble an eigenvalue problem for 

<math display="inline" id="Light-front_computational_methods:154">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda/2
  </annotation>
</semantics>
</math>


. It is valid in a theory with cutoff 

<math display="inline" id="Light-front_computational_methods:155">
<semantics>
<msub>
<mi>H</mi>
<mi>eff</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>eff</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{\rm eff}
  </annotation>
</semantics>
</math>

, but its effective ``Hamiltonian'' 

<math display="inline" id="Light-front_computational_methods:156">
<semantics>
<mi>E</mi>
<annotation-xml encoding="MathML-Content">
<ci>E</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   E
  </annotation>
</semantics>
</math>

 depends on the unknown eigenvalue 

<math display="inline" id="Light-front_computational_methods:157">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda/2
  </annotation>
</semantics>
</math>

. However, if 

<math display="inline" id="Light-front_computational_methods:158">
<semantics>
<mi>E</mi>
<annotation-xml encoding="MathML-Content">
<ci>E</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   E
  </annotation>
</semantics>
</math>

 is much greater than 

<math display="inline" id="Light-front_computational_methods:159">
<semantics>
<mi>E</mi>
<annotation-xml encoding="MathML-Content">
<ci>E</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   E
  </annotation>
</semantics>
</math>


 of interest, one can neglect 

<math display="inline" id="Light-front_computational_methods:160">
<semantics>
<mrow>
<mi>Q</mi>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<mi>Q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
<ci>Q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   QH_{0}Q
  </annotation>
</semantics>
</math>

 in comparison to 

<math display="inline" id="Light-front_computational_methods:161">
<semantics>
<mrow>
<mi>Q</mi>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<mi>Q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
<ci>Q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   QH_{I}Q
  </annotation>
</semantics>
</math>

 provided that 

<math display="inline" id="Light-front_computational_methods:162">
<semantics>
<mrow>
<mi>Q</mi>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<mi>Q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
<ci>Q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   QH_{0}Q
  </annotation>
</semantics>
</math>

 is small in comparison to 

<math display="inline" id="Light-front_computational_methods:163">
<semantics>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}
  </annotation>
</semantics>
</math>

.</p>

<p>In QCD, which is <a href="Asymptotic_freedom" title="wikilink">asymptotically free</a>, one indeed has 

<math display="inline" id="Light-front_computational_methods:164">
<semantics>
<msub>
<mi>H</mi>
<mi>eff</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>eff</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{\rm eff}
  </annotation>
</semantics>
</math>


 as the dominant term in the energy denominator in 

<math display="inline" id="Light-front_computational_methods:165">
<semantics>
<mi>E</mi>
<annotation-xml encoding="MathML-Content">
<ci>E</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   E
  </annotation>
</semantics>
</math>

 for small eigenvalues 

<math display="inline" id="Light-front_computational_methods:166">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

. In practice, this happens for cutoffs 

<math display="inline" id="Light-front_computational_methods:167">
<semantics>
<mi>E</mi>
<annotation-xml encoding="MathML-Content">
<ci>E</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   E
  </annotation>
</semantics>
</math>

 so much larger than the smallest eigenvalues 

<math display="inline" id="Light-front_computational_methods:168">
<semantics>
<mi>Q</mi>
<annotation-xml encoding="MathML-Content">
<ci>Q</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q
  </annotation>
</semantics>
</math>

 of physical interest that the corresponding eigenvalue problems are too complex for solving them with required precision. Namely, there are still too many degrees of freedom. One needs to reduce cutoffs considerably further. This issue appears in all approaches to the bound state problem in QCD, not only in the front form of the dynamics.</p>

<p>Even if interactions are sufficiently small, one faces an additional difficulty with eliminating 

<math display="inline" id="Light-front_computational_methods:169">
<semantics>
<mi>E</mi>
<annotation-xml encoding="MathML-Content">
<ci>E</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   E
  </annotation>
</semantics>
</math>


-states. Namely, for small interactions one can eliminate the eigenvalue 

<math display="inline" id="Light-front_computational_methods:170">
<semantics>
<mi>P</mi>
<annotation-xml encoding="MathML-Content">
<ci>P</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   P
  </annotation>
</semantics>
</math>

 from a proper effective Hamiltonian in 

<math display="inline" id="Light-front_computational_methods:171">
<semantics>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}
  </annotation>
</semantics>
</math>

-subspace in favor of eigenvalues of 

<math display="inline" id="Light-front_computational_methods:172">
<semantics>
<msub>
<mi>H</mi>
<mi>eff</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>eff</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{\rm eff}
  </annotation>
</semantics>
</math>

. Consequently, the denominators analogous to the one that appears above in 

<math display="inline" id="Light-front_computational_methods:173">
<semantics>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}
  </annotation>
</semantics>
</math>

 only contain differences of eigenvalues of 

<math display="inline" id="Light-front_computational_methods:174">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda/2
  </annotation>
</semantics>
</math>


, one above 

<math display="inline" id="Light-front_computational_methods:175">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda/2
  </annotation>
</semantics>
</math>

 and one below.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> Unfortunately, such differences can become arbitrarily small near the cutoff 

<math display="inline" id="Light-front_computational_methods:176">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda/2
  </annotation>
</semantics>
</math>

, and they generate strong interactions in the effective theory due to the coupling between the states just below and just above the cutoff 

<math display="inline" id="Light-front_computational_methods:177">
<semantics>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}
  </annotation>
</semantics>
</math>

. This is particularly bothersome when the eigenstates of 

<math display="inline" id="Light-front_computational_methods:178">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

 near the cutoff are highly degenerate and splitting of the bound state problem into parts below and above the cutoff cannot be accomplished through any simple expansion in powers of the coupling constant.</p>

<p>In any case, when one reduces the cutoff 

<math display="inline" id="Light-front_computational_methods:179">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda/2
  </annotation>
</semantics>
</math>


 to 

<math display="inline" id="Light-front_computational_methods:180">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>normal-Λ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda/2
  </annotation>
</semantics>
</math>

, and then 

<math display="inline" id="Light-front_computational_methods:181">
<semantics>
<mrow>
<mi mathvariant="normal">Λ</mi>
<mo>/</mo>
<mn>4</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>normal-Λ</ci>
<cn type="integer">4</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda/4
  </annotation>
</semantics>
</math>

 to 

<math display="inline" id="Light-front_computational_methods:182">
<semantics>
<mrow>
<mi>Q</mi>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<mi>Q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>Q</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
<ci>Q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   QH_{I}Q
  </annotation>
</semantics>
</math>

 and so on, the strength of interaction in QCD Hamiltonians increases and, especially if the interaction is attractive, 

<math display="inline" id="Light-front_computational_methods:183">
<semantics>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}
  </annotation>
</semantics>
</math>

 can cancel 

<math display="inline" id="Light-front_computational_methods:184">
<semantics>
<mi>E</mi>
<annotation-xml encoding="MathML-Content">
<ci>E</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   E
  </annotation>
</semantics>
</math>


 and 

<math display="inline" id="Light-front_computational_methods:185">
<semantics>
<mi>E</mi>
<annotation-xml encoding="MathML-Content">
<ci>E</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   E
  </annotation>
</semantics>
</math>

 cannot be ignored no matter how small it is in comparison to the reduced cutoff. In particular, this difficulty concerns bound states, where interactions must prevent free relative motion of constituents from dominating the scene and a spatially compact systems have to be formed. So far, it appears not possible to precisely eliminate the eigenvalue 

<math display="inline" id="Light-front_computational_methods:186">
<semantics>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}
  </annotation>
</semantics>
</math>

 from the effective dynamics obtained by projecting on sufficiently low energy eigenstates of 

<math display="inline" id="Light-front_computational_methods:187">
<semantics>
<msub>
<mi>H</mi>
<mi>I</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>I</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{I}
  </annotation>
</semantics>
</math>

 to facilitate reliable calculations.</p>

<p>Fortunately, one can use instead a change of basis.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> Namely, it is possible to define a procedure in which the basis states are rotated in such a way that the matrix elements of 

<math display="inline" id="Light-front_computational_methods:188">
<semantics>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}
  </annotation>
</semantics>
</math>

 vanish between basis states that according to 

<math display="inline" id="Light-front_computational_methods:189">
<semantics>
<mi>λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda
  </annotation>
</semantics>
</math>


 differ in energy by more than a running cutoff, say 

<math display="inline" id="Light-front_computational_methods:190">
<semantics>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{0}
  </annotation>
</semantics>
</math>

. The running cutoff is called the energy bandwidth. The name comes from the <a href="Bandwidth_(linear_algebra)" title="wikilink">band-diagonal</a> form of the Hamiltonian matrix in the new basis ordered in energy using 

<math display="inline" id="Light-front_computational_methods:191">
<semantics>
<mi>λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda
  </annotation>
</semantics>
</math>

. Different values of the running cutoff 

<math display="inline" id="Light-front_computational_methods:192">
<semantics>
<mi>E</mi>
<annotation-xml encoding="MathML-Content">
<ci>E</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   E
  </annotation>
</semantics>
</math>

 correspond to using differently rotated basis states. The rotation is designed not to depend at all on the eigenvalues 

<math display="inline" id="Light-front_computational_methods:193">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

 one wants to compute.</p>

<p>As a result, one obtains in the rotated basis an effective Hamiltonian matrix eigenvalue problem in which the dependence on cutoff 

<math display="inline" id="Light-front_computational_methods:194">
<semantics>
<msub>
<mi>H</mi>
<mi>eff</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>eff</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{\rm eff}
  </annotation>
</semantics>
</math>


 may manifest itself only in the explicit dependence of matrix elements of the new 

<math display="inline" id="Light-front_computational_methods:195">
<semantics>
<mi mathvariant="normal">Λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Lambda
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> The two features of similarity that (1) the 

<math display="inline" id="Light-front_computational_methods:196">
<semantics>
<msub>
<mi>H</mi>
<mi>eff</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>eff</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{\rm eff}
  </annotation>
</semantics>
</math>

-dependence becomes explicit before one tackles the problem of solving the eigenvalue problem for 

<math display="inline" id="Light-front_computational_methods:197">
<semantics>
<mi>λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda
  </annotation>
</semantics>
</math>

 and (2) the effective Hamiltonian with small energy bandwidth may not depend on the eigenvalues one tries to find, allow one to discover in advance the required counterterms to the diverging cutoff dependence. A complete set of counterterms defines the set of parameters required for defining the theory which has a finite energy bandwidth 

<math display="inline" id="Light-front_computational_methods:198">
<semantics>
<mi>λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda
  </annotation>
</semantics>
</math>

 and no cutoff dependence in the band. In the course of discovering the counterterms and corresponding parameters, one keeps changing the initial Hamiltonian. Eventually, the complete Hamiltonian may have cutoff independent eigenvalues, including bound states.</p>

<p>In the case of the front-form Hamiltonian for QCD, a perturbative version of the similarity renormalization group procedure is outlined by Wilson et al.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> Further discussion of computational methods stemming from the similarity renormalization group concept is provided in the next section.</p>
<h2 id="renormalization-group-procedure-for-effective-particles">Renormalization group procedure for effective particles</h2>

<p>The similarity renormalization group procedure, discussed in <a href="#Similarity_transformations" title="wikilink">#Similarity transformations</a>, can be applied to the problem of describing bound states of quarks and gluons using QCD according to the general computational scheme outlined by Wilson et al.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> and illustrated in a numerically soluble model by Glazek and Wilson.<ref name="Glazek-Wilson3">{{ cite journal | author=S. D. Glazek, K. G. Wilson title=Asymptotic freedom and bound states in Hamiltonian dynamics | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 57 | pages= 3558–3566 | year=1998 | doi= 10.1103/PhysRevD.57.3558</ref></p>

<p><code>| title=Asymptotic freedom and bound states in Hamiltonian dynamics}}</code></p>

<p>Since these works were completed, the method has been applied to various physical systems using a weak-coupling expansion. More recently, similarity has evolved into a computational tool called the renormalization group procedure for effective particles, or RGPEP. In principle, the RGPEP is now defined without a need to refer to some perturbative expansion. The most recent explanation of the RGPEP is given by Glazek in terms of an elementary and exactly solvable model for relativistic fermions that interact through a mass mixing term of arbitrary strength in their Hamiltonian.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>

<p>The effective particles can be seen as resulting from a dynamical transformation akin to the Melosh transformation from current to constituent quarks.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> Namely, the RGPEP transformation changes the bare quanta in a canonical theory to the effective quanta in an equivalent <a href="effective_theory" title="wikilink">effective theory</a> with a Hamiltonian that has the energy bandwidth 

<math display="inline" id="Light-front_computational_methods:199">
<semantics>
<mi>λ</mi>
<annotation-xml encoding="MathML-Content">
<ci>λ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda
  </annotation>
</semantics>
</math>


; see <a href="#Similarity_transformations" title="wikilink">#Similarity transformations</a> and references therein for an explanation of the band. The transformations that change 

<math display="inline" id="Light-front_computational_methods:200">
<semantics>
<mrow>
<mrow>
<msub>
<mi>ψ</mi>
<mi>s</mi>
</msub>
<mo>=</mo>
<mrow>
<mpadded width="+1.7pt">
<msub>
<mi>U</mi>
<mi>s</mi>
</msub>
</mpadded>
<mpadded width="+1.7pt">
<msub>
<mi>ψ</mi>
<mn>0</mn>
</msub>
</mpadded>
<mpadded width="+1.7pt">
<msubsup>
<mi>U</mi>
<mi>s</mi>
<mo>†</mo>
</msubsup>
</mpadded>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>s</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>U</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>U</ci>
<ci>s</ci>
</apply>
<ci>normal-†</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{s}=U_{s}\,\psi_{0}\,U_{s}^{\dagger}\,,
  </annotation>
</semantics>
</math>

 form a group.</p>

<p>The effective particles are introduced through a transformation</p>

<p>
<math display="inline" id="Light-front_computational_methods:201">
<semantics>
<msub>
<mi>ψ</mi>
<mi>s</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{s}
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Light-front_computational_methods:202">
<semantics>
<mrow>
<mi>s</mi>
<mo>∼</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mi>λ</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">similar-to</csymbol>
<ci>s</ci>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>λ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   s\sim 1/\lambda
  </annotation>
</semantics>
</math>

 is a quantum field operator built from creation and annihilation operators for effective particles of size 

<math display="inline" id="Light-front_computational_methods:203">
<semantics>
<msub>
<mi>ψ</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{0}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Light-front_computational_methods:204">
<semantics>
<msub>
<mi>ψ</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{0}
  </annotation>
</semantics>
</math>


 is the original quantum field operator built from creation and annihilation operators for point-like bare quanta of a canonical theory. In great brevity, a canonical Hamiltonian density is built from fields 

<math display="inline" id="Light-front_computational_methods:205">
<semantics>
<mi>s</mi>
<annotation-xml encoding="MathML-Content">
<ci>s</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   s
  </annotation>
</semantics>
</math>

 and the effective Hamiltonian at scale 

<math display="inline" id="Light-front_computational_methods:206">
<semantics>
<msub>
<mi>ψ</mi>
<mi>s</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{s}
  </annotation>
</semantics>
</math>

 is built from fields 

<math display="inline" id="Light-front_computational_methods:207">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>H</mi>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>ψ</mi>
<mi>s</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>ψ</mi>
<mn>0</mn>
</msub>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>s</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{s}(\psi_{s})=H_{0}(\psi_{0})\,,
  </annotation>
</semantics>
</math>

, but without actually changing the Hamiltonian. Thus,</p>

<p>
<math display="inline" id="Light-front_computational_methods:208">
<semantics>
<mi>s</mi>
<annotation-xml encoding="MathML-Content">
<ci>s</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   s
  </annotation>
</semantics>
</math>
</p>

<p>which means that the same dynamics is expressed in terms of different operators for different values of 

<math display="inline" id="Light-front_computational_methods:209">
<semantics>
<msub>
<mi>c</mi>
<mi>s</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   c_{s}
  </annotation>
</semantics>
</math>


. The coefficients 

<math display="inline" id="Light-front_computational_methods:210">
<semantics>
<msub>
<mi>ψ</mi>
<mi>s</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{s}
  </annotation>
</semantics>
</math>

 in the expansion of a Hamiltonian in powers of the field operators 

<math display="inline" id="Light-front_computational_methods:211">
<semantics>
<mi>s</mi>
<annotation-xml encoding="MathML-Content">
<ci>s</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   s
  </annotation>
</semantics>
</math>

 depend on 

<math display="inline" id="Light-front_computational_methods:212">
<semantics>
<mi>s</mi>
<annotation-xml encoding="MathML-Content">
<ci>s</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   s
  </annotation>
</semantics>
</math>

 and the field operators depend on 

<math display="inline" id="Light-front_computational_methods:213">
<semantics>
<mi>s</mi>
<annotation-xml encoding="MathML-Content">
<ci>s</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   s
  </annotation>
</semantics>
</math>

, but the Hamiltonian is not changing with 

<math display="inline" id="Light-front_computational_methods:214">
<semantics>
<msub>
<mi>c</mi>
<mi>s</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>s</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   c_{s}
  </annotation>
</semantics>
</math>


. The RGPEP provides an equation for the coefficients 

<math display="inline" id="Light-front_computational_methods:215">
<semantics>
<mi>s</mi>
<annotation-xml encoding="MathML-Content">
<ci>s</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   s
  </annotation>
</semantics>
</math>

 as functions of 

<math display="inline" id="Light-front_computational_methods:216">
<semantics>
<mi>s</mi>
<annotation-xml encoding="MathML-Content">
<ci>s</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   s
  </annotation>
</semantics>
</math>

.</p>

<p>In principle, if one had solved the RGPEP equation for the front form Hamiltonian of QCD exactly, the eigenvalue problem could be written using effective quarks and gluons corresponding to any 

<math display="inline" id="Light-front_computational_methods:217">
<semantics>
<mi>s</mi>
<annotation-xml encoding="MathML-Content">
<ci>s</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   s
  </annotation>
</semantics>
</math>

. In particular, for 

<math display="inline" id="Light-front_computational_methods:218">
<semantics>
<mrow>
<mi>λ</mi>
<mo>∼</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mi>s</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">similar-to</csymbol>
<ci>λ</ci>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda\sim 1/s
  </annotation>
</semantics>
</math>

 very small, the eigenvalue problem would involve very large numbers of virtual constituents capable of interacting with large momentum transfers up to about the bandwidth 

<math display="inline" id="Light-front_computational_methods:219">
<semantics>
<mi>s</mi>
<annotation-xml encoding="MathML-Content">
<ci>s</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   s
  </annotation>
</semantics>
</math>


. In contrast, the same eigenvalue problem written in terms of quanta corresponding to a large 

<math display="inline" id="Light-front_computational_methods:220">
<semantics>
<mrow>
<msub>
<mi>x</mi>
<mrow>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>c</mi>
<msub>
<mi>t</mi>
<mrow>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
</mrow>
</msub>
</mrow>
<mo>,</mo>
<msub>
<mover accent="true">
<mi>x</mi>
<mo stretchy="false">→</mo>
</mover>
<mrow>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<list>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</list>
</apply>
<interval closure="open">
<apply>
<times></times>
<ci>c</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>t</ci>
<list>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</list>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<ci>normal-→</ci>
<ci>x</ci>
</apply>
<list>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</list>
</apply>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{1,2}=(ct_{1,2},\vec{x}_{1,2})
  </annotation>
</semantics>
</math>

, comparable with the size of hadrons, is hoped to take the form of a simple equation that resembles the constituent <a href="quark_model" title="wikilink">quark models</a>. To demonstrate mathematically that this is precisely what happens in the RGPEP in QCD is a serious challenge.</p>
<h2 id="bethe-salpeter-equation">Bethe-Salpeter equation</h2>

<p>The Bethe-Salpeter amplitude, which satisfies the <a href="Bethe-Salpeter_equation" title="wikilink">Bethe-Salpeter equation</a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> <a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> <ref name="SalesPRC01">{{ cite journal | author=J. H. Sales, T. Frederico, B. V. Carlson, and P. U. Sauer | title=Renormalization of the ladder light-front Bethe-Salpeter equation in the Yukawa model journal=<a href="Physical_Review_C" title="wikilink">Physical Review C</a> | volume= 63 | page= 064003 | year=2001 | doi= 10.1103/PhysRevC.63.064003</ref></p>

<p><code>| journal=Physical Review C}}</code></p>

<p>(see the reviews by Nakanishi<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> <a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> ), when projected on the light-front plane, results in the light-front wave function. The meaning of the ``light-front projection" is the following. In the coordinate space, the Bethe-Salpeter amplitude is a function of two four-dimensional coordinates 

<math display="block" id="Light-front_computational_methods:221">
<semantics>
<mrow>
<mi mathvariant="normal">Φ</mi>
<mo>=</mo>
<mrow>
<mi mathvariant="normal">Φ</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
<mo>;</mo>
<mi>p</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>normal-Φ</ci>
<apply>
<times></times>
<ci>normal-Φ</ci>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<ci>p</ci>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Phi=\Phi(x_{1},x_{2};p)
  </annotation>
</semantics>
</math>

, namely

<math display="inline" id="Light-front_computational_methods:222">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Light-front_computational_methods:223">
<semantics>
<mrow>
<mrow>
<mi mathvariant="normal">Φ</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>k</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
<mo>;</mo>
<mi>p</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo largeop="true" symmetric="true">∫</mo>
<mrow>
<msup>
<mi>d</mi>
<mn>4</mn>
</msup>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<msup>
<mi>d</mi>
<mn>4</mn>
</msup>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
<mi mathvariant="normal">Φ</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
<mo>;</mo>
<mi>p</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>exp</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>i</mi>
<msub>
<mi>k</mi>
<mn>1</mn>
</msub>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<mi>i</mi>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>normal-Φ</ci>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
<ci>p</ci>
</vector>
</apply>
<apply>
<int></int>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>d</ci>
<cn type="integer">4</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>d</ci>
<cn type="integer">4</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-Φ</ci>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<ci>p</ci>
</vector>
<apply>
<exp></exp>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>i</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<times></times>
<ci>i</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Phi(k_{1},k_{2};p)=\int d^{4}x_{1}d^{4}x_{2}\Phi(x_{1},x_{2};p)\exp(ik_{1}x_{%
1}+ik_{2}x_{2})
  </annotation>
</semantics>
</math>

 is the total four-momentum of the system. In momentum space, it is given by the Fourier transform:</p>

<p>
<math display="inline" id="Light-front_computational_methods:224">
<semantics>
<mrow>
<mi mathvariant="normal">Φ</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>k</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
<mo>;</mo>
<mi>p</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>normal-Φ</ci>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
<ci>p</ci>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Phi(k_{1},k_{2};p)
  </annotation>
</semantics>
</math>
</p>

<p>(the momentum space Bethe-Salpeter amplitude 

<math display="inline" id="Light-front_computational_methods:225">
<semantics>
<mrow>
<mrow>
<msub>
<mi>k</mi>
<mn>1</mn>
</msub>
<mo>+</mo>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
</mrow>
<mo>=</mo>
<mi>p</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>p</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k_{1}+k_{2}=p
  </annotation>
</semantics>
</math>

 defined in this way includes in itself the delta-function responsible for the momenta conservation 

<math display="inline" id="Light-front_computational_methods:226">
<semantics>
<mrow>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{1},x_{2}
  </annotation>
</semantics>
</math>

). The light-front projection means that the arguments 

<math display="inline" id="Light-front_computational_methods:227">
<semantics>
<mrow>
<mrow>
<mi>ω</mi>
<mo>⋅</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>=</mo>
<mrow>
<mi>ω</mi>
<mo>⋅</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<ci>normal-⋅</ci>
<ci>ω</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<ci>normal-⋅</ci>
<ci>ω</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \omega\cdot x_{1}=\omega\cdot x_{2}=0
  </annotation>
</semantics>
</math>

 are on the light-front plane, i.e., they are constrained by the condition (in the covariant formulation): 

<math display="inline" id="Light-front_computational_methods:228">
<semantics>
<mrow>
<mi>δ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>ω</mi>
<mo>⋅</mo>
<msub>
<mi>x</mi>
<mrow>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
</mrow>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>δ</ci>
<apply>
<ci>normal-⋅</ci>
<ci>ω</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<list>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</list>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta(\omega\cdot x_{1,2})
  </annotation>
</semantics>
</math>

. This is achieved by inserting in the Fourier transform the corresponding delta functions 

<math display="inline" id="Light-front_computational_methods:229">
<semantics>
<mrow>
<mrow>
<msub>
<mi>ψ</mi>
<mrow>
<mi>L</mi>
<mi>F</mi>
</mrow>
</msub>
<mo>∝</mo>
<mrow>
<mo largeop="true" symmetric="true">∫</mo>
<mrow>
<msup>
<mi>d</mi>
<mn>4</mn>
</msup>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<msup>
<mi>d</mi>
<mn>4</mn>
</msup>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
<mi>δ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>ω</mi>
<mo>⋅</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>δ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>ω</mi>
<mo>⋅</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">Φ</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
<mo>;</mo>
<mi>p</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>exp</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>i</mi>
<msub>
<mi>k</mi>
<mn>1</mn>
</msub>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<mi>i</mi>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">proportional-to</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<apply>
<times></times>
<ci>L</ci>
<ci>F</ci>
</apply>
</apply>
<apply>
<int></int>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>d</ci>
<cn type="integer">4</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>d</ci>
<cn type="integer">4</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<ci>δ</ci>
<apply>
<ci>normal-⋅</ci>
<ci>ω</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>δ</ci>
<apply>
<ci>normal-⋅</ci>
<ci>ω</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>normal-Φ</ci>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<ci>p</ci>
</vector>
<apply>
<exp></exp>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>i</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<times></times>
<ci>i</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{LF}\propto\int d^{4}x_{1}d^{4}x_{2}\delta(\omega\cdot x_{1})\delta(%
\omega\cdot x_{2})\Phi(x_{1},x_{2};p)\exp(ik_{1}x_{1}+ik_{2}x_{2}).
  </annotation>
</semantics>
</math>

:</p>

<p>
<math display="inline" id="Light-front_computational_methods:230">
<semantics>
<msub>
<mi>ψ</mi>
<mrow>
<mi>L</mi>
<mi>F</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<apply>
<times></times>
<ci>L</ci>
<ci>F</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{LF}
  </annotation>
</semantics>
</math>
</p>

<p>In this way, we can find the light-front wave function 

<math display="inline" id="Light-front_computational_methods:231">
<semantics>
<mi>l</mi>
<annotation-xml encoding="MathML-Content">
<ci>l</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   l
  </annotation>
</semantics>
</math>

. Applying this formula to the Bethe-Salpeter amplitude with a given total angular momentum, one reproduces the angular momentum structure of the light-front wave function described in <a href="Light_front_quantization#Angular_momentum" title="wikilink">Light front quantization#Angular momentum</a>. In particular, projecting the Bethe-Salpeter amplitude corresponding to a system of two spinless particles with the angular momentum 

<math display="inline" id="Light-front_computational_methods:232">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>ψ</mi>
<mrow>
<mi>l</mi>
<mi>m</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mover accent="true">
<mi>k</mi>
<mo stretchy="false">→</mo>
</mover>
<mo>,</mo>
<mover accent="true">
<mi>n</mi>
<mo stretchy="false">^</mo>
</mover>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<msub>
<mi>f</mi>
<mn>1</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mrow>
<mover accent="true">
<mi>k</mi>
<mo stretchy="false">→</mo>
</mover>
<mo>⋅</mo>
<mover accent="true">
<mi>n</mi>
<mo stretchy="false">^</mo>
</mover>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<msub>
<mi>Y</mi>
<mrow>
<mi>l</mi>
<mi>m</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mover accent="true">
<mi>k</mi>
<mo stretchy="false">^</mo>
</mover>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mi>f</mi>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mrow>
<mover accent="true">
<mi>k</mi>
<mo stretchy="false">→</mo>
</mover>
<mo>⋅</mo>
<mover accent="true">
<mi>n</mi>
<mo stretchy="false">^</mo>
</mover>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<msub>
<mi>Y</mi>
<mrow>
<mi>l</mi>
<mi>m</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mover accent="true">
<mi>n</mi>
<mo stretchy="false">^</mo>
</mover>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<apply>
<times></times>
<ci>l</ci>
<ci>m</ci>
</apply>
</apply>
<interval closure="open">
<apply>
<ci>normal-→</ci>
<ci>k</ci>
</apply>
<apply>
<ci>normal-^</ci>
<ci>n</ci>
</apply>
</interval>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<cn type="integer">1</cn>
</apply>
<interval closure="open">
<ci>k</ci>
<apply>
<ci>normal-⋅</ci>
<apply>
<ci>normal-→</ci>
<ci>k</ci>
</apply>
<apply>
<ci>normal-^</ci>
<ci>n</ci>
</apply>
</apply>
</interval>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<apply>
<times></times>
<ci>l</ci>
<ci>m</ci>
</apply>
</apply>
<apply>
<ci>normal-^</ci>
<ci>k</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<cn type="integer">2</cn>
</apply>
<interval closure="open">
<ci>k</ci>
<apply>
<ci>normal-⋅</ci>
<apply>
<ci>normal-→</ci>
<ci>k</ci>
</apply>
<apply>
<ci>normal-^</ci>
<ci>n</ci>
</apply>
</apply>
</interval>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<apply>
<times></times>
<ci>l</ci>
<ci>m</ci>
</apply>
</apply>
<apply>
<ci>normal-^</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{lm}(\vec{k},\hat{n})=f_{1}(k,\vec{k}\cdot\hat{n})Y_{lm}(\hat{k})+f_{2}(k%
,\vec{k}\cdot\hat{n})Y_{lm}(\hat{n}),
  </annotation>
</semantics>
</math>

, one reproduces the light-front wave function</p>

<p>
<math display="inline" id="Light-front_computational_methods:233">
<semantics>
<mrow>
<mi>g</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>γ</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>g</ci>
<interval closure="open">
<ci>γ</ci>
<ci>z</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   g(\gamma,z)
  </annotation>
</semantics>
</math>
</p>

<p>given in <a href="Light_front_quantization#Angular_momentum" title="wikilink">Light front quantization#Angular momentum</a>.</p>

<p>The Bethe-Salpeter amplitude includes the propagators of the external particles, and, therefore, it is singular. It can be represented in the form of the Nakanishi integral<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> through a non-singular function 

<math display="inline" id="Light-front_computational_methods:234">
<semantics>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>k</mi>
<mn>1</mn>
</msub>
<mo>-</mo>
<msub>
<mi>k</mi>
<mn>2</mn>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>k</ci>
<apply>
<divide></divide>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k=(k_{1}-k_{2})/2
  </annotation>
</semantics>
</math>

:</p>

<p>\int_{-1}^1dz'\int_0^{\infty}d\gamma' \frac{g(\gamma',z')}{\left[\gamma'+m^2 -\frac{1}{4}M^2-k^2-p\cdot k\; z'-i\epsilon\right]^3}, |<mtpl><eqref>1<eqref></eqref></eqref></mtpl>}}</p>

<p>where 

<math display="inline" id="Light-front_computational_methods:235">
<semantics>
<mrow>
<mi>g</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>γ</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>g</ci>
<interval closure="open">
<ci>γ</ci>
<ci>z</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   g(\gamma,z)
  </annotation>
</semantics>
</math>

 is the relative four-momentum. The Nakanishi weight function 

<math display="inline" id="Light-front_computational_methods:236">
<semantics>
<mrow>
<mi>g</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>γ</mi>
<mo>,</mo>
<mi>z</mi>
<mo>=</mo>
<mo>±</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">g</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">γ</csymbol>
<ci>normal-,</ci>
<csymbol cd="unknown">z</csymbol>
<eq></eq>
<csymbol cd="latexml">plus-or-minus</csymbol>
<cn type="integer">1</cn>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<cn type="integer">0</cn>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   g(\gamma,z=\pm 1)=0
  </annotation>
</semantics>
</math>

 is found from an equation and has the properties: 

<math display="inline" id="Light-front_computational_methods:237">
<semantics>
<mrow>
<mi>g</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>γ</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
<mo>,</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>→</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">g</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">γ</csymbol>
<ci>normal-→</ci>
<infinity></infinity>
<ci>normal-,</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-→</ci>
<cn type="integer">0</cn>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   g(\gamma\to\infty,z)\to 0
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Light-front_computational_methods:238">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>ψ</mi>
<mrow>
<mi>L</mi>
<mi>F</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>k</mi>
<mo>⟂</mo>
</msub>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<msqrt>
<mrow>
<mn>4</mn>
<mi>π</mi>
</mrow>
</msqrt>
</mfrac>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mn>0</mn>
<mi mathvariant="normal">∞</mi>
</msubsup>
<mfrac>
<mrow>
<mi>x</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>g</mi>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>γ</mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>x</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>d</mi>
<msup>
<mi>γ</mi>
<mo>′</mo>
</msup>
</mrow>
<msup>
<mrow>
<mo maxsize="160%" minsize="160%">[</mo>
<mrow>
<mrow>
<msup>
<mi>γ</mi>
<mo>′</mo>
</msup>
<mo>+</mo>
<msubsup>
<mi>k</mi>
<mo>⟂</mo>
<mn>2</mn>
</msubsup>
<mo>+</mo>
<msup>
<mi>m</mi>
<mn>2</mn>
</msup>
</mrow>
<mo>-</mo>
<mrow>
<mi>x</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mi>M</mi>
<mn>2</mn>
</msup>
</mrow>
</mrow>
<mo maxsize="160%" minsize="160%">]</mo>
</mrow>
<mn>2</mn>
</msup>
</mfrac>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<apply>
<times></times>
<ci>L</ci>
<ci>F</ci>
</apply>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
<ci>x</ci>
</interval>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<root></root>
<apply>
<times></times>
<cn type="integer">4</cn>
<ci>π</ci>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">0</cn>
</apply>
<infinity></infinity>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>x</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>x</ci>
</apply>
<ci>g</ci>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>γ</ci>
<ci>normal-′</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>x</ci>
</apply>
</apply>
</interval>
<ci>d</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>γ</ci>
<ci>normal-′</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<minus></minus>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>γ</ci>
<ci>normal-′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>m</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<ci>x</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>x</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>M</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{LF}(k_{\perp},x)=\frac{1}{\sqrt{4\pi}}\int_{0}^{\infty}\frac{x(1-x)g(%
\gamma^{\prime},1-2x)d\gamma^{\prime}}{\Bigl[\gamma^{\prime}+k_{\perp}^{2}+m^{%
2}-x(1-x)M^{2}\Bigr]^{2}}.
  </annotation>
</semantics>
</math>

. Projecting the Bethe-Salpeter amplitude () on the light-front plane, we get the following useful representation for the light-front wave function (see the review by Carbonell and Karmanov<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a>):</p>

<p>
<math display="inline" id="Light-front_computational_methods:239">
<semantics>
<mrow>
<mi mathvariant="normal">Φ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>k</mi>
<mo>,</mo>
<mi>p</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>normal-Φ</ci>
<interval closure="open">
<ci>k</ci>
<ci>p</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Phi(k,p)
  </annotation>
</semantics>
</math>
</p>

<p>It turns out that the masses of a two-body system, found from the Bethe-Salpeter equation for 

<math display="inline" id="Light-front_computational_methods:240">
<semantics>
<mrow>
<msub>
<mi>ψ</mi>
<mrow>
<mi>L</mi>
<mi>F</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>k</mi>
<mo>⟂</mo>
</msub>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<apply>
<times></times>
<ci>L</ci>
<ci>F</ci>
</apply>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>k</ci>
<csymbol cd="latexml">perpendicular-to</csymbol>
</apply>
<ci>x</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{LF}(k_{\perp},x)
  </annotation>
</semantics>
</math>

 and from the light-front equation for 

<math display="inline" id="Light-front_computational_methods:241">
<semantics>
<msubsup>
<mi>p</mi>
<mi>i</mi>
<mo>+</mo>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<ci>i</ci>
</apply>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{i}^{+}
  </annotation>
</semantics>
</math>

 with the kernel corresponding to the same physical content, say, one-boson exchange (which, however, in the both approaches have very different analytical forms) are very close to each other. The same is true for the electromagnetic form factors<ref km08"="" name="ck_trento_09}.&lt;/p&gt;
&lt;p&gt;On the contrary, the masses of a three-body system found in the two approaches are rather different. They become very close to each other after incorporating the three-body forces of relativistic origin.&lt;ref name=">{{ cite journal | author=V. A. Karmanov and P. Maris | title=Manifestation of three-body forces in three-body Bethe-Salpeter and light-front equations | journal=<a href="Few_Body_Systems" title="wikilink">Few Body Systems</a> | volume= 46 | pages= 95–113 | year=2009 | doi= 10.1007/s00601-009-0054-3}} This undoubtedly proves the existence of three-body forces, though the contribution of relativistic origin does not exhaust, of course, all the contributions. The same relativistic dynamics should generate four-body forces, etc. Since in nuclei the small binding energies (relative to the nucleon mass) result from cancellations between the kinetic and potentials energies (which are comparable with nucleon mass, and, hence relativistic), the relativistic effects in nuclei are noticeable. Therefore, many-body forces should be taken into account for fine tuning to experimental data.</ref></p>
<h2 id="vacuum-structure-and-zero-modes">Vacuum structure and zero modes</h2>

<p>One of the advantages of light-front quantization is that the empty state, the so-called perturbative vacuum, is the physical vacuum.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> <a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> <a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> <a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> <a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> <a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> <a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a> <a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> <a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a> <ref name="Brodsky:2012ku">{{ cite journal | author= S. J. Brodsky, C. D. Roberts, R. Shrock and P. C. Tandy | title= Confinement contains condensates |</ref></p>

<p><code> journal=</code><a href="Physical_Review_C" title="wikilink"><code>Physical</code> <code>Review</code> <code>C</code></a><code> | volume= 85 | page= 065202 | year=2012 |</code><br/>
<code> doi= 10.1103/PhysRevC.85.065202}}</code></p>

<p><a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> The massive states of a theory can then be built on this lowest state without having any contributions from vacuum structure, and the wave functions for these massive states do not contain vacuum contributions. This occurs because each 

<math display="inline" id="Light-front_computational_methods:242">
<semantics>
<msubsup>
<mi>ϕ</mi>
<mrow>
<mn>1</mn>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mn>4</mn>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ϕ</ci>
<cn type="integer">4</cn>
</apply>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \phi^{4}_{1+1}
  </annotation>
</semantics>
</math>

 is positive, and the interactions of the theory cannot produce particles from the zero-momentum vacuum without violating momentum conservation. There is no need to <a href="Normal_order" title="wikilink">normal-order</a> the light-front vacuum.</p>

<p>However, certain aspects of some theories are associated with vacuum structure. For example, the Higgs mechanism of the <a href="Standard_Model" title="wikilink">Standard Model</a> relies on spontaneous symmetry breaking in the vacuum of the theory.<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a> <a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a> <a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> <ref name="Rozowsky:2000gy">{{ cite journal | author= J. S. Rozowsky and C. B. Thorn |</ref></p>

<p><code>title=  Spontaneous symmetry breaking at infinite momentum without P+ zero modes |</code><br/>
<code>  journal=</code><a href="Physical_Review_Letters" title="wikilink"><code>Physical</code> <code>Review</code> <code>Letters</code></a><code> | volume= 85 | pages= 1614–1617 | year=2000 |</code><br/>
<code>  doi= 10.1103/PhysRevLett.85.1614 | bibcode=2000PhRvL..85.1614R}}</code></p>

<p><ref name="Chakrabarti:2003tc">{{ cite journal | author= D. Chakrabarti, A. Harindranath, L. Martinovic, G. B. Pivovarov and J. P. Vary |</ref></p>

<p><code>title=  Ab initio results for the broken phase of scalar light front field theory |</code><br/>
<code>  journal=</code><a href="Physics_Letters_B" title="wikilink"><code>Physics</code> <code>Letters</code> <code>B</code></a><code> | volume= 617 | pages= 92–98 | year=2005 |</code><br/>
<code> doi= 10.1016/j.physletb.2005.05.012}}</code></p>

<p><ref name="Kim:2003ha">{{ cite journal | author= V. T. Kim, G. B. Pivovarov and J. P. Vary |</ref></p>

<p><code>title=  Phase transition in light front </code>
<math display="inline" id="Light-front_computational_methods:243">
<semantics>
<mrow>
<msup>
<mi>k</mi>
<mo>+</mo>
</msup>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>k</ci>
<plus></plus>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k^{+}=0
  </annotation>
</semantics>
</math>
<code> |</code><br/>
<code>  journal=</code><a href="Physical_Review_D" title="wikilink"><code>Physical</code> <code>Review</code> <code>D</code></a><code> | volume= 69 | page= 085008 | year=2004 |</code><br/>
<code>  doi= 10.1103/PhysRevD.69.085008}}</code></p>

<p>The usual Higgs vacuum expectation value in the instant form is replaced by 

<math display="inline" id="Light-front_computational_methods:244">
<semantics>
<msup>
<mi>ϕ</mi>
<mn>4</mn>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ϕ</ci>
<cn type="integer">4</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \phi^{4}
  </annotation>
</semantics>
</math>

 zero mode analogous to a constant Stark field when one quantizes the Standard model using the front form.<ref name="Srivastava:2002mw">{{ cite journal | author= P. P. Srivastava and S. J. Brodsky | title= A Unitary and renormalizable theory of the standard model in ghost free light cone gauge |</ref></p>

<p><code> journal=</code><a href="Physical_Review_D" title="wikilink"><code>Physical</code> <code>Review</code> <code>D</code></a><code> | volume= 66 | page= 045019 | year=2002 |</code><br/>
<code> doi= 10.1103/PhysRevD.66.045019}}</code></p>

<p><a href="Chiral_symmetry_breaking" title="wikilink">Chiral symmetry breaking</a> of quantum chromodynamics is often associated in the instant form with quark and gluon condensates in the QCD vacuum. However, these effects become properties of the hadron wave functions themselves using the front form.<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a> <a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a> <ref name="Brodsky:2009zd">{{ cite journal | author= S. J. Brodsky and R. Shrock | title= Condensates in Quantum Chromodynamics and the Cosmological Constant | journal=<a href="Proceedings_of_the_National_Academy_of_Science" title="wikilink">Proceedings of the National Academy of Science</a> | volume= 108 | pages= 45–50 | year=2011 |</ref></p>

<p><code> doi= 10.1073/pnas.1010113107}}</code></p>

<p><ref name="Brodsky:2010xf">{{ cite journal | author= S. J. Brodsky, C. D. Roberts, R. Shrock and P. C. Tandy | title= Essence of the vacuum quark condensate |</ref></p>

<p><code> journal=</code><a href="Physical_Review_C" title="wikilink"><code>Physical</code> <code>Review</code> <code>C</code></a><code> | volume= 82 | page= 022201 | year=2010 |</code><br/>
<code>doi= 10.1103/PhysRevC.82.022201}}</code></p>

<p>This also eliminates the many orders of magnitude conflict between the measured cosmological constant and quantum field theory.<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a></p>

<p>Some aspects of vacuum structure in light-front quantization can be analyzed by studying properties of massive states. In particular, by studying the appearance of <a href="Degenerate_energy_levels" title="wikilink">degeneracies</a> among the lowest massive states, one can determine the critical coupling strength associated with spontaneous symmetry breaking. One can also use a limiting process, where the analysis begins in equal-time quantization but arrives in light-front coordinates as the limit of some chosen parameter.<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a> <a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a> A much more direct approach is to include modes of zero longitudinal momentum (zero modes) in a calculation of a nontrivial light-front vacuum built from these modes; the Hamiltonian then contains effective interactions that determine the vacuum structure and provide for zero-mode exchange interactions between constituents of massive states.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Light_front_quantization" title="wikilink">Light front quantization</a></li>
<li><a href="Light-front_quantization_applications" title="wikilink">Light-front quantization applications</a></li>
<li><a href="Quantum_field_theories" title="wikilink">Quantum field theories</a></li>
<li><a href="Quantum_chromodynamics" title="wikilink">Quantum chromodynamics</a></li>
<li><a href="Quantum_electrodynamics" title="wikilink">Quantum electrodynamics</a></li>
<li><a href="Light_front_holography" title="wikilink">Light-front holography</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.ilcacinc.org">ILCAC, Inc.</a>, the International Light-Cone Advisory Committee.</li>
<li><a href="http://www.saha.ac.in/theory/a.harindranath/light/light.html">Publications on light-front dynamics</a>, maintained by A. Harindranath.</li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_chromodynamics" title="wikilink">Category:Quantum chromodynamics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">{{ cite journal | author=M. Burkardt | title= Light front quantization | journal=<a href="Advances_in_Nuclear_Physics" title="wikilink">Advances in Nuclear Physics</a> | volume= 23 | pages= 1–74 | year=2002 | doi= 10.1007/0-306-47067-5_1}}<a href="#fnref1">↩</a></li>
<li id="fn2">{{ cite journal | author=S.J. Brodsky, H.-C. Pauli, and S.S. Pinsky | title= Quantum chromodynamics and other field theories on the light cone | journal=<a href="Physics_Reports" title="wikilink">Physics Reports</a> | volume= 301 | pages= 299–486 | year=1998 | doi= 10.1016/S0370-1573(97)00089-6 | bibcode=1998PhR...301..299B}}<a href="#fnref2">↩</a></li>
<li id="fn3">{{ cite journal | author= P. A. M. Dirac | title= Forms of Relativistic Dynamics | journal=<a href="Reviews_of_Modern_Physics" title="wikilink">Reviews of Modern Physics</a> | volume= 21 | pages= 392–399 | year=1949 | doi= 10.1103/RevModPhys.21.392 | bibcode=1949RvMP...21..392D}}<a href="#fnref3">↩</a></li>
<li id="fn4">{{ cite journal | author= H.-C. Pauli and S. J. Brodsky | title=Solving field theory in one space one time dimension | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 32 | pages= 1993–2000 | year=1985 | doi= 10.1103/PhysRevD.32.1993}}<a href="#fnref4">↩</a></li>
<li id="fn5">{{ cite journal | author=H.-C. Pauli and S. J. Brodsky | title=Discretized light cone quantization: Solution to a field theory in one space one time dimensions | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 32 | pages= 2001–2013 | year=1985 | doi= 10.1103/PhysRevD.32.2001}}<a href="#fnref5">↩</a></li>
<li id="fn6">{{ cite journal | author= T. Eller, H.-C. Pauli, and S. J. Brodsky | title=Discretized Light Cone Quantization: The Massless and the Massive Schwinger Model | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 35 | pages= 1493–1507 | year=1987 | doi= 10.1103/PhysRevD.35.1493}}<a href="#fnref6">↩</a></li>
<li id="fn7">{{ cite journal | author= Y. Matsumura, N. Sakai, and T. Sakai | title=Mass spectra of supersymmetric Yang-Mills theories in (1+1)-dimensions | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 52 | pages= 2446–2461 | year=1995 | doi= 10.1103/PhysRevD.52.2446}}<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10">{{ cite journal | author=S.S. Chabysheva and J.R. Hiller | title= Zero momentum modes in discrete light-cone quantization | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 79 | page= 096012 | year=2009 | doi=10.1103/PhysRevD.79.096012}}<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15">{{ cite journal | author=X. Zhao, H. Honkanen, P. Maris, J.P. Vary, and S.J. Brodsky | title=Electron Anomalous Magnetic Moment in Basis Light-Front Quantization Approach | journal=<a href="Few_Body_Systems" title="wikilink">Few Body Systems</a> | volume= 52 | pages= 339–344 | year=2012 | doi= 10.1007/s00601-011-0273-2 | bibcode=2012FBS....52..339Z}}<a href="#fnref15">↩</a></li>
<li id="fn16">{{ cite journal | author=X. Zhao, H. Honkanen, P. Maris, J. P. Vary and S. J. Brodsky | title=Electron g-2 in Light-Front Quantization | arxiv=1402.4195}}<a href="#fnref16">↩</a></li>
<li id="fn17">{{ cite journal | author= R.J. Bartlett and M. Musial | title=Coupled-cluster theory in quantum chemistry | journal=<a href="Reviews_of_Modern_Physics" title="wikilink">Reviews of Modern Physics</a> | volume= 79 | pages= 291–352 | year=2007 | doi= 10.1103/RevModPhys.79.291 | bibcode=2007RvMP...79..291B}}<a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22">{{ cite journal | author= E. C. G. Stueckelberg and A. Petermann | title=Normalization of constants in the quanta theory | journal=<a href="Helvetica_Physica_Acta" title="wikilink">Helvetica Physica Acta</a> | volume= 26 | page= 499 | year=1953 }}<a href="#fnref22">↩</a></li>
<li id="fn23">{{ cite journal | author=M. Gell-Mann and F. E. Low | title=Quantum electrodynamics at small distances | journal=<a href="Physical_Review" title="wikilink">Physical Review</a> | volume= 95 | pages= 1300–1312 | year=1954 | doi= 10.1103/PhysRev.95.1300}}<a href="#fnref23">↩</a></li>
<li id="fn24">{{ cite journal | author=K. G. Wilson | title=Model Hamiltonians for Local Quantum Field Theory | journal=<a href="Physical_Review" title="wikilink">Physical Review</a> | volume= 140 | page= B445 | year=1965 | doi= 10.1103/PhysRev.140.B445 }}<a href="#fnref24">↩</a></li>
<li id="fn25">{{ cite journal | author=K. G. Wilson | title=A Model Of Coupling Constant Renormalization | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 2 | pages= 1438–1472 | year=1970 | doi= 10.1103/PhysRevD.2.1438 }}<a href="#fnref25">↩</a></li>
<li id="fn26">{{ cite journal | author=G. 't Hooft | title=Dimensional regularization and the renormalization group | journal=<a href="Nuclear_Physics_B" title="wikilink">Nuclear Physics B</a> | volume= 61 | pages= 455–468 | year=1973 | doi= 10.1016/0550-3213(73)90376-3}}<a href="#fnref26">↩</a></li>
<li id="fn27">{{ cite journal | author=K. G. Wilson and J. B. Kogut | title=The Renormalization group and the epsilon expansion | journal=<a href="Physics_Reports" title="wikilink">Physics Reports</a> | volume= 12 | pages= 75–199 | year=1974 | doi= 10.1016/0370-1573(74)90023-4}}<a href="#fnref27">↩</a></li>
<li id="fn28">{{ cite journal | author=P. A. M. Dirac | title=Quantum Electrodynamics without Dead Wood | journal=<a href="Physical_Review" title="wikilink">Physical Review</a> | volume= 139 | page= B684 | year=1965 | doi= 10.1103/PhysRev.139.B684}}<a href="#fnref28">↩</a></li>
<li id="fn29">{{ cite journal | author=R. J. Perry and K. G. Wilson | title=Perturbative renormalizability with an infinite number of relevant and marginal operators | journal=<a href="Nuclear_Physics_B" title="wikilink">Nuclear Physics B</a> | volume= 403 | pages= 587–601 | year=1993 | doi= 10.1016/0550-3213(93)90363-T}}<a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32">{{ cite journal | author=S. D. Glazek and K. G. Wilson | title=Renormalization of Hamiltonians | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 48 | pages= 5863–5872 | year=1993 | doi= 10.1103/PhysRevD.48.5863}}<a href="#fnref32">↩</a></li>
<li id="fn33"></li>
<li id="fn34">{{ cite journal | author=K. G. Wilson, T. S. Walhout, A. Harindranath, W.-M. Zhang, R. J. Perry, S. D. Glazek | title=Nonperturbative QCD: A Weak coupling treatment on the light front | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 49 | pages= 6720–6766 | year=1994 | doi= 10.1103/PhysRevD.49.6720}}<a href="#fnref34">↩</a></li>
<li id="fn35"></li>
<li id="fn36">{{ cite journal | author=S. D. Glazek | title=Perturbative Formulae for Relativistic Interactions of Effective Particles | journal=<a href="Acta_Physics_Polinca_B" title="wikilink">Acta Physics Polinca B</a> | volume= 43 | page= 1843 | year=2012 | doi= 10.5506/APhysPolB.43.1843}}<a href="#fnref36">↩</a></li>
<li id="fn37">{{ cite journal | author=S. D. Glazek | title=Fermion mass mixing and vacuum triviality in the renormalization group procedure for effective particles | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 87 | page= 125032 | year=2013 | doi= 10.1103/PhysRevD.87.125032 }}<a href="#fnref37">↩</a></li>
<li id="fn38">{{ cite journal | author=H. J. Melosh | title=Quarks: Currents and constituents | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 9 | pages= 1095–1112 | year=1974 | doi= 10.1103/PhysRevD.9.1095 }}<a href="#fnref38">↩</a></li>
<li id="fn39">{{ cite journal | author=E.E. Salpeter and H.A. Bethe | title=A Relativistic Equation for Bound-State Problems | journal=<a href="Physical_Review" title="wikilink">Physical Review</a> | volume= 84 | pages= 1232–1242 | year=1951 | doi= 10.1103/PhysRev.84.1232}}<a href="#fnref39">↩</a></li>
<li id="fn40">{{ cite journal | author=J. H. O. Sales, T. Frederico, B. V. Carlson and P. U. Sauer | title=Light-front Bethe-Salpeter equation | journal=<a href="Physical_Review_C" title="wikilink">Physical Review C</a> | volume= 61 | page= 044003 | year=2000 | doi= 10.1103/PhysRevC.61.044003}}<a href="#fnref40">↩</a></li>
<li id="fn41">{{ cite journal | author=N. Nakanishi | title=A General survey of the theory of the Bethe-Salpeter equation | journal=<a href="Progress_of_Theoretical_Physics_Supplement" title="wikilink">Progress of Theoretical Physics Supplement</a> | volume= 43 | pages= 1–81 | year=1969 | doi= 10.1143/PTPS.43.1}}<a href="#fnref41">↩</a></li>
<li id="fn42">{{ cite journal | author=N. Nakanishi | title=Review of the Wick-cutkosky Model | journal=<a href="Progress_of_Theoretical_Physics_Supplement" title="wikilink">Progress of Theoretical Physics Supplement</a> | volume= 95 | pages= 1–24 | year=1988 | doi= 10.1143/PTPS.95.1}}<a href="#fnref42">↩</a></li>
<li id="fn43">{{ cite book | first=N. | last=Nakanishi | title=Graph Theory and Feynman Integrals | publisher=Gordon and Breach | location= New York | date=1971 }}<a href="#fnref43">↩</a></li>
<li id="fn44">{{ cite journal | author=J. Carbonell and V.A. Karmanov | title=Solutions of the Bethe-Salpeter equation in Minkowski space and applications to electromagnetic form factors | journal=<a href="Few_Body_Systems" title="wikilink">Few Body Systems</a> | volume= 49 | pages= 205–222 | year=2011 | doi= 10.1007/s00601-010-0133-5}}<a href="#fnref44">↩</a></li>
<li id="fn45">{{ cite journal | author=Y. Nambu and G. Jona-Lasinio | title=Dynamical model of elementary particles based on an analogy with auperconductivity | journal=<a href="Physical_Review" title="wikilink">Physical Review</a> | volume= 122 | pages= 345–358 | year=1961 | doi= 10.1103/PhysRev.122.345}}<a href="#fnref45">↩</a></li>
<li id="fn46">{{ cite journal | author=M. Gell-Mann, R. J. Oakes, and B. Renner | title=Behavior of current divergences under SU(3) x SU(3) | journal=<a href="Physical_Review" title="wikilink">Physical Review</a> | volume= 175 | pages= 2195–2199 | year=1968 | doi= 10.1103/PhysRev.175.2195}}<a href="#fnref46">↩</a></li>
<li id="fn47">{{ cite journal | author=G. 't Hooft and M. Veltman | title=Regularization and renormalization of gauge fields | journal=<a href="Nuclear_Physics_B" title="wikilink">Nuclear Physics B</a> | volume= 44 | pages= 189–213 | year=1972 | doi= 10.1016/0550-3213(72)90279-9}}<a href="#fnref47">↩</a></li>
<li id="fn48">{{ cite journal | author=M. A. Shifman, A.I. Vainshtein, and V. I. Zakharov | title=QCD and Resonance Physics: Applications | journal=<a href="Nuclear_Physics_B" title="wikilink">Nuclear Physics B</a> | volume= 147 | pages= 448–518 | year=1979 | doi= 10.1016/0550-3213(79)90023-3}}<a href="#fnref48">↩</a></li>
<li id="fn49">{{ cite journal | author=R. P. Feynman | title=The Qualitative Behavior of Yang-Mills Theory in (2+1)-Dimensions | journal=<a href="Nuclear_Physics_B" title="wikilink">Nuclear Physics B</a> | volume= 188 | pages= 479–512 | year=1981 | doi= 10.1016/0550-3213(81)90005-5}}<a href="#fnref49">↩</a></li>
<li id="fn50">{{ cite journal | author=E. Witten | title=Dynamical Breaking of Supersymmetry | journal=<a href="Nuclear_Physics_B" title="wikilink">Nuclear Physics B</a> | volume= 188 | pages= 513–554 | year=1981 | doi= 10.1016/0550-3213(81)90006-7}}<a href="#fnref50">↩</a></li>
<li id="fn51">{{ cite journal | author=J. Gasser and H. Leutwyler | title=Chiral Perturbation Theory to One Loop | journal=<a href="Annals_of_Physics" title="wikilink">Annals of Physics</a> | volume= 158 | pages= 142–210 | year=1984 | doi= 10.1016/0003-4916(84)90242-2 }}<a href="#fnref51">↩</a></li>
<li id="fn52">{{ cite journal | author=S. D. Glazek | title=Light Front QCD in the Vacuum Background | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 38 | pages= 3277–3286 | year=1988 | doi= 10.1103/PhysRevD.38.3277 }}<a href="#fnref52">↩</a></li>
<li id="fn53">{{ cite journal | author=P. Maris, C. D. Roberts, and P. C. Tandy | title=Pion mass and decay constant | journal=<a href="Physics_Letters_B" title="wikilink">Physics Letters B</a> | volume= 420 | pages= 267–273 | year=1998 | doi= 10.1016/S0370-2693(97)01535-9}}<a href="#fnref53">↩</a></li>
<li id="fn54">{{ cite journal | author= A. Casher and L. Susskind | title=Chiral magnetism (or magnetohadrochironics) | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 9 | pages= 436–460 | year=1974 | doi= 10.1103/PhysRevD.9.436}}<a href="#fnref54">↩</a></li>
<li id="fn55">{{ cite journal | author=C. M. Bender, S. S. Pinsky, and B. van de Sande | title=Spontaneous symmetry breaking of 

<math display="inline" id="Light-front_computational_methods:245">
<semantics>
<msup>
<mi>ϕ</mi>
<mn>4</mn>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ϕ</ci>
<cn type="integer">4</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \phi^{4}
  </annotation>
</semantics>
</math>

 in (1+1)-dimensions in light front field theory | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 48 | pages= 816–821 | year=1993 | doi= 10.1103/PhysRevD.48.816}}<a href="#fnref55">↩</a></li>
<li id="fn56">{{ cite journal | author=S. S. Pinsky and B. van de Sande | title=Spontaneous symmetry breaking of (1+1)-dimensional 

<math display="inline" id="Light-front_computational_methods:246">
<semantics>
<msup>
<mi>ϕ</mi>
<mn>4</mn>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ϕ</ci>
<cn type="integer">4</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \phi^{4}
  </annotation>
</semantics>
</math>

 theory in light front field theory. 2 | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 49 | pages= 2001–2013 | year=1994 | doi= 10.1103/PhysRevD.49.2001}}<a href="#fnref56">↩</a></li>
<li id="fn57">{{ cite journal | author=S. S. Pinsky, B. van de Sande, and J.R. Hiller | title=Spontaneous symmetry breaking of (1+1)-dimensional 

<math display="inline" id="Light-front_computational_methods:0">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mo>+</mo>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mi>t</mi>
    </mrow>
    <mo>+</mo>
    <mi>z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <plus></plus>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>t</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{+}\equiv ct+z
  </annotation>
 </semantics>
</math>

 theory in light front field theory. 3 | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 51 | pages= 726–733 | year=1995 | doi= 10.1103/PhysRevD.51.726}}<a href="#fnref57">↩</a></li>
<li id="fn58"></li>
<li id="fn59"></li>
<li id="fn60"></li>
<li id="fn61">{{ cite journal | author=K. Hornbostel | title=Nontrivial vacua from equal time to the light cone | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 45 | pages= 3781–3801 | year=1992 | doi= 10.1103/PhysRevD.45.3781}}<a href="#fnref61">↩</a></li>
<li id="fn62">{{ cite journal | author=C.-R. Ji and A. Suzuki | title=Interpolating scattering amplitudes between the instant form and the front form of relativistic dynamics | journal=<a href="Physical_Review_D" title="wikilink">Physical Review D</a> | volume= 87|page= 065015 | year=2013 | doi= 10.1103/PhysRevD.87.065015}}<a href="#fnref62">↩</a></li>
</ol>
</section>
</body>
</html>
