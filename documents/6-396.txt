   Lambda lifting      Lambda lifting  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     '''Lambda lifting '''is a meta-process that restructures a computer program so that functions are defined independently of each other in a global scope . An individual "lift" transforms a local function into a global function. It is a two step process, consisting of;   Eliminating free variables in the function by adding parameters.  Moving functions from a restricted scope to broader or global scope.   Lambda lifting was historically considered as a mechanism for implementing functional programming languages . Lambda lifting is used in conjunction with other techniques in some modern compilers .  The term "lambda lifting" was first introduced by Thomas Johnsson around 1982.  Lambda lifting is not the same as closure conversion . Lambda lifting requires all call sites to be adjusted (adding extra arguments to calls) and does not introduce a closure for the lifted lambda expression. In contrast, closure conversion does not require call sites to be adjusted but does introduce a closure for the lambda expression mapping free variables to values.  Lambda lifts may be used on individual functions, in code refactoring , to make a function usable outside the scope in which it was written. Lambda lifts may also be repeated, in order to transform the program. Repeated lambda lifts may be used to convert a program written in lambda calculus into a set of recursive functions , without lambdas. This demonstrates the equivalence of programs written in lambda calculus and programs written as functions. 1 However it does not demonstrate the soundness of lambda calculus for deduction, as the eta reduction used in lambda lifting is the step that introduces cardinality problems into the lambda calculus, because it removes the value from the variable, without first checking that there is only one value that satisfies the conditions on the variable (see Curry's paradox ).  Lambda lifting is expensive on processing time for the compiler. An efficient implementation of lambda lifting is    O   (   n  2   )       O   superscript  n  2     O(n^{2})   on processing time for the compiler. 2  In the untyped lambda calculus , where the basic types are functions, lifting may change the result of beta reduction of a lambda expression. The resulting functions will have the same meaning, in a mathematical sense, but are not regarded as the same function in the untyped lambda calculus. See also intensional versus extensional equality .  The reverse operation to lambda lifting is lambda dropping . 3  Lambda dropping may make the compilation of programs quicker for the compiler, and may also increase the efficiency of the resulting program, by reducing the number of parameters, and reducing the size of stack frames.  However lambda dropping makes a function harder to re-use. A dropped function is tied to its context, and can only be used in a different context if it is first lifted.  Algorithm  The following algorithm is one way to lambda-lift an arbitrary program in a language which doesn't support closures as first-class objects :   Rename the functions so that each function has a unique name.  Replace each free variable with an additional argument to the enclosing function, and pass that argument to every use of the function.  Replace every local function definition that has no free variables with an identical global function.  Repeat steps 2 and 3 until all free variables and local functions are eliminated.   If the language has closures as first-class objects that can be passed as arguments or returned from other functions, the closure will need to be represented by a data structure that captures the bindings of the free variables.  Example  The following OCaml program computes the sum of the integers from 1 to 100:  let  rec sum n = if n = 1  then  1  else  let f x =
       n + x in f (sum (n - 1 )) in sum 100  (The let rec declares sum as a function that may call itself.) The function f, which adds sum's argument to the sum of the numbers less than the argument, is a local function. Within the definition of f, n is a free variable. Start by converting the free variable to an argument:  let  rec sum n = if n = 1  then  1  else  let f w x =
       w + x in f n (sum (n - 1 )) in sum 100  Next, lift f into a global function:  let  rec f w x =
   w + x and sum n = if n = 1  then  1  else f n (sum (n - 1 )) in sum 100   The following is the same example, this time written in JavaScript :  // Initial version  function  sum (n) {  function  f (x) {  return n + x ;  }  if (n ==  1 ) return  1 ;  else  return  f ( sum (n -  1 )) ;  }  // After converting the free variable n to a formal parameter w  function  sum (n) {  function  f (w , x) {  return w + x ;  }  if (n ==  1 ) return  1 ;  else  return  f (n ,  sum (n -  1 )) ;  }  // After lifting function f into the global scope  function  f (w , x) {  return w + x ;  }  function  sum (n) {  if (n ==  1 ) return  1 ;  else  return  f (n ,  sum (n -  1 )) ;  }  Lambda lifting versus closures  Lambda lifting and closure are both methods for implementing block structured programs. Lambda lifting implements block structure by eliminating it. All functions are lifted to the global level. Closure conversion provides a "closure" which links the current frame to other frames. Closure conversion takes less compile time.  Recursive functions, and block structured programs, with or without lifting, may be implemented using a stack based implementation, which is simple and efficient. However a stack frame based implementation must be strict (eager) . The stack frame based implementation requires that the life of functions be first-in, first-out (FIFO). That is, the most recent function to start its calculation must be the first to end.  Some functional languages (such as Haskell ) are implemented using lazy evaluation , which delays calculation until the value is needed. The lazy implementation strategy gives flexibility to the programmer. Lazy evaluation requires delaying the call to a function until a request is made to the value calculated by the function. One implementation is to record a reference to a "frame" of data describing the calculation, in place of the value. Later when the value is required, the frame is used to calculate the value, just in time for when it is needed. The calculated value then replaces the reference.  The "frame" is similar to a stack frame , the difference being that it is not stored on the stack. Lazy evaluation requires that all the data required for the calculation be saved in the frame. If the function is "lifted", then the frame needs only record the function pointer, and the parameters to the function. Modern languages use garbage collection in place of stack based allocation to manage the life of variables. In a managed, garbage collected environment, a closure records references to the frames from which values may be obtained. In contrast a lifted function has parameters for each value needed in the calculation.  Let expressions and lambda calculus  The Let expression , is useful in describing lifting and dropping, and in describing the relationship between recursive equations and lambda expressions. Most functional languages have let expressions. Also block structured programming languages like ALGOL and Pascal are similar in that they to allow the local definition of a function, for use in a restricted scope .  The let expression used here is a fully mutually recursive version of let rec , as implemented in many functional languages.  Let expressions are related to Lambda calculus . Lambda calculus has a simple syntax and semantics, and is good for describing Lambda lifting. It is convenient to describe lambda lifting as a translations from lambda to a let expression, and lambda dropping as the reverse. This is because let expressions allow mutual recursion, which is in a sense, more lifted than is supported in lambda calculus. Lambda calculus does not support mutual recursion and only one function may be defined at the outermost global scope.  Conversion rules which describe translation without lifting are given in the Let expression article.  The following rules describe the equivalence of lambda and let expressions,      Name   Law       Eta-reduction equivalence          f   x   =  y  ≡  f  =   λ  x    .  y     formulae-sequence        f  x   y       f         λ  x     y    f\ x=y\equiv f=\lambda x.y        Let-Lambda equivalence       f  ∉  F  V   (  E  )   →   (  let  f  :  f  =  E  in  L  ≡   (  λ  f  .  L  )   E  )      fragments  f   F  V   fragments  normal-(  E  normal-)   normal-→   fragments  normal-(  let  f  normal-:  f   E  in  L    fragments  normal-(  λ  f  normal-.  L  normal-)   E  normal-)     f\not\in FV(E)\to(\operatorname{let}f:f=E\operatorname{in}L\equiv(\lambda f.L)%
 \ E)   (where f is a variable name).     Let combination       x  ∉  F  V   (  E  )   →   (  let  v  ,  …  ,  w  ,  x  :  E  and  F  in  L  ≡  let  v  ,  …  ,  w  :  E  in  let  x  :  F  in  L  )      fragments  x   F  V   fragments  normal-(  E  normal-)   normal-→   fragments  normal-(  let  v  normal-,  normal-…  normal-,  w  normal-,  x  normal-:  E  and  F  in  L   let  v  normal-,  normal-…  normal-,  w  normal-:  E  in  let  x  normal-:  F  in  L  normal-)     x\not\in FV(E)\to(\operatorname{let}v,...,w,x:E\and F\operatorname{in}L\equiv%
 \operatorname{let}v,...,w:E\operatorname{in}\operatorname{let}x:F\operatorname%
 {in}L)        Meta-functions will be given that describe lambda lifting and dropping. A meta-function is a function that takes a program as a parameter. The program is data for the meta-program. The program and the meta program are at different meta-levels.  The following conventions will be used to distinguish program from the meta program,   Square brackets [] will be used to represent function application in the meta program.  Capital letters will be used for variables in the meta program. Lower case letters represent variables in the program.     ≡     \equiv   will be used for equals in the meta program.     _   normal-_   \_   represents a dummy variable, or an unknown value.   For simplicity the first rule given that matches will be applied. The rules also assume that the lambda expressions have been pre-processed so that each lambda abstraction has a unique name.  The substitution operator is used extensively. The expression    L   [  G  :=  S  ]      fragments  L   fragments  normal-[  G  assign  S  normal-]     L[G:=S]   means substitute every occurrence of G in L by S and return the expression. The definition used is extended to cover the substitution of expressions, from the definition given on the Lambda calculus page. The matching of expressions should compare expressions for alpha equivalence (renaming of variables).  Lambda lifting in lambda calculus  Each lambda lift takes a lambda abstraction which is a sub expression of a lambda expression and replaces it by a function call (application) to a function that it creates. The free variables in the sub expression are the parameters to the function call.  Lambda lifts may be used on individual functions, in code refactoring , to make a function usable outside the scope in which it was written. Lambda lifts may also be repeated, until the expression has no lambda abstractions, in order to transform the program.  Lambda lift  A lift is given a sub-expression within an expression to lift to the top of that expression. The expression may be part of a larger program. This allows control of where the sub-expression is lifted to. The lambda lift operation used to perform a lift within a program is,       lambda  -  lift  -  op    [  S  ,  L  ,  P  ]   =  P   [  L  :=   lambda  -  lift    [  S  ,  L  ]   ]      fragments    lambda  lift  op    fragments  normal-[  S  normal-,  L  normal-,  P  normal-]    P   fragments  normal-[  L  assign    lambda  lift    fragments  normal-[  S  normal-,  L  normal-]   normal-]     \operatorname{lambda-lift-op}[S,L,P]=P[L:=\operatorname{lambda-lift}[S,L]]     The sub expression may be either a lambda abstraction, or a lambda abstraction applied to a parameter.  Two types of lift are possible.   Anonymous lift  Named lift   An anonymous lift has a lift expression which is a lambda abstraction only. It is regarded as defining an anonymous function. A name must be created for the function.  A named lift expression has a lambda abstraction applied to an expression. This lift is regarded as a named definition of a function.  Anonymous Lift  An anonymous lift takes a lambda abstraction (called S ). For S ;   Create a name for the function that will replace S (called V ). Make sure that the name identified by V has not been used.  Add parameters to V , for all the free variables in S , to create an expression G (see make-call ).   The lambda lift is the substitution of the lambda abstraction S for a function application, along with the addition of a definition for the function.       lambda  -  lift    [  S  ,  L  ]   ≡  let  V  :   de  -  lambda    [  G  =  S  ]   in  L   [  S  :=  G  ]      fragments    lambda  lift    fragments  normal-[  S  normal-,  L  normal-]    let  V  normal-:    de  lambda    fragments  normal-[  G   S  normal-]   in  L   fragments  normal-[  S  assign  G  normal-]     \operatorname{lambda-lift}[S,L]\equiv\operatorname{let}V:\operatorname{de-%
 lambda}[G=S]\operatorname{in}L[S:=G]     The new lambda expression has S substituted for G. Note that L[S:=G] means substitution of S for G in L . The function definitions has the function definition G = S added.  In the above rule G is the function application that is substituted for the expression S . It is defined by,      G  =    make  -  call    [  V  ,   FV   [  S  ]    ]        G     make  call   V   FV  S      G=\operatorname{make-call}[V,\operatorname{FV}[S]]     where V is the function name. It must be a new variable, i.e. a name not already used in the lambda expression,      V  ∉   vars   [    let  F    in  L    ]        V   vars     let  F    in  L       V\not\in\operatorname{vars}[\operatorname{let}F\operatorname{in}L]     where    vars   [  E  ]      vars  E    \operatorname{vars}[E]   is a meta function that returns the set of variables used in E .      Example for anonymous lift.       For example,      F  =   t  r  u  e       F    t  r  u  e     F=true         L  =  λ  f  .   (  λ  x  .   f    (   x   x  )   )    (  λ  x  .   f    (   x   x  )   )      fragments  L   λ  f  normal-.   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     L=\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))          S  =   λ  x    .    f    (    x   x   )       formulae-sequence    S    λ  x      f    x  x      S=\lambda x.f\ (x\ x)         G  =    p   f       G    p  f     G=p\ f          de  -  lambda    [   p   f  =  λ  x  .   f    (   x   x  )   ]   ≡   p    f   x  =   f    (   x   x  )      fragments    de  lambda    fragments  normal-[  p  f   λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-]    p  f  x   f   fragments  normal-(  x  x  normal-)     \operatorname{de-lambda}[p\ f=\lambda x.f\ (x\ x)]\equiv p\ f\ x=f\ (x\ x)   See de-lambda in Conversion from lambda to let expressions . The result is,       lambda  -  lift    [  λ  x  .   f    (   x   x  )   ,  let  t  r  u  e  in  λ  f  .   (  λ  x  .   f    (   x   x  )   )    (  λ  x  .   f    (   x   x  )   )   ]   ≡  let   p    f   x  =   f    (   x   x  )   in  λ  f  .   (   p   f  )    (   p   f  )      fragments    lambda  lift    fragments  normal-[  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-,  let  t  r  u  e  in  λ  f  normal-.   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-]    let  p  f  x   f   fragments  normal-(  x  x  normal-)   in  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)     \operatorname{lambda-lift}[\lambda x.f\ (x\ x),\operatorname{let}true%
 \operatorname{in}\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))]\equiv%
 \operatorname{let}p\ f\ x=f\ (x\ x)\operatorname{in}\lambda f.(p\ f)\ (p\ f)        Constructing the call  The function call G is constructed by adding parameters for each variable in the free variable set (represented by V ), to the function H ,       X  ∈  V  →    make  -  call    [  H  ,  V  ]    ≡     make  -  call    [  H  ,   V  ∩   ¬   {  X  }     ]    X         X  V    normal-→       make  call   H  V             make  call   H    V    X     X      X\in V\to\operatorname{make-call}[H,V]\equiv\operatorname{make-call}[H,V\cap%
 \neg\{X\}]\ X           make  -  call    [  H  ,   {  }   ]    ≡  H         make  call   H    H    \operatorname{make-call}[H,\{\}]\equiv H          Example of call construction.            S  =   λ  x    .    f    (    x   x   )       formulae-sequence    S    λ  x      f    x  x      S=\lambda x.f\ (x\ x)          FV   (  S  )    =   {  f  }        FV  S    f     \operatorname{FV}(S)=\{f\}         G  ≡    make  -  call    [  p  ,   FV   [  S  ]    ]    ≡    make  -  call    [  p  ,   {  f  }   ]    ≡     make  -  call    [  p  ,   {  }   ]    f   ≡    p   f         G     make  call   p   FV  S            make  call   p   f              make  call   p    f          p  f      G\equiv\operatorname{make-call}[p,\operatorname{FV}[S]]\equiv\operatorname{%
 make-call}[p,\{f\}]\equiv\operatorname{make-call}[p,\{\}]\ f\equiv p\ f        Named Lift  The named lift is similar to the anonymous lift except that the function name V is provided.       lambda  -  lift    [   (  λ  V  .  E  )   S  ,  L  ]   ≡  let  V  :   de  -  lambda    [  G  =  S  ]   in  L   [   (  λ  V  .  E  )   S  :=  E   [  V  :=  G  ]   ]      fragments    lambda  lift    fragments  normal-[   fragments  normal-(  λ  V  normal-.  E  normal-)   S  normal-,  L  normal-]    let  V  normal-:    de  lambda    fragments  normal-[  G   S  normal-]   in  L   fragments  normal-[   fragments  normal-(  λ  V  normal-.  E  normal-)   S  assign  E   fragments  normal-[  V  assign  G  normal-]   normal-]     \operatorname{lambda-lift}[(\lambda V.E)\ S,L]\equiv\operatorname{let}V:%
 \operatorname{de-lambda}[G=S]\operatorname{in}L[(\lambda V.E)\ S:=E[V:=G]]     As for the anonymous lift, the expression G is constructed from V by applying the free variables of S . It is defined by,      G  =    make  -  call    [  V  ,   FV   [  S  ]    ]        G     make  call   V   FV  S      G=\operatorname{make-call}[V,\operatorname{FV}[S]]         Example for named lift.       For example,      V  =  x      V  x    V=x         E  =    f    (    x   x   )        E    f    x  x      E=f\ (x\ x)         S  =   (  λ  x  .   f    (   x   x  )   )      fragments  S    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     S=(\lambda x.f\ (x\ x))         L  =  λ  f  .   (  λ  x  .   f    (   x   x  )   )    (  λ  x  .   f    (   x   x  )   )      fragments  L   λ  f  normal-.   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     L=\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))         G  =    x   f       G    x  f     G=x\ f         E   [  V  :=  G  ]   =   f    (   x   x  )    [  x  :=   x   f  ]   =   f    (   (   x   f  )    (   x   f  )   )      fragments  E   fragments  normal-[  V  assign  G  normal-]    f   fragments  normal-(  x  x  normal-)    fragments  normal-[  x  assign  x  f  normal-]    f   fragments  normal-(   fragments  normal-(  x  f  normal-)    fragments  normal-(  x  f  normal-)   normal-)     E[V:=G]=f\ (x\ x)[x:=x\ f]=f\ ((x\ f)\ (x\ f))         L   [   (  λ  V  .  E  )   F  :=  E   [  V  :=  G  ]   ]   =  L   [   (  λ  x  .   f    (   x   x  )   )    (  λ  x  .   f    (   x   x  )   )   :=   f    (   (   x   f  )    (   x   f  )   )   ]   =  λ  f  .   f    (   (   x   f  )    (   x   f  )   )      fragments  L   fragments  normal-[   fragments  normal-(  λ  V  normal-.  E  normal-)   F  assign  E   fragments  normal-[  V  assign  G  normal-]   normal-]    L   fragments  normal-[   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   assign  f   fragments  normal-(   fragments  normal-(  x  f  normal-)    fragments  normal-(  x  f  normal-)   normal-)   normal-]    λ  f  normal-.  f   fragments  normal-(   fragments  normal-(  x  f  normal-)    fragments  normal-(  x  f  normal-)   normal-)     L[(\lambda V.E)\ F:=E[V:=G]]=L[(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x)):=f%
 \ ((x\ f)\ (x\ f))]=\lambda f.f\ ((x\ f)\ (x\ f))          de  -  lambda    [   x   f  =  λ  y  .   f    (   y   y  )   ]   ≡   x    f   y  =   f    (   y   y  )      fragments    de  lambda    fragments  normal-[  x  f   λ  y  normal-.  f   fragments  normal-(  y  y  normal-)   normal-]    x  f  y   f   fragments  normal-(  y  y  normal-)     \operatorname{de-lambda}[x\ f=\lambda y.f\ (y\ y)]\equiv x\ f\ y=f\ (y\ y)   See de-lambda in Conversion from lambda to let expressions . The result is, gives,       lambda  -  lift    [   (  λ  x  .   f    (   x   x  )   )    (  λ  x  .   f    (   x   x  )   )   ,  λ  f  .   (  λ  x  .   f    (   x   x  )   )    (  λ  x  .   f    (   x   x  )   )   ]   ≡  let   x    f   y  =   f    (   y   y  )   in  λ  f  .   (   x   f  )    (   x   f  )      fragments    lambda  lift    fragments  normal-[   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-,  λ  f  normal-.   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-]    let  x  f  y   f   fragments  normal-(  y  y  normal-)   in  λ  f  normal-.   fragments  normal-(  x  f  normal-)    fragments  normal-(  x  f  normal-)     \operatorname{lambda-lift}[(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x)),%
 \lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))]\equiv\operatorname{let%
 }x\ f\ y=f\ (y\ y)\operatorname{in}\lambda f.(x\ f)\ (x\ f)        Lamba-lift transformation  A lambda lift transformation takes a lambda expression and lifts all lambda abstractions to the top of the expression. The abstractions are then translated into recursive functions , which eliminates the lambda abstractions. The result is a functional program in the form,        let  M    in  N        let  M    in  N     \operatorname{let}M\operatorname{in}N      where M is a series of function definitions, and N is the expression representing the value returned.  For example,       lambda  -  lift  -  tran    [  λ  f  .   (  λ  x  .   f    (   x   x  )   )    (  λ  x  .   f    (   x   x  )   )   ]   ≡  let   p    f   x  =   f    (   x   x  )   and   q    p   f  =   (   p   f  )    (   p   f  )   in   q   p     fragments    lambda  lift  tran    fragments  normal-[  λ  f  normal-.   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-]    let  p  f  x   f   fragments  normal-(  x  x  normal-)   and  q  p  f    fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   in  q  p    \operatorname{lambda-lift-tran}[\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f%
 \ (x\ x))]\equiv\operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)%
 \operatorname{in}q\ p     The de-let meta function may then be used to convert the result back into lambda calculus.       de  -  let    [   lambda  -  lift  -  tran    [  λ  f  .   (  λ  x  .   f    (   x   x  )   )    (  λ  x  .   f    (   x   x  )   )   ]   ]   ≡   (  λ  p  .   (  λ  q  .   q   p  )   λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )   λ  f  .  λ  x  .   f    (   x   x  )      fragments    de  let    fragments  normal-[    lambda  lift  tran    fragments  normal-[  λ  f  normal-.   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-]   normal-]     fragments  normal-(  λ  p  normal-.   fragments  normal-(  λ  q  normal-.  q  p  normal-)   λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)   λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)     \operatorname{de-let}[\operatorname{lambda-lift-tran}[\lambda f.(\lambda x.f\ %
 (x\ x))\ (\lambda x.f\ (x\ x))]]\equiv(\lambda p.(\lambda q.q\ p)\ \lambda p.%
 \lambda f.(p\ f)\ (p\ f))\ \lambda f.\lambda x.f\ (x\ x)     The processing of transforming the lambda expression is a series of lifts. Each lift has,   A sub expression chosen for it by the function lift-choice . The sub expression should be chosen so that it may be converted into an equation with no lambdas.  The lift is performed by a call to the lambda-lift meta function, described in the next section,          lambda  -  lift  -  tran    [  L  ]    =    drop  -  params  -  tran    [    merge  -  let    [    lambda  -  apply    [  L  ]    ]    ]           lambda  lift  tran   L      drop  params  tran      merge  let      lambda  apply   L       \operatorname{lambda-lift-tran}[L]=\operatorname{drop-params-tran}[%
 \operatorname{merge-let}[\operatorname{lambda-apply}[L]]]           lambda  -  apply    [  L  ]    =    lambda  -  process    [    lift  -  choice    [  L  ]    ,  L  ]           lambda  apply   L      lambda  process      lift  choice   L   L     \operatorname{lambda-apply}[L]=\operatorname{lambda-process}[\operatorname{%
 lift-choice}[L],L]           lambda  -  process    [  none  ,  L  ]    =  L         lambda  process   none  L   L    \operatorname{lambda-process}[\operatorname{none},L]=L           lambda  -  process    [  S  ,  L  ]    =    lambda  -  apply    [    lambda  -  lift    [  S  ,  L  ]    ]           lambda  process   S  L      lambda  apply      lambda  lift   S  L      \operatorname{lambda-process}[S,L]=\operatorname{lambda-apply}[\operatorname{%
 lambda-lift}[S,L]]      After the lifts are applied the lets are combined together into a single let.        merge  -  let    [     let  V   :   E    in  let   W     :   F   in  G     ]    =    merge  -  let    [   let  V   ,   W  :   E  and  F   in  G     ]           merge  let    normal-:   normal-:   let  V     E    in  let   W       F   in  G         merge  let    let  V    normal-:  W    E  italic- and  F   in  G        \operatorname{merge-let}[\operatorname{let}V:E\operatorname{in}\operatorname{%
 let}W:F\operatorname{in}G]=\operatorname{merge-let}[\operatorname{let}V,W:E%
 \and F\operatorname{in}G]           merge  -  let    [  E  ]    =  E         merge  let   E   E    \operatorname{merge-let}[E]=E     Then Parameter dropping is applied to remove parameters that are not necessary in the "let" expression. The let expression allows the function definitions to refer to each other directly, whereas lambda abstractions are strictly hierarchical, and a function may not directly refer to itself.  Choosing the expression for lifting  There are two different ways that an expression may be selected for lifting. The first treats all lambda abstractions as defining anonymous functions. The second, treats lambda abstractions which are applied to a parameter as defining a function. Lambda abstractions applied to a parameter have a dual interpretation as either a let expression defining a function, or as defining an anonymous function. Both interpretations are valid.  These two predicates are needed for both definitions.  lambda-free - An expression containing no lambda abstractions.       lambda  -  free    [  λ  F  .  X  ]   =  false     fragments    lambda  free    fragments  normal-[  λ  F  normal-.  X  normal-]    false    \operatorname{lambda-free}[\lambda F.X]=\operatorname{false}           lambda  -  free    [  V  ]    =  true         lambda  free   V   true    \operatorname{lambda-free}[V]=\operatorname{true}           lambda  -  free    [    M   N   ]    =      lambda  -  free    [  M  ]    and     lambda  -  free    [  N  ]            lambda  free     M  N          lambda  free   M   italic- and      lambda  free   N      \operatorname{lambda-free}[M\ N]=\operatorname{lambda-free}[M]\and%
 \operatorname{lambda-free}[N]     lambda-anon - An anonymous function. An expression like     λ   x  1    .    …   λ   x  n    .  X     formulae-sequence    λ   subscript  x  1      normal-…  λ   subscript  x  n    X    \lambda x_{1}.\ ...\ \lambda x_{n}.X   where X is lambda free.       lambda  -  anon    [  λ  F  .  X  ]   =   lambda  -  free    [  X  ]    lambda  -  anon    [  X  ]      fragments    lambda  anon    fragments  normal-[  λ  F  normal-.  X  normal-]      lambda  free    fragments  normal-[  X  normal-]     lambda  anon    fragments  normal-[  X  normal-]     \operatorname{lambda-anon}[\lambda F.X]=\operatorname{lambda-free}[X]%
 \operatorname{lambda-anon}[X]           lambda  -  anon    [  V  ]    =  false         lambda  anon   V   false    \operatorname{lambda-anon}[V]=\operatorname{false}           lambda  -  anon    [    M   N   ]    =  false         lambda  anon     M  N    false    \operatorname{lambda-anon}[M\ N]=\operatorname{false}     Choosing anonymous functions only for lifting  Search for the deepest anonymous abstraction, so that when the lift is applied the function lifted will become a simple equation. This definition does not recognize a lambda abstractions with a parameter as defining a function. All lambda abstractions are regarded as defining anonymous functions.  lift-choice - The first anonymous found in traversing the expression or none if there is no function.         lambda  -  anon    [  X  ]    →    lift  -  choice    [  X  ]    =  X       normal-→     lambda  anon   X      lift  choice   X        X     \operatorname{lambda-anon}[X]\to\operatorname{lift-choice}[X]=X          lift  -  choice    [  λ  F  .  X  ]   =   lift  -  choice    [  X  ]      fragments    lift  choice    fragments  normal-[  λ  F  normal-.  X  normal-]      lift  choice    fragments  normal-[  X  normal-]     \operatorname{lift-choice}[\lambda F.X]=\operatorname{lift-choice}[X]           lift  -  choice    [  M  ]    ≠  none  →    lift  -  choice    [    M   N   ]    =    lift  -  choice    [  M  ]             lift  choice   M   none    normal-→       lift  choice     M  N            lift  choice   M      \operatorname{lift-choice}[M]\neq\operatorname{none}\to\operatorname{lift-%
 choice}[M\ N]=\operatorname{lift-choice}[M]           lift  -  choice    [    M   N   ]    =    lift  -  choice    [  N  ]           lift  choice     M  N       lift  choice   N     \operatorname{lift-choice}[M\ N]=\operatorname{lift-choice}[N]           lift  -  choice    [  V  ]    =  none         lift  choice   V   none    \operatorname{lift-choice}[V]=\operatorname{none}      For example,      Lambda choice on    λ  f  .   (  λ  x  .   f    (   x   x  )   )    (  λ  y  .   f    (   y   y  )   )      fragments  λ  f  normal-.   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  y  normal-.  f   fragments  normal-(  y  y  normal-)   normal-)     \lambda f.(\lambda x.f\ (x\ x))\ (\lambda y.f\ (y\ y))   is     λ  x   .    f    (    x   x   )       formulae-sequence    λ  x     f    x  x      \lambda x.f\ (x\ x)        Rule     2     3     1            Lambda choice on     λ  f   .    (    p   f   )    (    p   f   )       formulae-sequence    λ  f       p  f     p  f      \lambda f.(p\ f)\ (p\ f)   is     λ  f   .    (    p   f   )    (    p   f   )       formulae-sequence    λ  f       p  f     p  f      \lambda f.(p\ f)\ (p\ f)        Rule     2     2     Choosing named and anonymous functions for lifting  Search for the deepest named or anonymous function definition, so that when the lift is applied the function lifted will become a simple equation. This definition recognizes a lambda abstraction with an actual parameter as defining a function. Only lambda abstractions without an application are treated as anonymous functions.  lambda-named - A named function. An expression like     (  λ  F  .  M  )   N     fragments   fragments  normal-(  λ  F  normal-.  M  normal-)   N    (\lambda F.M)\ N   where M is lambda free and N is lambda free or an anonymous function.       lambda  -  named    [   (  λ  F  .  M  )   N  ]   =   lambda  -  free    [  M  ]   and   lambda  -  anon    [  N  ]      fragments    lambda  named    fragments  normal-[   fragments  normal-(  λ  F  normal-.  M  normal-)   N  normal-]      lambda  free    fragments  normal-[  M  normal-]   and    lambda  anon    fragments  normal-[  N  normal-]     \operatorname{lambda-named}[(\lambda F.M)\ N]=\operatorname{lambda-free}[M]%
 \and\operatorname{lambda-anon}[N]          lambda  -  named    [  λ  F  .  X  ]   =  false     fragments    lambda  named    fragments  normal-[  λ  F  normal-.  X  normal-]    false    \operatorname{lambda-named}[\lambda F.X]=\operatorname{false}           lambda  -  named    [  V  ]    =  false         lambda  named   V   false    \operatorname{lambda-named}[V]=\operatorname{false}     lift-choice - The first anonymous or named function found in traversing the expression or none if there is no function.          lambda  -  named    [  X  ]      lambda  -  anon    [  X  ]     →    lift  -  choice    [  X  ]    =  X       normal-→       lambda  named   X      lambda  anon   X       lift  choice   X        X     \operatorname{lambda-named}[X]\operatorname{lambda-anon}[X]\to\operatorname{%
 lift-choice}[X]=X          lift  -  choice    [  λ  F  .  X  ]   =   lift  -  choice    [  X  ]      fragments    lift  choice    fragments  normal-[  λ  F  normal-.  X  normal-]      lift  choice    fragments  normal-[  X  normal-]     \operatorname{lift-choice}[\lambda F.X]=\operatorname{lift-choice}[X]           lift  -  choice    [  M  ]    ≠  none  →    lift  -  choice    [    M   N   ]    =    lift  -  choice    [  M  ]             lift  choice   M   none    normal-→       lift  choice     M  N            lift  choice   M      \operatorname{lift-choice}[M]\neq\operatorname{none}\to\operatorname{lift-%
 choice}[M\ N]=\operatorname{lift-choice}[M]           lift  -  choice    [    M   N   ]    =    lift  -  choice    [  N  ]           lift  choice     M  N       lift  choice   N     \operatorname{lift-choice}[M\ N]=\operatorname{lift-choice}[N]           lift  -  choice    [  V  ]    =  none         lift  choice   V   none    \operatorname{lift-choice}[V]=\operatorname{none}      For example,      Lambda choice on    λ  f  .   (  λ  x  .   f    (   x   x  )   )    (  λ  y  .   f    (   y   y  )   )      fragments  λ  f  normal-.   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  y  normal-.  f   fragments  normal-(  y  y  normal-)   normal-)     \lambda f.(\lambda x.f\ (x\ x))\ (\lambda y.f\ (y\ y))   is     (  λ  x  .   f    (   x   x  )   )    (  λ  y  .   f    (   y   y  )   )      fragments   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  y  normal-.  f   fragments  normal-(  y  y  normal-)   normal-)     (\lambda x.f\ (x\ x))\ (\lambda y.f\ (y\ y))        Rule     2     1            Lambda choice on     λ  f   .    f    (    (    x   f   )    (    x   f   )    )       formulae-sequence    λ  f     f      x  f     x  f       \lambda f.f\ ((x\ f)\ (x\ f))   is     λ  f   .    f    (    (    x   f   )    (    x   f   )    )       formulae-sequence    λ  f     f      x  f     x  f       \lambda f.f\ ((x\ f)\ (x\ f))        Rule     1        Examples  For example the Y combinator ,      λ  f  .   (  λ  x  .   f    (   x   x  )   )    (  λ  x  .   f    (   x   x  )   )      fragments  λ  f  normal-.   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     \lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))   is lifted as,       let    x    f   y    =    f    (    y   y   )   and   q    x   f   =    f    (    (    x   f   )    (    x   f   )    )    in    q   x            let    x  f  y      f    y  y   italic- and  q  x  f          f      x  f     x  f     in    q  x        \operatorname{let}x\ f\ y=f\ (y\ y)\and q\ x\ f=f\ ((x\ f)\ (x\ f))%
 \operatorname{in}q\ x   and after Parameter dropping ,       let    x    f   y    =    f    (    y   y   )   and   q   f   =    f    (    (    x   f   )    (    x   f   )    )    in  q           let    x  f  y      f    y  y   italic- and  q  f          f      x  f     x  f     in  q       \operatorname{let}x\ f\ y=f\ (y\ y)\and q\ f=f\ ((x\ f)\ (x\ f))\operatorname{%
 in}q   As a lambda expression (see Conversion from let to lambda expressions ),       (  λ  x  .   (  λ  q  .  q  )   λ  f  .   f    (   x   f  )    (   x   f  )   )   λ  f  .  λ  y  .   f    (   y   y  )      fragments   fragments  normal-(  λ  x  normal-.   fragments  normal-(  λ  q  normal-.  q  normal-)   λ  f  normal-.  f   fragments  normal-(  x  f  normal-)    fragments  normal-(  x  f  normal-)   normal-)   λ  f  normal-.  λ  y  normal-.  f   fragments  normal-(  y  y  normal-)     (\lambda x.(\lambda q.q)\ \lambda f.f\ (x\ f)\ (x\ f))\ \lambda f.\lambda y.f%
 \ (y\ y)         Lifting named and anonymous functions        1     2     3     4     5     If lifting anonymous functions only, the Y combinator is,       let    p    f   x    =    f    (    x   x   )   and   q    p   f   =    (    p   f   )    (    p   f   )    in    q   p            let    p  f  x      f    x  x   italic- and  q  p  f            p  f     p  f    in    q  p        \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in%
 }q\ p   and after Parameter dropping ,       let    p    f   x    =    f    (    x   x   )   and   q   f   =    (    p   f   )    (    p   f   )    in  q           let    p  f  x      f    x  x   italic- and  q  f            p  f     p  f    in  q       \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ f=(p\ f)\ (p\ f)\operatorname{in}q   As a lambda expression,       (  λ  p  .   (  λ  q  .  q  )   λ  f  .   (   p   f  )    (   p   f  )   )   λ  f  .  λ  x  .   f    (   x   x  )      fragments   fragments  normal-(  λ  p  normal-.   fragments  normal-(  λ  q  normal-.  q  normal-)   λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)   λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)     (\lambda p.(\lambda q.q)\ \lambda f.(p\ f)\ (p\ f))\ \lambda f.\lambda x.f\ (x%
 \ x)         Lifting anonymous functions only        1     2     3     4     5     The first sub expression to be chosen for lifting is     λ  x   .    f    (    x   x   )       formulae-sequence    λ  x     f    x  x      \lambda x.f\ (x\ x)   . This transforms the lambda expression into     λ  f   .    (    p   f   )    (    p   f   )       formulae-sequence    λ  f       p  f     p  f      \lambda f.(p\ f)\ (p\ f)   and creates the equation      p    f   x   =   f   (    x   x   )          p  f  x     f    x  x      p\ f\ x=f(x\ x)   .  The second sub expression to be chosen for lifting is     λ  f   .    (    p   f   )    (    p   f   )       formulae-sequence    λ  f       p  f     p  f      \lambda f.(p\ f)\ (p\ f)   . This transforms the lambda expression into     q   p      q  p    q\ p   and creates the equation      q    p   f   =    (    p   f   )    (    p   f   )          q  p  f       p  f     p  f      q\ p\ f=(p\ f)\ (p\ f)   .  And the result is,       let    p    f   x    =    f    (    x   x   )   and   q    p   f   =    (    p   f   )    (    p   f   )    in    q   p            let    p  f  x      f    x  x   italic- and  q  p  f            p  f     p  f    in    q  p        \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in%
 }q\ p     Surprisingly this result is simpler than the one obtained from lifting named functions.  Execution  Apply function to,     K   K   K             λ  f  .   (  λ  x  .   f    (   x   x  )   )    (  λ  x  .   f    (   x   x  )   )   K     fragments  λ  f  normal-.   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   K    \lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))\ K            let    p    f   x    =    f    (    x   x   )   and   q    p   f   =    (    p   f   )    (    p   f   )    in    q   p      K     formulae-sequence       let    p  f  x      f    x  x   italic- and  q  p  f            p  f     p  f    in    q  p       K    \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in%
 }q\ p\ \ K               (  λ  x  .   K    (   x   x  )   )    (  λ  x  .   K    (   x   x  )   )      fragments   fragments  normal-(  λ  x  normal-.  K   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  K   fragments  normal-(  x  x  normal-)   normal-)     (\lambda x.K\ (x\ x))\ (\lambda x.K\ (x\ x))           let    p    f   x    =    f    (    x   x   )   and   q    p   f   =    (    p   f   )    (    p   f   )    in    p    K      (    p   K   )           let    p  f  x      f    x  x   italic- and  q  p  f            p  f     p  f    in    p  K      p  K       \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in%
 }p\ K\ (p\ K)             K    (   (  λ  x  .   K    (   x   x  )   )    (  λ  x  .   K    (   x   x  )   )   )      fragments  K   fragments  normal-(   fragments  normal-(  λ  x  normal-.  K   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  K   fragments  normal-(  x  x  normal-)   normal-)   normal-)     K\ ((\lambda x.K\ (x\ x))\ (\lambda x.K\ (x\ x)))           let    p    f   x    =    f    (    x   x   )   and   q    p   f   =    p    f    (    p   f   )    in   K     (    p    K    (    p   K   )    )           let    p  f  x      f    x  x   italic- and  q  p  f          p  f    p  f    in  K     p  K    p  K        \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=p\ f\ (p\ f)\operatorname{in}K%
 \ (p\ K\ (p\ K))        So,        (  λ  x  .   K    (   x   x  )   )    (  λ  x  .   K    (   x   x  )   )   =   K    (   (  λ  x  .   K    (   x   x  )   )    (  λ  x  .   K    (   x   x  )   )   )   )     fragments   fragments  normal-(  λ  x  normal-.  K   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  K   fragments  normal-(  x  x  normal-)   normal-)    K   fragments  normal-(   fragments  normal-(  λ  x  normal-.  K   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  K   fragments  normal-(  x  x  normal-)   normal-)   normal-)   normal-)    (\lambda x.K\ (x\ x))\ (\lambda x.K\ (x\ x))=K\ ((\lambda x.K\ (x\ x))\ (%
 \lambda x.K\ (x\ x))))      or         p    K    (    p   K   )    =    K    (    p    K    (    p   K   )    )          p  K    p  K      K    p  K    p  K       p\ K\ (p\ K)=K\ (p\ K\ (p\ K))      The Y-Combinator calls its parameter (function) repeatedly on itself. The value is defined if the function has a fixed point . But the function will never terminate.  Lambda dropping in lambda calculus  Lambda dropping {{ cite book |  first1 = Olivier | last1 = Danvy | first2 = Ulrik P. | last2 = Schultz |  title = Lambda-Dropping: Transforming Recursive Equations into Programs with Block Structure | year=2001 | url= http://www.brics.dk/RS/99/27/BRICS-RS-99-27.pdf }}  is making the scope of functions smaller and using the context from the reduced scope to reduce the number of parameters to functions. Reducing the number of parameters makes functions easier to comprehend.  In the Lambda lifting section, a meta function for first lifting and then converting the resulting lambda expression into recursive equation was described. The Lamda Drop meta function performs the reverse by first converting recursive equations to lambda abstractions, and then dropping the resulting lambda expression, into the smallest scope which covers all references to the lambda abstraction.  Lambda dropping is performed in two steps,   Sinking  Parameter dropping   Lambda drop  A Lambda drop is applied to an expression which is part of a program. Dropping is controlled by a set of expressions from which the drop will be excluded.       lambda  -  drop  -  op    [  L  ,  P  ,  X  ]   =  P   [  L  :=   drop  -  params  -  tran    [   sink  -  test    [  L  ,  X  ]   ]   ]      fragments    lambda  drop  op    fragments  normal-[  L  normal-,  P  normal-,  X  normal-]    P   fragments  normal-[  L  assign    drop  params  tran    fragments  normal-[    sink  test    fragments  normal-[  L  normal-,  X  normal-]   normal-]   normal-]     \operatorname{lambda-drop-op}[L,P,X]=P[L:=\operatorname{drop-params-tran}[%
 \operatorname{sink-test}[L,X]]]   where,   L is the lambda abstraction to be dropped.  P is the program  X is a set of expressions to be excluded from dropping.   Lambda drop transformation  The lambda drop transformation sinks all abstractions in an expression. Sinking is excluded from expressions in a set of expressions,        lambda  -  drop  -  tran    [  L  ,  X  ]    =    drop  -  params  -  tran    [    sink  -  tran    [    de  -  let    [  L  ,  X  ]    ]    ]           lambda  drop  tran   L  X      drop  params  tran      sink  tran      de  let   L  X       \operatorname{lambda-drop-tran}[L,X]=\operatorname{drop-params-tran}[%
 \operatorname{sink-tran}[\operatorname{de-let}[L,X]]]   where,   L is the expression to be transformed.  X is a set of sub expressions to be excluded from the dropping.   sink-tran sinks each abstraction, starting from the innermost,       sink  -  tran    [   (  λ  N  .  B  )   Y  ,  X  ]   =   sink  -  test    [   (  λ  N  .   sink  -  tran    [  B  ]   )    sink  -  tran    [  Y  ]   ,  X  ]      fragments    sink  tran    fragments  normal-[   fragments  normal-(  λ  N  normal-.  B  normal-)   Y  normal-,  X  normal-]      sink  test    fragments  normal-[   fragments  normal-(  λ  N  normal-.    sink  tran    fragments  normal-[  B  normal-]   normal-)     sink  tran    fragments  normal-[  Y  normal-]   normal-,  X  normal-]     \operatorname{sink-tran}[(\lambda N.B)\ Y,X]=\operatorname{sink-test}[(\lambda
 N%
 .\operatorname{sink-tran}[B])\ \operatorname{sink-tran}[Y],X]          sink  -  tran    [  λ  N  .  B  ,  X  ]   =  λ  N  .   sink  -  tran    [  B  ,  X  ]      fragments    sink  tran    fragments  normal-[  λ  N  normal-.  B  normal-,  X  normal-]    λ  N  normal-.    sink  tran    fragments  normal-[  B  normal-,  X  normal-]     \operatorname{sink-tran}[\lambda N.B,X]=\lambda N.\operatorname{sink-tran}[B,X]           sink  -  tran    [    M   N   ,  X  ]    =     sink  -  tran    [  M  ,  X  ]      sink  -  tran    [  M  ,  X  ]            sink  tran     M  N   X        sink  tran   M  X      sink  tran   M  X      \operatorname{sink-tran}[M\ N,X]=\operatorname{sink-tran}[M,X]\ \operatorname{%
 sink-tran}[M,X]           sink  -  tran    [  V  ,  X  ]    =  V         sink  tran   V  X   V    \operatorname{sink-tran}[V,X]=V     Abstraction sinking  Sinking is moving a lambda abstraction inwards as far as possible such that it is still outside all references to the variable.  Application - 4 cases.      E  ∉  FV   [  G  ]   and  E  ∉  FV   [  H  ]   →  sink   [   (  λ  E  .   G   H  )   Y  ,  X  ]   =   G   H     fragments  E   FV   fragments  normal-[  G  normal-]   and  E   FV   fragments  normal-[  H  normal-]   normal-→  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  G  H  normal-)   Y  normal-,  X  normal-]    G  H    E\not\in\operatorname{FV}[G]\and E\not\in\operatorname{FV}[H]\to\operatorname{%
 sink}[(\lambda E.G\ H)\ Y,X]=G\ H         E  ∉  FV   [  G  ]   and  E  ∈  FV   [  H  ]   →  sink   [   (  λ  E  .   G   H  )   Y  ,  X  ]   =   sink  -  test    [   G    sink  -  test    [   (  λ  E  .  H  )   Y  ,  X  ]   ]      fragments  E   FV   fragments  normal-[  G  normal-]   and  E   FV   fragments  normal-[  H  normal-]   normal-→  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  G  H  normal-)   Y  normal-,  X  normal-]      sink  test    fragments  normal-[  G    sink  test    fragments  normal-[   fragments  normal-(  λ  E  normal-.  H  normal-)   Y  normal-,  X  normal-]   normal-]     E\not\in\operatorname{FV}[G]\and E\in\operatorname{FV}[H]\to\operatorname{sink%
 }[(\lambda E.G\ H)\ Y,X]=\operatorname{sink-test}[G\ \operatorname{sink-test}[%
 (\lambda E.H)\ Y,X]]         E  ∈  FV   [  G  ]   and  E  ∉  FV   [  H  ]   →  sink   [   (  λ  E  .   G   H  )   Y  ,  X  ]   =   (   sink  -  test    [   (  λ  E  .  G  )   Y  ,  X  ]   )   H     fragments  E   FV   fragments  normal-[  G  normal-]   and  E   FV   fragments  normal-[  H  normal-]   normal-→  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  G  H  normal-)   Y  normal-,  X  normal-]     fragments  normal-(    sink  test    fragments  normal-[   fragments  normal-(  λ  E  normal-.  G  normal-)   Y  normal-,  X  normal-]   normal-)   H    E\in\operatorname{FV}[G]\and E\not\in\operatorname{FV}[H]\to\operatorname{sink%
 }[(\lambda E.G\ H)\ Y,X]=(\operatorname{sink-test}[(\lambda E.G)\ Y,X])\ H         E  ∈  FV   [  G  ]   and  E  ∈  FV   [  H  ]   →  sink   [   (  λ  E  .   G   H  )   Y  ,  X  ]   =   (  λ  E  .   G   H  )   Y     fragments  E   FV   fragments  normal-[  G  normal-]   and  E   FV   fragments  normal-[  H  normal-]   normal-→  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  G  H  normal-)   Y  normal-,  X  normal-]     fragments  normal-(  λ  E  normal-.  G  H  normal-)   Y    E\in\operatorname{FV}[G]\and E\in\operatorname{FV}[H]\to\operatorname{sink}[(%
 \lambda E.G\ H)\ Y,X]=(\lambda E.G\ H)\ Y     Abstraction . Use renaming to insure that the variable names are all distinct.      V  ≠  W  →  sink   [   (  λ  V  .  λ  W  .  E  )   Y  ,  X  ]   =  λ  W  .   sink  -  test    [   (  λ  V  .  E  )   Y  ,  X  ]      fragments  V   W  normal-→  sink   fragments  normal-[   fragments  normal-(  λ  V  normal-.  λ  W  normal-.  E  normal-)   Y  normal-,  X  normal-]    λ  W  normal-.    sink  test    fragments  normal-[   fragments  normal-(  λ  V  normal-.  E  normal-)   Y  normal-,  X  normal-]     V\neq W\to\operatorname{sink}[(\lambda V.\lambda W.E)\ Y,X]=\lambda W.%
 \operatorname{sink-test}[(\lambda V.E)\ Y,X]     Variable - 2 cases.      E  ≠  V  →  sink   [   (  λ  E  .  V  )   Y  ,  X  ]   =  V     fragments  E   V  normal-→  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  V  normal-)   Y  normal-,  X  normal-]    V    E\neq V\to\operatorname{sink}[(\lambda E.V)\ Y,X]=V         E  =  V  →  sink   [   (  λ  E  .  V  )   Y  ,  X  ]   =  Y     fragments  E   V  normal-→  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  V  normal-)   Y  normal-,  X  normal-]    Y    E=V\to\operatorname{sink}[(\lambda E.V)\ Y,X]=Y     Sink test excludes expressions from dropping,      L  ∈  X  →    sink  -  test    [  L  ,  X  ]    =  L        L  X    normal-→       sink  test   L  X        L     L\in X\to\operatorname{sink-test}[L,X]=L         L  ∉  X  →    sink  -  test    [  L  ,  X  ]    =   sink   [  L  ,  X  ]          L  X    normal-→       sink  test   L  X         sink  L  X      L\not\in X\to\operatorname{sink-test}[L,X]=\operatorname{sink}[L,X]     Example      Example of sinking       For example,      Rule   Expression       de-let        sink  -  tran    [    de  -  let    [    let    p    f   x    =    f    (    x   x   )   and   q    p   f   =    (    p   f   )    (    p   f   )    in    q   p      ]    ]        sink  tran      de  let        let    p  f  x      f    x  x   italic- and  q  p  f            p  f     p  f    in    q  p          \operatorname{sink-tran}[\operatorname{de-let}[\operatorname{let}p\ f\ x=f\ (x%
 \ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in}q\ p]]        sink-tran        sink  -  tran    [   (  λ  p  .   (  λ  q  .   q   p  )    (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )   )    (  λ  f  .  λ  x  .   f    (   x   x  )   )   ]      fragments    sink  tran    fragments  normal-[   fragments  normal-(  λ  p  normal-.   fragments  normal-(  λ  q  normal-.  q  p  normal-)    fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)   normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-]     \operatorname{sink-tran}[(\lambda p.(\lambda q.q\ p)\ (\lambda p.\lambda f.(p%
 \ f)\ (p\ f)))\ (\lambda f.\lambda x.f\ (x\ x))]        Application          sink   [   (  λ  p  .  sink   [   (  λ  q  .   q   p  )    (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )   ]   )    (  λ  f  .  λ  x  .   f    (   x   x  )   )   ]      fragments  sink   fragments  normal-[   fragments  normal-(  λ  p  normal-.  sink   fragments  normal-[   fragments  normal-(  λ  q  normal-.  q  p  normal-)    fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)   normal-]   normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-]     \operatorname{sink}[(\lambda p.\operatorname{sink}[(\lambda q.q\ p)\ (\lambda p%
 .\lambda f.(p\ f)\ (p\ f))])\ (\lambda f.\lambda x.f\ (x\ x))]              sink   [   (  λ  q  .   q   p  )    (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )   ]      fragments  sink   fragments  normal-[   fragments  normal-(  λ  q  normal-.  q  p  normal-)    fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)   normal-]     \operatorname{sink}[(\lambda q.q\ p)\ (\lambda p.\lambda f.(p\ f)\ (p\ f))]            E  ∈  FV   [  G  ]   and  E  ∉  FV   [  H  ]   →  sink   [   (  λ  E  .   G   H  )   Y  ,  X  ]      fragments  E   FV   fragments  normal-[  G  normal-]   and  E   FV   fragments  normal-[  H  normal-]   normal-→  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  G  H  normal-)   Y  normal-,  X  normal-]     E\in\operatorname{FV}[G]\and E\not\in\operatorname{FV}[H]\to\operatorname{sink%
 }[(\lambda E.G\ H)\ Y,X]            E  =  q  ,  G  =  q  ,  H  =  p  ,  Y  =   (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )   ,  X  =   {  }      fragments  E   q  normal-,  G   q  normal-,  H   p  normal-,  Y    fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)   normal-,  X    fragments  normal-{  normal-}     E=q,G=q,H=p,Y=(\lambda p.\lambda f.(p\ f)\ (p\ f)),X=\{\}             (  sink   [   (  λ  E  .  G  )   Y  ,  X  ]   )   H     fragments   fragments  normal-(  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  G  normal-)   Y  normal-,  X  normal-]   normal-)   H    (\operatorname{sink}[(\lambda E.G)\ Y,X])\ H             (  sink   [   (  λ  q  .  q  )    (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )   ,  X  ]   )   p     fragments   fragments  normal-(  sink   fragments  normal-[   fragments  normal-(  λ  q  normal-.  q  normal-)    fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)   normal-,  X  normal-]   normal-)   p    (\operatorname{sink}[(\lambda q.q)\ (\lambda p.\lambda f.(p\ f)\ (p\ f)),X])\ p           Variable          sink   [   (  λ  p  .  sink   [   (  λ  q  .  q  )    (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )   ]   p  )    (  λ  f  .  λ  x  .   f    (   x   x  )   )   ]      fragments  sink   fragments  normal-[   fragments  normal-(  λ  p  normal-.  sink   fragments  normal-[   fragments  normal-(  λ  q  normal-.  q  normal-)    fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)   normal-]   p  normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-]     \operatorname{sink}[(\lambda p.\operatorname{sink}[(\lambda q.q)\ (\lambda p.%
 \lambda f.(p\ f)\ (p\ f))]\ p)\ (\lambda f.\lambda x.f\ (x\ x))]              sink   [   (  λ  q  .  q  )    (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )   ]      fragments  sink   fragments  normal-[   fragments  normal-(  λ  q  normal-.  q  normal-)    fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)   normal-]     \operatorname{sink}[(\lambda q.q)\ (\lambda p.\lambda f.(p\ f)\ (p\ f))]            E  =  V  →  sink   [   (  λ  E  .  V  )   Y  ,  X  ]      fragments  E   V  normal-→  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  V  normal-)   Y  normal-,  X  normal-]     E=V\to\operatorname{sink}[(\lambda E.V)\ Y,X]            E  =  q  ,  V  =  q  ,  Y  =   (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )   ,  X  =   {  }      fragments  E   q  normal-,  V   q  normal-,  Y    fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)   normal-,  X    fragments  normal-{  normal-}     E=q,V=q,Y=(\lambda p.\lambda f.(p\ f)\ (p\ f)),X=\{\}           Y   Y   Y            (    λ  p   .   λ  f   .    (    p   f   )    (    p   f   )     )     formulae-sequence    λ  p     λ  f       p  f     p  f      (\lambda p.\lambda f.(p\ f)\ (p\ f))           Application          sink   [   (  λ  p  .   (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )   p  )    (  λ  f  .  λ  x  .   f    (   x   x  )   )   ]      fragments  sink   fragments  normal-[   fragments  normal-(  λ  p  normal-.   fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)   p  normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-]     \operatorname{sink}[(\lambda p.(\lambda p.\lambda f.(p\ f)\ (p\ f))\ p)\ (%
 \lambda f.\lambda x.f\ (x\ x))]              E  ∉  FV   [  G  ]   and  E  ∈  FV   [  H  ]   →  sink   [   (  λ  E  .   G   H  )   Y  ,  X  ]      fragments  E   FV   fragments  normal-[  G  normal-]   and  E   FV   fragments  normal-[  H  normal-]   normal-→  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  G  H  normal-)   Y  normal-,  X  normal-]     E\not\in\operatorname{FV}[G]\and E\in\operatorname{FV}[H]\to\operatorname{sink%
 }[(\lambda E.G\ H)\ Y,X]            E  =  p  ,  G  =   (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )   ,  H  =  p  ,  Y  =   (  λ  f  .  λ  x  .   f    (   x   x  )   )      fragments  E   p  normal-,  G    fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)   normal-,  H   p  normal-,  Y    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     E=p,G=(\lambda p.\lambda f.(p\ f)\ (p\ f)),H=p,Y=(\lambda f.\lambda x.f\ (x\ x))            sink   [   G   sink   [   (  λ  E  .  H  )   Y  ,  X  ]   ]      fragments  sink   fragments  normal-[  G  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  H  normal-)   Y  normal-,  X  normal-]   normal-]     \operatorname{sink}[G\ \operatorname{sink}[(\lambda E.H)\ Y,X]]               Variable          sink   [   (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )    sink  -  test    [   (  λ  p  .  p  )    (  λ  f  .  λ  x  .   f    (   x   x  )   )   ,  X  ]   ]      fragments  sink   fragments  normal-[   fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)     sink  test    fragments  normal-[   fragments  normal-(  λ  p  normal-.  p  normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-,  X  normal-]   normal-]     \operatorname{sink}[(\lambda p.\lambda f.(p\ f)\ (p\ f))\ \operatorname{sink-%
 test}[(\lambda p.p)\ (\lambda f.\lambda x.f\ (x\ x)),X]]              sink   [   (  λ  p  .  p  )    (  λ  f  .  λ  x  .   f    (   x   x  )   )   ,  X  ]      fragments  sink   fragments  normal-[   fragments  normal-(  λ  p  normal-.  p  normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-,  X  normal-]     \operatorname{sink}[(\lambda p.p)\ (\lambda f.\lambda x.f\ (x\ x)),X]            E  =  V  →  sink   [   (  λ  E  .  V  )   Y  ,  X  ]      fragments  E   V  normal-→  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  V  normal-)   Y  normal-,  X  normal-]     E=V\to\operatorname{sink}[(\lambda E.V)\ Y,X]            E  =  p  ,  V  =  p  ,  Y  =   (  λ  f  .  λ  x  .   f    (   x   x  )   )   ,  X  =   {  }      fragments  E   p  normal-,  V   p  normal-,  Y    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-,  X    fragments  normal-{  normal-}     E=p,V=p,Y=(\lambda f.\lambda x.f\ (x\ x)),X=\{\}           Y   Y   Y            (    λ  f   .   λ  x   .    f    (    x   x   )     )     formulae-sequence    λ  f     λ  x     f    x  x      (\lambda f.\lambda x.f\ (x\ x))           Abstraction          sink   [   (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )    (  λ  f  .  λ  x  .   f    (   x   x  )   )   ]      fragments  sink   fragments  normal-[   fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-]     \operatorname{sink}[(\lambda p.\lambda f.(p\ f)\ (p\ f))\ (\lambda f.\lambda x%
 .f\ (x\ x))]              V  ≠  W  →  sink   [   (  λ  V  .  λ  W  .  E  )   Y  ,  X  ]      fragments  V   W  normal-→  sink   fragments  normal-[   fragments  normal-(  λ  V  normal-.  λ  W  normal-.  E  normal-)   Y  normal-,  X  normal-]     V\neq W\to\operatorname{sink}[(\lambda V.\lambda W.E)\ Y,X]            V  =  p  ,  W  =  f  ,  E  =   (   p   f  )    (   p   f  )   ,  Y  =   (  λ  f  .  λ  x  .   f    (   x   x  )   )      fragments  V   p  normal-,  W   f  normal-,  E    fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-,  Y    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     V=p,W=f,E=(p\ f)\ (p\ f),Y=(\lambda f.\lambda x.f\ (x\ x))            λ  W  .  sink   [   (  λ  V  .  E  )   Y  ,  X  ]      fragments  λ  W  normal-.  sink   fragments  normal-[   fragments  normal-(  λ  V  normal-.  E  normal-)   Y  normal-,  X  normal-]     \lambda W.\operatorname{sink}[(\lambda V.E)\ Y,X]           Application          λ  f  .  sink   [   (  λ  p  .   (   p   f  )    (   p   f  )   )    (  λ  f  .  λ  x  .   f    (   x   x  )   )   ,  X  ]      fragments  λ  f  normal-.  sink   fragments  normal-[   fragments  normal-(  λ  p  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-,  X  normal-]     \lambda f.\operatorname{sink}[(\lambda p.(p\ f)\ (p\ f))\ (\lambda f.\lambda x%
 .f\ (x\ x)),X]              sink   [   (  λ  p  .   (   p   f  )    (   p   f  )   )    (  λ  f  .  λ  x  .   f    (   x   x  )   )   ,  X  ]      fragments  sink   fragments  normal-[   fragments  normal-(  λ  p  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-,  X  normal-]     \operatorname{sink}[(\lambda p.(p\ f)\ (p\ f))\ (\lambda f.\lambda x.f\ (x\ x)%
 ),X]            E  ∈  FV   [  G  ]   and  E  ∈  FV   [  H  ]   →  sink   [   (  λ  E  .   G   H  )   Y  ,  X  ]      fragments  E   FV   fragments  normal-[  G  normal-]   and  E   FV   fragments  normal-[  H  normal-]   normal-→  sink   fragments  normal-[   fragments  normal-(  λ  E  normal-.  G  H  normal-)   Y  normal-,  X  normal-]     E\in\operatorname{FV}[G]\and E\in\operatorname{FV}[H]\to\operatorname{sink}[(%
 \lambda E.G\ H)\ Y,X]            E  =  p  ,  G  =   (   p   f  )   ,  H  =   (   p   f  )   ,  Y  =   (  λ  f  .  λ  x  .   f    (   x   x  )   )      fragments  E   p  normal-,  G    fragments  normal-(  p  f  normal-)   normal-,  H    fragments  normal-(  p  f  normal-)   normal-,  Y    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     E=p,G=(p\ f),H=(p\ f),Y=(\lambda f.\lambda x.f\ (x\ x))             (  λ  E  .   G   H  )   Y     fragments   fragments  normal-(  λ  E  normal-.  G  H  normal-)   Y    (\lambda E.G\ H)\ Y             (  λ  p  .   (   p   f  )    (   p   f  )   )    (  λ  f  .  λ  x  .   f    (   x   x  )   )      fragments   fragments  normal-(  λ  p  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     (\lambda p.(p\ f)\ (p\ f))\ (\lambda f.\lambda x.f\ (x\ x))                λ  f  .   (  λ  p  .   (   p   f  )    (   p   f  )   )    (  λ  f  .  λ  x  .   f    (   x   x  )   )      fragments  λ  f  normal-.   fragments  normal-(  λ  p  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     \lambda f.(\lambda p.(p\ f)\ (p\ f))\ (\lambda f.\lambda x.f\ (x\ x))           Parameter dropping  Parameter dropping is optimizing a function for its position in the function. Lambda lifting added parameters that were necessary so that a function can be moved out of its context. In dropping, this process is reversed, and extra parameters that contain variables that are free may be removed.  Dropping a parameter is removing an unnecessary parameter from a function, where the actual parameter being passed in is always the same expression. The free variables of the expression must also be free where the function is defined. In this case the parameter that is dropped is replaced by the expression in the body of the function definition. This makes the parameter unnecessary.  For example, consider,      λ  m  ,  p  ,  q  .   (  λ  g  .  λ  n  .   (   n    (   g    m    p   n  )    (   g    q    p   n  )   )   )   λ  x  .  λ  o  .  λ  y  .   o    x   y     fragments  λ  m  normal-,  p  normal-,  q  normal-.   fragments  normal-(  λ  g  normal-.  λ  n  normal-.   fragments  normal-(  n   fragments  normal-(  g  m  p  n  normal-)    fragments  normal-(  g  q  p  n  normal-)   normal-)   normal-)   λ  x  normal-.  λ  o  normal-.  λ  y  normal-.  o  x  y    \lambda m,p,q.(\lambda g.\lambda n.(n\ (g\ m\ p\ n)\ (g\ q\ p\ n)))\ \lambda x%
 .\lambda o.\lambda y.o\ x\ y     In this example the actual parameter for the formal parameter o is always p . As p is a free variable in the whole expression, the parameter may be dropped. The actual parameter for the formal parameter y is always n . However n is bound in a lambda abstraction. So this parameter may not be dropped.  The result of dropping the parameter is,       drop  -  params  -  tran    [  λ  m  ,  p  ,  q  .   (  λ  g  .  λ  n  .   n    (   g    m    p   n  )    (   g    q    p   n  )   )   λ  x  .  λ  o  .  λ  y  .   o    x   y      fragments    drop  params  tran    fragments  normal-[  λ  m  normal-,  p  normal-,  q  normal-.   fragments  normal-(  λ  g  normal-.  λ  n  normal-.  n   fragments  normal-(  g  m  p  n  normal-)    fragments  normal-(  g  q  p  n  normal-)   normal-)   λ  x  normal-.  λ  o  normal-.  λ  y  normal-.  o  x  y     \operatorname{drop-params-tran}[\lambda m,p,q.(\lambda g.\lambda n.n\ (g\ m\ p%
 \ n)\ (g\ q\ p\ n))\ \lambda x.\lambda o.\lambda y.o\ x\ y           ≡  λ  m  ,  p  ,  q  .   (  λ  g  .  λ  n  .   n    (   g    m   n  )    (   g    q   n  )   )   λ  x  .  λ  y  .   p    x   y     fragments   λ  m  normal-,  p  normal-,  q  normal-.   fragments  normal-(  λ  g  normal-.  λ  n  normal-.  n   fragments  normal-(  g  m  n  normal-)    fragments  normal-(  g  q  n  normal-)   normal-)   λ  x  normal-.  λ  y  normal-.  p  x  y    \equiv\lambda m,p,q.(\lambda g.\lambda n.n\ (g\ m\ n)\ (g\ q\ n))\ \lambda x.%
 \lambda y.p\ x\ y        For the main example,       drop  -  params  -  tran    [  λ  f  .   (  λ  p  .   (   p   f  )    (   p   f  )   )    (  λ  f  .  λ  x  .   f    (   x   x  )   )   ]      fragments    drop  params  tran    fragments  normal-[  λ  f  normal-.   fragments  normal-(  λ  p  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-]     \operatorname{drop-params-tran}[\lambda f.(\lambda p.(p\ f)\ (p\ f))\ (\lambda
 f%
 .\lambda x.f\ (x\ x))]           ≡  λ  f  .   (  λ  p  .   p   p  )    (  λ  x  .   f    (   x   x  )   )      fragments   λ  f  normal-.   fragments  normal-(  λ  p  normal-.  p  p  normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     \equiv\lambda f.(\lambda p.p\ p)\ (\lambda x.f\ (x\ x))        The definition of drop-params-tran is,        drop  -  params  -  tran    [  L  ]    ≡   (    drop  -  params    [  L  ,  D  ,   F  V   [  L  ]    ,   [  ]   ]    )          drop  params  tran   L      drop  params   L  D    F  V   delimited-[]  L        \operatorname{drop-params-tran}[L]\equiv(\operatorname{drop-params}[L,D,FV[L],%
 []])   where,       build  -  param  -  list    [  L  ,  D  ,  V  ,  _  ]        build  param  list   L  D  V  normal-_    \operatorname{build-param-list}[L,D,V,\_]     Build parameter lists  For each abstraction that defines a function, build the information required to make decisions on dropping names. This information describes each parameter; the parameter name, the expression for the actual value, and an indication that all the expressions have the same value.  For example in,      λ  m  ,  p  ,  q  .   (  λ  g  .  λ  n  .   (   n    (   g    m    p   n  )    (   g    q    p   n  )   )   )   λ  x  .  λ  o  .  λ  y  .   o    x   y     fragments  λ  m  normal-,  p  normal-,  q  normal-.   fragments  normal-(  λ  g  normal-.  λ  n  normal-.   fragments  normal-(  n   fragments  normal-(  g  m  p  n  normal-)    fragments  normal-(  g  q  p  n  normal-)   normal-)   normal-)   λ  x  normal-.  λ  o  normal-.  λ  y  normal-.  o  x  y    \lambda m,p,q.(\lambda g.\lambda n.(n\ (g\ m\ p\ n)\ (g\ q\ p\ n)))\ \lambda x%
 .\lambda o.\lambda y.o\ x\ y     the parameters to the function g are,      Formal Parameter   All Same Value   Actual parameter expression       x   false   _     o   true   p     y   true   n     Each abstraction is renamed with a unique name, and the parameter list is associated with the name of the abstraction. For example, g there is parameter list.       D   [  g  ]    =   [   [  x  ,  false  ,  _  ]   ,   [  o  ,  _  ,  p  ]   ,   [  y  ,  _  ,  n  ]   ]         D   delimited-[]  g      x  false  normal-_    o  normal-_  p    y  normal-_  n      D[g]=[[x,\operatorname{false},\_],[o,\_,p],[y,\_,n]]     build-param-lists builds all the lists for an expression, by traversing the expression. It has four parameters;   The lambda expression being analyzed.  The table parameter lists for names.  The table of values for parameters.  The returned parameter list, which is used internally by the   Abstraction - A lambda expression of the form     (  λ  N  .  S  )   L     fragments   fragments  normal-(  λ  N  normal-.  S  normal-)   L    (\lambda N.S)\ L   is analyzed to extract the names of parameters for the function.       build  -  param  -  lists    [   (  λ  N  .  S  )   L  ,  D  ,  V  ,  R  ]   ≡   build  -  param  -  lists    [  S  ,  D  ,  V  ,  R  ]   and   build  -  list    [  L  ,  D  ,  V  ,  D   [  N  ]   ]      fragments    build  param  lists    fragments  normal-[   fragments  normal-(  λ  N  normal-.  S  normal-)   L  normal-,  D  normal-,  V  normal-,  R  normal-]      build  param  lists    fragments  normal-[  S  normal-,  D  normal-,  V  normal-,  R  normal-]   and    build  list    fragments  normal-[  L  normal-,  D  normal-,  V  normal-,  D   fragments  normal-[  N  normal-]   normal-]     \operatorname{build-param-lists}[(\lambda N.S)\ L,D,V,R]\equiv\operatorname{%
 build-param-lists}[S,D,V,R]\and\operatorname{build-list}[L,D,V,D[N]]          build  -  param  -  lists    [  λ  N  .  S  ,  D  ,  V  ,  R  ]   ≡   build  -  param  -  lists    [  S  ,  D  ,  V  ,  R  ]      fragments    build  param  lists    fragments  normal-[  λ  N  normal-.  S  normal-,  D  normal-,  V  normal-,  R  normal-]      build  param  lists    fragments  normal-[  S  normal-,  D  normal-,  V  normal-,  R  normal-]     \operatorname{build-param-lists}[\lambda N.S,D,V,R]\equiv\operatorname{build-%
 param-lists}[S,D,V,R]     Locate the name and start building the parameter list for the name, filling in the formal parameter names. Also receive any actual parameter list from the body of the expression, and return it as the actual parameter list from this expression       build  -  list    [  λ  P  .  B  ,  D  ,  V  ,   [  X  ,  _  ,  _  ]   :  :  L  ]   ≡   build  -  list    [  B  ,  D  ,  V  ,  L  ]      fragments    build  list    fragments  normal-[  λ  P  normal-.  B  normal-,  D  normal-,  V  normal-,   fragments  normal-[  X  normal-,  _  normal-,  _  normal-]   normal-:  normal-:  L  normal-]      build  list    fragments  normal-[  B  normal-,  D  normal-,  V  normal-,  L  normal-]     \operatorname{build-list}[\lambda P.B,D,V,[X,\_,\_]::L]\equiv\operatorname{%
 build-list}[B,D,V,L]           build  -  list    [  B  ,  D  ,  V  ,   [  ]   ]    ≡    build  -  param  -  lists    [  B  ,  D  ,  V  ,  _  ]           build  list   B  D  V       build  param  lists   B  D  V  normal-_     \operatorname{build-list}[B,D,V,[]]\equiv\operatorname{build-param-lists}[B,D,%
 V,\_]     Variable - A call to a function.       build  -  param  -  lists    [  N  ,  D  ,  V  ,   D   [  N  ]    ]        build  param  lists   N  D  V    D   delimited-[]  N      \operatorname{build-param-lists}[N,D,V,D[N]]     For a function name or parameter start populating actual parameter list by outputting the parameter list for this name.  Application - An application (function call) is processed to extract actual parameter details.        build  -  param  -  lists    [    E   P   ,  D  ,  V  ,  R  ]    ≡     build  -  param  -  lists    [  E  ,  D  ,  V  ,  T  ]    and    build  -  param  -  lists    [  P  ,  D  ,  V  ,  K  ]            build  param  lists     E  P   D  V  R        build  param  lists   E  D  V  T   italic- and     build  param  lists   P  D  V  K      \operatorname{build-param-lists}[E\ P,D,V,R]\equiv\operatorname{build-param-%
 lists}[E,D,V,T]\and\operatorname{build-param-lists}[P,D,V,K]           and  T  =   [  F  ,  S  ,  A  ]   :  :  R  and   (  S  ⟹   (  equate   [  A  ,  P  ]   and  V   [  F  ]   =  A  )   )   and  D   [  F  ]   =  K     fragments  and  T    fragments  normal-[  F  normal-,  S  normal-,  A  normal-]   normal-:  normal-:  R  and   fragments  normal-(  S    fragments  normal-(  equate   fragments  normal-[  A  normal-,  P  normal-]   and  V   fragments  normal-[  F  normal-]    A  normal-)   normal-)   and  D   fragments  normal-[  F  normal-]    K    \and T=[F,S,A]::R\and(S\implies(\operatorname{equate}[A,P]\and V[F]=A))\and D[%
 F]=K        Retrieve the parameter lists for the expression, and the parameter. Retrieve a parameter record from the parameter list from the expression, and check that the current parameter value matches this parameter. Record the value for the parameter name for use later in checking.      equate   [  A  ,  N  ]   ≡  A  =  N   (  def   [  V   [  N  ]   ]   and  A  =  V   [  N  ]   )      fragments  equate   fragments  normal-[  A  normal-,  N  normal-]    A   N   fragments  normal-(  def   fragments  normal-[  V   fragments  normal-[  N  normal-]   normal-]   and  A   V   fragments  normal-[  N  normal-]   normal-)     \operatorname{equate}[A,N]\equiv A=N(\operatorname{def}[V[N]]\and A=V[N])   ... if N is a variable.       equate   [  A  ,  E  ]    ≡  A  =  E         equate  A  E   A       E     \operatorname{equate}[A,E]\equiv A=E   ... otherwise.  The above logic is quite subtle in the way that it works. The same value indicator is never set to true. It is only set to false if all the values cannot be matched. The value is retrieved by using S to build a set of the Boolean values allowed for S . If true is a member then all the values for this parameter are equal, and the parameter may be dropped.       ask   [  S  ]    ≡  S  ∈   {  X  :   X  =  S   }          ask  S   S        conditional-set  X    X  S       \operatorname{ask}[S]\equiv S\in\{X:X=S\}     Similarly, def uses set theory to query if a variable has been given a value;       def   [  F  ]    ≡   |   {  X  :   X  =  F   }   |        def  F      conditional-set  X    X  F       \operatorname{def}[F]\equiv|\{X:X=F\}|     Let - Let expression.        build  -  param  -  list    [    let  V   :    E   in  L    ,  D  ,  V  ,  _    ]    ≡     build  -  param  -  list    [  E  ,  D  ,  V  ,  _  ]    and    build  -  param  -  list    [  L  ,  D  ,  V  ,  _  ]            build  param  list    normal-:   let  V      E   in  L    D  V  normal-_          build  param  list   E  D  V  normal-_   italic- and     build  param  list   L  D  V  normal-_      \operatorname{build-param-list}[\operatorname{let}V:E\operatorname{in}L,D,V,\_%
 ]\equiv\operatorname{build-param-list}[E,D,V,\_]\and\operatorname{build-param-%
 list}[L,D,V,\_]     And - For use in "let".        build  -  param  -  lists    [   E  and  F   ,  D  ,  V  ,  _  ]    ≡     build  -  param  -  lists    [  E  ,  D  ,  V  ,  _  ]    and    build  -  param  -  lists    [  F  ,  D  ,  V  ,  _  ]            build  param  lists     E  italic- and  F   D  V  normal-_        build  param  lists   E  D  V  normal-_   italic- and     build  param  lists   F  D  V  normal-_      \operatorname{build-param-lists}[E\and F,D,V,\_]\equiv\operatorname{build-%
 param-lists}[E,D,V,\_]\and\operatorname{build-param-lists}[F,D,V,\_]     Examples  For example building the parameter lists for,      λ  m  ,  p  ,  q  .   (  λ  g  .  λ  n  .   (   n    (   g    m    p   n  )    (   g    q    p   n  )   )   )   λ  x  .  λ  o  .  λ  y  .   o    x   y     fragments  λ  m  normal-,  p  normal-,  q  normal-.   fragments  normal-(  λ  g  normal-.  λ  n  normal-.   fragments  normal-(  n   fragments  normal-(  g  m  p  n  normal-)    fragments  normal-(  g  q  p  n  normal-)   normal-)   normal-)   λ  x  normal-.  λ  o  normal-.  λ  y  normal-.  o  x  y    \lambda m,p,q.(\lambda g.\lambda n.(n\ (g\ m\ p\ n)\ (g\ q\ p\ n)))\ \lambda x%
 .\lambda o.\lambda y.o\ x\ y   gives,       D   [  g  ]    =   [   [  x  ,  false  ,  _  ]   ,   [  o  ,  true  ,  p  ]   ,   [  y  ,  true  ,  n  ]   ]         D   delimited-[]  g      x  false  normal-_    o  true  p    y  true  n      D[g]=[[x,\operatorname{false},\_],[o,\operatorname{true},p],[y,\operatorname{%
 true},n]]   and the parameter o is dropped to give,      λ  m  ,  p  ,  q  .   (  λ  g  .  λ  n  .   (   n    (   g    m   n  )    (   g    q   n  )   )   )   λ  x  .  λ  y  .   p    x   y     fragments  λ  m  normal-,  p  normal-,  q  normal-.   fragments  normal-(  λ  g  normal-.  λ  n  normal-.   fragments  normal-(  n   fragments  normal-(  g  m  n  normal-)    fragments  normal-(  g  q  n  normal-)   normal-)   normal-)   λ  x  normal-.  λ  y  normal-.  p  x  y    \lambda m,p,q.(\lambda g.\lambda n.(n\ (g\ m\ n)\ (g\ q\ n)))\ \lambda x.%
 \lambda y.p\ x\ y         Build parameter list for    λ  m  ,  p  ,  q  .   (  λ  g  .  λ  n  .   (   n    (   g    m    p   n  )    (   g    q    p   n  )   )   )   λ  x  .  λ  o  .  λ  y  .   o    x   y     fragments  λ  m  normal-,  p  normal-,  q  normal-.   fragments  normal-(  λ  g  normal-.  λ  n  normal-.   fragments  normal-(  n   fragments  normal-(  g  m  p  n  normal-)    fragments  normal-(  g  q  p  n  normal-)   normal-)   normal-)   λ  x  normal-.  λ  o  normal-.  λ  y  normal-.  o  x  y    \lambda m,p,q.(\lambda g.\lambda n.(n\ (g\ m\ p\ n)\ (g\ q\ p\ n)))\ \lambda x%
 .\lambda o.\lambda y.o\ x\ y          Build parameter list example             build  -  param  -  list    [  λ  m  ,  p  ,  q  .   (  λ  g  .  λ  n  .   (   n    (   g    m    p   n  )    (   g    q    p   n  )   )   )   λ  x  .  λ  o  .  λ  y  .   o    x   y  ,  D  ,  V  ,  _  ]      fragments    build  param  list    fragments  normal-[  λ  m  normal-,  p  normal-,  q  normal-.   fragments  normal-(  λ  g  normal-.  λ  n  normal-.   fragments  normal-(  n   fragments  normal-(  g  m  p  n  normal-)    fragments  normal-(  g  q  p  n  normal-)   normal-)   normal-)   λ  x  normal-.  λ  o  normal-.  λ  y  normal-.  o  x  y  normal-,  D  normal-,  V  normal-,  _  normal-]     \operatorname{build-param-list}[\lambda m,p,q.(\lambda g.\lambda n.(n\ (g\ m\ %
 p\ n)\ (g\ q\ p\ n)))\ \lambda x.\lambda o.\lambda y.o\ x\ y,D,V,\_]        Rule     Abstraction     Abstraction                 build  -  list    [  λ  x  .  λ  o  .  λ  y  .   o    x   y  ,  D  ,  V  ,  D   [  g  ]   ]      fragments    build  list    fragments  normal-[  λ  x  normal-.  λ  o  normal-.  λ  y  normal-.  o  x  y  normal-,  D  normal-,  V  normal-,  D   fragments  normal-[  g  normal-]   normal-]     \operatorname{build-list}[\lambda x.\lambda o.\lambda y.o\ x\ y,D,V,D[g]]        Rule     Add param     Add param     Add param     End list                 build  -  param  -  lists    [    n    (    g    m    p   n   )    (    g    q    p   n   )    ,  D  ,  V  ,  R  ]        build  param  lists     n    g  m  p  n     g  q  p  n    D  V  R    \operatorname{build-param-lists}[n\ (g\ m\ p\ n)\ (g\ q\ p\ n),D,V,R]        Rule     Application     Application     Variable     Variable     Gives,      D   [  n  ]   =   [  _  ,  _  ,   g    m    p   n  ]   :  :   [  _  ,  _  ,   g    q    p   n  ]   :  :  R     fragments  D   fragments  normal-[  n  normal-]     fragments  normal-[  _  normal-,  _  normal-,  g  m  p  n  normal-]   normal-:  normal-:   fragments  normal-[  _  normal-,  _  normal-,  g  q  p  n  normal-]   normal-:  normal-:  R    D[n]=[\_,\_,g\ m\ p\ n]::[\_,\_,g\ q\ p\ n]::R              build  -  param  -  lists    [    g    m    p   n   ,  D  ,  V  ,   K  2   ]        build  param  lists     g  m  p  n   D  V   subscript  K  2     \operatorname{build-param-lists}[g\ m\ p\ n,D,V,K_{2}]        Rule     application        application, Variable     application, Variable     Variable              build  -  param  -  lists    [    g    q    p   n   ,  D  ,  V  ,   K  1   ]        build  param  lists     g  q  p  n   D  V   subscript  K  1     \operatorname{build-param-lists}[g\ q\ p\ n,D,V,K_{1}]        Rule     application        application, Variable     application, Variable     Variable     As there are no definitions for,     V   [  n  ]    ,   V   [  p  ]    ,   V   [  q  ]    ,   V   [  m  ]         V   delimited-[]  n      V   delimited-[]  p      V   delimited-[]  q      V   delimited-[]  m      V[n],V[p],V[q],V[m]   , then equate can be simplified to,      equate   [  A  ,  N  ]   ≡  A  =  N   (  def   [  V   [  N  ]   ]   and  A  =  V   [  N  ]   )   ≡  A  =  N     fragments  equate   fragments  normal-[  A  normal-,  N  normal-]    A   N   fragments  normal-(  def   fragments  normal-[  V   fragments  normal-[  N  normal-]   normal-]   and  A   V   fragments  normal-[  N  normal-]   normal-)    A   N    \operatorname{equate}[A,N]\equiv A=N(\operatorname{def}[V[N]]\and A=V[N])%
 \equiv A=N     By removing expressions not needed,    D   [  g  ]   =   [  x  ,   S  5   ,   A  5   ]   :  :   [  o  ,   S  4   ,   A  4   ]   :  :   [  y  ,   S  3   ,   A  3   ]   :  :   K  2      fragments  D   fragments  normal-[  g  normal-]     fragments  normal-[  x  normal-,   subscript  S  5   normal-,   subscript  A  5   normal-]   normal-:  normal-:   fragments  normal-[  o  normal-,   subscript  S  4   normal-,   subscript  A  4   normal-]   normal-:  normal-:   fragments  normal-[  y  normal-,   subscript  S  3   normal-,   subscript  A  3   normal-]   normal-:  normal-:   subscript  K  2     D[g]=[x,S_{5},A_{5}]::[o,S_{4},A_{4}]::[y,S_{3},A_{3}]::K_{2}          and   S  3    ⟹   A  3   =  n          italic- and   subscript  S  3     subscript  A  3        n     \and S_{3}\implies A_{3}=n          and   S  4    ⟹   A  4   =  p          italic- and   subscript  S  4     subscript  A  4        p     \and S_{4}\implies A_{4}=p          and   S  5    ⟹   A  5   =  m          italic- and   subscript  S  5     subscript  A  5        m     \and S_{5}\implies A_{5}=m       D   [  g  ]   =   [  x  ,   S  8   ,   A  8   ]   :  :   [  o  ,   S  6   ,   A  7   ]   :  :   [  y  ,   S  6   ,   A  6   ]   :  :   K  1      fragments  D   fragments  normal-[  g  normal-]     fragments  normal-[  x  normal-,   subscript  S  8   normal-,   subscript  A  8   normal-]   normal-:  normal-:   fragments  normal-[  o  normal-,   subscript  S  6   normal-,   subscript  A  7   normal-]   normal-:  normal-:   fragments  normal-[  y  normal-,   subscript  S  6   normal-,   subscript  A  6   normal-]   normal-:  normal-:   subscript  K  1     D[g]=[x,S_{8},A_{8}]::[o,S_{6},A_{7}]::[y,S_{6},A_{6}]::K_{1}          and   S  6    ⟹   A  6   =  n          italic- and   subscript  S  6     subscript  A  6        n     \and S_{6}\implies A_{6}=n          and   S  7    ⟹   A  7   =  p          italic- and   subscript  S  7     subscript  A  7        p     \and S_{7}\implies A_{7}=p          and   S  8    ⟹   A  8   =  q          italic- and   subscript  S  8     subscript  A  8        q     \and S_{8}\implies A_{8}=q     By comparing the two expressions for    D   [  g  ]       D   delimited-[]  g     D[g]   , get,        S  5   =   S  8    ,     A  5   =   A  8    ,     S  4   =   S  7    ,     A  4   =   A  7    ,     S  3   =   S  6    ,    A  3   =   A  6           formulae-sequence     subscript  S  5    subscript  S  8     formulae-sequence     subscript  A  5    subscript  A  8     formulae-sequence     subscript  S  4    subscript  S  7     formulae-sequence     subscript  A  4    subscript  A  7     formulae-sequence     subscript  S  3    subscript  S  6       subscript  A  3    subscript  A  6          S_{5}=S_{8},A_{5}=A_{8},S_{4}=S_{7},A_{4}=A_{7},S_{3}=S_{6},A_{3}=A_{6}     If    S  3     subscript  S  3    S_{3}   is true;      n  =   A  3   =   A  6   =  n        n   subscript  A  3         subscript  A  6        n     n=A_{3}=A_{6}=n   If    S  3     subscript  S  3    S_{3}   is false there is no implication. So     S  3   =  _       subscript  S  3   normal-_    S_{3}=\_   which means it may be true or false.  If    S  4     subscript  S  4    S_{4}   is true;      p  =   A  4   =   A  7   =  p        p   subscript  A  4         subscript  A  7        p     p=A_{4}=A_{7}=p     If    S  5     subscript  S  5    S_{5}   is true;      m  =   A  5   =   A  8   =  q        m   subscript  A  5         subscript  A  8        q     m=A_{5}=A_{8}=q   So    S  5     subscript  S  5    S_{5}   is false.  The result is,    D   [  g  ]   =   [  x  ,  false  ,  _  ]   :  :   [  o  ,  _  ,  p  ]   :  :   [  y  ,  _  ,  n  ]   :  :  _     fragments  D   fragments  normal-[  g  normal-]     fragments  normal-[  x  normal-,  false  normal-,  _  normal-]   normal-:  normal-:   fragments  normal-[  o  normal-,  _  normal-,  p  normal-]   normal-:  normal-:   fragments  normal-[  y  normal-,  _  normal-,  n  normal-]   normal-:  normal-:  _    D[g]=[x,\operatorname{false},\_]::[o,\_,p]::[y,\_,n]::\_              build  -  param  -  lists    [    o    x   y   ,  D  ,  V  ,  L  ]        build  param  lists     o  x  y   D  V  L    \operatorname{build-param-lists}[o\ x\ y,D,V,L]        Rule     application     application     variable        By similar arguments as used above get,      D   [  o  ]   =   [  _  ,  _  ,  x  ]   :  :   [  _  ,  _  ,  y  ]   :  :  _     fragments  D   fragments  normal-[  o  normal-]     fragments  normal-[  _  normal-,  _  normal-,  x  normal-]   normal-:  normal-:   fragments  normal-[  _  normal-,  _  normal-,  y  normal-]   normal-:  normal-:  _    D[o]=[\_,\_,x]::[\_,\_,y]::\_     and from previously,       D   [  g  ]    =   [   [  x  ,  false  ,  _  ]   ,   [  o  ,  true  ,  p  ]   ,   [  y  ,  true  ,  n  ]   ]         D   delimited-[]  g      x  false  normal-_    o  true  p    y  true  n      D[g]=[[x,\operatorname{false},\_],[o,\operatorname{true},p],[y,\operatorname{%
 true},n]]          D   [  n  ]    =   [   [  _  ,  _  ,   (    g    m    p   n   )   ]   ,   [  _  ,  _  ,   (    g    q    p   n   )   ]   ]         D   delimited-[]  n      normal-_  normal-_    g  m  p  n     normal-_  normal-_    g  q  p  n       D[n]=[[\_,\_,(g\ m\ p\ n)],[\_,\_,(g\ q\ p\ n)]]          D   [  m  ]    =  _        D   delimited-[]  m    normal-_    D[m]=\_          D   [  p  ]    =  _        D   delimited-[]  p    normal-_    D[p]=\_          D   [  q  ]    =  _        D   delimited-[]  q    normal-_    D[q]=\_        Another example is,      λ  f  .   (   (  λ  p  .   f    (   p    p   f  )   )    (  λ  q  .  λ  x  .   x    (   q    q   x  )   )       fragments  λ  f  normal-.   fragments  normal-(   fragments  normal-(  λ  p  normal-.  f   fragments  normal-(  p  p  f  normal-)   normal-)    fragments  normal-(  λ  q  normal-.  λ  x  normal-.  x   fragments  normal-(  q  q  x  normal-)   normal-)      \lambda f.((\lambda p.f\ (p\ p\ f))\ (\lambda q.\lambda x.x\ (q\ q\ x))   Here x is equal to f. The parameter list mapping is,       D   [  p  ]    =   [   [  q  ,  _  ,  p  ]   ,   [  x  ,  _  ,  f  ]   ]         D   delimited-[]  p      q  normal-_  p    x  normal-_  f      D[p]=[[q,\_,p],[x,\_,f]]   and the parameter x is dropped to give,      λ  f  .   (   (  λ  q  .   f    (   q   q  )   )    (  λ  q  .   f    (   q   q  )   )       fragments  λ  f  normal-.   fragments  normal-(   fragments  normal-(  λ  q  normal-.  f   fragments  normal-(  q  q  normal-)   normal-)    fragments  normal-(  λ  q  normal-.  f   fragments  normal-(  q  q  normal-)   normal-)      \lambda f.((\lambda q.f\ (q\ q))\ (\lambda q.f\ (q\ q))         Build parameter list for    λ  f  .   (   (  λ  p  .   f    (   p    p   f  )   )    (  λ  q  .  λ  x  .   x    (   q    q   x  )   )       fragments  λ  f  normal-.   fragments  normal-(   fragments  normal-(  λ  p  normal-.  f   fragments  normal-(  p  p  f  normal-)   normal-)    fragments  normal-(  λ  q  normal-.  λ  x  normal-.  x   fragments  normal-(  q  q  x  normal-)   normal-)      \lambda f.((\lambda p.f\ (p\ p\ f))\ (\lambda q.\lambda x.x\ (q\ q\ x))          The logic in equate is used in this more difficult example.           build  -  param  -  list    [  λ  f  .   (   (  λ  p  .   f    (   p    p   f  )   )    (  λ  q  .  λ  x  .   x    (   q    q   x  )   )   ,  D  ,  V  ,  _  ]       fragments    build  param  list    fragments  normal-[  λ  f  normal-.   fragments  normal-(   fragments  normal-(  λ  p  normal-.  f   fragments  normal-(  p  p  f  normal-)   normal-)    fragments  normal-(  λ  q  normal-.  λ  x  normal-.  x   fragments  normal-(  q  q  x  normal-)   normal-)   normal-,  D  normal-,  V  normal-,  _  normal-]      \operatorname{build-param-list}[\lambda f.((\lambda p.f\ (p\ p\ f))\ (\lambda q%
 .\lambda x.x\ (q\ q\ x)),D,V,\_]        Rule     Abstraction     Abstraction                    build  -  list    [  λ  q  .  λ  x  .   x    (   q    q   x  )   ,  D  ,  D   [  p  ]   ]      fragments    build  list    fragments  normal-[  λ  q  normal-.  λ  x  normal-.  x   fragments  normal-(  q  q  x  normal-)   normal-,  D  normal-,  D   fragments  normal-[  p  normal-]   normal-]     \operatorname{build-list}[\lambda q.\lambda x.x\ (q\ q\ x),D,D[p]]        Rule     Add param     Add param     End list                 build  -  param  -  lists    [  λ  p  .   f    (   p    p   f  )   ,  D  ,  V  ,   T  1   ]      fragments    build  param  lists    fragments  normal-[  λ  p  normal-.  f   fragments  normal-(  p  p  f  normal-)   normal-,  D  normal-,  V  normal-,   subscript  T  1   normal-]     \operatorname{build-param-lists}[\lambda p.f\ (p\ p\ f),D,V,T_{1}]        Rule     Abstraction     Application     Name     Name     Name     Application     Name                 build  -  param  -  lists    [   x    (   q    q   x  )   )   ,  D  ,  V  ,  _  ]     fragments    build  param  lists    fragments  normal-[  x   fragments  normal-(  q  q  x  normal-)   normal-)   normal-,  D  normal-,  V  normal-,  _  normal-]    \operatorname{build-param-lists}[x\ (q\ q\ x)),D,V,\_]        Rule     Abstraction     Application     Name     Name     Name     Application     Name     Name     After collecting the results together,      D   [  p  ]   =   [  q  ,  _  ,  _  ]   :  :   [  x  ,  _  ,  _  ]   :  :   L  3      fragments  D   fragments  normal-[  p  normal-]     fragments  normal-[  q  normal-,  _  normal-,  _  normal-]   normal-:  normal-:   fragments  normal-[  x  normal-,  _  normal-,  _  normal-]   normal-:  normal-:   subscript  L  3     D[p]=[q,\_,\_]::[x,\_,\_]::L_{3}         D   [  p  ]   =   [   F  4   ,   S  4   ,   A  4   ]   :  :   [   F  3   ,   S  3   ,   A  3   ]   :  :   K  2      fragments  D   fragments  normal-[  p  normal-]     fragments  normal-[   subscript  F  4   normal-,   subscript  S  4   normal-,   subscript  A  4   normal-]   normal-:  normal-:   fragments  normal-[   subscript  F  3   normal-,   subscript  S  3   normal-,   subscript  A  3   normal-]   normal-:  normal-:   subscript  K  2     D[p]=[F_{4},S_{4},A_{4}]::[F_{3},S_{3},A_{3}]::K_{2}         and   (   S  3   ⟹   (  equate   [   A  3   ,  f  ]   and  V   [   F  3   ]   =   A  3   )   )   and  D   [   F  3   ]   =  D   [  f  ]      fragments  and   fragments  normal-(   subscript  S  3     fragments  normal-(  equate   fragments  normal-[   subscript  A  3   normal-,  f  normal-]   and  V   fragments  normal-[   subscript  F  3   normal-]     subscript  A  3   normal-)   normal-)   and  D   fragments  normal-[   subscript  F  3   normal-]    D   fragments  normal-[  f  normal-]     \and(S_{3}\implies(\operatorname{equate}[A_{3},f]\and V[F_{3}]=A_{3}))\and D[F%
 _{3}]=D[f]         and   (   S  4   ⟹   (  equate   [   A  4   ,  p  ]   and  V   [   F  4   ]   =   A  4   )   )   and  D   [   F  4   ]   =  D   [  p  ]      fragments  and   fragments  normal-(   subscript  S  4     fragments  normal-(  equate   fragments  normal-[   subscript  A  4   normal-,  p  normal-]   and  V   fragments  normal-[   subscript  F  4   normal-]     subscript  A  4   normal-)   normal-)   and  D   fragments  normal-[   subscript  F  4   normal-]    D   fragments  normal-[  p  normal-]     \and(S_{4}\implies(\operatorname{equate}[A_{4},p]\and V[F_{4}]=A_{4}))\and D[F%
 _{4}]=D[p]         D   [  q  ]   =   [   F  7   ,   S  7   ,   A  7   ]   :  :   [   F  6   ,   S  6   ,   A  6   ]   :  :   K  5      fragments  D   fragments  normal-[  q  normal-]     fragments  normal-[   subscript  F  7   normal-,   subscript  S  7   normal-,   subscript  A  7   normal-]   normal-:  normal-:   fragments  normal-[   subscript  F  6   normal-,   subscript  S  6   normal-,   subscript  A  6   normal-]   normal-:  normal-:   subscript  K  5     D[q]=[F_{7},S_{7},A_{7}]::[F_{6},S_{6},A_{6}]::K_{5}          (   S  6   ⟹   (  equate   [   A  6   ,  x  ]   and  V   [   F  6   ]   =   A  6   )   )   and  D   [   F  6   ]   =  D   [  x  ]      fragments   fragments  normal-(   subscript  S  6     fragments  normal-(  equate   fragments  normal-[   subscript  A  6   normal-,  x  normal-]   and  V   fragments  normal-[   subscript  F  6   normal-]     subscript  A  6   normal-)   normal-)   and  D   fragments  normal-[   subscript  F  6   normal-]    D   fragments  normal-[  x  normal-]     (S_{6}\implies(\operatorname{equate}[A_{6},x]\and V[F_{6}]=A_{6}))\and D[F_{6}%
 ]=D[x]          (   S  7   ⟹   (  equate   [   A  7   ,  q  ]   and  V   [   F  7   ]   =   A  7   )   )   and  D   [   F  7   ]   =  D   [  q  ]      fragments   fragments  normal-(   subscript  S  7     fragments  normal-(  equate   fragments  normal-[   subscript  A  7   normal-,  q  normal-]   and  V   fragments  normal-[   subscript  F  7   normal-]     subscript  A  7   normal-)   normal-)   and  D   fragments  normal-[   subscript  F  7   normal-]    D   fragments  normal-[  q  normal-]     (S_{7}\implies(\operatorname{equate}[A_{7},q]\and V[F_{7}]=A_{7}))\and D[F_{7}%
 ]=D[q]     From the two definitions for    D   [  p  ]       D   delimited-[]  p     D[p]   ;       F  4   =  q       subscript  F  4   q    F_{4}=q          F  3   =  x       subscript  F  3   x    F_{3}=x   so      D   [  p  ]   =   [  q  ,   S  4   ,   A  4   ]   :  :   [  x  ,   S  3   ,   A  3   ]   :  :   K  2      fragments  D   fragments  normal-[  p  normal-]     fragments  normal-[  q  normal-,   subscript  S  4   normal-,   subscript  A  4   normal-]   normal-:  normal-:   fragments  normal-[  x  normal-,   subscript  S  3   normal-,   subscript  A  3   normal-]   normal-:  normal-:   subscript  K  2     D[p]=[q,S_{4},A_{4}]::[x,S_{3},A_{3}]::K_{2}          (   S  3   ⟹   (  equate   [   A  3   ,  f  ]   and  V   [  x  ]   =   A  3   )   )   and  D   [  x  ]   =  D   [  f  ]      fragments   fragments  normal-(   subscript  S  3     fragments  normal-(  equate   fragments  normal-[   subscript  A  3   normal-,  f  normal-]   and  V   fragments  normal-[  x  normal-]     subscript  A  3   normal-)   normal-)   and  D   fragments  normal-[  x  normal-]    D   fragments  normal-[  f  normal-]     (S_{3}\implies(\operatorname{equate}[A_{3},f]\and V[x]=A_{3}))\and D[x]=D[f]          (   S  4   ⟹   (  equate   [   A  4   ,  p  ]   and  V   [  q  ]   =   A  4   )   )   and  D   [  q  ]   =  D   [  p  ]      fragments   fragments  normal-(   subscript  S  4     fragments  normal-(  equate   fragments  normal-[   subscript  A  4   normal-,  p  normal-]   and  V   fragments  normal-[  q  normal-]     subscript  A  4   normal-)   normal-)   and  D   fragments  normal-[  q  normal-]    D   fragments  normal-[  p  normal-]     (S_{4}\implies(\operatorname{equate}[A_{4},p]\and V[q]=A_{4}))\and D[q]=D[p]     Using     D   [  q  ]    =   D   [  p  ]          D   delimited-[]  q      D   delimited-[]  p      D[q]=D[p]   and      D   [  p  ]   =   [   F  7   ,   S  7   ,   A  7   ]   :  :   [   F  6   ,   S  6   ,   A  6   ]   :  :   K  5      fragments  D   fragments  normal-[  p  normal-]     fragments  normal-[   subscript  F  7   normal-,   subscript  S  7   normal-,   subscript  A  7   normal-]   normal-:  normal-:   fragments  normal-[   subscript  F  6   normal-,   subscript  S  6   normal-,   subscript  A  6   normal-]   normal-:  normal-:   subscript  K  5     D[p]=[F_{7},S_{7},A_{7}]::[F_{6},S_{6},A_{6}]::K_{5}          (   S  6   ⟹   (  equate   [   A  6   ,  x  ]   and  V   [   F  6   ]   =   A  6   )   )   and  D   [   F  6   ]   =  D   [  x  ]      fragments   fragments  normal-(   subscript  S  6     fragments  normal-(  equate   fragments  normal-[   subscript  A  6   normal-,  x  normal-]   and  V   fragments  normal-[   subscript  F  6   normal-]     subscript  A  6   normal-)   normal-)   and  D   fragments  normal-[   subscript  F  6   normal-]    D   fragments  normal-[  x  normal-]     (S_{6}\implies(\operatorname{equate}[A_{6},x]\and V[F_{6}]=A_{6}))\and D[F_{6}%
 ]=D[x]          (   S  7   ⟹   (  equate   [   A  7   ,  q  ]   and  V   [   F  7   ]   =   A  7   )   )   and  D   [   F  7   ]   =  D   [  q  ]      fragments   fragments  normal-(   subscript  S  7     fragments  normal-(  equate   fragments  normal-[   subscript  A  7   normal-,  q  normal-]   and  V   fragments  normal-[   subscript  F  7   normal-]     subscript  A  7   normal-)   normal-)   and  D   fragments  normal-[   subscript  F  7   normal-]    D   fragments  normal-[  q  normal-]     (S_{7}\implies(\operatorname{equate}[A_{7},q]\and V[F_{7}]=A_{7}))\and D[F_{7}%
 ]=D[q]     by comparing with the above,        F  7   =  q   ,     F  6   =  x   ,     A  3   =   A  6    ,     A  4   =   A  7    ,     S  3   =   S  6    ,    S  4   =   S  7           formulae-sequence     subscript  F  7   q    formulae-sequence     subscript  F  6   x    formulae-sequence     subscript  A  3    subscript  A  6     formulae-sequence     subscript  A  4    subscript  A  7     formulae-sequence     subscript  S  3    subscript  S  6       subscript  S  4    subscript  S  7          F_{7}=q,F_{6}=x,A_{3}=A_{6},A_{4}=A_{7},S_{3}=S_{6},S_{4}=S_{7}   so,       V   [  x  ]    =   A  3         V   delimited-[]  x     subscript  A  3     V[x]=A_{3}          V   [  q  ]    =   A  4         V   delimited-[]  q     subscript  A  4     V[q]=A_{4}   in,       S  3   ⟹   A  3   =  f         subscript  S  3    subscript  A  3        f     S_{3}\implies A_{3}=f          S  3   ⟹   (   A  3   =  x   A  3   =  v   [  x  ]   )      fragments   subscript  S  3     fragments  normal-(   subscript  A  3    x   subscript  A  3    v   fragments  normal-[  x  normal-]   normal-)     S_{3}\implies(A_{3}=xA_{3}=v[x])   reduces to,       S  3   ⟹   A  3   =  f         subscript  S  3    subscript  A  3        f     S_{3}\implies A_{3}=f   also,       S  4   ⟹   A  4   =  p         subscript  S  4    subscript  A  4        p     S_{4}\implies A_{4}=p          S  4   ⟹   (   A  4   =  q   A  4   =  v   [  q  ]   )      fragments   subscript  S  4     fragments  normal-(   subscript  A  4    q   subscript  A  4    v   fragments  normal-[  q  normal-]   normal-)     S_{4}\implies(A_{4}=qA_{4}=v[q])   reduces to,       S  4   ⟹   A  4   =  p         subscript  S  4    subscript  A  4        p     S_{4}\implies A_{4}=p     So the parameter list for p is effectively;      D   [  p  ]   =   [  q  ,  _  ,  p  ]   :  :   [  x  ,  _  ,  f  ]   :  :  _     fragments  D   fragments  normal-[  p  normal-]     fragments  normal-[  q  normal-,  _  normal-,  p  normal-]   normal-:  normal-:   fragments  normal-[  x  normal-,  _  normal-,  f  normal-]   normal-:  normal-:  _    D[p]=[q,\_,p]::[x,\_,f]::\_        Drop parameters  Use the information obtained by Build parameter lists to drop actual parameters that are no longer required. drop-params has the parameters,   The lambda expression in which the parameters are to be dropped.  The mapping of variable names to parameter lists (built in Build parameter lists).  The set of variables free in the lambda expression.  The returned parameter list. A parameter used internally in the algorithm.   Abstraction       drop  -  params    [   (  λ  N  .  S  )   L  ,  D  ,  V  ,  R  ]   ≡   (  λ  N  .   drop  -  params    [  S  ,  D  ,  F  ,  R  ]   )    drop  -  formal    [  D   [  N  ]   ,  L  ,  F  ]      fragments    drop  params    fragments  normal-[   fragments  normal-(  λ  N  normal-.  S  normal-)   L  normal-,  D  normal-,  V  normal-,  R  normal-]     fragments  normal-(  λ  N  normal-.    drop  params    fragments  normal-[  S  normal-,  D  normal-,  F  normal-,  R  normal-]   normal-)     drop  formal    fragments  normal-[  D   fragments  normal-[  N  normal-]   normal-,  L  normal-,  F  normal-]     \operatorname{drop-params}[(\lambda N.S)\ L,D,V,R]\equiv(\lambda N.%
 \operatorname{drop-params}[S,D,F,R])\ \operatorname{drop-formal}[D[N],L,F]   where,      F  =  F  V   [   (  λ  N  .  S  )   L  ]      fragments  F   F  V   fragments  normal-[   fragments  normal-(  λ  N  normal-.  S  normal-)   L  normal-]     F=FV[(\lambda N.S)\ L]          drop  -  params    [  λ  N  .  S  ,  D  ,  V  ,  R  ]   ≡   (  λ  N  .   drop  -  params    [  S  ,  D  ,  F  ,  R  ]   )      fragments    drop  params    fragments  normal-[  λ  N  normal-.  S  normal-,  D  normal-,  V  normal-,  R  normal-]     fragments  normal-(  λ  N  normal-.    drop  params    fragments  normal-[  S  normal-,  D  normal-,  F  normal-,  R  normal-]   normal-)     \operatorname{drop-params}[\lambda N.S,D,V,R]\equiv(\lambda N.\operatorname{%
 drop-params}[S,D,F,R])   where,      F  =  F  V   [  λ  N  .  S  ]      fragments  F   F  V   fragments  normal-[  λ  N  normal-.  S  normal-]     F=FV[\lambda N.S]     Variable        drop  -  params    [  N  ,  D  ,  V  ,   D   [  N  ]    ]    ≡  N         drop  params   N  D  V    D   delimited-[]  N     N    \operatorname{drop-params}[N,D,V,D[N]]\equiv N     For a function name or parameter start populating actual parameter list by outputting the parameter list for this name.  Application - An application (function call) is processed to extract       (  def   [  F  ]   and  ask   [  S  ]   and  F  V   [  A  ]   ⊂  V  )   →   drop  -  params    [   E   P  ,  D  ,  V  ,  R  ]   ≡   drop  -  params    [  E  ,  D  ,  V  ,   [  F  ,  S  ,  A  ]   :  :  R  ]      fragments   fragments  normal-(  def   fragments  normal-[  F  normal-]   and  ask   fragments  normal-[  S  normal-]   and  F  V   fragments  normal-[  A  normal-]    V  normal-)   normal-→    drop  params    fragments  normal-[  E  P  normal-,  D  normal-,  V  normal-,  R  normal-]      drop  params    fragments  normal-[  E  normal-,  D  normal-,  V  normal-,   fragments  normal-[  F  normal-,  S  normal-,  A  normal-]   normal-:  normal-:  R  normal-]     (\operatorname{def}[F]\and\operatorname{ask}[S]\and FV[A]\subset V)\to%
 \operatorname{drop-params}[E\ P,D,V,R]\equiv\operatorname{drop-params}[E,D,V,[%
 F,S,A]::R]         ¬   (  def   [  F  ]   and  ask   [  S  ]   and  F  V   [  A  ]   ⊂  V  )   →   drop  -  params    [   E   P  ,  D  ,  V  ,  R  ]   ≡   drop  -  params    [  E  ,  D  ,  V  ,   [  F  ,  S  ,  A  ]   :  :  R  ]    drop  -  params    [  P  ,  D  ,  V  ,  _  ]      fragments    fragments  normal-(  def   fragments  normal-[  F  normal-]   and  ask   fragments  normal-[  S  normal-]   and  F  V   fragments  normal-[  A  normal-]    V  normal-)   normal-→    drop  params    fragments  normal-[  E  P  normal-,  D  normal-,  V  normal-,  R  normal-]      drop  params    fragments  normal-[  E  normal-,  D  normal-,  V  normal-,   fragments  normal-[  F  normal-,  S  normal-,  A  normal-]   normal-:  normal-:  R  normal-]     drop  params    fragments  normal-[  P  normal-,  D  normal-,  V  normal-,  _  normal-]     \neg(\operatorname{def}[F]\and\operatorname{ask}[S]\and FV[A]\subset V)\to%
 \operatorname{drop-params}[E\ P,D,V,R]\equiv\operatorname{drop-params}[E,D,V,[%
 F,S,A]::R]\ \operatorname{drop-params}[P,D,V,\_]     Let - Let expression.         drop  -  params    [    let  V   :   E   in  L     ]    ≡   let  V    :     drop  -  params    [  E  ,  D  ,   F  V   [  E  ]    ,   [  ]   ]      in   drop  -  params     [  L  ,  D  ,   F  V   [  L  ]    ,   [  ]   ]        normal-:       drop  params    normal-:   let  V     E   in  L       let  V         drop  params   E  D    F  V   delimited-[]  E        in    drop  params    L  D    F  V   delimited-[]  L         \operatorname{drop-params}[\operatorname{let}V:E\operatorname{in}L]\equiv%
 \operatorname{let}V:\operatorname{drop-params}[E,D,FV[E],[]]\operatorname{in}%
 \operatorname{drop-params}[L,D,FV[L],[]]     And - For use in "let".        drop  -  params    [   E  and  F   ,  D  ,  V  ,  _  ]    ≡     drop  -  params    [  E  ,  D  ,  V  ,  _  ]    and    drop  -  params    [  F  ,  D  ,  V  ,  _  ]            drop  params     E  italic- and  F   D  V  normal-_        drop  params   E  D  V  normal-_   italic- and     drop  params   F  D  V  normal-_      \operatorname{drop-params}[E\and F,D,V,\_]\equiv\operatorname{drop-params}[E,D%
 ,V,\_]\and\operatorname{drop-params}[F,D,V,\_]         Drop parameters from applications               λ  g   .   λ  n   .    n    (    g    m    p   n   )    (    g    q    p   n   )       formulae-sequence    λ  g     λ  n     n    g  m  p  n     g  q  p  n      \lambda g.\lambda n.n\ (g\ m\ p\ n)\ (g\ q\ p\ n)        Condition               ¬   (    def   [   F  1   ]     and  …    )         def   subscript  F  1      italic- and  normal-…      \neg(\operatorname{def}[F_{1}]\and...)            ¬   (    def   [   F  2   ]     and  …    )         def   subscript  F  2      italic- and  normal-…      \neg(\operatorname{def}[F_{2}]\and...)            D   [  n  ]   =   [   F  2   ,   S  2   ,   A  2   ]   :  :   [   F  1   ,   S  1   ,   A  1   ]   :  :  _  ]     fragments  D   fragments  normal-[  n  normal-]     fragments  normal-[   subscript  F  2   normal-,   subscript  S  2   normal-,   subscript  A  2   normal-]   normal-:  normal-:   fragments  normal-[   subscript  F  1   normal-,   subscript  S  1   normal-,   subscript  A  1   normal-]   normal-:  normal-:  _  normal-]    D[n]=[F_{2},S_{2},A_{2}]::[F_{1},S_{1},A_{1}]::\_]           From the results of building parameter lists;       D   [  n  ]    =   [   [  _  ,  _  ,   (    g    m    p   n   )   ]   ,   [  _  ,  _  ,   (    g    q    p   n   )   ]   ]         D   delimited-[]  n      normal-_  normal-_    g  m  p  n     normal-_  normal-_    g  q  p  n       D[n]=[[\_,\_,(g\ m\ p\ n)],[\_,\_,(g\ q\ p\ n)]]   so,       F  1   =  _       subscript  F  1   normal-_    F_{1}=\_          F  2   =  _       subscript  F  2   normal-_    F_{2}=\_   so,       def   [   F  1   ]    =  false       def   subscript  F  1    false    \operatorname{def}[F_{1}]=\operatorname{false}          def   [   F  2   ]    =  false       def   subscript  F  2    false    \operatorname{def}[F_{2}]=\operatorname{false}              drop  -  param    [   (    g    m    p   n   )   ,  D  ,   {  p  ,  q  ,  m  }   ,  _  ]        drop  param     g  m  p  n   D   p  q  m   normal-_    \operatorname{drop-param}[(g\ m\ p\ n),D,\{p,q,m\},\_]        Condition         V  =   {  p  ,  q  ,  m  }       V   p  q  m     V=\{p,q,m\}             F  V   (   A  1   )    ⊄   {  p  ,  q  ,  m  }      not-subset-of    F  V   subscript  A  1     p  q  m     FV(A_{1})\not\subset\{p,q,m\}               def   [   F  2   ]    and     ask   [   S  2   ]     and  F  V     [   A  2   ]    ⊂  V          def   subscript  F  2    italic- and     ask   subscript  S  2      italic- and  F  V     delimited-[]   subscript  A  2     V    \operatorname{def}[F_{2}]\and\operatorname{ask}[S_{2}]\and FV[A_{2}]\subset V            ¬   ask   [   S  3   ]          ask   subscript  S  3      \neg\operatorname{ask}[S_{3}]             D   [  g  ]    =   [   [  x  ,  false  ,  _  ]   ,   [  o  ,  _  ,  p  ]   ,   [  y  ,  _  ,  n  ]   ]         D   delimited-[]  g      x  false  normal-_    o  normal-_  p    y  normal-_  n      D[g]=[[x,\operatorname{false},\_],[o,\_,p],[y,\_,n]]       =   [   F  3   ,   S  3   ,   A  3   ]   :  :   [   F  2   ,   S  2   ,   A  2   ]   :  :   [   F  1   ,   S  1   ,   A  1   ]   :  :  _  ]     fragments    fragments  normal-[   subscript  F  3   normal-,   subscript  S  3   normal-,   subscript  A  3   normal-]   normal-:  normal-:   fragments  normal-[   subscript  F  2   normal-,   subscript  S  2   normal-,   subscript  A  2   normal-]   normal-:  normal-:   fragments  normal-[   subscript  F  1   normal-,   subscript  S  1   normal-,   subscript  A  1   normal-]   normal-:  normal-:  _  normal-]    =[F_{3},S_{3},A_{3}]::[F_{2},S_{2},A_{2}]::[F_{1},S_{1},A_{1}]::\_]                 drop  -  param    [   (    g    q    p   n   )   ,  D  ,   {  p  ,  q  ,  m  }   ,  _  ]        drop  param     g  q  p  n   D   p  q  m   normal-_    \operatorname{drop-param}[(g\ q\ p\ n),D,\{p,q,m\},\_]        Condition     V = \{p, q, m\}          F  V   (   A  4   )    ⊄  V     not-subset-of    F  V   subscript  A  4    V    FV(A_{4})\not\subset V               def   [   F  5   ]    and     ask   [   S  5   ]     and  F  V     [   A  5   ]    ⊂  V          def   subscript  F  5    italic- and     ask   subscript  S  5      italic- and  F  V     delimited-[]   subscript  A  5     V    \operatorname{def}[F_{5}]\and\operatorname{ask}[S_{5}]\and FV[A_{5}]\subset V            ¬   ask   [   S  -  6   ]          ask    S  6      \neg\operatorname{ask}[S-6]             D   [  g  ]    =   [   [  x  ,  false  ,  _  ]   ,   [  o  ,  _  ,  p  ]   ,   [  y  ,  _  ,  n  ]   ]         D   delimited-[]  g      x  false  normal-_    o  normal-_  p    y  normal-_  n      D[g]=[[x,\operatorname{false},\_],[o,\_,p],[y,\_,n]]       =   [   F  6   ,   S  6   ,   A  6   ]   :  :   [   F  5   ,   S  5   ,   A  5   ]   :  :   [   F  4   ,   S  4   ,   A  4   ]   :  :  _  ]     fragments    fragments  normal-[   subscript  F  6   normal-,   subscript  S  6   normal-,   subscript  A  6   normal-]   normal-:  normal-:   fragments  normal-[   subscript  F  5   normal-,   subscript  S  5   normal-,   subscript  A  5   normal-]   normal-:  normal-:   fragments  normal-[   subscript  F  4   normal-,   subscript  S  4   normal-,   subscript  A  4   normal-]   normal-:  normal-:  _  normal-]    =[F_{6},S_{6},A_{6}]::[F_{5},S_{5},A_{5}]::[F_{4},S_{4},A_{4}]::\_]           Drop formal parameters  drop-formal removes formal parameters, based on the contents of the drop lists. Its parameters are,   The drop list,  The function definition (lambda abstraction).  The free variables from the function definition.   drop-formal is defined as,        (  ask   [  S  ]   and  F  V   [  A  ]   ⊂  V  )   →   drop  -  formal    [   [  F  ,  S  ,  A  ]   :  :  Z  ,  λ  F  .  Y  ,  V  ]   ≡   drop  -  formal    [   [  F  ,  S  ,  A  ]   :  :  Z  ,  Y   [  F  :=  A  ]   ,  L  ]      fragments   fragments  normal-(  ask   fragments  normal-[  S  normal-]   and  F  V   fragments  normal-[  A  normal-]    V  normal-)   normal-→    drop  formal    fragments  normal-[   fragments  normal-[  F  normal-,  S  normal-,  A  normal-]   normal-:  normal-:  Z  normal-,  λ  F  normal-.  Y  normal-,  V  normal-]      drop  formal    fragments  normal-[   fragments  normal-[  F  normal-,  S  normal-,  A  normal-]   normal-:  normal-:  Z  normal-,  Y   fragments  normal-[  F  assign  A  normal-]   normal-,  L  normal-]     (\operatorname{ask}[S]\and FV[A]\subset V)\to\operatorname{drop-formal}[[F,S,A%
 ]::Z,\lambda F.Y,V]\equiv\operatorname{drop-formal}[[F,S,A]::Z,Y[F:=A],L]         ¬   (  ask   [  S  ]   and  F  V   [  A  ]   ⊂  V  )   →   drop  -  formal    [   [  F  ,  S  ,  A  ]   :  :  Z  ,  λ  F  .  Y  ,  V  ]   ≡  λ  F  .   drop  -  formal    [   [  F  ,  S  ,  A  ]   :  :  Z  ,  Y  ,  V  ]      fragments    fragments  normal-(  ask   fragments  normal-[  S  normal-]   and  F  V   fragments  normal-[  A  normal-]    V  normal-)   normal-→    drop  formal    fragments  normal-[   fragments  normal-[  F  normal-,  S  normal-,  A  normal-]   normal-:  normal-:  Z  normal-,  λ  F  normal-.  Y  normal-,  V  normal-]    λ  F  normal-.    drop  formal    fragments  normal-[   fragments  normal-[  F  normal-,  S  normal-,  A  normal-]   normal-:  normal-:  Z  normal-,  Y  normal-,  V  normal-]     \neg(\operatorname{ask}[S]\and FV[A]\subset V)\to\operatorname{drop-formal}[[F%
 ,S,A]::Z,\lambda F.Y,V]\equiv\lambda F.\operatorname{drop-formal}[[F,S,A]::Z,Y%
 ,V]           drop  -  formal    [  Z  ,  Y  ,  V  ]    ≡  Y         drop  formal   Z  Y  V   Y    \operatorname{drop-formal}[Z,Y,V]\equiv Y      Which can be explained as,   If all the actual parameters have the same value, and all the free variables of that value are available for definition of the function then drop the parameter, and replace the old parameter with its value.  else do not drop the parameter.  else return the body of the function.       Condition   Expression          false   false   \operatorname{false}           drop  -  formal    [  D  ,  λ  x  .  λ  o  .  λ  y  .   o    x   y  ,  F  ]      fragments    drop  formal    fragments  normal-[  D  normal-,  λ  x  normal-.  λ  o  normal-.  λ  y  normal-.  o  x  y  normal-,  F  normal-]     \operatorname{drop-formal}[D,\lambda x.\lambda o.\lambda y.o\ x\ y,F]              true  and    {  p  }    ⊂  F         true  italic- and    p    F    \operatorname{true}\and\{p\}\subset F          λ  x  .   drop  -  formal    [  D  ,  λ  o  .  λ  y  .   o    x   y  ,  F  ]      fragments  λ  x  normal-.    drop  formal    fragments  normal-[  D  normal-,  λ  o  normal-.  λ  y  normal-.  o  x  y  normal-,  F  normal-]     \lambda x.\operatorname{drop-formal}[D,\lambda o.\lambda y.o\ x\ y,F]            ¬   (  true  and   {  n  }   ⊂  F      fragments    fragments  normal-(  true  and   fragments  normal-{  n  normal-}    F     \neg(\operatorname{true}\and\{n\}\subset F   )       λ  x  .   drop  -  formal    [  D  ,   (  λ  y  .   o    x   y  )    [  o  :=  p  ]   ,  F  ]      fragments  λ  x  normal-.    drop  formal    fragments  normal-[  D  normal-,   fragments  normal-(  λ  y  normal-.  o  x  y  normal-)    fragments  normal-[  o  assign  p  normal-]   normal-,  F  normal-]     \lambda x.\operatorname{drop-formal}[D,(\lambda y.o\ x\ y)[o:=p],F]              λ  x   .   λ  y   .    drop  -  formal    [  D  ,    p    x   y   ,  F  ]       formulae-sequence    λ  x     λ  y      drop  formal   D    p  x  y   F     \lambda x.\lambda y.\operatorname{drop-formal}[D,p\ x\ y,F]              λ  x   .   λ  y   .    p    x   y      formulae-sequence    λ  x     λ  y     p  x  y     \lambda x.\lambda y.p\ x\ y        Example  Starting with the function definition of the Y-combinator,       let    p    f   x    =    f    (    x   x   )   and   q    p   f   =    (    p   f   )    (    p   f   )    in    q   p            let    p  f  x      f    x  x   italic- and  q  p  f            p  f     p  f    in    q  p        \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in%
 }q\ p         Transformation   Expression             let    p    f   x    =    f    (    x   x   )   and   q    p   f   =    (    p   f   )    (    p   f   )    in    q   p            let    p  f  x      f    x  x   italic- and  q  p  f            p  f     p  f    in    q  p        \operatorname{let}p\ f\ x=f\ (x\ x)\and q\ p\ f=(p\ f)\ (p\ f)\operatorname{in%
 }q\ p        abstract * 4         let  p   =   λ  f    .   λ  x   .     f    (    x   x   )   and  q   =   λ  p    .   λ  f   .    (    p   f   )    (    p   f   )    in    q   p        formulae-sequence     let  p     λ  f      λ  x       f    x  x   italic- and  q     λ  p      λ  f       p  f     p  f    in    q  p       \operatorname{let}p=\lambda f.\lambda x.f\ (x\ x)\and q=\lambda p.\lambda f.(p%
 \ f)\ (p\ f)\operatorname{in}q\ p        lambda-abstract-tran        (  λ  q  .   (  λ  p  .   q   p  )    (  λ  f  .  λ  x  .   f    (   x   x  )   )   )    (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )      fragments   fragments  normal-(  λ  q  normal-.   fragments  normal-(  λ  p  normal-.  q  p  normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-)    fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)     (\lambda q.(\lambda p.q\ p)\ (\lambda f.\lambda x.f\ (x\ x)))\ (\lambda p.%
 \lambda f.(p\ f)\ (p\ f))        sink-tran        (  λ  p  .  λ  f  .   (   p   f  )    (   p   f  )   )    (  λ  f  .  λ  x  .   f    (   x   x  )   )      fragments   fragments  normal-(  λ  p  normal-.  λ  f  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     (\lambda p.\lambda f.(p\ f)\ (p\ f))\ (\lambda f.\lambda x.f\ (x\ x))        sink-tran       λ  f  .   (  λ  p  .   (   p   f  )    (   p   f  )   )    (  λ  f  .  λ  x  .   f    (   x   x  )   )      fragments  λ  f  normal-.   fragments  normal-(  λ  p  normal-.   fragments  normal-(  p  f  normal-)    fragments  normal-(  p  f  normal-)   normal-)    fragments  normal-(  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     \lambda f.(\lambda p.(p\ f)\ (p\ f))\ (\lambda f.\lambda x.f\ (x\ x))        drop-param       λ  f  .   (  λ  p  .   p   p  )    (  λ  x  .   f    (   x   x  )   )      fragments  λ  f  normal-.   fragments  normal-(  λ  p  normal-.  p  p  normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     \lambda f.(\lambda p.p\ p)\ (\lambda x.f\ (x\ x))        beta-redex       λ  f  .   (  λ  x  .   f    (   x   x  )   )    (  λ  x  .   f    (   x   x  )   )      fragments  λ  f  normal-.   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     \lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))        Which gives back the Y combinator ,      λ  f  .   (  λ  x  .   f    (   x   x  )   )    (  λ  x  .   f    (   x   x  )   )      fragments  λ  f  normal-.   fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     \lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))     See also   Let expression  Fixed-point combinator  Lambda calculus  Deductive lambda calculus  Supercombinator  Curry's paradox   References  External links   Explanation on Stack Overflow, with a JavaScript example  Some discussion of let expressions   "  Category:Implementation of functional programming languages  Category:Lambda calculus     ↩  ↩  ↩    