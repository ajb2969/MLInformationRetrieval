   Flajolet–Martin algorithm      Flajolet–Martin algorithm   The '''Flajolet–Martin algorithm '''is an algorithm for approximating the number of distinct elements in a stream with a single pass and space-consumption which is logarithmic in the maximum number of possible distinct elements in the stream. The algorithm was introduced by Philippe Flajolet and G. Nigel Martin in their 1984 paper "Probabilistic Counting Algorithms for Data Base Applications". 1 Later it has been refined in the papers "LogLog counting of large cardinalities" by Marianne Durand and Philippe Flajolet , 2 and "HyperLogLog: The analysis of a near-optimal cardinality estimation algorithm" by Philippe Flajolet et al. 3  In their 2010 paper "An optimal algorithm for the distinct elements problem", 4 Daniel M. Kane, Jelani Nelson and David P. Woodruff gives an improved algorithm which uses nearly optimal space, and has optimal O (1) update and reporting times.  The algorithm  Assume that we are given a hash function     h  a  s  h   (  x  )       h  a  s  h  x    hash(x)   which maps input   x   x   x   to integers in the range    [  0  ;    2  L   -  1   ]     0     superscript  2  L   1     [0;2^{L}-1]   and where the outputs are sufficiently uniformly distributed . Note that the set of integers from 0 to     2  L   -  1       superscript  2  L   1    2^{L}-1   corresponds to the set of binary strings of length   L   L   L   . For any non-negative integer   y   y   y   , define    b  i  t   (  y  ,  k  )       b  i  t   y  k     bit(y,k)   to be the   k   k   k   -th bit in the binary representation of   y   y   y   , such that:      y  =    ∑   k  ≥  0     bit   (  y  ,  k  )    2  k         y    subscript     k  0      bit   y  k    superscript  2  k       y=\sum_{k\geq 0}\text{bit}(y,k)2^{k}     We then define a function    ρ   (  y  )       ρ  y    \rho(y)   which outputs the position of the least significant 1-bit in the binary representation of   y   y   y   :       ρ   (  y  )    =     min   k  ≥  0    bit    (  y  ,  k  )    ≠  0          ρ  y       subscript     k  0    bit    y  k         0     \rho(y)=\min_{k\geq 0}\text{bit}(y,k)\neq 0     where     ρ   (  0  )    =  L        ρ  0   L    \rho(0)=L   . Note that with the above definition we are using 0-indexing for the positions. For example,     ρ   (  13  )    =   ρ   (  1101  )    =  0          ρ  13     ρ  1101        0     \rho(13)=\rho(1101)=0   since the least significant bit is a 1, and     ρ   (  8  )    =   ρ   (  0100  )    =  2          ρ  8     ρ  0100        2     \rho(8)=\rho(0100)=2   since the least significant 1-bit is at the third position. At this point, note that under the assumption that the output of our hash-function is uniformly distributed, then the probability of observing a hash-output ending with    2  k     superscript  2  k    2^{k}   (a one, followed by   k   k   k   zeroes) is    2   -   (   k  +  1   )       superscript  2      k  1      2^{-(k+1)}   since this corresponds to flipping   k   k   k   heads and then a tail with a fair coin.  Now the Flajolet–Martin algorithm for estimating the cardinality of a multiset    M   M   M   is as follows:   Initialize a bit-vector BITMAP to be of length   L   L   L   and contain all 0's.  For each element   x   x   x   in   M   M   M   :  index =    ρ   (   hash   (  x  )    )       ρ    hash  x     \rho(\text{hash}(x))   .       B  I  T  M  A  P   [   i  n  d  e  x   ]    =  1        B  I  T  M  A  P   delimited-[]    i  n  d  e  x     1    BITMAP[index]=1   .   Let   R   R   R   denote the smallest index   i   i   i   such that     B  I  T  M  A  P   [  i  ]    =  0        B  I  T  M  A  P   delimited-[]  i    0    BITMAP[i]=0   .  Estimate the cardinality of   M   M   M   as     2  R   ⋅  ϕ     normal-⋅   superscript  2  R   ϕ    2^{R}\cdot\phi   where    ϕ  ≈  0.77351      ϕ  0.77351    \phi\approx 0.77351   .   The idea is that if   n   n   n   is the number of distinct elements in the multiset   M   M   M   , then    B  I  T  M  A  P   [  0  ]       B  I  T  M  A  P   delimited-[]  0     BITMAP[0]   is accessed approximately    n  /  2      n  2    n/2   times,    B  I  T  M  A  P   [  1  ]       B  I  T  M  A  P   delimited-[]  1     BITMAP[1]   is accessed approximately    n  /  4      n  4    n/4   times and so on. Consequently if    i  ≫    log  2   n      much-greater-than  i    subscript   2   n     i\gg\log_{2}n   then    B  I  T  M  A  P   [  i  ]       B  I  T  M  A  P   delimited-[]  i     BITMAP[i]   is almost certainly 0, and if    i  ≪    log  2   n      much-less-than  i    subscript   2   n     i\ll\log_{2}n   then    B  I  T  M  A  P   [  i  ]       B  I  T  M  A  P   delimited-[]  i     BITMAP[i]   is almost certainly 1. If    i  ≈    log  2   n       i    subscript   2   n     i\approx\log_{2}n   then    B  I  T  M  A  P   [  i  ]       B  I  T  M  A  P   delimited-[]  i     BITMAP[i]   can be expected to be either 1 or 0.  The correction factor    ϕ  ≈  0.77351      ϕ  0.77351    \phi\approx 0.77351   is found by calculations which can be found in the original paper.  Improving accuracy  A problem with the Flajolet–Martin algorithm in the above form, is that the results vary a lot. A common solution is to run the algorithm multiple times with   k   k   k   different hash-functions, and combine the results from the different runs. One idea is to take the mean of the   k   k   k   results together from each hash-function, obtaining a single estimate of the cardinality. The problem with this is that averaging is very susceptible to outliers (which are likely here). A different idea is to use the median which is less prone to be influences by outliers. The problem with this is that the results can only take form     2  R   /  ϕ       superscript  2  R   ϕ    2^{R}/\phi   , where   R   R   R   is integer. A common solution is to combine both the mean and the median: Create    k  ⋅  ℓ     normal-⋅  k  normal-ℓ    k\cdot\ell   hash-functions and split them into   k   k   k   distinct groups (each of size   ℓ   normal-ℓ   \ell   ). Within each group use the median for aggregating together the   ℓ   normal-ℓ   \ell   results, and finally take the mean of the   k   k   k   group estimates as the final estimate.  See also   Streaming algorithm   References  Additional sources     "  Category:Algorithms     ↩  ↩  ↩  ↩     