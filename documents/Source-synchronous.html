<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1032">Source-synchronous</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Source-synchronous</h1>
<hr/>

<p><strong>Source-Synchronous</strong> clocking refers to a technique used for timing symbols on a digital interface. Specifically, it refers to the technique of having the transmitting device send a clock signal along with the data signals. The timing of the unidirectional data signals is referenced to the clock (often called the strobe) sourced by the same device that generates those signals, and not to a global clock (i.e. generated by a bus master). Compared to other digital clocking topologies like system-synchronous clocks, where a global clock source is fed to all devices in the system, a source-synchronous clock topology can attain far higher speeds.</p>

<p>This type of clocking is common in high-speed interfaces between micro-chips, including <a href="DDR_SDRAM" title="wikilink">DDR SDRAM</a>, SGI <a class="uri" href="XIO" title="wikilink">XIO</a> interface, <a class="uri" href="Intel" title="wikilink">Intel</a> <a href="Front_Side_Bus" title="wikilink">Front Side Bus</a> for the <a class="uri" href="x86" title="wikilink">x86</a> and <a class="uri" href="Itanium" title="wikilink">Itanium</a> processors, <a class="uri" href="HyperTransport" title="wikilink">HyperTransport</a>, <a class="uri" href="SPI-4.2" title="wikilink">SPI-4.2</a> and many others.</p>
<h2 id="reasons-for-usage">Reasons for usage</h2>

<p>A reason that source-synchronous clocking is useful is that it has been observed that all of the circuits within a given semiconductor device experience roughly the same process-voltage-temperature (PVT) variation. This means signal propagation delay experienced by the data through a device tracks the delay experienced by the clock through that same device over PVT. This advantage allows higher speed operation as compared to the traditional technique of providing the clock from a third device to both the transmitter and the receiver. Another benefit is that higher complexity data-recovery or clock-data-recovery circuits (such as <a href="PLL" title="wikilink">PLLs</a>) are not required when this technique is used.</p>

<p>Or rather than higher clock speeds, large systems that take advantage of source-synchronous clocking can have the benefit of a higher tolerance of PVT variation of its individual components.</p>
<h3 id="timing-analysis">Timing Analysis</h3>

<p>Synchronous logic elements such as <a class="uri" href="flip-flops" title="wikilink">flip-flops</a> have static timing criteria that must be satisfied in order for them to work correctly. In a system-synchronous clock topology where a skew-aligned clock is fed to all devices, the criteria is</p>

<p>

<math display="inline" id="Source-synchronous:0">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mrow>
     <mi>c</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>c</mi>
     <mi>k</mi>
    </mrow>
   </msub>
   <mo>></mo>
   <mrow>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>s</mi>
      <mi>e</mi>
      <mi>t</mi>
      <mi>u</mi>
      <mi>p</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>k</mi>
      <mi>o</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>s</mi>
      <mi>k</mi>
      <mi>e</mi>
      <mi>w</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>l</ci>
      <ci>o</ci>
      <ci>c</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>e</ci>
       <ci>t</ci>
       <ci>u</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>o</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>k</ci>
       <ci>e</ci>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{clock}>T_{setup}+T_{ko}+T_{skew}
  </annotation>
 </semantics>
</math>

</p>

<p>A source-synchronous clock topology eliminates two of these factors, 

<math display="inline" id="Source-synchronous:1">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>k</mi>
    <mi>o</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>o</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{ko}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Source-synchronous:2">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>s</mi>
    <mi>k</mi>
    <mi>e</mi>
    <mi>w</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>k</ci>
     <ci>e</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{skew}
  </annotation>
 </semantics>
</math>

. The former is eliminated since both clock and data signals are driven by identical flip-flops on the same silicon at the same temperature and voltage, thereby equalizing the T_{ko} seen by both clock and data. The latter is eliminated for the same reason - since the clock and data are driven by identical devices and (ideally) connected with wires of equal length, the skew between clock and data is greatly reduced. For this reason, 

<math display="inline" id="Source-synchronous:3">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>c</mi>
    <mi>l</mi>
    <mi>o</mi>
    <mi>c</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>c</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{clock}
  </annotation>
 </semantics>
</math>


 can be reduced significantly. Since frequency is inversely proportional to clock period, the clock frequency increases as a result.</p>
<h2 id="drawbacks">Drawbacks</h2>

<p>One drawback of using source-synchronous clocking is the creation of a separate clock-domain at the receiving device, namely the clock-domain of the strobe generated by the transmitting device. This strobe clock-domain is often not synchronous to the core clock domain of the receiving device. For proper operation of the received data with other data already present in the device, an additional stage of synchronization logic is required to transfer the received data into the core clock-domain of the receiving device. This stage can often be found alongside source synchronous logic. This usually results in greater system complexity compared to globally clocked systems, but the benefits are generally much greater than this increase in complexity.</p>
<h2 id="implementation-variations">Implementation Variations</h2>

<p>In bi-directional data transfer buses, two opposing unidirectional strobes can be sent from each device. Often the strobe is free running in this case. That is, the strobe continues to toggle whether there is data being transferred or not.</p>

<p>Another variation is the sharing of the same bus to transfer the strobe. In this case the strobe can only be transferred by the device that is sending the data and may require transmission of pre-ambles and post-ambles to indicate the start and end of the strobes. (Example: <a href="DDR2_SDRAM" title="wikilink">DDR2</a>).</p>

<p>In large <a href="ASIC" title="wikilink">ASICs</a> or <a class="uri" href="processors" title="wikilink">processors</a>, multiple strobes and data groups (data bits that are associated to the same strobe) may exist between the same two devices to account for the slightly different PVT variations in different regions of the same die.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Clock_recovery" title="wikilink">Clock recovery</a></li>
<li><a href="8B/10B_encoding" title="wikilink">8B/10B encoding</a></li>
<li><a href="Synchronization_(computer_science)" title="wikilink">Synchronization (computer science)</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.fpgajournal.com/articles/20041109_lattice.htm">Overview of Memory Types and DDR Interface Design Implementation</a></li>
</ul>

<p>"</p>

<p><a href="Category:Clock_signal" title="wikilink">Category:Clock signal</a> <a href="Category:Electrical_circuits" title="wikilink">Category:Electrical circuits</a></p>
</body>
</html>
