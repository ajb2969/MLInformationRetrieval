<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1480">Reed–Solomon error correction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Reed–Solomon error correction</h1>
<hr/>

<p><strong>Reed–Solomon codes</strong> are an important group of <a href="error-correcting_code" title="wikilink">error-correcting codes</a> that were introduced by <a href="Irving_S._Reed" title="wikilink">Irving S. Reed</a> and <a href="Gustave_Solomon" title="wikilink">Gustave Solomon</a> in 1960.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> They have many important applications, the most prominent of which include consumer technologies such as <a href="CD" title="wikilink">CDs</a>, <a href="DVD" title="wikilink">DVDs</a>, <a href="Blu-ray_Disc" title="wikilink">Blu-ray Discs</a>, <a href="QR_Code" title="wikilink">QR Codes</a>, <a href="data_transmission" title="wikilink">data transmission</a> technologies such as <a class="uri" href="DSL" title="wikilink">DSL</a> and <a class="uri" href="WiMAX" title="wikilink">WiMAX</a>, <a href="Broadcasting" title="wikilink">broadcast</a> systems such as <a href="Digital_Video_Broadcasting" title="wikilink">DVB</a> and <a href="ATSC_Standards" title="wikilink">ATSC</a>, and storage systems such as <a href="RAID_6" title="wikilink">RAID 6</a>. They are also used in satellite communication.</p>

<p>In <a href="coding_theory" title="wikilink">coding theory</a>, the Reed–Solomon code belongs to the class of non-<a href="Binary_number" title="wikilink">binary</a> <a href="cyclic_code" title="wikilink">cyclic</a> error-correcting codes. The Reed–Solomon code is based on <a class="uri" href="univariate" title="wikilink">univariate</a> <a class="uri" href="polynomials" title="wikilink">polynomials</a> over <a href="finite_field" title="wikilink">finite fields</a>.</p>

<p>It is able to detect and correct multiple symbol errors. By adding 

<math display="inline" id="Reed–Solomon_error_correction:0">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 check symbols to the data, a Reed–Solomon code can detect any combination of up to 

<math display="inline" id="Reed–Solomon_error_correction:1">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 erroneous symbols, or correct up to 

<math display="inline" id="Reed–Solomon_error_correction:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">⌊</mi>
     <mi>t</mi>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mi mathvariant="normal">⌋</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-⌊</ci>
      <ci>t</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⌋</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ⌊t/2⌋
  </annotation>
 </semantics>
</math>

 symbols. As an <a href="erasure_code" title="wikilink">erasure code</a>, it can correct up to 

<math display="inline" id="Reed–Solomon_error_correction:3">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 known erasures, or it can detect and correct combinations of errors and erasures. Furthermore, Reed–Solomon codes are suitable as multiple-<a href="burst_error" title="wikilink">burst</a> bit-error correcting codes, since a sequence of 

<math display="inline" id="Reed–Solomon_error_correction:4">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal"></mi>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>b</ci>
    <apply>
     <times></times>
     <ci>normal-</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b+ 1
  </annotation>
 </semantics>
</math>

 consecutive bit errors can affect at most two symbols of size 

<math display="inline" id="Reed–Solomon_error_correction:5">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. The choice of 

<math display="inline" id="Reed–Solomon_error_correction:6">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is up to the designer of the code, and may be selected within wide limits.</p>
<h2 id="history">History</h2>

<p>Reed–Solomon codes were developed in 1960 by <a href="Irving_S._Reed" title="wikilink">Irving S. Reed</a> and <a href="Gustave_Solomon" title="wikilink">Gustave Solomon</a>, who were then staff members of <a class="uri" href="MIT" title="wikilink">MIT</a> <a href="Lincoln_Laboratory" title="wikilink">Lincoln Laboratory</a>. Their seminal article was entitled "Polynomial Codes over Certain Finite Fields." . When the article was written, an efficient decoding algorithm was not known. A solution for the latter was found in 1969 by <a href="Elwyn_Berlekamp" title="wikilink">Elwyn Berlekamp</a> and <a href="James_Massey" title="wikilink">James Massey</a>, and is since known as the <a href="Berlekamp–Massey_algorithm" title="wikilink">Berlekamp–Massey decoding algorithm</a>. In 1977, Reed–Solomon codes were notably implemented in the <a href="Voyager_program" title="wikilink">Voyager program</a> in the form of <a href="concatenated_codes" title="wikilink">concatenated codes</a>. The first commercial application in mass-produced consumer products appeared in 1982 with the <a href="compact_disc" title="wikilink">compact disc</a>, where two <a href="forward_error_correction#Interleaving" title="wikilink">interleaved</a> Reed–Solomon codes are used. Today, Reed–Solomon codes are widely implemented in <a href="digital_storage" title="wikilink">digital storage</a> devices and <a href="digital_communication" title="wikilink">digital communication</a> standards, though they are being slowly replaced by more modern <a href="low-density_parity-check_code" title="wikilink">low-density parity-check (LDPC) codes</a> or <a href="turbo_code" title="wikilink">turbo codes</a>. For example, Reed–Solomon codes are used in the <a href="digital_video_broadcasting" title="wikilink">digital video broadcasting (DVB)</a> standard <a class="uri" href="DVB-S" title="wikilink">DVB-S</a>, but <a href="Low-density_parity-check_code" title="wikilink">LDPC</a> codes are used in its successor <a class="uri" href="DVB-S2" title="wikilink">DVB-S2</a>.</p>
<h2 id="basis">Basis</h2>

<p>The Reed–Solomon code is based on univariate polynomials over finite fields; in particular, for some parameters 

<math display="inline" id="Reed–Solomon_error_correction:7">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Reed–Solomon_error_correction:8">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, the codewords of the Reed–Solomon code consists of all <a href="function_table" title="wikilink">function tables</a> of polynomials of degree less than 

<math display="inline" id="Reed–Solomon_error_correction:9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 over the finite field with 

<math display="inline" id="Reed–Solomon_error_correction:10">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 elements - for this to work, 

<math display="inline" id="Reed–Solomon_error_correction:11">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 has to be <a href="prime_power" title="wikilink">prime power</a>. The encoding scheme of the Reed–Solomon code turns 

<math display="inline" id="Reed–Solomon_error_correction:12">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 symbols into such a function table, which is essentially a list of 

<math display="inline" id="Reed–Solomon_error_correction:13">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 symbols. One way to perform this encoding is by interpreting the 

<math display="inline" id="Reed–Solomon_error_correction:14">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 given symbols as the first segment of the function table of a polynomial of degree less than 

<math display="inline" id="Reed–Solomon_error_correction:15">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. A simple argument shows that there is exactly one such polynomial, and the remaining 

<math display="inline" id="Reed–Solomon_error_correction:16">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−k
  </annotation>
 </semantics>
</math>

 symbols can thus be generated by evaluating the polynomial at those points. Since the 

<math display="inline" id="Reed–Solomon_error_correction:17">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 transmitted symbols form an <a href="overdetermined_system" title="wikilink">overdetermined system</a> that specifies a polynomial of degree less than 

<math display="inline" id="Reed–Solomon_error_correction:18">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, we can use <a class="uri" href="interpolation" title="wikilink">interpolation</a> techniques at the receiver to recover the original message in case not too many errors happened.</p>

<p>In order to achieve the most efficient decoding procedures, the encoding procedure of the Reed–Solomon code is often constructed a bit differently, namely as cyclic <a href="BCH_code" title="wikilink">BCH codes</a>: the 

<math display="inline" id="Reed–Solomon_error_correction:19">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 source symbols are interpreted as the <em>coefficients</em> of a polynomial of degree less than 

<math display="inline" id="Reed–Solomon_error_correction:20">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, and the additional 

<math display="inline" id="Reed–Solomon_error_correction:21">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−k
  </annotation>
 </semantics>
</math>

 symbols are derived from the coefficients of a polynomial constructed by multiplying 

<math display="inline" id="Reed–Solomon_error_correction:22">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

 with a cyclic <a href="generator_polynomial" title="wikilink">generator polynomial</a>.</p>
<h2 id="applications">Applications</h2>
<h3 id="data-storage">Data storage</h3>

<p>Reed–Solomon coding is very widely used in mass storage systems to correct the burst errors associated with media defects.</p>

<p>Reed–Solomon coding is a key component of the <a href="compact_disc" title="wikilink">compact disc</a>. It was the first use of strong error correction coding in a mass-produced consumer product, and <a href="digital_audio_tape" title="wikilink">DAT</a> and <a class="uri" href="DVD" title="wikilink">DVD</a> use similar schemes. In the CD, two layers of Reed–Solomon coding separated by a 28-way <a href="convolution" title="wikilink">convolutional</a> <a class="uri" href="interleaver" title="wikilink">interleaver</a> yields a scheme called Cross-Interleaved Reed–Solomon Coding (<a href="Cross-interleaved_Reed–Solomon_coding" title="wikilink">CIRC</a>). The first element of a CIRC decoder is a relatively weak inner (32,28) Reed–Solomon code, shortened from a (255,251) code with 8-bit symbols. This code can correct up to 2 byte errors per 32-byte block. More importantly, it flags as erasures any uncorrectable blocks, i.e., blocks with more than 2 byte errors. The decoded 28-byte blocks, with erasure indications, are then spread by the deinterleaver to different blocks of the (28,24) outer code. Thanks to the deinterleaving, an erased 28-byte block from the inner code becomes a single erased byte in each of 28 outer code blocks. The outer code easily corrects this, since it can handle up to 4 such erasures per block.</p>

<p>The result is a CIRC that can completely correct error bursts up to 4000 bits, or about 2.5 mm on the disc surface. This code is so strong that most CD playback errors are almost certainly caused by tracking errors that cause the laser to jump track, not by uncorrectable error bursts.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>DVDs use a similar scheme, but with much larger blocks, a (208,192) inner code, and a (182,172) outer code.</p>

<p>Reed–Solomon error correction is also used in <a class="uri" href="parchive" title="wikilink">parchive</a> files which are commonly posted accompanying multimedia files on <a class="uri" href="USENET" title="wikilink">USENET</a>. The Distributed online storage service <a class="uri" href="Wuala" title="wikilink">Wuala</a> also makes use of Reed–Solomon when breaking up files.</p>
<h3 id="bar-code">Bar code</h3>

<p>Almost all two-dimensional bar codes such as <a class="uri" href="PDF-417" title="wikilink">PDF-417</a>, <a class="uri" href="MaxiCode" title="wikilink">MaxiCode</a>, <a class="uri" href="Datamatrix" title="wikilink">Datamatrix</a>, <a href="QR_Code" title="wikilink">QR Code</a>, and <a href="Aztec_Code" title="wikilink">Aztec Code</a> use Reed–Solomon error correction to allow correct reading even if a portion of the bar code is damaged. When the bar code scanner cannot recognize a bar code symbol, it will treat it as an erasure.</p>

<p>Reed–Solomon coding is less common in one-dimensional bar codes, but is used by the <a class="uri" href="PostBar" title="wikilink">PostBar</a> symbology.</p>
<h3 id="data-transmission">Data transmission</h3>

<p>Specialized forms of Reed–Solomon codes, specifically <a href="Cauchy_matrix" title="wikilink">Cauchy</a>-RS and <a href="Vandermonde_matrix" title="wikilink">Vandermonde</a>-RS, can be used to overcome the unreliable nature of data transmission over <a href="Binary_erasure_channel" title="wikilink">erasure channels</a>. The encoding process assumes a code of RS(<em>N</em>, <em>K</em>) which results in <em>N</em> codewords of length <em>N</em> symbols each storing <em>K</em> symbols of data, being generated, that are then sent over an erasure channel.</p>

<p>Any combination of <em>K</em> codewords received at the other end is enough to reconstruct all of the <em>N</em> codewords. The code rate is generally set to 1/2 unless the channel's erasure likelihood can be adequately modelled and is seen to be less. In conclusion, <em>N</em> is usually 2<em>K</em>, meaning that at least half of all the codewords sent must be received in order to reconstruct all of the codewords sent.</p>

<p>Reed–Solomon codes are also used in <a class="uri" href="xDSL" title="wikilink">xDSL</a> systems and <a class="uri" href="CCSDS" title="wikilink">CCSDS</a>'s <a href="Space_Communications_Protocol_Specifications" title="wikilink">Space Communications Protocol Specifications</a> as a form of <a href="forward_error_correction" title="wikilink">forward error correction</a>.</p>
<h3 id="space-transmission">Space transmission</h3>

<p>One significant application of Reed–Solomon coding was to encode the digital pictures sent back by the <a href="Voyager_program" title="wikilink">Voyager</a> space probe.</p>

<p>Voyager introduced Reed–Solomon coding <a href="concatenated_code" title="wikilink">concatenated</a> with <a href="convolutional_code" title="wikilink">convolutional codes</a>, a practice that has since become very widespread in deep space and satellite (e.g., direct digital broadcasting) communications.</p>

<p><a href="Viterbi_decoder" title="wikilink">Viterbi decoders</a> tend to produce errors in short bursts. Correcting these burst errors is a job best done by short or simplified Reed–Solomon codes.</p>

<p>Modern versions of concatenated Reed–Solomon/Viterbi-decoded convolutional coding were and are used on the <a href="Mars_Pathfinder" title="wikilink">Mars Pathfinder</a>, <a href="Galileo_probe" title="wikilink">Galileo</a>, <a href="Mars_Exploration_Rover" title="wikilink">Mars Exploration Rover</a> and <a href="Cassini_probe" title="wikilink">Cassini</a> missions, where they perform within about 1–1.5 <a href="decibel" title="wikilink">dB</a> of the ultimate limit imposed by the <a href="Shannon_capacity" title="wikilink">Shannon capacity</a>.</p>

<p>These concatenated codes are now being replaced by more powerful <a href="turbo_code" title="wikilink">turbo codes</a>.</p>
<h2 id="constructions">Constructions</h2>

<p>The Reed–Solomon code is actually a family of codes: For every choice of the three parameters <em>k</em> a_1,\dots,a_n of the field <em>F</em>, and the sequence of values is the corresponding codeword. Formally, the set 

<math display="inline" id="Reed–Solomon_error_correction:23">
 <semantics>
  <mi>𝐂</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐂</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}
  </annotation>
 </semantics>
</math>

 of codewords of the Reed–Solomon code is defined as follows:</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:24">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k-1
  </annotation>
 </semantics>
</math>

 agree in at most 

<math display="inline" id="Reed–Solomon_error_correction:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-(k-1)=n-k+1
  </annotation>
 </semantics>
</math>

 points, this means that any two codewords of the Reed–Solomon code disagree in at least 

<math display="inline" id="Reed–Solomon_error_correction:26">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k-1
  </annotation>
 </semantics>
</math>

 positions. Furthermore, there are two polynomials that do agree in 

<math display="inline" id="Reed–Solomon_error_correction:27">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=n-k+1
  </annotation>
 </semantics>
</math>

 points but are not equal, and thus, the <a href="Block_code#The_distance_d" title="wikilink">distance</a> of the Reed–Solomon code is exactly 

<math display="inline" id="Reed–Solomon_error_correction:28">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>=</mo>
   <mrow>
    <mi>d</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>k</mi>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>∼</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>δ</ci>
     <apply>
      <divide></divide>
      <ci>d</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <ci>k</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta=d/n=1-k/n+1/n\sim 1-R
  </annotation>
 </semantics>
</math>

. Then the relative distance is 

<math display="inline" id="Reed–Solomon_error_correction:29">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <divide></divide>
     <ci>k</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=k/n
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Reed–Solomon_error_correction:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mo>+</mo>
    <mi>R</mi>
   </mrow>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <ci>δ</ci>
     <ci>R</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta+R\leq 1
  </annotation>
 </semantics>
</math>

 is the rate. This trade-off between the relative distance and the rate is asymptotically optimal since, by the <a href="Singleton_bound" title="wikilink">Singleton bound</a>, <em>every</em> code satisfies 

<math display="inline" id="Reed–Solomon_error_correction:31">
 <semantics>
  <msup>
   <mi>q</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{k}
  </annotation>
 </semantics>
</math>

. Being a code that achieves this optimal trade-off, the Reed–Solomon code belongs to the class of <a href="maximum_distance_separable_code" title="wikilink">maximum distance separable codes</a>.</p>

<p>While the number of different polynomials of degree less than <em>k</em> and the number of different messages are both equal to 

<math display="inline" id="Reed–Solomon_error_correction:32">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},\dots,a_{k}
  </annotation>
 </semantics>
</math>

, and thus every message can be uniquely mapped to such a polynomial, there are different ways of doing this encoding. The original construction of  interprets the message <em>x</em> as the <em>coefficients</em> of the polynomial <em>p</em>, whereas subsequent constructions interpret the message as the <em>values</em> of the polynomial at the first <em>k</em> points 

<math display="inline" id="Reed–Solomon_error_correction:33">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},\dots,a_{n}
  </annotation>
 </semantics>
</math>

 and obtain the polynomial <em>p</em> by interpolating these values with a polynomial of degree less than <em>k</em>. The latter encoding procedure, while being slightly less efficient, has the advantage that it gives rise to a <a href="systematic_code" title="wikilink">systematic code</a>, that is, the original message is always contained as a subsequence of the codeword.</p>

<p>In many contexts it is convenient to choose the sequence 

<math display="inline" id="Reed–Solomon_error_correction:34">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 of evaluation points so that they exhibit some additional structure. In particular, it is useful to choose the sequence of successive powers of a <a href="primitive_root_modulo_n" title="wikilink">primitive root</a> 

<math display="inline" id="Reed–Solomon_error_correction:35">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 of the field 

<math display="inline" id="Reed–Solomon_error_correction:36">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, that is, 

<math display="inline" id="Reed–Solomon_error_correction:37">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mi>α</mi>
    <mi>i</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}=\alpha^{i}
  </annotation>
 </semantics>
</math>

 is generator of the finite field's <a href="multiplicative_group" title="wikilink">multiplicative group</a> and the sequence is defined as 

<math display="inline" id="Reed–Solomon_error_correction:38">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>q</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>q</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\dots,q-1
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Reed–Solomon_error_correction:39">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

. This sequence contains all elements of 

<math display="inline" id="Reed–Solomon_error_correction:40">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 except for 

<math display="inline" id="Reed–Solomon_error_correction:41">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mi>q</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <minus></minus>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=q-1
  </annotation>
 </semantics>
</math>

, so in this setting, the block length is 

<math display="inline" id="Reed–Solomon_error_correction:42">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(a)
  </annotation>
 </semantics>
</math>

. Then it follows that, whenever 

<math display="inline" id="Reed–Solomon_error_correction:43">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is a polynomial over 

<math display="inline" id="Reed–Solomon_error_correction:44">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>α</mi>
     <mi>a</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\alpha a)
  </annotation>
 </semantics>
</math>

, then the function 

<math display="inline" id="Reed–Solomon_error_correction:45">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(a)
  </annotation>
 </semantics>
</math>

 is also a polynomial of the same degree, which gives rise to a codeword that is a <a href="circular_shift" title="wikilink">cyclic left-shift</a> of the codeword derived from 

<math display="inline" id="Reed–Solomon_error_correction:46">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>F</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=(x_{1},\dots,x_{k})\in F^{k}
  </annotation>
 </semantics>
</math>

; thus, this construction of Reed–Solomon codes gives rise to a <a href="cyclic_code" title="wikilink">cyclic code</a>.</p>
<h4 id="simple-encoding-procedure-the-message-as-a-sequence-of-coefficients">Simple encoding procedure: The message as a sequence of coefficients</h4>

<p>In the original construction of , the message 

<math display="inline" id="Reed–Solomon_error_correction:47">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}
  </annotation>
 </semantics>
</math>

 is mapped to the polynomial 

<math display="block" id="Reed–Solomon_error_correction:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>x</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>k</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mpadded width="+1.7pt">
       <msup>
        <mi>a</mi>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mpadded>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>x</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}(a)=\sum_{i=1}^{k}x_{i}a^{i-1}\,.
  </annotation>
 </semantics>
</math>

 with</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:49">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 As described above, the codeword is then obtained by evaluating 

<math display="inline" id="Reed–Solomon_error_correction:50">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Reed–Solomon_error_correction:51">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},\dots,a_{n}
  </annotation>
 </semantics>
</math>

 different points 

<math display="inline" id="Reed–Solomon_error_correction:52">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 of the field 

<math display="inline" id="Reed–Solomon_error_correction:53">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>F</mi>
     <mi>k</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>F</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>C</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C:F^{k}\to F^{n}
  </annotation>
 </semantics>
</math>

. Thus the classical encoding function 

<math display="block" id="Reed–Solomon_error_correction:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo maxsize="120%" minsize="120%">(</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo maxsize="120%" minsize="120%" rspace="4.2pt">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>x</ci>
    </apply>
    <vector>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(x)=\big(p_{x}(a_{1}),\dots,p_{x}(a_{n})\big)\,.
  </annotation>
 </semantics>
</math>

 for the Reed–Solomon code is defined as follows:</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:55">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 This function 

<math display="inline" id="Reed–Solomon_error_correction:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>⋅</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>x</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(x)=x\cdot A
  </annotation>
 </semantics>
</math>

 is a <a href="linear_mapping" title="wikilink">linear mapping</a>, that is, it satisfies 

<math display="inline" id="Reed–Solomon_error_correction:57">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>k</mi>
    <mo>×</mo>
    <mi>n</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (k\times n)
  </annotation>
 </semantics>
</math>

 for the following 

<math display="inline" id="Reed–Solomon_error_correction:58">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

-matrix 

<math display="inline" id="Reed–Solomon_error_correction:59">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 with elements from 

<math display="block" id="Reed–Solomon_error_correction:60">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">…</mi>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">…</mi>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mi>n</mi>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msubsup>
        <mi>a</mi>
        <mn>1</mn>
        <mn>2</mn>
       </msubsup>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">…</mi>
      </mtd>
      <mtd columnalign="center">
       <msubsup>
        <mi>a</mi>
        <mi>n</mi>
        <mn>2</mn>
       </msubsup>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋱</mi>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msubsup>
        <mi>a</mi>
        <mn>1</mn>
        <mrow>
         <mi>k</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">…</mi>
      </mtd>
      <mtd columnalign="center">
       <msubsup>
        <mi>a</mi>
        <mi>n</mi>
        <mrow>
         <mi>k</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
      <ci>normal-⋱</ci>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\begin{bmatrix}1&\dots&1\\
a_{1}&\dots&a_{n}\\
a_{1}^{2}&\dots&a_{n}^{2}\\
\vdots&\ddots&\vdots\\
a_{1}^{k-1}&\dots&a_{n}^{k-1}\end{bmatrix}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:61">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>


 This matrix is the transpose of a <a href="Vandermonde_matrix" title="wikilink">Vandermonde matrix</a> over 

<math display="inline" id="Reed–Solomon_error_correction:62">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. In other words, the Reed–Solomon code is a <a href="linear_code" title="wikilink">linear code</a>, and in the classical encoding procedure, its <a href="Linear_code#Properties" title="wikilink">generator matrix</a> is 

<math display="inline" id="Reed–Solomon_error_correction:63">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="systematic-encoding-procedure-the-message-as-an-initial-sequence-of-values">Systematic encoding procedure: The message as an initial sequence of values</h4>

<p>As mentioned above, there is an alternative way to map codewords 

<math display="inline" id="Reed–Solomon_error_correction:64">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}
  </annotation>
 </semantics>
</math>

 to polynomials 

<math display="inline" id="Reed–Solomon_error_correction:65">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}
  </annotation>
 </semantics>
</math>

. In this alternative encoding procedure, the polynomial 

<math display="inline" id="Reed–Solomon_error_correction:66">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 is the unique polynomial of degree less than 

<math display="block" id="Reed–Solomon_error_correction:67">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}(a_{i})=x_{i}
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:68">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\dots,k
  </annotation>
 </semantics>
</math>

 holds for all 

<math display="inline" id="Reed–Solomon_error_correction:69">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}
  </annotation>
 </semantics>
</math>

. To compute this polynomial 

<math display="inline" id="Reed–Solomon_error_correction:70">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Reed–Solomon_error_correction:71">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k+1},\dots,a_{n}
  </annotation>
 </semantics>
</math>


, one can use <a href="Lagrange_interpolation" title="wikilink">Lagrange interpolation</a>. Once it has been found, it is evaluated at the other points 

<math display="inline" id="Reed–Solomon_error_correction:72">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>F</mi>
     <mi>k</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>F</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>C</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C:F^{k}\to F^{n}
  </annotation>
 </semantics>
</math>

 of the field. The alternative encoding function 

<math display="block" id="Reed–Solomon_error_correction:73">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo maxsize="120%" minsize="120%">(</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo maxsize="120%" minsize="120%" rspace="4.2pt">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>x</ci>
    </apply>
    <vector>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(x)=\big(p_{x}(a_{1}),\dots,p_{x}(a_{n})\big)\,.
  </annotation>
 </semantics>
</math>

 for the Reed–Solomon code is then again just the sequence of values:</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:74">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 This time, however, the first 

<math display="inline" id="Reed–Solomon_error_correction:75">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 entries of the codeword are exactly equal to 

<math display="inline" id="Reed–Solomon_error_correction:76">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


, so this encoding procedure gives rise to a <a href="systematic_code" title="wikilink">systematic code</a>. It can be checked that the alternative encoding function is a linear mapping as well.</p>
<h3 id="the-bch-view-the-codeword-as-a-sequence-of-coefficients">The BCH view: The codeword as a sequence of coefficients</h3>

<p>In this view, the sender again maps the message 

<math display="inline" id="Reed–Solomon_error_correction:77">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}
  </annotation>
 </semantics>
</math>

 to a polynomial 

<math display="inline" id="Reed–Solomon_error_correction:78">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}
  </annotation>
 </semantics>
</math>

, and for this, any of the two mappings above can be used (where the message is either interpreted as the coefficients of 

<math display="inline" id="Reed–Solomon_error_correction:79">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}
  </annotation>
 </semantics>
</math>

 or as the initial sequence of values of 

<math display="inline" id="Reed–Solomon_error_correction:80">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}
  </annotation>
 </semantics>
</math>

). Once the sender has constructed the polynomial 

<math display="inline" id="Reed–Solomon_error_correction:81">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}
  </annotation>
 </semantics>
</math>


 in some way, however, instead of sending the <em>values</em> of 

<math display="inline" id="Reed–Solomon_error_correction:82">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 at all points, the sender computes some related polynomial 

<math display="inline" id="Reed–Solomon_error_correction:83">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

 of degree at most 

<math display="inline" id="Reed–Solomon_error_correction:84">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mi>q</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <minus></minus>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=q-1
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Reed–Solomon_error_correction:85">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and sends the 

<math display="inline" id="Reed–Solomon_error_correction:86">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(a)
  </annotation>
 </semantics>
</math>


 <em>coefficients</em> of that polynomial. The polynomial 

<math display="inline" id="Reed–Solomon_error_correction:87">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}(a)
  </annotation>
 </semantics>
</math>

 is constructed by multiplying the message polynomial 

<math display="inline" id="Reed–Solomon_error_correction:88">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k-1
  </annotation>
 </semantics>
</math>

, which has degree at most 

<math display="inline" id="Reed–Solomon_error_correction:89">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(a)
  </annotation>
 </semantics>
</math>

, with a <a href="generator_polynomial" title="wikilink">generator polynomial</a> 

<math display="inline" id="Reed–Solomon_error_correction:90">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k
  </annotation>
 </semantics>
</math>

 of degree 

<math display="inline" id="Reed–Solomon_error_correction:91">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>


 that is known to both the sender and the receiver.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The generator polynomial 

<math display="inline" id="Reed–Solomon_error_correction:92">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>,</mo>
   <msup>
    <mi>α</mi>
    <mn>2</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>α</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>α</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha,\alpha^{2},\dots,\alpha^{n-k}
  </annotation>
 </semantics>
</math>

 is defined as the polynomial whose roots are exactly 

<math display="block" id="Reed–Solomon_error_correction:93">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mi>α</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msup>
        <mi>α</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">⋯</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msup>
        <mi>α</mi>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mi>k</mi>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>g</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mn>1</mn>
      </msub>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msup>
       <mi>x</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>+</mo>
     <mpadded width="+1.7pt">
      <msup>
       <mi>x</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>k</mi>
       </mrow>
      </msup>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>α</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>x</ci>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=(x-\alpha)(x-\alpha^{2})\cdots(x-\alpha^{n-k})=g_{0}+g_{1}x+\cdots+g_{n-k%
-1}x^{n-k-1}+x^{n-k}\,.
  </annotation>
 </semantics>
</math>

, i.e.,</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:94">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mi>q</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <minus></minus>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=q-1
  </annotation>
 </semantics>
</math>

</p>

<p>The transmitter sends the 

<math display="inline" id="Reed–Solomon_error_correction:95">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi>g</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>x</ci>
       </apply>
       <ci>a</ci>
      </apply>
      <ci>g</ci>
     </apply>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(a)=p_{x}(a)\cdot g(a)
  </annotation>
 </semantics>
</math>

 coefficients of 

<math display="inline" id="Reed–Solomon_error_correction:96">
 <semantics>
  <msup>
   <mi>𝐂</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐂</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C^{\prime}}
  </annotation>
 </semantics>
</math>


. Thus, in the BCH view of Reed Solomon codes, the set 

<math display="inline" id="Reed–Solomon_error_correction:97">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mi>q</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <minus></minus>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=q-1
  </annotation>
 </semantics>
</math>

 of codewords is defined for 

<math display="block" id="Reed–Solomon_error_correction:98">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐂</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mo maxsize="160%" minsize="160%" rspace="5.3pt">{</mo>
     <mrow>
      <mo maxsize="120%" minsize="120%">(</mo>
      <msub>
       <mi>s</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>s</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>s</mi>
       <mi>n</mi>
      </msub>
      <mo maxsize="120%" minsize="120%" rspace="5.3pt">)</mo>
     </mrow>
     <mo mathsize="160%" rspace="5.3pt" stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mi>s</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </munderover>
        <mrow>
         <msub>
          <mi>s</mi>
          <mi>i</mi>
         </msub>
         <msup>
          <mi>a</mi>
          <mrow>
           <mi>i</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
         <mtext>is a polynomial that has at least the roots</mtext>
         <msup>
          <mi>α</mi>
          <mn>1</mn>
         </msup>
        </mrow>
       </mrow>
       <mo>,</mo>
       <msup>
        <mi>α</mi>
        <mn>2</mn>
       </msup>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mpadded width="+2.8pt">
        <msup>
         <mi>α</mi>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mi>k</mi>
         </mrow>
        </msup>
       </mpadded>
      </mrow>
     </mrow>
     <mo maxsize="160%" minsize="160%" rspace="4.2pt">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐂</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>n</ci>
      </apply>
     </vector>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>a</ci>
      </apply>
      <list>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>a</ci>
          <apply>
           <minus></minus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <mtext>is a polynomial that has at least the roots</mtext>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>α</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C^{\prime}}=\Big\{\;\big(s_{1},s_{2},\dots,s_{n}\big)\;\Big|\;s(a)=%
\sum_{i=1}^{n}s_{i}a^{i-1}\text{ is a polynomial that has at least the roots }%
\alpha^{1},\alpha^{2},\dots,\alpha^{n-k}\;\Big\}\,.
  </annotation>
 </semantics>
</math>

 as follows:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:99">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(a)
  </annotation>
 </semantics>
</math>

 With this definition of the codewords, it can be immediately seen that a Reed–Solomon code is a <a href="polynomial_code" title="wikilink">polynomial code</a>, and in particular a <a href="BCH_code" title="wikilink">BCH code</a>. The generator polynomial 

<math display="inline" id="Reed–Solomon_error_correction:100">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>,</mo>
   <msup>
    <mi>α</mi>
    <mn>2</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>α</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>α</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha,\alpha^{2},\ldots,\alpha^{n-k}
  </annotation>
 </semantics>
</math>


 is the minimal polynomial with roots 

<math display="inline" id="Reed–Solomon_error_correction:101">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(a)
  </annotation>
 </semantics>
</math>

 as defined above, and the codewords are exactly the polynomials that are divisible by 

<math display="inline" id="Reed–Solomon_error_correction:102">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(a)
  </annotation>
 </semantics>
</math>

.</p>

<p>Since Reed–Solomon codes are a special case of <a href="BCH_code" title="wikilink">BCH codes</a> and the <a href="Berlekamp–Massey_algorithm" title="wikilink">Berlekamp–Massey algorithm</a> has been designed for the decoding of such codes, it is applicable to Reed–Solomon codes: The receiver interprets the received word as the coefficients of a polynomial 

<math display="inline" id="Reed–Solomon_error_correction:103">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(a)=s(a)
  </annotation>
 </semantics>
</math>

. If no error has occurred during the transmission, that is, if 

<math display="inline" id="Reed–Solomon_error_correction:104">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>r</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <mi>g</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>x</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>a</ci>
      </apply>
      <ci>g</ci>
     </apply>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{x}(a)=r(a)/g(a)
  </annotation>
 </semantics>
</math>

, then the receiver can use <a href="polynomial_division" title="wikilink">polynomial division</a> to determine the message polynomial 

<math display="inline" id="Reed–Solomon_error_correction:105">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(a)
  </annotation>
 </semantics>
</math>


. In general, the receiver can use polynomial division to construct the unique polynomials 

<math display="inline" id="Reed–Solomon_error_correction:106">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(a)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Reed–Solomon_error_correction:107">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(a)
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Reed–Solomon_error_correction:108">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(a)
  </annotation>
 </semantics>
</math>

 has degree less than the degree of 

<math display="block" id="Reed–Solomon_error_correction:109">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>r</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>a</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <mi>g</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>a</ci>
       </apply>
       <ci>g</ci>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(a)=p(a)\cdot g(a)+e(a)\,.
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:110">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(a)
  </annotation>
 </semantics>
</math>


 If the remainder polynomial 

<math display="inline" id="Reed–Solomon_error_correction:111">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(a)
  </annotation>
 </semantics>
</math>

 is not identically zero, then an error has occurred during the transmission. The receiver can evaluate 

<math display="inline" id="Reed–Solomon_error_correction:112">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(a)
  </annotation>
 </semantics>
</math>

 at the roots of 

<math display="inline" id="Reed–Solomon_error_correction:113">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(a)
  </annotation>
 </semantics>
</math>

 and build a system of equations that eliminates 

<math display="inline" id="Reed–Solomon_error_correction:114">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(a)
  </annotation>
 </semantics>
</math>

 and identifies which coefficients of 

<math display="inline" id="Reed–Solomon_error_correction:115">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(a)
  </annotation>
 </semantics>
</math>


 are in error, and the magnitude of each coefficient's error ( and ). If the system of equations can be solved, then the receiver knows how to modify the received word 

<math display="inline" id="Reed–Solomon_error_correction:116">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(a)
  </annotation>
 </semantics>
</math>

 to get the most likely codeword 

<math display="inline" id="Reed–Solomon_error_correction:117">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>x</ci>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)=p(x)g(x)
  </annotation>
 </semantics>
</math>

 that was sent.</p>
<h4 id="systematic-encoding-procedure">Systematic encoding procedure</h4>

<p>The above encoding procedure for the BCH view of Reed–Solomon codes is classical, but does not give rise to a <a href="systematic_code" title="wikilink">systematic encoding procedure</a>, i.e., the codewords do not necessarily contain the message as a subsequence. To remedy this fact, instead of sending 

<math display="inline" id="Reed–Solomon_error_correction:118">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)
  </annotation>
 </semantics>
</math>

, the encoder constructs the transmitted polynomial 

<math display="inline" id="Reed–Solomon_error_correction:119">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 such that the coefficients of the 

<math display="inline" id="Reed–Solomon_error_correction:120">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>


 largest monomials are equal to the corresponding coefficients of 

<math display="inline" id="Reed–Solomon_error_correction:121">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)
  </annotation>
 </semantics>
</math>

, and the lower-order coefficients of 

<math display="inline" id="Reed–Solomon_error_correction:122">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)
  </annotation>
 </semantics>
</math>

 are chosen exactly in such a way that 

<math display="inline" id="Reed–Solomon_error_correction:123">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

 becomes evenly divisible by 

<math display="inline" id="Reed–Solomon_error_correction:124">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

. Then the coefficients of 

<math display="inline" id="Reed–Solomon_error_correction:125">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)
  </annotation>
 </semantics>
</math>


 are a subsequence of the coefficients of 

<math display="inline" id="Reed–Solomon_error_correction:126">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

. To get a code that is overall systematic, we construct the message polynomial 

<math display="inline" id="Reed–Solomon_error_correction:127">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

 by interpreting the message as the sequence of its coefficients.</p>

<p>Formally, the construction is done by multiplying 

<math display="inline" id="Reed–Solomon_error_correction:128">
 <semantics>
  <msup>
   <mi>x</mi>
   <mi>t</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{t}
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Reed–Solomon_error_correction:129">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=n-k
  </annotation>
 </semantics>
</math>

 to make room for the 

<math display="inline" id="Reed–Solomon_error_correction:130">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>


 check symbols, dividing that product by 

<math display="inline" id="Reed–Solomon_error_correction:131">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 to find the remainder, and then compensating for that remainder by subtracting it. The 

<math display="inline" id="Reed–Solomon_error_correction:132">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>r</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>r</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{r}(x)
  </annotation>
 </semantics>
</math>

 check symbols are created by computing the remainder 

<math display="block" id="Reed–Solomon_error_correction:133">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>s</mi>
      <mi>r</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <mpadded width="+5pt">
       <msup>
        <mi>x</mi>
        <mi>t</mi>
       </msup>
      </mpadded>
     </mrow>
     <mo lspace="2.5pt" rspace="7.5pt">mod</mo>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>r</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{r}(x)=p(x)\cdot x^{t}\ \bmod\ g(x)\,.
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:134">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t-1
  </annotation>
 </semantics>
</math>

 Note that the remainder has degree at most 

<math display="inline" id="Reed–Solomon_error_correction:135">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>x</mi>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>x</mi>
    <mn>1</mn>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>x</mi>
    <mn>0</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{t-1},x^{t-2},\dots,x^{1},x^{0}
  </annotation>
 </semantics>
</math>


, whereas the coefficients of 

<math display="inline" id="Reed–Solomon_error_correction:136">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⋅</mo>
   <msup>
    <mi>x</mi>
    <mi>t</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)\cdot x^{t}
  </annotation>
 </semantics>
</math>

 in the polynomial 

<math display="inline" id="Reed–Solomon_error_correction:137">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)
  </annotation>
 </semantics>
</math>

 are zero. Therefore, the following definition of the codeword 

<math display="inline" id="Reed–Solomon_error_correction:138">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 has the property that the first 

<math display="inline" id="Reed–Solomon_error_correction:139">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

 coefficients are identical to the coefficients of 

<math display="block" id="Reed–Solomon_error_correction:140">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <msup>
       <mi>x</mi>
       <mi>t</mi>
      </msup>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>s</mi>
       <mi>r</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>r</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)=p(x)\cdot x^{t}-s_{r}(x)\,.
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:141">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)
  </annotation>
 </semantics>
</math>

 As a result, the codewords 

<math display="inline" id="Reed–Solomon_error_correction:142">
 <semantics>
  <msup>
   <mi>𝐂</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐂</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C^{\prime}}
  </annotation>
 </semantics>
</math>

 are indeed elements of 

<math display="inline" id="Reed–Solomon_error_correction:143">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

, that is, they are evenly divisible by the generator polynomial 

<math display="block" id="Reed–Solomon_error_correction:144">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <msup>
       <mi>x</mi>
       <mi>t</mi>
      </msup>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>s</mi>
       <mi>r</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>s</mi>
       <mi>r</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>s</mi>
       <mi>r</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mn>0</mn>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>r</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>r</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>r</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <cn type="integer">0</cn>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)\equiv p(x)\cdot x^{t}-s_{r}(x)\equiv s_{r}(x)-s_{r}(x)\equiv 0\mod g(x)\,.
  </annotation>
 </semantics>
</math>

:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:145">
 <semantics>
  <mi>𝐂</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐂</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}
  </annotation>
 </semantics>
</math>


</p>
<h3 id="equivalence-of-the-two-views">Equivalence of the two views</h3>

<p>At first sight, the two views of Reed–Solomon codes above seem very different. In the first definition, codewords in the set 

<math display="inline" id="Reed–Solomon_error_correction:146">
 <semantics>
  <msup>
   <mi>𝐂</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐂</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C^{\prime}}
  </annotation>
 </semantics>
</math>

 are <em>values</em> of polynomials, whereas in the second set 

<math display="inline" id="Reed–Solomon_error_correction:147">
 <semantics>
  <mrow>
   <mi>𝐂</mi>
   <mo>=</mo>
   <msup>
    <mi>𝐂</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐂</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐂</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}=\mathbf{C^{\prime}}
  </annotation>
 </semantics>
</math>

, they are <em>coefficients</em>. Moreover, the polynomials in the first definition are required to be of small degree, whereas those in the second definition are required to have specific roots. Yet, it can be shown that the two sets are actually equal, that is, 

<math display="inline" id="Reed–Solomon_error_correction:148">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},\dots,a_{n}
  </annotation>
 </semantics>
</math>

 holds (for an appropriate choice of 

<math display="inline" id="Reed–Solomon_error_correction:149">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

).</p>

<p>The equivalence of the two definitions is proved using the <a href="discrete_Fourier_transform_(general)" title="wikilink">discrete Fourier transform</a>. This transform, which exists in all finite fields as well as the complex numbers, establishes a duality between the coefficients of polynomials and their values. This duality can be approximately summarized as follows: Let 

<math display="inline" id="Reed–Solomon_error_correction:150">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>q</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(x)
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Reed–Solomon_error_correction:151">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 be two polynomials of degree less than 

<math display="inline" id="Reed–Solomon_error_correction:152">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

. If the <em>values</em> of 

<math display="inline" id="Reed–Solomon_error_correction:153">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>q</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(x)
  </annotation>
 </semantics>
</math>

 are the <em>coefficients</em> of 

<math display="inline" id="Reed–Solomon_error_correction:154">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>q</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(x)
  </annotation>
 </semantics>
</math>

, then (up to a scalar factor and reordering), the <em>values</em> of 

<math display="inline" id="Reed–Solomon_error_correction:155">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>


 are the <em>coefficients</em> of 

<math display="inline" id="Reed–Solomon_error_correction:156">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <msup>
    <mi>α</mi>
    <mi>i</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\alpha^{i}
  </annotation>
 </semantics>
</math>

. For this to make sense, the values must be taken at locations 

<math display="inline" id="Reed–Solomon_error_correction:157">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=0,\dots,n-1
  </annotation>
 </semantics>
</math>

, for 

<math display="inline" id="Reed–Solomon_error_correction:158">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Reed–Solomon_error_correction:159">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is a <a href="primitive_nth_root_of_unity" title="wikilink">primitive 

<math display="block" id="Reed–Solomon_error_correction:160">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>v</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>v</mi>
       <mn>1</mn>
      </msub>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>v</mi>
       <mn>2</mn>
      </msub>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>v</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msup>
       <mi>x</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=v_{0}+v_{1}x+v_{2}x^{2}+\cdots+v_{n-1}x^{n-1},
  </annotation>
 </semantics>
</math>

th root of unity</a>.</p>

<p>To be more precise, let</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:161">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msup>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>q</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(x)=f_{0}+f_{1}x+f_{2}x^{2}+\cdots+f_{n-1}x^{n-1}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:162">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

 and assume 

<math display="inline" id="Reed–Solomon_error_correction:163">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>q</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Reed–Solomon_error_correction:164">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

 are related by the discrete Fourier transform. Then the coefficients and values of 

<math display="inline" id="Reed–Solomon_error_correction:165">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>q</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(x)
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Reed–Solomon_error_correction:166">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=0,\dots,n-1
  </annotation>
 </semantics>
</math>

 are related as follows: for all 

<math display="inline" id="Reed–Solomon_error_correction:167">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>α</mi>
      <mi>i</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}=p(\alpha^{i})
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Reed–Solomon_error_correction:168">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>α</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <ci>q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle v_{i}=\frac{1}{n}q(\alpha^{n-i})
  </annotation>
 </semantics>
</math>

 and 

<math display="block" id="Reed–Solomon_error_correction:169">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>f</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f_{0},\ldots,f_{n-1})
  </annotation>
 </semantics>
</math>

.</p>

<p>Using these facts, we have

<math display="inline" id="Reed–Solomon_error_correction:170">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>


 is a code word of the Reed–Solomon code according to the first definition</p>
<ul>
<li>if and only if 

<math display="inline" id="Reed–Solomon_error_correction:171">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is of degree less than 

<math display="inline" id="Reed–Solomon_error_correction:172">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{0},\ldots,f_{n-1}
  </annotation>
 </semantics>
</math>

 (because 

<math display="inline" id="Reed–Solomon_error_correction:173">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

 are the values of 

<math display="inline" id="Reed–Solomon_error_correction:174">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}=0
  </annotation>
 </semantics>
</math>

),</li>
<li>if and only if 

<math display="inline" id="Reed–Solomon_error_correction:175">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <ci>k</ci>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=k,\ldots,n-1
  </annotation>
 </semantics>
</math>


 for 

<math display="inline" id="Reed–Solomon_error_correction:176">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>α</mi>
      <mi>i</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(\alpha^{i})=0
  </annotation>
 </semantics>
</math>

,</li>
<li>if and only if 

<math display="inline" id="Reed–Solomon_error_correction:177">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\ldots,n-k
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Reed–Solomon_error_correction:178">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>α</mi>
      <mi>i</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <msub>
     <mi>v</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(\alpha^{i})=nv_{n-i}
  </annotation>
 </semantics>
</math>

 (because 

<math display="inline" id="Reed–Solomon_error_correction:179">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>f</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f_{0},\ldots,f_{n-1})
  </annotation>
 </semantics>
</math>

),</li>
<li>if and only if 

<math display="inline" id="Reed–Solomon_error_correction:180">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k
  </annotation>
 </semantics>
</math>


 is a code word of the Reed–Solomon code according to the second definition.</li>
</ul>

<p>This shows that the two definitions are equivalent.</p>
<h3 id="remarks">Remarks</h3>

<p>Designers are not required to use the "natural" sizes of Reed–Solomon code blocks. A technique known as "shortening" can produce a smaller code of any desired size from a larger code. For example, the widely used (255,223) code can be converted to a (160,128) code by padding the unused portion of the source block with 95 binary zeroes and not transmitting them. At the decoder, the same portion of the block is loaded locally with binary zeroes. The Delsarte-Goethals-Seidel<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> theorem illustrates an example of an application of shortened Reed–Solomon codes. In parallel to shortening, a technique known as <a class="uri" href="puncturing" title="wikilink">puncturing</a> allows omitting some of the encoded parity symbols.</p>
<h2 id="properties">Properties</h2>

<p>The Reed–Solomon code is a [<em>n</em>, <em>k</em>, <em>n</em> − <em>k</em> + 1] code; in other words, it is a <a href="linear_code" title="wikilink">linear block code</a> of length <em>n</em> (over <em>F</em>) with <a href="Dimension_(vector_space)" title="wikilink">dimension</a> <em>k</em> and minimum <a href="Hamming_distance" title="wikilink">Hamming distance</a> <em>n</em> − <em>k</em> + 1. The Reed–Solomon code is optimal in the sense that the minimum distance has the maximum value possible for a linear code of size (<em>n</em>, <em>k</em>); this is known as the <a href="Singleton_bound" title="wikilink">Singleton bound</a>. Such a code is also called a <a href="MDS_code" title="wikilink">maximum distance separable (MDS) code</a>.</p>

<p>The error-correcting ability of a Reed–Solomon code is determined by its minimum distance, or equivalently, by 

<math display="inline" id="Reed–Solomon_error_correction:181">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-k)/2
  </annotation>
 </semantics>
</math>

, the measure of redundancy in the block. If the locations of the error symbols are not known in advance, then a Reed–Solomon code can correct up to 

<math display="inline" id="Reed–Solomon_error_correction:182">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 erroneous symbols, i.e., it can correct half as many errors as there are redundant symbols added to the block. Sometimes error locations are known in advance (e.g., "side information" in <a class="uri" href="demodulator" title="wikilink">demodulator</a> <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratios</a>)—these are called <a href="Erasure_channel_(disambiguation)" title="wikilink">erasures</a>. A Reed–Solomon code (like any <a href="Maximum_distance_separable_code" title="wikilink">MDS code</a>) is able to correct twice as many erasures as errors, and any combination of errors and erasures can be corrected as long as the relation 2<em>E</em> + <em>S</em> ≤ <em>n</em> − <em>k</em> is satisfied, where 

<math display="inline" id="Reed–Solomon_error_correction:183">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is the number of errors and 

<math display="inline" id="Reed–Solomon_error_correction:184">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is the number of erasures in the block.</p>

<p>For practical uses of Reed–Solomon codes, it is common to use a finite field 

<math display="inline" id="Reed–Solomon_error_correction:185">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m}
  </annotation>
 </semantics>
</math>


 with 

<math display="inline" id="Reed–Solomon_error_correction:186">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 elements. In this case, each symbol can be represented as an 

<math display="inline" id="Reed–Solomon_error_correction:187">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>m</mi>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>m</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=2^{m}-1
  </annotation>
 </semantics>
</math>

-bit value. The sender sends the data points as encoded blocks, and the number of symbols in the encoded block is 

<math display="inline" id="Reed–Solomon_error_correction:188">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mn>8</mn>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>255</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">8</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">255</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=2^{8}-1=255
  </annotation>
 </semantics>
</math>

. Thus a Reed–Solomon code operating on 8-bit symbols has 

<math display="inline" id="Reed–Solomon_error_correction:189">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 symbols per block. (This is a very popular value because of the prevalence of <a class="uri" href="byte-oriented" title="wikilink">byte-oriented</a> computer systems.) The number 

<math display="inline" id="Reed–Solomon_error_correction:190">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo><</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>k</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k<n
  </annotation>
 </semantics>
</math>


, with 

<math display="inline" id="Reed–Solomon_error_correction:191">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>223</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">223</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=223
  </annotation>
 </semantics>
</math>

, of <em>data</em> symbols in the block is a design parameter. A commonly used code encodes 

<math display="inline" id="Reed–Solomon_error_correction:192">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>255</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">255</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=255
  </annotation>
 </semantics>
</math>

 eight-bit data symbols plus 32 eight-bit parity symbols in an 

<math display="inline" id="Reed–Solomon_error_correction:193">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>255</mn>
    <mo>,</mo>
    <mn>223</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>n</ci>
     <ci>k</ci>
    </interval>
    <interval closure="open">
     <cn type="integer">255</cn>
     <cn type="integer">223</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,k)=(255,223)
  </annotation>
 </semantics>
</math>

-symbol block; this is denoted as a 

<math display="inline" id="Reed–Solomon_error_correction:194">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>n</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,k)
  </annotation>
 </semantics>
</math>

 code, and is capable of correcting up to 16 symbol errors per block.</p>

<p>The Reed–Solomon code properties discussed above make them especially well-suited to applications where errors occur in <a href="burst_error" title="wikilink">bursts</a>. This is because it does not matter to the code how many bits in a symbol are in error — if multiple bits in a symbol are corrupted it only counts as a single error. Conversely, if a data stream is not characterized by error bursts or drop-outs but by random single bit errors, a Reed–Solomon code is usually a poor choice compared to a binary code.</p>

<p>The Reed–Solomon code, like the <a href="convolutional_code" title="wikilink">convolutional code</a>, is a transparent code. This means that if the channel symbols have been <a href="bitwise_NOT" title="wikilink">inverted</a> somewhere along the line, the decoders will still operate. The result will be the inversion of the original data. However, the Reed–Solomon code loses its transparency when the code is shortened. The "missing" bits in a shortened code need to be filled by either zeros or ones, depending on whether the data is complemented or not. (To put it another way, if the symbols are inverted, then the zero-fill needs to be inverted to a one-fill.) For this reason it is mandatory that the sense of the data (i.e., true or complemented) be resolved before Reed–Solomon decoding.</p>
<h2 id="error-correction-algorithms">Error correction algorithms</h2>
<h3 id="theoretical-decoder">Theoretical decoder</h3>

<p>described a theoretical decoder that corrected errors by finding the most popular message polynomial. The decoder for a RS 

<math display="inline" id="Reed–Solomon_error_correction:195">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 code would look at all possible subsets of 

<math display="inline" id="Reed–Solomon_error_correction:196">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 symbols from the set of 

<math display="inline" id="Reed–Solomon_error_correction:197">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 symbols that were received. For the code to be correctable in general, at least 

<math display="inline" id="Reed–Solomon_error_correction:198">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 symbols had to be received correctly, and 

<math display="inline" id="Reed–Solomon_error_correction:199">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle scriptlevel="+1">
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mi>n</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mi>k</mi>
       </mtd>
      </mtr>
     </mtable>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>n</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>k</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mrow>
      <mi>k</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <factorial></factorial>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <factorial></factorial>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <factorial></factorial>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle{\left({{n}\atop{k}}\right)}={n!\over(n-k)!k!}
  </annotation>
 </semantics>
</math>

 symbols are needed to interpolate the message polynomial. The decoder would interpolate a message polynomial for each subset, and it would keep track of the resulting polynomial candidates. The most popular message is the corrected result. Unfortunately, there are a lot of subsets, so the algorithm is impractical. The number of subsets is the <a href="binomial_coefficient" title="wikilink">binomial coefficient</a>, 

<math display="inline" id="Reed–Solomon_error_correction:200">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>255</mn>
   <mo>,</mo>
   <mn>249</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">255</cn>
    <cn type="integer">249</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (255,249)
  </annotation>
 </semantics>
</math>


, and the number of subsets is infeasible for even modest codes. For a 

<math display="block" id="Reed–Solomon_error_correction:201">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mi>x</mi>
      <mi>i</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)=\sum_{i=0}^{n-1}c_{i}x^{i}
  </annotation>
 </semantics>
</math>

 code that can correct 3 errors, the naive theoretical decoder would examine 359 billion subsets. The Reed–Solomon code needed a practical decoder.</p>
<h3 id="peterson-decoder">Peterson decoder</h3>

<p>developed a practical decoder based on syndrome decoding.  Berlekamp (below) would improve on that decoder.</p>
<h4 id="syndrome-decoding">Syndrome decoding</h4>

<p>The transmitted message is viewed as the coefficients of a polynomial <em>s</em>(<em>x</em>) that is divisible by a generator polynomial <em>g</em>(<em>x</em>). </p>

<p>

<math display="block" id="Reed–Solomon_error_correction:202">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>k</mi>
      </mrow>
     </munderover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msup>
        <mi>α</mi>
        <mi>j</mi>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=\prod_{j=1}^{n-k}(x-\alpha^{j}),
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:203">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>α</mi>
       <mi>i</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>k</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(\alpha^{i})=0,\ i=1,2,\ldots,n-k
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>α</em> is a primitive root.</p>

<p>Since <em>s</em>(<em>x</em>) is divisible by generator <em>g</em>(<em>x</em>), it follows that</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:204">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x)=s(x)+e(x)
  </annotation>
 </semantics>
</math>

</p>

<p>The transmitted polynomial is corrupted in transit by an error polynomial <em>e</em>(<em>x</em>) to produce the received polynomial <em>r</em>(<em>x</em>).</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:205">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <msub>
      <mi>e</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mi>x</mi>
      <mi>i</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(x)=\sum_{i=0}^{n-1}e_{i}x^{i}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:206">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>ν</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>e</mi>
      <msub>
       <mi>i</mi>
       <mi>k</mi>
      </msub>
     </msub>
     <msup>
      <mi>x</mi>
      <msub>
       <mi>i</mi>
       <mi>k</mi>
      </msub>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>ν</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(x)=\sum_{k=1}^{\nu}e_{i_{k}}x^{i_{k}}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>e<sub>i</sub></em> is the coefficient for the <em>i</em>-th power of <em>x</em>. Coefficient <em>e<sub>i</sub></em> will be zero if there is no error at that power of <em>x</em> and nonzero if there is an error. If there are <em>ν</em> errors at distinct powers <em>i<sub>k</sub></em> of <em>x</em>, then</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:207">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle S_{j}
  </annotation>
 </semantics>
</math>


</p>

<p>The goal of the decoder is to find the number of errors (<em>ν</em>), the positions of the errors (<em>i<sub>k</sub></em>), and the error values at those positions (<em>e<sub>i<sub>k</sub></sub></em>). From those, e(x) can be calculated and subtracted from r(x) to get the original message s(x).</p>

<p>The syndromes <em>S</em><sub><em>j</em></sub> are defined as</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:208">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>α</mi>
    <mi>j</mi>
   </msup>
   <mo>,</mo>
   <msub>
    <mi>S</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>j</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha^{j},S_{j})
  </annotation>
 </semantics>
</math>

</p>

<p>The advantage of looking at the syndromes is that the message polynomial drops out. Another possible way of calculating e(x) is using <a href="polynomial_interpolation" title="wikilink">polynomial interpolation</a> to find the only polynomial that passes through the points 

<math display="inline" id="Reed–Solomon_error_correction:209">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>α</mi>
      <mi>j</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{j}=e(\alpha^{j})
  </annotation>
 </semantics>
</math>

 (Because 

<math display="block" id="Reed–Solomon_error_correction:210">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <msup>
     <mi>α</mi>
     <msub>
      <mi>i</mi>
      <mi>k</mi>
     </msub>
    </msup>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <msub>
     <mi>Y</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>e</mi>
     <msub>
      <mi>i</mi>
      <mi>k</mi>
     </msub>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k}=\alpha^{i_{k}},\ Y_{k}=e_{i_{k}}
  </annotation>
 </semantics>
</math>

), however, this is not used widely because polynomial interpolation is not always feasible in the fields used in Reed–Solomon error correction. For example, it is feasible over the integers (of course), but it is infeasible over the integers modulo a prime.</p>
<h4 id="error-locators-and-error-values">Error locators and error values</h4>

<p>For convenience, define the <strong>error locators</strong> <em>X<sub>k</sub></em> and <strong>error values</strong> <em>Y<sub>k</sub></em> as:</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:211">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>ν</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>Y</mi>
      <mi>k</mi>
     </msub>
     <msubsup>
      <mi>X</mi>
      <mi>k</mi>
      <mi>j</mi>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>ν</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>k</ci>
       </apply>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{j}=\sum_{k=1}^{\nu}Y_{k}X_{k}^{j}
  </annotation>
 </semantics>
</math>

</p>

<p>Then the syndromes can be written in terms of the error locators and error values as</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:212">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msubsup>
         <mi>X</mi>
         <mn>1</mn>
         <mn>1</mn>
        </msubsup>
       </mtd>
       <mtd columnalign="center">
        <msubsup>
         <mi>X</mi>
         <mn>2</mn>
         <mn>1</mn>
        </msubsup>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋯</mi>
       </mtd>
       <mtd columnalign="center">
        <msubsup>
         <mi>X</mi>
         <mi>ν</mi>
         <mn>1</mn>
        </msubsup>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msubsup>
         <mi>X</mi>
         <mn>1</mn>
         <mn>2</mn>
        </msubsup>
       </mtd>
       <mtd columnalign="center">
        <msubsup>
         <mi>X</mi>
         <mn>2</mn>
         <mn>2</mn>
        </msubsup>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋯</mi>
       </mtd>
       <mtd columnalign="center">
        <msubsup>
         <mi>X</mi>
         <mi>ν</mi>
         <mn>2</mn>
        </msubsup>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msubsup>
         <mi>X</mi>
         <mn>1</mn>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mi>k</mi>
         </mrow>
        </msubsup>
       </mtd>
       <mtd columnalign="center">
        <msubsup>
         <mi>X</mi>
         <mn>2</mn>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mi>k</mi>
         </mrow>
        </msubsup>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋯</mi>
       </mtd>
       <mtd columnalign="center">
        <msubsup>
         <mi>X</mi>
         <mi>ν</mi>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mi>k</mi>
         </mrow>
        </msubsup>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>Y</mi>
         <mn>1</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>Y</mi>
         <mn>2</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>Y</mi>
         <mi>ν</mi>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>S</mi>
        <mn>1</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>S</mi>
        <mn>2</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>S</mi>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mi>k</mi>
        </mrow>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>ν</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>ν</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
       <ci>normal-⋮</ci>
       <csymbol cd="latexml">absent</csymbol>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>ν</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>ν</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}X_{1}^{1}&X_{2}^{1}&\cdots&X_{\nu}^{1}\\
X_{1}^{2}&X_{2}^{2}&\cdots&X_{\nu}^{2}\\
\vdots&\vdots&&\vdots\\
X_{1}^{n-k}&X_{2}^{n-k}&\cdots&X_{\nu}^{n-k}\\
\end{bmatrix}\begin{bmatrix}Y_{1}\\
Y_{2}\\
\vdots\\
Y_{\nu}\end{bmatrix}=\begin{bmatrix}S_{1}\\
S_{2}\\
\vdots\\
S_{n-k}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The syndromes give a system of <em>n</em> − <em>k</em> ≥ 2<em>ν</em> equations in 2<em>ν</em> unknowns, but that system of equations is nonlinear in the <em>X<sub>k</sub></em> and does not have an obvious solution. However, if the <em>X<sub>k</sub></em> were known (see below), then the syndrome equations provide a linear system of equations that can easily be solved for the <em>Y<sub>k</sub></em> error values.</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:213">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>ν</mi>
    </munderover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mi>x</mi>
       <msub>
        <mi>X</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mn>1</mn>
     </msub>
     <msup>
      <mi>x</mi>
      <mn>1</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mn>2</mn>
     </msub>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mi>ν</mi>
     </msub>
     <msup>
      <mi>x</mi>
      <mi>ν</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Λ</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>ν</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <ci>ν</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>ν</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(x)=\prod_{k=1}^{\nu}(1-xX_{k})=1+\Lambda_{1}x^{1}+\Lambda_{2}x^{2}+%
\cdots+\Lambda_{\nu}x^{\nu}
  </annotation>
 </semantics>
</math>

</p>

<p>Consequently, the problem is finding the <em>X<sub>k</sub></em>, because then the leftmost matrix would be known, and both sides of the equation could be multiplied by its inverse, yielding Y<em><sub>k</sub></em></p>
<h4 id="error-locator-polynomial">Error locator polynomial</h4>

<p>Peterson found a linear recurrence relation that gave rise to a system of linear equations.  Solving those equations identifies the error locations.</p>

<p>Define the <strong>error locator polynomial</strong> Λ(<em>x</em>) as</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:214">
 <semantics>
  <msubsup>
   <mi>X</mi>
   <mi>k</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k}^{-1}
  </annotation>
 </semantics>
</math>

</p>

<p>The zeros of Λ(<em>x</em>) are the reciprocals 

<math display="block" id="Reed–Solomon_error_correction:215">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>X</mi>
      <mi>k</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(X_{k}^{-1})=0
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:216">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>X</mi>
      <mi>k</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mn>1</mn>
     </msub>
     <msubsup>
      <mi>X</mi>
      <mi>k</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mn>2</mn>
     </msub>
     <msubsup>
      <mi>X</mi>
      <mi>k</mi>
      <mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msubsup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mi>ν</mi>
     </msub>
     <msubsup>
      <mi>X</mi>
      <mi>k</mi>
      <mrow>
       <mo>-</mo>
       <mi>ν</mi>
      </mrow>
     </msubsup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Λ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <ci>ν</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>ν</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(X_{k}^{-1})=1+\Lambda_{1}X_{k}^{-1}+\Lambda_{2}X_{k}^{-2}+\cdots+%
\Lambda_{\nu}X_{k}^{-\nu}=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:217">
 <semantics>
  <mrow>
   <msub>
    <mi>Y</mi>
    <mi>k</mi>
   </msub>
   <msubsup>
    <mi>X</mi>
    <mi>k</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mi>ν</mi>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <ci>ν</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{k}X_{k}^{j+\nu}
  </annotation>
 </semantics>
</math>


</p>

<p>Multiply both sides by 

<math display="inline" id="Reed–Solomon_error_correction:218">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Y</mi>
     <mi>k</mi>
    </msub>
    <msubsup>
     <mi>X</mi>
     <mi>k</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mi>ν</mi>
     </mrow>
    </msubsup>
    <mi mathvariant="normal">Λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>X</mi>
      <mi>k</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <ci>ν</ci>
      </apply>
     </apply>
     <ci>normal-Λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle Y_{k}X_{k}^{j+\nu}\Lambda(X_{k}^{-1})=0.
  </annotation>
 </semantics>
</math>


 and it will still be zero. j is any number such that 1≤j≤v.</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:219">
 <semantics>
  <mrow>
   <mrow>
    <mstyle displaystyle="true">
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>ν</mi>
     </munderover>
    </mstyle>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>Y</mi>
        <mi>k</mi>
       </msub>
       <msubsup>
        <mi>X</mi>
        <mi>k</mi>
        <mrow>
         <mi>j</mi>
         <mo>+</mo>
         <mi>ν</mi>
        </mrow>
       </msubsup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi mathvariant="normal">Λ</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>Y</mi>
        <mi>k</mi>
       </msub>
       <msubsup>
        <mi>X</mi>
        <mi>k</mi>
        <mrow>
         <mrow>
          <mi>j</mi>
          <mo>+</mo>
          <mi>ν</mi>
         </mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi mathvariant="normal">Λ</mi>
        <mn>2</mn>
       </msub>
       <msub>
        <mi>Y</mi>
        <mi>k</mi>
       </msub>
       <msubsup>
        <mi>X</mi>
        <mi>k</mi>
        <mrow>
         <mrow>
          <mi>j</mi>
          <mo>+</mo>
          <mi>ν</mi>
         </mrow>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </msubsup>
      </mrow>
      <mo>+</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi mathvariant="normal">Λ</mi>
        <mi>ν</mi>
       </msub>
       <msub>
        <mi>Y</mi>
        <mi>k</mi>
       </msub>
       <msubsup>
        <mi>X</mi>
        <mi>k</mi>
        <mi>j</mi>
       </msubsup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>ν</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <ci>ν</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <plus></plus>
          <ci>j</ci>
          <ci>ν</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <plus></plus>
          <ci>j</ci>
          <ci>ν</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <ci>ν</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>k</ci>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\sum_{k=1}^{\nu}(Y_{k}X_{k}^{j+\nu}+\Lambda_{1}Y_{k}X_{k}^{j+\nu-%
1}+\Lambda_{2}Y_{k}X_{k}^{j+\nu-2}+\cdots+\Lambda_{\nu}Y_{k}X_{k}^{j})=0
  </annotation>
 </semantics>
</math>


</p>

<p>Sum for <em>k</em> = 1 to <em>ν</em></p>

<p>

<math display="block" id="Reed–Solomon_error_correction:220">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mi>ν</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>S</mi>
      <mrow>
       <mrow>
        <mi>j</mi>
        <mo>+</mo>
        <mi>ν</mi>
       </mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mi>ν</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>j</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mi>ν</mi>
     </msub>
     <msub>
      <mi>S</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <ci>ν</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Λ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <ci>ν</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Λ</ci>
       <apply>
        <minus></minus>
        <ci>ν</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Λ</ci>
       <ci>ν</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{j+\nu}+\Lambda_{1}S_{j+\nu-1}+\cdots+\Lambda_{\nu-1}S_{j+1}+\Lambda_{\nu}S_%
{j}=0\,
  </annotation>
 </semantics>
</math>

</p>

<p>This reduces to</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:221">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>S</mi>
      <mi>j</mi>
     </msub>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mi>ν</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>j</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mi>ν</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>S</mi>
      <mrow>
       <mrow>
        <mi>j</mi>
        <mo>+</mo>
        <mi>ν</mi>
       </mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi mathvariant="normal">Λ</mi>
      <mn>1</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mi>ν</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Λ</ci>
       <ci>ν</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Λ</ci>
       <apply>
        <minus></minus>
        <ci>ν</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <ci>ν</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Λ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <ci>ν</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{j}\Lambda_{\nu}+S_{j+1}\Lambda_{\nu-1}+\cdots+S_{j+\nu-1}\Lambda_{1}=-S_{j+\nu}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:222">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>S</mi>
         <mn>1</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>S</mi>
         <mn>2</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋯</mi>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>S</mi>
         <mi>ν</mi>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>S</mi>
         <mn>2</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>S</mi>
         <mn>3</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋯</mi>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>S</mi>
         <mrow>
          <mi>ν</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>S</mi>
         <mi>ν</mi>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>S</mi>
         <mrow>
          <mi>ν</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋯</mi>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>S</mi>
         <mrow>
          <mrow>
           <mn>2</mn>
           <mi>ν</mi>
          </mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi mathvariant="normal">Λ</mi>
         <mi>ν</mi>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi mathvariant="normal">Λ</mi>
         <mrow>
          <mi>ν</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi mathvariant="normal">Λ</mi>
         <mn>1</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <msub>
         <mi>S</mi>
         <mrow>
          <mi>ν</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <msub>
         <mi>S</mi>
         <mrow>
          <mi>ν</mi>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
        </msub>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <msub>
         <mi>S</mi>
         <mrow>
          <mi>ν</mi>
          <mo>+</mo>
          <mi>ν</mi>
         </mrow>
        </msub>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>ν</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">3</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <apply>
         <plus></plus>
         <ci>ν</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
       <ci>normal-⋮</ci>
       <csymbol cd="latexml">absent</csymbol>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>ν</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <apply>
         <plus></plus>
         <ci>ν</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>ν</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <ci>ν</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <apply>
         <minus></minus>
         <ci>ν</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Λ</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <apply>
         <plus></plus>
         <ci>ν</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <apply>
         <plus></plus>
         <ci>ν</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <apply>
         <plus></plus>
         <ci>ν</ci>
         <ci>ν</ci>
        </apply>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}S_{1}&S_{2}&\cdots&S_{\nu}\\
S_{2}&S_{3}&\cdots&S_{\nu+1}\\
\vdots&\vdots&&\vdots\\
S_{\nu}&S_{\nu+1}&\cdots&S_{2\nu-1}\end{bmatrix}\begin{bmatrix}\Lambda_{\nu}\\
\Lambda_{\nu-1}\\
\vdots\\
\Lambda_{1}\end{bmatrix}=\begin{bmatrix}-S_{\nu+1}\\
-S_{\nu+2}\\
\vdots\\
-S_{\nu+\nu}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>This yields a system of linear equations that can be solved for the coefficients Λ<sub><em>i</em></sub> of the error location polynomial:</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:223">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mpadded width="+5pt">
      <msub>
       <mi mathvariant="normal">Λ</mi>
       <mn>1</mn>
      </msub>
     </mpadded>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <mpadded width="+5pt">
      <msub>
       <mi mathvariant="normal">Λ</mi>
       <mi>e</mi>
      </msub>
     </mpadded>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mi>e</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Δ</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Λ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Λ</ci>
       <ci>e</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <ci>e</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta=S_{i}+\Lambda_{1}\ S_{i-1}+\cdots+\Lambda_{e}\ S_{i-e}
  </annotation>
 </semantics>
</math>

 The above assumes the decoder knows the number of errors <em>ν</em>, but that number has not been determined yet. The PGZ decoder does not determine <em>ν</em> directly but rather searches for it by trying successive values. The decoder first assumes the largest value for a trial <em>ν</em> and sets up the linear system for that value. If the equations can be solved (i.e., the matrix determinant is nonzero), then that trial value is the number of errors. If the linear system cannot be solved, then the trial <em>ν</em> is reduced by one and the next smaller system is examined. </p>
<h4 id="obtain-the-error-locators-from-the-error-locator-polynomial">Obtain the error locators from the error locator polynomial</h4>

<p>Use the coefficients Λ<sub><em>i</em></sub> found in the last step to build the error location polynomial. The roots of the error location polynomial can be found by exhaustive search. The error locators are the reciprocals of those roots. <a href="Chien_search" title="wikilink">Chien search</a> is an efficient implementation of this step.</p>
<h4 id="calculate-the-error-locations">Calculate the error locations</h4>

<p>Calculate i<sub>k</sub> by taking the log base a of <em>X<sub>k</sub></em>. This is generally done using a precomputed lookup table.</p>
<h4 id="calculate-the-error-values">Calculate the error values</h4>

<p>Once the error locators are known, the error values can be determined. This can be done by direct solution for <em>Y<sub>k</sub></em> in the <a href="#Error_locators_and_error_values" title="wikilink">error equations</a> given above, or using the <a href="Forney_algorithm" title="wikilink">Forney algorithm</a>.</p>
<h4 id="fix-the-errors">Fix the errors</h4>

<p>Finally, e(x) is generated from i<sub>k</sub> and e<sub>i<sub>k</sub></sub> and then is subtracted from r(x) to get the sent message s(x).</p>
<h3 id="berlekampmassey-decoder">Berlekamp–Massey decoder</h3>

<p>The <a href="Berlekamp–Massey_algorithm" title="wikilink">Berlekamp–Massey algorithm</a> is an alternate iterative procedure for finding the error locator polynomial. During each iteration, it calculates a discrepancy based on a current instance of Λ(x) with an assumed number of errors <em>e</em>:</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:224">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>929</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>F</ci>
    <cn type="integer">929</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GF(929)
  </annotation>
 </semantics>
</math>

</p>

<p>and then adjusts Λ(x) and <em>e</em> so that a recalculated Δ would be zero. The article <a href="Berlekamp–Massey_algorithm" title="wikilink">Berlekamp–Massey algorithm</a> has a detailed description of the procedure. In the following example, C(x) is used to represent Λ(x).</p>
<h4 id="example">Example</h4>

<p>Consider the Reed–Solomon code defined in 

<math display="inline" id="Reed–Solomon_error_correction:225">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   α=3
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Reed–Solomon_error_correction:226">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=4
  </annotation>
 </semantics>
</math>

 and 

<math display="block" id="Reed–Solomon_error_correction:227">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mn>3</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <msup>
       <mn>3</mn>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <msup>
       <mn>3</mn>
       <mn>3</mn>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <msup>
       <mn>3</mn>
       <mn>4</mn>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>4</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mn>809</mn>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>723</mn>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>568</mn>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mn>522</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">3</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">3</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">3</cn>
        <cn type="integer">4</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">809</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">723</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">568</cn>
       <ci>x</ci>
      </apply>
      <cn type="integer">522</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=(x-3)(x-3^{2})(x-3^{3})(x-3^{4})=x^{4}+809x^{3}+723x^{2}+568x+522
  </annotation>
 </semantics>
</math>

 (this is used in <a class="uri" href="PDF417" title="wikilink">PDF417</a> barcodes). The generator polynomial is</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:228">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>r</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>x</mi>
      <mi>t</mi>
     </msup>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>547</mn>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>738</mn>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>442</mn>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mn>455</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>r</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">547</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">738</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">442</cn>
       <ci>x</ci>
      </apply>
      <cn type="integer">455</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{r}(x)=p(x)\,x^{t}\mod g(x)=547x^{3}+738x^{2}+442x+455
  </annotation>
 </semantics>
</math>

 If the message polynomial is <mtpl> 3 <em>x</em><sup>2</sup> + 2 <em>x</em> + 1}}</mtpl>, then the codeword is calculated as follows.</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:229">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>x</mi>
      <mi>t</mi>
     </msup>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mi>r</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>3</mn>
     <msup>
      <mi>x</mi>
      <mn>6</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <msup>
      <mi>x</mi>
      <mn>5</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>1</mn>
     <msup>
      <mi>x</mi>
      <mn>4</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>382</mn>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>191</mn>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>487</mn>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mn>474</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>r</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">6</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">5</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">4</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">382</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">191</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">487</cn>
       <ci>x</ci>
      </apply>
      <cn type="integer">474</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)=p(x)\,x^{t}-s_{r}(x)=3x^{6}+2x^{5}+1x^{4}+382x^{3}+191x^{2}+487x+474
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:230">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>3</mn>
     <msup>
      <mi>x</mi>
      <mn>6</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <msup>
      <mi>x</mi>
      <mn>5</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>123</mn>
     <msup>
      <mi>x</mi>
      <mn>4</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>456</mn>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>191</mn>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>487</mn>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mn>474</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">6</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">5</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">123</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">4</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">456</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">191</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">487</cn>
       <ci>x</ci>
      </apply>
      <cn type="integer">474</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x)=s(x)+e(x)=3x^{6}+2x^{5}+123x^{4}+456x^{3}+191x^{2}+487x+474
  </annotation>
 </semantics>
</math>

 Errors in transmission might cause this to be received instead.</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:231">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>3</mn>
      <mn>1</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>3</mn>
     <mo>⋅</mo>
     <msup>
      <mn>3</mn>
      <mn>6</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <msup>
      <mn>3</mn>
      <mn>5</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>123</mn>
     <mo>⋅</mo>
     <msup>
      <mn>3</mn>
      <mn>4</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>456</mn>
     <mo>⋅</mo>
     <msup>
      <mn>3</mn>
      <mn>3</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>191</mn>
     <mo>⋅</mo>
     <msup>
      <mn>3</mn>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>487</mn>
     <mo>⋅</mo>
     <mn>3</mn>
    </mrow>
    <mo>+</mo>
    <mn>474</mn>
   </mrow>
   <mo>=</mo>
   <mn>732</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">3</cn>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">3</cn>
        <cn type="integer">6</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">3</cn>
        <cn type="integer">5</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">123</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">3</cn>
        <cn type="integer">4</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">456</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">3</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">191</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">3</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">487</cn>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">474</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">732</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}=r(3^{1})=3\cdot 3^{6}+2\cdot 3^{5}+123\cdot 3^{4}+456\cdot 3^{3}+191%
\cdot 3^{2}+487\cdot 3+474=732
  </annotation>
 </semantics>
</math>

 The syndromes are calculated by evaluating <em>r</em> at powers of <em>α</em>.</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:232">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>r</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mn>3</mn>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>637</mn>
   </mrow>
   <mo rspace="5.3pt">,</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>3</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>r</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mn>3</mn>
       <mn>3</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>762</mn>
   </mrow>
   <mo rspace="5.3pt">,</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>4</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>r</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mn>3</mn>
       <mn>4</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>925</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">3</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">637</cn>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">3</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">762</cn>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">3</cn>
        <cn type="integer">4</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">925</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}=r(3^{2})=637,\;S_{3}=r(3^{3})=762,\;S_{4}=r(3^{4})=925
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:233">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">Λ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <msup>
     <mi>x</mi>
     <mn>4</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>546</mn>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mn>732</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Ω</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>x</ci>
       <ci>normal-Λ</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">546</cn>
       <ci>x</ci>
      </apply>
      <cn type="integer">732</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(x)=S(x)\Lambda(x)\mod x^{4}=546x+732\,
  </annotation>
 </semantics>
</math>

 To correct the errors, first use the <a href="Berlekamp–Massey_algorithm#Berlekamp–Massey_algorithm_for_fields" title="wikilink">Berlekamp–Massey algorithm</a> to calculate the error locator polynomial.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><em>n</em></p></th>
<th style="text-align: left;">
<p><em>S</em><sub><em>n</em>+1</sub></p></th>
<th style="text-align: left;">
<p><em>d</em></p></th>
<th style="text-align: left;">
<p><em>C</em></p></th>
<th style="text-align: left;">
<p><em>B</em></p></th>
<th style="text-align: left;">
<p><em>b</em></p></th>
<th style="text-align: left;">
<p><em>m</em></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>732</p></td>
<td style="text-align: left;">
<p>732</p></td>
<td style="text-align: left;">
<p>197 <em>x</em> + 1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>732</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>637</p></td>
<td style="text-align: left;">
<p>846</p></td>
<td style="text-align: left;">
<p>173 <em>x</em> + 1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>732</p></td>
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>762</p></td>
<td style="text-align: left;">
<p>412</p></td>
<td style="text-align: left;">
<p>634 <em>x</em><sup>2</sup> + 173 <em>x</em> + 1</p></td>
<td style="text-align: left;">
<p>173 <em>x</em> + 1</p></td>
<td style="text-align: left;">
<p>412</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>925</p></td>
<td style="text-align: left;">
<p>576</p></td>
<td style="text-align: left;">
<p>329 <em>x</em><sup>2</sup> + 821 <em>x</em> + 1</p></td>
<td style="text-align: left;">
<p>173 <em>x</em> + 1</p></td>
<td style="text-align: left;">
<p>412</p></td>
<td style="text-align: left;">
<p>2</p></td>
</tr>
</tbody>
</table>

<p>The final value of <em>C</em> is the error locator polynomial, Λ(<em>x</em>). The zeros can be found by trial substitution. They are <em>x</em><sub>1</sub> = 757 = 3<sup>−3</sup> and <em>x</em><sub>2</sub> = 562 = 3<sup>−4</sup>, corresponding to the error locations. To calculate the error values, apply the <a href="Forney_algorithm" title="wikilink">Forney algorithm</a>.</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:234">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi mathvariant="normal">Λ</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>658</mn>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mn>821</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Λ</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">658</cn>
      <ci>x</ci>
     </apply>
     <cn type="integer">821</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda^{\prime}(x)=658x+821\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:235">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Ω</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <msup>
       <mi mathvariant="normal">Λ</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mn>649</mn>
     <mo>/</mo>
     <mn>54</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>280</mn>
    <mo>×</mo>
    <mn>843</mn>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>74</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>normal-Ω</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Λ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">649</cn>
       <cn type="integer">54</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">280</cn>
      <cn type="integer">843</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">74</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}=-\Omega(x_{1})/\Lambda^{\prime}(x_{1})=-649/54=280\times 843=74\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Reed–Solomon_error_correction:236">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Ω</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <msup>
       <mi mathvariant="normal">Λ</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>122</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>normal-Ω</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Λ</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">122</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{2}=-\Omega(x_{2})/\Lambda^{\prime}(x_{2})=122\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Reed–Solomon_error_correction:237">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 Subtracting <em>e</em><sub>1</sub><em>x</em><sup>3</sup> and <em>e</em><sub>2</sub><em>x</em><sup>4</sup> from the received polynomial <em>r</em> reproduces the original codeword <em>s</em>.</p>
<h3 id="euclidean-decoder">Euclidean decoder</h3>

<p>Another iterative method for calculating the error locator polynomial is based on the <a href="Euclidean_algorithm" title="wikilink">Euclidean algorithm</a></p>
<dl>
<dd><em>t</em> = number of parities
</dd>
<dd><em>R</em><sub>0</sub> = <em>x<sup>t</sup></em>
</dd>
<dd><em>S</em><sub>0</sub> = syndrome polynomial
</dd>
<dd><em>A</em><sub>0</sub> = 1
</dd>
<dd><em>B</em><sub>0</sub> = 0
</dd>
<dd><em>i</em> = 0
</dd>
<dd>while degree of <em>S<sub>i</sub></em> ≥ (<em>t</em>/2)
<dl>
<dd><em>Q</em> = <em>R<sub>i</sub></em> / <em>S<sub>i</sub></em>
</dd>
<dd><em>S</em><sub><em>i</em>+1</sub> = <em>R<sub>i</sub></em> – Q <em>S<sub>i</sub></em> = <em>R<sub>i</sub></em> modulo <em>S<sub>i</sub></em>
</dd>
<dd><em>A</em><sub><em>i</em>+1</sub> = Q <em>A<sub>i</sub></em> + <em>B<sub>i</sub></em>
</dd>
<dd><em>R</em><sub><em>i</em>+1</sub> = <em>S<sub>i</sub></em>
</dd>
<dd><em>B</em><sub><em>i</em>+1</sub> = <em>A<sub>i</sub></em>
</dd>
<dd><em>i</em> = <em>i</em> + 1
</dd>
</dl>
</dd>
<dd>Λ(<em>x</em>) = <em>A<sub>i</sub></em> / <em>A<sub>i</sub></em>(0)
</dd>
<dd>Ω(<em>x</em>) = (–1)<sup>deg <em>A<sub>i</sub></em></sup> <em>S<sub>i</sub></em> / <em>A<sub>i</sub></em>(0)
</dd>
</dl>

<p><em>A<sub>i</sub></em>(0) is the constant (least significant) term of <em>A<sub>i</sub></em>.</p>

<p>Here is an example of the Euclidean method, using the same data as the Berlekamp Massey example above. In the table below, R and S are forward, A and B are reversed.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><em>i</em></p></th>
<th style="text-align: left;">
<p>R<sub><em>i</em></sub></p></th>
<th style="text-align: left;">
<p>A<sub><em>i</em></sub></p></th>
<th style="text-align: left;">
<p>S<sub><em>i</em></sub></p></th>
<th style="text-align: left;">
<p>B<sub><em>i</em></sub></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>001 <em>x</em><sup>4</sup> + 000 <em>x</em><sup>3</sup> + 000 <em>x</em><sup>2</sup> + 000 <em>x</em> + 000</p></td>
<td style="text-align: left;">
<p>001</p></td>
<td style="text-align: left;">
<p>925 <em>x</em><sup>3</sup> + 762 <em>x</em><sup>2</sup> + 637 <em>x</em> + 732</p></td>
<td style="text-align: left;">
<p>000</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>925 <em>x</em><sup>3</sup> + 762 <em>x</em><sup>2</sup> + 637 <em>x</em> + 732</p></td>
<td style="text-align: left;">
<p>533 + 232 <em>x</em></p></td>
<td style="text-align: left;">
<p>683<em>x</em><sup>2</sup> + 676 <em>x</em> + 024</p></td>
<td style="text-align: left;">
<p>001</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>683 <em>x</em><sup>2</sup> + 676 <em>x</em> + 024</p></td>
<td style="text-align: left;">
<p>544 + 704 <em>x</em> + 608 <em>x</em><sup>2</sup></p></td>
<td style="text-align: left;">
<p>673 <em>x</em> + 596</p></td>
<td style="text-align: left;">
<p>533 + 232 <em>x</em></p></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>
<dl>
<dd>Λ(<em>x</em>) = <em>A</em><sub>2</sub> / 544 = 001 + 821 x + 329 x<sup>2</sup>
</dd>
<dd>Ω(<em>x</em>) = (–1)<sup>2</sup> <em>S</em><sub>2</sub> / 544 = 546 x + 732
</dd>
</dl>
<h3 id="decoding-in-frequency-domain-sketch">Decoding in frequency domain (sketch)</h3>

<p>The above algorithms are presented in the <a href="time_domain" title="wikilink">time domain</a>. Decoding in the <a href="frequency_domain" title="wikilink">frequency domain</a>, using <a href="Fourier_transform" title="wikilink">Fourier transform</a> techniques, can offer computational and implementation advantages. </p>

<p>The following is a sketch of the main idea behind this error correction technique.</p>

<p>By definition, a code word of a Reed–Solomon code is given by the sequence of values of a low-degree polynomial over a <a href="finite_field" title="wikilink">finite field</a>. A key fact for the error correction algorithm is that the <em>values</em> and the <em>coefficients</em> of a polynomial are related by the <a href="discrete_Fourier_transform_(general)" title="wikilink">discrete Fourier transform</a>.</p>

<p>The purpose of a Fourier transform is to convert a signal from a time domain to a frequency domain or vice versa. In case of the <a href="discrete_Fourier_transform_(general)" title="wikilink">Fourier transform over a finite field</a>, the frequency domain signal corresponds to the coefficients of a polynomial, and the time domain signal correspond to the values of the same polynomial.</p>

<p>As shown in Figures 1 and 2, an isolated value in the frequency domain corresponds to a smooth wave in the time domain. The wavelength depends on the location of the isolated value.</p>

<p>Conversely, as shown in Figures 3 and 4, an isolated value in the time domain corresponds to a smooth wave in the frequency domain.</p>

<p>In a Reed–Solomon code, the frequency domain is divided into two regions as shown in Figure 5: a left (low-frequency) region of length 

<math display="inline" id="Reed–Solomon_error_correction:238">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k
  </annotation>
 </semantics>
</math>

, and a right (high-frequency) region of length 

<math display="inline" id="Reed–Solomon_error_correction:239">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. A data word is then embedded into the left region (corresponding to the 

<math display="inline" id="Reed–Solomon_error_correction:240">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k-1
  </annotation>
 </semantics>
</math>

 coefficients of a polynomial of degree at most 

<math display="inline" id="Reed–Solomon_error_correction:241">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k
  </annotation>
 </semantics>
</math>

), while the right region is filled with zeros. The result is Fourier transformed into the time domain, yielding a code word that is composed only of low frequencies. In the absence of errors, a code word can be decoded by reverse Fourier transforming it back into the frequency domain.</p>

<p>Now consider a code word containing a single error, as shown in red in Figure 6. The effect of this error in the frequency domain is a smooth, single-frequency wave in the right region, called the <em>syndrome</em> of the error. The error location can be determined by determining the frequency of the syndrome signal.</p>

<p>Similarly, if two or more errors are introduced in the code word, the syndrome will be a signal composed of two or more frequencies, as shown in Figure 7. As long as it is possible to determine the frequencies of which the syndrome is composed, it is possible to determine the error locations. Notice that the error <em>locations</em> depend only on the <em>frequencies</em> of these waves, whereas the error <em>magnitudes</em> depend on their amplitudes and phase.</p>

<p>The problem of determining the error locations has therefore been reduced to the problem of finding, given a sequence of 

<math display="inline" id="Reed–Solomon_error_correction:242">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mn>2</mn>
     <mi>m</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GF(2^{m})
  </annotation>
 </semantics>
</math>

 values, the smallest set of elementary waves into which these values can be decomposed. It is known from <a href="digital_signal_processing" title="wikilink">digital signal processing</a> that this problem is equivalent to finding the roots of the <a href="recurrence_relation" title="wikilink">minimal polynomial</a> of the sequence, or equivalently, of finding the shortest <a href="linear_feedback_shift_register" title="wikilink">linear feedback shift register</a> (LFSR) for the sequence. The latter problem can either be solved inefficiently by solving a system of linear equations, or more efficiently by the <a href="Berlekamp–Massey_algorithm" title="wikilink">Berlekamp–Massey algorithm</a>.</p>
<h3 id="decoding-beyond-the-error-correction-bound">Decoding beyond the error-correction bound</h3>

<p>The <a href="Singleton_bound" title="wikilink">Singleton bound</a> states that the minimum distance <em>d</em> of a linear block code of size (<em>n</em>,<em>k</em>) is upper-bounded by <em>n</em> − <em>k</em> + 1. The distance <em>d</em> was usually understood to limit the error-correction capability to ⌊<em>d</em>/2⌋. The Reed–Solomon code achieves this bound with equality, and can thus correct up to ⌊(<em>n</em> − <em>k</em> + 1)/2⌋ errors. However, this error-correction bound is not exact.</p>

<p>In 1999, <a href="Madhu_Sudan" title="wikilink">Madhu Sudan</a> and <a href="Venkatesan_Guruswami" title="wikilink">Venkatesan Guruswami</a> at MIT published "Improved Decoding of Reed–Solomon and Algebraic-Geometry Codes" introducing an algorithm that allowed for the correction of errors beyond half the minimum distance of the code.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> It applies to Reed–Solomon codes and more generally to <a href="algebraic_geometric_code" title="wikilink">algebraic geometric codes</a>. This algorithm produces a list of codewords (it is a <a class="uri" href="list-decoding" title="wikilink">list-decoding</a> algorithm) and is based on interpolation and factorization of polynomials over <span class="LaTeX">$GF(2^m)$</span> and its extensions.</p>
<h3 id="soft-decoding">Soft-decoding</h3>

<p>The algebraic decoding methods described above are hard-decision methods, which means that for every symbol a hard decision is made about its value. For example, a decoder could associate with each symbol an additional value corresponding to the channel <a class="uri" href="demodulator" title="wikilink">demodulator</a>'s confidence in the correctness of the symbol. The advent of <a href="low-density_parity-check_code" title="wikilink">LDPC</a> and <a href="turbo_code" title="wikilink">turbo codes</a>, which employ iterated <a href="soft-decision_decoding" title="wikilink">soft-decision</a> belief propagation decoding methods to achieve error-correction performance close to the <a href="Shannon_limit" title="wikilink">theoretical limit</a>, has spurred interest in applying soft-decision decoding to conventional algebraic codes. In 2003, Ralf Koetter and Alexander Vardy presented a polynomial-time soft-decision algebraic list-decoding algorithm for Reed–Solomon codes, which was based upon the work by Sudan and Guruswami.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="BCH_code" title="wikilink">BCH code</a></li>
<li><a href="Cyclic_code" title="wikilink">Cyclic code</a></li>
<li><a href="Chien_search" title="wikilink">Chien search</a></li>
<li><a href="Berlekamp–Massey_algorithm" title="wikilink">Berlekamp–Massey algorithm</a></li>
<li><a href="Forward_error_correction" title="wikilink">Forward error correction</a></li>
<li><a href="Berlekamp–Welch_algorithm" title="wikilink">Berlekamp–Welch algorithm</a></li>
<li><a href="Folded_Reed–Solomon_code" title="wikilink">Folded Reed–Solomon code</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<h3 id="information-and-tutorials">Information and Tutorials</h3>
<ul>
<li><a href="http://www.cs.cmu.edu/~guyb/realworld/reedsolomon/reed_solomon_codes.html">Introduction to Reed-Solomon codes: principles, architecture and implementation</a> (CMU)</li>
<li><a href="http://www.cs.utk.edu/%7Eplank/plank/papers/SPE-9-97.html">A Tutorial on Reed–Solomon Coding for Fault-Tolerance in RAID-like Systems</a></li>
<li><a href="http://sidewords.files.wordpress.com/2007/12/thesis.pdf">Algebraic soft-decoding of Reed–Solomon codes</a></li>
<li>Wikiversity: <a href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders">Reed–Solomon codes for coders</a></li>
<li><a href="http://www.bbc.co.uk/rd/pubs/whp/whp031.shtml">BBC R&amp;D; White Paper WHP031</a></li>
<li></li>
</ul>
<h3 id="code">Code</h3>
<ul>
<li><a href="http://www.schifra.com">Schifra Open Source C++ Reed–Solomon Codec</a></li>
<li><a href="http://rscode.sourceforge.net/">Henry Minsky's RSCode library, Reed–Solomon encoder/decoder</a></li>
<li><a href="https://code.google.com/p/rssoft/">Open Source C++ Reed-Solomon Soft Decoding library</a></li>
<li><a href="http://dept.ee.wits.ac.za/~versfeld/research_resources/sourcecode/Errors_And_Erasures_Test.zip">Matlab implementation of errors and-erasures Reed–Solomon decoding</a></li>
<li><a href="https://pypi.python.org/pypi/reedsolo">Pure-Python implementation of a Reed–Solomon codec</a></li>
</ul>

<p>"</p>

<p><a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a> <a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Not quite true. See <a href="#Remarks" title="wikilink">remarks</a> below.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">See , for example.<a href="#fnref5">↩</a></li>
<li id="fn6">. Explains the Delsarte-Goethals-Seidel theorem as used in the context of the error correcting code for <a href="compact_disc" title="wikilink">compact disc</a>.<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
