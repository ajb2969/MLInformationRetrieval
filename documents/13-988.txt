   Nested word      Nested word   In computer science , more specifically in automata and formal language theory, nested words are a concept proposed by Alur and Madhusudan as a joint generalization of words , as traditionally used for modelling linearly ordered structures, and of ordered unranked trees , as traditionally used for modelling hierarchical structures. Finite-state acceptors for nested words, so-called nested word automata , then give a more expressive generalization of finite automata on words. The linear encodings of languages accepted by finite nested word automata gives the class of visibly pushdown languages . The latter language class lies properly between the regular languages and the deterministic context-free languages . Since their introduction in 2004, these concepts have triggered much research in that area. 1  Formal definition  To define nested words , we first need to define matching relation . As usual, for a nonnegative integer    ℓ   normal-ℓ   \ell   , we use the notation    [  ℓ  ]     delimited-[]  normal-ℓ    [\ell]   to denote the set    {  1  ,  2  ,  …  ,   ℓ  -  1   ,  ℓ  }     1  2  normal-…    normal-ℓ  1   normal-ℓ    \{1,2,\ldots,\ell-1,\ell\}   , with the special case     [  0  ]   =  ∅       delimited-[]  0      [0]=\emptyset   .  A matching relation ↝ of length    ℓ  ≥  0      normal-ℓ  0    \ell\geq 0   is a subset of     {   -  ∞   ,  1  ,  2  ,  …  ,   ℓ  -  1   ,  ℓ  }   ×   {  1  ,  2  ,  …  ,   ℓ  -  1   ,  ℓ  ,  ∞  }            1  2  normal-…    normal-ℓ  1   normal-ℓ    1  2  normal-…    normal-ℓ  1   normal-ℓ      \{-\infty,1,2,\ldots,\ell-1,\ell\}\times\{1,2,\ldots,\ell-1,\ell,\infty\}   such that:   all nesting edges are forward, that is, if i ↝ j then i < j ;  nesting edges never have a finite position in common, that is, for -∞ < i < ∞, there is at most one position h such that h ↝ i , and there is at most one position j such that i ↝ j ; and  nesting edges never cross, that is, we can't find i < i ’≤ j < j ’ such that both i ↝ j and i ’ ↝ j ’.   A position i is referred to as   a call position , if i ↝ j for some j ,  a pending call if i ↝ ∞,  a return position , if h ↝ i for some h ,  a pending return if -∞ ↝ i , and  an internal position in all remaining cases.   A nested word of length   ℓ   normal-ℓ   \ell   over an alphabet Σ is a pair ( w ,↝), where w is a word of length   ℓ   normal-ℓ   \ell   over Σ (in the usual sense) and ↝ is a matching relation of length   ℓ   normal-ℓ   \ell   .  Encoding nested words into ordinary words  Nested words over the alphabet    Σ  =   {   a  1   ,   a  2   ,  …  ,   a  n   }       normal-Σ    subscript  a  1    subscript  a  2   normal-…   subscript  a  n      \Sigma=\{a_{1},a_{2},\ldots,a_{n}\}   can be encoded into "ordinary" words over the tagged alphabet     Σ  ^     normal-^  normal-Σ    \hat{\Sigma}   , in which each symbol a from Σ has three tagged counterparts: the symbol ⟨a for encoding a call position in a nested word labelled with a , the symbol a⟩ for encoding a return position labelled with a , and finally the symbol a itself for representing an internal position labelled with a . More precisely, let φ be the function mapping nested words over Σ to words over    Σ  ^     normal-^  normal-Σ    \hat{\Sigma}   such that each nested word (     w  1    w  2   ⋯   w  ℓ        subscript  w  1    subscript  w  2   normal-⋯   subscript  w  normal-ℓ     w_{1}w_{2}\cdots w_{\ell}   ,↝) is mapped to the word     x  1    x  2   …   x  ℓ        subscript  x  1    subscript  x  2   normal-…   subscript  x  normal-ℓ     x_{1}x_{2}...x_{\ell}   , where the letter    x  i     subscript  x  i    x_{i}   equals ⟨a , a , and a⟩ , if     w  i   =  a       subscript  w  i   a    w_{i}=a   and i is a (possibly pending) call position, an internal position, and a (possibly pending) return position, respectively.  Example  For illustration, let n=(w,↝) be the nested word over an ternary alphabet with w=abaabccca and matching relation ↝ = {(-∞,1),(2,∞),(3,4),(5,7),(8,∞)} . Then its encoding as word reads as φ(n) = a⟩⟨b⟨aa⟩⟨bcc⟩⟨ca .  Automata  Nested word automaton  A nested word automaton has a finite number of states, and operates in almost the same way as a deterministic finite automaton on classical strings: a classical finite automaton reads the input word    w  =    w  1   ⋯   w  ℓ        w     subscript  w  1   normal-⋯   subscript  w  normal-ℓ      w=w_{1}\cdots w_{\ell}   from left to right, and the state of the automaton after reading the j th letter    w  j     subscript  w  j    w_{j}   depends on the state in which the automaton was before reading    w  j     subscript  w  j    w_{j}   .  In a nested word automaton, the position   j   j   j   in the nested word (w,↝) might be a return position; if so, the state after reading    w  j     subscript  w  j    w_{j}   will not only depend on the linear state in which the automaton was before reading    w  j     subscript  w  j    w_{j}   , but also on a hierarchical state propagated by the automaton at the time it was in the corresponding call position. In analogy to regular languages of words, a set L of nested words is called regular if it is accepted by some (finite-state) nested word automaton.  Visibly pushdown automaton  Nested word automata are an automaton model accepting nested words. There is an equivalent automaton model operating on (ordinary) words. Namely, the notion of a deterministic visibly pushdown automaton is a restriction of the notion of a deterministic pushdown automaton .  Following Alur and Madhusudan, 2 a deterministic visibly pushdown automaton is formally defined as a 6-tuple    M  =   (  Q  ,   Σ  ^   ,  Γ  ,  δ  ,   q  0   ,  F  )       M   Q   normal-^  normal-Σ   normal-Γ  δ   subscript  q  0   F     M=(Q,\hat{\Sigma},\Gamma,\delta,q_{0},F)   where      Q   Q   Q   is a finite set of states ,      Σ  ^     normal-^  normal-Σ    \hat{\Sigma}   is the input alphabet , which – in contrast to that of ordinary pushdown automata – is partitioned into three sets    Σ  c     subscript  normal-Σ  c    \Sigma_{\text{c}}   ,    Σ  r     subscript  normal-Σ  r    \Sigma_{\text{r}}   , and    Σ  int     subscript  normal-Σ  int    \Sigma_{\text{int}}   . The alphabet    Σ  c     subscript  normal-Σ  c    \Sigma_{\text{c}}   denotes the set of call symbols ,    Σ  r     subscript  normal-Σ  r    \Sigma_{\text{r}}   contains the return symbols , and the set    Σ  int     subscript  normal-Σ  int    \Sigma_{\text{int}}   contains the internal symbols ,     Γ   normal-Γ   \Gamma   is a finite set which is called the stack alphabet , containing a special symbol    ⊥  ∈  Γ     fragments  bottom   Γ    \bot\in\Gamma   denoting the empty stack,      δ  =    δ  c   ∪   δ  r   ∪   δ  int        δ     subscript  δ  c    subscript  δ  r    subscript  δ  int      \delta=\delta_{\text{c}}\cup\delta_{\text{r}}\cup\delta_{\text{int}}   is the transition function , which is partitioned into three parts corresponding to call transitions, return transitions, and internal transitions, namely       δ  c   :    Q  ×   Σ  c    →   Q  ×  Γ       normal-:   subscript  δ  c    normal-→    Q   subscript  normal-Σ  c      Q  normal-Γ      \delta_{\text{c}}\colon Q\times\Sigma_{\text{c}}\to Q\times\Gamma   , the call transition function       δ  r   :    Q  ×   Σ  r   ×  Γ   →  Q      normal-:   subscript  δ  r    normal-→    Q   subscript  normal-Σ  r   normal-Γ   Q     \delta_{\text{r}}\colon Q\times\Sigma_{\text{r}}\times\Gamma\to Q   , the return transition function       δ  int   :    Q  ×   Σ  int    →  Q      normal-:   subscript  δ  int    normal-→    Q   subscript  normal-Σ  int    Q     \delta_{\text{int}}:Q\times\Sigma_{\text{int}}\to Q   , the internal transition function ,        q  0   ∈  Q       subscript  q  0   Q    q_{0}\in\,Q   is the initial state , and      F  ⊆  Q      F  Q    F\subseteq Q   is the set of accepting states .   The notion of computation of a visibly pushdown automaton is a restriction of the one used for pushdown automata . Visibly pushdown automata only add a symbol to the stack when reading a call symbol     a  c   ∈   Σ  c        subscript  a  c    subscript  normal-Σ  c     a_{\text{c}}\in\Sigma_{\text{c}}   , they only remove the top element from the stack when reading a return symbol     a  r   ∈   Σ  r        subscript  a  r    subscript  normal-Σ  r     a_{\text{r}}\in\Sigma_{\text{r}}   and they do not alter the stack when reading an internal event     a  i   ∈   Σ  int        subscript  a  i    subscript  normal-Σ  int     a_{\text{i}}\in\Sigma_{\text{int}}   . A computation ending in an accepting state is an accepting computation .  As a result, a visibly pushdown automaton cannot push to and pop from the stack with the same input symbol. Thus the language    L  =   {    a  n   b   a  n    ∣   n  ∈  N   }       L   conditional-set     superscript  a  n   b   superscript  a  n      n  normal-N      L=\{a^{n}ba^{n}\mid n\in\mathrm{N}\}   cannot be accepted by a visibly pushdown automaton for any partition of   Σ   normal-Σ   \Sigma   , however there are pushdown automata accepting this language.  If a language    L   L   L   over a tagged alphabet    Σ  ^     normal-^  normal-Σ    \hat{\Sigma}   is accepted by a deterministic visibly pushdown automaton, then   L   L   L   is called a visibly pushdown language .  Nondeterministic visibly pushdown automata  Nondeterministic visibly pushdown automata are as expressive as deterministic ones. Hence one can transform a nondeterministic visibly pushdown automaton into a deterministic one, but if the nondeterministic automaton had   s   s   s   states, the deterministic one may have up to    2   s  2      superscript  2   superscript  s  2     2^{s^{2}}   states. 3  Decision problems  Let    |  A  |      A    |A|   be the size of the description of an automaton   A   A   A   , then it is possible to check if a word n is accepted by the automaton in time    O   (     |  A  |   3   ℓ   )       O     superscript    A   3   normal-ℓ     O(|A|^{3}\ell)   . In particular, the emptiness problem is solvable in time    O   (    |  A  |   3   )       O   superscript    A   3     O(|A|^{3})   . If   A   A   A   is fixed, it is decidable in time    O   (  ℓ  )       O  normal-ℓ    O(\ell)   and space    O   (  d  )       O  d    O(d)   where   d   d   d   is the depth of n in a streaming seeing. It is also decidable with space    O   (   log   (  ℓ  )    )       O    normal-ℓ     O(\log(\ell))   and time    O   (    ℓ  2    log   (  ℓ  )     )       O     superscript  normal-ℓ  2     normal-ℓ      O(\ell^{2}\log(\ell))   , and by a uniform boolean circuit of depth    O   (   log  ℓ   )       O    normal-ℓ     O(\log\ell)   . 4  For two nondeterministic automata A and B , deciding whether the set of words accepted by A is a subset of the word accepted by B is EXPTIME -complete. It is also EXPTIME-complete to figure out if there is a word that is not accepted. 5  Languages  As the definition of visibly pushdown automata shows, deterministic visibly pushdown automata can be seen as a special case of deterministic pushdown automata ; thus the set VPL of visibly pushdown languages over     Σ  ^      normal-^  normal-Σ    \,\hat{\Sigma}   forms a subset of the set DCFL of deterministic context-free languages over the set of symbols in     Σ  ^      normal-^  normal-Σ    \,\hat{\Sigma}   . In particular, the function that removes the matching relation from nested words transforms regular languages over nested words into context-free languages.  Closure properties  The set of visibly pushdown languages is closed under the following operations: 6   set operations:  union  intersection  complement,     thus giving rise to a boolean algebra .    Kleene star  concatenation   For the intersection operation, one can construct a VPA M simulating two given VPAs    M  1     subscript  M  1    M_{1}   and    M  2     subscript  M  2    M_{2}   by a simple product construction : For    i  =   1  ,  2       i   1  2     i=1,2   , assume    M  i     subscript  M  i    M_{i}   is given as    (   Q  i   ,   Σ  ^   ,   Γ  i   ,   δ  i   ,   s  i   ,   Z  i   ,   F  i   )      subscript  Q  i    normal-^  normal-Σ    subscript  normal-Γ  i    subscript  δ  i    subscript  s  i    subscript  Z  i    subscript  F  i     (Q_{i},\ \hat{\Sigma},\ \Gamma_{i},\ \delta_{i},\ s_{i},\ Z_{i},\ F_{i})   . Then for the automaton M , the set of states is      Q   1   ×   Q  2        subscript  Q  1    subscript  Q  2     \,Q_{1}\times Q_{2}   , the initial state is    (   s  1   ,   s  2   )      subscript  s  1    subscript  s  2     \left(s_{1},s_{2}\right)   , the set of final states is     F  1   ×   F  2        subscript  F  1    subscript  F  2     F_{1}\times F_{2}   , the stack alphabet is given by      Γ   1   ×   Γ  2        subscript  normal-Γ  1    subscript  normal-Γ  2     \,\Gamma_{1}\times\Gamma_{2}   , and the initial stack symbol is    (   Z  1   ,   Z  2   )      subscript  Z  1    subscript  Z  2     (Z_{1},Z_{2})   .  If   M   M   M   is in state    (   p  1   ,   p  2   )      subscript  p  1    subscript  p  2     (p_{1},p_{2})   on reading a call symbol     ⟨  a     fragments  normal-⟨  a    \left\langle a\right.   , then   M   M   M   pushes the stack symbol    (   γ  1   ,   γ  2   )      subscript  γ  1    subscript  γ  2     (\gamma_{1},\gamma_{2})   and goes to state    (   q  1   ,   q  2   )      subscript  q  1    subscript  q  2     (q_{1},q_{2})   , where    γ  i     subscript  γ  i    \gamma_{i}   is the stack symbol pushed by    M  i     subscript  M  i    M_{i}   when transitioning from state    p  i     subscript  p  i    p_{i}   to    q  i     subscript  q  i    q_{i}   on reading input    ⟨  a     fragments  normal-⟨  a    \left\langle a\right.   .  If   M   M   M   is in state    (   p  1   ,   p  2   )      subscript  p  1    subscript  p  2     (p_{1},p_{2})   on reading an internal symbol    a   a   a   , then   M   M   M   goes to state    (   q  1   ,   q  2   )      subscript  q  1    subscript  q  2     (q_{1},q_{2})   , whenever    M  i     subscript  M  i    M_{i}   transitions from state    p  i     subscript  p  i    p_{i}   to    q  i     subscript  q  i    q_{i}   on reading a .  If   M   M   M   is in state    (   p  1   ,   p  2   )      subscript  p  1    subscript  p  2     (p_{1},p_{2})   on reading a return symbol     a  ⟩     fragments  a  normal-⟩    \left.a\right\rangle   , then   M   M   M   pops the symbol    (   γ  1   ,   γ  2   )      subscript  γ  1    subscript  γ  2     (\gamma_{1},\gamma_{2})   from the stack and goes to state    (   q  1   ,   q  2   )      subscript  q  1    subscript  q  2     (q_{1},q_{2})   , where    γ  i     subscript  γ  i    \gamma_{i}   is the stack symbol popped by    M  i     subscript  M  i    M_{i}   when transitioning from state    p  i     subscript  p  i    p_{i}   to    q  i     subscript  q  i    q_{i}   on reading    a  ⟩     fragments  a  normal-⟩    \left.a\right\rangle   .  Correctness of the above construction crucially relies on the fact that the push and pop actions of the simulated machines    M  1     subscript  M  1    M_{1}   and    M  2     subscript  M  2    M_{2}   are synchronized along the input symbols read. In fact, a similar simulation is no longer possible for deterministic pushdown automata , as the larger class of deterministic context-free languages is no longer closed under intersection.  In contrast to the construction for concatenation shown above, the complementation construction for visibly pushdown automata parallels the standard construction 7 for deterministic pushdown automata.  Moreover, like the class of context free languages the class of visibly pushdown languages is closed under prefix closure and reversal, hence also suffix closure.  Relation to other language classes  point out that the visibly pushdown languages are more general than the parenthesis languages suggested in . As shown by , the VPL in turn are strictly contained in the class of languages described by operator-precedence grammars , which were introduced by . In comparison to conjunctive grammars , a generalization of context-free grammars,  shows that the linear conjunctive languages form a superclass of the visibly pushdown languages. The table at the end of this article puts the family of visibly pushdown languages in relation to other language families in the Chomsky hierarchy . Rajeev Alur and Parthasarathy Madhusudan 8 9 related a subclass of regular binary tree languages to visibly pushdown languages.  Other models of description  Visibly pushdown grammars  Visibly pushdown languages are exactly the languages that can be described by visibly pushdown grammars . 10  Visibly pushdown grammars can be defined as a restriction of context-free grammars . A visibly pushdown grammars G is defined by the 4- tuple :      G  =   (  V  =   V  0   ∪    V  1    ,   Σ   ,   R   ,   S   )      fragments  G    fragments  normal-(  V    superscript  V  0     superscript  V  1   normal-,  Σ  normal-,  R  normal-,  S  normal-)     G=(V=V^{0}\cup V^{1}\,,\Sigma\,,R\,,S\,)   where        V  0      superscript  V  0    V^{0}\,   and     V  1      superscript  V  1    V^{1}\,   are disjoint finite set; each element    v  ∈  V      v  V    v\in V   is called a non-terminal character or a variable . Each variable represents a different type of phrase or clause in the sentence. Each variable defines a sub-language of the language defined by    G    G   G\,   , and the sub-languages of     V  0      superscript  V  0    V^{0}\,   are the one without pending calls or pending returns.      Σ    normal-Σ   \Sigma\,   is a finite set of terminal s, disjoint from    V    V   V\,   , which make up the actual content of the sentence. The set of terminals is the alphabet of the language defined by the grammar    G    G   G\,   .      S    S   S\,   is the start variable (or start symbol), used to represent the whole sentence (or program). It must be an element of    V    V   V\,   .      R    R   R\,   is a finite relation from    V    V   V\,   to     (   V  ∪  Σ   )   *     superscript    V  normal-Σ      (V\cup\Sigma)^{*}   such that       \exist   w   ∈    (   V  ∪  Σ   )   *    :    (  S  ,  w  )   ∈  R      normal-:      \exist  w    superscript    V  normal-Σ         S  w   R     \exist\,w\in(V\cup\Sigma)^{*}:(S,w)\in R   . The members of    R    R   R\,   are called the (rewrite) rule s or production s of the grammar. There are three kinds of rewrite rules. For      X  ,  Y   ∈  V   ,   Z  ∈   V  0       formulae-sequence     X  Y   V     Z   superscript  V  0      X,Y\in V,Z\in V^{0}   ,    a  ∈   Σ  ^       a   normal-^  normal-Σ     a\in\hat{\Sigma}   and    b  ∈   Σ  ^       b   normal-^  normal-Σ     b\in\hat{\Sigma}         X  →  ϵ     normal-→  X  ϵ    X\to\epsilon         X  →   a  Y      normal-→  X    a  Y     X\to aY   and if    X  ∈   V  0       X   superscript  V  0     X\in V^{0}   then    Y  ∈   V  0       Y   superscript  V  0     Y\in V^{0}   and    a  ∈  Σ      a  normal-Σ    a\in\Sigma         X  →    ⟨   a  Z  b   ⟩   Y      normal-→  X     delimited-⟨⟩    a  Z  b    Y     X\to\langle aZb\rangle Y   and if    X  ∈   V  0       X   superscript  V  0     X\in V^{0}   then    Y  ∈   V  0       Y   superscript  V  0     Y\in V^{0}       Here, the asterisk represents the Kleene star operation and   ϵ   ϵ   \epsilon   is the empty word.  Uniform Boolean circuits  The problem whether a word of length   ℓ   normal-ℓ   \ell   is accepted by a given nested word automaton can be solved by uniform boolean circuits of depth     \Omicron    (   log  ℓ   )       \Omicron    normal-ℓ     \Omicron(\log\ell)   . 11  Logical description  Regular languages over nested words are exactly the set of languages described by Monadic  second-order logic with two unary predicates call and return , linear successor and the matching relation ↝. 12  See also   Model checking   Notes    References       Okhotin, Alexander: Comparing linear conjunctive languages to subfamilies of the context-free languages , 37th International Conference on Current Trends in Theory and Practice of Computer Science (SOFSEM 2011).   External links   Nested words and visibly pushdown languages  Visibly pushdown automata - Automata on nested words  class VPL at the Complexity Zoo   "  Category:Words  Category:Formal languages  Category:Automata theory     [ http://scholar.google.com/scholar?as_q =&as;_oq=%22nested+words%22+%22visibly+pushdown%22 Google Scholar search results] for "nested words" OR "visibly pushdown" ↩  ↩  ↩     , p. 238 f. ↩  Sect.4, Theorem 5, ↩  Sect.7 ↩        