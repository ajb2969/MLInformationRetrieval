<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1785">Randomized rounding</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Randomized rounding</h1>
<hr/>

<p>Within <a href="computer_science" title="wikilink">computer science</a> and <a href="operations_research" title="wikilink">operations research</a>, many <a href="combinatorial_optimization" title="wikilink">combinatorial optimization</a> problems are computationally <a href="intractability_(complexity)" title="wikilink">intractable</a> to solve exactly (to optimality). Many such problems do admit fast (<a href="polynomial_time" title="wikilink">polynomial time</a>) <a href="approximation_algorithms" title="wikilink">approximation algorithms</a>—that is, algorithms that are guaranteed to return an approximately optimal solution given any input.</p>

<p><strong>Randomized rounding</strong>  is a widely used approach for designing and analyzing such <a href="approximation_algorithms" title="wikilink">approximation algorithms</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The basic idea is to use the <a href="probabilistic_method" title="wikilink">probabilistic method</a> to convert an optimal solution of a <a href="linear_programming_relaxation" title="wikilink">relaxation</a> of the problem into an approximately optimal solution to the original problem.</p>
<h2 id="overview">Overview</h2>

<p>The basic approach has three steps:</p>
<ol>
<li>Formulate the problem to be solved as an <a href="integer_linear_program" title="wikilink">integer linear program</a> (ILP).</li>
<li>Compute an optimal fractional solution 

<math display="inline" id="Randomized_rounding:0">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to the <a href="linear_programming_relaxation" title="wikilink">linear programming relaxation</a> (LP) of the ILP.</li>
<li>Round the fractional solution 

<math display="inline" id="Randomized_rounding:1">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 of the LP to an integer solution 

<math display="inline" id="Randomized_rounding:2">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 of the ILP.</li>
</ol>

<p>(Although the approach is most commonly applied with linear programs, other kinds of relaxations are sometimes used. For example, see Goeman's and Williamson's <a href="semi-definite_programming" title="wikilink">semi-definite programming</a>-based <a href="Semi-definite_programming#Example_3_.28Goemans-Williamson_MAX_CUT_approximation_algorithm.29" title="wikilink">Max-Cut approximation algorithm</a>.)</p>

<p>The challenge in the first step is to choose a suitable integer linear program. Familiarity with linear programming is required, in particular, familiarity with how to model problems using linear programs and integer linear programs. But, for many problems, there is a natural integer linear program that works well, such as in the Set Cover example below. (The integer linear program should have a small <a href="Linear_programming_relaxation#Approximation_and_integrality_gap" title="wikilink">integrality gap</a>; indeed randomized rounding is often used to prove bounds on integrality gaps.)</p>

<p>In the second step, the optimal fractional solution can typically be computed in <a href="Polynomial_time#Polynomial_time" title="wikilink">polynomial time</a> using any standard <a href="linear_programming" title="wikilink">linear programming</a> algorithm.</p>

<p>In the third step, the fractional solution must be converted into an integer solution (and thus a solution to the original problem). This is called <em>rounding</em> the fractional solution. The resulting integer solution should (provably) have cost not much larger than the cost of the fractional solution. This will ensure that the cost of the integer solution is not much larger than the cost of the optimal integer solution.</p>

<p>The main technique used to do the third step (rounding) is to use randomization, and then to use probabilistic arguments to bound the increase in cost due to the rounding (following the <a href="probabilistic_method" title="wikilink">probabilistic method</a> from combinatorics). There, probabilistic arguments are used to show the existence of discrete structures with desired properties. In this context, one uses such arguments to show the following:</p>
<dl>
<dd><em>Given any fractional solution 

<math display="inline" id="Randomized_rounding:3">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 of the LP, with positive probability the randomized rounding process produces an integer solution 

<math display="inline" id="Randomized_rounding:4">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 that approximates 

<math display="inline" id="Randomized_rounding:5">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

</em> according to some desired criterion.
</dd>
</dl>

<p>Finally, to make the third step computationally efficient, one either shows that 

<math display="inline" id="Randomized_rounding:6">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 approximates 

<math display="inline" id="Randomized_rounding:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 with high probability (so that the step can remain randomized) or one <a href="Derandomization" title="wikilink">derandomizes</a> the rounding step, typically using the <a href="method_of_conditional_probabilities" title="wikilink">method of conditional probabilities</a>. The latter method converts the randomized rounding process into an efficient deterministic process that is guaranteed to reach a good outcome.</p>
<h2 id="comparison-to-other-applications-of-the-probabilistic-method">Comparison to other applications of the probabilistic method</h2>

<p>The randomized rounding step differs from most applications of the <a href="probabilistic_method" title="wikilink">probabilistic method</a> in two respects:</p>
<ol>
<li>The <a href="Analysis_of_algorithms" title="wikilink">computational complexity</a> of the rounding step is important. It should be implementable by a fast (e.g. <a href="polynomial_time" title="wikilink">polynomial time</a>) <a class="uri" href="algorithm" title="wikilink">algorithm</a>.</li>
<li>The probability distribution underlying the random experiment is a function of the solution 

<math display="inline" id="Randomized_rounding:8">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 of a <a href="linear_programming_relaxation" title="wikilink">relaxation</a> of the problem instance. This fact is crucial to proving the <a href="Approximation_algorithm#Performance_guarantees" title="wikilink">performance guarantee</a> of the approximation algorithm --- that is, that for any problem instance, the algorithm returns a solution that approximates the <em>optimal solution for that specific instance</em>. In comparison, <a href="Probabilistic_method" title="wikilink">applications of the probabilistic method in combinatorics</a> typically show the existence of structures whose features depend on other parameters of the input. For example, consider <a href="Turán's_theorem" title="wikilink">Turán's theorem</a>, which can be stated as "any <a href="Graph_(mathematics)" title="wikilink">graph</a> with 

<math display="inline" id="Randomized_rounding:9">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 vertices of average degree 

<math display="inline" id="Randomized_rounding:10">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 must have an <a href="Independent_set_(graph_theory)" title="wikilink">independent set</a> of size at least 

<math display="inline" id="Randomized_rounding:11">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>d</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <apply>
     <plus></plus>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/(d+1)
  </annotation>
 </semantics>
</math>

. (See <a href="Method_of_conditional_probabilities#Turán.27s_theorem" title="wikilink">this for a probabilistic proof of Turán's theorem</a>.) While there are graphs for which this bound is tight, there are also graphs which have independent sets much larger than 

<math display="inline" id="Randomized_rounding:12">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>d</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <apply>
     <plus></plus>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/(d+1)
  </annotation>
 </semantics>
</math>

. Thus, the size of the independent set shown to exist by Turán's theorem in a graph may, in general, be much smaller than the maximum independent set for that graph.</li>
</ol>
<h2 id="set-cover-example">Set Cover example</h2>

<p>The method is best illustrated by example. The following example illustrates how randomized rounding can be used to design an approximation algorithm for the <a href="Set_Cover" title="wikilink">Set Cover</a> problem.</p>

<p>Fix any instance 

<math display="inline" id="Randomized_rounding:13">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>c</mi>
   <mo>,</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>c</ci>
    <ci>𝒮</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle c,\mathcal{S}\rangle
  </annotation>
 </semantics>
</math>


 of the Set Cover problem over a universe 

<math display="inline" id="Randomized_rounding:14">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

.</p>

<p>For step 1, let IP be the <a href="set_cover#Integer_linear_program_formulation" title="wikilink">standard integer linear program for set cover</a> for this instance.</p>

<p>For step 2, let LP be the <a href="linear_programming_relaxation" title="wikilink">linear programming relaxation</a> of IP, and compute an optimal solution 

<math display="inline" id="Randomized_rounding:15">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 to LP using any standard <a href="linear_programming" title="wikilink">linear programming</a> algorithm. (This takes time polynomial in the input size.)</p>

<p>(The feasible solutions to LP are the vectors 

<math display="inline" id="Randomized_rounding:16">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 that assign each set 

<math display="inline" id="Randomized_rounding:17">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in\mathcal{S}
  </annotation>
 </semantics>
</math>

 a non-negative weight 

<math display="inline" id="Randomized_rounding:18">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{s}
  </annotation>
 </semantics>
</math>


, such that, for each element 

<math display="inline" id="Randomized_rounding:19">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>e</ci>
    <ci>𝒰</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\in\mathcal{U}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Randomized_rounding:20">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 <em>covers</em> 

<math display="inline" id="Randomized_rounding:21">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 -- the total weight assigned to the sets containing 

<math display="inline" id="Randomized_rounding:22">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is at least 1, that is,</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Randomized_rounding:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>s</mi>
      <mo>∋</mo>
      <mi>e</mi>
     </mrow>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>s</mi>
    </msub>
   </mrow>
   <mo>≥</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>e</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{s\ni e}x_{s}\geq 1.
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>

<p>The optimal solution 

<math display="inline" id="Randomized_rounding:24">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 is a feasible solution whose cost</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Randomized_rounding:25">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mi class="ltx_font_mathcaligraphic">𝒰</mi>
    </mrow>
   </msub>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msubsup>
     <mi>x</mi>
     <mi>s</mi>
     <mo>*</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>s</ci>
      <ci>𝒰</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{s\in\mathcal{U}}c(S)x^{*}_{s}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>is as small as possible.)</p>
<hr/>

<p>Note that any set cover 

<math display="inline" id="Randomized_rounding:26">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Randomized_rounding:27">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 gives a feasible solution 

<math display="inline" id="Randomized_rounding:28">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 (where 

<math display="inline" id="Randomized_rounding:29">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>s</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{s}=1
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Randomized_rounding:30">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in\mathcal{C}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Randomized_rounding:31">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>s</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{s}=0
  </annotation>
 </semantics>
</math>

 otherwise). The cost of this 

<math display="inline" id="Randomized_rounding:32">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 equals the cost of 

<math display="inline" id="Randomized_rounding:33">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


, that is,</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Randomized_rounding:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>s</mi>
       <mo>∈</mo>
       <mi class="ltx_font_mathcaligraphic">𝒞</mi>
      </mrow>
     </msub>
     <mrow>
      <mi>c</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>s</mi>
       <mo>∈</mo>
       <mi class="ltx_font_mathcaligraphic">𝒮</mi>
      </mrow>
     </msub>
     <mrow>
      <mi>c</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>x</mi>
       <mi>s</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>s</ci>
       <ci>𝒞</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>s</ci>
       <ci>𝒮</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{s\in\mathcal{C}}c(s)=\sum_{s\in\mathcal{S}}c(s)x_{s}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>In other words, the linear program LP is a <a href="linear_programming_relaxation" title="wikilink">relaxation</a> of the given set-cover problem.</p>

<p>Since 

<math display="inline" id="Randomized_rounding:35">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 has minimum cost among feasible solutions to the LP, <em>the cost of 

<math display="inline" id="Randomized_rounding:36">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 is a lower bound on the cost of the optimal set cover</em>.</p>
<h3 id="step-3-the-randomized-rounding-step">Step 3: The randomized rounding step</h3>

<p>Here is a description of the third step—the rounding step, which must convert the minimum-cost fractional set cover 

<math display="inline" id="Randomized_rounding:37">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 into a feasible integer solution 

<math display="inline" id="Randomized_rounding:38">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>


 (corresponding to a true set cover).</p>

<p>The rounding step should produce an 

<math display="inline" id="Randomized_rounding:39">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 that, with positive probability, has cost within a small factor of the cost of 

<math display="inline" id="Randomized_rounding:40">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

. Then (since the cost of 

<math display="inline" id="Randomized_rounding:41">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 is a lower bound on the cost of the optimal set cover), the cost of 

<math display="inline" id="Randomized_rounding:42">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 will be within a small factor of the optimal cost.</p>

<p>As a starting point, consider the most natural rounding scheme:</p>
<dl>
<dd><dl>
<dd><em>For each set 

<math display="inline" id="Randomized_rounding:43">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in\mathcal{S}
  </annotation>
 </semantics>
</math>


 in turn, take 

<math display="inline" id="Randomized_rounding:44">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mi>s</mi>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s}=1
  </annotation>
 </semantics>
</math>

 with probability 

<math display="inline" id="Randomized_rounding:45">
 <semantics>
  <mrow>
   <mi>min</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <msubsup>
     <mi>x</mi>
     <mi>s</mi>
     <mo>*</mo>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <min></min>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <times></times>
     </apply>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min(1,x^{*}_{s})
  </annotation>
 </semantics>
</math>

, otherwise take 

<math display="inline" id="Randomized_rounding:46">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mi>s</mi>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s}=0
  </annotation>
 </semantics>
</math>

.</em>
</dd>
</dl>
</dd>
</dl>

<p>With this rounding scheme, the expected cost of the chosen sets is at most 

<math display="inline" id="Randomized_rounding:47">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mi>s</mi>
   </msub>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msubsup>
     <mi>x</mi>
     <mi>s</mi>
     <mo>*</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{s}c(s)x^{*}_{s}
  </annotation>
 </semantics>
</math>

, the cost of the fractional cover. This is good. Unfortunately the coverage is not good. When the variables 

<math display="inline" id="Randomized_rounding:48">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <mi>s</mi>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}_{s}
  </annotation>
 </semantics>
</math>


 are small, the probability that an element 

<math display="inline" id="Randomized_rounding:49">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is not covered is about</p>

<p>

<math display="block" id="Randomized_rounding:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mi>s</mi>
        <mo>∋</mo>
        <mi>e</mi>
       </mrow>
      </munder>
      <mn>1</mn>
     </mrow>
     <mo>-</mo>
     <msubsup>
      <mi>x</mi>
      <mi>s</mi>
      <mo>*</mo>
     </msubsup>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>s</mi>
       <mo>∋</mo>
       <mi>e</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <msubsup>
         <mi>x</mi>
         <mi>s</mi>
         <mo>*</mo>
        </msubsup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo maxsize="160%" minsize="160%">(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>s</mi>
          <mo>∋</mo>
          <mi>e</mi>
         </mrow>
        </munder>
        <msubsup>
         <mi>x</mi>
         <mi>s</mi>
         <mo>*</mo>
        </msubsup>
       </mrow>
      </mrow>
      <mo maxsize="160%" minsize="160%">)</mo>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <in></in>
         <ci>e</ci>
         <ci>s</ci>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <in></in>
        <ci>e</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <apply>
       <exp></exp>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <times></times>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <in></in>
          <ci>e</ci>
          <ci>s</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <times></times>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{s\ni e}1-x^{*}_{s}\approx\prod_{s\ni e}\exp(-x^{*}_{s})=\exp\Big(-\sum_%
{s\ni e}x^{*}_{s}\Big)\approx\exp(-1).
  </annotation>
 </semantics>
</math>

</p>

<p>So only a constant fraction of the elements will be covered in expectation.</p>

<p>To make 

<math display="inline" id="Randomized_rounding:51">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 cover every element with high probability, the standard rounding scheme first <em>scales up</em> the rounding probabilities by an appropriate factor 

<math display="inline" id="Randomized_rounding:52">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>λ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda>1
  </annotation>
 </semantics>
</math>


. Here is the standard rounding scheme:</p>
<dl>
<dd><dl>
<dd><em>Fix a parameter 

<math display="inline" id="Randomized_rounding:53">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>λ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\geq 1
  </annotation>
 </semantics>
</math>

. For each set 

<math display="inline" id="Randomized_rounding:54">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in\mathcal{S}
  </annotation>
 </semantics>
</math>

 in turn,</em>
</dd>
<dd><em>take 

<math display="inline" id="Randomized_rounding:55">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mi>s</mi>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s}=1
  </annotation>
 </semantics>
</math>

 with probability 

<math display="inline" id="Randomized_rounding:56">
 <semantics>
  <mrow>
   <mi>min</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>λ</mi>
     <msubsup>
      <mi>x</mi>
      <mi>s</mi>
      <mo>*</mo>
     </msubsup>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <min></min>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min(\lambda x^{*}_{s},1)
  </annotation>
 </semantics>
</math>

, otherwise take 

<math display="inline" id="Randomized_rounding:57">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mi>s</mi>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s}=0
  </annotation>
 </semantics>
</math>


.</em>
</dd>
</dl>
</dd>
</dl>

<p>Scaling the probabilities up by 

<math display="inline" id="Randomized_rounding:58">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 increases the expected cost by 

<math display="inline" id="Randomized_rounding:59">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

, but makes coverage of all elements likely. The idea is to choose 

<math display="inline" id="Randomized_rounding:60">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 as small as possible so that all elements are provably covered with non-zero probability. Here is a detailed analysis.</p>
<hr/>
<h4 id="lemma-approximation-guarantee-for-rounding-scheme">lemma (approximation guarantee for rounding scheme)</h4>
<dl>
<dd><dl>
<dd><em>Fix 

<math display="inline" id="Randomized_rounding:61">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mrow>
    <mi>ln</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi class="ltx_font_mathcaligraphic">𝒰</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <ln></ln>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <abs></abs>
       <ci>𝒰</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=\ln(2|\mathcal{U}|)
  </annotation>
 </semantics>
</math>

. With positive probability, the rounding scheme returns a set cover 

<math display="inline" id="Randomized_rounding:62">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>


 of cost at most 

<math display="inline" id="Randomized_rounding:63">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mi>ln</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi class="ltx_font_mathcaligraphic">𝒰</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mi>c</mi>
   </mrow>
   <mo>⋅</mo>
   <msup>
    <mi>x</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <ln></ln>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <abs></abs>
        <ci>𝒰</ci>
       </apply>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\ln(2|\mathcal{U}|)c\cdot x^{*}
  </annotation>
 </semantics>
</math>

 (and thus of cost 

<math display="inline" id="Randomized_rounding:64">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi class="ltx_font_mathcaligraphic">𝒰</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <apply>
      <abs></abs>
      <ci>𝒰</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log|\mathcal{U}|)
  </annotation>
 </semantics>
</math>

 times the cost of the optimal set cover).</em>
</dd>
</dl>
</dd>
</dl>

<p>(Note: with care the 

<math display="inline" id="Randomized_rounding:65">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi class="ltx_font_mathcaligraphic">𝒰</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <apply>
      <abs></abs>
      <ci>𝒰</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log|\mathcal{U}|)
  </annotation>
 </semantics>
</math>

 can be reduced to 

<math display="inline" id="Randomized_rounding:66">
 <semantics>
  <mrow>
   <mrow>
    <mi>ln</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi class="ltx_font_mathcaligraphic">𝒰</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi class="ltx_font_mathcaligraphic">𝒰</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ln></ln>
     <apply>
      <abs></abs>
      <ci>𝒰</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <log></log>
      <apply>
       <log></log>
       <apply>
        <abs></abs>
        <ci>𝒰</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ln(|\mathcal{U}|)+O(\log\log|\mathcal{U}|)
  </annotation>
 </semantics>
</math>

.)</p>
<h4 id="proof">proof</h4>

<p>The output 

<math display="inline" id="Randomized_rounding:67">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>


 of the random rounding scheme has the desired properties as long as none of the following "bad" events occur:</p>
<ol>
<li>the cost 

<math display="inline" id="Randomized_rounding:68">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>⋅</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>c</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\cdot x^{\prime}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Randomized_rounding:69">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 exceeds 

<math display="inline" id="Randomized_rounding:70">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>λ</mi>
    <mi>c</mi>
   </mrow>
   <mo>⋅</mo>
   <msup>
    <mi>x</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>λ</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\lambda c\cdot x^{*}
  </annotation>
 </semantics>
</math>

, or</li>
<li>for some element 

<math display="inline" id="Randomized_rounding:71">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Randomized_rounding:72">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>


 fails to cover 

<math display="inline" id="Randomized_rounding:73">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>The expectation of each 

<math display="inline" id="Randomized_rounding:74">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <mi>s</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s}
  </annotation>
 </semantics>
</math>

 is at most 

<math display="inline" id="Randomized_rounding:75">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <msubsup>
    <mi>x</mi>
    <mi>s</mi>
    <mo>*</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>λ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>s</ci>
     </apply>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x_{s}^{*}
  </annotation>
 </semantics>
</math>

. By <a href="Expected_value#Linearity" title="wikilink">linearity of expectation</a>, the expectation of 

<math display="inline" id="Randomized_rounding:76">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>⋅</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>c</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\cdot x^{\prime}
  </annotation>
 </semantics>
</math>

 is at most 

<math display="inline" id="Randomized_rounding:77">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>s</mi>
    </msub>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>λ</mi>
     <msubsup>
      <mi>x</mi>
      <mi>s</mi>
      <mo>*</mo>
     </msubsup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>λ</mi>
     <mi>c</mi>
    </mrow>
    <mo>⋅</mo>
    <msup>
     <mi>x</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>s</ci>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>s</ci>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{s}c(s)\lambda x_{s}^{*}=\lambda c\cdot x^{*}
  </annotation>
 </semantics>
</math>


. Thus, by <a href="Markov's_inequality" title="wikilink">Markov's inequality</a>, the probability of the first bad event above is at most 

<math display="inline" id="Randomized_rounding:78">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2
  </annotation>
 </semantics>
</math>

.</p>

<p>For the remaining bad events (one for each element 

<math display="inline" id="Randomized_rounding:79">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

), note that, since 

<math display="inline" id="Randomized_rounding:80">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>s</mi>
      <mo>∋</mo>
      <mi>e</mi>
     </mrow>
    </msub>
    <msubsup>
     <mi>x</mi>
     <mi>s</mi>
     <mo>*</mo>
    </msubsup>
   </mrow>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>e</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{s\ni e}x^{*}_{s}\geq 1
  </annotation>
 </semantics>
</math>

 for any given element 

<math display="inline" id="Randomized_rounding:81">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

, the probability that 

<math display="inline" id="Randomized_rounding:82">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>


 is not covered is</p>

<p>

<math display="inline" id="Randomized_rounding:83">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>s</mi>
      <mo>∋</mo>
      <mi>e</mi>
     </mrow>
    </munder>
   </mstyle>
   <mrow>
    <mo maxsize="120%" minsize="120%">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>min</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>λ</mi>
        <msubsup>
         <mi>x</mi>
         <mi>s</mi>
         <mo>*</mo>
        </msubsup>
       </mrow>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo maxsize="120%" minsize="120%">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <in></in>
      <ci>e</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <min></min>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <times></times>
        </apply>
        <ci>s</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\prod_{s\ni e}\big(1-\min(\lambda x^{*}_{s},1)\big)
  </annotation>
 </semantics>
</math>


</p>

<p>(This uses the inequality 

<math display="inline" id="Randomized_rounding:84">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mi>z</mi>
   </mrow>
   <mo>≤</mo>
   <msup>
    <mi>e</mi>
    <mi>z</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+z\leq e^{z}
  </annotation>
 </semantics>
</math>

, which is strict for 

<math display="inline" id="Randomized_rounding:85">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>z</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\neq 0
  </annotation>
 </semantics>
</math>

.)</p>

<p>Thus, for each of the 

<math display="inline" id="Randomized_rounding:86">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>𝒰</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathcal{U}|
  </annotation>
 </semantics>
</math>

 elements, the probability that the element is not covered is less than 

<math display="inline" id="Randomized_rounding:87">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>2</mn>
     <mi class="ltx_font_mathcaligraphic">𝒰</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>𝒰</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/(2\mathcal{U})
  </annotation>
 </semantics>
</math>

.</p>

<p>By the <a href="naive_union_bound" title="wikilink">naive union bound</a>, the probability that one of the 

<math display="inline" id="Randomized_rounding:88">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi class="ltx_font_mathcaligraphic">𝒰</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <apply>
     <abs></abs>
     <ci>𝒰</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+|\mathcal{U}|
  </annotation>
 </semantics>
</math>

 bad events happens is less than 

<math display="inline" id="Randomized_rounding:89">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi class="ltx_font_mathcaligraphic">𝒰</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>/</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi class="ltx_font_mathcaligraphic">𝒰</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <abs></abs>
       <ci>𝒰</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>𝒰</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2+|\mathcal{U}|/(2\mathcal{U})=1
  </annotation>
 </semantics>
</math>

. Thus, with positive probability there are no bad events and 

<math display="inline" id="Randomized_rounding:90">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 is a set cover of cost at most 

<math display="inline" id="Randomized_rounding:91">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>λ</mi>
    <mi>c</mi>
   </mrow>
   <mo>⋅</mo>
   <msup>
    <mi>x</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>λ</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\lambda c\cdot x^{*}
  </annotation>
 </semantics>
</math>

. QED</p>
<h3 id="derandomization-using-the-method-of-conditional-probabilities">Derandomization using the method of conditional probabilities</h3>

<p>The lemma above shows the <em>existence</em> of a set cover of cost 

<math display="inline" id="Randomized_rounding:92">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo stretchy="false">|</mo>
     <mi class="ltx_font_mathcaligraphic">𝒰</mi>
     <mo stretchy="false">|</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
    <mo>⋅</mo>
    <msup>
     <mi>x</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">O</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <log></log>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>normal-|</ci>
      <csymbol cd="unknown">U</csymbol>
      <ci>normal-|</ci>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <times></times>
     </apply>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log(|\mathcal{U}|)c\cdot x^{*}
  </annotation>
 </semantics>
</math>

). In this context our goal is an efficient approximation algorithm, not just an existence proof, so we are not done.</p>

<p>One approach would be to increase 

<math display="inline" id="Randomized_rounding:93">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 a little bit, then show that the probability of success is at least, say, 1/4. With this modification, repeating the random rounding step a few times is enough to ensure a successful outcome with high probability.</p>

<p>That approach weakens the approximation ratio. We next describe a different approach that yields a deterministic algorithm that is guaranteed to match the approximation ratio of the existence proof above. The approach is called the <a href="method_of_conditional_probabilities" title="wikilink">method of conditional probabilities</a>.</p>

<p>The deterministic algorithm emulates the randomized rounding scheme: it considers each set 

<math display="inline" id="Randomized_rounding:94">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in\mathcal{S}
  </annotation>
 </semantics>
</math>

 in turn, and chooses 

<math display="inline" id="Randomized_rounding:95">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mi>s</mi>
    <mo>′</mo>
   </msubsup>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s}\in\{0,1\}
  </annotation>
 </semantics>
</math>

. But instead of making each choice <em>randomly</em> based on 

<math display="inline" id="Randomized_rounding:96">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

, it makes the choice <em>deterministically</em>, so as to <em>keep the conditional probability of failure, given the choices so far, below 1</em>.</p>
<h4 id="bounding-the-conditional-probability-of-failure">Bounding the conditional probability of failure</h4>

<p>We want to be able to set each variable 

<math display="inline" id="Randomized_rounding:97">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <mi>s</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s}
  </annotation>
 </semantics>
</math>

 in turn so as to keep the conditional probability of failure below 1. To do this, we need a good bound on the conditional probability of failure. The bound will come by refining the original existence proof. That proof implicitly bounds the probability of failure by the expectation of the random variable</p>

<p>

<math display="block" id="Randomized_rounding:98">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>c</mi>
      <mo>⋅</mo>
      <msup>
       <mi>x</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>λ</mi>
       <mi>c</mi>
      </mrow>
      <mo>⋅</mo>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
     </mrow>
    </mfrac>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msup>
      <mi class="ltx_font_mathcaligraphic">𝒰</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>m</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-⋅</ci>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>λ</ci>
        <ci>c</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝒰</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=\frac{c\cdot x^{\prime}}{2\lambda c\cdot x^{*}}+|\mathcal{U}^{(m)}|
  </annotation>
 </semantics>
</math>

, where</p>

<p>

<math display="block" id="Randomized_rounding:99">
 <semantics>
  <mrow>
   <msup>
    <mi class="ltx_font_mathcaligraphic">𝒰</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo maxsize="160%" minsize="160%">{</mo>
    <mi>e</mi>
    <mo>:</mo>
    <mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mi>s</mi>
        <mo>∋</mo>
        <mi>e</mi>
       </mrow>
      </munder>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <msubsup>
         <mi>x</mi>
         <mi>s</mi>
         <mo>′</mo>
        </msubsup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo maxsize="160%" minsize="160%">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝒰</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>e</ci>
     <apply>
      <eq></eq>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <in></in>
         <ci>e</ci>
         <ci>s</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}^{(m)}=\Big\{e:\prod_{s\ni e}(1-x^{\prime}_{s})=1\Big\}
  </annotation>
 </semantics>
</math>

 is the set of elements left uncovered at the end.</p>

<p>The random variable 

<math display="inline" id="Randomized_rounding:100">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 may appear a bit mysterious, but it mirrors the probabilistic proof in a systematic way. The first term in 

<math display="inline" id="Randomized_rounding:101">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 comes from applying <a href="Markov's_inequality" title="wikilink">Markov's inequality</a> to bound the probability of the first bad event (the cost is too high). It contributes at least 1 to 

<math display="inline" id="Randomized_rounding:102">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 if the cost of 

<math display="inline" id="Randomized_rounding:103">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 is too high. The second term counts the number of bad events of the second kind (uncovered elements). It contributes at least 1 to 

<math display="inline" id="Randomized_rounding:104">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Randomized_rounding:105">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 leaves any element uncovered. Thus, in any outcome where 

<math display="inline" id="Randomized_rounding:106">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is less than 1, 

<math display="inline" id="Randomized_rounding:107">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 must cover all the elements and have cost meeting the desired bound from the lemma. In short, if the rounding step fails, then 

<math display="inline" id="Randomized_rounding:108">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>F</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\geq 1
  </annotation>
 </semantics>
</math>

. This implies (by <a href="Markov's_inequality" title="wikilink">Markov's inequality</a>) that <em>

<math display="inline" id="Randomized_rounding:109">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F]
  </annotation>
 </semantics>
</math>

 is an upper bound on the probability of failure.</em> Note that the argument above is implicit already in the proof of the lemma, which also shows by calculation that 

<math display="inline" id="Randomized_rounding:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>F</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>F</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F]<1
  </annotation>
 </semantics>
</math>

.</p>

<p>To apply the method of conditional probabilities, we need to extend the argument to bound the <em>conditional</em> probability of failure as the rounding step proceeds. Usually, this can be done in a systematic way, although it can be technically tedious.</p>

<p>So, what about the <em>conditional</em> probability of failure as the rounding step iterates through the sets? Since 

<math display="inline" id="Randomized_rounding:111">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>F</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\geq 1
  </annotation>
 </semantics>
</math>

 in any outcome where the rounding step fails, by <a href="Markov's_inequality" title="wikilink">Markov's inequality</a>, the <em>conditional</em> probability of failure is at most the <em>conditional</em> expectation of 

<math display="inline" id="Randomized_rounding:112">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

.</p>

<p>Next we calculate the conditional expectation of 

<math display="inline" id="Randomized_rounding:113">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

, much as we calculated the unconditioned expectation of 

<math display="inline" id="Randomized_rounding:114">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 in the original proof. Consider the state of the rounding process at the end of some iteration 

<math display="inline" id="Randomized_rounding:115">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Randomized_rounding:116">
 <semantics>
  <msup>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{(t)}
  </annotation>
 </semantics>
</math>

 denote the sets considered so far (the first 

<math display="inline" id="Randomized_rounding:117">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 sets in 

<math display="inline" id="Randomized_rounding:118">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

). Let 

<math display="inline" id="Randomized_rounding:119">
 <semantics>
  <msup>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(t)}
  </annotation>
 </semantics>
</math>

 denote the (partially assigned) vector 

<math display="inline" id="Randomized_rounding:120">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 (so 

<math display="inline" id="Randomized_rounding:121">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(t)}_{s}
  </annotation>
 </semantics>
</math>

 is determined only if 

<math display="inline" id="Randomized_rounding:122">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <msup>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in S^{(t)}
  </annotation>
 </semantics>
</math>

). For each set 

<math display="inline" id="Randomized_rounding:123">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∉</mo>
   <msup>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\not\in S^{(t)}
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Randomized_rounding:124">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>s</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>λ</mi>
      <msubsup>
       <mi>x</mi>
       <mi>s</mi>
       <mo>*</mo>
      </msubsup>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <min></min>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
       <ci>s</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{s}=\min(\lambda x^{*}_{s},1)
  </annotation>
 </semantics>
</math>

 denote the probability with which 

<math display="inline" id="Randomized_rounding:125">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <mi>s</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s}
  </annotation>
 </semantics>
</math>

 will be set to 1. Let 

<math display="inline" id="Randomized_rounding:126">
 <semantics>
  <msup>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝒰</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}^{(t)}
  </annotation>
 </semantics>
</math>

 contain the not-yet-covered elements. Then the conditional expectation of 

<math display="inline" id="Randomized_rounding:127">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

, given the choices made so far, that is, given 

<math display="inline" id="Randomized_rounding:128">
 <semantics>
  <msup>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{(t)}
  </annotation>
 </semantics>
</math>

, is</p>

<p>

<math display="block" id="Randomized_rounding:129">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo rspace="5.8pt" stretchy="false">]</mo>
   </mrow>
   <mo rspace="5.8pt">=</mo>
   <mpadded width="+3.3pt">
    <mfrac>
     <mrow>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>s</mi>
         <mo>∈</mo>
         <msup>
          <mi>S</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msup>
        </mrow>
       </msub>
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <msubsup>
         <mi>x</mi>
         <mi>s</mi>
         <mo>′</mo>
        </msubsup>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>s</mi>
         <mo>∉</mo>
         <msup>
          <mi>S</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msup>
        </mrow>
       </msub>
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>p</mi>
         <mi>s</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>λ</mi>
       <mi>c</mi>
      </mrow>
      <mo>⋅</mo>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
     </mrow>
    </mfrac>
   </mpadded>
   <mo rspace="5.8pt">+</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>e</mi>
     <mo>∈</mo>
     <msup>
      <mi class="ltx_font_mathcaligraphic">𝒰</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
    </mrow>
   </munder>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mrow>
      <mi>s</mi>
      <mo>∉</mo>
      <msup>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>s</mi>
      <mo>∋</mo>
      <mi>e</mi>
     </mrow>
    </mrow>
   </munder>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>-</mo>
    <msub>
     <mi>p</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>s</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>S</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>c</ci>
        <ci>s</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <notin></notin>
         <ci>s</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>S</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>c</ci>
        <ci>s</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>λ</ci>
       <ci>c</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝒰</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <notin></notin>
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>S</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <ci>e</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F|x^{(t)}]~{}=~{}\frac{\sum_{s\in S^{(t)}}c(s)x^{\prime}_{s}+\sum_{s\not\in S%
^{(t)}}c(s)p_{s}}{2\lambda c\cdot x^{*}}~{}+~{}\sum_{e\in\mathcal{U}^{(t)}}%
\prod_{s\not\in S^{(t)},s\ni e}(1-p_{s}).
  </annotation>
 </semantics>
</math>

</p>

<p>Note that 

<math display="inline" id="Randomized_rounding:130">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F|x^{(t)}]
  </annotation>
 </semantics>
</math>

 is determined only after iteration 

<math display="inline" id="Randomized_rounding:131">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="keeping-the-conditional-probability-of-failure-below-1">Keeping the conditional probability of failure below 1</h4>

<p>To keep the conditional probability of failure below 1, it suffices to keep the conditional expectation of 

<math display="inline" id="Randomized_rounding:132">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 below 1. To do this, it suffices to keep the conditional expectation of 

<math display="inline" id="Randomized_rounding:133">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 from increasing. This is what the algorithm will do. It will set 

<math display="inline" id="Randomized_rounding:134">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <mi>s</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s}
  </annotation>
 </semantics>
</math>

 in each iteration to ensure that</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Randomized_rounding:135">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≤</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≤</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>≤</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≤</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <leq></leq>
    <ci>normal-⋯</ci>
    <leq></leq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <lt></lt>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F|x^{(m)}]\leq E[F|x^{(m-1)}]\leq\cdots\leq E[F|x^{(1)}]\leq E[F|x^{(0)}]<1
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>(where 

<math display="inline" id="Randomized_rounding:136">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi class="ltx_font_mathcaligraphic">𝒮</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <abs></abs>
     <ci>𝒮</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=|\mathcal{S}|
  </annotation>
 </semantics>
</math>

).</p>

<p>In the 

<math display="inline" id="Randomized_rounding:137">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

th iteration, how can the algorithm set 

<math display="inline" id="Randomized_rounding:138">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s^{\prime}}
  </annotation>
 </semantics>
</math>

 to ensure that 

<math display="inline" id="Randomized_rounding:139">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≤</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F|x^{(t)}]\leq E[F|S^{(t-1)}]
  </annotation>
 </semantics>
</math>

? It turns out that it can simply set 

<math display="inline" id="Randomized_rounding:140">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s^{\prime}}
  </annotation>
 </semantics>
</math>

 so as to <em>minimize</em> the resulting value of 

<math display="inline" id="Randomized_rounding:141">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F|x^{(t)}]
  </annotation>
 </semantics>
</math>

.</p>

<p>To see why, focus on the point in time when iteration 

<math display="inline" id="Randomized_rounding:142">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 starts. At that time, 

<math display="inline" id="Randomized_rounding:143">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F|x^{(t-1)}]
  </annotation>
 </semantics>
</math>

 is determined, but 

<math display="inline" id="Randomized_rounding:144">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F|x^{(t)}]
  </annotation>
 </semantics>
</math>

 is not yet determined --- it can take two possible values depending on how 

<math display="inline" id="Randomized_rounding:145">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s^{\prime}}
  </annotation>
 </semantics>
</math>

 is set in iteration 

<math display="inline" id="Randomized_rounding:146">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Randomized_rounding:147">
 <semantics>
  <msup>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>E</ci>
    <apply>
     <minus></minus>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{(t-1)}
  </annotation>
 </semantics>
</math>

 denote the value of 

<math display="inline" id="Randomized_rounding:148">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mi mathvariant="normal">′</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <list>
       <ci>normal-′</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F|x^{\prime(t-1)}]
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Randomized_rounding:149">
 <semantics>
  <msubsup>
   <mi>E</mi>
   <mn>0</mn>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>E</ci>
     <ci>t</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{(t)}_{0}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Randomized_rounding:150">
 <semantics>
  <msubsup>
   <mi>E</mi>
   <mn>1</mn>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>E</ci>
     <ci>t</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{(t)}_{1}
  </annotation>
 </semantics>
</math>

, denote the two possible values of 

<math display="inline" id="Randomized_rounding:151">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F|x^{(t)}]
  </annotation>
 </semantics>
</math>

, depending on whether 

<math display="inline" id="Randomized_rounding:152">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s^{\prime}}
  </annotation>
 </semantics>
</math>

 is set to 0, or 1, respectively. By the definition of conditional expectation,</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>E^{(t-1)} ~=~ \Pr[x'_{s'}=0] E^{(t)}_0 + \Pr[x'_{s'}=1] E^{(t)}_1.  Since a weighted average of two quantities is always at least the minimum of those two quantities, it follows that</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>E^{(t-1)} ~\ge~ \min( E^{(t)}_0, E^{(t)}_1 ).  Thus, setting 

<math display="inline" id="Randomized_rounding:153">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s^{\prime}}
  </annotation>
 </semantics>
</math>

 so as to minimize the resulting value of 

<math display="inline" id="Randomized_rounding:154">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F|x^{(t)}]
  </annotation>
 </semantics>
</math>

 will guarantee that 

<math display="inline" id="Randomized_rounding:155">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≤</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F|x^{(t)}]\leq E[F|x^{(t-1)}]
  </annotation>
 </semantics>
</math>

. This is what the algorithm will do.</p>

<p>In detail, what does this mean? Considered as a function of 

<math display="inline" id="Randomized_rounding:156">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s^{\prime}}
  </annotation>
 </semantics>
</math>

 (with all other quantities fixed) 

<math display="inline" id="Randomized_rounding:157">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>F</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F|x^{(t)}]
  </annotation>
 </semantics>
</math>

 is a linear function of 

<math display="inline" id="Randomized_rounding:158">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s^{\prime}}
  </annotation>
 </semantics>
</math>

, and the coefficient of 

<math display="inline" id="Randomized_rounding:159">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s^{\prime}}
  </annotation>
 </semantics>
</math>

 in that function is</p>

<p>

<math display="block" id="Randomized_rounding:160">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+3.3pt">
     <mfrac>
      <msub>
       <mi>c</mi>
       <msup>
        <mi>s</mi>
        <mo>′</mo>
       </msup>
      </msub>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mi>λ</mi>
        <mi>c</mi>
       </mrow>
       <mo>⋅</mo>
       <msup>
        <mi>x</mi>
        <mo>*</mo>
       </msup>
      </mrow>
     </mfrac>
    </mpadded>
    <mo rspace="5.8pt">-</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>e</mi>
       <mo>∈</mo>
       <mrow>
        <msup>
         <mi>s</mi>
         <mo>′</mo>
        </msup>
        <mo>∩</mo>
        <msub>
         <mi class="ltx_font_mathcaligraphic">𝒰</mi>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mrow>
         <mi>s</mi>
         <mo>∉</mo>
         <msup>
          <mi>S</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msup>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>s</mi>
         <mo>∋</mo>
         <mi>e</mi>
        </mrow>
       </mrow>
      </munder>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <msub>
         <mi>p</mi>
         <mi>s</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>λ</ci>
       <ci>c</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>e</ci>
       <apply>
        <intersect></intersect>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝒰</ci>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <notin></notin>
         <ci>s</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>S</ci>
          <ci>t</ci>
         </apply>
        </apply>
        <apply>
         <in></in>
         <ci>e</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{c_{s^{\prime}}}{2\lambda c\cdot x^{*}}~{}-~{}\sum_{e\in s^{\prime}\cap%
\mathcal{U}_{t-1}}\prod_{s\not\in S^{(t)},s\ni e}(1-p_{s}).
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, the algorithm should set 

<math display="inline" id="Randomized_rounding:161">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s^{\prime}}
  </annotation>
 </semantics>
</math>

 to 0 if this expression is positive, and 1 otherwise. This gives the following algorithm.</p>
<h3 id="randomized-rounding-algorithm-for-set-cover">Randomized-rounding algorithm for Set Cover</h3>

<p><strong>input:</strong> set system 

<math display="inline" id="Randomized_rounding:162">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

, universe 

<math display="inline" id="Randomized_rounding:163">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

, cost vector 

<math display="inline" id="Randomized_rounding:164">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

</p>

<p><strong>output:</strong> set cover 

<math display="inline" id="Randomized_rounding:165">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 (a solution to the standard integer linear program for set cover)</p>
<hr/>
<ol>
<li>Compute a min-cost fractional set cover 

<math display="inline" id="Randomized_rounding:166">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 (an optimal solution to the LP relaxation).</li>
<li>Let 

<math display="inline" id="Randomized_rounding:167">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>←</mo>
   <mrow>
    <mi>ln</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi class="ltx_font_mathcaligraphic">𝒰</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>λ</ci>
    <apply>
     <ln></ln>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <abs></abs>
       <ci>𝒰</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\leftarrow\ln(2|\mathcal{U}|)
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Randomized_rounding:168">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>s</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>λ</mi>
      <msubsup>
       <mi>x</mi>
       <mi>s</mi>
       <mo>*</mo>
      </msubsup>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <min></min>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
       <ci>s</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{s}\leftarrow\min(\lambda x^{*}_{s},1)
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Randomized_rounding:169">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in\mathcal{S}
  </annotation>
 </semantics>
</math>

.</li>
<li>For each 

<math display="inline" id="Randomized_rounding:170">
 <semantics>
  <mrow>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}\in\mathcal{S}
  </annotation>
 </semantics>
</math>

 do:
<ol>
<li>Let 

<math display="inline" id="Randomized_rounding:171">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   <mo>←</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒮</mi>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>𝒮</ci>
    <apply>
     <minus></minus>
     <ci>𝒮</ci>
     <set>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}\leftarrow\mathcal{S}-\{s^{\prime}\}
  </annotation>
 </semantics>
</math>

.   (

<math display="inline" id="Randomized_rounding:172">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 contains the not-yet-decided sets.)</li>
<li>If    <math></math></li>
</ol></li>
</ol>

<p>\frac{c_{s'}}{2\lambda c\cdot x^*} &gt; \sum_{e\in s'\cap\mathcal U} \prod_{s\in \mathcal S, s\ni e}(1-p_s) </p>

<p>##: then set 

<math display="inline" id="Randomized_rounding:173">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mi>s</mi>
    <mo>′</mo>
   </msubsup>
   <mo>←</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s}\leftarrow 0
  </annotation>
 </semantics>
</math>

,</p>

<p>##: else set 

<math display="inline" id="Randomized_rounding:174">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mi>s</mi>
    <mo>′</mo>
   </msubsup>
   <mo>←</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{s}\leftarrow 1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Randomized_rounding:175">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   <mo>←</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒰</mi>
    <mo>-</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>𝒰</ci>
    <apply>
     <minus></minus>
     <ci>𝒰</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}\leftarrow\mathcal{U}-s^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>##:   (

<math display="inline" id="Randomized_rounding:176">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

 contains the not-yet-covered elements.)</p>
<ol>
<li>Return 

<math display="inline" id="Randomized_rounding:177">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

.</li>
</ol>
<hr/>
<h4 id="lemma-approximation-guarantee-for-algorithm">lemma (approximation guarantee for algorithm)</h4>
<dl>
<dd><dl>
<dd><em>The algorithm above returns a set cover 

<math display="inline" id="Randomized_rounding:178">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 of cost at most 

<math display="inline" id="Randomized_rounding:179">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mrow>
    <mi>ln</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi class="ltx_font_mathcaligraphic">𝒰</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <ln></ln>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <abs></abs>
       <ci>𝒰</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\ln(2|\mathcal{U}|)
  </annotation>
 </semantics>
</math>

 times the minimum cost of any (fractional) set cover.</em>
</dd>
</dl>
</dd>
</dl>
<h4 id="proof-1">proof</h4>
<hr/>

<p>The algorithm ensures that the conditional expectation of 

<math display="inline" id="Randomized_rounding:180">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Randomized_rounding:181">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mpadded width="+1.7pt">
     <mi>F</mi>
    </mpadded>
    <mo rspace="4.2pt" stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[F\,|\,x^{(t)}]
  </annotation>
 </semantics>
</math>

, does not increase at each iteration. Since this conditional expectation is initially less than 1 (as shown previously), the algorithm ensures that the conditional expectation stays below 1. Since the conditional probability of failure is at most the conditional expectation of 

<math display="inline" id="Randomized_rounding:182">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

, in this way the algorithm ensures that the conditional probability of failure stays below 1. Thus, at the end, when all choices are determined, the algorithm reaches a successful outcome. That is, the algorithm above returns a set cover 

<math display="inline" id="Randomized_rounding:183">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 of cost at most 

<math display="inline" id="Randomized_rounding:184">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mrow>
    <mi>ln</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi class="ltx_font_mathcaligraphic">𝒰</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <ln></ln>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <abs></abs>
       <ci>𝒰</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\ln(2|\mathcal{U}|)
  </annotation>
 </semantics>
</math>

 times the minimum cost of any (fractional) set cover.</p>
<h3 id="remarks">Remarks</h3>

<p>In the example above, the algorithm was guided by the conditional expectation of a random variable 

<math display="inline" id="Randomized_rounding:185">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

. In some cases, instead of an exact conditional expectation, an <em>upper bound</em> (or sometimes a lower bound) on some conditional expectation is used instead. This is called a <a href="pessimistic_estimator" title="wikilink">pessimistic estimator</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Method_of_conditional_probabilities" title="wikilink">Method of conditional probabilities</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Algorithms" title="wikilink">Category:Algorithms</a> <a href="Category:Probabilistic_arguments" title="wikilink">Category:Probabilistic arguments</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
