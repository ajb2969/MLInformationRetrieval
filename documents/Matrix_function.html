<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="20">Matrix function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Matrix function</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>matrix function</strong> is a <a href="function_(mathematics)" title="wikilink">function</a> which maps a <a href="matrix_(mathematics)" title="wikilink">matrix</a> to another matrix.</p>
<h2 id="extending-scalar-function-to-matrix-functions">Extending scalar function to matrix functions</h2>

<p>There are several techniques for lifting a real function to a <a href="square_matrix" title="wikilink">square matrix</a> function such that interesting properties are maintained. All of the following techniques yield the same matrix function, but the domains on which the function are defined may differ.</p>
<h3 id="power-series">Power series</h3>

<p>If the real function 

<math display="inline" id="Matrix_function:0">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 has the <a href="Taylor_expansion" title="wikilink">Taylor expansion</a></p>

<p>

<math display="block" id="Matrix_function:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mfrac>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mn>2</mn>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mfrac>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>′′</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <factorial></factorial>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=f(0)+f^{\prime}(0)\cdot x+f^{\prime\prime}(0)\cdot\frac{x^{2}}{2!}+\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>then a matrix function can be defined by substituting 

<math display="inline" id="Matrix_function:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 by a matrix: the powers become <a href="Matrix_multiplication#Powers_of_matrices" title="wikilink">matrix powers</a>, the additions become matrix sums and the multiplications become scaling operations. If the real series converges for 

<math display="inline" id="Matrix_function:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x|<r
  </annotation>
 </semantics>
</math>

, then the corresponding matrix series will converge for matrix argument <em>A</em> if 

<math display="inline" id="Matrix_function:4">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mi>A</mi>
    <mo>∥</mo>
   </mrow>
   <mo><</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>A</ci>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|A\|<r
  </annotation>
 </semantics>
</math>

 for some <a href="matrix_norm" title="wikilink">matrix norm</a> 

<math display="inline" id="Matrix_function:5">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mo>⋅</mo>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">parallel-to</csymbol>
    <ci>normal-⋅</ci>
    <csymbol cd="latexml">parallel-to</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\cdot\|
  </annotation>
 </semantics>
</math>

 which satisfies 

<math display="inline" id="Matrix_function:6">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>A</mi>
     <mi>B</mi>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mi>A</mi>
     <mo>∥</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo>∥</mo>
     <mi>B</mi>
     <mo>∥</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|AB\|\leq\|A\|\cdot\|B\|
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="jordan-decomposition">Jordan decomposition</h3>

<p>If the matrix <em>A</em> is <a href="diagonalizable_matrix" title="wikilink">diagonalizable</a>, then we can find a matrix <em>P</em> and a <a href="diagonal_matrix" title="wikilink">diagonal matrix</a> <em>D</em> such that 

<math display="inline" id="Matrix_function:7">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mo>⋅</mo>
    <mi>D</mi>
    <mo>⋅</mo>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>P</ci>
     <ci>D</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=P\cdot D\cdot P^{-1}
  </annotation>
 </semantics>
</math>

. Applying the power series definition to this decomposition, we find that 

<math display="inline" id="Matrix_function:8">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(A)
  </annotation>
 </semantics>
</math>

 is defined by</p>

<p>

<math display="block" id="Matrix_function:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>d</mi>
            <mn>1</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">…</mi>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋮</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋱</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋮</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">…</mi>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>d</mi>
            <mi>n</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <msup>
      <mi>P</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
       <ci>normal-⋱</ci>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(A)=P\begin{bmatrix}f(d_{1})&\dots&0\\
\vdots&\ddots&\vdots\\
0&\dots&f(d_{n})\end{bmatrix}P^{-1},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Matrix_function:10">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>d</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{1},\dots,d_{n}
  </annotation>
 </semantics>
</math>

 denote the diagonal entries of <em>D</em>.</p>

<p>All matrices, whether they are diagonalizable or not, have a <a href="Jordan_normal_form" title="wikilink">Jordan normal form</a> 

<math display="inline" id="Matrix_function:11">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mo>⋅</mo>
    <mi>J</mi>
    <mo>⋅</mo>
    <msup>
     <mi>P</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>P</ci>
     <ci>J</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=P\cdot J\cdot P^{-1}
  </annotation>
 </semantics>
</math>

, where the matrix <em>J</em> consists of <a href="Jordan_block" title="wikilink">Jordan blocks</a>. Consider these blocks separately and apply the power series to a Jordan block:</p>

<p>

<math display="block" id="Matrix_function:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mi>λ</mi>
         </mtd>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">…</mi>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mi>λ</mi>
         </mtd>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋱</mi>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋱</mi>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">…</mi>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋱</mi>
         </mtd>
         <mtd columnalign="center">
          <mi>λ</mi>
         </mtd>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">…</mi>
         </mtd>
         <mtd columnalign="center">
          <mi mathvariant="normal">…</mi>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
         <mtd columnalign="center">
          <mi>λ</mi>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mstyle displaystyle="false">
         <mfrac>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mn>0</mn>
           <mo lspace="0pt" rspace="3.5pt">!</mo>
          </mrow>
         </mfrac>
        </mstyle>
       </mtd>
       <mtd columnalign="center">
        <mstyle displaystyle="false">
         <mfrac>
          <mrow>
           <msup>
            <mi>f</mi>
            <mo>′</mo>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mn>1</mn>
           <mo lspace="0pt" rspace="3.5pt">!</mo>
          </mrow>
         </mfrac>
        </mstyle>
       </mtd>
       <mtd columnalign="center">
        <mstyle displaystyle="false">
         <mfrac>
          <mrow>
           <msup>
            <mi>f</mi>
            <mi>′′</mi>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mn>2</mn>
           <mo lspace="0pt" rspace="3.5pt">!</mo>
          </mrow>
         </mfrac>
        </mstyle>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">…</mi>
       </mtd>
       <mtd columnalign="center">
        <mstyle displaystyle="false">
         <mfrac>
          <mrow>
           <msup>
            <mi>f</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>n</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mi>n</mi>
           <mo lspace="0pt" rspace="3.5pt">!</mo>
          </mrow>
         </mfrac>
        </mstyle>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mstyle displaystyle="false">
         <mfrac>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mn>0</mn>
           <mo lspace="0pt" rspace="3.5pt">!</mo>
          </mrow>
         </mfrac>
        </mstyle>
       </mtd>
       <mtd columnalign="center">
        <mstyle displaystyle="false">
         <mfrac>
          <mrow>
           <msup>
            <mi>f</mi>
            <mo>′</mo>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mn>1</mn>
           <mo lspace="0pt" rspace="3.5pt">!</mo>
          </mrow>
         </mfrac>
        </mstyle>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
       <mtd columnalign="center">
        <mstyle displaystyle="false">
         <mfrac>
          <mrow>
           <msup>
            <mi>f</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>n</mi>
              <mo>-</mo>
              <mn>1</mn>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>n</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo lspace="0pt" rspace="3.5pt">!</mo>
          </mrow>
         </mfrac>
        </mstyle>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋱</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋱</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">…</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋱</mi>
       </mtd>
       <mtd columnalign="center">
        <mstyle displaystyle="false">
         <mfrac>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mn>0</mn>
           <mo lspace="0pt" rspace="3.5pt">!</mo>
          </mrow>
         </mfrac>
        </mstyle>
       </mtd>
       <mtd columnalign="center">
        <mstyle displaystyle="false">
         <mfrac>
          <mrow>
           <msup>
            <mi>f</mi>
            <mo>′</mo>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mn>1</mn>
           <mo lspace="0pt" rspace="3.5pt">!</mo>
          </mrow>
         </mfrac>
        </mstyle>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">…</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">…</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mstyle displaystyle="false">
         <mfrac>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <mn>0</mn>
           <mo lspace="0pt" rspace="3.5pt">!</mo>
          </mrow>
         </mfrac>
        </mstyle>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <matrix>
      <matrixrow>
       <ci>λ</ci>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <ci>normal-…</ci>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <ci>λ</ci>
       <cn type="integer">1</cn>
       <ci>normal-⋮</ci>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <ci>normal-⋱</ci>
       <ci>normal-⋱</ci>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
       <ci>normal-…</ci>
       <ci>normal-⋱</ci>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <ci>normal-…</ci>
       <ci>normal-…</ci>
       <cn type="integer">0</cn>
       <ci>λ</ci>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>λ</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>λ</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>′′</ci>
        </apply>
        <ci>λ</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>n</ci>
        </apply>
        <ci>λ</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <ci>n</ci>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>λ</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>λ</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⋮</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>λ</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <ci>normal-⋱</ci>
      <ci>normal-⋱</ci>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
      <ci>normal-…</ci>
      <ci>normal-⋱</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>λ</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>λ</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <ci>normal-…</ci>
      <cn type="integer">0</cn>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>λ</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\left(\begin{bmatrix}\lambda&1&0&\ldots&0\\
0&\lambda&1&\vdots&\vdots\\
0&0&\ddots&\ddots&\vdots\\
\vdots&\ldots&\ddots&\lambda&1\\
0&\ldots&\ldots&0&\lambda\end{bmatrix}\right)=\par
\begin{bmatrix}\frac{f(%
\lambda)}{0!}&\frac{f^{\prime}(\lambda)}{1!}&\frac{f^{\prime\prime}(\lambda)}{%
2!}&\ldots&\frac{f^{(n)}(\lambda)}{n!}\\
0&\frac{f(\lambda)}{0!}&\frac{f^{\prime}(\lambda)}{1!}&\vdots&\frac{f^{(n-1)}(%
\lambda)}{(n-1)!}\\
0&0&\ddots&\ddots&\vdots\\
\vdots&\ldots&\ddots&\frac{f(\lambda)}{0!}&\frac{f^{\prime}(\lambda)}{1!}\\
0&\ldots&\ldots&0&\frac{f(\lambda)}{0!}\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>This definition can be used to extend the domain of the matrix function beyond the set of matrices with spectral radius smaller than the radius of convergence of the power series. Note that there is also a connection to <a href="Divided_difference#Polynomials_and_power_series" title="wikilink">divided differences</a>.</p>

<p>A related notion is the <a href="Jordan–Chevalley_decomposition" title="wikilink">Jordan–Chevalley decomposition</a> which expresses a matrix as a sum of a diagonalizable and a nilpotent part.</p>
<h4 id="hermitian-matrices">Hermitian matrices</h4>

<p>A <a href="Hermitian_matrix" title="wikilink">Hermitian matrix</a> has all real eigenvalues and can always be diagonalized by a <a href="unitary_matrix" title="wikilink">unitary matrix</a> P, according to the <a href="spectral_theorem" title="wikilink">spectral theorem</a>. In this case, the Jordan definition is natural. Moreover, this definition allows one to extend standard inequalities for real functions:</p>

<p>If 

<math display="inline" id="Matrix_function:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a)\leq g(a)
  </annotation>
 </semantics>
</math>

 for all eigenvalues of 

<math display="inline" id="Matrix_function:14">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Matrix_function:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⪯</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">precedes-or-equals</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(A)\preceq g(A)
  </annotation>
 </semantics>
</math>

. (As a convention, 

<math display="inline" id="Matrix_function:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>⪯</mo>
    <mi>Y</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi>Y</mi>
    <mo>-</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <csymbol cd="latexml">precedes-or-equals</csymbol>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>Y</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\preceq Y\Leftrightarrow Y-X
  </annotation>
 </semantics>
</math>


 is a <a href="positive-semidefinite_matrix" title="wikilink">positive-semidefinite matrix</a>.) The proof follows directly from the definition.</p>
<h3 id="cauchy-integral">Cauchy integral</h3>

<p><a href="Cauchy's_integral_formula" title="wikilink">Cauchy's integral formula</a> from <a href="complex_analysis" title="wikilink">complex analysis</a> can also be used to generalize scalar functions to matrix functions. Cauchy's integral formula states that for any <a href="analytic_function" title="wikilink">analytic function</a> <em>f</em> defined on a set <em>D</em>⊂ℂ, it holds</p>

<p>

<math display="block" id="Matrix_function:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∮</mo>
      <mi>C</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>z</mi>
         <mo>-</mo>
         <mi>x</mi>
        </mrow>
       </mfrac>
      </mpadded>
      <mi mathvariant="normal">d</mi>
      <mi>z</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">contour-integral</csymbol>
       <ci>C</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>z</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>z</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>normal-d</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\frac{1}{2\pi i}\oint_{C}{\frac{f(z)}{z-x}}\,\mathrm{d}z
  </annotation>
 </semantics>
</math>

,</p>

<p>where <em>C</em> is a closed curve inside the domain <em>D</em> enclosing <em>x</em>. Now replace <em>x</em> by a matrix <em>A</em> and consider a path <em>C</em> inside <em>D</em> that encloses all <a href="eigenvalue" title="wikilink">eigenvalues</a> of <em>A</em>. One possibility to achieve this is to let <em>C</em> be a circle around the <a href="origin_(mathematics)" title="wikilink">origin</a> with <a class="uri" href="radius" title="wikilink">radius</a> larger than 

<math display="inline" id="Matrix_function:18">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mi>A</mi>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\|A\|
  </annotation>
 </semantics>
</math>

 for an arbitrary <a href="matrix_norm" title="wikilink">matrix norm</a> 

<math display="inline" id="Matrix_function:19">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mo>⋅</mo>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">parallel-to</csymbol>
    <ci>normal-⋅</ci>
    <csymbol cd="latexml">parallel-to</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\|\cdot\|
  </annotation>
 </semantics>
</math>

. Then, 

<math display="inline" id="Matrix_function:20">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(A)
  </annotation>
 </semantics>
</math>

 is defined by</p>

<p>

<math display="block" id="Matrix_function:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>i</mi>
      </mrow>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∮</mo>
       <mi>C</mi>
      </msub>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mpadded width="+1.7pt">
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <mi>z</mi>
            <mi>I</mi>
           </mrow>
           <mo>-</mo>
           <mi>A</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mpadded>
       <mi mathvariant="normal">d</mi>
       <mi>z</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">contour-integral</csymbol>
       <ci>C</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>z</ci>
          <ci>I</ci>
         </apply>
         <ci>A</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-d</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(A)=\frac{1}{2\pi i}\oint_{C}{f(z)(zI-A)^{-1}}\,\mathrm{d}z.
  </annotation>
 </semantics>
</math>

</p>

<p>This integral can readily be evaluated numerically using the <a href="trapezium_rule" title="wikilink">trapezium rule</a>, which <a href="Convergent_series" title="wikilink">converges</a> exponentially in this case. That means that the <a href="precision_(arithmetic)" title="wikilink">precision</a> of the result doubles when the number of nodes is doubled.</p>

<p>This idea applied to <a href="bounded_linear_operator" title="wikilink">bounded linear operators</a> on a <a href="Banach_space" title="wikilink">Banach space</a>, which can be seen as infinite matrices, leads to the <a href="holomorphic_functional_calculus" title="wikilink">holomorphic functional calculus</a>.</p>
<h3 id="matrix-perturbations">Matrix perturbations</h3>

<p>The above Taylor power series allows the scalar 

<math display="inline" id="Matrix_function:22">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to be replaced by the matrix. This is not true in general when expanding in terms of 

<math display="inline" id="Matrix_function:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>η</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mrow>
     <mi>η</mi>
     <mi>B</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>η</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>η</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(\eta)=A+\eta B
  </annotation>
 </semantics>
</math>

 about 

<math display="inline" id="Matrix_function:24">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>η</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta=0
  </annotation>
 </semantics>
</math>

 unless 

<math display="inline" id="Matrix_function:25">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="closed">
     <ci>A</ci>
     <ci>B</ci>
    </interval>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [A,B]=0
  </annotation>
 </semantics>
</math>

. A counter example is 

<math display="inline" id="Matrix_function:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>x</mi>
    <mn>3</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{3}
  </annotation>
 </semantics>
</math>


, which has a finite length Taylor series. We compute this in two ways,</p>
<ul>
<li>Brute force :</li>
</ul>

<p>

<math display="block" id="Matrix_function:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mrow>
       <mi>η</mi>
       <mi>B</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mrow>
       <mi>η</mi>
       <mi>B</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>3</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>A</mi>
         <mn>2</mn>
        </msup>
        <mi>B</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>A</mi>
        <mi>B</mi>
        <mi>A</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>B</mi>
        <msup>
         <mi>A</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>η</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>A</mi>
        <msup>
         <mi>B</mi>
         <mn>2</mn>
        </msup>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>B</mi>
        <mi>A</mi>
        <mi>B</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msup>
         <mi>B</mi>
         <mn>2</mn>
        </msup>
        <mi>A</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>η</mi>
      <mn>3</mn>
     </msup>
     <msup>
      <mi>B</mi>
      <mn>3</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>A</ci>
       <apply>
        <times></times>
        <ci>η</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>A</ci>
       <apply>
        <times></times>
        <ci>η</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <ci>η</ci>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>A</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>B</ci>
        </apply>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>B</ci>
         <ci>A</ci>
        </apply>
        <apply>
         <times></times>
         <ci>B</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>A</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>η</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>A</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>B</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>A</ci>
         <ci>B</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>B</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>η</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(A+\eta B)=(A+\eta B)^{3}=A^{3}+\eta(A^{2}B+ABA+BA^{2})+\eta^{2}(AB^{2}+BAB+B%
^{2}A)+\eta^{3}B^{3}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>Using scalar Taylor expansion for 

<math display="inline" id="Matrix_function:28">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>a</mi>
     <mo>+</mo>
     <mrow>
      <mi>η</mi>
      <mi>b</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>η</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a+\eta b)
  </annotation>
 </semantics>
</math>

 and replacing scalars with matrices at the end :</li>
</ul>

<p>

<math display="block" id="Matrix_function:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>+</mo>
      <mrow>
       <mi>η</mi>
       <mi>b</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mrow>
       <mi>η</mi>
       <mi>b</mi>
      </mrow>
      <mrow>
       <mn>1</mn>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mfrac>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>f</mi>
      <mi>′′</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>η</mi>
         <mi>b</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mrow>
       <mn>2</mn>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mfrac>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>f</mi>
      <mi>′′′</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>η</mi>
         <mi>b</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>3</mn>
      </msup>
      <mrow>
       <mn>3</mn>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mn>3</mn>
     <msup>
      <mi>a</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>η</mi>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>3</mn>
     <mi>a</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>η</mi>
        <mi>b</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>η</mi>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>3</mn>
    </msup>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mn>3</mn>
     <msup>
      <mi>A</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>η</mi>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>3</mn>
     <mi>A</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>η</mi>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>η</mi>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>3</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>η</ci>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>a</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>η</ci>
         <ci>b</ci>
        </apply>
        <apply>
         <factorial></factorial>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>′′</ci>
       </apply>
       <ci>a</ci>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <times></times>
          <ci>η</ci>
          <ci>b</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <factorial></factorial>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>′′′</ci>
       </apply>
       <ci>a</ci>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <times></times>
          <ci>η</ci>
          <ci>b</ci>
         </apply>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <factorial></factorial>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <ci>η</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <ci>η</ci>
         <ci>b</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>η</ci>
        <ci>b</ci>
       </apply>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <ci>η</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <ci>η</ci>
         <ci>B</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>η</ci>
        <ci>B</ci>
       </apply>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a+\eta b)=f(a)+f^{\prime}(a)\frac{\eta b}{1!}+f^{\prime\prime}(a)\frac{(\eta
b%
)^{2}}{2!}+f^{\prime\prime\prime}(a)\frac{(\eta b)^{3}}{3!}=a^{3}+3a^{2}(\eta b%
)+3a(\eta b)^{2}+(\eta b)^{3}\to A^{3}+3A^{2}(\eta B)+3A(\eta B)^{2}+(\eta B)^%
{3}
  </annotation>
 </semantics>
</math>

</p>

<p>The scalar expression assumes commutativity while the matrix expression does not and thus they cannot be equated directly unless 

<math display="inline" id="Matrix_function:30">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="closed">
     <ci>A</ci>
     <ci>B</ci>
    </interval>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [A,B]=0
  </annotation>
 </semantics>
</math>

. For some f(x) this can be dealt with using the same method as scalar Taylor series. For example, 

<math display="inline" id="Matrix_function:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>x</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\frac{1}{x}
  </annotation>
 </semantics>
</math>


. If 

<math display="inline" id="Matrix_function:32">
 <semantics>
  <msup>
   <mi>A</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{-1}
  </annotation>
 </semantics>
</math>

 exists then 

<math display="inline" id="Matrix_function:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mrow>
       <mi>η</mi>
       <mi>B</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝕀</mi>
      <mo>+</mo>
      <mrow>
       <mi>η</mi>
       <msup>
        <mi>A</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mi>B</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>η</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <ci>𝕀</ci>
      <apply>
       <times></times>
       <ci>η</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>B</ci>
      </apply>
     </apply>
     <ci>f</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(A+\eta B)=f(\mathbb{I}+\eta A^{-1}B)f(A)
  </annotation>
 </semantics>
</math>

. The expansion of the first term then follows the power series given above,</p>

<p>

<math display="block" id="Matrix_function:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝕀</mi>
      <mo>+</mo>
      <mrow>
       <mi>η</mi>
       <msup>
        <mi>A</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mi>B</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>𝕀</mi>
     <mo>-</mo>
     <mrow>
      <mi>η</mi>
      <msup>
       <mi>A</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>B</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>η</mi>
        <msup>
         <mi>A</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mi>B</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>η</mi>
        <msup>
         <mi>A</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mi>B</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>𝕀</ci>
       <apply>
        <times></times>
        <ci>η</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>𝕀</ci>
       <apply>
        <times></times>
        <ci>η</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>η</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>A</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>B</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>η</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>A</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>B</ci>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\mathbb{I}+\eta A^{-1}B)=\mathbb{I}-\eta A^{-1}B+(-\eta A^{-1}B)^{2}+\ldots=%
\sum_{n=0}^{\infty}(-\eta A^{-1}B)^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>The convergence criteria of the power series then apply, requiring 

<math display="inline" id="Matrix_function:35">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mrow>
    <mi>η</mi>
    <msup>
     <mi>A</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>B</mi>
   </mrow>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <apply>
     <times></times>
     <ci>η</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\eta A^{-1}B\|
  </annotation>
 </semantics>
</math>

 to be sufficiently small under the appropriate matrix norm. For more general problems, which cannot be rewritten in such a way that the two matrices commute, the ordering of matrix products produced by repeated application of the Leibniz rule must be tracked.</p>
<h3 id="examples">Examples</h3>
<ul>
<li><a href="Algebraic_Riccati_equation" title="wikilink">Algebraic Riccati equation</a></li>
<li><a href="Cayley–Hamilton_theorem" title="wikilink">Matrix polynomial</a></li>
<li><a href="Square_root_of_a_matrix" title="wikilink">Matrix root</a></li>
<li><a href="Matrix_logarithm" title="wikilink">Matrix logarithm</a></li>
<li><a href="Matrix_exponential" title="wikilink">Matrix exponential</a></li>
</ul>
<h2 id="classes-of-matrix-functions">Classes of matrix functions</h2>

<p>Using the semidefinite ordering (

<math display="inline" id="Matrix_function:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>⪯</mo>
    <mi>Y</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi>Y</mi>
    <mo>-</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <csymbol cd="latexml">precedes-or-equals</csymbol>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>Y</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\preceq Y\Leftrightarrow Y-X
  </annotation>
 </semantics>
</math>


 is <a href="positive-semidefinite_matrix" title="wikilink">positive-semidefinite</a> and 

<math display="inline" id="Matrix_function:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>≺</mo>
    <mi>Y</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi>Y</mi>
    <mo>-</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <csymbol cd="latexml">precedes</csymbol>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>Y</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\prec Y\Leftrightarrow Y-X
  </annotation>
 </semantics>
</math>

 is <a href="positive-definite_matrix" title="wikilink">positive definite</a>), some of the classes of scalar functions can be extended to matrix functions of <a href="Hermitian_matrix" title="wikilink">Hermitian matrices</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="operator-monotone">Operator monotone</h3>

<p>A function 

<math display="inline" id="Matrix_function:38">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is called operator monotone if and only if</p>
<dl>
<dd>
</dd>
</dl>

<p>

<math display="inline" id="Matrix_function:39">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≺</mo>
   <mi>A</mi>
   <mo>⪯</mo>
   <mi>H</mi>
   <mo>⇒</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⪯</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">precedes</csymbol>
     <cn type="integer">0</cn>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">precedes-or-equals</csymbol>
     <share href="#.cmml">
     </share>
     <ci>H</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">precedes-or-equals</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>H</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\prec A\preceq H\Rightarrow f(A)\preceq f(H)
  </annotation>
 </semantics>
</math>

 for all self-adjoint matrices 

<math display="inline" id="Matrix_function:40">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>,</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>A</ci>
    <ci>H</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,H
  </annotation>
 </semantics>
</math>

 with spectra in the domain of f. This is analogous to <a href="monotonic_function" title="wikilink">monotone function</a> in the scalar case.</p>
<h3 id="operator-concaveconvex">Operator concave/convex</h3>

<p>A function 

<math display="inline" id="Matrix_function:41">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


 is called operator concave if and only if</p>

<p>

<math display="block" id="Matrix_function:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>τ</mi>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>τ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⪯</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi>τ</mi>
       <mi>A</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>τ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>H</mi>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">precedes-or-equals</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>τ</ci>
      <ci>f</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>τ</ci>
      </apply>
      <ci>f</ci>
      <ci>H</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>τ</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>τ</ci>
       </apply>
       <ci>H</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau f(A)+(1-\tau)f(H)\preceq f\left(\tau A+(1-\tau)H\right)
  </annotation>
 </semantics>
</math>

 for all self-adjoint matrices 

<math display="inline" id="Matrix_function:43">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>,</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>A</ci>
    <ci>H</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,H
  </annotation>
 </semantics>
</math>

 with spectra in the domain of f and 

<math display="inline" id="Matrix_function:44">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>τ</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau\in[0,1]
  </annotation>
 </semantics>
</math>

. This definition is analogous to a <a href="concave_function" title="wikilink">concave scalar function</a>. An operator convex function can be defined be switching 

<math display="inline" id="Matrix_function:45">
 <semantics>
  <mo>⪯</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">precedes-or-equals</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \preceq
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Matrix_function:46">
 <semantics>
  <mo>⪰</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">succeeds-or-equals</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \succeq
  </annotation>
 </semantics>
</math>


 in the definition above.</p>
<h3 id="examples-1">Examples</h3>

<p>The matrix log is both operator monotone and operator concave. The matrix square is operator convex. The matrix exponential is none of these. <strong>Loewner's Theorem</strong> states that a function on an <em>open</em> interval is operator monotone if and only if it has an analytic extension to the upper and lower complex half planes so that the upper half plane is mapped to itself.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Sylvester's_formula" title="wikilink">Sylvester's formula</a></li>
<li><a href="Matrix_calculus" title="wikilink">Matrix calculus</a></li>
<li><a href="Trace_inequalities" title="wikilink">Trace inequalities</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Matrix_theory" title="wikilink">Category:Matrix theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
</ol>
</section>
</body>
</html>
