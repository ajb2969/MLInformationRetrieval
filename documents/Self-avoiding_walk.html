<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1390">Self-avoiding walk</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Self-avoiding walk</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Self avoiding walk.svg</figcaption>
</figure>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>self-avoiding walk</strong> (<strong>SAW</strong>) is a <a class="uri" href="sequence" title="wikilink">sequence</a> of moves on a <a href="lattice_(group)" title="wikilink">lattice</a> (a <a href="lattice_path" title="wikilink">lattice path</a>) that does not visit the same point more than once. This is a special case of the <a href="graph_(mathematics)" title="wikilink">graph theoretical</a> notion of a <a href="Path_(graph_theory)" title="wikilink">path</a>. A <strong>self-avoiding polygon</strong> (<strong>SAP</strong>) is a closed self-avoiding walk on a lattice. SAWs were first introduced by the chemist <a href="Paul_Flory" title="wikilink">Paul Flory</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in order to model the real-life behavior of chain-like entities such as <a href="solvent" title="wikilink">solvents</a> and <a href="polymer" title="wikilink">polymers</a>, whose physical volume prohibits multiple occupation of the same spatial point. Very little is known rigorously about the self-avoiding walk from a mathematical perspective, although physicists have provided numerous conjectures that are believed to be true and are strongly supported by numerical simulations.</p>

<p>In <a href="computational_physics" title="wikilink">computational physics</a> a self-avoiding walk is a chain-like path in <mtpl></mtpl> or <mtpl></mtpl> with a certain number of nodes, typically a fixed step length and has the imperative property that it doesn't cross itself or another walk. A system of self-avoiding walks satisfies the so-called <a href="excluded_volume" title="wikilink">excluded volume</a> condition. In higher dimensions, the self-avoiding walk is believed to behave much like the ordinary <a href="random_walk" title="wikilink">random walk</a>. SAWs and SAPs play a central role in the modelling of the <a href="topology" title="wikilink">topological</a> and <a href="knot_theory" title="wikilink">knot-theoretic</a> behaviour of thread- and loop-like molecules such as <a href="protein" title="wikilink">proteins</a>. SAW is a <a class="uri" href="fractal" title="wikilink">fractal</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> For example, in 

<math display="inline" id="Self-avoiding_walk:0">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=2
  </annotation>
 </semantics>
</math>

 the <a href="fractal_dimension" title="wikilink">fractal dimension</a> is 

<math display="inline" id="Self-avoiding_walk:1">
 <semantics>
  <mfrac>
   <mn>4</mn>
   <mn>3</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">4</cn>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{4}{3}
  </annotation>
 </semantics>
</math>

, for 

<math display="inline" id="Self-avoiding_walk:2">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=3
  </annotation>
 </semantics>
</math>

 it is close to 

<math display="inline" id="Self-avoiding_walk:3">
 <semantics>
  <mfrac>
   <mn>5</mn>
   <mn>3</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">5</cn>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{5}{3}
  </annotation>
 </semantics>
</math>

 while for 

<math display="inline" id="Self-avoiding_walk:4">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi mathvariant="normal">≥</mi>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>normal-≥</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d≥4
  </annotation>
 </semantics>
</math>

 the fractal dimension is 

<math display="inline" id="Self-avoiding_walk:5">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

. The dimension is called the upper <a href="critical_dimension" title="wikilink">critical dimension</a> above which excluded volume is negligible. A SAW that does not satisfy the excluded volume condition was recently studied to model explicit surface geometry resulting from expansion of a SAW.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The properties of SAWs cannot be calculated analytically, so numerical <a href="simulation" title="wikilink">simulations</a> are employed. The <a href="pivot_algorithm" title="wikilink">pivot algorithm</a> is a common method for <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a> simulations for the uniform measure on 

<math display="inline" id="Self-avoiding_walk:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-step self-avoiding walks. The pivot algorithm works by taking a self-avoiding walk and randomly choosing a point on this walk, and then applying a symmetry operation (rotations and reflections) on the walk after the nth step to create a new walk. Calculating the number of self-avoiding walks in any given lattice is a common computational problem. There is currently no known formula for determining the number of self-avoiding walks, although there are rigorous methods for approximating them.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Finding the number of such paths is <a href="mathematical_conjecture" title="wikilink">conjectured</a> to be an <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> problem. For self-avoiding walks from one end of a diagonal to the other, with only moves in the positive direction, there are exactly</p>

<p>

<math display="block" id="Self-avoiding_walk:7">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable columnspacing="0.4em" rowspacing="0.2ex">
    <mtr>
     <mtd>
      <mrow>
       <mi>m</mi>
       <mo>+</mo>
       <mi>n</mi>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd>
      <mrow>
       <mi>m</mi>
       <mo>,</mo>
       <mi>n</mi>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">binomial</csymbol>
    <apply>
     <plus></plus>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
    <list>
     <ci>m</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {m+n\choose m,n}
  </annotation>
 </semantics>
</math>

</p>

<p>paths for an 

<math display="inline" id="Self-avoiding_walk:8">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×n
  </annotation>
 </semantics>
</math>

 rectangular lattice.</p>
<h2 id="universality">Universality</h2>

<p>One of the phenomena associated with self-avoiding walks and 

<math display="inline" id="Self-avoiding_walk:9">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

-dimensional statistical physics models in general is the notion of universality, that is, independence of macroscopic observables from microscopic details, such as the choice of the lattice. One important quantity that appears in conjectures for universal laws is the <a href="connective_constant" title="wikilink">connective constant</a>, defined as follows. Let <mtpl></mtpl> denote the number of 

<math display="inline" id="Self-avoiding_walk:10">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-step self-avoiding walks. Since every 

<math display="inline" id="Self-avoiding_walk:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mi>m</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n+m)
  </annotation>
 </semantics>
</math>

-step self avoiding walk can be decomposed into an 

<math display="inline" id="Self-avoiding_walk:12">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-step self-avoiding walk and an 

<math display="inline" id="Self-avoiding_walk:13">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-step self-avoiding walk, it follows that <mtpl></mtpl>. Therefore the sequence  is <a href="Subadditivity" title="wikilink">subadditive</a> and we can apply <a href="Fekete's_lemma" title="wikilink">Fekete's lemma</a> to show that the following limit exists:</p>

<p>

<math display="block" id="Self-avoiding_walk:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">lim</mo>
      <mrow>
       <mi>n</mi>
       <mo>→</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </munder>
     <msubsup>
      <mi>c</mi>
      <mi>n</mi>
      <mfrac>
       <mn>1</mn>
       <mi>n</mi>
      </mfrac>
     </msubsup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>μ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu=\lim_{n\to\infty}c_{n}^{\frac{1}{n}}.
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Self-avoiding_walk:15">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   μ
  </annotation>
 </semantics>
</math>

 is called the <strong>connective constant</strong>, since <mtpl></mtpl> depends on the particular lattice chosen for the walk so does 

<math display="inline" id="Self-avoiding_walk:16">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   μ
  </annotation>
 </semantics>
</math>

. The exact value of 

<math display="inline" id="Self-avoiding_walk:17">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   μ
  </annotation>
 </semantics>
</math>

 is only known for the hexagonal lattice, where it is equal to:<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>

<math display="block" id="Self-avoiding_walk:18">
 <semantics>
  <mrow>
   <msqrt>
    <mrow>
     <mn>2</mn>
     <mo>+</mo>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mrow>
   </msqrt>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <plus></plus>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{2+\sqrt{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>For other lattices, 

<math display="inline" id="Self-avoiding_walk:19">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   μ
  </annotation>
 </semantics>
</math>

 has only been approximated numerically, and is believed to not even be an <a href="algebraic_number" title="wikilink">algebraic number</a>. It is conjectured that</p>

<p>

<math display="block" id="Self-avoiding_walk:20">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>n</mi>
   </msub>
   <mo>≈</mo>
   <mrow>
    <msup>
     <mi>μ</mi>
     <mi>n</mi>
    </msup>
    <msup>
     <mi>n</mi>
     <mfrac>
      <mn>11</mn>
      <mn>32</mn>
     </mfrac>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>μ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <cn type="integer">11</cn>
       <cn type="integer">32</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{n}\approx\mu^{n}n^{\frac{11}{32}}
  </annotation>
 </semantics>
</math>

</p>

<p>as 

<math display="inline" id="Self-avoiding_walk:21">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">→</mi>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-→</ci>
    <ci>normal-∞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n→∞
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Self-avoiding_walk:22">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   μ
  </annotation>
 </semantics>
</math>

 depends on the lattice, but the power law correction 

<math display="inline" id="Self-avoiding_walk:23">
 <semantics>
  <msup>
   <mi>n</mi>
   <mfrac>
    <mn>11</mn>
    <mn>32</mn>
   </mfrac>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <divide></divide>
     <cn type="integer">11</cn>
     <cn type="integer">32</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{\frac{11}{32}}
  </annotation>
 </semantics>
</math>

 does not; in other words, this law is believed to be universal.</p>
<h2 id="limits">Limits</h2>

<p>Consider the uniform measure on 

<math display="inline" id="Self-avoiding_walk:24">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-step self-avoiding walks in the full plane. It is currently unknown whether the limit of the uniform measure as 

<math display="inline" id="Self-avoiding_walk:25">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">→</mi>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-→</ci>
    <ci>normal-∞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n→∞
  </annotation>
 </semantics>
</math>

 induces a measure on infinite full-plane walks. However, <a href="Harry_Kesten" title="wikilink">Harry Kesten</a> has shown that such a measure exists for self-avoiding walks in the half-plane. One important question involving self-avoiding walks is the existence and conformal invariance of the <a href="scaling_limit" title="wikilink">scaling limit</a>, that is, the limit as the length of the walk goes to infinity and the mesh of the lattice goes to zero. The scaling limit of the self-avoiding walk is conjectured to be described by <a href="Schramm–Loewner_evolution" title="wikilink">Schramm–Loewner evolution</a> with parameter 

<math display="inline" id="Self-avoiding_walk:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>κ</mi>
    <mo>=</mo>
    <mfrac>
     <mn>8</mn>
     <mn>3</mn>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>κ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">8</cn>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   κ=\frac{8}{3}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="self-avoiding-walks-in-popular-culture">Self-avoiding walks in popular culture</h2>

<p>The <a href="computer_video_game" title="wikilink">computer video game</a> <a href="Snake_(video_game)" title="wikilink">Snake</a> is an example of a self-avoiding walk.</p>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ol>
<li></li>
<li></li>
<li></li>
<li></li>
</ol>
<h2 id="external-links">External links</h2>
<ul>
<li>
<dl>
<dd>the number of self-avoiding paths joining opposite corners of an <em>N</em> × <em>N</em> grid, for <em>N</em> from 0 to 12. Also includes an extended list up to <em>N</em> = 21.
</dd>
</dl></li>
<li></li>
<li><a href="http://polymer.bu.edu/java/java/saw/saw.html">Java applet of a 2D self-avoiding walk</a></li>
<li><a href="https://github.com/abucksch/FiberWalk">Generic python implementation to simulate SAWs and expanding FiberWalks on a square lattices in n-dimensions.</a></li>
<li><a href="http://www.sas.upenn.edu/~vnanda/software.html">Norris software</a> to generate SAWs on the <a href="Diamond_cubic" title="wikilink">Diamond cubic</a>.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Polygons" title="wikilink">Category:Polygons</a> <a href="Category:Discrete_geometry" title="wikilink">Category:Discrete geometry</a> <a href="Category:Computational_physics" title="wikilink">Category:Computational physics</a> <a href="Category:Computational_chemistry" title="wikilink">Category:Computational chemistry</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">This is a recent result from Duminil-Copin and <a href="Stanislav_Smirnov" title="wikilink">Smirnov</a>: <a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
