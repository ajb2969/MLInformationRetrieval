<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1414">Low-density parity-check code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Low-density parity-check code</h1>
<hr/>

<p>In <a href="information_theory" title="wikilink">information theory</a>, a <strong>low-density parity-check</strong> (<strong>LDPC</strong>) <strong>code</strong> is a <a href="linear_block_code" title="wikilink">linear</a> <a href="error_correcting_code" title="wikilink">error correcting code</a>, a method of transmitting a message over a <a href="signal_noise" title="wikilink">noisy</a> transmission channel.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> An LDPC is constructed using a sparse <a href="bipartite_graph" title="wikilink">bipartite graph</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> LDPC codes are <a href=":Category:capacity-approaching_codes" title="wikilink">capacity-approaching codes</a>, which means that practical constructions exist that allow the noise threshold to be set very close (or even <em>arbitrarily</em> close on the <a href="binary_erasure_channel" title="wikilink">BEC</a>) to the theoretical maximum (the <a href="Shannon-Hartley_theorem" title="wikilink">Shannon limit</a>) for a symmetric memoryless channel. The noise threshold defines an upper bound for the channel noise, up to which the probability of lost information can be made as small as desired. Using iterative <a href="belief_propagation" title="wikilink">belief propagation</a> techniques, LDPC codes can be decoded in time linear to their block length.</p>

<p>LDPC codes are finding increasing use in applications requiring reliable and highly efficient information transfer over bandwidth or return channel-constrained links in the presence of corrupting noise. Implementation of LDPC codes has lagged behind that of other codes, notably <a href="turbo_code" title="wikilink">turbo codes</a>. The fundamental patent for Turbo Codes expired on August 29, 2013.<a href="https://www.google.com/patents/US5446747">[US5446747]</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>LDPC codes are also known as <strong>Gallager codes</strong>, in honor of <a href="Robert_G._Gallager" title="wikilink">Robert G. Gallager</a>, who developed the LDPC concept in his doctoral dissertation at the <a href="Massachusetts_Institute_of_Technology" title="wikilink">Massachusetts Institute of Technology</a> in 1960.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="history">History</h2>

<p>Impractical to implement when first developed by Gallager in 1963,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> LDPC codes were forgotten until his work was rediscovered in 1996.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <a href="Turbo_code" title="wikilink">Turbo codes</a>, another class of capacity-approaching codes discovered in 1993, became the coding scheme of choice in the late 1990s, used for applications such as the <a href="Deep_Space_Network" title="wikilink">Deep Space Network</a> and <a href="satellite_communication" title="wikilink">satellite communications</a>. However, in the last few years, the advances in low-density parity-check codes have seen them surpass turbo codes in terms of <a href="error_floor" title="wikilink">error floor</a> and performance in the higher <a href="code_rate" title="wikilink">code rate</a> range, leaving turbo codes better suited for the lower code rates only.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="applications">Applications</h2>

<p>In 2003, an irregular repeat accumulate (IRA) style LDPC code beat six turbo codes to become the error correcting code in the new <a class="uri" href="DVB-S2" title="wikilink">DVB-S2</a> standard for the satellite transmission of <a href="digital_television" title="wikilink">digital television</a>. <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The DVB-S2 selection committee made decoder complexity estimates for the Turbo Code proposals using a much less efficient serial decoder architecture rather than a parallel decoder architecture. This forced the Turbo Code proposals to use frame sizes on the order of one half the frame size of the LDPC proposals. In 2008, LDPC beat convolutional turbo codes as the <a href="forward_error_correction" title="wikilink">forward error correction</a> (FEC) system for the <a class="uri" href="ITU-T" title="wikilink">ITU-T</a> <a class="uri" href="G.hn" title="wikilink">G.hn</a> standard.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> G.hn chose LDPC codes over turbo codes because of their lower decoding complexity (especially when operating at data rates close to 1.0 Gbit/s) and because the proposed turbo codes exhibited a significant <a href="error_floor" title="wikilink">error floor</a> at the desired range of operation.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> LDPC is also used for <a class="uri" href="10GBase-T" title="wikilink">10GBase-T</a> Ethernet, which sends data at 10 gigabits per second over twisted-pair cables. As of 2009, LDPC codes are also part of the <a class="uri" href="Wi-Fi" title="wikilink">Wi-Fi</a> 802.11 standard as an optional part of <a class="uri" href="802.11n" title="wikilink">802.11n</a> and <a class="uri" href="802.11ac" title="wikilink">802.11ac</a>, in the High Throughput (HT) PHY specification.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>Some <a class="uri" href="OFDM" title="wikilink">OFDM</a> systems add an additional outer error correction that fixes the occasional errors (the "error floor") that get past the LDPC correction inner code even at low <a href="bit_error_rate" title="wikilink">bit error rates</a>. For example: The <a href="Reed-Solomon_code" title="wikilink">Reed-Solomon code</a> with LDPC Coded Modulation (RS-LCM) uses a Reed-Solomon outer code.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The DVB-S2, the DVB-T2 and the DVB-C2 standards all use a <a href="BCH_code" title="wikilink">BCH code</a> outer code to mop up residual errors after LDPC decoding.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="function">Function</h2>

<p>LDPC codes are defined by a sparse <a href="parity-check_matrix" title="wikilink">parity-check matrix</a>. This <a href="sparse_matrix" title="wikilink">sparse matrix</a> is often randomly generated, subject to the <a class="uri" href="sparsity" title="wikilink">sparsity</a> constraints‚Äî<a href="#Code_construction" title="wikilink">LDPC code construction</a> is discussed <a href="#Code_construction" title="wikilink">later</a>. These codes were first designed by Robert Gallager in 1962.</p>

<p>Below is a graph fragment of an example LDPC code using <a href="factor_graph" title="wikilink">Forney's factor graph notation</a>. In this graph, <em>n</em> variable nodes in the top of the graph are connected to (<em>n</em>‚àí<em>k</em>) constraint nodes in the bottom of the graph. This is a popular way of graphically representing an (<em>n</em>,¬†<em>k</em>) LDPC code. The bits of a valid message, when placed on the <strong>T's</strong> at the top of the graph, satisfy the graphical constraints. Specifically, all lines connecting to a variable node (box with an '=' sign) have the same value, and all values connecting to a factor node (box with a '+' sign) must sum, <a href="modular_arithmetic" title="wikilink">modulo</a> two, to zero (in other words, they must sum to an even number; or there must be an even number of odd values).</p>

<p> Ignoring any lines going out of the picture, there are eight possible six-bit strings corresponding to valid codewords: (i.e., 000000, 011001, 110010, 101011, 111100, 100101, 001110, 010111). This LDPC code fragment represents a three-bit message encoded as six bits. Redundancy is used, here, to increase the chance of recovering from channel errors. This is a (6,¬†3) <a href="linear_code" title="wikilink">linear code</a>, with <em>n</em>¬†=¬†6 and <em>k</em>¬†=¬†3.</p>

<p>Once again ignoring lines going out of the picture, the parity-check matrix representing this graph fragment is</p>

<p>

<math display="block" id="Low-density_parity-check_code:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùêá</mi>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùêá</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H}=\begin{pmatrix}1&1&1&1&0&0\\
0&0&1&1&0&1\\
1&0&0&1&1&0\\
\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>In this matrix, each row represents one of the three parity-check constraints, while each column represents one of the six bits in the received codeword.</p>

<p>In this example, the eight codewords can be obtained by putting the <a href="parity-check_matrix" title="wikilink">parity-check matrix</a> <strong>H</strong> into this form 

<math display="inline" id="Low-density_parity-check_code:1">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <msup>
        <mi>P</mi>
        <mi>T</mi>
       </msup>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>I</mi>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mi>k</mi>
        </mrow>
       </msub>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <ci>T</ci>
      </apply>
      <ci>normal-|</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}-P^{T}|I_{n-k}\end{bmatrix}
  </annotation>
 </semantics>
</math>

 through basic <a href="row_operations" title="wikilink">row operations</a> in <a class="uri" href="GF(2)" title="wikilink">GF(2)</a>:</p>

<p>

<math display="block" id="Low-density_parity-check_code:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùêá</mi>
    <mo>=</mo>
    <msub>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mn>1</mn>
    </msub>
    <mo>‚àº</mo>
    <msub>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mn>2</mn>
    </msub>
    <mo>‚àº</mo>
    <msub>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mn>3</mn>
    </msub>
    <mo>‚àº</mo>
    <msub>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mn>4</mn>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>ùêá</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{H}=\begin{pmatrix}1&1&1&1&0&0\\
0&0&1&1&0&1\\
1&0&0&1&1&0\\
\end{pmatrix}_{1}\sim\begin{pmatrix}1&1&1&1&0&0\\
0&0&1&1&0&1\\
0&1&1&0&1&0\\
\end{pmatrix}_{2}\sim\begin{pmatrix}1&1&1&1&0&0\\
0&1&1&0&1&0\\
0&0&1&1&0&1\\
\end{pmatrix}_{3}\sim\begin{pmatrix}1&1&1&1&0&0\\
0&1&1&0&1&0\\
1&1&0&0&0&1\\
\end{pmatrix}_{4}.
  </annotation>
 </semantics>
</math>

</p>

<p>Step 1: H.</p>

<p>Step 2: Row 1 is added to row 3.</p>

<p>Step 3: Row 2 and 3 are swapped.</p>

<p>Step 4: Row 1 is added to row 3.</p>

<p>From this, the <a href="generator_matrix" title="wikilink">generator matrix</a> <strong>G</strong> can be obtained as 

<math display="inline" id="Low-density_parity-check_code:3">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <msub>
        <mi>I</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">|</mo>
       <mi>P</mi>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>k</ci>
      </apply>
      <ci>normal-|</ci>
      <csymbol cd="unknown">P</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}I_{k}|P\end{bmatrix}
  </annotation>
 </semantics>
</math>

 (noting that in the special case of this being a binary code 

<math display="inline" id="Low-density_parity-check_code:4">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <minus></minus>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=-P
  </annotation>
 </semantics>
</math>

), or specifically:</p>

<p>

<math display="block" id="Low-density_parity-check_code:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùêÜ</mi>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùêÜ</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{G}=\begin{pmatrix}1&0&0&1&0&1\\
0&1&0&1&1&1\\
0&0&1&1&1&0\\
\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>Finally, by multiplying all eight possible 3-bit strings by <strong>G</strong>, all eight valid codewords are obtained. For example, the codeword for the bit-string '101' is obtained by:</p>

<p>

<math display="block" id="Low-density_parity-check_code:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mo>‚ãÖ</mo>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}1&0&1\\
\end{pmatrix}\cdot\begin{pmatrix}1&0&0&1&0&1\\
0&1&0&1&1&1\\
0&0&1&1&1&0\\
\end{pmatrix}=\begin{pmatrix}1&0&1&0&1&1\\
\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>As a check, the row space of <strong>G</strong> is orthogonal to <strong>H</strong> such that 

<math display="inline" id="Low-density_parity-check_code:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <msup>
     <mi>H</mi>
     <mi>T</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GH^{T}=0
  </annotation>
 </semantics>
</math>

</p>
<h2 id="example-encoder">Example Encoder</h2>

<p>Figure 1 illustrates the functional components of most LDPC encoders.</p>
<figure><b>(Figure)</b>
<figcaption>Fig. 1. LDPC Encoder</figcaption>
</figure>

<p>During the encoding of a frame, the input data bits (D) are repeated and distributed to a set of constituent encoders. The constituent encoders are typically accumulators and each accumulator is used to generate a parity symbol. A single copy of the original data (S<sub>0,K-1</sub>) is transmitted with the parity bits (P) to make up the code symbols. The S bits from each constituent encoder are discarded.</p>

<p>The parity bit may be used within another constituent code.</p>

<p>In an example using the DVB-S2 rate 2/3 code the encoded block size is 64800 symbols (N=64800) with 43200 data bits (K=43200) and 21600 parity bits (M=21600). Each constituent code (check node) encodes 16 data bits except for the first parity bit which encodes 8 data bits. The first 4680 data bits are repeated 13 times (used in 13 parity codes), while the remaining data bits are used in 3 parity codes (irregular LDPC code).</p>

<p>For comparison, classic turbo codes typically use two constituent codes configured in parallel, each of which encodes the entire input block (K) of data bits. These constituent encoders are recursive convolutional codes (RSC) of moderate depth (8 or 16 states) that are separated by a code interleaver which interleaves one copy of the frame.</p>

<p>The LDPC code, in contrast, uses many low depth constituent codes (accumulators) in parallel, each of which encode only a small portion of the input frame. The many constituent codes can be viewed as many low depth (2 state) 'convolutional codes' that are connected via the repeat and distribute operations. The repeat and distribute operations perform the function of the interleaver in the turbo code.</p>

<p>The ability to more precisely manage the connections of the various constituent codes and the level of redundancy for each input bit give more flexibility in the design of LDPC codes, which can lead to better performance than turbo codes in some instances. Turbo codes still seem to perform better than LDPCs at low code rates, or at least the design of well performing low rate codes is easier for Turbo Codes.</p>

<p>As a practical matter, the hardware that forms the accumulators is reused during the encoding process. That is, once a first set of parity bits are generated and the parity bits stored, the same accumulator hardware is used to generate a next set of parity bits.</p>
<h2 id="decoding">Decoding</h2>

<p>As with other codes, the <a href="maximum_likelihood_decoding" title="wikilink">maximum likelihood decoding</a> of an LDPC code on the <a href="binary_symmetric_channel" title="wikilink">binary symmetric channel</a> is an <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem. Performing optimal decoding for a NP-complete code of any useful size is not practical.</p>

<p>However, sub-optimal techniques based on iterative <a href="belief_propagation" title="wikilink">belief propagation</a> decoding give excellent results and can be practically implemented. The sub-optimal decoding techniques view each parity check that makes up the LDPC as an independent single parity check (SPC) code. Each SPC code is decoded separately using <a href="Soft-in_soft-out_decoder" title="wikilink">soft-in-soft-out</a> (SISO) techniques such as <a href="Soft_output_Viterbi_algorithm" title="wikilink">SOVA</a>, <a href="BCJR_algorithm" title="wikilink">BCJR</a>, <a href="Maximum_a_posteriori_estimation" title="wikilink">MAP</a>, and other derivates thereof. The soft decision information from each SISO decoding is cross-checked and updated with other redundant SPC decodings of the same information bit. Each SPC code is then decoded again using the updated soft decision information. This process is iterated until a valid code word is achieved or decoding is exhausted. This type of decoding is often referred to as sum-product decoding.</p>

<p>The decoding of the SPC codes is often referred to as the "check node" processing, and the cross-checking of the variables is often referred to as the "variable-node" processing.</p>

<p>In a practical LDPC decoder implementation, sets of SPC codes are decoded in parallel to increase throughput.</p>

<p>In contrast, belief propagation on the <a href="binary_erasure_channel" title="wikilink">binary erasure channel</a> is particularly simple where it consists of iterative constraint satisfaction.</p>

<p>For example, consider that the valid codeword, 101011, from the example above, is transmitted across a binary erasure channel and received with the first and fourth bit erased to yield ?‚Å†01?‚Å†11. Since the transmitted message must have satisfied the code constraints, the message can be represented by writing the received message on the top of the factor graph.</p>

<p>In this example, the first bit cannot yet be recovered, because all of the constraints connected to it have more than one unknown bit. In order to proceed with decoding the message, constraints connecting to only one of the erased bits must be identified. In this example, only the second constraint suffices. Examining the second constraint, the fourth bit must have been zero, since only a zero in that position would satisfy the constraint.</p>

<p>This procedure is then iterated. The new value for the fourth bit can now be used in conjunction with the first constraint to recover the first bit as seen below. This means that the first bit must be a one to satisfy the leftmost constraint.</p>
<figure><b>(Figure)</b>
<figcaption>ldpc code fragment factor graph w erasures decode step 2.svg</figcaption>
</figure>

<p>Thus, the message can be decoded iteratively. For other channel models, the messages passed between the variable nodes and check nodes are <a href="real_number" title="wikilink">real numbers</a>, which express probabilities and likelihoods of belief.</p>

<p>This result can be validated by multiplying the corrected codeword <strong>r</strong> by the parity-check matrix <strong>H</strong>:</p>

<p>

<math display="block" id="Low-density_parity-check_code:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùê≥</mi>
    <mo>=</mo>
    <mi>ùêáùê´</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>ùê≥</ci>
     <ci>ùêáùê´</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{z}=\mathbf{Hr}=\begin{pmatrix}1&1&1&1&0&0\\
0&0&1&1&0&1\\
1&0&0&1&1&0\\
\end{pmatrix}\par
\begin{pmatrix}1\\
0\\
1\\
0\\
1\\
1\\
\end{pmatrix}\par
=\begin{pmatrix}0\\
0\\
0\\
\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>Because the outcome <strong>z</strong> (the <a href="Decoding_methods#Syndrome_decoding" title="wikilink">syndrome</a>) of this operation is the three √ó one zero vector, the resulting codeword <strong>r</strong> is successfully validated.</p>

<p>While illustrative, this erasure example does not show the use of soft-decision decoding or soft-decision message passing, which is used in virtually all commercial LDPC decoders.</p>
<h3 id="updating-node-information">Updating node information</h3>

<p>In recent years, there has also been a great deal of work spent studying the effects of alternative schedules for variable-node and constraint-node update. The original technique that was used for decoding LDPC codes was known as <em>flooding</em>. This type of update required that, before updating a variable node, all constraint nodes needed to be updated and vice versa. In later work by Vila Casado <em>et al.</em>,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> alternative update techniques were studied, in which variable nodes are updated with the newest available check-node information.</p>

<p>The intuition behind these algorithms is that variable nodes whose values vary the most are the ones that need to be updated first. Highly reliable nodes, whose <a href="log-likelihood_ratio" title="wikilink">log-likelihood ratio</a> (LLR) magnitude is large and does not change significantly from one update to the next, do not require updates with the same frequency as other nodes, whose sign and magnitude fluctuate more widely. These scheduling algorithms show greater speed of convergence and lower error floors than those that use flooding. These lower error floors are achieved by the ability of the Informed Dynamic Scheduling (IDS)<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> algorithm to overcome trapping sets of near codewords.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>When nonflooding scheduling algorithms are used, an alternative definition of iteration is used. For an (<em>n</em>,¬†<em>k</em>) LDPC code of rate <em>k</em>/<em>n</em>, a full <em>iteration</em> occurs when <em>n</em> variable and <em>n</em>¬†‚àí¬†<em>k</em> constraint nodes have been updated, no matter the order in which they were updated.</p>
<h3 id="lookup-table-decoding">Lookup table decoding</h3>

<p>It is possible to decode LDPC codes on a relatively low-power microprocessor by the use of <a href="lookup_table" title="wikilink">lookup tables</a>.</p>

<p>While codes such as the LDPC are generally implemented on high-power processors, with long block lengths, there are also applications which use lower-power processors and short block lengths (1024).</p>

<p>Therefore, it is possible to precalculate the output bit based upon predetermined input bits. A table is generated which contains <em>n</em> entries (for a block length of 1024 bits, this would be 1024 bits long), and contains all possible entries for different input states (both errored and nonerrored).</p>

<p>As a bit is input, it is then added to a FIFO register, and the value of the FIFO register is then used to look up in the table the relevant output from the precalculated values.</p>

<p>By this method, very high iterations can be used, with little processor overhead, the only cost being that of the memory for the lookup table, such that LDPC decoding is possible even on a 4.0¬†MHz PIC chip.</p>
<h2 id="code-construction">Code construction</h2>

<p>For large block sizes, LDPC codes are commonly constructed by first studying the behaviour of decoders. As the block size tends to infinity, LDPC decoders can be shown to have a noise threshold below which decoding is reliably achieved, and above which decoding is not achieved,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> colloquially referred to as the <a href="cliff_effect" title="wikilink">cliff effect</a>. This threshold can be optimised by finding the best proportion of arcs from check nodes and arcs from variable nodes. An approximate graphical approach to visualising this threshold is an <a href="EXIT_chart" title="wikilink">EXIT chart</a>.</p>

<p>The construction of a specific LDPC code after this optimization falls into two main types of techniques:</p>
<ul>
<li>Pseudorandom approaches</li>
<li>Combinatorial approaches</li>
</ul>

<p>Construction by a pseudo-random approach builds on theoretical results that, for large block size, a random construction gives good decoding performance.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> In general, pseudorandom codes have complex encoders, but pseudorandom codes with the best decoders can have simple encoders.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Various constraints are often applied to help ensure that the desired properties expected at the theoretical limit of infinite block size occur at a finite block size.</p>

<p>Combinatorial approaches can be used to optimize the properties of small block-size LDPC codes or to create codes with simple encoders.</p>

<p>Some LDPC codes are based on <a href="Reed‚ÄìSolomon_code" title="wikilink">Reed‚ÄìSolomon codes</a>, such as the RS-LDPC code used in the <a href="10_Gigabit_Ethernet" title="wikilink">10 Gigabit Ethernet</a> standard.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> Compared to randomly generated LDPC codes, structured LDPC codes‚Äîsuch as the LDPC code used in the <a class="uri" href="DVB-S2" title="wikilink">DVB-S2</a> standard‚Äîcan have simpler and therefore lower-cost hardware‚Äîin particular, codes constructed such that the H matrix is a <a href="circulant_matrix" title="wikilink">circulant matrix</a>.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>Yet another way of constructing LDPC codes is to use <a href="finite_geometry" title="wikilink">finite geometries</a>. This method was proposed by Y. Kou <em>et al.</em> in 2001.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h2 id="see-also">See also</h2>
<h3 id="people">People</h3>
<ul>
<li><a href="Robert_G._Gallager" title="wikilink">Robert G. Gallager</a></li>
<li><a href="Richard_Hamming" title="wikilink">Richard Hamming</a></li>
<li><a href="Claude_Shannon" title="wikilink">Claude Shannon</a></li>
<li><a href="David_J._C._MacKay" title="wikilink">David J. C. MacKay</a></li>
<li><a href="Irving_S._Reed" title="wikilink">Irving S. Reed</a></li>
</ul>
<h3 id="theory">Theory</h3>
<ul>
<li><a href="Belief_propagation" title="wikilink">Belief propagation</a></li>
<li><a href="Graph_theory" title="wikilink">Graph theory</a></li>
<li><a href="Hamming_code" title="wikilink">Hamming code</a></li>
<li><a href="Linear_code" title="wikilink">Linear code</a></li>
<li><a href="Sparse_graph_code" title="wikilink">Sparse graph code</a></li>
<li><a href="Expander_code" title="wikilink">Expander code</a></li>
</ul>
<h3 id="applications-1">Applications</h3>
<ul>
<li><a href="G.hn" title="wikilink">G.hn/G.9960</a> (ITU-T Standard for networking over power lines, phone lines and coaxial cable)</li>
<li><a class="uri" href="802.3an" title="wikilink">802.3an</a> (10 Giga-bit/s Ethernet over Twisted pair)</li>
<li><a class="uri" href="CMMB" title="wikilink">CMMB</a>(China Multimedia Mobile Broadcasting)</li>
<li><a class="uri" href="DVB-S2" title="wikilink">DVB-S2</a> / <a class="uri" href="DVB-T2" title="wikilink">DVB-T2</a> / <a class="uri" href="DVB-C2" title="wikilink">DVB-C2</a> (Digital video broadcasting, 2nd Generation)</li>
<li><a class="uri" href="DMB-T/H" title="wikilink">DMB-T/H</a> (Digital video broadcasting)<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></li>
<li><a class="uri" href="WiMAX" title="wikilink">WiMAX</a> (IEEE 802.16e standard for microwave communications)</li>
<li><a href="IEEE_802.11n-2009" title="wikilink">IEEE 802.11n-2009</a> (<a class="uri" href="Wi-Fi" title="wikilink">Wi-Fi</a> standard)</li>
</ul>
<h3 id="other-capacity-approaching-codes">Other capacity-approaching codes</h3>
<ul>
<li><a href="Turbo_code" title="wikilink">Turbo codes</a></li>
<li><a href="Serial_concatenated_convolutional_codes" title="wikilink">Serial concatenated convolutional codes</a></li>
<li><a href="Online_codes" title="wikilink">Online codes</a></li>
<li><a href="Fountain_codes" title="wikilink">Fountain codes</a></li>
<li><a href="LT_codes" title="wikilink">LT codes</a></li>
<li><a href="Raptor_codes" title="wikilink">Raptor codes</a></li>
<li><a href="Repeat-accumulate_code" title="wikilink">Repeat-accumulate codes</a> (a class of simple turbo codes)</li>
<li><a href="Tornado_code" title="wikilink">Tornado codes</a> (LDPC codes designed for <a href="binary_erasure_channel" title="wikilink">erasure decoding</a>)</li>
<li><a href="Polar_code_(coding_theory)" title="wikilink">Polar codes</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.inference.phy.cam.ac.uk/mackay/itila/">The on-line textbook: Information Theory, Inference, and Learning Algorithms</a>, by <a href="David_J.C._MacKay" title="wikilink">David J.C. MacKay</a>, discusses LDPC codes in Chapter 47.</li>
<li><a href="http://www.ics.uci.edu/~welling/teaching/ICS279/LPCD.pdf">1</a> LDPC Codes: An Introduction</li>
<li><a href="http://www.inference.phy.cam.ac.uk/mackay/CodesFiles.html">LDPC codes and performance results</a></li>
<li><a href="http://www.sigpromu.org/ldpc/DE/index.php">Online density evolution for LDPC codes</a></li>
<li><a href="http://bernh.net/media/download/papers/ldpc.pdf">LDPC Codes ‚Äì a brief Tutorial (by Bernhard Leiner, 2005)</a></li>
<li><a href="http://www.cambridge.org/gb/knowledge/isbn/item2711886/?site_locale=en_GB">Iterative Error Correction: Turbo, Low-Density Parity-Check and Repeat-Accumulate Codes</a></li>
<li>Source code for encoding, decoding, and simulating LDPC codes is available from a variety of locations:
<ul>
<li><a href="http://www.cs.utoronto.ca/~radford/ldpc.software.html">Binary LDPC codes in </a><a href="C_(programming_language)" title="wikilink">C</a></li>
<li><a href="http://freshmeat.net/projects/pycodes/">Binary LDPC codes for </a><a href="Python_(programming_language)" title="wikilink">Python</a> (core algorithm in C)</li>
<li><a href="http://www.kozintsev.net/soft.html">LDPC codes over GF(q) in </a><a class="uri" href="MATLAB" title="wikilink">MATLAB</a></li>
<li><a href="http://www.mathworks.com/access/helpdesk/help/toolbox/comm/ref/fec.ldpcenc.html">LDPC encoder</a> and <a href="http://www.mathworks.com/access/helpdesk/help/toolbox/comm/ref/fec.ldpcdec.html">LDPC decoder</a> in <a class="uri" href="MATLAB" title="wikilink">MATLAB</a></li>
</ul></li>
</ul>

<p>"</p>

<p><a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a> <a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Capacity-approaching_codes" title="wikilink">Category:Capacity-approaching codes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="David_J.C._MacKay" title="wikilink">David J.C. MacKay</a> (2003) Information theory, Inference and Learning Algorithms, CUP, ISBN 0-521-64298-1, (also <a href="http://www.inference.phy.cam.ac.uk/mackay/itila/book.html">available online</a>)<a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="Todd_K._Moon" title="wikilink">Todd K. Moon</a> (2005) Error Correction Coding, Mathematical Methods and Algorithms. Wiley, ISBN 0-471-64800-0 (Includes code)<a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="Amin_Shokrollahi" title="wikilink">Amin Shokrollahi</a> (2003) LDPC Codes: An Introduction<a href="#fnref3">‚Ü©</a></li>
<li id="fn4">NewScientist, <em>Communication speed nears terminal velocity</em>, by Dana Mackenzie, 9 July 2005<a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="David_J.C._MacKay" title="wikilink">David J.C. MacKay</a> and Radford M. Neal, "Near Shannon Limit Performance of Low Density Parity Check Codes," Electronics Letters, July 1996<a href="#fnref7">‚Ü©</a></li>
<li id="fn8"><a href="http://deepspace.jpl.nasa.gov/dsndocs/810-005/208/208B.pdf">Telemetry Data Decoding, Design Handbook</a><a href="#fnref8">‚Ü©</a></li>
<li id="fn9"><a href="http://www.ieeevtc.org/vtc2003fall/2003panelsessions/llee.pdf">Presentation by Hughes Systems</a><a href="#fnref9">‚Ü©</a></li>
<li id="fn10"><a href="http://homepnablog.typepad.com/my_weblog/2008/12/ghn-a-phy-for-all-seasons.html">HomePNA Blog: G.hn, a PHY For All Seasons</a><a href="#fnref10">‚Ü©</a></li>
<li id="fn11"><a href="http://blog.ds2.es/ds2blog/2009/10/ieee-communications-magazine-paper-on-ghn.html">IEEE Communications Magazine paper on G.hn</a><a href="#fnref11">‚Ü©</a></li>
<li id="fn12">IEEE Standard, section 20.3.11.6 <a href="http://standards.ieee.org/getieee802/download/802.11n-2009.pdf">"802.11n-2009"</a>, IEEE, October 29, 2009, accessed March 21, 2011.<a href="#fnref12">‚Ü©</a></li>
<li id="fn13">Chih-Yuan Yang, Mong-Kai Ku. <a class="uri" href="http://123seminarsonly.com/Seminar-Reports/029/26540350-Ldpc-Coded-Ofdm-Modulation.pdf">http://123seminarsonly.com/Seminar-Reports/029/26540350-Ldpc-Coded-Ofdm-Modulation.pdf</a> "LDPC coded OFDM modulation for high spectral efficiency transmission"<a href="#fnref13">‚Ü©</a></li>
<li id="fn14">Nick Wells. <a href="http://www.atsc.org/cms/pdf/pt2/Wells_ATSC_paper_on_T2.pdf">"DVB-T2 in relation to the DVB-x2 Family of Standards"</a><a href="#fnref14">‚Ü©</a></li>
<li id="fn15">A.I. Vila Casado, M. Griot, and R.Wesel, ‚ÄúInformed dynamic scheduling for belief propagation decoding of LDPC codes,‚Äù Proc. <a class="uri" href="IEEE" title="wikilink">IEEE</a> Int. Conf. on Comm. (ICC), June 2007.<a href="#fnref15">‚Ü©</a></li>
<li id="fn16"></li>
<li id="fn17">T. Richardson, ‚ÄúError floors of LDPC codes,‚Äù in Proc. 41st Allerton Conf. Comm., Control, and Comput., Monticello, IL, 2003.<a href="#fnref17">‚Ü©</a></li>
<li id="fn18">Thomas J. Richardson and M. Amin Shokrollahi and R√ºdiger L. Urbanke, "Design of Capacity-Approaching Irregular Low-Density Parity-Check Codes," IEEE Transactions in Information Theory, 47(2), February 2001<a href="#fnref18">‚Ü©</a></li>
<li id="fn19"></li>
<li id="fn20">Thomas J. Richardson and R√ºdiger L. Urbanke, "Efficient Encoding of Low-Density Parity-Check Codes," IEEE Transactions in Information Theory, 47(2), February 2001<a href="#fnref20">‚Ü©</a></li>
<li id="fn21">Ahmad Darabiha, Anthony Chan Carusone, Frank R. Kschischang. <a href="http://www.eecg.toronto.edu/~tcc/darabiha_jssc08.pdf">"Power Reduction Techniques for LDPC Decoders"</a><a href="#fnref21">‚Ü©</a></li>
<li id="fn22">Zhengya Zhang, Venkat Anantharam, Martin J. Wainwright, and Borivoje Nikolic. <a href="http://www.eecs.berkeley.edu/~ananth/2008+/jssc_apr10.pdf">"An Efficient 10GBASE-T Ethernet LDPC Decoder Design With Low Error Floors"</a>.<a href="#fnref22">‚Ü©</a></li>
<li id="fn23">Y. Kou, S. Lin and M. Fossorier, "Low-Density Parity-Check Codes Based on Finite Geometries: A Rediscovery and New Results," IEEE Transactions on Information Theory, vol. 47, no. 7, November 2001, pp. 2711- 2736.<a href="#fnref23">‚Ü©</a></li>
<li id="fn24"><a class="uri" href="http://spectrum.ieee.org/consumer-electronics/standards/does-china-have-the-best-digital-television-standard-on-the-planet/2">http://spectrum.ieee.org/consumer-electronics/standards/does-china-have-the-best-digital-television-standard-on-the-planet/2</a><a href="#fnref24">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
