<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1292">Boundary-value analysis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Boundary-value analysis</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Boundary value analysis</strong> is a <a href="software_testing" title="wikilink">software testing</a> technique in which tests are designed to include representatives of boundary values in a range. The idea comes from the <a href="Boundary_(topology)" title="wikilink">boundary</a>. Given that we have a set of <a href="test_vector" title="wikilink">test vectors</a> to test the system, a topology can be defined on that set. Those inputs which belong to the same <a href="equivalence_class" title="wikilink">equivalence class</a> as defined by the <a href="equivalence_partitioning" title="wikilink">equivalence partitioning</a> theory would constitute the <a href="basis_(topology)" title="wikilink">basis</a>. Given that the basis sets are <a href="neighbourhood_(mathematics)" title="wikilink">neighbors</a>, there would exist a boundary between them. The test vectors on either side of the boundary are called boundary values. In practice this would require that the test vectors can be ordered, and that the individual parameters follows some kind of order (either <a href="partial_order" title="wikilink">partial order</a> or <a href="total_order" title="wikilink">total order</a>).</p>
<h2 id="formal-definition">Formal Definition</h2>

<p>Formally the boundary values can be defined as below:- Let the set of the <a href="test_vector" title="wikilink">test vectors</a> be 

<math display="inline" id="Boundary-value_analysis:0">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},\dots,X_{n}
  </annotation>
 </semantics>
</math>

. Let's assume that there is an ordering relation defined over them, as 

<math display="inline" id="Boundary-value_analysis:1">
 <semantics>
  <mo>≤</mo>
  <annotation-xml encoding="MathML-Content">
   <leq></leq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Boundary-value_analysis:2">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1},C_{2}
  </annotation>
 </semantics>
</math>

 be two equivalent classes. Assume that test vector 

<math display="inline" id="Boundary-value_analysis:3">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>∈</mo>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1}\in C_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Boundary-value_analysis:4">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>∈</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{2}\in C_{2}
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Boundary-value_analysis:5">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>≤</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1}\leq X_{2}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Boundary-value_analysis:6">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>≤</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{2}\leq X_{1}
  </annotation>
 </semantics>
</math>

 then the classes 

<math display="inline" id="Boundary-value_analysis:7">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>C</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1},C_{2}
  </annotation>
 </semantics>
</math>

 are in the same <a href="neighbourhood_(mathematics)" title="wikilink">neighborhood</a> and the values 

<math display="inline" id="Boundary-value_analysis:8">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},X_{2}
  </annotation>
 </semantics>
</math>

 are boundary values.</p>

<p>In plainer English, values on the minimum and maximum edges of an <a href="equivalence_partitioning" title="wikilink">equivalence partition</a> are tested. The values could be input or output ranges of a software component, can also be the internal implementation. Since these boundaries are common locations for errors that result in software <a href="fault_(technology)" title="wikilink">faults</a> they are frequently exercised in <a href="test_case" title="wikilink">test cases</a>.</p>
<h2 id="application">Application</h2>

<p>The expected input and output values to the software component should be extracted from the component specification. The values are then grouped into sets with identifiable boundaries. Each set, or partition, contains values that are expected to be processed by the component in the same way. Partitioning of test data ranges is explained in the <a href="equivalence_partitioning" title="wikilink">equivalence partitioning</a> test case design technique. It is important to consider both valid and invalid partitions when designing test cases.</p>

<p>The demonstration can be done using a function written in <a href="C_(programming_language)" title="wikilink">C</a></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> safe_add( <span class="dt">int</span> a, <span class="dt">int</span> b )
{
     <span class="dt">int</span> c = a + b ;
     <span class="kw">if</span> ( a &gt;= <span class="dv">0</span> &amp;&amp; b &gt;= <span class="dv">0</span> &amp;&amp; c &lt; <span class="dv">0</span> )
     {
        fprintf ( stderr, <span class="st">"Overflow!</span><span class="ch">\n</span><span class="st">"</span>);
    } 
    <span class="kw">if</span> ( a &lt; <span class="dv">0</span> &amp;&amp; b &lt; <span class="dv">0</span> &amp;&amp; c &gt;= <span class="dv">0</span> )
     {
        fprintf ( stderr, <span class="st">"Underflow!</span><span class="ch">\n</span><span class="st">"</span>);
    } 
    <span class="kw">return</span> c;
}</code></pre></div>

<p>On the basis of the code, the input vectors of 

<math display="inline" id="Boundary-value_analysis:9">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a,b]
  </annotation>
 </semantics>
</math>

 are partitioned. The blocks we need to cover are the overflow statement and the underflow statement and neither of these 2. That gives rise to 3 equivalent classes, from the code review itself.</p>
<figure><b>(Figure)</b>
<figcaption>|right| Demonstrating Boundary Values (Orange) </figcaption>
</figure>

<p>we note that there is a fixed size of <a href="Integer_(computer_science)" title="wikilink">integer</a> hence:- 

<math display="inline" id="Boundary-value_analysis:10">
 <semantics>
  <mrow>
   <mrow>
    <mtext>INT</mtext>
    <mi mathvariant="normal">_</mi>
    <mtext>MIN</mtext>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mtext>INT</mtext>
    <mi mathvariant="normal">_</mi>
    <mtext>MAX</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <mtext>INT</mtext>
      <ci>normal-_</ci>
      <mtext>MIN</mtext>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <mtext>INT</mtext>
      <ci>normal-_</ci>
      <mtext>MAX</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{INT}\_\text{MIN}\leq x+y\leq\text{INT}\_\text{MAX}
  </annotation>
 </semantics>
</math>

</p>

<p>We note that the input parameter <em>a</em> and <em>b</em> both are integers, hence <a href="total_order" title="wikilink">total order</a> exists on them. When we compute the equalities:-</p>

<p>

<math display="inline" id="Boundary-value_analysis:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mtext>INT</mtext>
    <mi mathvariant="normal">_</mi>
    <mtext>MAX</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>INT</mtext>
     <ci>normal-_</ci>
     <mtext>MAX</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+y=\text{INT}\_\text{MAX}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Boundary-value_analysis:12">
 <semantics>
  <mrow>
   <mrow>
    <mtext>INT</mtext>
    <mi mathvariant="normal">_</mi>
    <mtext>MIN</mtext>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>INT</mtext>
     <ci>normal-_</ci>
     <mtext>MIN</mtext>
    </apply>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{INT}\_\text{MIN}=x+y
  </annotation>
 </semantics>
</math>

</p>

<p>we get back the values which are on the boundary, inclusive, that is these pairs of 

<math display="inline" id="Boundary-value_analysis:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

 are valid combinations, and no underflow or overflow would happen for them.</p>

<p>On the other hand:-</p>

<p>

<math display="inline" id="Boundary-value_analysis:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mtext>INT</mtext>
     <mi mathvariant="normal">_</mi>
     <mtext>MAX</mtext>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <mtext>INT</mtext>
      <ci>normal-_</ci>
      <mtext>MAX</mtext>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+y=\text{INT}\_\text{MAX}+1
  </annotation>
 </semantics>
</math>

 gives pairs of 

<math display="inline" id="Boundary-value_analysis:15">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

 which are invalid combinations, Overflow would occur for them. In the same way:-</p>

<p>

<math display="inline" id="Boundary-value_analysis:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mtext>INT</mtext>
     <mi mathvariant="normal">_</mi>
     <mtext>MIN</mtext>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <mtext>INT</mtext>
      <ci>normal-_</ci>
      <mtext>MIN</mtext>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+y=\text{INT}\_\text{MIN}-1
  </annotation>
 </semantics>
</math>

 gives pairs of 

<math display="inline" id="Boundary-value_analysis:17">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

 which are invalid combinations, Underflow would occur for them.</p>

<p>Boundary values (drawn only for the overflow case) are being shown as the orange line in the right hand side figure.</p>

<p>For another example, if the input values were months of the year, expressed as integers, the input parameter 'month' might have the following partitions:</p>

<p><code>       ... -2 -1  0 1 .............. 12 13  14  15 .....</code><br/>
<code>     --------------|-------------------|-------------------</code><br/>
<code>invalid partition 1   valid partition   invalid partition 2</code></p>

<p>The boundary between two partitions is the place where the behavior of the application changes and is not a real number itself. The boundary value is the minimum (or maximum) value that is at the boundary. The number 0 is the maximum number in the first partition, the number 1 is the minimum value in the second partition, both are boundary values. Test cases should be created to generate inputs or outputs that will fall on and to either side of each boundary, which results in two cases per boundary. The test cases on each side of a boundary should be in the smallest increment possible for the component under test, for an integer this is 1, but if the input was a decimal with 2 places then it would be .01. In the example above there are boundary values at 0,1 and 12,13 and each should be tested.</p>

<p>Boundary value analysis does not require invalid partitions. Take an example where a heater is turned on if the temperature is 10 degrees or colder. There are two partitions (temperature10) and two boundary values to be tested (temperature=10, temperature=11).</p>

<p>Where a boundary value falls within the invalid partition the test case is designed to ensure the software component handles the value in a controlled manner. Boundary value analysis can be used throughout the testing cycle and is equally applicable at all testing phases.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.testingstandards.co.uk">The Testing Standards Working Party</a> website.</li>
</ul>

<p>"</p>

<p><a href="Category:Software_testing" title="wikilink">Category:Software testing</a></p>
</body>

