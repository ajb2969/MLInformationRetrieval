<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="983">Functional dependency</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Functional dependency</h1>
<hr/>
<p>In <a href="relational_database" title="wikilink">relational database</a> theory, a <strong>functional dependency</strong> is a <strong><a href="Relational_database#Constraints" title="wikilink">constraint</a></strong> between two sets of attributes in a <a href="Relation_(database)" title="wikilink">relation</a> from a database.</p>
<p>Given a relation <em>R</em>, a set of attributes <em>X</em> in <em>R</em> is said to <strong>functionally determine</strong> another set of attributes <em>Y</em>, also in <em>R</em>, (written <em>X</em> → <em>Y</em>) if, and only if, each <em>X</em> value is associated with precisely one <em>Y</em> value; <em>R</em> is then said to <em>satisfy</em> the functional dependency <em>X</em> → <em>Y</em>. Equivalently, the <a href="projection_(relational_algebra)" title="wikilink">projection</a> <span class="LaTeX">$\pi_{X,Y}R$</span> is a <a href="function_(mathematics)" title="wikilink">function</a>, i.e. <em>Y</em> is a function of <em>X</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In simple words, if the values for the <em>X</em> attributes are known (say they are <em>x</em>), then the values for the <em>Y</em> attributes corresponding to <em>x</em> can be determined by looking them up in <em>any</em> <a href="Tuple#Relational_model" title="wikilink">tuple</a> of <em>R</em> containing <em>x</em>. Customarily <em>X</em> is called the <em>determinant</em> set and <em>Y</em> the <em>dependent</em> set. A functional dependency FD: <em>X</em> → <em>Y</em> is called <em>trivial</em> if <em>Y</em> is a <a class="uri" href="subset" title="wikilink">subset</a> of <em>X</em>.</p>
<p>In other words, a dependency FD: <em>X</em> → <em>Y</em> means that the values of <em>Y</em> are determined by the values of <em>X</em>. Two tuples sharing the same values of <em>X</em> will necessarily have the same values of <em>Y</em>.</p>
<p>The determination of functional dependencies is an important part of designing databases in the <a href="relational_model" title="wikilink">relational model</a>, and in <a href="database_normalization" title="wikilink">database normalization</a> and <a class="uri" href="denormalization" title="wikilink">denormalization</a>. A simple application of functional dependencies is <strong>Heath’s theorem</strong>; it says that a relation <em>R</em> over an attribute set <em>U</em> and satisfying a functional dependency <em>X</em> → <em>Y</em> can be safely split in two relations having the <a href="lossless-join_decomposition" title="wikilink">lossless-join decomposition</a> property, namely into <span class="LaTeX">$\pi_{XY}(R)\bowtie\pi_{XZ}(R) = R$</span> where <em>Z</em> = <em>U</em> − <em>XY</em> are the rest of the attributes. (<a href="set_union" title="wikilink">Unions</a> of attribute sets are customarily denoted by mere juxtapositions in database theory.) An important notion in this context is a <a href="candidate_key" title="wikilink">candidate key</a>, defined as a minimal set of attributes that functionally determine all of the attributes in a relation. The functional dependencies, along with the <a href="attribute_domain" title="wikilink">attribute domains</a>, are selected so as to generate constraints that would exclude as much data inappropriate to the <a href="user_domain" title="wikilink">user domain</a> from the system as possible.</p>
<p>A notion of <a href="logical_implication" title="wikilink">logical implication</a> is defined for functional dependencies in the following way: a set of functional dependencies <span class="LaTeX">$\Sigma$</span> logically implies another set of dependencies <span class="LaTeX">$\Gamma$</span>, if any relation <em>R</em> satisfying all dependencies from <span class="LaTeX">$\Sigma$</span> also satisfies all dependencies from <span class="LaTeX">$\Gamma$</span>; this is usually written <span class="LaTeX">$\Sigma \models \Gamma$</span>. The notion of logical implication for functional dependencies admits a <a href="soundness" title="wikilink">sound</a> and <a href="completeness_(logic)" title="wikilink">complete</a> finite <a class="uri" href="axiomatization" title="wikilink">axiomatization</a>, known as <strong>Armstrong's axioms</strong>.</p>
<h2 id="examples">Examples</h2>
<h3 id="cars">Cars</h3>
<p>Suppose one is designing a system to track vehicles and the capacity of their engines. Each vehicle has a unique <a href="vehicle_identification_number" title="wikilink">vehicle identification number</a> (VIN). One would write <strong>VIN</strong> → <strong>EngineCapacity</strong> because it would be inappropriate for a vehicle's engine to have more than one capacity. (Assuming, in this case, that vehicles only have one engine.) Transversely, <em>EngineCapacity</em> → <em>VIN</em> is incorrect because there could be many vehicles with the same engine capacity.</p>
<p>This functional dependency may suggest that the attribute EngineCapacity be placed in a relation with <a href="candidate_key" title="wikilink">candidate key</a> VIN. However, that may not always be appropriate. For example, if that functional dependency occurs as a result of the <a href="transitive_relation" title="wikilink">transitive</a> functional dependencies VIN → VehicleModel and VehicleModel → EngineCapacity then that would not result in a normalized relation.</p>
<h3 id="lectures">Lectures</h3>
<p>This example illustrates the concept of functional dependency. The situation modelled is that of college students visiting one or more lectures in each of which they are assigned a teaching assistant (TA). Let's further assume that every student is in some semester and is identified by a unique integer ID.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>StudentID</p></th>
<th style="text-align: left;"><p>Semester</p></th>
<th style="text-align: left;"><p>Lecture</p></th>
<th style="text-align: left;"><p>TA</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>1234</p></td>
<td style="text-align: left;"><p>6</p></td>
<td style="text-align: left;"><p>Numerical Methods</p></td>
<td style="text-align: left;"><p>Aisaule</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>1221</p></td>
<td style="text-align: left;"><p>4</p></td>
<td style="text-align: left;"><p>Numerical Methods</p></td>
<td style="text-align: left;"><p>Dimash</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>1234</p></td>
<td style="text-align: left;"><p>6</p></td>
<td style="text-align: left;"><p>Visual Computing</p></td>
<td style="text-align: left;"><p>Ahmed</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>1201</p></td>
<td style="text-align: left;"><p>4</p></td>
<td style="text-align: left;"><p>Numerical Methods</p></td>
<td style="text-align: left;"><p>Peter</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>1201</p></td>
<td style="text-align: left;"><p>4</p></td>
<td style="text-align: left;"><p>Physics II</p></td>
<td style="text-align: left;"><p>Simone</p></td>
</tr>
</tbody>
</table>
<p>We notice that whenever two rows in this table feature the same StudentID, they also necessarily have the same Semester values. This basic fact can be expressed by a functional dependency:</p>
<ul>
<li>StudentID → Semester.</li>
</ul>
<p>Note that if a row was added where the student had a different value of semester that the FD would no longer exist. This means that the FD is implied by the data as it is possible to have values that would invalidate the FD.</p>
<p>Other nontrivial functional dependencies can be identified, for example:</p>
<ul>
<li>{StudentID, Lecture} → TA</li>
<li>{StudentID, Lecture} → {TA, Semester}</li>
</ul>
<p>The latter expresses the fact that the set {StudentID, Lecture} is a <a class="uri" href="superkey" title="wikilink">superkey</a> of the relation.</p>
<h3 id="employee-department-model">Employee Department Model</h3>
<p>A classic example of functional dependency is the employee, department model. The following table</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Employee ID</p></th>
<th style="text-align: left;"><p>Employee Name</p></th>
<th style="text-align: left;"><p>Department ID</p></th>
<th style="text-align: left;"><p>Department Name</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>0001</p></td>
<td style="text-align: left;"><p>John Doe</p></td>
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"><p>Human Resources</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>0002</p></td>
<td style="text-align: left;"><p>Jane Doe</p></td>
<td style="text-align: left;"><p>2</p></td>
<td style="text-align: left;"><p>Marketing</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>0003</p></td>
<td style="text-align: left;"><p>John Smith</p></td>
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"><p>Human Resources</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>0004</p></td>
<td style="text-align: left;"><p>Jane Goodall</p></td>
<td style="text-align: left;"><p>3</p></td>
<td style="text-align: left;"><p>Sales</p></td>
</tr>
</tbody>
</table>
<p>This case represents an example where multiple functional dependencies are embedded in a single representation of data. Note that because an employee can only be a member of one department, the unique ID of that employee determines the department.</p>
<ul>
<li>Employee ID → Employee Name</li>
<li>Employee ID → Department ID</li>
<li>Employee ID → Department Name</li>
</ul>
<p>In addition to this relationship, the table also represents a second functional dependency</p>
<ul>
<li>Department ID → Department Name</li>
</ul>
<p>This example demonstrates that even though there exists a FD Employee ID → Department ID - the employee ID would not be a logical key for determination of the department ID. The process of normalization of the data would recognize all FD's and allow the designer to construct tables and relationships that are more logical based on the data.</p>
<h2 id="properties-and-axiomatization-of-functional-dependencies">Properties and axiomatization of functional dependencies</h2>
<p>Given that <em>X</em>, <em>Y</em>, and <em>Z</em> are sets of attributes in a relation <em>R</em>, one can derive several properties of functional dependencies. Among the most important are the following, usually called <a href="Armstrong's_axioms" title="wikilink">Armstrong's axioms</a>:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ul>
<li><strong>Reflexivity</strong>: If <em>Y</em> is a subset of <em>X</em>, then <em>X</em> → <em>Y</em></li>
<li><strong>Augmentation</strong>: If <em>X</em> → <em>Y</em>, then <em>XZ</em> → <em>YZ</em></li>
<li><strong>Transitivity</strong>: If <em>X</em> → <em>Y</em> and <em>Y</em> → <em>Z</em>, then <em>X</em> → <em>Z</em></li>
</ul>
<p>"Reflexivity" can be weakened to just <span class="LaTeX">$X \rightarrow \varnothing$</span>, i.e. it is an actual <a class="uri" href="axiom" title="wikilink">axiom</a>, where the other two are proper <a href="inference_rules" title="wikilink">inference rules</a>, more precisely giving rise to the following rules of syntactic consequence:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <span class="LaTeX">$\vdash X \rightarrow \varnothing$</span><br/>
<span class="LaTeX">$X \rightarrow Y \vdash XZ \rightarrow YZ$</span><br/>
<span class="LaTeX">$X \rightarrow Y, Y \rightarrow Z \vdash X \rightarrow Z$</span>.</p>
<p>These three rules are a <a href="Soundness" title="wikilink">sound</a> and <a href="Completeness_(logic)" title="wikilink">complete</a> axiomatization of functional dependencies. This axiomatization is sometimes described as finite because the number of inference rules is finite,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> with the caveat that the axiom and rules of inference are all <a href="Schema_(logic)" title="wikilink">schemata</a>, meaning that the <em>X</em>, <em>Y</em> and <em>Z</em> range over all ground terms (attribute sets).<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<p>From these rules, we can derive these secondary rules:<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<ul>
<li><strong>Union</strong>: If <em>X</em> → <em>Y</em> and <em>X</em> → <em>Z</em>, then <em>X</em> → <em>YZ</em></li>
<li><strong>Decomposition</strong>: If <em>X</em> → <em>YZ</em>, then <em>X</em> → <em>Y</em> and <em>X</em> → <em>Z</em></li>
<li><strong>Pseudotransitivity</strong>: If <em>X</em> → <em>Y</em> and <em>WY</em> → <em>Z</em>, then <em>WX</em> → <em>Z</em></li>
</ul>
<p>The union and decomposition rules can be combined in a <a href="logical_equivalence" title="wikilink">logical equivalence</a> stating that <em>X</em> → <em>YZ</em>, holds <a class="uri" href="iff" title="wikilink">iff</a> <em>X</em> → <em>Y</em> and <em>X</em> → <em>Z</em>. This is sometimes called the splitting/combining rule.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<p>Another rule that is sometimes handy is:<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<ul>
<li><strong>Composition</strong>: If <em>X</em> → <em>Y</em> and <em>Z</em> → <em>W</em>, then <em>XZ</em> → <em>YW</em></li>
</ul>
<h2 id="closure-of-functional-dependency">Closure of Functional Dependency</h2>
<p>The closure is essentially the full set of values that can be determined from a set of known values for a given relationship using its functional dependencies. You use <a href="Armstrong's_axioms" title="wikilink">Armstrong's axioms</a> to provide a proof - i.e. Reflexivity, Augmentation, Transitivity.</p>
<p>Given <span class="LaTeX">$R$</span> and <span class="LaTeX">$F$</span> a set of FD’s that holds in <span class="LaTeX">$R$</span>: The closure of <span class="LaTeX">$F$</span> in <span class="LaTeX">$R$</span> (denoted <span class="LaTeX">$F$</span><sup>+</sup>) is the set of all FD’s in that are logically implied by <span class="LaTeX">$F$</span></p>
<h3 id="closure-of-a-set-of-attributes">Closure of a set of attributes</h3>
<p>Closure of a set of attributes X with respect to <span class="LaTeX">$F$</span> is the set X<sup>+</sup> of all attributes that are functionally determined by X using <span class="LaTeX">$F$</span><sup>+</sup>.</p>
<h3 id="example">Example</h3>
<p>Imagine the following list of FD's. We are going to calculate a closure for A from this relationship.</p>
<p>1. <em>A</em> → <em>B</em><br/>
2. ''B → <em>C</em><br/>
3. <em>AB</em> → <em>D</em></p>
<p>The closure would be as follows:</p>
<p>a) A → A ( by Armstrong's reflexivity )<br/>
b) A → AB ( by 1. and (a ))<br/>
c) A → ABD ( by (b), 3, and Armstrong's transitivity )<br/>
d) A → ABCD ( by (c), and 2 )</p>
<p>The closure is therefore A → ABCD. By calculating the closure of A, we have validated that A is also a good candidate key as its closure is every single data value in the relationship.</p>
<h2 id="covers-and-equivalence">Covers and Equivalence</h2>
<h3 id="covers">Covers</h3>
<p><strong>Definition</strong><span class="LaTeX">$$F$$</span> covers <span class="LaTeX">$G$</span> if every FD in <span class="LaTeX">$G$</span> can be inferred from <span class="LaTeX">$F$</span>. <span class="LaTeX">$F$</span> covers <span class="LaTeX">$G$</span> if <span class="LaTeX">$G$</span><sup>+</sup> ⊆ <span class="LaTeX">$F$</span><sup>+</sup><br/>
Every set of functional dependencies has a <a href="canonical_cover" title="wikilink">canonical cover</a>.</p>
<h3 id="equivalence-of-two-sets-of-fds">Equivalence of two sets of FD's</h3>
<p>Two sets of FDs <span class="LaTeX">$F$</span> and <span class="LaTeX">$G$</span> over schema <span class="LaTeX">$R$</span> are equivalent, written <span class="LaTeX">$F$</span> ≡ <span class="LaTeX">$G$</span>, if <span class="LaTeX">$F$</span><sup>+</sup> = <span class="LaTeX">$G$</span><sup>+</sup>. If <span class="LaTeX">$F$</span> ≡ <span class="LaTeX">$G$</span>, then <span class="LaTeX">$F$</span> is a cover for <span class="LaTeX">$G$</span> and vice versa. In other words, equivalent sets of functional dependencies are called <em>covers</em> of each other.</p>
<h3 id="non-redundant-covers">Non-redundant Covers</h3>
<p>A set <span class="LaTeX">$F$</span> of FDs is nonredundant if there is no proper subset <span class="LaTeX">$F'$</span> of <span class="LaTeX">$F$</span> with <span class="LaTeX">$F'$</span> = <span class="LaTeX">$F$</span>. If such an <span class="LaTeX">$F'$</span> exists, <span class="LaTeX">$F$</span> is redundant. <span class="LaTeX">$F$</span> is a nonredundant cover for <span class="LaTeX">$G$</span> if <span class="LaTeX">$F$</span> is a cover for <span class="LaTeX">$G$</span> and <span class="LaTeX">$F$</span> is nonredundant.<br/>
An alternative characterization of nonredundancy is that <span class="LaTeX">$F$</span> is nonredundant if there is no FD <em>X</em> → <em>Y</em> in <span class="LaTeX">$F$</span> such that <span class="LaTeX">$F$</span> - {<em>X</em> → <em>Y</em>} <span class="LaTeX">$\models$</span> <em>X</em> → <em>Y</em>. Call an FD <em>X</em> → <em>Y</em> in <span class="LaTeX">$F$</span> redundunt in <span class="LaTeX">$F$</span> if <span class="LaTeX">$F$</span> - {<em>X</em> → <em>Y</em>} <span class="LaTeX">$\models$</span> <em>X</em> → <em>Y</em> Y.</p>
<h2 id="applications-to-normalization">Applications to normalization</h2>
<h3 id="heaths-theorem">Heath's theorem</h3>
<p>An important property (yielding an immediate application) of functional dependencies is that if <em>R</em> is a relation with columns named from some set of attributes <em>U</em> and <em>R</em> satisfies some functional dependency <em>X</em> → <em>Y</em> then <span class="LaTeX">$R=\pi_{XY}(R)\bowtie\pi_{XZ}(R)$</span> where <em>Z</em> = <em>U</em> − <em>XY</em>. Intuitively, if a functional dependency <em>X</em> → <em>Y</em> holds in <em>R</em>, then the relation can be safely split in two relations alongside the column <em>X</em> (which is a key for <span class="LaTeX">$\pi_{XY}(R)\bowtie\pi_{XZ}(R)$</span>) ensuring that when the two parts are joined back no data is lost, i.e. a functional dependency provides a simple way to construct a <a href="lossless-join_decomposition" title="wikilink">lossless-join decomposition</a> of <em>R</em> in two smaller relations. This fact is sometimes called <strong>Heath’s theorem</strong>; it is one of the early results in database theory.<ref> cited in:</ref></p>
<ul>
<li></li>
<li></li>
</ul>
<p></p>
<p>Heath’s theorem effectively says we can pull out the values of <em>Y</em> from the big relation <em>R</em> and store them into one, <span class="LaTeX">$\pi_{XY}(R)$</span>, which has no value repetitions in the row for <em>X</em> and is effectively a <a href="lookup_table" title="wikilink">lookup table</a> for <em>Y</em> keyed by <em>X</em> and consequently has only one place to update the <em>Y</em> corresponding to each <em>X</em> unlike the "big" relation <em>R</em> where there are potentially many copies of each <em>X</em>, each one with its copy of <em>Y</em> which need to be kept synchronized on updates. (This elimination of redundancy is an advantage in <a class="uri" href="OLTP" title="wikilink">OLTP</a> contexts, where many changes are expected, but not so much in <a class="uri" href="OLAP" title="wikilink">OLAP</a> contexts, which involve mostly queries.) Heath’s decomposition leaves only <em>X</em> to act as a <a href="foreign_key" title="wikilink">foreign key</a> in the remainder of the big table <span class="LaTeX">$\pi_{XZ}(R)$</span>.</p>
<p>Functional dependencies however should not be confused with <a href="inclusion_dependency" title="wikilink">inclusion dependencies</a>, which are the formalism for foreign keys; even though they are used for normalization, functional dependencies express constraints over one relation (schema), whereas inclusion dependencies express constraints between relation schemas in a <a href="database_schema" title="wikilink">database schema</a>.Furthermore, the two notions do not even intersect in the <a href="classification_of_dependencies" title="wikilink">classification of dependencies</a>: functional dependencies are <a href="equality-generating_dependencies" title="wikilink">equality-generating dependencies</a> whereas inclusion dependencies are <a href="tuple-generating_dependencies" title="wikilink">tuple-generating dependencies</a>. Enforcing referential constraints after relation schema decomposition (normalization) requires a new formalism, i.e. inclusion dependencies. In the decomposition resulting from Heath's theorem, there's nothing preventing the insertion of tuples in <span class="LaTeX">$\pi_{XZ}(R)$</span> having some value of <em>X</em> not found in <span class="LaTeX">$\pi_{XY}(R)$</span>.</p>
<h3 id="normal-forms">Normal forms</h3>
<p>Normal forms are <a href="database_normalization" title="wikilink">database normalization</a> levels which determine the "goodness" of a table. Generally, the <a href="third_normal_form" title="wikilink">third normal form</a> is considered to be a "good" standard for a relational database.</p>
<p>Normalization aims to free the database from update, insertion and deletion anomalies. It also ensures that when a new value is introduced into the relation, it has minimal effect on the database, and thus minimal effect on the applications using the database.</p>
<h2 id="irreducible-function-depending-set">Irreducible function depending set</h2>
<p>A functional depending set S is irreducible if the set has the following three properties:</p>
<ol>
<li>Each right set of a functional dependency of S contains only one attribute.</li>
<li>Each left set of a functional dependency of S is irreducible. It means that reducing any one attribute from left set will change the content of S (S will lose some information).</li>
<li>Reducing any functional dependency will change the content of S.</li>
</ol>
<p>Sets of Functional Dependencies(FD) with these properties are also called <em>canonical</em> or <em>minimal</em>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Chase_(algorithm)" title="wikilink">Chase (algorithm)</a></li>
<li><a href="Inclusion_dependency" title="wikilink">Inclusion dependency</a></li>
<li><a href="Join_dependency" title="wikilink">Join dependency</a></li>
<li><a href="Multivalued_dependency" title="wikilink">Multivalued dependency</a> (MVD)</li>
<li><a href="Database_normalization" title="wikilink">Database normalization</a></li>
<li><a href="First_normal_form" title="wikilink">First normal form</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<p>"</p>
<p><a href="Category:Data_modeling" title="wikilink">Category:Data modeling</a> <a href="Category:Database_constraints" title="wikilink">Category:Database constraints</a> <a href="Category:Database_theory" title="wikilink">Category:Database theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">M. Y. Vardi. <a href="http://www.cs.rice.edu/~vardi/papers/ttcs87.pdf">Fundamentals of dependency theory</a>. In E. Borger, editor, Trends in Theoretical Computer Science, pages 171–224. Computer Science Press, Rockville, MD, 1987. ISBN 0881750840<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
