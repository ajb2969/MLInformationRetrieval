   Interval arithmetic      Interval arithmetic    Interval arithmetic , interval mathematics , interval analysis , or interval computation , is a method developed by mathematicians since the 1950s and 1960s as an approach to putting bounds on rounding errors and measurement errors in mathematical computation and thus developing numerical methods that yield reliable results. Very simply put, it represents each value as a range of possibilities. For example, instead of estimating the height of someone using standard arithmetic as 2.0 metres, using interval arithmetic we might be certain that that person is somewhere between 1.97 and 2.03 metres.  Whereas classical arithmetic defines operations on individual numbers, interval arithmetic defines a set of operations on intervals :       T  *  S   =   {  x  |     there is some  y  in  T   ,   and some  z  in  S   ,   such that  x    =   y  *  z    }         T  S    conditional-set  x       there is some  y  in  T     and some  z  in  S     such that  x      y  z       T*S=\left\{x|\text{there is some }y\text{ in }T,\text{ and some }z\text{ in }S%
 ,\text{ such that }x=y*z\right\}   .  The basic operations of interval arithmetic are, for two intervals    [  a  ,  b  ]     a  b    [a,b]   and    [  c  ,  d  ]     c  d    [c,d]   that are subsets of the real line    (   -  ∞   ,  ∞  )            (-\infty,\infty)   ,         [  a  ,  b  ]   +   [  c  ,  d  ]    =   [   a  +  c   ,   b  +  d   ]          a  b    c  d       a  c     b  d      [a,b]+[c,d]=[a+c,b+d]   ,        [  a  ,  b  ]   -   [  c  ,  d  ]    =   [   a  -  d   ,   b  -  c   ]          a  b    c  d       a  d     b  c      [a,b]-[c,d]=[a-d,b-c]   ,        [  a  ,  b  ]   ⋅   [  c  ,  d  ]    =   [   min   (   a  c   ,   a  d   ,   b  c   ,   b  d   )    ,   max   (   a  c   ,   a  d   ,   b  c   ,   b  d   )    ]        normal-⋅   a  b    c  d         a  c     a  d     b  c     b  d        a  c     a  d     b  c     b  d       [a,b]\cdot[c,d]=\left[\min(ac,ad,bc,bd),\max(ac,ad,bc,bd)\right]   ,         [  a  ,  b  ]    [  c  ,  d  ]    =    [   min   (   a  c   ,   a  d   ,   b  c   ,   b  d   )    ,   max   (   a  c   ,   a  d   ,   b  c   ,   b  d   )    ]   when  0  is not in   [  c  ,  d  ]     .         a  b    c  d           a  c     a  d     b  c     b  d        a  c     a  d     b  c     b  d     when  0  is not in   c  d      \frac{[a,b]}{[c,d]}=\left[\min\left(\frac{a}{c},\frac{a}{d},\frac{b}{c},\frac{%
 b}{d}\right),\max\left(\frac{a}{c},\frac{a}{d},\frac{b}{c},\frac{b}{d}\right)%
 \right]\text{ when }0\text{ is not in }[c,d].      Division by an interval containing zero is not defined under the basic interval arithmetic. The addition and multiplication operations are commutative , associative and sub- distributive : the set    X   (   Y  +  Z   )       X    Y  Z     X(Y+Z)   is a subset of     X  Y   +   X  Z         X  Y     X  Z     XY+XZ   .  Instead of working with an uncertain real    x   x   x   we work with the two ends of the interval    [  a  ,  b  ]     a  b    [a,b]   which contains   x   x   x      x   x   x   lies between   a   a   a   and   b   b   b   , or could be one of them. Similarly a function   f   f   f   when applied to   x   x   x   is also uncertain. Instead, in interval arithmetic   f   f   f   produces an interval    [  c  ,  d  ]     c  d    [c,d]   which is all the possible values for    f   (  x  )       f  x    f(x)   for all    x  ∈   [  a  ,  b  ]       x   a  b     x\in[a,b]   .  This concept is suitable for a variety of purposes. The most common use is to keep track of and handle rounding errors directly during the calculation and of uncertainties in the knowledge of the exact values of physical and technical parameters. The latter often arise from measurement errors and tolerances for components or due to limits on computational accuracy. Interval arithmetic also helps find reliable and guaranteed solutions to equations and optimization problems.  Introduction  The main focus in the interval arithmetic is on the simplest way to calculate upper and lower endpoints for the range of values of a function in one or more variables. These barriers are not necessarily the supremum or infimum , since the precise calculation of those values can be difficult or impossible.  Treatment is typically limited to real intervals, so quantities of form        [  a  ,  b  ]   =   {   x  ∈   ℝ    |   a  ≤  x  ≤  b   }    ,       a  b    conditional-set    x  ℝ       a  x       b       [a,b]=\{x\in\mathbb{R}\,|\,a\leq x\leq b\},   where    a  =   -  ∞       a        a={-\infty}   and    b  =  ∞      b     b={\infty}   are allowed; with one of them infinite we would have an unbounded interval, while with both infinite we would have the extended real number line.  As with traditional calculations with real numbers, simple arithmetic operations and functions on elementary intervals must first be defined. 1 More complicated functions can be calculated from these basic elements. 2  Example  Take as an example the calculation of body mass index (BMI). The BMI is the body weight in kilograms divided by the square of height in metres. Measuring the mass with bathroom scales may have an accuracy of one kilogram. We will not know intermediate values - about 79.6 kg or 80.3 kg - but information rounded to the nearest whole number. It is unlikely that when the scale reads 80 kg, someone really weighs exactly 80.0 kg. In normal rounding to the nearest value, the scales showing 80 kg indicates a weight between 79.5 kg and 80.5 kg. The relevant range is that of all real numbers that are greater than or equal to 79.5, while less than or equal to 80.5, or in other words the interval [79.5,80.5].  For a man who weighs 80 kg and is 1.80 m tall, the BMI is about 24.7. With a weight of 79.5 kg and the same height the value is 24.5, while 80.5 kilograms gives almost 24.9. So the actual BMI is in the range [24.5,24.9]. The error in this case does not affect the conclusion (normal weight), but this is not always the position. For example, weight fluctuates in the course of a day so that the BMI can vary between 24 (normal weight) and 25 (overweight). Without detailed analysis it is not possible to always exclude questions as to whether an error ultimately is large enough to have significant influence.  Interval arithmetic states the range of possible outcomes explicitly. Simply put, results are no longer stated as numbers, but as intervals which represent imprecise values. The size of the intervals are similar to error bars to a metric in expressing the extent of uncertainty. Simple arithmetic operations, such as basic arithmetic and trigonometric functions, enable the calculation of outer limits of intervals.  Simple arithmetic  Returning to the earlier BMI example, in determining the body mass index, height and body weight both affect the result. For height, measurements are usually in round centimetres: a recorded measurement of 1.80 metres actually means a height somewhere between 1.795 m and 1.805 m. This uncertainty must be combined with the fluctuation range in weight between 79.5 kg and 80.5 kg. The BMI is defined as the weight in kilograms divided by the square of height in metre. Using either 79.5 kg and 1.795 m or 80.5 kg and 1.805 m gives approximately 24.7. But the person in question may only be 1.795 m tall, with a weight of 80.5 kilograms - or 1.805 m and 79.5 kilograms: all combinations of all possible intermediate values must be considered. Using the interval arithmetic methods described below, the BMI lies in the interval         [  79.5  ;  80.5  ]   /    (   [  1.795  ;  1.805  ]   )   2    =   [  24.4  ;  25.0  ]    .         79.5  80.5    superscript   1.795  1.805   2     24.4  25.0     [79{.}5;80{.}5]/([1{.}795;1{.}805])^{2}=[24{.}4;25{.}0].     An operation    ⟨   op   ⟩     delimited-⟨⟩  op    {\langle\!\mathrm{op}\!\rangle}   , such as addition or multiplication, on two intervals is defined by        [   x  1   ,   x  2   ]    ⟨   op   ⟩    [   y  1   ,   y  2   ]    =   {    x    ⟨   op   ⟩    y    |   x  ∈    [   x  1   ,   x  2   ]    and   y   ∈   [   y  1   ,   y  2   ]    }           subscript  x  1    subscript  x  2     delimited-⟨⟩  op     subscript  y  1    subscript  y  2      conditional-set    x   delimited-⟨⟩  op   y       x      subscript  x  1    subscript  x  2    and  y          subscript  y  1    subscript  y  2         [x_{1},x_{2}]{\,\langle\!\mathrm{op}\!\rangle\,}[y_{1},y_{2}]=\{x{\,\langle\!%
 \mathrm{op}\!\rangle\,}y\,|\,x\in[x_{1},x_{2}]\,\mbox{and}\,y\in[y_{1},y_{2}]\}   . For the four basic arithmetic operations this can become       [  ]    [   x  1   ,   x  2   ]    ⟨   op   ⟩    [   y  1   ,   y  2   ]          subscript  x  1    subscript  x  2     delimited-⟨⟩  op     subscript  y  1    subscript  y  2      \displaystyle[][x_{1},x_{2}]\,\langle\!\mathrm{op}\!\rangle\,[y_{1},y_{2}]     provided that     x    ⟨   op   ⟩   y      x   delimited-⟨⟩  op   y    x{\,\langle\!\mathrm{op}\!\rangle\,}y   is allowed for all    x  ∈   [   x  1   ,   x  2   ]       x    subscript  x  1    subscript  x  2      x\in[x_{1},x_{2}]   and    y  ∈   [   y  1   ,   y  2   ]       y    subscript  y  1    subscript  y  2      y\in[y_{1},y_{2}]   .  For practical applications this can be simplified further:   Addition       [   x  1   ,   x  2   ]   +   [   y  1   ,   y  2   ]    =   [    x  1   +   y  1    ,    x  2   +   y  2    ]           subscript  x  1    subscript  x  2      subscript  y  1    subscript  y  2         subscript  x  1    subscript  y  1       subscript  x  2    subscript  y  2       [x_{1},x_{2}]+[y_{1},y_{2}]=[x_{1}+y_{1},x_{2}+y_{2}]     Subtraction       [   x  1   ,   x  2   ]   -   [   y  1   ,   y  2   ]    =   [    x  1   -   y  2    ,    x  2   -   y  1    ]           subscript  x  1    subscript  x  2      subscript  y  1    subscript  y  2         subscript  x  1    subscript  y  2       subscript  x  2    subscript  y  1       [x_{1},x_{2}]-[y_{1},y_{2}]=[x_{1}-y_{2},x_{2}-y_{1}]     Multiplication       [   x  1   ,   x  2   ]   ⋅   [   y  1   ,   y  2   ]    =   [   min   (    x  1    y  1    ,    x  1    y  2    ,    x  2    y  1    ,    x  2    y  2    )    ,   max   (    x  1    y  1    ,    x  1    y  2    ,    x  2    y  1    ,    x  2    y  2    )    ]        normal-⋅    subscript  x  1    subscript  x  2      subscript  y  1    subscript  y  2           subscript  x  1    subscript  y  1       subscript  x  1    subscript  y  2       subscript  x  2    subscript  y  1       subscript  x  2    subscript  y  2          subscript  x  1    subscript  y  1       subscript  x  1    subscript  y  2       subscript  x  2    subscript  y  1       subscript  x  2    subscript  y  2        [x_{1},x_{2}]\cdot[y_{1},y_{2}]=[\min(x_{1}y_{1},x_{1}y_{2},x_{2}y_{1},x_{2}y_%
 {2}),\max(x_{1}y_{1},x_{1}y_{2},x_{2}y_{1},x_{2}y_{2})]     Division : [x_1, x_2] / [y_1, y_2] =   [x_1, x_2] \cdot (1/[y_1, y_2]), where     1  /   [   y  1   ,   y  2   ]    =   [   1  /   y  2    ,   1  /   y  1    ]         1    subscript  y  1    subscript  y  2        1   subscript  y  2      1   subscript  y  1       1/[y_{1},y_{2}]=[1/y_{2},1/y_{1}]   if    0  ∉   [   y  1   ,   y  2   ]       0    subscript  y  1    subscript  y  2      0\notin[y_{1},y_{2}]   .  For division by an interval including zero, first define       1  /   [   y  1   ,  0  ]    =   [   -  ∞   ,   1  /   y  1    ]         1    subscript  y  1   0           1   subscript  y  1       1/[y_{1},0]=[-\infty,1/y_{1}]   and     1  /   [  0  ,   y  2   ]    =   [   1  /   y  2    ,  ∞  ]         1   0   subscript  y  2        1   subscript  y  2        1/[0,y_{2}]=[1/y_{2},\infty]   . For     y  1   <  0  <   y  2          subscript  y  1   0        subscript  y  2      y_{1}<0   , we get     1  /   [   y  1   ,   y  2   ]    =    [   -  ∞   ,   1  /   y  1    ]   ∪   [   1  /   y  2    ,  ∞  ]          1    subscript  y  1    subscript  y  2              1   subscript  y  1        1   subscript  y  2         1/[y_{1},y_{2}]=[-\infty,1/y_{1}]\cup[1/y_{2},\infty]   which as a single interval gives     1  /   [   y  1   ,   y  2   ]    =   [   -  ∞   ,  ∞  ]         1    subscript  y  1    subscript  y  2              1/[y_{1},y_{2}]=[-\infty,\infty]   ; this loses useful information about    (   1  /   y  1    ,   1  /   y  2    )       1   subscript  y  1      1   subscript  y  2      (1/y_{1},1/y_{2})   . So typically it is common to work with    [   -  ∞   ,   1  /   y  1    ]           1   subscript  y  1      [-\infty,1/y_{1}]   and    [   1  /   y  2    ,  ∞  ]       1   subscript  y  2       [1/y_{2},\infty]   as separate intervals.  Because several such divisions may occur in an interval arithmetic calculation, it is sometimes useful to do the calculation with so-called multi-intervals of the form     ⋃   i  =  1   l    [   x   i  1    ,   x   i  2    ]       superscript   subscript     i  1    l     subscript  x    i  1     subscript  x    i  2       \textstyle\bigcup_{i=1}^{l}[x_{i1},x_{i2}]   . The corresponding multi-interval arithmetic maintains a disjoint set of intervals and also provides for overlapping intervals to unite. 3  Since a real number    r  ∈  ℝ      r  ℝ    r\in\mathbb{R}   can be interpreted as the interval    [  r  ,  r  ]     r  r    [r,r]   , intervals and real numbers can be freely and easily combined.  With the help of these definitions, it is already possible to calculate the range of simple functions, such as     f   (  a  ,  b  ,  x  )    =    a  ⋅  x   +  b         f   a  b  x       normal-⋅  a  x   b     f(a,b,x)=a\cdot x+b   . If, for example,    a  =   [  1  ,  2  ]       a   1  2     a=[1,2]   ,    b  =   [  5  ,  7  ]       b   5  7     b=[5,7]   and    x  =   [  2  ,  3  ]       x   2  3     x=[2,3]   , it is clear       f   (  a  ,  b  ,  x  )    =    (    [  1  ,  2  ]   ⋅   [  2  ,  3  ]    )   +   [  5  ,  7  ]    =    [   1  ⋅  2   ,   2  ⋅  3   ]   +   [  5  ,  7  ]    =   [  7  ,  13  ]           f   a  b  x       normal-⋅   1  2    2  3     5  7             normal-⋅  1  2    normal-⋅  2  3     5  7          7  13      f(a,b,x)=([1,2]\cdot[2,3])+[5,7]=[1\cdot 2,2\cdot 3]+[5,7]=[7,13]   .  Interpreting this as a function    f   (  a  ,  b  ,  x  )       f   a  b  x     f(a,b,x)   of the variable   x   x   x   with interval parameters   a   a   a   and   b   b   b   , then it is possible to find the roots of this function. It is then         f   (   [  1  ,  2  ]   ,   [  5  ,  7  ]   ,  x  )    =    (    [  1  ,  2  ]   ⋅  x   )   +   [  5  ,  7  ]    =  0   ⇔     [  1  ,  2  ]   ⋅  x   =   [   -  7   ,   -  5   ]    ⇔   x  =    [   -  7   ,   -  5   ]   /   [  1  ,  2  ]      ,       normal-⇔        f    1  2    5  7   x       normal-⋅   1  2   x    5  7         0       normal-⋅   1  2   x      7     5       normal-⇔      x       7     5     1  2        f([1,2],[5,7],x)=([1,2]\cdot x)+[5,7]=0\Leftrightarrow[1,2]\cdot x=[-7,-5]%
 \Leftrightarrow x=[-7,-5]/[1,2],   the possible zeros are in the interval    [   -  7   ,   -  2.5   ]       7     2.5     [-7,{-2.5}]   .  As in the above example, the multiplication of intervals often only requires two multiplications. It is in fact         [   x  1   ,   x  2   ]   ⋅   [   y  1   ,   y  2   ]    =    [    x  1   ⋅   y  1    ,    x  2   ⋅   y  2    ]   ,   if   x  1      ,    y  1   ≥  0.      formulae-sequence     normal-⋅    subscript  x  1    subscript  x  2      subscript  y  1    subscript  y  2        normal-⋅   subscript  x  1    subscript  y  1     normal-⋅   subscript  x  2    subscript  y  2       if   subscript  x  1         subscript  y  1   0.     [x_{1},x_{2}]\cdot[y_{1},y_{2}]=[x_{1}\cdot y_{1},x_{2}\cdot y_{2}],\text{ if %
 }x_{1},y_{1}\geq 0.     The multiplication can be seen as a destination area of a rectangle with varying edges. The result interval covers all levels from the smallest to the largest.  The same applies when one of the two intervals is non-positive and the other non-negative. Generally, multiplication can produce results as wide as    [   -  ∞   ,  ∞  ]            [-\infty,\infty]   , for example if    0  ⋅  ∞     normal-⋅  0     0\cdot\infty   is squared. This also occurs, for example, in a division, if the numerator and denominator both contain zero.  Notation  To make the notation of intervals smaller in formulae, brackets can be used.  So we can use     [  x  ]   ≡   [   x  1   ,   x  2   ]        delimited-[]  x     subscript  x  1    subscript  x  2      [x]\equiv[x_{1},x_{2}]   to represent an interval. For the set of all finite intervals, we can use       [  ℝ  ]   :=   {   [   x  1   ,   x  2   ]   |     x  1   ≤    x  2   and   x  1     ,    x  2   ∈   ℝ  ∪   {   -  ∞   ,  ∞  }      }      assign   delimited-[]  ℝ    conditional-set    subscript  x  1    subscript  x  2     formulae-sequence     subscript  x  1      subscript  x  2   and   subscript  x  1        subscript  x  2     ℝ               [\mathbb{R}]:=\big\{\,[x_{1},x_{2}]\,|\,x_{1}\leq x_{2}\text{ and }x_{1},x_{2}%
 \in\mathbb{R}\cup\{-\infty,\infty\}\big\}     as an abbreviation. For a vector of intervals     (    [  x  ]   1   ,  …  ,    [  x  ]   n   )   ∈    [  ℝ  ]   n         subscript   delimited-[]  x   1   normal-…   subscript   delimited-[]  x   n     superscript   delimited-[]  ℝ   n     \big([x]_{1},\ldots,[x]_{n}\big)\in[\mathbb{R}]^{n}   we can also use a bold font    [  𝐱  ]     delimited-[]  𝐱    [\mathbf{x}]   .  Note that in such a compact notation,    [  x  ]     delimited-[]  x    [x]   should not be confused between a so-called improper or single point interval    [   x  1   ,   x  1   ]      subscript  x  1    subscript  x  1     [x_{1},x_{1}]   and the lower and upper limit.  Elementary functions  Interval methods can also apply to functions which do not just use simple arithmetic, and we must also use other basic functions for redefining intervals, using already known monotonicity properties.  For monotonic functions in one variable, the range of values is also easy. If    f  :   ℝ  →  ℝ      normal-:  f   normal-→  ℝ  ℝ     f:\mathbb{R}\rightarrow\mathbb{R}   is monotonically rising or falling in the interval    [   x  1   ,   x  2   ]      subscript  x  1    subscript  x  2     [x_{1},x_{2}]   , then for all values in the interval      y  1   ,   y  2    ∈   [   x  1   ,   x  2   ]         subscript  y  1    subscript  y  2      subscript  x  1    subscript  x  2      y_{1},y_{2}\in[x_{1},x_{2}]   such that     y  1   ≤   y  2        subscript  y  1    subscript  y  2     y_{1}\leq y_{2}   , one of the following inequalities applies:       f   (   y  1   )    ≤   f   (   y  2   )          f   subscript  y  1      f   subscript  y  2      f(y_{1})\leq f(y_{2})   , or     f   (   y  1   )    ≥   f   (   y  2   )          f   subscript  y  1      f   subscript  y  2      f(y_{1})\geq f(y_{2})   .  The range corresponding to the interval     [   y  1   ,   y  2   ]   ⊆   [   x  1   ,   x  2   ]         subscript  y  1    subscript  y  2      subscript  x  1    subscript  x  2      [y_{1},y_{2}]\subseteq[x_{1},x_{2}]   can be calculated by applying the function to the endpoints    y  1     subscript  y  1    y_{1}   and    y  2     subscript  y  2    y_{2}   :       f   (   [   y  1   ,   y  2   ]   )    =   [   min   {   f   (   y  1   )    ,   f   (   y  2   )    }    ,   max   {   f   (   y  1   )    ,   f   (   y  2   )    }    ]         f    subscript  y  1    subscript  y  2          f   subscript  y  1      f   subscript  y  2         f   subscript  y  1      f   subscript  y  2        f([y_{1},y_{2}])=\left[\min\big\{f(y_{1}),f(y_{2})\big\},\max\big\{f(y_{1}),f(%
 y_{2})\big\}\right]   .  From this the following basic features for interval functions can easily be defined:   Exponential function      a   [   x  1   ,   x  2   ]    =   [   a   x  1    ,   a   x  2    ]        superscript  a    subscript  x  1    subscript  x  2       superscript  a   subscript  x  1     superscript  a   subscript  x  2       a^{[x_{1},x_{2}]}=[a^{x_{1}},a^{x_{2}}]   , for    a  >  1      a  1    a>1   ,  Logarithm       log  a    (   [   x  1   ,   x  2   ]   )    =   [    log  a    x  1    ,    log  a    x  2    ]         subscript   a     subscript  x  1    subscript  x  2        subscript   a    subscript  x  1      subscript   a    subscript  x  2       \log_{a}\big({[x_{1},x_{2}]}\big)=[\log_{a}{x_{1}},\log_{a}{x_{2}}]   , for positive intervals    [   x  1   ,   x  2   ]      subscript  x  1    subscript  x  2     [x_{1},x_{2}]   and    a  >  1      a  1    a>1     Odd powers      [   x  1   ,   x  2   ]   n   =   [   x  1    n   ,   x  2    n   ]        superscript    subscript  x  1    subscript  x  2    n     superscript   subscript  x  1   n    superscript   subscript  x  2   n      {[x_{1},x_{2}]}^{n}=[{x_{1}}^{n},{x_{2}}^{n}]   , for odd    n  ∈  ℕ      n  ℕ    n\in\mathbb{N}   .   For even powers, the range of values being considered is important, and needs to be dealt with before doing any multiplication. For example    x  n     superscript  x  n    x^{n}   for    x  ∈   [   -  1   ,  1  ]       x     1   1     x\in[-1,1]   should produce the interval    [  0  ,  1  ]     0  1    [0,1]   when    n  =   2  ,  4  ,  6  ,  …       n   2  4  6  normal-…     n=2,4,6,\ldots   . But if     [   -  1   ,  1  ]   n     superscript     1   1   n    [-1,1]^{n}   is taken by applying interval multiplication of form     [   -  1   ,  1  ]   ⋅  …  ⋅   [   -  1   ,  1  ]      normal-⋅     1   1   normal-…     1   1     [-1,1]\cdot\ldots\cdot[-1,1]   then the result will appear to be    [   -  1   ,  1  ]       1   1    [-1,1]   , wider than necessary.  Instead consider the function    x  n     superscript  x  n    x^{n}   as a monotonically decreasing function for    x  <  0      x  0    x<0   and a monotonically increasing function for    x  >  0      x  0    x>0   . So for even    n  ∈  ℕ      n  ℕ    n\in\mathbb{N}   :         [   x  1   ,   x  2   ]   n   =   [   x  1  n   ,   x  2  n   ]        superscript    subscript  x  1    subscript  x  2    n     superscript   subscript  x  1   n    superscript   subscript  x  2   n      {[x_{1},x_{2}]}^{n}=[x_{1}^{n},x_{2}^{n}]   , if     x  1   ≥  0       subscript  x  1   0    x_{1}\geq 0   ,        [   x  1   ,   x  2   ]   n   =   [   x  2  n   ,   x  1  n   ]        superscript    subscript  x  1    subscript  x  2    n     superscript   subscript  x  2   n    superscript   subscript  x  1   n      {[x_{1},x_{2}]}^{n}=[x_{2}^{n},x_{1}^{n}]   , if     x  2   <  0       subscript  x  2   0    x_{2}<0   ,        [   x  1   ,   x  2   ]   n   =   [  0  ,   max   {   x  1  n   ,   x  2  n   }    ]        superscript    subscript  x  1    subscript  x  2    n    0     superscript   subscript  x  1   n    superscript   subscript  x  2   n       {[x_{1},x_{2}]}^{n}=[0,\max\{x_{1}^{n},x_{2}^{n}\}]   , otherwise.   More generally, one can say that for piecewise monotonic functions it is sufficient to consider the endpoints     x  1   ,   x  2       subscript  x  1    subscript  x  2     x_{1},x_{2}   of the interval    [   x  1   ,   x  2   ]      subscript  x  1    subscript  x  2     [x_{1},x_{2}]   , together with the so-called critical points within the interval being those points where the monotonicity of the function changes direction.  For the sine and cosine functions, the critical points are at     (    /    1     +   2    n  )   ⋅  π     fragments   fragments  normal-(   superscript   1    subscript   2   n  normal-)   normal-⋅  π    \left({}^{1}\!\!/\!{}_{2}+{n}\right)\cdot\pi   or    n  ⋅  π     normal-⋅  n  π    {n}\cdot\pi   for all    n  ∈  ℤ      n  ℤ    n\in\mathbb{Z}   respectively. Only up to five points matter as the resulting interval will be    [   -  1   ,  1  ]       1   1    [-1,1]   if the interval includes at least two extrema. For sine and cosine, only the endpoints need full evaluation as the critical points lead to easily pre-calculated values – namely -1, 0, +1.  Interval extensions of general functions  In general, it may not be easy to find such a simple description of the output interval for many functions. But it may still be possible to extend functions to interval arithmetic. If    f  :    ℝ  n   →  ℝ      normal-:  f   normal-→   superscript  ℝ  n   ℝ     f:\mathbb{R}^{n}\rightarrow\mathbb{R}   is a function from a real vector to a real number, then     [  f  ]   :     [  ℝ  ]   n   →   [  ℝ  ]       normal-:   delimited-[]  f    normal-→   superscript   delimited-[]  ℝ   n    delimited-[]  ℝ      [f]:[\mathbb{R}]^{n}\rightarrow[\mathbb{R}]   is called an interval extension of   f   f   f   if        [  f  ]    (   [  𝐱  ]   )    ⊇   {   f   (  𝐲  )    |   𝐲  ∈   [  𝐱  ]    }        conditional-set    f  𝐲     𝐲   delimited-[]  𝐱        delimited-[]  f    delimited-[]  𝐱      [f]([\mathbf{x}])\supseteq\{f(\mathbf{y})|\mathbf{y}\in[\mathbf{x}]\}   .  This definition of the interval extension does not give a precise result. For example, both      [  f  ]    (   [   x  1   ,   x  2   ]   )    =   [   e   x  1    ,   e   x  2    ]          delimited-[]  f     subscript  x  1    subscript  x  2       superscript  e   subscript  x  1     superscript  e   subscript  x  2       [f]([x_{1},x_{2}])=[e^{x_{1}},e^{x_{2}}]   and      [  g  ]    (   [   x  1   ,   x  2   ]   )    =   [   -  ∞   ,  ∞  ]          delimited-[]  g     subscript  x  1    subscript  x  2              [g]([x_{1},x_{2}])=[{-\infty},{\infty}]   are allowable extensions of the exponential function. Extensions as tight as possible are desirable, taking into the relative costs of calculation and imprecision; in this case    [  f  ]     delimited-[]  f    [f]   should be chosen as it give the tightest possible result.  The natural interval extension is achieved by combining the function rule    f   (   x  1   ,  ⋯  ,   x  n   )       f    subscript  x  1   normal-⋯   subscript  x  n      f(x_{1},\cdots,x_{n})   with the equivalents of the basic arithmetic and elementary functions.  The Taylor interval extension (of degree   k   k   k   ) is a    k  +  1      k  1    k+1   times differentiable function   f   f   f   defined by        [  f  ]    (   [  𝐱  ]   )    :=    f   (  𝐲  )    +    ∑   i  =  1   k      1   i  !     D  i   f   (  𝐲  )    ⋅    (    [  𝐱  ]   -  𝐲   )   i     +    [  r  ]    (   [  𝐱  ]   ,   [  𝐱  ]   ,  𝐲  )        assign     delimited-[]  f    delimited-[]  𝐱        f  𝐲     superscript   subscript     i  1    k    normal-⋅      1    i     superscript  normal-D  i   f  𝐲    superscript     delimited-[]  𝐱   𝐲   i        delimited-[]  r     delimited-[]  𝐱    delimited-[]  𝐱   𝐲       [f]([\mathbf{x}]):=f(\mathbf{y})+\sum_{i=1}^{k}\frac{1}{i!}\mathrm{D}^{i}f(%
 \mathbf{y})\cdot([\mathbf{x}]-\mathbf{y})^{i}+[r]([\mathbf{x}],[\mathbf{x}],%
 \mathbf{y})   , for some    𝐲  ∈   [  𝐱  ]       𝐲   delimited-[]  𝐱     \mathbf{y}\in[\mathbf{x}]   , where     D  i   f   (  𝐲  )        superscript  normal-D  i   f  𝐲    \mathrm{D}^{i}f(\mathbf{y})   is the   i   i   i   th order differential of   f   f   f   at the point   𝐲   𝐲   \mathbf{y}   and    [  r  ]     delimited-[]  r    [r]   is an interval extension of the Taylor remainder        r   (  𝐱  ,  ξ  ,  𝐲  )    =     1    (   k  +  1   )   !     D   k  +  1    f   (  ξ  )    ⋅    (   𝐱  -  𝐲   )    k  +  1      .        r   𝐱  ξ  𝐲     normal-⋅      1      k  1      superscript  normal-D    k  1    f  ξ    superscript    𝐱  𝐲     k  1       r(\mathbf{x},\xi,\mathbf{y})=\frac{1}{(k+1)!}\mathrm{D}^{k+1}f(\xi)\cdot(%
 \mathbf{x}-\mathbf{y})^{k+1}.     The vector   ξ   ξ   \xi   lies between   𝐱   𝐱   \mathbf{x}   and   𝐲   𝐲   \mathbf{y}   with     𝐱  ,  𝐲   ∈   [  𝐱  ]        𝐱  𝐲    delimited-[]  𝐱     \mathbf{x},\mathbf{y}\in[\mathbf{x}]   ,   ξ   ξ   \xi   is protected by    [  𝐱  ]     delimited-[]  𝐱    [\mathbf{x}]   . Usually one chooses   𝐲   𝐲   \mathbf{y}   to be the midpoint of the interval and uses the natural interval extension to assess the remainder.  The special case of the Taylor interval extension of degree    k  =  0      k  0    k=0   is also referred to as the mean value form . For an interval extension of the Jacobian      [   J  f   ]    (   [  𝐱  ]   )        delimited-[]   subscript  J  f     delimited-[]  𝐱     [J_{f}](\mathbf{[x]})   we get        [  f  ]    (   [  𝐱  ]   )    :=    f   (  𝐲  )    +     [   J  f   ]    (   [  𝐱  ]   )    ⋅   (    [  𝐱  ]   -  𝐲   )        assign     delimited-[]  f    delimited-[]  𝐱        f  𝐲    normal-⋅     delimited-[]   subscript  J  f     delimited-[]  𝐱       delimited-[]  𝐱   𝐲       [f]([\mathbf{x}]):=f(\mathbf{y})+[J_{f}](\mathbf{[x]})\cdot([\mathbf{x}]-%
 \mathbf{y})   .  A nonlinear function can be defined by linear features.  Complex interval arithmetic  An interval can also be defined as a locus of points at a given distance from the centre, and this definition can be extended from real numbers to complex numbers . 4 As it is the case with computing with real numbers, computing with complex numbers involves uncertain data. So, given the fact that an interval number is a real closed interval and a complex number is an ordered pair of real numbers , there is no reason to limit the application of interval arithmetic to the measure of uncertainties in computations with real numbers. 5 Interval arithmetic can thus be extended, via complex interval numbers , to determine regions of uncertainty in computing with complex numbers. 6  The basic algebraic operations for real interval numbers (real closed intervals) can be extended to complex numbers. It is therefore not surprising that complex interval arithmetic is similar to, but not the same as, ordinary complex arithmetic. 7 It can be shown that, as it is the case with real interval arithmetic, there is no distributivity between addition and multiplication of complex interval numbers except for certain special cases, and inverse elements do not always exist for complex interval numbers. 8 Two other useful properties of ordinary complex arithmetic fail to hold in complex interval arithmetic: the additive and multiplicative properties, of ordinary complex conjugates, do not hold for complex interval conjugates. 9  Interval arithmetic can be extended, in an analogous manner, to other multidimensional number systems such as quaternions and octonions , but with the expense that we have to sacrifice other useful properties of ordinary arithmetic. 10  Interval methods  The methods of classical numerical analysis can not be transferred one-to-one into interval-valued algorithms, as dependencies between numerical values are usually not taken into account.  Rounded interval arithmetic  In order to work effectively in a real-life implementation, intervals must be compatible with floating point computing. The earlier operations were based on exact arithmetic, but in general fast numerical solution methods may not be available. The range of values of the function     f   (  x  ,  y  )    =   x  +  y         f   x  y      x  y     f(x,y)=x+y   for    x  ∈   [  0.1  ,  0.8  ]       x   0.1  0.8     x\in[0.1,0.8]   and    y  ∈   [  0.06  ,  0.08  ]       y   0.06  0.08     y\in[0.06,0.08]   are for example    [  0.16  ,  0.88  ]     0.16  0.88    [0.16,0.88]   . Where the same calculation is done with single digit precision, the result would normally be    [  0.2  ,  0.9  ]     0.2  0.9    [0.2,0.9]   . But     [  0.2  ,  0.9  ]   ⊉   [  0.16  ,  0.88  ]      not-superset-of-or-equals   0.2  0.9    0.16  0.88     [0.2,0.9]\not\supseteq[0.16,0.88]   , so this approach would contradict the basic principles of interval arithmetic, as a part of the domain of    f   (   [  0.1  ,  0.8  ]   ,   [  0.06  ,  0.08  ]   )       f    0.1  0.8    0.06  0.08      f([0.1,0.8],[0.06,0.08])   would be lost. Instead, it is the outward rounded solution    [  0.1  ,  0.9  ]     0.1  0.9    [0.1,0.9]   which is used.  The standard IEEE 754 for binary floating-point arithmetic also sets out procedures for the implementation of rounding. An IEEE 754 compliant system allows programmers to round to the nearest floating point number; alternatives are rounding towards 0 (truncating), rounding toward positive infinity (i.e. up), or rounding towards negative infinity (i.e. down).  The required external rounding for interval arithmetic can thus be achieved by changing the rounding settings of the processor in the calculation of the upper limit (up) and lower limit (down). Alternatively, an appropriate small interval    [   ε  1   ,   ε  2   ]      subscript  ε  1    subscript  ε  2     [\varepsilon_{1},\varepsilon_{2}]   can be added.  Dependency problem  The so-called dependency problem is a major obstacle to the application of interval arithmetic. Although interval methods can determine the range of elementary arithmetic operations and functions very accurately, this is not always true with more complicated functions. If an interval occurs several times in a calculation using parameters, and each occurrence is taken independently then this can lead to an unwanted expansion of the resulting intervals.  As an illustration, take the function   f   f   f   defined by     f   (  x  )    =    x  2   +  x         f  x      superscript  x  2   x     f(x)=x^{2}+x   . The values of this function over the interval    [   -  1   ,  1  ]       1   1    [-1,1]   are really    [   -   1  /  4    ,  2  ]         1  4    2    [-1/4,2]   . As the natural interval extension, it is calculated as       [   -  1   ,  1  ]   2   +   [   -  1   ,  1  ]    =    [  0  ,  1  ]   +   [   -  1   ,  1  ]    =   [   -  1   ,  2  ]            superscript     1   1   2      1   1       0  1      1   1            1   2      [-1,1]^{2}+[-1,1]=[0,1]+[-1,1]=[-1,2]   , which is slightly larger; we have instead calculated the infimum and supremum of the function     h   (  x  ,  y  )    =    x  2   +  y         h   x  y       superscript  x  2   y     h(x,y)=x^{2}+y   over     x  ,  y   ∈   [   -  1   ,  1  ]        x  y      1   1     x,y\in[-1,1]   . There is a better expression of   f   f   f   in which the variable   x   x   x   only appears once, namely by rewriting     f   (  x  )    =    x  2   +  x         f  x      superscript  x  2   x     f(x)=x^{2}+x   as addition and squaring in the quadratic     f   (  x  )    =     (   x  +   1  2    )   2   -   1  4          f  x      superscript    x    1  2    2     1  4      f(x)=\left(x+\frac{1}{2}\right)^{2}-\frac{1}{4}   .  So the suitable interval calculation is         (    [   -  1   ,  1  ]   +   1  2    )   2   -   1  4    =     [   -   1  2    ,   3  2   ]   2   -   1  4    =    [  0  ,   9  4   ]   -   1  4    =   [   -   1  4    ,  2  ]            superscript       1   1     1  2    2     1  4       superscript       1  2      3  2    2     1  4            0    9  4      1  4              1  4    2      \left([-1,1]+\frac{1}{2}\right)^{2}-\frac{1}{4}=\left[-\frac{1}{2},\frac{3}{2}%
 \right]^{2}-\frac{1}{4}=\left[0,\frac{9}{4}\right]-\frac{1}{4}=\left[-\frac{1}%
 {4},2\right]   and gives the correct values.  In general, it can be shown that the exact range of values can be achieved, if each variable appears only once and if   f   f   f   is continuous inside the box. However, not every function can be rewritten this way.  The dependency of the problem causing over-estimation of the value range can go as far as covering a large range, preventing more meaningful conclusions.  An additional increase in the range stems from the solution of areas that do not take the form of an interval vector. The solution set of the linear system        x    =    p      y    =    p        x   p    y   p     \begin{matrix}x&=&p\\
 y&=&p\end{matrix}   for    p  ∈   [   -  1   ,  1  ]       p     1   1     p\in[-1,1]   is precisely the line between the points    (   -  1   ,   -  1   )       1     1     (-1,-1)   and    (  1  ,  1  )     1  1    (1,1)   . Interval methods deliver the best case, but in the square     [   -  1   ,  1  ]   ×   [   -  1   ,  1  ]          1   1      1   1     [-1,1]\times[-1,1]   , The real solution is contained in this square (this is known as the wrapping effect ).  Linear interval systems  A linear interval system consists of a matrix interval extension     [  𝐀  ]   ∈    [  ℝ  ]    n  ×  m         delimited-[]  𝐀    superscript   delimited-[]  ℝ     n  m      [\mathbf{A}]\in[\mathbb{R}]^{n\times m}   and an interval vector     [  𝐛  ]   ∈    [  ℝ  ]   n        delimited-[]  𝐛    superscript   delimited-[]  ℝ   n     [\mathbf{b}]\in[\mathbb{R}]^{n}   . We want the smallest cuboid     [  𝐱  ]   ∈    [  ℝ  ]   m        delimited-[]  𝐱    superscript   delimited-[]  ℝ   m     [\mathbf{x}]\in[\mathbb{R}]^{m}   , for all vectors    𝐱  ∈   ℝ  m       𝐱   superscript  ℝ  m     \mathbf{x}\in\mathbb{R}^{m}   which there is a pair    (  𝐀  ,  𝐛  )     𝐀  𝐛    (\mathbf{A},\mathbf{b})   with    𝐀  ∈   [  𝐀  ]       𝐀   delimited-[]  𝐀     \mathbf{A}\in[\mathbf{A}]   and    𝐛  ∈   [  𝐛  ]       𝐛   delimited-[]  𝐛     \mathbf{b}\in[\mathbf{b}]   satisfying       𝐀  ⋅  𝐱   =  𝐛       normal-⋅  𝐀  𝐱   𝐛    \mathbf{A}\cdot\mathbf{x}=\mathbf{b}   .  For quadratic systems – in other words, for    n  =  m      n  m    n=m   – there can be such an interval vector    [  𝐱  ]     delimited-[]  𝐱    [\mathbf{x}]   , which covers all possible solutions, found simply with the interval Gauss method. This replaces the numerical operations, in that the linear algebra method known as Gaussian elimination becomes its interval version. However, since this method uses the interval entities    [  𝐀  ]     delimited-[]  𝐀    [\mathbf{A}]   and    [  𝐛  ]     delimited-[]  𝐛    [\mathbf{b}]   repeatedly in the calculation, it can produce poor results for some problems. Hence using the result of the interval-valued Gauss only provides first rough estimates, since although it contains the entire solution set, it also has a large area outside it.  A rough solution    [  𝐱  ]     delimited-[]  𝐱    [\mathbf{x}]   can often be improved by an interval version of the Gauss–Seidel method . The motivation for this is that the   i   i   i   -th row of the interval extension of the linear equation        (      [   a  11   ]     ⋯     [   a   1  n    ]       ⋮    ⋱    ⋮       [   a   n  1    ]     ⋯     [   a   n  n    ]      )   ⋅   (      x  1       ⋮       x  n      )    =   (      [   b  1   ]       ⋮       [   b  n   ]      )        normal-⋅     delimited-[]   subscript  a  11    normal-⋯   delimited-[]   subscript  a    1  n       normal-⋮  normal-⋱  normal-⋮     delimited-[]   subscript  a    n  1     normal-⋯   delimited-[]   subscript  a    n  n          subscript  x  1     normal-⋮     subscript  x  n         delimited-[]   subscript  b  1      normal-⋮     delimited-[]   subscript  b  n        \begin{pmatrix}{[a_{11}]}&\cdots&{[a_{1n}]}\\
 \vdots&\ddots&\vdots\\
 {[a_{n1}]}&\cdots&{[a_{nn}]}\end{pmatrix}\cdot\begin{pmatrix}{x_{1}}\\
 \vdots\\
 {x_{n}}\end{pmatrix}=\begin{pmatrix}{[b_{1}]}\\
 \vdots\\
 {[b_{n}]}\end{pmatrix}   can be determined by the variable    x  i     subscript  x  i    x_{i}   if the division    1  /   [   a   i  i    ]       1   delimited-[]   subscript  a    i  i       1/[a_{ii}]   is allowed. It is therefore simultaneously       x  j   ∈   [   x  j   ]        subscript  x  j    delimited-[]   subscript  x  j      x_{j}\in[x_{j}]   and     x  j   ∈     [   b  i   ]   -     ∑   k  ≠  j       [   a   i  k    ]   ⋅   [   x  k   ]       [   a   i  i    ]         subscript  x  j        delimited-[]   subscript  b  i      subscript     k  j     normal-⋅   delimited-[]   subscript  a    i  k      delimited-[]   subscript  x  k        delimited-[]   subscript  a    i  i        x_{j}\in\frac{[b_{i}]-\sum\limits_{k\not=j}[a_{ik}]\cdot[x_{k}]}{[a_{ii}]}   . So we can now replace    [   x  j   ]     delimited-[]   subscript  x  j     [x_{j}]   by       [   x  j   ]   ∩     [   b  i   ]   -    ∑   k  ≠  j      [   a   i  k    ]   ⋅   [   x  k   ]       [   a   i  i    ]         delimited-[]   subscript  x  j         delimited-[]   subscript  b  i      subscript     k  j     normal-⋅   delimited-[]   subscript  a    i  k      delimited-[]   subscript  x  k        delimited-[]   subscript  a    i  i        [x_{j}]\cap\frac{[b_{i}]-\sum\limits_{k\not=j}[a_{ik}]\cdot[x_{k}]}{[a_{ii}]}   , and so the vector    [  𝐱  ]     delimited-[]  𝐱    [\mathbf{x}]   by each element. Since the procedure is more efficient for a diagonally dominant matrix , instead of the system      [  𝐀  ]   ⋅  𝐱   =    [  𝐛  ]   ,        normal-⋅   delimited-[]  𝐀   𝐱      delimited-[]  𝐛   ,     [\mathbf{A}]\cdot\mathbf{x}=[\mathbf{b}]\mbox{,}   one can often try multiplying it by an appropriate rational matrix   𝐌   𝐌   \mathbf{M}   with the resulting matrix equation        (   𝐌  ⋅   [  𝐀  ]    )   ⋅  𝐱   =   𝐌  ⋅   [  𝐛  ]         normal-⋅   normal-⋅  𝐌   delimited-[]  𝐀    𝐱    normal-⋅  𝐌   delimited-[]  𝐛      (\mathbf{M}\cdot[\mathbf{A}])\cdot\mathbf{x}=\mathbf{M}\cdot[\mathbf{b}]   left to solve. If one chooses, for example,    𝐌  =   𝐀   -  1        𝐌   superscript  𝐀    1      \mathbf{M}=\mathbf{A}^{-1}   for the central matrix    𝐀  ∈   [  𝐀  ]       𝐀   delimited-[]  𝐀     \mathbf{A}\in[\mathbf{A}]   , then    𝐌  ⋅   [  𝐀  ]      normal-⋅  𝐌   delimited-[]  𝐀     \mathbf{M}\cdot[\mathbf{A}]   is outer extension of the identity matrix.  These methods only work well if the widths of the intervals occurring are sufficiently small. For wider intervals it can be useful to use an interval-linear system on finite (albeit large) real number equivalent linear systems. If all the matrices    𝐀  ∈   [  𝐀  ]       𝐀   delimited-[]  𝐀     \mathbf{A}\in[\mathbf{A}]   are invertible, it is sufficient to consider all possible combinations (upper and lower) of the endpoints occurring in the intervals. The resulting problems can be resolved using conventional numerical methods. Interval arithmetic is still used to determine rounding errors.  This is only suitable for systems of smaller dimension, since with a fully occupied    n  ×  n      n  n    n\times n   matrix,    2   n  2      superscript  2   superscript  n  2     2^{n^{2}}   real matrices need to be inverted, with    2  n     superscript  2  n    2^{n}   vectors for the right hand side. This approach was developed by Jiri Rohn and is still being developed. 11  Interval Newton method  An interval variant of Newton's method for finding the zeros in an interval vector    [  𝐱  ]     delimited-[]  𝐱    [\mathbf{x}]   can be derived from the average value extension. 12 For an unknown vector    𝐳  ∈   [  𝐱  ]       𝐳   delimited-[]  𝐱     \mathbf{z}\in[\mathbf{x}]   applied to    𝐲  ∈   [  𝐱  ]       𝐲   delimited-[]  𝐱     \mathbf{y}\in[\mathbf{x}]   , gives       f   (  𝐳  )    ∈    f   (  𝐲  )    +     [   J  f   ]    (   [  𝐱  ]   )    ⋅   (   𝐳  -  𝐲   )           f  𝐳       f  𝐲    normal-⋅     delimited-[]   subscript  J  f     delimited-[]  𝐱      𝐳  𝐲       f(\mathbf{z})\in f(\mathbf{y})+[J_{f}](\mathbf{[x]})\cdot(\mathbf{z}-\mathbf{y})   . For a zero   𝐳   𝐳   \mathbf{z}   , that is     f   (  z  )    =  0        f  z   0    f(z)=0   , and thus must satisfy        f   (  𝐲  )    +     [   J  f   ]    (   [  𝐱  ]   )    ⋅   (   𝐳  -  𝐲   )     =  0          f  𝐲    normal-⋅     delimited-[]   subscript  J  f     delimited-[]  𝐱      𝐳  𝐲     0    f(\mathbf{y})+[J_{f}](\mathbf{[x]})\cdot(\mathbf{z}-\mathbf{y})=0   . This is equivalent to    𝐳  ∈   𝐲  -      [   J  f   ]     (   [  𝐱  ]   )    -  1     ⋅  f    (  𝐲  )         𝐳    𝐲     normal-⋅     delimited-[]   subscript  J  f     superscript   delimited-[]  𝐱     1     f   𝐲      \mathbf{z}\in\mathbf{y}-[J_{f}](\mathbf{[x]})^{-1}\cdot f(\mathbf{y})   . An outer estimate of     [   J  f   ]     (   [  𝐱  ]   )    -  1    ⋅  f   (  𝐲  )   )     fragments   fragments  normal-[   subscript  J  f   normal-]    superscript   fragments  normal-(   fragments  normal-[  x  normal-]   normal-)     1    normal-⋅  f   fragments  normal-(  y  normal-)   normal-)    [J_{f}](\mathbf{[x]})^{-1}\cdot f(\mathbf{y}))   can be determined using linear methods.  In each step of the interval Newton method, an approximate starting value     [  𝐱  ]   ∈    [  ℝ  ]   n        delimited-[]  𝐱    superscript   delimited-[]  ℝ   n     [\mathbf{x}]\in[\mathbb{R}]^{n}   is replaced by     [  𝐱  ]   ∩   (   𝐲  -      [   J  f   ]     (   [  𝐱  ]   )    -  1     ⋅  f    (  𝐲  )     )        delimited-[]  𝐱     𝐲     normal-⋅     delimited-[]   subscript  J  f     superscript   delimited-[]  𝐱     1     f   𝐲      [\mathbf{x}]\cap\left(\mathbf{y}-[J_{f}](\mathbf{[x]})^{-1}\cdot f(\mathbf{y})\right)   and so the result can be improved iteratively. In contrast to traditional methods, the interval method approaches the result by containing the zeros. This guarantees that the result will produce all the zeros in the initial range. Conversely, it will prove that no zeros of   f   f   f   were in the initial range    [  𝐱  ]     delimited-[]  𝐱    [\mathbf{x}]   if a Newton step produces the empty set.  The method converges on all zeros in the starting region. Division by zero can lead to separation of distinct zeros, though the separation may not be complete; it can be complemented by the bisection method .  As an example, consider the function     f   (  x  )    =    x  2   -  2         f  x      superscript  x  2   2     f(x)=x^{2}-2   , the starting range     [  x  ]   =   [   -  2   ,  2  ]        delimited-[]  x      2   2     [x]=[-2,2]   , and the point    y  =  0      y  0    y=0   . We then have      J  f    (  x  )    =    2   x          subscript  J  f   x     2  x     J_{f}(x)=2\,x   and the first Newton step gives        [   -  2   ,  2  ]   ∩   (   0  -    1   2  ⋅   [   -  2   ,  2  ]      (   0  -  2   )     )    =    [   -  2   ,  2  ]   ∩   (    [   -  ∞   ,   -  0.5   ]   ∪   [  0.5  ,  ∞  ]    )    =    [   -  2   ,   -  0.5   ]   ∪   [  0.5  ,  2  ]               2   2     0      1   normal-⋅  2     2   2       0  2           2   2            0.5     0.5                2     0.5     0.5  2       [-2,2]\cap\left(0-\frac{1}{2\cdot[-2,2]}(0-2)\right)=[-2,2]\cap\Big([{-\infty}%
 ,{-0.5}]\cup[{0.5},{\infty}]\Big)=[{-2},{-0.5}]\cup[{0.5},{2}]   . More Newton steps are used separately on    x  ∈   [   -  2   ,   -  0.5   ]       x     2     0.5      x\in[{-2},{-0.5}]   and    [  0.5  ,  2  ]     0.5  2    [{0.5},{2}]   . These converge to arbitrarily small intervals around    -   2         2     -\sqrt{2}   and    +   2         2     +\sqrt{2}   .  The Interval Newton method can also be used with thick functions such as     g   (  x  )    =    x  2   -   [  2  ,  3  ]          g  x      superscript  x  2    2  3      g(x)=x^{2}-[2,3]   , which would in any case have interval results. The result then produces intervals containing     [   -   3    ,   -   2    ]   ∪   [   2   ,   3   ]            3        2        2     3      \left[-\sqrt{3},-\sqrt{2}\right]\cup\left[\sqrt{2},\sqrt{3}\right]   .  Bisection and covers  The various interval methods deliver conservative results as dependencies between the sizes of different intervals extensions are not taken into account. However the dependency problem becomes less significant for narrower intervals.  Covering an interval vector    [  𝐱  ]     delimited-[]  𝐱    [\mathbf{x}]   by smaller boxes     [   𝐱  1   ]   ,  …  ,    [   𝐱  k   ]   ,       delimited-[]   subscript  𝐱  1    normal-…     delimited-[]   subscript  𝐱  k    ,     [\mathbf{x}_{1}],\dots,[\mathbf{x}_{k}]\mbox{,}   so that     [  𝐱  ]   =    ⋃   i  =  1   k     [   𝐱  i   ]   ,         delimited-[]  𝐱     superscript   subscript     i  1    k      delimited-[]   subscript  𝐱  i    ,      \textstyle[\mathbf{x}]=\bigcup_{i=1}^{k}[\mathbf{x}_{i}]\mbox{,}   is then valid for the range of values     f   (   [  𝐱  ]   )    =    ⋃   i  =  1   k    f   (   [   𝐱  i   ]   )   .          f   delimited-[]  𝐱      superscript   subscript     i  1    k     f   delimited-[]   subscript  𝐱  i    .      \textstyle f([\mathbf{x}])=\bigcup_{i=1}^{k}f([\mathbf{x}_{i}])\mbox{.}   So for the interval extensions described above,      [  f  ]    (   [  𝐱  ]   )    ⊇    ⋃   i  =  1   k     [  f  ]    (   [   𝐱  i   ]   )           superscript   subscript     i  1    k      delimited-[]  f    delimited-[]   subscript  𝐱  i         delimited-[]  f    delimited-[]  𝐱      \textstyle[f]([\mathbf{x}])\supseteq\bigcup_{i=1}^{k}[f]([\mathbf{x}_{i}])   is valid. Since     [  f  ]    (   [  𝐱  ]   )        delimited-[]  f    delimited-[]  𝐱     [f]([\mathbf{x}])   is often a genuine superset of the right-hand side, this usually leads to an improved estimate.  Such a cover can be generated by the bisection method such as thick elements    [   x   i  1    ,   x   i  2    ]      subscript  x    i  1     subscript  x    i  2      [x_{i1},x_{i2}]   of the interval vector     [  𝐱  ]   =   (   [   x  11   ,   x  12   ]   ,  …  ,   [   x   n  1    ,   x   n  2    ]   )        delimited-[]  𝐱      subscript  x  11    subscript  x  12    normal-…    subscript  x    n  1     subscript  x    n  2        [\mathbf{x}]=([x_{11},x_{12}],\dots,[x_{n1},x_{n2}])   by splitting in the centre into the two intervals    [   x   i  1    ,    (    x   i  1    +   x   i  2     )   /  2   ]      subscript  x    i  1         subscript  x    i  1     subscript  x    i  2     2     [x_{i1},(x_{i1}+x_{i2})/2]   and    [    (    x   i  1    +   x   i  2     )   /  2   ,   x   i  2    ]          subscript  x    i  1     subscript  x    i  2     2    subscript  x    i  2      [(x_{i1}+x_{i2})/2,x_{i2}]   . If the result is still not suitable then further gradual subdivision is possible. Note that a cover of    2  r     superscript  2  r    2^{r}   intervals results from   r   r   r   divisions of vector elements, substantially increasing the computation costs.  With very wide intervals, it can be helpful to split all intervals into several subintervals with a constant (and smaller) width, a method known as mincing . This then avoids the calculations for intermediate bisection steps. Both methods are only suitable for problems of low dimension.  Application  Interval arithmetic can be used in various areas (such as set inversion , motion planning , set estimation or stability analysis ), in order to be treated estimates for which no exact numerical values can stated. 13  Rounding error analysis  Interval arithmetic is used with error analysis, to control rounding errors arising from each calculation. The advantage of interval arithmetic is that after each operation there is an interval which reliably includes the true result. The distance between the interval boundaries gives the current calculation of rounding errors directly:   Error =    abs   (   a  -  b   )       abs    a  b     \mathrm{abs}(a-b)   for a given interval    [  a  ,  b  ]     a  b    [a,b]   .   Interval analysis adds to rather than substituting for traditional methods for error reduction, such as pivoting .  Tolerance analysis  Parameters for which no exact figures can be allocated often arise during the simulation of technical and physical processes. The production process of technical components allows certain tolerances, so some parameters fluctuate within intervals. In addition, many fundamental constants are not known precisely. 14  If the behavior of such a system affected by tolerances satisfies, for example,     f   (  𝐱  ,  𝐩  )    =  0        f   𝐱  𝐩    0    f(\mathbf{x},\mathbf{p})=0   , for    𝐩  ∈   [  𝐩  ]       𝐩   delimited-[]  𝐩     \mathbf{p}\in[\mathbf{p}]   and unknown   𝐱   𝐱   \mathbf{x}   then the set of possible solutions      {   𝐱   |     ∃  𝐩   ∈   [  𝐩  ]    ,    f   (  𝐱  ,  𝐩  )    =  0    }     conditional-set  𝐱   formulae-sequence      𝐩    delimited-[]  𝐩        f   𝐱  𝐩    0      \{\mathbf{x}\,|\,\exists\mathbf{p}\in[\mathbf{p}],f(\mathbf{x},\mathbf{p})=0\}   , can be found by interval methods. This provides an alternative to traditional propagation of error analysis. Unlike point methods, such as Monte Carlo simulation , interval arithmetic methodology ensures that no part of the solution area can be overlooked. However, the result is always a worst case analysis for the distribution of error, as other probability-based distributions are not considered.  Fuzzy interval arithmetic  Interval arithmetic can also be used with affiliation functions for fuzzy quantities as they are used in fuzzy logic . Apart from the strict statements    x  ∈   [  x  ]       x   delimited-[]  x     x\in[x]   and    x  ∉   [  x  ]       x   delimited-[]  x     x\not\in[x]   , intermediate values are also possible, to which real numbers    μ  ∈   [  0  ,  1  ]       μ   0  1     \mu\in[0,1]   are assigned.    μ  =  1      μ  1    \mu=1   corresponds to definite membership while    μ  =  0      μ  0    \mu=0   is non-membership. A distribution function assigns uncertainty which can be understood as a further interval.  For fuzzy arithmetic 15 only a finite number of discrete affiliation stages     μ  i   ∈   [  0  ,  1  ]        subscript  μ  i    0  1     \mu_{i}\in[0,1]   are considered. The form of such a distribution for an indistinct value can then represented by a sequence of intervals       [   x   (  1  )    ]   ⊃   [   x   (  2  )    ]   ⊃  ⋯  ⊃   [   x   (  k  )    ]        superset-of   delimited-[]   superscript  x  1     delimited-[]   superscript  x  2      superset-of    normal-⋯    superset-of     delimited-[]   superscript  x  k       \left[x^{(1)}\right]\supset\left[x^{(2)}\right]\supset\cdots\supset\left[x^{(k%
 )}\right]   . The interval    [   x   (  i  )    ]     delimited-[]   superscript  x  i     [x^{(i)}]   corresponds exactly to the fluctuation range for the stage    μ  i     subscript  μ  i    \mu_{i}   .  The appropriate distribution for a function    f   (   x  1   ,  ⋯  ,   x  n   )       f    subscript  x  1   normal-⋯   subscript  x  n      f(x_{1},\cdots,x_{n})   concerning indistinct values     x  1   ,  ⋯  ,   x  n       subscript  x  1   normal-⋯   subscript  x  n     x_{1},\cdots,x_{n}   and the corresponding sequences      [   x  1   (  1  )    ]   ⊃  ⋯  ⊃   [   x  1   (  k  )    ]    ,    ⋯  ,   [   x  n   (  1  )    ]    ⊃  ⋯  ⊃   [   x  n   (  k  )    ]       formulae-sequence     superset-of   delimited-[]   superscript   subscript  x  1   1    normal-⋯    superset-of     delimited-[]   superscript   subscript  x  1   k         superset-of   normal-⋯   delimited-[]   superscript   subscript  x  n   1     normal-⋯    superset-of     delimited-[]   superscript   subscript  x  n   k        \left[x_{1}^{(1)}\right]\supset\cdots\supset\left[x_{1}^{(k)}\right],\cdots,%
 \left[x_{n}^{(1)}\right]\supset\cdots\supset\left[x_{n}^{(k)}\right]   can be approximated by the sequence     [   y   (  1  )    ]   ⊃  ⋯  ⊃   [   y   (  k  )    ]        superset-of   delimited-[]   superscript  y  1    normal-⋯    superset-of     delimited-[]   superscript  y  k       \left[y^{(1)}\right]\supset\cdots\supset\left[y^{(k)}\right]   . The values    [   y   (  i  )    ]     delimited-[]   superscript  y  i     \left[y^{(i)}\right]   are given by     [   y   (  i  )    ]   =   f   (   [   x  1   (  i  )    ]   ,   ⋯   [   x  n   (  i  )    ]    )         delimited-[]   superscript  y  i      f    delimited-[]   superscript   subscript  x  1   i      normal-⋯   delimited-[]   superscript   subscript  x  n   i         \left[y^{(i)}\right]=f\left(\left[x_{1}^{(i)}\right],\cdots\left[x_{n}^{(i)}%
 \right]\right)   and can be calculated by interval methods. The value    [   y   (  1  )    ]     delimited-[]   superscript  y  1     \left[y^{(1)}\right]   corresponds to the result of an interval calculation.  History  Interval arithmetic is not a completely new phenomenon in mathematics; it has appeared several times under different names in the course of history. For example Archimedes calculated lower and upper bounds 223/71  The birth of modern interval arithmetic was marked by the appearance of the book Interval Analysis by Ramon E. Moore in 1966. 16 17 He had the idea in Spring 1958, and a year later he published an article about computer interval arithmetic. 18 Its merit was that starting with a simple principle, it provided a general method for automated error analysis, not just errors resulting from rounding.  Independently in 1956, Mieczyslaw Warmus suggested formulae for calculations with intervals, 19 though Moore found the first non-trivial applications.  In the following twenty years, German groups of researchers carried out pioneering work around Götz Alefeld 20 and Ulrich Kulisch 21 at the University of Karlsruhe and later also at the Bergische University of Wuppertal . For example, Karl Nickel explored more effective implementations, while improved containment procedures for the solution set of systems of equations were due to Arnold Neumaier among others. In the 1960s, Eldon R. Hansen dealt with interval extensions for linear equations and then provided crucial contributions to global optimisation, including what is now known as Hansen's method, perhaps the most widely used interval algorithm. 22 Classical methods in this often have the problem of determining the largest (or smallest) global value, but could only find a local optimum and could not find better values; Helmut Ratschek and Jon George Rokne developed branch and bound methods, which till then had only applied to integer values, by using intervals to provide applications for continuous values.  In 1988, Rudolf Lohner developed Fortran -based software for reliable solutions for initial value problems using ordinary differential equations . 23  The journal Reliable Computing (originally Interval Computations ) has been published since the 1990s, dedicated to the reliability of computer-aided computations. As lead editor, R. Baker Kearfott, in addition to his work on global optimisation, has contributed significantly to the unification of notation and terminology used in interval arithmetic ( Web : Kearfott).  In recent years work has concentrated in particular on the estimation of preimages of parameterised functions and to robust control theory by the COPRIN working group of INRIA in Sophia Antipolis in France ( Web : INRIA).  Implementations  There are many software packages that permit the development of numerical applications using interval arithmetic. 24 These are usually provided in the form of program libraries. There are also C++ and Fortran compilers that handle interval data types and suitable operations as a language extension, so interval arithmetic is supported directly.  Since 1967 Extensions for Scientific Computation (XSC) have been developed in the University of Karlsruhe for various programming languages , such as C++, Fortran and Pascal . 25 The first platform was a Zuse  Z 23 , for which a new interval data type with appropriate elementary operators was made available. There followed in 1976 Pascal-SC, a Pascal variant on a Zilog Z80 which it made possible to create fast complicated routines for automated result verification. Then came the Fortran 77-based ACRITH XSC for the System/370 architecture, which was later delivered by IBM. Starting from 1991 one could produce code for C compilers with Pascal-XSC ; a year later the C++ class library supported C-XSC on many different computer systems. In 1997 all XSC variants were made available under the GNU General Public License . At the beginning of 2000 C-XSC 2.0 was released under the leadership of the working group for scientific computation at the Bergische University of Wuppertal, in order to correspond to the improved C++ standard.  Another C++-class library was created in 1993 at the Hamburg University of Technology called Profil/BIAS (Programmer's Runtime Optimized Fast Interval Library, Basic Interval Arithmetic), which made the usual interval operations more user friendly. It emphasized the efficient use of hardware, portability and independence of a particular presentation of intervals.  The Boost collection of C++ libraries contains a template class for intervals. Its authors are aiming to have interval arithmetic in the standard C++ language. 26  Gaol 27 is another C++ interval arithmetic library that is unique in that it offers the relational interval operators used in interval constraint programming .  The Frink programming language has an implementation of interval arithmetic which can handle arbitrary-precision numbers . Programs written in Frink can use intervals without rewriting or recompilation.  In addition computer algebra systems, such as Mathematica , Maple and MuPAD , can handle intervals. There is a Matlab extension Intlab which builds on BLAS routines, as well as the Toolbox b4m which makes a Profil/BIAS interface. 28 Moreover, the Software Euler Math Toolbox includes an interval arithmetic.  IEEE Std 1788-2015 – IEEE standard for interval arithmetic  A standard for interval arithmetic has been approved in June 2015. 29 There are two reference implementations freely available, 30 which have been developed by members of the standard's working group: The libieep1788 31 library for C++, and the interval package 32 for GNU Octave .  A minimalistic subset of the standard is currently under development, which shall be easier to implement and speed up production of implementations. 33  Conferences and Workshop  Several international conferences or workshop take place every year in the world. The main conference is probably SCAN (International Symposium on Scientific Computing, Computer Arithmetic, and Verified Numerical Computation), but there is also SWIM (Small Workshop on Interval Methods), PPAM (International Conference on Parallel Processing and Applied Mathematics), REC (International Workshop on Reliable Engineering Computing).  See also   Affine arithmetic  Automatic differentiation  Multigrid method  Monte-Carlo simulation  Interval finite element  Fuzzy number  Significant figures   References  Further reading     External links   Introductory Film (mpeg) of the COPRIN teams of INRIA , Sophia Antipolis  Bibliography of R. Baker Kearfott , University of Louisiana at Lafayette  Interval Methods from Arnold Neumaier , University of Vienna  INTLAB, Institute for Reliable Computing , Hamburg University of Technology   "  Category:Arithmetic  Category:Computer arithmetic  Category:Numerical analysis  Category:Uncertainty of numbers  Category:Data types  Category:Articles with images not understandable by color blind users     ↩   ↩  Complex interval arithmetic and its applications , Miodrag Petkovi?, Ljiljana Petkovi?, Wiley-VCH, 1998, ISBN 978-3-527-40134-5 ↩  Hend Dawood (2011). Theories of Interval Arithmetic: Mathematical Foundations and Applications . Saarbrücken: LAP LAMBERT Academic Publishing. ISBN 978-3-8465-0154-2. ↩       Jiri Rohn, List of publications ↩  ↩  ↩   Application of Fuzzy Arithmetic to Quantifying the Effects of Uncertain Model Parameters, Michael Hanss , University of Stuttgart ↩  ↩  ↩  ↩  Precursory papers on interval analysis by M. Warmus ↩  ↩    Bounds for ordinary differential equations of Rudolf Lohner (in German) ↩  Software for Interval Computations collected by Vladik Kreinovich , University of Texas at El Paso ↩  History of XSC-Languages ↩  A Proposal to add Interval Arithmetic to the C++ Standard Library ↩  Gaol is Not Just Another Interval Arithmetic Library ↩  INTerval LABoratory and b4m ↩  IEEE Standard for Interval Arithmetic ↩  Revol, Nathalie (2015). The (near-)future IEEE 1788 standard for interval arithmetic. 8th small workshop on interval methods. Slides (PDF) ↩  C++ implementation of the preliminary IEEE P1788 standard for interval arithmetic ↩  GNU Octave interval package ↩  IEEE Project P1788.1 ↩     