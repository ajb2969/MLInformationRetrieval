   Rayleigh quotient iteration      Rayleigh quotient iteration  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     Rayleigh quotient iteration is an eigenvalue algorithm which extends the idea of the inverse iteration by using the Rayleigh quotient to obtain increasingly accurate eigenvalue estimates.  Rayleigh quotient iteration is an iterative method , that is, it must be repeated until it converges to an answer (this is true for all eigenvalue algorithms). Fortunately, very rapid convergence is guaranteed and no more than a few iterations are needed in practice. The Rayleigh quotient iteration algorithm converges cubically for Hermitian or symmetric matrices, given an initial vector that is sufficiently close to an eigenvector of the matrix that is being analyzed.  Algorithm  The algorithm is very similar to inverse iteration, but replaces the estimated eigenvalue at the end of each iteration with the Rayleigh quotient. Begin by choosing some value    μ  0     subscript  μ  0    \mu_{0}   as an initial eigenvalue guess for the Hermitian matrix   A   A   A   . An initial vector    b  0     subscript  b  0    b_{0}   must also be supplied as initial eigenvector guess.  Calculate the next approximation of the eigenvector    b   i  +  1      subscript  b    i  1     b_{i+1}   by        b   i  +  1    =      (   A  -    μ  i   I    )    -  1     b  i     ||     (   A  -    μ  i   I    )    -  1     b  i    ||     ,       subscript  b    i  1         superscript    A     subscript  μ  i   I      1     subscript  b  i     norm     superscript    A     subscript  μ  i   I      1     subscript  b  i        b_{i+1}=\frac{(A-\mu_{i}I)^{-1}b_{i}}{||(A-\mu_{i}I)^{-1}b_{i}||},    where   I   I   I   is the identity matrix, and set the next approximation of the eigenvalue to the Rayleigh quotient of the current iteration equal to       μ  i   =     b  i  *   A   b  i      b  i  *    b  i      .       subscript  μ  i        subscript   superscript  b    i   A   subscript  b  i       subscript   superscript  b    i    subscript  b  i       \mu_{i}=\frac{b^{*}_{i}Ab_{i}}{b^{*}_{i}b_{i}}.     To compute more than one eigenvalue, the algorithm can be combined with a deflation technique.  Example  Consider the matrix      A  =   [     1    2    3      1    2    1      3    2    1     ]       A   delimited-[]    1  2  3    1  2  1    3  2  1       A=\left[\begin{matrix}1&2&3\\
 1&2&1\\
 3&2&1\\
 \end{matrix}\right]     for which the exact eigenvalues are     λ  1   =   3  +   5         subscript  λ  1     3    5      \lambda_{1}=3+\sqrt{5}   ,     λ  2   =   3  -   5         subscript  λ  2     3    5      \lambda_{2}=3-\sqrt{5}   and     λ  3   =   -  2        subscript  λ  3     2     \lambda_{3}=-2   , with corresponding eigenvectors       v  1   =   [     1       φ  -  1       1     ]        subscript  v  1    delimited-[]    1      φ  1     1       v_{1}=\left[\begin{matrix}1\\
 \varphi-1\\
 1\\
 \end{matrix}\right]   ,     v  2   =   [     1       -  φ       1     ]        subscript  v  2    delimited-[]    1      φ     1       v_{2}=\left[\begin{matrix}1\\
 -\varphi\\
 1\\
 \end{matrix}\right]   and     v  3   =   [     1      0      1     ]        subscript  v  3    delimited-[]    1    0    1       v_{3}=\left[\begin{matrix}1\\
 0\\
 1\\
 \end{matrix}\right]   .  (where    φ  =    1  +   5    2       φ      1    5    2     \textstyle\varphi=\frac{1+\sqrt{5}}{2}   is the golden ratio).  The largest eigenvalue is     λ  1   ≈  5.2361       subscript  λ  1   5.2361    \lambda_{1}\approx 5.2361   and corresponds to any eigenvector proportional to      v  1   ≈   [     1      0.6180      1     ]    .       subscript  v  1    delimited-[]    1    0.6180    1       v_{1}\approx\left[\begin{matrix}1\\
 0.6180\\
 1\\
 \end{matrix}\right].     We begin with an initial eigenvalue guess of        b  0   =   [     1      1      1     ]    ,    μ  0   =  200      formulae-sequence     subscript  b  0    delimited-[]    1    1    1         subscript  μ  0   200     b_{0}=\left[\begin{matrix}1\\
 1\\
 1\\
 \end{matrix}\right],~{}\mu_{0}=200   .  Then, the first iteration yields        b  1   ≈   [      -  0.57927        -  0.57348        -  0.57927      ]    ,    μ  1   ≈  5.3355      formulae-sequence     subscript  b  1    delimited-[]      0.57927       0.57348       0.57927          subscript  μ  1   5.3355     b_{1}\approx\left[\begin{matrix}-0.57927\\
 -0.57348\\
 -0.57927\\
 \end{matrix}\right],~{}\mu_{1}\approx 5.3355     the second iteration,        b  2   ≈   [     0.64676      0.40422      0.64676     ]    ,    μ  2   ≈  5.2418      formulae-sequence     subscript  b  2    delimited-[]    0.64676    0.40422    0.64676         subscript  μ  2   5.2418     b_{2}\approx\left[\begin{matrix}0.64676\\
 0.40422\\
 0.64676\\
 \end{matrix}\right],~{}\mu_{2}\approx 5.2418     and the third,        b  3   ≈   [      -  0.64793        -  0.40045        -  0.64793      ]    ,    μ  3   ≈  5.2361      formulae-sequence     subscript  b  3    delimited-[]      0.64793       0.40045       0.64793          subscript  μ  3   5.2361     b_{3}\approx\left[\begin{matrix}-0.64793\\
 -0.40045\\
 -0.64793\\
 \end{matrix}\right],~{}\mu_{3}\approx 5.2361     from which the cubic convergence is evident.  Octave Implementation  The following is a simple implementation of the algorithm in Octave .  function x = rayleigh(A,epsilon,mu,x)
   x = x / norm(x);
   y = (A-mu*eye(rows(A))) \ x;
   lambda = y'*x;
   mu = mu + 1 / lambda
   err = norm(y-lambda*x) / norm(y)
   while err > epsilon
     x = y / norm(y);
     y = (A-mu*eye(rows(A))) \ x;
     lambda = y'*x;
     mu = mu + 1 / lambda
     err = norm(y-lambda*x) / norm(y)
   end
 end  See also   Power iteration  Inverse iteration   References   Lloyd N. Trefethen and David Bau, III, Numerical Linear Algebra , Society for Industrial and Applied Mathematics, 1997. ISBN 0-89871-361-7.  Rainer Kress, "Numerical Analysis", Springer, 1991. ISBN 0-387-98408-9   "  Category:Numerical linear algebra  Category:Articles with example MATLAB/Octave code  