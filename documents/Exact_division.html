<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1050">Exact division</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Exact division</h1>
<hr/>

<p>An <strong>exact division</strong> (also called: even division or <strong>consensus division</strong>) is a division of a heterogeneous resource ("<a href="fair_cake-cutting" title="wikilink">cake</a>") to several subsets such that each of <em>n</em> people with different tastes agree about the valuations of the pieces.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>For example, consider a cake which is half chocolate and half vanilla. Alice values only the chocolate and George values only the vanilla. The cake is divided to three pieces: one piece contains 20% of the chocolate and 20% of the vanilla, the second contains 50% of the chocolate and 50% of the vanilla, and the third contains the rest of the cake. This is a consensus division, as both Alice and George value the three pieces as 20%, 50% and 10% respectively.</p>

<p>As the example illustrates, a consensus division is not necessarily fair. For example, if the 20% piece is given to Alice and the 50% is given to George, this is obviously unfair to Alice. In the theory of <a href="fair_cake-cutting" title="wikilink">cake</a>, consensus divisions are often used as subroutines for creating fair divisions.</p>

<p>Consensus divisions always exist, but they cannot be found by discrete protocols (with a finite number of queries). In some cases, exact divisions can be found by moving-knife protocols. Near-exact divisions can be found by discrete protocols.</p>
<h2 id="definitions">Definitions</h2>

<p>Let 

<math display="inline" id="Exact_division:0">
<semantics>
<mrow>
<msub>
<mi>w</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>w</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>w</mi>
<mi>k</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<ci>k</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   w_{1},w_{2},...,w_{k}
  </annotation>
</semantics>
</math>

 be <em>k</em> weights whose sum is 1. Assume that all <em>n</em> partners value the cake <em>C</em> as 1.</p>

<p>An <strong>exact division</strong> (aka <strong>consensus division</strong>) in the ratios 

<math display="inline" id="Exact_division:1">
<semantics>
<mrow>
<msub>
<mi>w</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>w</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>w</mi>
<mi>k</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<ci>k</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   w_{1},w_{2},...,w_{k}
  </annotation>
</semantics>
</math>

 is a partition of the cake to <em>k</em> pieces

<math display="block" id="Exact_division:2">
<semantics>
<mrow>
<mi>C</mi>
<mo>=</mo>
<mrow>
<msub>
<mi>P</mi>
<mn>1</mn>
</msub>
<mo>⊔</mo>
<mi mathvariant="normal">…</mi>
<mo>⊔</mo>
<msub>
<mi>P</mi>
<mi>k</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>C</ci>
<apply>
<csymbol cd="latexml">square-union</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C=P_{1}\sqcup...\sqcup P_{k}
  </annotation>
</semantics>
</math>

, such that for every partner <em>i</em> and every piece <em>j</em>:</p>

<p>
<math display="block" id="Exact_division:3">
<semantics>
<mrow>
<mrow>
<msub>
<mi>V</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>P</mi>
<mi>j</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<msub>
<mi>w</mi>
<mi>j</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>j</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<ci>j</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V_{i}(P_{j})=w_{j}
  </annotation>
</semantics>
</math>

 I.e., there is a consensus among all partners that the value of piece <em>j</em> is exactly 

<math display="inline" id="Exact_division:4">
<semantics>
<msub>
<mi>w</mi>
<mi>j</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<ci>j</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w_{j}
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="near-exact-division">Near-exact division</h3>

<p>For every 

<math display="inline" id="Exact_division:5">
<semantics>
<mrow>
<mi>ϵ</mi>
<mo>&gt;</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<gt></gt>
<ci>ϵ</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \epsilon&gt;0
  </annotation>
</semantics>
</math>

, An <strong>
<math display="inline" id="Exact_division:6">
<semantics>
<mi>ϵ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ϵ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \epsilon
  </annotation>
</semantics>
</math>

-near-exact division</strong> in the ratios 

<math display="inline" id="Exact_division:7">
<semantics>
<mrow>
<msub>
<mi>w</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>w</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>w</mi>
<mi>k</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<ci>k</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   w_{1},w_{2},...,w_{k}
  </annotation>
</semantics>
</math>

 is a division in which:</p>

<p>
<math display="block" id="Exact_division:8">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<mrow>
<msub>
<mi>V</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>P</mi>
<mi>j</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>-</mo>
<msub>
<mi>w</mi>
<mi>j</mi>
</msub>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mo>&lt;</mo>
<mi>ϵ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<lt></lt>
<apply>
<abs></abs>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>j</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
<ci>ϵ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |V_{i}(P_{j})-w_{j}|&lt;\epsilon
  </annotation>
</semantics>
</math>

 I.e., there is a consensus among all partners that the value of piece <em>j</em> is <em>nearly-exactly</em>
<math display="inline" id="Exact_division:9">
<semantics>
<msub>
<mi>w</mi>
<mi>j</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<ci>j</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w_{j}
  </annotation>
</semantics>
</math>

, where the difference is less than 

<math display="inline" id="Exact_division:10">
<semantics>
<mi>ϵ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ϵ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \epsilon
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="exact-division-with-arbitrary-number-of-cuts">Exact division with arbitrary number of cuts</h2>
<h3 id="piecewise-homogeneous-cake-many-partners-any-weights">Piecewise-homogeneous cake, many partners, any weights</h3>
<div id="piecewise">
</div>

<p>A cake is called <em>piecewise-homogeneous</em> if it can be divided to <em>R</em> regions, such that all partners agree that the value density in each region is uniform. For example, consider a circular cake in which each of its 4 quarters has a different topping. The partners may value each of the toppings differently, but do not distinguish between different pieces having the same topping. This means that the value of each piece to each partner only depends on the <em>amount</em> they get from each region.</p>

<p>Saying that the cake is piecewise-homogeneous is equivalent to saying that the valuations of the partners are <em>piecewise-constant</em>: each piece of the cake is homogeneous if and only if it is the intersection of <em>n</em> pieces of the <em>n</em> partners.</p>

<p>whenever the cake is piecewise-homogeneous (and the valuations are piecewise-constant), a consensus division can be achieved in the following way:</p>
<ul>
<li>Divide each region to <em>k</em> sub-regions, such that sub-region <em>j</em> contains exactly 

<math display="inline" id="Exact_division:11">
<semantics>
<msub>
<mi>w</mi>
<mi>j</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<ci>j</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w_{j}
  </annotation>
</semantics>
</math>

 of the regions.</li>
<li>Let piece <em>j</em> be the union of the <em>j</em>-th sub-regions in all <em>R</em> regions. This defines a consensus division with the given weights.</li>
</ul>

<p>This algorithm can be generalized to slightly more general families of value measures, such as piecewise linear.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The number of required cuts is 

<math display="inline" id="Exact_division:12">
<semantics>
<mrow>
<mi>k</mi>
<mi>R</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>k</ci>
<ci>R</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   kR
  </annotation>
</semantics>
</math>

, where <em>R</em> is the number of regions.</p>
<h3 id="general-cake-many-partners-any-weights">General cake, many partners, any weights</h3>
<div id="dubins_spanier">
</div>

<p>When the value functions are additive and non-atomic, a consensus division exists for every set of weights.</p>

<p>Dubins and Spanier proved the existence of such a division based on <a href="Lyapunov_vector-measure_theorem" title="wikilink">Lyapunov vector-measure theorem</a>:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<ul>
<li>Every partition of the cake to <em>k</em> pieces defines an 

<math display="inline" id="Exact_division:13">
<semantics>
<mrow>
<mi>n</mi>
<mo>×</mo>
<mi>k</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>n</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n\times k
  </annotation>
</semantics>
</math>

 matrix, in which element 

<math display="inline" id="Exact_division:14">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo>,</mo>
<mi>j</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="open">
<ci>i</ci>
<ci>j</ci>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   (i,j)
  </annotation>
</semantics>
</math>

 is the valuation of partner <em>i</em> to piece <em>j</em>.</li>
<li>For every <em>j</em>, the partition in which piece <em>j</em> is the entire cake corresponds to a matrix in which the <em>j</em>-th column is all 1's and the other columns are all 0's. Call this matrix 

<math display="inline" id="Exact_division:15">
<semantics>
<msub>
<mi>M</mi>
<mi>j</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>j</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   M_{j}
  </annotation>
</semantics>
</math>

.</li>
<li>The space of all partition matrices is <a href="convex_set" title="wikilink">convex</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> (see <a href="Lyapunov_vector-measure_theorem" title="wikilink">Lyapunov vector-measure theorem</a>).</li>
<li>Hence, for every set of weights, the space of all partition matrices contains the convex combination of the 

<math display="inline" id="Exact_division:16">
<semantics>
<msub>
<mi>M</mi>
<mi>j</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>j</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   M_{j}
  </annotation>
</semantics>
</math>

 matrices with the given weights.</li>
<li>Hence, there is a partition in which, for every <em>j</em>, the <em>j</em>-th column contains only the weight 

<math display="inline" id="Exact_division:17">
<semantics>
<msub>
<mi>w</mi>
<mi>j</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<ci>j</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w_{j}
  </annotation>
</semantics>
</math>

. This partition is a consensus division with the given weights.</li>
</ul>

<p>Woodall<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> showed that it is possible to construct such a division of an interval cake as a countable union of intervals.</p>

<p>INTUITION: Consider the division procedure for piecewise-homogeneous cakes described above. In general, the cake is not piecewise-homogeneous. However, because the value measures are continuous, it is possible to divide the cake to smaller and smaller regions such that the regions become more and more homogeneous. When 

<math display="inline" id="Exact_division:18">
<semantics>
<mrow>
<mi>R</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>R</ci>
<infinity></infinity>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R\to\infty
  </annotation>
</semantics>
</math>

, this process converges to a consensus division.</p>

<p>Fremlin showed that it is possible to construct such a division as a <em>finite</em> union of intervals.</p>

<p>Stromquist and Woodall<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> showed that it is possible with the <em>minimal</em> number of intervals; see <a href="#stromquist_woodall" title="wikilink">below</a>.</p>
<h2 id="exact-division-with-a-minimal-number-of-cuts">Exact division with a minimal number of cuts</h2>

<p>Suppose the cake is an interval made of <em>n</em> districts (sub-intervals), and each of the <em>n</em> partners values only a single district. Then, a consensus division of the cake to <em>k</em> subsets requires 

<math display="inline" id="Exact_division:19">
<semantics>
<mrow>
<mi>n</mi>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>k</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-⋅</ci>
<ci>n</ci>
<apply>
<minus></minus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n\cdot(k-1)
  </annotation>
</semantics>
</math>

 cuts, since each of the districts must be cut to <em>k</em> pieces which are equal in the eyes of the partner that values this district. Hence, it is an interesting question whether it is <strong>always</strong> possible to attain a consensus division with this exact number of cuts.</p>
<h3 id="interval-cake-two-partners-many-subsets-any-weights">Interval cake, two partners, many subsets, any weights</h3>
<div id="austin">
</div>

<p>Two partners can achieve a consensus division using <a href="Austin_moving-knife_procedure" title="wikilink">Austin moving-knife procedure</a>.</p>

<p>The simplest case is when the weights are 1/2, i.e. they want to cut a piece that both of them agree to be half the cake value. This is done as follows. One partner moves two knives over the cake from left to right, always keeping the value between the knives as exactly 1/2. It is possible to prove (by the <a href="intermediate_value_theorem" title="wikilink">intermediate value theorem</a>) that at some point, the value of the piece between the knives to the other partner will also be exactly 1/2. The other partner calls "stop!" at that point and the piece is cut.</p>

<p>The same protocol can be used to cut a piece that both player agree that its value is exactly 

<math display="inline" id="Exact_division:20">
<semantics>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1/n
  </annotation>
</semantics>
</math>

.</p>

<p>By combining several such pieces, it is possible to achieve a consensus division with any ratios that are rational numbers. But this may require a large number of cuts.</p>

<p>A better way to achieve a consensus division is to identify the two endpoints of the cake and treat it like a circle. I.e, when the right knife gets to the right side, it immediately goes to the left side, and the piece-between-the-knives is now actually the union of the piece to the right of the right knife and the piece to the left of the left knife. This way, it is possible to find a consensus division for every 

<math display="inline" id="Exact_division:21">
<semantics>
<mrow>
<mi>p</mi>
<mo>∈</mo>
<mrow>
<mo stretchy="false">[</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>p</ci>
<interval closure="closed">
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p\in[0,1]
  </annotation>
</semantics>
</math>

. One partner moves the knives cyclically around the cake, always keeping the value between them at exactly <em>p</em>. It is possible to prove that at some point, the value of the piece between the knives to the other partner will also be exactly <em>p</em>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The other partner calls "stop!" at that point and the piece is cut. This requires only two cuts.</p>

<p>By repeatedly applying the above procedure, it is possible to achieve a consensus division to two partners and any number of subsets. The number of cuts is 

<math display="inline" id="Exact_division:22">
<semantics>
<mrow>
<mn>2</mn>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>k</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<cn type="integer">2</cn>
<apply>
<minus></minus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2(k-1)
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Exact_division:23">
<semantics>
<mi>k</mi>
<annotation-xml encoding="MathML-Content">
<ci>k</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   k
  </annotation>
</semantics>
</math>

 is the number of subsets.</p>

<p>As of 2015, there is no known generalization of this moving-knife procedure to more than 2 partners. <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="interval-cake-many-partners-two-subsets-equal-weights">Interval cake, many partners, two subsets, equal weights</h3>
<div id="halving">
</div>

<p>Suppose the cake is an interval of value 1. It should be divided to 

<math display="inline" id="Exact_division:24">
<semantics>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k=2
  </annotation>
</semantics>
</math>

 subsets, each of which has a value of exactly 1/2 to all <em>n</em> partners. We want to use the minimal number of cuts, which is 

<math display="inline" id="Exact_division:25">
<semantics>
<mrow>
<mrow>
<mi>n</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>k</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>n</ci>
<apply>
<minus></minus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n(k-1)=n
  </annotation>
</semantics>
</math>

.</p>

<p>A division like this always exists.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> This is a direct corollary of the <a href="Hobby–Rice_theorem" title="wikilink">Hobby–Rice theorem</a>. This can also be proved based on the <a href="Borsuk-Ulam_theorem" title="wikilink">Borsuk-Ulam theorem</a>:<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<ul>
<li>Every partition of an interval using 

<math display="inline" id="Exact_division:26">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

 cuts can be represented as a vector of length 

<math display="inline" id="Exact_division:27">
<semantics>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n+1
  </annotation>
</semantics>
</math>

, in which the elements are the lengths of the sub-intervals.</li>
<li>Every element of the vector can be either positive (if it belongs to piece #1) or negative (if it belongs to piece #2).</li>
<li>The set of all partitions is the sphere 

<math display="inline" id="Exact_division:28">
<semantics>
<msup>
<mi>S</mi>
<mi>n</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>S</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   S^{n}
  </annotation>
</semantics>
</math>

.</li>
<li>Define a 

<math display="inline" id="Exact_division:29">
<semantics>
<mrow>
<mi>V</mi>
<mo>:</mo>
<mrow>
<msup>
<mi>S</mi>
<mi>n</mi>
</msup>
<mo>→</mo>
<msup>
<mi>ℝ</mi>
<mi>n</mi>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>V</ci>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>S</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℝ</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V:S^{n}\to\mathbb{R}^{n}
  </annotation>
</semantics>
</math>

 in the following way: for every partition 

<math display="inline" id="Exact_division:30">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Exact_division:31">
<semantics>
<mrow>
<mi>V</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>V</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V(x)
  </annotation>
</semantics>
</math>

 is a vector whose 

<math display="inline" id="Exact_division:32">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

-th element is the value of piece #1 in that partition according to partner 

<math display="inline" id="Exact_division:33">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

, minus 1/2.</li>
<li>The function 

<math display="inline" id="Exact_division:34">
<semantics>
<mi>V</mi>
<annotation-xml encoding="MathML-Content">
<ci>V</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   V
  </annotation>
</semantics>
</math>

 is continuous. Moreover, for all 

<math display="inline" id="Exact_division:35">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Exact_division:36">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>V</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mi>V</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>V</ci>
<ci>x</ci>
</apply>
<apply>
<times></times>
<ci>V</ci>
<apply>
<minus></minus>
<ci>x</ci>
</apply>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V(x)+V(-x)=0
  </annotation>
</semantics>
</math>

.</li>
<li>Hence, by the <a href="Borsuk-Ulam_theorem" title="wikilink">Borsuk-Ulam theorem</a>, there exists an 

<math display="inline" id="Exact_division:37">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 such that 

<math display="inline" id="Exact_division:38">
<semantics>
<mrow>
<mrow>
<mi>V</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>V</ci>
<ci>x</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V(x)=0
  </annotation>
</semantics>
</math>

. In that partition, all partners value piece #1 (and piece #2) as exactly 1/2.</li>
</ul>

<p>A consensus division to two subsets can be found based on <a href="Tucker's_lemma" title="wikilink">Tucker's lemma</a>, which is the discrete version of <a href="Borsuk-Ulam_theorem" title="wikilink">Borsuk-Ulam theorem</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="interval-cake-many-partners-many-subsets-equal-weights">Interval cake, many partners, many subsets, equal weights</h3>
<div id="necklace">
</div>

<p>The existence theorem of the previous subsection can be generalized from 

<math display="inline" id="Exact_division:39">
<semantics>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k=2
  </annotation>
</semantics>
</math>

 pieces to an arbitrary number of pieces. This was proved by <a href="Noga_Alon" title="wikilink">Noga Alon</a> in his 1987 paper about the <a href="necklace_splitting_problem" title="wikilink">necklace splitting problem</a>.</p>
<h3 id="interval-cake-many-partners-two-subsets-arbitrary-weights">Interval cake, many partners, two subsets, arbitrary weights</h3>
<div id="stromquist_woodall">
</div>

<p>The existence theorem of the previous subsection can be generalized to arbitrary weights.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> The proof is based on the <a href="Stone–Tukey_theorem" title="wikilink">Stone–Tukey theorem</a>.</p>

<p>The proof is easier if we assume that the cake is a circle. Specifically, we define the cake 

<math display="inline" id="Exact_division:40">
<semantics>
<mi>C</mi>
<annotation-xml encoding="MathML-Content">
<ci>C</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   C
  </annotation>
</semantics>
</math>

 as the interval [0,1] in which the two endpoints are identified. Then, for every weight 

<math display="inline" id="Exact_division:41">
<semantics>
<mrow>
<mi>w</mi>
<mo>∈</mo>
<mrow>
<mo stretchy="false">[</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>w</ci>
<interval closure="closed">
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w\in[0,1]
  </annotation>
</semantics>
</math>

, there is a subset 

<math display="inline" id="Exact_division:42">
<semantics>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{w}
  </annotation>
</semantics>
</math>

, which is a union of 

<math display="inline" id="Exact_division:43">
<semantics>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n-1
  </annotation>
</semantics>
</math>

 intervals, which all partners value as exactly 

<math display="inline" id="Exact_division:44">
<semantics>
<mi>w</mi>
<annotation-xml encoding="MathML-Content">
<ci>w</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   w
  </annotation>
</semantics>
</math>

:</p>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Exact_division:45">
<semantics>
<mrow>
<mrow>
<mrow>
<mo>∀</mo>
<mi>i</mi>
</mrow>
<mo>=</mo>
<mrow>
<mn>1</mn>
<mo>,</mo>
<mi mathvariant="normal">⋯</mi>
<mo>,</mo>
<mi>n</mi>
</mrow>
</mrow>
<mo rspace="11pt">:</mo>
<mrow>
<mrow>
<msub>
<mi>u</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mi>w</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>i</ci>
</apply>
<list>
<cn type="integer">1</cn>
<ci>normal-⋯</ci>
<ci>n</ci>
</list>
</apply>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>u</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</apply>
<ci>w</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall i=1,\cdots,n:\,\,\,\,\,u_{i}(C_{w})=w
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>

<p>PROOF SKETCH: Let 

<math display="inline" id="Exact_division:46">
<semantics>
<mrow>
<mi>W</mi>
<mo>⊆</mo>
<mrow>
<mo stretchy="false">[</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<ci>W</ci>
<interval closure="closed">
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   W\subseteq[0,1]
  </annotation>
</semantics>
</math>

 be the subset of all weights for which the theorem is true. Then:</p>
<ol>
<li>
<math display="inline" id="Exact_division:47">
<semantics>
<mrow>
<mn>1</mn>
<mo>∈</mo>
<mi>W</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<cn type="integer">1</cn>
<ci>W</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1\in W
  </annotation>
</semantics>
</math>

. Proof: take 

<math display="inline" id="Exact_division:48">
<semantics>
<mrow>
<msub>
<mi>C</mi>
<mn>1</mn>
</msub>
<mo>:=</mo>
<mi>C</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">assign</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<cn type="integer">1</cn>
</apply>
<ci>C</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{1}:=C
  </annotation>
</semantics>
</math>

 (recall that the value measures are normalized such that all partners value the entire cake as 1).</li>
<li>If 

<math display="inline" id="Exact_division:49">
<semantics>
<mrow>
<mi>w</mi>
<mo>∈</mo>
<mi>W</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>w</ci>
<ci>W</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w\in W
  </annotation>
</semantics>
</math>

, then also 

<math display="inline" id="Exact_division:50">
<semantics>
<mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>w</mi>
</mrow>
<mo>∈</mo>
<mi>W</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>w</ci>
</apply>
<ci>W</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1-w\in W
  </annotation>
</semantics>
</math>

. Proof: take 

<math display="inline" id="Exact_division:51">
<semantics>
<mrow>
<msub>
<mi>C</mi>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>w</mi>
</mrow>
</msub>
<mo>:=</mo>
<mrow>
<mi>C</mi>
<mo>∖</mo>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">assign</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>w</ci>
</apply>
</apply>
<apply>
<setdiff></setdiff>
<ci>C</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{1-w}:=C\setminus C_{w}
  </annotation>
</semantics>
</math>

. If 

<math display="inline" id="Exact_division:52">
<semantics>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{w}
  </annotation>
</semantics>
</math>

 is a union of 

<math display="inline" id="Exact_division:53">
<semantics>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n-1
  </annotation>
</semantics>
</math>

 intervals in a circle, then 

<math display="inline" id="Exact_division:54">
<semantics>
<msub>
<mi>C</mi>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>w</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>w</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{1-w}
  </annotation>
</semantics>
</math>

 is also a union of 

<math display="inline" id="Exact_division:55">
<semantics>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n-1
  </annotation>
</semantics>
</math>

 intervals.</li>
<li>
<math display="inline" id="Exact_division:56">
<semantics>
<mi>W</mi>
<annotation-xml encoding="MathML-Content">
<ci>W</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   W
  </annotation>
</semantics>
</math>

 is a <a href="closed_set" title="wikilink">closed set</a>. This is easy to prove, since the space of unions of 

<math display="inline" id="Exact_division:57">
<semantics>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n-1
  </annotation>
</semantics>
</math>

 intervals is a <a href="compact_set" title="wikilink">compact set</a> under a suitable topology.</li>
<li>If 

<math display="inline" id="Exact_division:58">
<semantics>
<mrow>
<mi>w</mi>
<mo>∈</mo>
<mi>W</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>w</ci>
<ci>W</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w\in W
  </annotation>
</semantics>
</math>

, then also 

<math display="inline" id="Exact_division:59">
<semantics>
<mrow>
<mrow>
<mi>w</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
<mo>∈</mo>
<mi>W</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<divide></divide>
<ci>w</ci>
<cn type="integer">2</cn>
</apply>
<ci>W</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w/2\in W
  </annotation>
</semantics>
</math>

. This is the most interesting part of the proof; see below.</li>
</ol>

<p>From 1-4, it follows that 

<math display="inline" id="Exact_division:60">
<semantics>
<mrow>
<mi>W</mi>
<mo>=</mo>
<mrow>
<mo stretchy="false">[</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>W</ci>
<interval closure="closed">
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   W=[0,1]
  </annotation>
</semantics>
</math>

. In other words, the theorem is valid for <em>every</em> possible weight.</p>

<p>PROOF SKETCH FOR 4:</p>
<ul>
<li>Assume that 

<math display="inline" id="Exact_division:61">
<semantics>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{w}
  </annotation>
</semantics>
</math>

 is a union of 

<math display="inline" id="Exact_division:62">
<semantics>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n-1
  </annotation>
</semantics>
</math>

 intervals and that all 

<math display="inline" id="Exact_division:63">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

 partners value it as exactly 

<math display="inline" id="Exact_division:64">
<semantics>
<mi>w</mi>
<annotation-xml encoding="MathML-Content">
<ci>w</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   w
  </annotation>
</semantics>
</math>

.</li>
<li>Define the following function on the cake, 

<math display="inline" id="Exact_division:65">
<semantics>
<mrow>
<mi>f</mi>
<mo>:</mo>
<mrow>
<mi>C</mi>
<mo>→</mo>
<msup>
<mi>ℝ</mi>
<mi>n</mi>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>f</ci>
<apply>
<ci>normal-→</ci>
<ci>C</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℝ</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f:C\to\mathbb{R}^{n}
  </annotation>
</semantics>
</math>

:</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Exact_division:66">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo>,</mo>
<msup>
<mi>t</mi>
<mn>2</mn>
</msup>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msup>
<mi>t</mi>
<mi>n</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mi>t</mi>
<mo>∈</mo>
<mrow>
<mo stretchy="false">[</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>f</ci>
<ci>t</ci>
</apply>
<vector>
<ci>t</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<ci>n</ci>
</apply>
</vector>
</apply>
<apply>
<in></in>
<ci>t</ci>
<interval closure="closed">
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</interval>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(t)=(t,t^{2},...,t^{n})\,\,\,\,\,\,t\in[0,1]
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>Define the following measures on 

<math display="inline" id="Exact_division:67">
<semantics>
<msup>
<mi>ℝ</mi>
<mi>n</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℝ</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
</semantics>
</math>

:</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Exact_division:68">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>v</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>U</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>u</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<msup>
<mi>f</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>U</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>∩</mo>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mrow>
<mi>U</mi>
<mo>⊆</mo>
<msup>
<mi>ℝ</mi>
<mi>n</mi>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<ci>i</ci>
</apply>
<ci>U</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>u</ci>
<ci>i</ci>
</apply>
<apply>
<intersect></intersect>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>U</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<subset></subset>
<ci>U</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℝ</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   v_{i}(U)=u_{i}(f^{-1}(U)\cap C_{w})\,\,\,\,\,\,\,\,\,U\subseteq\mathbb{R}^{n}
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>Note that 

<math display="inline" id="Exact_division:69">
<semantics>
<mrow>
<mrow>
<msup>
<mi>f</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>ℝ</mi>
<mi>n</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mi>C</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℝ</ci>
<ci>n</ci>
</apply>
</apply>
<ci>C</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f^{-1}(\mathbb{R}^{n})=C
  </annotation>
</semantics>
</math>

. Hence, for every partner 

<math display="inline" id="Exact_division:70">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>
<math display="block" id="Exact_division:71">
<semantics>
<mrow>
<mrow>
<msub>
<mi>v</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>ℝ</mi>
<mi>n</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mi>w</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℝ</ci>
<ci>n</ci>
</apply>
</apply>
<ci>w</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   v_{i}(\mathbb{R}^{n})=w
  </annotation>
</semantics>
</math>

.</li>
<li>Hence, by the <a href="Stone-Tukey_theorem" title="wikilink">Stone-Tukey theorem</a>, there is a hyper-plane that cuts 

<math display="inline" id="Exact_division:72">
<semantics>
<msup>
<mi>ℝ</mi>
<mi>n</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℝ</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
</semantics>
</math>
</li>
</ul>

<p>to two half-spaces, 

<math display="inline" id="Exact_division:73">
<semantics>
<mrow>
<mi>H</mi>
<mo>,</mo>
<msup>
<mi>H</mi>
<mo>′</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>H</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>H</ci>
<ci>normal-′</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   H,H^{\prime}
  </annotation>
</semantics>
</math>

, such that:</p>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Exact_division:74">
<semantics>
<mrow>
<mrow>
<mrow>
<mo>∀</mo>
<mi>i</mi>
</mrow>
<mo>=</mo>
<mrow>
<mn>1</mn>
<mo>,</mo>
<mi mathvariant="normal">⋯</mi>
<mo>,</mo>
<mi>n</mi>
</mrow>
</mrow>
<mo rspace="11pt">:</mo>
<mrow>
<mrow>
<msub>
<mi>v</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>H</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>v</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>H</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>w</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>i</ci>
</apply>
<list>
<cn type="integer">1</cn>
<ci>normal-⋯</ci>
<ci>n</ci>
</list>
</apply>
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<ci>i</ci>
</apply>
<ci>H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>H</ci>
<ci>normal-′</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<divide></divide>
<ci>w</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall i=1,\cdots,n:\,\,\,\,\,v_{i}(H)=v_{i}(H^{\prime})=w/2
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>Define 

<math display="inline" id="Exact_division:75">
<semantics>
<mrow>
<mi>M</mi>
<mo>=</mo>
<mrow>
<mrow>
<msup>
<mi>f</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>H</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>∩</mo>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>M</ci>
<apply>
<intersect></intersect>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   M=f^{-1}(H)\cap C_{w}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Exact_division:76">
<semantics>
<mrow>
<msup>
<mi>M</mi>
<mo>′</mo>
</msup>
<mo>=</mo>
<mrow>
<mrow>
<msup>
<mi>f</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>H</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>∩</mo>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>M</ci>
<ci>normal-′</ci>
</apply>
<apply>
<intersect></intersect>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>H</ci>
<ci>normal-′</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   M^{\prime}=f^{-1}(H^{\prime})\cap C_{w}
  </annotation>
</semantics>
</math>

. Then, by the definition of the 

<math display="inline" id="Exact_division:77">
<semantics>
<msub>
<mi>v</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   v_{i}
  </annotation>
</semantics>
</math>

:</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Exact_division:78">
<semantics>
<mrow>
<mrow>
<mrow>
<mo>∀</mo>
<mi>i</mi>
</mrow>
<mo>=</mo>
<mrow>
<mn>1</mn>
<mo>,</mo>
<mi mathvariant="normal">⋯</mi>
<mo>,</mo>
<mi>n</mi>
</mrow>
</mrow>
<mo rspace="11pt">:</mo>
<mrow>
<mrow>
<msub>
<mi>u</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>M</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>u</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>M</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>w</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<eq></eq>
<apply>
<csymbol cd="latexml">for-all</csymbol>
<ci>i</ci>
</apply>
<list>
<cn type="integer">1</cn>
<ci>normal-⋯</ci>
<ci>n</ci>
</list>
</apply>
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>u</ci>
<ci>i</ci>
</apply>
<ci>M</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>u</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>M</ci>
<ci>normal-′</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<divide></divide>
<ci>w</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \forall i=1,\cdots,n:\,\,\,\,\,u_{i}(M)=u_{i}(M^{\prime})=w/2
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>The set 

<math display="inline" id="Exact_division:79">
<semantics>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{w}
  </annotation>
</semantics>
</math>

 has 

<math display="inline" id="Exact_division:80">
<semantics>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n-1
  </annotation>
</semantics>
</math>

 connected components (intervals). Hence, its image 

<math display="inline" id="Exact_division:81">
<semantics>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>f</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(C_{w})
  </annotation>
</semantics>
</math>

 also has 

<math display="inline" id="Exact_division:82">
<semantics>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n-1
  </annotation>
</semantics>
</math>

 connected components (1-dimensional curves in 

<math display="inline" id="Exact_division:83">
<semantics>
<msup>
<mi>ℝ</mi>
<mi>n</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℝ</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
</semantics>
</math>

).</li>
<li>The hyperplane that forms the boundary between 

<math display="inline" id="Exact_division:84">
<semantics>
<mi>H</mi>
<annotation-xml encoding="MathML-Content">
<ci>H</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   H
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Exact_division:85">
<semantics>
<msup>
<mi>H</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>H</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H^{\prime}
  </annotation>
</semantics>
</math>

 intersects 

<math display="inline" id="Exact_division:86">
<semantics>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>f</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(C_{w})
  </annotation>
</semantics>
</math>

 in at most 

<math display="inline" id="Exact_division:87">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

 points. Hence, the total number of connected components (curves) in 

<math display="inline" id="Exact_division:88">
<semantics>
<mrow>
<mi>H</mi>
<mo>∩</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<intersect></intersect>
<ci>H</ci>
<apply>
<times></times>
<ci>f</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H\cap f(C_{w})
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Exact_division:89">
<semantics>
<mrow>
<msup>
<mi>H</mi>
<mo>′</mo>
</msup>
<mo>∩</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>C</mi>
<mi>w</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<intersect></intersect>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>H</ci>
<ci>normal-′</ci>
</apply>
<apply>
<times></times>
<ci>f</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>w</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H^{\prime}\cap f(C_{w})
  </annotation>
</semantics>
</math>

 is 

<math display="inline" id="Exact_division:90">
<semantics>
<mrow>
<mrow>
<mn>2</mn>
<mi>n</mi>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>n</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2n-1
  </annotation>
</semantics>
</math>

. Hence, one of these must have at most 

<math display="inline" id="Exact_division:91">
<semantics>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n-1
  </annotation>
</semantics>
</math>

 components.</li>
<li>Suppose it is 

<math display="inline" id="Exact_division:92">
<semantics>
<mi>H</mi>
<annotation-xml encoding="MathML-Content">
<ci>H</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   H
  </annotation>
</semantics>
</math>

 that has at most 

<math display="inline" id="Exact_division:93">
<semantics>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n-1
  </annotation>
</semantics>
</math>

 components (curves). Hence, 

<math display="inline" id="Exact_division:94">
<semantics>
<mi>M</mi>
<annotation-xml encoding="MathML-Content">
<ci>M</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   M
  </annotation>
</semantics>
</math>

 has at most 

<math display="inline" id="Exact_division:95">
<semantics>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n-1
  </annotation>
</semantics>
</math>

 components (intervals).</li>
<li>Hence, we can take 

<math display="inline" id="Exact_division:96">
<semantics>
<mrow>
<msub>
<mi>C</mi>
<mrow>
<mi>w</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msub>
<mo>=</mo>
<mi>M</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<apply>
<divide></divide>
<ci>w</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>M</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{w/2}=M
  </annotation>
</semantics>
</math>

. This proves that 

<math display="inline" id="Exact_division:97">
<semantics>
<mrow>
<mi>w</mi>
<mo>∈</mo>
<mi>W</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>w</ci>
<ci>W</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w\in W
  </annotation>
</semantics>
</math>

.</li>
</ul>
<h3 id="multi-dimensional-cake-many-partners-many-subsets-equal-weights">Multi-dimensional cake, many partners, many subsets, equal weights</h3>
<div id="stone_tukey">
</div>

<p>The <a href="Stone-Tukey_theorem" title="wikilink">Stone-Tukey theorem</a> states that given 

<math display="inline" id="Exact_division:98">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>
<a class="uri" href="measurable" title="wikilink">measurable</a> "objects" in 

<math display="inline" id="Exact_division:99">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

-<a href="dimension" title="wikilink">dimensional</a> space, it is possible to divide all of them in half (with respect to their <a href="Measure_(mathematics)" title="wikilink">measure</a>, i.e. volume) with a single 

<math display="inline" id="Exact_division:100">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>n</mi>
<mi mathvariant="normal">−</mi>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>n</ci>
<ci>normal-−</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (n−1)
  </annotation>
</semantics>
</math>

-dimensional <a class="uri" href="hyperplane" title="wikilink">hyperplane</a>.</p>

<p>Stated differently: if the cake is the space 

<math display="inline" id="Exact_division:101">
<semantics>
<msup>
<mi>ℝ</mi>
<mi>n</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℝ</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
</semantics>
</math>

, and the value measures of the partners are finite and vanish on any 

<math display="inline" id="Exact_division:102">
<semantics>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n-1
  </annotation>
</semantics>
</math>

 dimensional hyperplane, then there is a half-space whose value is exactly 1/2 to each partner. Hence there exists a consensus division using a <em>single</em> cut.</p>

<p>The original version of this theorem works only if the number of dimensions of the cake is equal to the number of partners. E.g, it is not possible to use this theorem to divide a 3-dimensional sandwich to 4 or more partners.</p>

<p>However, there are generalizations that enable such a division. They do not use a hyperplane knife but rather a more complicated polynomial surface.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="near-exact-division-procedures">Near-Exact division procedures</h2>
<h3 id="crumb-and-pack-procedure">Crumb-and-Pack procedure</h3>
<div id="crumb_and_pack">
</div>

<p>For any given 

<math display="inline" id="Exact_division:103">
<semantics>
<mrow>
<mi>ϵ</mi>
<mo>&gt;</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<gt></gt>
<ci>ϵ</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \epsilon&gt;0
  </annotation>
</semantics>
</math>

, one can give each partner a piece such that all partners believe that the values they have differ by less than 

<math display="inline" id="Exact_division:104">
<semantics>
<mi>ϵ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ϵ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \epsilon
  </annotation>
</semantics>
</math>

, i.e., for every <em>i</em> and every <em>j</em>:<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>
<math display="block" id="Exact_division:105">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<mrow>
<msub>
<mi>V</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>P</mi>
<mi>j</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>-</mo>
<msub>
<mi>w</mi>
<mi>j</mi>
</msub>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mo>&lt;</mo>
<mi>ϵ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<lt></lt>
<apply>
<abs></abs>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>P</ci>
<ci>j</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>w</ci>
<ci>j</ci>
</apply>
</apply>
</apply>
<ci>ϵ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |V_{i}(P_{j})-w_{j}|&lt;\epsilon
  </annotation>
</semantics>
</math>
</p>

<p>The near-exact division procedure has two steps: <em>crumbing</em> and <em>packing</em>.</p>

<p><strong>Crumbing step</strong>: the goal is to cut the cake to tiny bits ("crumbs") such that each partner assigns a sufficiently small value to each crumb. This is done in the following way. Let <em>k</em> be a certain constant. Ask partner #1 cut the cake to <em>k</em> pieces that he values as 1/<em>k</em>. Ask partner #2 to trim pieces as needed (using at most <em>k</em>-1 cuts) such that each piece has a value of at most 1/<em>k</em>. These new pieces of course still have a value of at most 1/<em>k</em> for partner #1. Continue with partners #3, #4, ..., #<em>n</em>. Finally all <em>n</em> partners value each resulting crumb as at most 1/<em>k</em>.</p>

<p><strong>Packing step</strong>: the goal here is to partition the crumbs to <em>n</em> subsets, such that the sum of values in each subset <em>j</em> is near <em>w</em><sub><em>j</em></sub>. Here is an intuitive explanation of the packing step for two partners (Alice and George) when the weights are 1/2.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<ol>
<li>Get an empty bowl.</li>
<li>Insert into the bowl one of the crumbs.</li>
<li>If the value in the bowl becomes more than 1/2 to either partner, give the bowl to that partner and give the other crumbs to the other partner.</li>
<li>Otherwise (the value in the bowl is less than 1/2 to both partners), if the value in the bowl is larger for Alice than for George, then find a crumb whose value for George is more than its value for Alice (such a crumb must exist because the sum of values of all crumbs is 1 both for Alice and for George). Add this crumb to the bowl and return to step 2.</li>
</ol>

<p>It is possible to prove by induction, that the difference in the valuation of the bowl between Alice and George is always at most 1/<em>k</em>. Hence, when one of the partners receives the bowl, its value for both partners is between than 1/2-1/<em>k</em> and 1/2+1/<em>k</em>.</p>

<p>Formally, each piece can be represented as a vector of values, one per partner. The length of each vector is bounded, i.e. for each such vector <em>v</em>
<math display="block" id="Exact_division:106">
<semantics>
<mrow>
<mrow>
<mo fence="true">||</mo>
<mi>v</mi>
<mo fence="true">||</mo>
</mrow>
<mo>≤</mo>
<mrow>
<msqrt>
<mi>n</mi>
</msqrt>
<mo>/</mo>
<mi>k</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<apply>
<csymbol cd="latexml">norm</csymbol>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<apply>
<root></root>
<ci>n</ci>
</apply>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   ||v||\leq\sqrt{n}/k
  </annotation>
</semantics>
</math>

. Our goal is to create, for each partner <em>j</em>, a vector all whose elements are near <em>w</em><sub><em>j</em></sub>. To do this, we have to divide the vectors to subsets, such that the sum of vectors in each subset <em>j</em> is sufficiently close to a vector all whose elements are <em>w</em><sub><em>j</em></sub>. This is possible thanks to a theorem by V.Bergström,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>The Crumb-and-Pack procedure is a subroutine in the <a href="Robertson-Webb_protocol" title="wikilink">Robertson-Webb protocol</a>. The latter protocol generates a division which is both near-exact and <a class="uri" href="envy-free" title="wikilink">envy-free</a>.</p>

<p>A different explanation of the crumb-and-pack procedure is provided by Brams and Taylor.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="truthful-mechanisms">Truthful mechanisms</h2>

<p>Any algorithm for consensus division relies on the value measures reported by the partners. If the partners know how the algorithm works, they may have an incentive to lie about their value measures in order to receive more than their weight. In order to prevent this, <a href="incentive_compatible" title="wikilink">incentive compatible</a> (truthful) <a href="Mechanism_design" title="wikilink">mechanisms</a> can be used.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>The simplest truthful division mechanism is: select a single partner at random (with probabilities determined by the weights) and give him the entire cake. This mechanism is trivially truthful because it asks no questions. Moreover, it is consensus in expectation: the expected value of each partner is exactly its weight, and this is true according to all value measures. However, the resulting division is of course not a consensus division.</p>

<p>A better truthful mechanism, which works for the case in which all weights are 1/<em>n</em>, can be built given any existing algorithm (or oracle) for finding a consensus division:</p>
<ol>
<li>Ask each partner to report his value measure.</li>
<li>Use the existing algorithm/oracle to generate a partition in which all <em>n</em> pieces are exactly 1/<em>n</em> according to the value functions reported by the partners.</li>
<li>Perform a random permutation on the consensus partition and give each partner one of the pieces.</li>
</ol>

<p>Here, the expected value of each partner is still 1/<em>n</em> regardless of the reported value function, so the mechanism is still truthful - no partner can gain anything from lying. Moreover, a truthful partner is guaranteed a value of exactly 1/<em>n</em> with probability 1 (not only in expectation). Hence the partners have an incentive to reveal their true value functions.</p>
<h2 id="impossibility">Impossibility</h2>

<p>It is impossible to achieve an exact division with a finite number of queries, even if there are only 2 partners and the weights are exactly 1/2.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> This means that the best we can achieve using a discrete algorithm is a near-exact division.</p>

<p><strong>Proof</strong>: When the protocol is at step <em>k</em>, it has a collection of at most <em>k</em> pieces. To provide an exact division, the protocol must find an <em>exact subset</em> - a subset of the pieces which both partners value as exactly 1/2. We are going to prove that, for every <em>k</em>, there are situations in which at step <em>k</em> there is no exact subset, and hence the protocol might have to continue endlessly.</p>

<p>Initially, there is only one piece which both partners value as 1, so there is obviously no exact subset. After one step, at most one partner (say, Alice) has had an option to cut the cake. Even if Alice cuts the cake to two pieces that are equal in her opinion, they may be different in George's opinion, so again there is no exact subset.</p>

<p>Suppose now that we are at step <em>k</em> and there are <em>k</em> pieces. Without loss of generality, we may assume that each piece has a non-zero value to both partners. This is because, if Alice (for example) cuts a piece which she values as 0, it is possible that George also values the same piece as 0, so we can discard this piece and continue with the other pieces.</p>

<p>The total number of different subsets now is 2<sup><em>k</em></sup>, and by the induction assumption none of them is exact. At step <em>k</em>, the protocol can ask either Alice or George to cut a certain piece to two pieces. Suppose w.l.o.g. that the cutter is George and that he cuts piece X to two sub-pieces: X1 and X2. Now, the total number of subsets is 2<sup><em>k</em>+1</sup>: half of them already existed and by assumption they are not exact, so the protocol's only chance of finding an exact subset is to look at the new subsets. Each new subset is made of an old subset in which the piece X has been replaced with either X1 or X2. Since George is the cutter, he can cut in a way which makes one of these subsets an exact subset for him (e.g. if a certain subset containing piece X had a value of 3/4, George can cut X such that X1 has a value of 1/4 in his opinion, so that the new subset has a value of exactly 1/2). But, George does not know Alice's valuation and cannot take it into account when cutting. Therefore, there is an uncountable infinity of different values that the pieces X1 and X2 can have for Alice. Since the number of new subsets is finite, there is an infinite number of cases in which no new subset has a value of 1/2 for Alice, hence no new subset is exact.</p>
<h2 id="comparison-with-other-criteria">Comparison with other criteria</h2>

<p>An exact division with equal weights (

<math display="inline" id="Exact_division:107">
<semantics>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1/n
  </annotation>
</semantics>
</math>

) is, in particular, also <a href="proportional_division" title="wikilink">proportional</a>, <a class="uri" href="envy-free" title="wikilink">envy-free</a> and <a href="equitable_division" title="wikilink">equitable</a>.</p>

<p>However, it is not necessarily <a href="Pareto_efficient" title="wikilink">Pareto efficient</a>, since in many cases it is possible to take advantage of the subjective valuations and divide the resources such that all partners receive more than their fair share of 

<math display="inline" id="Exact_division:108">
<semantics>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1/n
  </annotation>
</semantics>
</math>

.</p>

<p>Exact divisions are much easier if the participants cooperate in establishing <a href="entitlement_(fair_division)" title="wikilink">entitlements</a> rather than competing as in <a href="fair_division" title="wikilink">fair division</a>. Some authors refer to this as <strong>consensus division</strong> or <strong>consensus halving</strong>.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h2 id="summary-table">Summary table</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>Result</p></th>
<th style="text-align: left;">

<p>Type</p></th>
<th style="text-align: left;">

<p>Cake</p></th>
<th style="text-align: left;">

<p>#partners (

<math display="inline" id="Exact_division:109">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

)</p></th>
<th style="text-align: left;">

<p>#subsets (

<math display="inline" id="Exact_division:110">
<semantics>
<mi>k</mi>
<annotation-xml encoding="MathML-Content">
<ci>k</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   k
  </annotation>
</semantics>
</math>

)</p></th>
<th style="text-align: left;">

<p>#cuts</p></th>
<th style="text-align: left;">

<p>weights</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p><a href="#austin" title="wikilink">Austin</a></p></td>
<td style="text-align: left;">

<p>Moving-knife procedure</p></td>
<td style="text-align: left;">

<p>Interval</p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>Many</p></td>
<td style="text-align: left;">

<p>
<math display="inline" id="Exact_division:111">
<semantics>
<mrow>
<mn>2</mn>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>k</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<cn type="integer">2</cn>
<apply>
<minus></minus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2(k-1)
  </annotation>
</semantics>
</math>

 (optimal)</p></td>
<td style="text-align: left;">

<p>Any</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><a href="#piecewise" title="wikilink">Piecewise-homogeneous</a></p></td>
<td style="text-align: left;">

<p>Discrete procedure</p></td>
<td style="text-align: left;">

<p>Piecewise-homogeneous</p></td>
<td style="text-align: left;">

<p>Many</p></td>
<td style="text-align: left;">

<p>Many</p></td>
<td style="text-align: left;">

<p>Num. of districts</p></td>
<td style="text-align: left;">

<p>Any</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><a href="#dubins_spanier" title="wikilink">Dubins–Spanier</a></p></td>
<td style="text-align: left;">

<p>Existence proof</p></td>
<td style="text-align: left;">

<p>Any</p></td>
<td style="text-align: left;">

<p>Many</p></td>
<td style="text-align: left;">

<p>Many</p></td>
<td style="text-align: left;">

<p>Unbounded</p></td>
<td style="text-align: left;">

<p>Any</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><a href="#halving" title="wikilink">Consensus-halving</a></p></td>
<td style="text-align: left;">

<p>Infinite procedure</p></td>
<td style="text-align: left;">

<p>Interval</p></td>
<td style="text-align: left;">

<p>Many</p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>
<math display="inline" id="Exact_division:112">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

 (optimal)</p></td>
<td style="text-align: left;">

<p>Equal</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><a href="#necklace" title="wikilink">Necklace-splitting</a></p></td>
<td style="text-align: left;">

<p>Existence proof</p></td>
<td style="text-align: left;">

<p>Interval</p></td>
<td style="text-align: left;">

<p>Many</p></td>
<td style="text-align: left;">

<p>Many</p></td>
<td style="text-align: left;">

<p>
<math display="inline" id="Exact_division:113">
<semantics>
<mrow>
<mi>n</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>k</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>n</ci>
<apply>
<minus></minus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n(k-1)
  </annotation>
</semantics>
</math>

 (optimal)</p></td>
<td style="text-align: left;">

<p>Equal</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><a href="#stromquist_woodall" title="wikilink">Stromquist-Woodall</a></p></td>
<td style="text-align: left;">

<p>Existence proof</p></td>
<td style="text-align: left;">

<p>Circle</p></td>
<td style="text-align: left;">

<p>Many</p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>
<math display="inline" id="Exact_division:114">
<semantics>
<mrow>
<mn>2</mn>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2n
  </annotation>
</semantics>
</math>

 (optimal for some weights)</p></td>
<td style="text-align: left;">

<p>Any</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p><a href="#stone_tukey" title="wikilink">Stone–Tukey</a></p></td>
<td style="text-align: left;">

<p>Existence proof</p></td>
<td style="text-align: left;">

<p>
<math display="inline" id="Exact_division:115">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

-dimensional</p></td>
<td style="text-align: left;">

<p>
<math display="inline" id="Exact_division:116">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>
</p></td>
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>1 half-plane</p></td>
<td style="text-align: left;">

<p>Equal</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p><a href="#crumb_and_pack" title="wikilink">Crumb-and-pack</a></p></td>
<td style="text-align: left;">

<p>Near-exact procedure</p></td>
<td style="text-align: left;">

<p>Any</p></td>
<td style="text-align: left;">

<p>Many</p></td>
<td style="text-align: left;">

<p>Many</p></td>
<td style="text-align: left;">

<p>Unbounded</p></td>
<td style="text-align: left;">

<p>Any</p></td>
</tr>
</tbody>
</table>
<h2 id="references">References</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Fair_cake-cutting" title="wikilink">Fair cake-cutting</a></li>
<li><a href="Problem_of_the_Nile" title="wikilink">Problem of the Nile</a></li>
</ul>

<p>"</p>

<p><a href="Category:Fair_division" title="wikilink">Category:Fair division</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">, Corollary 1.1.<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">There is a generalization which gives each of <em>n</em> partners, a piece worth exactly 

<math display="inline" id="Exact_division:117">
<semantics>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1/n
  </annotation>
</semantics>
</math>

 for him. But this is not a consensus division, because the partners may not agree on the value of the other pieces besides the piece allocated to them. See <a href="Austin_moving-knife_procedures#Many_partners" title="wikilink">Austin moving-knife procedures#Many partners</a>.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18">Adapted from <a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
</ol>
</section>
</body>
</html>
