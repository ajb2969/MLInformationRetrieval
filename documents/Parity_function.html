<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="325">Parity function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Parity function</h1>
<hr/>

<p>In <a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra</a>, a <strong>parity function</strong> is a <a href="Boolean_function" title="wikilink">Boolean function</a> whose value is 1 <a href="if_and_only_if" title="wikilink">if and only if</a> the input vector has an odd number of ones. The parity function of two inputs is also known as the <a href="XOR_gate" title="wikilink">XOR</a> function.</p>

<p>The parity function is notable for its role in theoretical investigation of <a href="circuit_complexity" title="wikilink">circuit complexity</a> of Boolean functions.</p>
<h2 id="definition">Definition</h2>

<p>The 

<math display="inline" id="Parity_function:0">
<semantics>
<mi>n</mi>
<annotation-xml encoding="MathML-Content">
<ci>n</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   n
  </annotation>
</semantics>
</math>

-variable parity function is the <a href="Boolean_function" title="wikilink">Boolean function</a>
<math display="inline" id="Parity_function:1">
<semantics>
<mrow>
<mi>f</mi>
<mo>:</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<mi>n</mi>
</msup>
<mo>→</mo>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>f</ci>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
<ci>n</ci>
</apply>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f:\{0,1\}^{n}\to\{0,1\}
  </annotation>
</semantics>
</math>

 with the property that 

<math display="inline" id="Parity_function:2">
<semantics>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>f</ci>
<ci>x</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(x)=1
  </annotation>
</semantics>
</math>
<a href="if_and_only_if" title="wikilink">if and only if</a> the number of ones in the vector 

<math display="inline" id="Parity_function:3">
<semantics>
<mrow>
<mi>x</mi>
<mo>∈</mo>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<mi>n</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x\in\{0,1\}^{n}
  </annotation>
</semantics>
</math>


 is odd. In other words, 

<math display="inline" id="Parity_function:4">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 is defined as follows:</p>

<p>
<math display="block" id="Parity_function:5">
<semantics>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>⊕</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
<mo>⊕</mo>
<mi mathvariant="normal">…</mi>
<mo>⊕</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>f</ci>
<ci>x</ci>
</apply>
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(x)=x_{1}\oplus x_{2}\oplus\dots\oplus x_{n}
  </annotation>
</semantics>
</math>

.</p>
<h2 id="properties">Properties</h2>

<p>Parity only depends on the number of ones and is therefore a <a href="symmetric_Boolean_function" title="wikilink">symmetric Boolean function</a>.</p>

<p>The <em>n</em>-variable parity function and its negation are the only Boolean functions for which all <a href="disjunctive_normal_form" title="wikilink">disjunctive normal forms</a> have the maximal number of 2<sup> <em>n</em> − 1</sup> <a href="monomial" title="wikilink">monomials</a> of length <em>n</em> and all <a href="conjunctive_normal_form" title="wikilink">conjunctive normal forms</a> have the maximal number of 2<sup> <em>n</em> − 1</sup> clauses of length <em>n</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="circuit-complexity">Circuit complexity</h2>

<p>In the early 1980s, <a href="Merrick_L._Furst" title="wikilink">Merrick Furst</a>, <a href="James_Saxe" title="wikilink">James Saxe</a> and <a href="Michael_Sipser" title="wikilink">Michael Sipser</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and independently <a href="Miklós_Ajtai" title="wikilink">Miklós Ajtai</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> established super-polynomial <a href="lower_bound" title="wikilink">lower bounds</a> on the size of constant-depth <a href="Boolean_circuits" title="wikilink">Boolean circuits</a> for the parity function, i.e., they showed that polynomial-size constant-depth circuits cannot compute the parity function. Similar results were also established for the majority, multiplication and transitive closure functions, by reduction from the parity function.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>  established tight exponential lower bounds on the size of constant-depth <a href="Boolean_circuits" title="wikilink">Boolean circuits</a> for the parity function. <a href="Håstad's_Switching_Lemma" title="wikilink">Håstad's Switching Lemma</a> is the key technical tool used for these lower bounds and <a href="Johan_Håstad" title="wikilink">Johan Håstad</a> was awarded the <a href="Gödel_Prize" title="wikilink">Gödel Prize</a> for this work in 1994. The precise result is that depth-

<math display="inline" id="Parity_function:6">
<semantics>
<mi>k</mi>
<annotation-xml encoding="MathML-Content">
<ci>k</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   k
  </annotation>
</semantics>
</math>

 circuits with AND, OR, and NOT gates require size 

<math display="inline" id="Parity_function:7">
<semantics>
<mrow>
<mi>exp</mi>
<mrow>
<mo>(</mo>
<mrow>
<mi mathvariant="normal">Ω</mi>
<mrow>
<mo>(</mo>
<msup>
<mi>n</mi>
<mfrac>
<mn>1</mn>
<mrow>
<mi>k</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mfrac>
</msup>
<mo>)</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<exp></exp>
<apply>
<times></times>
<ci>normal-Ω</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>n</ci>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<minus></minus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \exp\left(\Omega\left(n^{\frac{1}{k-1}}\right)\right)
  </annotation>
</semantics>
</math>

 to compute the parity function. This is asymptotically almost optimal as there are depth-

<math display="inline" id="Parity_function:8">
<semantics>
<mi>k</mi>
<annotation-xml encoding="MathML-Content">
<ci>k</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   k
  </annotation>
</semantics>
</math>


 circuits computing parity which have size 

<math display="inline" id="Parity_function:9">
<semantics>
<mrow>
<mi>exp</mi>
<mrow>
<mo>(</mo>
<mrow>
<mi>O</mi>
<mrow>
<mo>(</mo>
<msup>
<mi>n</mi>
<mfrac>
<mn>1</mn>
<mrow>
<mi>k</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mfrac>
</msup>
<mo>)</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<exp></exp>
<apply>
<times></times>
<ci>O</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>n</ci>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<minus></minus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \exp\left(O\left(n^{\frac{1}{k-1}}\right)\right)
  </annotation>
</semantics>
</math>

.</p>
<h2 id="infinite-version">Infinite version</h2>

<p>An infinite parity function is a function 

<math display="inline" id="Parity_function:10">
<semantics>
<mrow>
<mi>f</mi>
<mo>:</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<mi>ω</mi>
</msup>
<mo>→</mo>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>f</ci>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
<ci>ω</ci>
</apply>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f\colon\{0,1\}^{\omega}\to\{0,1\}
  </annotation>
</semantics>
</math>

 mapping every infinite binary string to 0 or 1, having the following property: if 

<math display="inline" id="Parity_function:11">
<semantics>
<mi>w</mi>
<annotation-xml encoding="MathML-Content">
<ci>w</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   w
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Parity_function:12">
<semantics>
<mi>v</mi>
<annotation-xml encoding="MathML-Content">
<ci>v</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   v
  </annotation>
</semantics>
</math>

 are infinite binary strings differing only on finite number of coordinates then 

<math display="inline" id="Parity_function:13">
<semantics>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>w</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>f</ci>
<ci>w</ci>
</apply>
<apply>
<times></times>
<ci>f</ci>
<ci>v</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(w)=f(v)
  </annotation>
</semantics>
</math>


 if and only if 

<math display="inline" id="Parity_function:14">
<semantics>
<mi>w</mi>
<annotation-xml encoding="MathML-Content">
<ci>w</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   w
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Parity_function:15">
<semantics>
<mi>v</mi>
<annotation-xml encoding="MathML-Content">
<ci>v</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   v
  </annotation>
</semantics>
</math>

 differ on even number of coordinates.</p>

<p>Assuming <a href="axiom_of_choice" title="wikilink">axiom of choice</a> it can be easily proved that parity functions exist and there are 

<math display="inline" id="Parity_function:16">
<semantics>
<msup>
<mn>2</mn>
<mi>𝔠</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>𝔠</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{\mathfrak{c}}
  </annotation>
</semantics>
</math>

 many of them - as many as the number of all functions from 

<math display="inline" id="Parity_function:17">
<semantics>
<msup>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<mi>ω</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
<ci>ω</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{0,1\}^{\omega}
  </annotation>
</semantics>
</math>

 to 

<math display="inline" id="Parity_function:18">
<semantics>
<mrow>
<mo stretchy="false">{</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">}</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<set>
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</set>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{0,1\}
  </annotation>
</semantics>
</math>


. It is enough to take one representative per equivalence class of relation 

<math display="inline" id="Parity_function:19">
<semantics>
<mo>≈</mo>
<annotation-xml encoding="MathML-Content">
<approx></approx>
</annotation-xml>
<annotation encoding="application/x-tex">
   \approx
  </annotation>
</semantics>
</math>

 defined as follows

<math display="block" id="Parity_function:20">
<semantics>
<mrow>
<mi>w</mi>
<mo>≈</mo>
<mi>v</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<approx></approx>
<ci>w</ci>
<ci>v</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w\approx v
  </annotation>
</semantics>
</math>

 if 

<math display="inline" id="Parity_function:21">
<semantics>
<mi>w</mi>
<annotation-xml encoding="MathML-Content">
<ci>w</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   w
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Parity_function:22">
<semantics>
<mi>v</mi>
<annotation-xml encoding="MathML-Content">
<ci>v</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   v
  </annotation>
</semantics>
</math>

 differ at finite number of coordinates. Having such representatives, we can map all of them to 0; the rest of 

<math display="inline" id="Parity_function:23">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>


 values are deducted unambiguously.</p>

<p>Infinite parity functions are often used in theoretical Computer Science and Set Theory because of their simple definition and - on the other hand - their descriptive complexity. For example, it can be shown that an inverse image 

<math display="inline" id="Parity_function:24">
<semantics>
<mrow>
<msup>
<mi>f</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">[</mo>
<mn>0</mn>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f^{-1}[0]
  </annotation>
</semantics>
</math>

 is a <a href="non-Borel_set" title="wikilink">non-Borel set</a>.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Boolean_algebra" title="wikilink">Category:Boolean algebra</a> <a href="Category:Circuit_complexity" title="wikilink">Category:Circuit complexity</a> <a href="Category:Functions_and_mappings" title="wikilink">Category:Functions and mappings</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Ingo_Wegener" title="wikilink">Ingo Wegener</a>, Randall J. Pruim, <em>Complexity Theory</em>, 2005, ISBN 3-540-21045-8, [<a class="uri" href="http://books.google.com/books?id=u7DZSDSUYlQC&amp;pg">http://books.google.com/books?id=u7DZSDSUYlQC&amp;pg;</a>;=PA261&amp;lpg;=PA261&amp;dq;=%22parity+function%22+H%C3%A5stad&amp;source;=bl&amp;ots;=HNQ-Jx67yy&amp;sig;=qOg_lAiE3JbqsDdQO0rrmgxJmDs&amp;hl;=en&amp;ei;=U9PjSfGYDYjaswOCkNysCQ&amp;sa;=X&amp;oi;=book_result&amp;ct;=result&amp;resnum;=3#PPA260,M1 p. 260]<a href="#fnref1">↩</a></li>
<li id="fn2">Merrick Furst, James Saxe and Michael Sipser, "Parity, Circuits, and the Polynomial-Time Hierarchy", Annu. Intl. Symp. Found.Coimputer Sci., 1981, <em><a href="Theory_of_Computing_Systems" title="wikilink">Theory of Computing Systems</a></em>, vol. 17, no. 1, 1984, pp. 13–27, <a href="#fnref2">↩</a></li>
<li id="fn3">Miklós Ajtai, "

<math display="inline" id="Parity_function:25">
<semantics>
<msubsup>
<mi mathvariant="normal">Σ</mi>
<mn>1</mn>
<mn>1</mn>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Σ</ci>
<cn type="integer">1</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Sigma^{1}_{1}
  </annotation>
</semantics>
</math>

-Formulae on Finite Structures", <em><a href="Annals_of_Pure_and_Applied_Logic" title="wikilink">Annals of Pure and Applied Logic</a></em>, 24 (1983) 1–48.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
</ol>
</section>
</body>
</html>
