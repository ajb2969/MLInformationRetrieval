<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1035">Cache-oblivious distribution sort</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cache-oblivious distribution sort</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>The cache-oblivious <strong>distribution sort</strong> is a <a href="comparison_sort" title="wikilink">comparison-based</a> <a href="sorting_algorithm" title="wikilink">sorting algorithm</a>. It was introduced in 1999 in the context of the <a href="Cache-oblivious_algorithm" title="wikilink">cache oblivious model</a>. In the external memory model, the number of memory transfers it needs to perform a sort of 

<math display="inline" id="Cache-oblivious_distribution_sort:0">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 items on a machine with cache of size 

<math display="inline" id="Cache-oblivious_distribution_sort:1">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 and cache lines of length 

<math display="inline" id="Cache-oblivious_distribution_sort:2">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Cache-oblivious_distribution_sort:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mfrac>
      <mi>N</mi>
      <mi>L</mi>
     </mfrac>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>Z</mi>
      </msub>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>N</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <ci>Z</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\frac{N}{L}\log_{Z}N)
  </annotation>
 </semantics>
</math>


, under the tall cache assumption that 

<math display="inline" id="Cache-oblivious_distribution_sort:4">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>L</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <times></times>
     <ci>normal-Ω</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=\Omega(L^{2})
  </annotation>
 </semantics>
</math>

. This number of memory transfers has been shown to be asymptotically optimal for comparison sorts. This distribution sort also achieves the asymptotically optimal runtime complexity of 

<math display="inline" id="Cache-oblivious_distribution_sort:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mi>log</mi>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <log></log>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(N\log N)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="algorithm">Algorithm</h2>
<h3 id="basic-overview">Basic Overview</h3>

<p>Distribution sort operates on a contiguous array of 

<math display="inline" id="Cache-oblivious_distribution_sort:6">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 elements. To sort the elements, it performs the following:</p>
<ol>
<li>Partition the array into 

<math display="inline" id="Cache-oblivious_distribution_sort:7">
 <semantics>
  <msqrt>
   <mi>N</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{N}
  </annotation>
 </semantics>
</math>

 contiguous subarrays of size 

<math display="inline" id="Cache-oblivious_distribution_sort:8">
 <semantics>
  <msqrt>
   <mi>N</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{N}
  </annotation>
 </semantics>
</math>


, and recursively sort each subarray.</li>
<li>Distribute the elements of the sorted subarrays into 

<math display="inline" id="Cache-oblivious_distribution_sort:9">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>≤</mo>
   <msqrt>
    <mi>N</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>q</ci>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\leq\sqrt{N}
  </annotation>
 </semantics>
</math>

 buckets 

<math display="inline" id="Cache-oblivious_distribution_sort:10">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>B</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>B</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>q</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{1},B_{2},\ldots,B_{q}
  </annotation>
 </semantics>
</math>

 each of size at most 

<math display="inline" id="Cache-oblivious_distribution_sort:11">
 <semantics>
  <mrow>
   <mn>2</mn>
   <msqrt>
    <mi>N</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\sqrt{N}
  </annotation>
 </semantics>
</math>

 such that for every i from 1 to q-1, every element of bucket 

<math display="inline" id="Cache-oblivious_distribution_sort:12">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{i}
  </annotation>
 </semantics>
</math>

 is not larger than any element in 

<math display="inline" id="Cache-oblivious_distribution_sort:13">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{i+1}.
  </annotation>
 </semantics>
</math>


 This distribution step is the main step of this algorithm, and is covered in more detail below.</li>
<li>Recursively sort each bucket.</li>
<li>Output the concatenation of the buckets.</li>
</ol>
<h3 id="distribution-step">Distribution Step</h3>

<p>As mentioned in step 2 above, the goal of the distribution step is to distribute the sorted subarrays into q buckets 

<math display="inline" id="Cache-oblivious_distribution_sort:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>B</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>B</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>B</mi>
     <mi>q</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>q</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{1},B_{2},\ldots,B_{q}.
  </annotation>
 </semantics>
</math>

 The distribution step algorithm maintains two invariants. The first is that each bucket has size at most 

<math display="inline" id="Cache-oblivious_distribution_sort:15">
 <semantics>
  <mrow>
   <mn>2</mn>
   <msqrt>
    <mi>N</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\sqrt{N}
  </annotation>
 </semantics>
</math>

 at any time, and any element in bucket 

<math display="inline" id="Cache-oblivious_distribution_sort:16">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{i}
  </annotation>
 </semantics>
</math>

 is no larger than any element in bucket 

<math display="inline" id="Cache-oblivious_distribution_sort:17">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{i+1}.
  </annotation>
 </semantics>
</math>

 The second is that every bucket has an associated <em>pivot</em>, a value which is greater than all elements in the bucket.</p>

<p>Initially, the algorithm starts with one empty bucket with pivot 

<math display="inline" id="Cache-oblivious_distribution_sort:18">
 <semantics>
  <mi mathvariant="normal">∞</mi>
  <annotation-xml encoding="MathML-Content">
   <infinity></infinity>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \infty
  </annotation>
 </semantics>
</math>


. As it fills buckets, it creates new buckets by splitting a bucket into two when it would be made overfull (by having at least 

<math display="inline" id="Cache-oblivious_distribution_sort:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mi>N</mi>
     </msqrt>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <ci>N</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2\sqrt{N}+1)
  </annotation>
 </semantics>
</math>

 elements placed into it). The split is done by performing the <a href="Median_of_medians" title="wikilink">linear time median finding</a> algorithm, and partitioning based on this median. The pivot of the lower bucket will be set to the median found, and the pivot of the higher bucket will be set to the same as the bucket before the split. At the end of the distribution step, all elements are in the buckets, and the two invariants will still hold.</p>

<p>To accomplish this, each subarray and bucket will have a state associated with it. The state of a subarray consists of an index <em>next</em> of the next element to be read from the subarray, and a bucket number <em>bnum</em> indicating which bucket index the element should be copied to. By convention, 

<math display="inline" id="Cache-oblivious_distribution_sort:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mi>n</mi>
    <mi>u</mi>
    <mi>m</mi>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>n</ci>
     <ci>u</ci>
     <ci>m</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   bnum=\infty
  </annotation>
 </semantics>
</math>

 if all elements in the subarray have been distributed. (Note that when we split a bucket, we have to increment all <em>bnum</em> values of all subarrays whose <em>bnum</em> value is greater than the index of the bucket that is split.) The state of a bucket consists of the value of the bucket's pivot, and the number of elements currently in the bucket.</p>

<p>Consider the follow basic strategy: iterate through each subarray, attempting to copy over its element at position <em>next</em>. If the element is smaller than the pivot of bucket <em>bnum</em>, then place it in that bucket, possibly incurring a bucket split. Otherwise, increment <em>bnum</em> until a bucket whose pivot is large enough is found. Though this correctly distributes all elements, it does not exhibit a good cache performance.</p>

<p>Instead, the distribution step is performed in a recursive divide-and-conquer. The step will be performed as a call to the function <strong>distribute</strong>, which takes three parameters i, j, and m. <strong>distribute</strong>(i,j,m) will distribute elements from the i-th through (i+m-1)-th subarrays into buckets, starting from 

<math display="inline" id="Cache-oblivious_distribution_sort:21">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{j}
  </annotation>
 </semantics>
</math>

. It requires as a precondition that each subarray r in the range 

<math display="inline" id="Cache-oblivious_distribution_sort:22">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mi>m</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>normal-…</ci>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <ci>m</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,\ldots,i+m-1
  </annotation>
 </semantics>
</math>

 has its 

<math display="inline" id="Cache-oblivious_distribution_sort:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mi>n</mi>
    <mi>u</mi>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>r</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>n</ci>
     <ci>u</ci>
     <ci>m</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>r</ci>
     </apply>
    </apply>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   bnum[r]\geq j
  </annotation>
 </semantics>
</math>


. The execution of <strong>distribute</strong>(i,j,m) will guarantee that each 

<math display="inline" id="Cache-oblivious_distribution_sort:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mi>n</mi>
    <mi>u</mi>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>r</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>j</mi>
    <mo>+</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>n</ci>
     <ci>u</ci>
     <ci>m</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>j</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   bnum[r]\geq j+m
  </annotation>
 </semantics>
</math>

. The whole distribution step is <strong>distribute</strong>

<math display="inline" id="Cache-oblivious_distribution_sort:25">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <msqrt>
    <mi>N</mi>
   </msqrt>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">1</cn>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,1,\sqrt{N})
  </annotation>
 </semantics>
</math>

. Pseudocode for the implementation of distribute is shown below:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> distribute(i,j,m):
  <span class="cf">if</span> m <span class="op">==</span> <span class="dv">1</span>:
    copy_elems(i,j)
  <span class="cf">else</span>:
    distribute(i,j,m<span class="op">/</span><span class="dv">2</span>)
    distribute(i<span class="op">+</span>m<span class="op">/</span><span class="dv">2</span>,j,m<span class="op">/</span><span class="dv">2</span>)
    distribute(i,j<span class="op">+</span>m<span class="op">/</span><span class="dv">2</span>,m<span class="op">/</span><span class="dv">2</span>)
    distribute(i<span class="op">+</span>m<span class="op">/</span><span class="dv">2</span>,j<span class="op">+</span>m<span class="op">/</span><span class="dv">2</span>,m<span class="op">/</span><span class="dv">2</span>)</code></pre></div>

<p>The base case, where m=1, has a call to the subroutine <strong>copy_elems</strong>. In this base case, all elements from subarray i that belong to bucket j are added at once. If this leads to bucket j having too many elements, it splits the bucket with the procedure described beforehand.</p>
<h2 id="references">References</h2>
<ul>
<li>Harald Prokop. <a href="http://supertech.csail.mit.edu/papers/Prokop99.pdf">Cache-Oblivious Algorithms</a>. Masters thesis, MIT. 1999.</li>
</ul>

<p>"</p>

<p><a href="Category:Sorting_algorithms" title="wikilink">Category:Sorting algorithms</a> <a href="Category:Comparison_sorts" title="wikilink">Category:Comparison sorts</a> <a href="Category:External_memory_algorithms" title="wikilink">Category:External memory algorithms</a> <a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a> <a href="Category:Cache_(computing)" title="wikilink">Category:Cache (computing)</a> <a href="Category:Analysis_of_algorithms" title="wikilink">Category:Analysis of algorithms</a></p>
</body>

