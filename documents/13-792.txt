   CoBoosting      CoBoosting   CoBoost is a semi-supervised training algorithm proposed by Collins and Singer in 1999. The original application for the algorithm was the task of Named Entity Classification using very weak learners. 1 It can be used for performing semi-supervised learning in cases in which there exist redundancy in features.  It may be seen as a combination of co-training and boosting . Each example is available in two views (subsections of the feature set), and boosting is applied iteratively in alternation with each view using predicted labels produced in the alternate view on the previous iteration. CoBoosting is not a valid boosting algorithm in the PAC learning sense.  Motivation  CoBoosting was an attempt by Collins and Singer to improve on previous attempts to leverage redundancy in features for training classifiers in a semi-supervised fashion. CoTraining, a seminal work by Blum and Mitchell, was shown to be a powerful framework for learning classifiers given a small number of seed examples by iteratively inducing rules in a decision list. The advantage of CoBoosting to CoTraining is that it generalizes the CoTraining pattern so that it could be used with any classifier. CoBoosting accomplishes this feat by borrowing concepts from AdaBoost .  In both CoTrain and CoBoost the training and testing example sets must follow two properties. The first is that the feature space of the examples can separated into two feature spaces (or views) such that each view is sufficiently expressive for classification. Formally, there exist two functions     f  1    (   x  1   )        subscript  f  1    subscript  x  1     f_{1}(x_{1})   and     f  2    (   x  2   )        subscript  f  2    subscript  x  2     f_{2}(x_{2})   such that for all examples    x  =   (   x  1   ,   x  2   )       x    subscript  x  1    subscript  x  2      x=(x_{1},x_{2})   ,      f  1    (   x  1   )    =    f  2    (   x  2   )    =   f   (  x  )             subscript  f  1    subscript  x  1       subscript  f  2    subscript  x  2           f  x      f_{1}(x_{1})=f_{2}(x_{2})=f(x)   . While ideal, this constraint is in fact too strong due to noise and other factors, and both algorithms instead seek to maximize the agreement between the two functions. The second property is that the two views must not be highly correlated.  Algorithm  Input     {   (   x   1  ,  i    ,   x   2  ,  i    )   }    i  =  1   n     superscript   subscript     subscript  x   1  i     subscript  x   2  i        i  1    n    \{(x_{1,i},x_{2,i})\}_{i=1}^{n}   ,     {   y  i   }    i  =  1   m     superscript   subscript    subscript  y  i      i  1    m    \{y_{i}\}_{i=1}^{m}     Initialize      âˆ€  i   ,  j   :     g  j  0    (   ğ’™  ğ’Š   )    =  0      normal-:    for-all  i   j        superscript   subscript  g  j   0    subscript  ğ’™  ğ’Š    0     \forall i,j:g_{j}^{0}(\boldsymbol{x_{i}})=0   .  For    t  =   1  ,  â€¦  ,  T       t   1  normal-â€¦  T     t=1,...,T   and for    j  =   1  ,  2       j   1  2     j=1,2   :  Set pseudo-labels:         y  i   ^   =   {        y  i   1   â‰¤  i  â‰¤  m          s  i  g  n   (    g   3  -  j    t  -  1     (   ğ’™    ğŸ‘  -  ğ’‹   ,  ğ’Š    )    )   m   <  i  â‰¤  n              normal-^   subscript  y  i     cases           subscript  y  i   1   i       m     missing-subexpression           s  i  g  n     superscript   subscript  g    3  j      t  1     subscript  ğ’™     3  ğ’‹   ğ’Š     m   i       n     missing-subexpression        \hat{y_{i}}=\left\{\begin{array}[]{ll}y_{i}1\leq i\leq m\\
 sign(g_{3-j}^{t-1}(\boldsymbol{x_{3-j,i}}))m     Set virtual distribution:      D  t  j    (  i  )    =    1   Z  t  j     e   -     y  i   ^    g  j   t  -  1     (   ğ’™   ğ’‹  ,  ğ’Š    )              superscript   subscript  D  t   j   i       1   superscript   subscript  Z  t   j     superscript  e       normal-^   subscript  y  i     superscript   subscript  g  j     t  1     subscript  ğ’™   ğ’‹  ğ’Š          D_{t}^{j}(i)=\frac{1}{Z_{t}^{j}}e^{-\hat{y_{i}}g_{j}^{t-1}(\boldsymbol{x_{j,i}%
 })}     where      Z  t  j   =    âˆ‘   i  =  1   n    e   -     y  i   ^    g  j   t  -  1     (   ğ’™   ğ’‹  ,  ğ’Š    )            superscript   subscript  Z  t   j     superscript   subscript     i  1    n    superscript  e       normal-^   subscript  y  i     superscript   subscript  g  j     t  1     subscript  ğ’™   ğ’‹  ğ’Š          Z_{t}^{j}=\sum_{i=1}^{n}e^{-\hat{y_{i}}g_{j}^{t-1}(\boldsymbol{x_{j,i}})}       FindÂ theÂ weakÂ hypothesis     h  t  j     superscript   subscript  h  t   j    h_{t}^{j}    thatÂ minimizesÂ expandedÂ trainingÂ error.    ChooseÂ valueÂ for     Î±  t     subscript  Î±  t    \alpha_{t}    thatÂ minimizesÂ expandedÂ trainingÂ error.  UpdateÂ theÂ valueÂ forÂ currentÂ strongÂ non-thresholdedÂ classfier:       âˆ€  i   :     g  j  t    (   ğ’™   ğ’‹  ,  ğ’Š    )    =     g  j   t  -  1     (   ğ’™   ğ’‹  ,  ğ’Š    )    +    Î±  t    h  t  j    (   ğ’™   ğ’‹  ,  ğ’Š    )         normal-:   for-all  i        superscript   subscript  g  j   t    subscript  ğ’™   ğ’‹  ğ’Š          superscript   subscript  g  j     t  1     subscript  ğ’™   ğ’‹  ğ’Š        subscript  Î±  t    superscript   subscript  h  t   j    subscript  ğ’™   ğ’‹  ğ’Š         \forall i:g_{j}^{t}(\boldsymbol{x_{j,i}})=g_{j}^{t-1}(\boldsymbol{x_{j,i}})+%
 \alpha_{t}h_{t}^{j}(\boldsymbol{x_{j,i}})     The final strong classifier output is       f   (  ğ’™  )    =   s  i  g  n   (    âˆ‘   j  =  1   2     g  j  T    (   ğ’™  ğ’‹   )     )          f  ğ’™     s  i  g  n    superscript   subscript     j  1    2      superscript   subscript  g  j   T    subscript  ğ’™  ğ’‹        f(\boldsymbol{x})=sign\left(\sum_{j=1}^{2}g_{j}^{T}(\boldsymbol{x_{j}})\right)     Setting up AdaBoost  CoBoosting builds on the AdaBoost algorithm, which gives CoBoosting its generalization ability since AdaBoost can be used in conjunction with many other learning algorithms. This build up assumes a two class classification task, although it can be adapted to multiple class classification. In the AdaBoost framework, weak classifiers are generated in series as well as a distribution over examples in the training set. Each weak classifier is given a weight and the final strong classifier is defined as the sign of the sum of the weak classifiers weighted by their assigned weight. (See AdaBoost Wikipedia page for notation). In the AdaBoost framework Schapire and Singer have shown that the training error is bounded by the following equation:        1  m     âˆ‘   i  =  1   m    e   (   -    y  i    (     âˆ‘   t  =  1   T      Î±  t    h  t    (   ğ’™  ğ’Š   )     )     )      =    âˆ  t    Z  t            1  m     superscript   subscript     i  1    m    superscript  e       subscript  y  i     superscript   subscript     t  1    T      subscript  Î±  t    subscript  h  t    subscript  ğ’™  ğ’Š            subscript  product  t    subscript  Z  t      \frac{1}{m}\sum_{i=1}^{m}e^{\left(-y_{i}\left(\sum_{t=1}^{T}\alpha_{t}h_{t}(%
 \boldsymbol{x_{i}})\right)\right)}=\prod_{t}Z_{t}     Where    Z  t     subscript  Z  t    Z_{t}   is the normalizing factor for the distribution    D   t  +  1      subscript  D    t  1     D_{t+1}   . Solving for    Z  t     subscript  Z  t    Z_{t}   in the equation for     D  t    (  i  )        subscript  D  t   i    D_{t}(i)   we get:       Z  t   =     âˆ‘   i  :    x  t   âˆ‰   x  i        D  t    (  i  )     +    âˆ‘   i  :    x  t   âˆˆ   x  i        D  t    (  i  )    e   -    y  i    Î±  i    h  t    (   ğ’™  ğ’Š   )              subscript  Z  t       subscript    normal-:  i     subscript  x  t    subscript  x  i         subscript  D  t   i      subscript    normal-:  i     subscript  x  t    subscript  x  i         subscript  D  t   i   superscript  e       subscript  y  i    subscript  Î±  i    subscript  h  t    subscript  ğ’™  ğ’Š           Z_{t}=\sum_{i:x_{t}\notin x_{i}}D_{t}(i)+\sum_{i:x_{t}\in x_{i}}D_{t}(i)e^{-y_%
 {i}\alpha_{i}h_{t}(\boldsymbol{x_{i}})}     Where    x  t     subscript  x  t    x_{t}   is the feature selected in the current weak hypothesis. Three equations are defined describing the sum of the distributions for in which the current hypothesis has selected either correct or incorrect label. Note that it is possible for the classifier to abstain from selecting a label for an example, in which the label provided is 0. The two labels are selected to be either -1 or 1.       W  0   =    âˆ‘   i  :     h  t    (   x  i   )    =  0       D  t    (  i  )          subscript  W  0     subscript    normal-:  i       subscript  h  t    subscript  x  i    0        subscript  D  t   i      W_{0}=\sum_{i:h_{t}(x_{i})=0}D_{t}(i)        W  +   =    âˆ‘   i  :     h  t    (   x  i   )    =   y  i        D  t    (  i  )          subscript  W      subscript    normal-:  i       subscript  h  t    subscript  x  i     subscript  y  i         subscript  D  t   i      W_{+}=\sum_{i:h_{t}(x_{i})=y_{i}}D_{t}(i)        W  -   =    âˆ‘   i  :     h  t    (   x  i   )    =   -   y  i         D  t    (  i  )          subscript  W      subscript    normal-:  i       subscript  h  t    subscript  x  i       subscript  y  i          subscript  D  t   i      W_{-}=\sum_{i:h_{t}(x_{i})=-y_{i}}D_{t}(i)     Schapire and Singer have shown that the value    Z  t     subscript  Z  t    Z_{t}   can be minimized (and thus the training error) by selecting    Î±  t     subscript  Î±  t    \alpha_{t}   to be as follows:       Î±  t   =    1  2    ln   (    W  +    W  -    )          subscript  Î±  t       1  2        subscript  W     subscript  W         \alpha_{t}=\frac{1}{2}\ln\left(\frac{W_{+}}{W_{-}}\right)     Providing confidence values for the current hypothesized classifier based on the number of correctly classified vs. the number of incorrectly classified examples weighted by the distribution over examples. This equation can be smoothed to compensate for cases in which    W  -     subscript  W     W_{-}   is too small. Deriving    Z  t     subscript  Z  t    Z_{t}   from this equation we get:       Z  t   =    W  0   +   2     W  +    W  -            subscript  Z  t      subscript  W  0     2       subscript  W     subscript  W          Z_{t}=W_{0}+2\sqrt{W_{+}W_{-}}     The training error thus is minimized by selecting the weak hypothesis at every iteration that minimizes the previous equation.  AdaBoost with two views  CoBoosting extends this framework in the case where one has a labeled training set (examples from    1...  m      1...  m    1...m   ) and an unlabeled training set (from     m  1   â€¦  n       subscript  m  1   normal-â€¦  n    m_{1}...n   ), as well as satisfy the conditions of redundancy in features in the form of     x  i   =   (   x   1  ,  i    ,   x   2  ,  i    )        subscript  x  i     subscript  x   1  i     subscript  x   2  i       x_{i}=(x_{1,i},x_{2,i})   . The algorithm trains two classifiers in the same fashion as AdaBoost that agree on the labeled training sets correct labels and maximizes the agreement between the two classifiers on the unlabeled training set. The final classifier is the sign of the sum of the two strong classifiers. The bounded training error on CoBoost is extended as follows, where    Z   C  O      subscript  Z    C  O     Z_{CO}   is the extension of    Z  t     subscript  Z  t    Z_{t}   :       Z   C  O    =     âˆ‘   i  =  1   m    e   -    y  i    g  1    (   ğ’™   ğŸ  ,  ğ’Š    )       +    âˆ‘   i  =  1   m    e   -    y  i    g  2    (   ğ’™   ğŸ  ,  ğ’Š    )       +    âˆ‘   i  =   m  +  1    n    e   -    f  2    (   ğ’™   ğŸ  ,  ğ’Š    )    g  1    (   ğ’™   ğŸ  ,  ğ’Š    )       +    âˆ‘   i  =   m  +  1    n    e   -    f  1    (   ğ’™   ğŸ  ,  ğ’Š    )    g  2    (   ğ’™   ğŸ  ,  ğ’Š    )             subscript  Z    C  O        superscript   subscript     i  1    m    superscript  e       subscript  y  i    subscript  g  1    subscript  ğ’™   1  ğ’Š          superscript   subscript     i  1    m    superscript  e       subscript  y  i    subscript  g  2    subscript  ğ’™   2  ğ’Š          superscript   subscript     i    m  1     n    superscript  e       subscript  f  2    subscript  ğ’™   2  ğ’Š     subscript  g  1    subscript  ğ’™   1  ğ’Š          superscript   subscript     i    m  1     n    superscript  e       subscript  f  1    subscript  ğ’™   1  ğ’Š     subscript  g  2    subscript  ğ’™   2  ğ’Š           Z_{CO}=\sum_{i=1}^{m}e^{-y_{i}g_{1}(\boldsymbol{x_{1,i}})}+\sum_{i=1}^{m}e^{-y%
 _{i}g_{2}(\boldsymbol{x_{2,i}})}+\sum_{i=m+1}^{n}e^{-f_{2}(\boldsymbol{x_{2,i}%
 })g_{1}(\boldsymbol{x_{1,i}})}+\sum_{i=m+1}^{n}e^{-f_{1}(\boldsymbol{x_{1,i}})%
 g_{2}(\boldsymbol{x_{2,i}})}     Where    g  j     subscript  g  j    g_{j}   is the summation of hypotheses weight by their confidence values for the    j   t  h      superscript  j    t  h     j^{th}   view (j = 1 or 2).    f  j     subscript  f  j    f_{j}   is the sign of    g  j     subscript  g  j    g_{j}   . At each iteration of CoBoost both classifiers are updated iteratively. If    g  j   t  -  1      superscript   subscript  g  j     t  1     g_{j}^{t-1}   is the strong classifier output for the    j   t  h      superscript  j    t  h     j^{th}   view up to the    t  -  1      t  1    t-1   iteration we can set the pseudo-labels for the j th update to be:        y  i   ^   =   {        y  i   1   â‰¤  i  â‰¤  m          s  i  g  n   (    g   3  -  j    t  -  1     (   ğ’™    ğŸ‘  -  ğ’‹   ,  ğ’Š    )    )   m   <  i  â‰¤  n              normal-^   subscript  y  i     cases           subscript  y  i   1   i       m     missing-subexpression           s  i  g  n     superscript   subscript  g    3  j      t  1     subscript  ğ’™     3  ğ’‹   ğ’Š     m   i       n     missing-subexpression        \hat{y_{i}}=\left\{\begin{array}[]{ll}y_{i}1\leq i\leq m\\
 sign(g_{3-j}^{t-1}(\boldsymbol{x_{3-j,i}}))m     In which    3  -  j      3  j    3-j   selects the other view to the one currently being updated.    Z   C  O      subscript  Z    C  O     Z_{CO}   is split into two such that     Z   C  O    =    Z   C  O   1   +   Z   C  O   2         subscript  Z    C  O       superscript   subscript  Z    C  O    1    superscript   subscript  Z    C  O    2      Z_{CO}=Z_{CO}^{1}+Z_{CO}^{2}   . Where       Z   C  O   j   =    âˆ‘   i  =  1   n    e   -     y  i   ^    (     g  j   t  -  1     (   ğ’™  ğ’Š   )    +    Î±  t  j    g  t  j    (   ğ’™   ğ’‹  ,  ğ’Š    )     )            superscript   subscript  Z    C  O    j     superscript   subscript     i  1    n    superscript  e       normal-^   subscript  y  i         superscript   subscript  g  j     t  1     subscript  ğ’™  ğ’Š       superscript   subscript  Î±  t   j    superscript   subscript  g  t   j    subscript  ğ’™   ğ’‹  ğ’Š            Z_{CO}^{j}=\sum_{i=1}^{n}e^{-\hat{y_{i}}(g_{j}^{t-1}(\boldsymbol{x_{i}})+%
 \alpha_{t}^{j}g_{t}^{j}(\boldsymbol{x_{j,i}}))}     The distribution over examples for each view   j   j   j   at iteration   t   t   t   is defined as follows:        D  t  j    (  i  )    =    1   Z  t  j     e   -     y  i   ^    g  j   t  -  1     (   ğ’™   ğ’‹  ,  ğ’Š    )              superscript   subscript  D  t   j   i       1   superscript   subscript  Z  t   j     superscript  e       normal-^   subscript  y  i     superscript   subscript  g  j     t  1     subscript  ğ’™   ğ’‹  ğ’Š          D_{t}^{j}(i)=\frac{1}{Z_{t}^{j}}e^{-\hat{y_{i}}g_{j}^{t-1}(\boldsymbol{x_{j,i}%
 })}     At which point    Z   C  O   j     superscript   subscript  Z    C  O    j    Z_{CO}^{j}   can be rewritten as       Z   C  O   j   =    âˆ‘   i  =  1   n     D  t  j    e   -     y  i   ^    Î±  t  j    g  t  j    (   ğ’™   ğ’‹  ,  ğ’Š    )             superscript   subscript  Z    C  O    j     superscript   subscript     i  1    n      superscript   subscript  D  t   j    superscript  e       normal-^   subscript  y  i     superscript   subscript  Î±  t   j    superscript   subscript  g  t   j    subscript  ğ’™   ğ’‹  ğ’Š           Z_{CO}^{j}=\sum_{i=1}^{n}D_{t}^{j}e^{-\hat{y_{i}}\alpha_{t}^{j}g_{t}^{j}(%
 \boldsymbol{x_{j,i}})}     Which is identical to the equation in AdaBoost. Thus the same process can be used to update the values of    Î±  t  j     superscript   subscript  Î±  t   j    \alpha_{t}^{j}   as in AdaBoost using     y  i   ^     normal-^   subscript  y  i     \hat{y_{i}}   and    D  t  j     superscript   subscript  D  t   j    D_{t}^{j}   . By alternating this, the minimization of    Z   C  O   1     superscript   subscript  Z    C  O    1    Z_{CO}^{1}   and    Z   C  O   2     superscript   subscript  Z    C  O    2    Z_{CO}^{2}   in this fashion    Z   C  O      subscript  Z    C  O     Z_{CO}   is minimized in a greedy fashion.  References  Footnotes  "  Category:Classification algorithms     Michael Collins and Yoram Singer, Unsupervised Models for Named Entity Classification. Proceedings of the 1999 Joint SIGDAT Conference on Empirical Methods in Natural Language Processing and Very Large Corpora, pp. 100-110, 1999. â†©     