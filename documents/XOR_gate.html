<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="450">XOR gate</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>XOR gate</h1>
<hr/>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>INPUT</strong></p></td>
<td style="text-align: left;">
<p><strong>OUTPUT</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>B</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p>The <strong>XOR gate</strong> (sometimes <strong>EOR gate</strong>, or <strong>EXOR gate</strong> and pronounced as <strong>Exclusive OR gate</strong>) is a digital <a href="logic_gate" title="wikilink">logic gate</a> that implements an <a href="exclusive_or" title="wikilink">exclusive or</a>; that is, a true output (1/HIGH) results if one, and only one, of the inputs to the gate is true. If both inputs are false (0/LOW) or both are true, a false output results. XOR represents the inequality function, i.e., the output is true if the inputs are not alike otherwise the output is false. A way to remember XOR is "one or the other but not both".</p>

<p>XOR can also be viewed as addition modulo 2. As a result, XOR gates are used to implement binary addition in computers. A <a href="Adder_(electronics)#half_adder" title="wikilink">Half adder</a> consists of an XOR gate and an <a href="AND_gate" title="wikilink">AND gate</a>. Other uses include substractors, comparators, and controlled inverters.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The <a href="Boolean_algebra" title="wikilink">algebraic expressions</a> 

<math display="inline" id="XOR_gate:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>⋅</mo>
    <mover accent="true">
     <mi>B</mi>
     <mo>¯</mo>
    </mover>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mover accent="true">
     <mi>A</mi>
     <mo>¯</mo>
    </mover>
    <mo>⋅</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-⋅</ci>
     <ci>A</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>A</ci>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cdot\overline{B}+\overline{A}\cdot B
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="XOR_gate:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>+</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <plus></plus>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A+B)\cdot
  </annotation>
 </semantics>
</math>

 ( 

<math display="inline" id="XOR_gate:2">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>A</mi>
    <mo>¯</mo>
   </mover>
   <mo>+</mo>
   <mover accent="true">
    <mi>B</mi>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-¯</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{A}+\overline{B}
  </annotation>
 </semantics>
</math>

 ) both represent the XOR gate with inputs <em>A</em> and <em>B</em>. The behavior of XOR is summarized in the <a href="truth_table" title="wikilink">truth table</a> shown on the right.</p>
<figure><b>(Figure)</b>
<figcaption>CMOS XOR gate</figcaption>
</figure>
<h2 id="symbols">Symbols</h2>

<p>There are two symbols for XOR gates: the traditional symbol and the <a href="Institute_of_Electrical_and_Electronics_Engineers" title="wikilink">IEEE</a> symbol. For more information see <a href="Logic_gate#Symbols" title="wikilink">Logic Gate Symbols</a>.</p>

<p> </p>

<p>The <a href="List_of_logic_symbols" title="wikilink">logic symbols</a> ⊕ and  can be used to denote XOR in algebraic expressions.</p>

<p><a href="C_programming_language" title="wikilink">C-like languages</a> use the <a href="Caret#Programming_languages" title="wikilink">caret</a> symbol <strong>^</strong> to denote bitwise XOR. (Note that the caret does not denote <a href="logical_conjunction" title="wikilink">logical conjunction</a> (AND) in these languages, despite the similarity of symbol.)</p>
<h2 id="alternatives">Alternatives</h2>

<p>If a specific type of gate is not available, a circuit that implements the same function can be constructed from other available gates. A circuit implementing an XOR function can be trivially constructed from an XNOR gate followed by a NOT gate. If we consider the expression 

<math display="inline" id="XOR_gate:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>⋅</mo>
    <mover accent="true">
     <mi>B</mi>
     <mo>¯</mo>
    </mover>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mover accent="true">
     <mi>A</mi>
     <mo>¯</mo>
    </mover>
    <mo>⋅</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-⋅</ci>
     <ci>A</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>A</ci>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cdot\overline{B}+\overline{A}\cdot B
  </annotation>
 </semantics>
</math>

, we can construct an XOR gate circuit directly using AND, OR and NOT gates. However, this approach requires five gates of three different kinds.</p>

<p>An XOR gate circuit can be made from four NAND or five NOR gates in the configurations shown below . In fact, both NAND and NOR gates are so-called "universal gates," and any logical function can be constructed from either <a href="NAND_logic" title="wikilink">NAND logic</a> or <a href="NOR_logic" title="wikilink">NOR logic</a> alone.</p>

<p>As an alternative, if different gates are available we can apply <a href="Boolean_algebra" title="wikilink">Boolean algebra</a> to transform 

<math display="inline" id="XOR_gate:4">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⋅</mo>
   <mover accent="true">
    <mi>B</mi>
    <mo>¯</mo>
   </mover>
   <mo>+</mo>
   <mover accent="true">
    <mi>A</mi>
    <mo>¯</mo>
   </mover>
   <mo>⋅</mo>
   <mi>B</mi>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>+</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-⋅</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>B</ci>
    </apply>
    <plus></plus>
    <apply>
     <ci>normal-¯</ci>
     <ci>A</ci>
    </apply>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">B</csymbol>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <plus></plus>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cdot\overline{B}+\overline{A}\cdot B\equiv(A+B)\cdot
  </annotation>
 </semantics>
</math>

 ( 

<math display="inline" id="XOR_gate:5">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>A</mi>
    <mo>¯</mo>
   </mover>
   <mo>+</mo>
   <mover accent="true">
    <mi>B</mi>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-¯</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{A}+\overline{B}
  </annotation>
 </semantics>
</math>

) as stated above, and apply <a href="de_Morgan's_Law" title="wikilink">de Morgan's Law</a> to the last term to get 

<math display="inline" id="XOR_gate:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>+</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <plus></plus>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A+B)\cdot
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="XOR_gate:7">
 <semantics>
  <mover accent="true">
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>⋅</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{(A\cdot B)}
  </annotation>
 </semantics>
</math>

 which can be implemented using only three gates as shown below.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="image:XOR_from_NAND.svg" title="wikilink">frame|right|XOR gate circuit constructed using only NAND gates.</a></p></td>
<td style="text-align: left;">
<p><a href="image:XOR_from_NOR.svg" title="wikilink">frame|right|XOR gate circuit constructed using only NOR gates.</a></p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>XOR gate circuit using three mixed gates</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<h2 id="more-than-two-inputs">More than two inputs</h2>

<p>Strict reading of the definition of <a href="exclusive_or" title="wikilink">exclusive or</a>, or observation of the IEC rectangular symbol, raises the question of correct behaviour with additional inputs. If a logic gate were to accept three or more inputs and produce a true output if exactly one of those inputs were true, then it would in effect be a <a class="uri" href="one-hot" title="wikilink">one-hot</a> detector (and indeed this is the case for only two inputs). However, it is rarely implemented this way in practice.</p>

<p>It is most common to regard subsequent inputs as being applied through a cascade of binary exclusive-or operations: the first two signals are fed into an XOR gate, then the output of that gate is fed into a second XOR gate together with the third signal, and so on for any remaining signals. The result is a circuit that outputs a 1 when the number of 1s at its inputs is odd, and a 0 when the number of incoming 1s is even. This makes it practically useful as a <a href="parity_(telecommunication)" title="wikilink">parity generator</a> or a modulo-2 <a href="adder_(electronics)" title="wikilink">adder</a>.</p>

<p>For example, the 74LVC1G386 microchip is advertised as a three-input logic gate, and implements a parity generator.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="applications">Applications</h2>
<h3 id="uses-in-addition">Uses in addition</h3>

<p>The XOR logic gate can be used as a one-bit <a href="adder_(electronics)" title="wikilink">adder</a> that adds any two bits together to output one bit. For example, if we add <strong>1</strong> plus <strong>1</strong> in <a href="Binary_numeral_system" title="wikilink">binary</a>, we expect a two-bit answer, <strong>10</strong> (i.e. <strong>2</strong> in decimal). Since the trailing <em>sum</em> bit in this output is achieved with XOR, the preceding <em>carry</em> bit is calculated with an <a href="AND_gate" title="wikilink">AND gate</a>. This is the main principle in <a href="Adder_(electronics)#Half_adder" title="wikilink">Half Adders</a> and the combined AND-XOR circuit may be chained together in order to add ever longer binary numbers.</p>
<h3 id="pseudo-random-number-generation">Pseudo-random number generation</h3>

<p>Pseudo-random number (PRN) generators, specifically <strong><a href="Linear_feedback_shift_register" title="wikilink">Linear feedback shift registers</a></strong>, are defined in terms of the exclusive-or operation. Hence, a suitable setup of XOR gates can model a linear feedback shift register, in order to generate random numbers.</p>
<h3 id="correlation-and-sequence-detection">Correlation and sequence detection</h3>

<p>XOR gates produce a <strong>0</strong> when both inputs match. When searching for a specific bit pattern or PRN sequence in a very long data sequence, a series of XOR gates can be used to compare a string of bits from the data sequence against the target sequence in parallel. The number of <strong>0</strong> outputs can then be counted to determine how well the data sequence matches the target sequence. Correlators are used in many communications devices such as <a class="uri" href="CDMA" title="wikilink">CDMA</a> receivers and decoders for error correction and channel codes. In a CDMA receiver, correlators are used to extract the polarity of a specific PRN sequence out of a combined collection of PRN sequences.</p>

<p>A correlator looking for <strong>11010</strong> in the data sequence <strong>1110100101</strong> would compare the incoming data bits against the target sequence at every possible offset while counting the number of matches (zeros):</p>

<p><code>1110100101 (data)</code><br/>
<code>11010      (target)</code><br/>
<code>00111      (XOR) 2 zero bits</code><br/>
<br/>
<code>1110100101</code><br/>
<code> 11010</code><br/>
<code> 00000     5 zero bits</code><br/>
<br/>
<code>1110100101</code><br/>
<code>  11010</code><br/>
<code>  01110    2 zero bits</code><br/>
<br/>
<code>1110100101</code><br/>
<code>   11010</code><br/>
<code>   10011   2 zero bits</code><br/>
<br/>
<code>1110100101</code><br/>
<code>    11010</code><br/>
<code>    01000  4 zero bits</code><br/>
<br/>
<code>1110100101</code><br/>
<code>     11010</code><br/>
<code>     11111 0 zero bits</code><br/>
<br/>
<code>Matches by offset:</code><br/>
<br/>
<code>  .</code><br/>
<code>  :     :</code><br/>
<code>: : : : :  </code><br/>
<code>-----------</code><br/>
<code>0 1 2 3 4 5</code></p>

<p>In this example, the best match occurs when the target sequence is offset by 1 bit and all five bits match. When offset by 5 bits, the sequence exactly matches its inverse. By looking at the difference between the number of ones and zeros that come out of the bank of XOR gates, it is easy to see where the sequence occurs and whether or not it is inverted. Longer sequences are easier to detect than short sequences.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Exclusive_or" title="wikilink">Exclusive or</a></li>
<li><a href="AND_gate" title="wikilink">AND gate</a></li>
<li><a href="OR_gate" title="wikilink">OR gate</a></li>
<li><a href="Inverter_(logic_gate)" title="wikilink">Inverter (NOT gate)</a></li>
<li><a href="NAND_gate" title="wikilink">NAND gate</a></li>
<li><a href="NOR_gate" title="wikilink">NOR gate</a></li>
<li><a href="XNOR_gate" title="wikilink">XNOR gate</a></li>
<li><a href="Boolean_algebra" title="wikilink">Boolean algebra</a></li>
<li><a href="Logic_gate" title="wikilink">Logic gate</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://teahlab.com/xor_gate/">Interactive XOR Gate</a>, Demonstrate the logic flow of the XOR Gate circuit created with Teahlab's simulator.</li>
</ul>

<p><a href="sv:Disjunktion_(logik)#OR-grind_och_XOR-grind" title="wikilink">sv:Disjunktion (logik)#OR-grind och XOR-grind</a>"</p>

<p><a href="Category:Logic_gates" title="wikilink">Category:Logic gates</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.nxp.com/documents/data_sheet/74LVC1G386.pdf">74LVC1G386</a> <a href="data_sheet" title="wikilink">data sheet</a><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
