   Cache-oblivious matrix multiplication      Cache-oblivious matrix multiplication   Rectangular matrices can be multiplied when the size of the cache and cache line is not known to the algorithm, or cache-obliviously . Cache-oblivious matrix multiplication was first formalized by Harald Prokop . 1  Matrix multiplication  Two matrixes   A   A   A   and   B   B   B   of size    m  ×  n      m  n    m\times n   and    n  ×  p      n  p    n\times p   with a cache of size   Z   Z   Z   and cache lines of length   L   L   L   can be multiplied with    Θ   (   m  +  n  +  p  +     m  n   +   n  p   +   m  p    L   +    m  n  p    L   Z      )       normal-Θ    m  n  p        m  n     n  p     m  p    L       m  n  p     L    Z        \Theta(m+n+p+\frac{mn+np+mp}{L}+\frac{mnp}{L\sqrt{Z}})   cache misses under the tall cache assumption    Z  =   Ω   (   L  2   )        Z    normal-Ω   superscript  L  2      Z=\Omega(L^{2})   .   Z   Z   Z   and   L   L   L   are not known at runtime.  Algorithm  The matrices are stored in row major order , meaning that a matrix is laid out in memory with the each row's elements contiguously, from the first row to the last row. The algorithm works by recursive divide and conquer . In each step, the largest dimension halved.  Case 1    m  ≥   n  ,  p       m   n  p     m\geq n,p        A  B   =    (      A  1        A  2      )   B   =   (       A  1   B         A  2   B      )           A  B        subscript  A  1      subscript  A  2     B             subscript  A  1   B        subscript  A  2   B        AB=\begin{pmatrix}A_{1}\\
 A_{2}\end{pmatrix}B=\begin{pmatrix}A_{1}B\\
 A_{2}B\end{pmatrix}     Case 2    n  ≥   m  ,  p       n   m  p     n\geq m,p        A  B   =    (      A  1      A  2      )    (      B  1        B  2      )    =     A  1    B  1    +    A  2    B  2             A  B        subscript  A  1    subscript  A  2        subscript  B  1      subscript  B  2                subscript  A  1    subscript  B  1       subscript  A  2    subscript  B  2        AB=\begin{pmatrix}A_{1}&A_{2}\end{pmatrix}\begin{pmatrix}B_{1}\\
 B_{2}\end{pmatrix}=A_{1}B_{1}+A_{2}B_{2}     Case 3    p  ≥   m  ,  n       p   m  n     p\geq m,n        A  B   =   A   (      B  1      B  2      )    =   (      A   B  1       A   B  2       )           A  B     A     subscript  B  1    subscript  B  2               A   subscript  B  1      A   subscript  B  2         AB=A\begin{pmatrix}B_{1}&B_{2}\end{pmatrix}=\begin{pmatrix}AB_{1}&AB_{2}\end{pmatrix}     In the base case    m  =  n  =  p  =  1        m  n       p       1     m=n=p=1   , the single element matrices   A   A   A   and   B   B   B   are multiplied and then added to the resulting matrix.  Cache complexity and work      Θ   (   m  +  n  +  p  +     m  n   +   n  p   +   m  p    L   +    m  n  p    L   Z      )       normal-Θ    m  n  p        m  n     n  p     m  p    L       m  n  p     L    Z        \Theta(m+n+p+\frac{mn+np+mp}{L}+\frac{mnp}{L\sqrt{Z}})   caches misses are incurred.    Θ   (   m  n  p   )       normal-Θ    m  n  p     \Theta(mnp)   additions and multiplications are done.  References  "  Category:Models of computation  Category:Cache (computing)  Category:Analysis of algorithms  Category:External memory algorithms  Category:Matrix multiplication algorithms     ↩     