   Merkle signature scheme      Merkle signature scheme   The Merkle signature scheme is a digital signature scheme based on hash trees (also called Merkle trees) and one-time signatures such as the Lamport signature scheme. It was developed by Ralph Merkle in the late 1970s and is an alternative to traditional digital signatures such as the Digital Signature Algorithm or RSA .  The advantage of the Merkle Signature Scheme is that it is believed to be resistant against quantum computer algorithms. The traditional public key algorithms, such as RSA and ELGamal would become insecure in case an effective quantum computer can be built (due to Shor's algorithm ). The Merkle Signature Scheme however only depends on the existence of secure hash functions . This makes the Merkle Signature Scheme very adjustable and resistant to quantum computing.  Key generation  The Merkle Signature Scheme can be used to sign a limited number of messages with one public key    p  u  b      p  u  b    pub   . The number of possible messages must be a power of two, so we denote the possible number of messages as    N  =   2  n       N   superscript  2  n     N=2^{n}   .  The first step of generating the public key    p  u  b      p  u  b    pub   is to generate the public keys    X  i     subscript  X  i    X_{i}   and private keys    Y  i     subscript  Y  i    Y_{i}   of    2  n     superscript  2  n    2^{n}   one-time signatures. For each public key    X  i     subscript  X  i    X_{i}   , with    1  ≤  i  ≤   2  n         1  i        superscript  2  n      1\leq i\leq 2^{n}   , a hash value     h  i   =   X  i   =   H   (   Y  i   )           subscript  h  i    subscript  X  i          H   subscript  Y  i       h_{i}=X_{i}=H(Y_{i})   is computed. With these hash values    h  i     subscript  h  i    h_{i}   a hash tree is built.  Each node of the tree is represented as    a   i  ,  j      subscript  a   i  j     a_{i,j}   , where   i   i   i   denotes the height of the node and   j   j   j   denotes the left-to-right position of the node. The height of a node is defined as the distance from the node to a leaf. Hence, a leaf of the tree has height    i  =  0      i  0    i=0   and the root has height    i  =  n      i  n    i=n   . Nodes with the same height are numbered from left to right, so    a   i  ,  0      subscript  a   i  0     a_{i,0}   is the leftmost node of level   i   i   i   .  In the Merkle Tree the hash values    h  i     subscript  h  i    h_{i}   are the leaves of a binary tree, so that     h  i   =   a   0  ,  i         subscript  h  i    subscript  a   0  i      h_{i}=a_{0,i}   . Each inner node of the tree is the hash value of the concatenation of its two children. For example     a   1  ,  0    =  H   (   a   0  ,  0    |  |   a   0  ,  1    )      fragments   subscript  a   1  0     H   fragments  normal-(   subscript  a   0  0    normal-|  normal-|   subscript  a   0  1    normal-)     a_{1,0}=H(a_{0,0}||a_{0,1})   and     a   2  ,  0    =  H   (   a   1  ,  0    |  |   a   1  ,  1    )      fragments   subscript  a   2  0     H   fragments  normal-(   subscript  a   1  0    normal-|  normal-|   subscript  a   1  1    normal-)     a_{2,0}=H(a_{1,0}||a_{1,1})   .  In this way, a tree with    2  n     superscript  2  n    2^{n}   leaves and     2   n  +  1    -  1       superscript  2    n  1    1    2^{n+1}-1   nodes is built. The root of the tree,    a   n  ,  0      subscript  a   n  0     a_{n,0}   , is the public key    p  u  b      p  u  b    pub   of the Merkle Signature Scheme.  Signature generation  To sign a message   M   M   M   with the Merkle Signature Scheme, the message   M   M   M   is signed with a one-time signature scheme, resulting in a signature    s  i   g  ′       s  i   superscript  g  normal-′     sig^{\prime}   , first. This is done, by using one of the public and private key pairs    (   X  i   ,   Y  i   ,  )     fragments  normal-(   subscript  X  i   normal-,   subscript  Y  i   normal-,  normal-)    (X_{i},Y_{i},)   . [Need to define computation of    s  i   g  ′       s  i   superscript  g  normal-′     sig^{\prime}   ]  The corresponding leaf of the hash tree to a one-time public key    X  i     subscript  X  i    X_{i}   is     a   0  ,  i    =   H   (   X  i   )         subscript  a   0  i      H   subscript  X  i      a_{0,i}=H(X_{i})   . We call the path in the hash tree from    a   0  ,  i      subscript  a   0  i     a_{0,i}   to the root   A   A   A   . The path   A   A   A   consists of    n  +  1      n  1    n+1   nodes,     A  0   ,   …   A  n        subscript  A  0     normal-…   subscript  A  n      A_{0},...A_{n}   , with     A  0   =   a   0  ,  i         subscript  A  0    subscript  a   0  i      A_{0}=a_{0,i}   being the leaf and     A  n   =   a   n  ,  0    =   p  u  b          subscript  A  n    subscript  a   n  0           p  u  b      A_{n}=a_{n,0}=pub   being the root of the tree. To compute this path   A   A   A   , we need every child of the nodes     A  1   ,  …  ,   A  n       subscript  A  1   normal-…   subscript  A  n     A_{1},...,A_{n}   . We know that    A  i     subscript  A  i    A_{i}   is a child of    A   i  +  1      subscript  A    i  1     A_{i+1}   . To calculate the next node    A   i  +  1      subscript  A    i  1     A_{i+1}   of the path   A   A   A   , we need to know both children of    A   i  +  1      subscript  A    i  1     A_{i+1}   . So we need the brother node of    A  i     subscript  A  i    A_{i}   . We call this node    a  u  t   h  i       a  u  t   subscript  h  i     auth_{i}   , so that     A   i  +  1    =  H   (   A  i   |  |  a  u  t   h  i   )      fragments   subscript  A    i  1     H   fragments  normal-(   subscript  A  i   normal-|  normal-|  a  u  t   subscript  h  i   normal-)     A_{i+1}=H(A_{i}||auth_{i})   . Hence,   n   n   n   nodes     a  u  t   h  0    ,  …  ,   a  u  t   h   n  -  1          a  u  t   subscript  h  0    normal-…    a  u  t   subscript  h    n  1       auth_{0},...,auth_{n-1}   are needed, to compute every node of the path   A   A   A   . We now calculate and save these nodes     a  u  t   h  0    ,  …  ,   a  u  t   h   n  -  1          a  u  t   subscript  h  0    normal-…    a  u  t   subscript  h    n  1       auth_{0},...,auth_{n-1}   .  These nodes, plus the one-time signature    s  i   g  ′       s  i   superscript  g  normal-′     sig^{\prime}   of   M   M   M   is the signature     s  i  g   =   (   s  i   g  ′    ||   a  u  t   h  0    ||   a  u  t   h  1    ||  …  ||   a  u  t   h   n  -  1     )         s  i  g     s  i   superscript  g  normal-′    norm    a  u  t   subscript  h  0     a  u  t   subscript  h  1    norm  normal-…   a  u  t   subscript  h    n  1       sig=(sig^{\prime}||auth_{0}||auth_{1}||...||auth_{n-1})   of the Merkle Signature Scheme. An example of an authentication path is illustrated in the figure on the right.  Signature verification  The receiver knows the public key    p  u  b      p  u  b    pub   , the message   M   M   M   , and the signature     s  i  g   =   (   s  i   g  ′    ||   a  u  t   h  0    ||   a  u  t   h  1    ||  …  ||   a  u  t   h   n  -  1     )         s  i  g     s  i   superscript  g  normal-′    norm    a  u  t   subscript  h  0     a  u  t   subscript  h  1    norm  normal-…   a  u  t   subscript  h    n  1       sig=(sig^{\prime}||auth_{0}||auth_{1}||...||auth_{n-1})   . At first, the receiver verifies the one-time signature    s  i   g  ′       s  i   superscript  g  normal-′     sig^{\prime}   of the message   M   M   M   . If    s  i   g  ′       s  i   superscript  g  normal-′     sig^{\prime}   is a valid signature of   M   M   M   , the receiver computes     A  0   =   H   (   X  i   )         subscript  A  0     H   subscript  X  i      A_{0}=H(X_{i})   by hashing the public key of the one-time signature. For    j  =  1  ,  .  .  ,  n  -  1     fragments  j   1  normal-,  normal-.  normal-.  normal-,  n   1    j=1,..,n-1   , the nodes of    A  j     subscript  A  j    A_{j}   of the path   A   A   A   are computed with     A  j   =  H   (   A   j  -  1    |  |  a  u  t   h   j  -  1    )      fragments   subscript  A  j    H   fragments  normal-(   subscript  A    j  1    normal-|  normal-|  a  u  t   subscript  h    j  1    normal-)     A_{j}=H(A_{j-1}||auth_{j-1})   . If    A  n     subscript  A  n    A_{n}   equals the public key    p  u  b      p  u  b    pub   of the merkle signature scheme, the signature is valid.  References   G. Becker. "Merkle Signature Schemes, Merkle Trees and Their Cryptanalysis", seminar 'Post Quantum Cryptology' at the Ruhr-University Bochum, Germany.  E. Dahmen, M. Dring, E. Klintsevich, J. Buchmann, L.C. Coronado Garca. "CMSS - an improved merkle signature scheme". Progress in Cryptology - Indocrypt 2006, 2006.  E. Klintsevich, K. Okeya, C.Vuillaume, J. Buchmann, E.Dahmen. "Merkle signatures with virtually unlimited signature capacity". 5th International Conference on Applied Cryptography and Network Security - ACNS07, 2007.  Ralph Merkle. "Secrecy, authentication and public key systems / A certified digital signature". Ph.D. dissertation, Dept. of Electrical Engineering, Stanford University, 1979. 1  S. Micali, M. Jakobsson, T. Leighton, M. Szydlo. "Fractal merkle tree representation and traversal". RSA-CT 03, 2003   External links   Efficient Use of Merkle Trees - RSA labs explanation of the original purpose of Merkle trees + Lamport signatures, as an efficient one-time signature scheme.   "  Category:Digital signature schemes  Category:Hash-based cryptography   