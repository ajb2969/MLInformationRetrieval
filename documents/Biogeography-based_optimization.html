<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="489">Biogeography-based optimization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Biogeography-based optimization</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Biogeography-based optimization (BBO)</strong> is an <a href="evolutionary_algorithm" title="wikilink">evolutionary algorithm</a> (EA) that <a href="optimization" title="wikilink">optimizes</a> a <a href="function_(mathematics)" title="wikilink">function</a> by <a href="stochastic" title="wikilink">stochastically</a> and <a href="iterative_method" title="wikilink">iteratively</a> improving <a href="candidate_solution" title="wikilink">candidate solutions</a> with regard to a given measure of quality, or <a href="fitness_function" title="wikilink">fitness function</a>. BBO belongs to the class of <a href="metaheuristic" title="wikilink">metaheuristics</a> since it includes many variations, and since it does not make any assumptions about the problem and can therefore be applied to a wide class of problems.</p>

<p>BBO is typically used to optimize multidimensional real-valued functions, but it does not use the <a class="uri" href="gradient" title="wikilink">gradient</a> of the function, which means that it does not require the function to be <a class="uri" href="differentiable" title="wikilink">differentiable</a> as required by classic optimization methods such as <a href="gradient_descent" title="wikilink">gradient descent</a> and <a href="quasi-newton_methods" title="wikilink">quasi-newton methods</a>. BBO can therefore be used on dis<a href="continuous_function" title="wikilink">continuous functions</a>.</p>

<p>BBO optimizes a problem by maintaining a population of candidate solutions, and creating new candidate solutions by combining existing ones according to a simple formula. In this way the <a href="loss_function" title="wikilink">objective function</a> is treated as a black box that merely provides a measure of quality given a candidate solution, and the function's gradient is not needed.</p>

<p>Like many EAs, BBO was motivated by a natural process; in particular, BBO was motivated by <a class="uri" href="biogeography" title="wikilink">biogeography</a>, which is the study of the distribution of biological species through time and space.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> BBO was originally introduced by <a href="http://academic.csuohio.edu/simond/">Dan Simon</a> in 2008.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="underlying-principles">Underlying principles</h2>

<p>Mathematical models of <a class="uri" href="biogeography" title="wikilink">biogeography</a> describe <a class="uri" href="speciation" title="wikilink">speciation</a> (the evolution of new <a class="uri" href="species" title="wikilink">species</a>), the <a href="Animal_migration" title="wikilink">migration</a> of species (animals, fish, birds, or insects) between islands, and the <a class="uri" href="extinction" title="wikilink">extinction</a> of species.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Islands that are friendly to life are said to have a high habitat suitability index (HSI).<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Features that correlate with HSI include rainfall, vegetative diversity, topographic diversity, land area, temperature, and others. The features that determine are called suitability index variables (SIVs). In terms of habitability, SIVs are the independent variables and HSI is the dependent variable.</p>

<p>Islands with a high HSI can support many species, and islands with a low HSI can support only a few species. Islands with a high HSI have many species that <a href="emigration" title="wikilink">emigrate</a> to nearby habitats because of the large populations and the large numbers of species that they host. Note that emigration from an island with a high HSI does not occur because species <em>want</em> to leave their home; after all, their home island is an attractive place to live. Emigration occurs because of the accumulation of random effects on a large number of species with large populations. Emigration occurs as animals ride <a class="uri" href="flotsam" title="wikilink">flotsam</a>, swim, fly, or ride the wind to neighboring islands. When a species emigrates from an island, it does not mean that the species completely disappears from its original island; only a few representatives emigrate, so an emigrating species remains present on its original island while at the same time migrating to a neighboring island. However, in BBO it is assumed that emigration from an island results in extinction from that island. This assumption is necessary in BBO because species represent the independent variables of a function, and each island represents a candidate solution to a function optimization problem.</p>

<p>Islands with a high HSI not only have a high emigration rate, but they also have a low immigration rate because they already support many species. Species that migrate to such islands will tend to die in spite of the island's high HSI, because there is too much competition for resources from other species.</p>

<p>Islands with a low HSI have a high immigration rate because of their low populations. Again, this is not because species <em>want</em> to immigrate to such islands; after all, these islands are undesirable places to live. The reason that immigration occurs to these islands is because there is a lot of room for additional species. Whether or not the immigrating species can survive in its new home, and for how long, is another question. However, <a href="species_diversity" title="wikilink">species diversity</a> is correlated with HSI, so when more species arrive at a low HSI island, the island's HSI will tend to increase.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The figure on the right illustrates an island migration model.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The immigration rate 

<math display="inline" id="Biogeography-based_optimization:0">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 and the emigration rate 

<math display="inline" id="Biogeography-based_optimization:1">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 are functions of the number of species on the island. The maximum possible immigration rate 

<math display="inline" id="Biogeography-based_optimization:2">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 occurs when there are zero species on the island. As the number of species increases, the island becomes more crowded, fewer species are able to survive immigration, and the immigration rate decreases. The largest possible number of species that the habitat can support is 

<math display="inline" id="Biogeography-based_optimization:3">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>max</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <max></max>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{\max}
  </annotation>
 </semantics>
</math>

, at which point the immigration rate is zero. If there are no species on the island, then the emigration rate is zero. As the number of species on the island increases, it becomes more crowded, more species representatives are able to leave the island, and the emigration rate increases. When the island contains the largest number of possible species 

<math display="inline" id="Biogeography-based_optimization:4">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>max</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <max></max>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{\max}
  </annotation>
 </semantics>
</math>

, the emigration rate reaches its maximum possible value 

<math display="inline" id="Biogeography-based_optimization:5">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

.</p>
<figure><b>(Figure)</b>
<figcaption>Model of immigration 

<math display="inline" id="Biogeography-based_optimization:6">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 and emigration 

<math display="inline" id="Biogeography-based_optimization:7">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 probabilities. 

<math display="inline" id="Biogeography-based_optimization:8">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{0}
  </annotation>
 </semantics>
</math>

 is the equilibrium species count, and 

<math display="inline" id="Biogeography-based_optimization:9">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>max</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <max></max>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{\max}
  </annotation>
 </semantics>
</math>

 is the maximum number of species that the island can support. 

<math display="inline" id="Biogeography-based_optimization:10">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Biogeography-based_optimization:11">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 are the maximum immigration and emigration rates, respectively.</figcaption>
</figure>

<p>In BBO, 

<math display="inline" id="Biogeography-based_optimization:12">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{k}
  </annotation>
 </semantics>
</math>

 is the probability that a given independent variable in the 

<math display="inline" id="Biogeography-based_optimization:13">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-th candidate solution will be replaced; that is, 

<math display="inline" id="Biogeography-based_optimization:14">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{k}
  </annotation>
 </semantics>
</math>

 is the immigration probability of 

<math display="inline" id="Biogeography-based_optimization:15">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

. If an independent variable is to be replaced, then the emigrating candidate solution is chosen with a probability that is proportional to the emigration probability 

<math display="inline" id="Biogeography-based_optimization:16">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{k}
  </annotation>
 </semantics>
</math>

. This is usually performed using <a href="fitness_proportionate_selection" title="wikilink">roulette wheel selection</a>.</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\text{Prob}(x_j)\text{ is selected for emigration} = \frac{\mu_j}{\sum_{i=1}^N \mu_i}  for 

<math display="inline" id="Biogeography-based_optimization:17">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-⋯</ci>
     <ci>N</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1,\cdots,N
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Biogeography-based_optimization:18">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is the number of candidate solutions in the population.</p>
<h2 id="algorithm">Algorithm</h2>

<p>Like most other EAs, BBO includes <a href="mutation_(genetic_algorithm)" title="wikilink">mutation</a>. A basic BBO algorithm with a population size of 

<math display="inline" id="Biogeography-based_optimization:19">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 for optimizing an 

<math display="inline" id="Biogeography-based_optimization:20">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-dimensional function can be described as follows. <code>
  Initialize a population of <math>N</math> candidate solutions <math>\{ x_k \}</math> 
  While not(termination criterion)
     For each <math>x_k</math>, set emigration probability <math>\mu_k \propto</math> fitness of <math>x_k</math>,
        with <math>\mu_k \in [0,1]</math>
     For each <math>x_k</math>, set immigration probability <math>\lambda_k = 1 - \mu_k</math>
<math> \{ z_k \} \leftarrow \{ x_k \} </math>
     For each individual <math> z_k (k=1,\cdots,N) </math> 
        For each independent variable index <math>s \in [1,n] </math>
           Use <math>\lambda_k</math> to probabilistically decide whether to immigrate to <math>z_k</math>
           If immigrating then
              Use <math> \{ \mu_i \} </math> to probabilistically select the emigrating individual <math> x_j </math>
<math> z_k(s) \leftarrow x_j(s) </math>
           End if
        Next independent variable index:<math> s \leftarrow s+1 </math>
        Probabilistically mutate <math> z_k </math>
     Next individual:<math> k \leftarrow k+1 </math>
<math> \{ x_k \} \leftarrow \{ z_k \} </math>
  Next generation
</code></p>
<h2 id="discussion-of-the-bbo-algorithm">Discussion of the BBO algorithm</h2>
<ul>
<li>The population size 

<math display="inline" id="Biogeography-based_optimization:21">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is a tuning parameter. If 

<math display="inline" id="Biogeography-based_optimization:22">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is too small or too large, then the optimization performance of BBO will suffer. Typical implementations of BBO use a value of 

<math display="inline" id="Biogeography-based_optimization:23">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 somewhere between 20 and 200.</li>
<li>The initial population of candidate solutions 

<math display="inline" id="Biogeography-based_optimization:24">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>N</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{k}\}_{k=1}^{N}
  </annotation>
 </semantics>
</math>

 is usually generated randomly. However, it could be generated in a problem-dependent way based on some reasonable guesses or previously-known good solutions to the optimization problem.</li>
<li>The termination criterion is problem-dependent, like in any other EA. In most applications the termination criterion is a generation count limit or a function evaluation limit (that is, how often the objective function is evaluated).</li>
<li>

<math display="inline" id="Biogeography-based_optimization:25">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>z</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>k</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{z_{k}\}
  </annotation>
 </semantics>
</math>

 is a temporary population so that all emigrating variables can originate from the population that is in place at the beginning of the generation, which is 

<math display="inline" id="Biogeography-based_optimization:26">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{k}\}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="algorithmic-variations">Algorithmic variations</h2>

<p>Many variations have been proposed to the basic BBO algorithm, among which are the following.</p>
<ul>
<li>Elitism is implemented in most EAs to make sure that the best candidate solution is not lost from one generation to the next. This can be implemented in a variety of ways, but one common way is to save the best candidate solutions at the beginning of each generation in a set 

<math display="inline" id="Biogeography-based_optimization:27">
 <semantics>
  <mi>𝔼</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔼</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}
  </annotation>
 </semantics>
</math>

; then replace the worst candidate solutions with 

<math display="inline" id="Biogeography-based_optimization:28">
 <semantics>
  <mi>𝔼</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔼</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}
  </annotation>
 </semantics>
</math>

 at the end of the generation, after migration and mutation have completed. The size of 

<math display="inline" id="Biogeography-based_optimization:29">
 <semantics>
  <mi>𝔼</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔼</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}
  </annotation>
 </semantics>
</math>

 is a tuning parameter, but 

<math display="inline" id="Biogeography-based_optimization:30">
 <semantics>
  <mi>𝔼</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔼</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}
  </annotation>
 </semantics>
</math>

 typically includes the best two individuals. Elitism was originally proposed for <a href="genetic_algorithm" title="wikilink">genetic algorithms</a> by DeJong.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Elitism can make a significant difference in the performance of BBO, and is highly recommended.</li>
<li>Duplicate replacement is often implemented in BBO. This is a procedure at the end of each generation that replaces duplicate individuals in the population. Scanning for duplicates can be computationally intensive because it is an 

<math display="inline" id="Biogeography-based_optimization:31">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>N</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N^{2})
  </annotation>
 </semantics>
</math>

 operation, so it is often performed only every few generations, rather than every generation.</li>
<li>Blending can be implemented in BBO. With blending, instead of replacing 

<math display="inline" id="Biogeography-based_optimization:32">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>k</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{k}(s)
  </annotation>
 </semantics>
</math>

 in an immigrating candidate solution with 

<math display="inline" id="Biogeography-based_optimization:33">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}(s)
  </annotation>
 </semantics>
</math>

 from the emigrating candidate solution, 

<math display="inline" id="Biogeography-based_optimization:34">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>k</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{k}(s)
  </annotation>
 </semantics>
</math>

 is set equal to a linear combination of its original value and 

<math display="inline" id="Biogeography-based_optimization:35">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}(s)
  </annotation>
 </semantics>
</math>

:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Biogeography-based_optimization:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>z</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <msub>
      <mi>z</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>α</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>k</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>k</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>α</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{k}(s)\leftarrow\alpha z_{k}(s)+(1-\alpha)x_{j}(s)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>where 

<math display="inline" id="Biogeography-based_optimization:37">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>α</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in[0,1]
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Biogeography-based_optimization:38">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=0
  </annotation>
 </semantics>
</math>

 corresponds to standard migration as shown in the algorithm above. Blended BBO is based on blended crossover in genetic algorithms,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and has been shown to outperform standard BBO.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a>
</dd>
</dl>
<ul>
<li>The BBO algorithm presented above is called partial immigration-based BBO because the immigrating candidate solution is selected before the emigrating candidate solution is selected, and migration for each independent variable in the immigrating candidate solution is performed independently of all other independent variables. Other approaches for selecting the immigrating and emigrating candidate solutions have also been proposed.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
<li>The migration curves in the above figure are linear, but nonlinear migration curves often give better performance.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
<li>BBO has been hybridized with several other EAs, including <a href="particle_swarm_optimization" title="wikilink">particle swarm optimization</a>,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a href="differential_evolution" title="wikilink">differential evolution</a>,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> <a href="evolution_strategy" title="wikilink">evolution strategy</a>,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <a href="http://tizhoosh.uwaterloo.ca/Research/opposition_based_learning.htm">opposition-based computing</a>,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> <a href="case-based_reasoning" title="wikilink">case-based reasoning</a>,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> <a href="artificial_bee_colony_algorithm" title="wikilink">artificial bee colony algorithm</a>,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> bacterial foraging optimization,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> <a href="harmony_search" title="wikilink">harmony search</a>,<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> and the <a href="simplex_algorithm" title="wikilink">simplex algorithm</a>.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></li>
<li>BBO can be combined with local search to create a <a href="memetic_algorithm" title="wikilink">memetic algorithm</a> that performs much better than BBO alone.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></li>
</ul>
<h2 id="software">Software</h2>
<h3 id="matlab">MATLAB</h3>
<ul>
<li>The following MATLAB code gives a BBO implementation for minimizing the 20-dimensional <a href="Rosenbrock_function" title="wikilink">Rosenbrock function</a>. Note that the following code is very basic, although it does include elitism. A serious BBO implementation should include some of the variations discussed above, such as duplicate replacement, blending, nonlinear migration, and local optimization.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function BBO
<span class="co">% Biogeography-based optimization (BBO) to minimize a continuous function</span>
<span class="co">% This program was tested with MATLAB R2012b</span>

GenerationLimit = <span class="fl">50</span>; <span class="co">% generation count limit </span>
PopulationSize = <span class="fl">50</span>; <span class="co">% population size</span>
ProblemDimension = <span class="fl">20</span>; <span class="co">% number of variables in each solution (i.e., problem dimension)</span>
MutationProbability = <span class="fl">0.04</span>; <span class="co">% mutation probability per solution per independent variable</span>
NumberOfElites = <span class="fl">2</span>; <span class="co">% how many of the best solutions to keep from one generation to the next</span>
MinDomain = -<span class="fl">2.048</span>; <span class="co">% lower bound of each element of the function domain</span>
MaxDomain = +<span class="fl">2.048</span>; <span class="co">% upper bound of each element of the function domain</span>

<span class="co">% Initialize the population</span>
rng(round(sum(<span class="fl">100</span>*clock))); <span class="co">% initialize the random number generator</span>
x = zeros(PopulationSize, ProblemDimension); <span class="co">% allocate memory for the population</span>
for index = <span class="fl">1</span> : PopulationSize <span class="co">% randomly initialize the population</span>
    x(index, :) = MinDomain + (MaxDomain - MinDomain) * rand(<span class="fl">1</span>, ProblemDimension);
end
Cost = RosenbrockCost(x); <span class="co">% compute the cost of each individual  </span>
[x, Cost] = PopulationSort(x, Cost); <span class="co">% sort the population from best to worst</span>
MinimumCost = zeros(GenerationLimit, <span class="fl">1</span>); <span class="co">% allocate memory</span>
MinimumCost(<span class="fl">1</span>) = Cost(<span class="fl">1</span>); <span class="co">% save the best cost at each generation in the MinimumCost array</span>
disp([<span class="st">'Generation 0 min cost = '</span>, num2str(MinimumCost(<span class="fl">1</span>))]);
z = zeros(PopulationSize, ProblemDimension); <span class="co">% allocate memory for the temporary population</span>

<span class="co">% Compute migration rates, assuming the population is sorted from most fit to least fit</span>
mu = (PopulationSize + <span class="fl">1</span> - (<span class="fl">1</span>:PopulationSize)) / (PopulationSize + <span class="fl">1</span>); <span class="co">% emigration rate</span>
lambda = <span class="fl">1</span> - mu; <span class="co">% immigration rate</span>

for Generation = <span class="fl">1</span> : GenerationLimit
    <span class="co">% Save the best solutions and costs in the elite arrays</span>
    EliteSolutions = x(<span class="fl">1</span> : NumberOfElites, :);
    EliteCosts = Cost(<span class="fl">1</span> : NumberOfElites);

    <span class="co">% Use migration rates to decide how much information to share between solutions</span>
    for k = <span class="fl">1</span> : PopulationSize
        <span class="co">% Probabilistic migration to the k-th solution</span>
        for j = <span class="fl">1</span> : ProblemDimension

            if rand &lt; lambda(k) <span class="co">% Should we immigrate?</span>
                <span class="co">% Yes - Pick a solution from which to emigrate (roulette wheel selection)</span>
                RandomNum = rand * sum(mu);
                Select = mu(<span class="fl">1</span>);
                SelectIndex = <span class="fl">1</span>;
                while (RandomNum &gt; Select) &amp;&amp; (SelectIndex &lt; PopulationSize)
                    SelectIndex = SelectIndex + <span class="fl">1</span>;
                    Select = Select + mu(SelectIndex);
                end
                z(k, j) = x(SelectIndex, j); <span class="co">% this is the migration step</span>
            else
                z(k, j) = x(k, j); <span class="co">% no migration for this independent variable</span>
            end

        end
    end

    <span class="co">% Mutation</span>
    for k = <span class="fl">1</span> : PopulationSize
        for ParameterIndex = <span class="fl">1</span> : ProblemDimension
            if rand &lt; MutationProbability
                z(k, ParameterIndex) = MinDomain + (MaxDomain - MinDomain) * rand;
            end
        end
    end

    x = z; <span class="co">% replace the solutions with their new migrated and mutated versions</span>
    Cost = RosenbrockCost(x); <span class="co">% calculate cost</span>
    [x, Cost] = PopulationSort(x, Cost); <span class="co">% sort the population and costs from best to worst</span>

    for k = <span class="fl">1</span> : NumberOfElites <span class="co">% replace the worst individuals with the previous generation's elites</span>
        x(PopulationSize-k+<span class="fl">1</span>, :) = EliteSolutions(k, :);
        Cost(PopulationSize-k+<span class="fl">1</span>) = EliteCosts(k);
    end

    [x, Cost] = PopulationSort(x, Cost); <span class="co">% sort the population and costs from best to worst</span>
    MinimumCost(Generation+<span class="fl">1</span>) = Cost(<span class="fl">1</span>);
    disp([<span class="st">'Generation '</span>, num2str(Generation), <span class="st">' min cost = '</span>, num2str(MinimumCost(Generation+<span class="fl">1</span>))])
end

<span class="co">% Wrap it up by displaying the best solution and by plotting the results</span>
disp([<span class="st">'Best solution found = '</span>, num2str(x(<span class="fl">1</span>, :))])
close all
plot(<span class="fl">0</span>:GenerationLimit, MinimumCost);
xlabel(<span class="st">'Generation'</span>)
ylabel(<span class="st">'Minimum Cost'</span>)
return

<span class="co">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
function [x, Cost] = PopulationSort(x, Cost)
<span class="co">% Sort the population and costs from best to worst</span>
[Cost, indices] = sort(Cost, <span class="st">'ascend'</span>);
x = x(indices, :);
return

<span class="co">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
function [Cost] = RosenbrockCost(x)
<span class="co">% Compute the Rosenbrock function value of each element in x</span>
NumberOfDimensions = size(x, <span class="fl">2</span>);
Cost = zeros(size(x, <span class="fl">1</span>), <span class="fl">1</span>); <span class="co">% allocate memory for the Cost array</span>
for PopulationIndex = <span class="fl">1</span> : length(x)
    Cost(PopulationIndex) = <span class="fl">0</span>;
    for i = <span class="fl">1</span> : NumberOfDimensions-<span class="fl">1</span>
        Temp1 = x(PopulationIndex, i);
        Temp2 = x(PopulationIndex, i+<span class="fl">1</span>);
        Cost(PopulationIndex) = Cost(PopulationIndex) + <span class="fl">100</span> * (Temp2 - Temp1^<span class="fl">2</span>)^<span class="fl">2</span> + (Temp1 - <span class="fl">1</span>)^<span class="fl">2</span>;
    end
end
return</code></pre></div>
<h3 id="r">R</h3>
<ul>
<li>"bbo: Biogeography-Based Optimization" is an <a href="R_(programming_language)" title="wikilink">R</a> package for continuous BBO.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></li>
</ul>
<h2 id="extensions">Extensions</h2>

<p>BBO has been extended to noisy functions (that is, functions whose fitness evaluation is corrupted by noise);<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> constrained functions;<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> combinatorial functions;<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> and multi-objective functions.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h2 id="mathematical-analyses">Mathematical analyses</h2>

<p>BBO has been mathematically analyzed using Markov models<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> and dynamic system models.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://embeddedlab.csuohio.edu/BBO/">BBO Home Page</a></li>
</ul>

<p>"</p>

<p><a href="Category:Evolutionary_algorithms" title="wikilink">Category:Evolutionary algorithms</a> <a href="Category:Stochastic_optimization" title="wikilink">Category:Stochastic optimization</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
</ol>
</section>
</body>

