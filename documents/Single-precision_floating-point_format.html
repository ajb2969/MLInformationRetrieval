<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="759">Single-precision floating-point format</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Single-precision floating-point format</h1>
<hr/>

<p>'''Single-precision floating-point format ''' is a <a href="computer_number_format" title="wikilink">computer number format</a> that occupies 4 bytes (32 bits) in computer memory and represents a wide dynamic range of values by using a <a href="floating_point" title="wikilink">floating point</a>.</p>

<p>In <a href="IEEE_754-2008" title="wikilink">IEEE 754-2008</a> the 32-bit base 2 format is officially referred to as <strong>binary32</strong>. It was called <strong>single</strong> in <a href="IEEE_754-1985" title="wikilink">IEEE 754-1985</a>. In older computers, different floating-point formats of 4 bytes were used.</p>

<p>One of the first <a href="programming_language" title="wikilink">programming languages</a> to provide single- and double-precision floating-point data types was <a class="uri" href="Fortran" title="wikilink">Fortran</a>. Before the widespread adoption of <a href="IEEE_754-1985" title="wikilink">IEEE 754-1985</a>, the representation and properties of the double float data type depended on the computer manufacturer and computer model.</p>

<p>Single-precision binary floating-point is used due to its wider range over <a href="fixed-point_arithmetic" title="wikilink">fixed point</a> (of the same bit-width), even if at the cost of precision.</p>

<p>Single precision is known as <strong>REAL</strong> in <a class="uri" href="Fortran" title="wikilink">Fortran</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> as <strong>float</strong> in <a href="C_(programming_language)" title="wikilink">C</a>, <a href="C++_(programming_language)" title="wikilink">C++</a>, <a href="C_Sharp_(programming_language)" title="wikilink">C#</a>, <a href="Java_(programming_language)" title="wikilink">Java</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> as <strong>Float</strong> in <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and as <strong>single</strong> in <a href="Object_Pascal" title="wikilink">Delphi (Pascal)</a>, Visual Basic, and <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>. However, <strong>float</strong> in <a href="Python_(programming_language)" title="wikilink">Python</a>, <a href="Ruby_(programming_language)" title="wikilink">Ruby</a>, <a class="uri" href="PHP" title="wikilink">PHP</a>, and <a class="uri" href="OCaml" title="wikilink">OCaml</a> and <strong>single</strong> in versions of <a href="GNU_Octave" title="wikilink">Octave</a> prior to 3.2 refer to <a href="double-precision_floating-point_format" title="wikilink">double-precision</a> numbers. In <a class="uri" href="PostScript" title="wikilink">PostScript</a>, the only floating-point precision is single.</p>
<h2 id="ieee-754-single-precision-binary-floating-point-format-binary32">IEEE 754 single-precision binary floating-point format: binary32</h2>

<p>The IEEE 754 standard specifies a <strong>binary32</strong> as having:</p>
<ul>
<li><a href="Sign_bit" title="wikilink">Sign bit</a>: 1 bit</li>
<li><a class="uri" href="Exponent" title="wikilink">Exponent</a> width: 8 bits</li>
<li><a class="uri" href="Significand" title="wikilink">Significand</a> <a href="precision_(arithmetic)" title="wikilink">precision</a>: 24 bits (23 explicitly stored)</li>
</ul>

<p>This gives from 6 to 9 <a href="significant_figures" title="wikilink">significant decimal digits</a> precision (if a decimal string with at most 6 significant decimal digits is converted to IEEE 754 single precision and then converted back to the same number of significant decimal digits, then the final string should match the original; and if an IEEE 754 single precision is converted to a decimal string with at least 9 significant decimal digits and then converted back to single, then the final number must match the original<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>).</p>

<p>Sign bit determines the sign of the number, which is the sign of the significand as well. Exponent is either an 8 bit signed integer from −128 to 127 (<a href="2's_complement" title="wikilink">2's complement</a>) or an 8 bit unsigned integer from 0 to 255 which is the accepted biased form in IEEE 754 binary32 definition. If the unsigned integer format is used, the exponent value used in the arithmetic is the exponent shifted by a bias – for the IEEE 754 binary32 case, an exponent value of 127 represents the actual zero (i.e. for 2

<math display="inline" id="Single-precision_floating-point_format:0">
 <semantics>
  <msup>
   <mi></mi>
   <mrow>
    <mi>e</mi>
    <mi mathvariant="normal">−</mi>
    <mn>127</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>normal-−</ci>
     <cn type="integer">127</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}^{e−127}
  </annotation>
 </semantics>
</math>

 to be one, e must be 127).</p>

<p>The true significand includes 23 fraction bits to the right of the binary point and an implicit leading bit (to the left of the binary point) with value 1 unless the exponent is stored with all zeros. Thus only 23 fraction bits of the <a class="uri" href="significand" title="wikilink">significand</a> appear in the memory format but the total precision is 24 bits (equivalent to log<sub>10</sub>(2<sup>24</sup>) ≈ 7.225 decimal digits). The bits are laid out as follows:</p>

<p><br/>
The real value assumed by a given 32 bit <strong>binary32</strong> data with a given biased exponent <strong>e</strong> (the 8 bit unsigned integer) and a <strong>23 bit fraction</strong> is 

<math display="inline" id="Single-precision_floating-point_format:1">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mtext>sign</mtext>
     </msup>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1.</mn>
        <msub>
         <mi>b</mi>
         <mn>22</mn>
        </msub>
        <msub>
         <mi>b</mi>
         <mn>21</mn>
        </msub>
        <mi mathvariant="normal">…</mi>
        <msub>
         <mi>b</mi>
         <mn>0</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>×</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>e</mi>
      <mo>-</mo>
      <mn>127</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <mtext>sign</mtext>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <times></times>
        <cn type="float">1.</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">22</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">21</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>e</ci>
       <cn type="integer">127</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(-1)^{\text{sign}}(1.b_{22}b_{21}...b_{0})_{2}\times 2^{e-127}
  </annotation>
 </semantics>
</math>

 where more precisely we have 

<math display="inline" id="Single-precision_floating-point_format:2">
 <semantics>
  <mrow>
   <mtext>value</mtext>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mtext>sign</mtext>
     </msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mn>23</mn>
        </msubsup>
        <mrow>
         <msub>
          <mi>b</mi>
          <mrow>
           <mn>23</mn>
           <mo>-</mo>
           <mi>i</mi>
          </mrow>
         </msub>
         <msup>
          <mn>2</mn>
          <mrow>
           <mo>-</mo>
           <mi>i</mi>
          </mrow>
         </msup>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>×</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>e</mi>
       <mo>-</mo>
       <mn>127</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>value</mtext>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <mtext>sign</mtext>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <cn type="integer">23</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <apply>
           <minus></minus>
           <cn type="integer">23</cn>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <cn type="integer">2</cn>
          <apply>
           <minus></minus>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>e</ci>
       <cn type="integer">127</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{value}=(-1)^{\text{sign}}\left(1+\sum_{i=1}^{23}b_{23-i}2^{-i}\right)%
\times 2^{(e-127)}
  </annotation>
 </semantics>
</math>

.</p>

<p>In this example:</p>
<ul>
<li>

<math display="inline" id="Single-precision_floating-point_format:3">
 <semantics>
  <mrow>
   <mtext>sign</mtext>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>sign</mtext>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{sign}=0
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Single-precision_floating-point_format:4">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mn>23</mn>
     </msubsup>
     <mrow>
      <msub>
       <mi>b</mi>
       <mrow>
        <mn>23</mn>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
      </msub>
      <msup>
       <mn>2</mn>
       <mrow>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>1.25</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">23</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <apply>
          <minus></minus>
          <cn type="integer">23</cn>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <apply>
          <minus></minus>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">1.25</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+\sum_{i=1}^{23}b_{23-i}2^{-i}=1+2^{-2}=1.25
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Single-precision_floating-point_format:5">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>e</mi>
      <mo>-</mo>
      <mn>127</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mn>124</mn>
     <mo>-</mo>
     <mn>127</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mn>3</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>e</ci>
       <cn type="integer">127</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">124</cn>
       <cn type="integer">127</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{(e-127)}=2^{124-127}=2^{-3}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>thus:</p>
<ul>
<li>

<math display="inline" id="Single-precision_floating-point_format:6">
 <semantics>
  <mrow>
   <mtext>value</mtext>
   <mo>=</mo>
   <mrow>
    <mn>1.25</mn>
    <mo>×</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mn>3</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>0.15625</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <mtext>value</mtext>
     <apply>
      <times></times>
      <cn type="float">1.25</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.15625</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{value}=1.25\times 2^{-3}=0.15625
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h3 id="exponent-encoding">Exponent encoding</h3>

<p>The single-precision binary floating-point exponent is encoded using an <a href="offset_binary" title="wikilink">offset-binary</a> representation, with the zero offset being 127; also known as exponent bias in the IEEE 754 standard.</p>
<ul>
<li>E<sub>min</sub> = 01<sub>H</sub>−7F<sub>H</sub> = −126</li>
<li>E<sub>max</sub> = FE<sub>H</sub>−7F<sub>H</sub> = 127</li>
<li><a href="Exponent_bias" title="wikilink">Exponent bias</a> = 7F<sub>H</sub> = 127</li>
</ul>

<p>Thus, in order to get the true exponent as defined by the offset-binary representation, the offset of 127 has to be subtracted from the stored exponent.</p>

<p>The stored exponents 00<sub>H</sub> and FF<sub>H</sub> are interpreted specially.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Exponent</p></th>
<th style="text-align: left;">
<p>Significand zero</p></th>
<th style="text-align: left;">
<p>Significand non-zero</p></th>
<th style="text-align: left;">
<p>Equation</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>00<sub>H</sub></p></td>
<td style="text-align: left;">
<p><a href="0_(number)" title="wikilink">zero</a>, <a class="uri" href="−0" title="wikilink">−0</a></p></td>
<td style="text-align: left;">
<p><a href="denormal_numbers" title="wikilink">denormal numbers</a></p></td>
<td style="text-align: left;">
<p>(−1)<sup>signbits</sup>×2<sup>−126</sup>× 0.significandbits</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>01<sub>H</sub>, ..., FE<sub>H</sub></p></td>
<td style="text-align: left;">
<p>normalized value</p></td>
<td style="text-align: left;">
<p>(−1)<sup>signbits</sup>×2<sup>exponentbits−127</sup>× 1.significandbits</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>FF<sub>H</sub></p></td>
<td style="text-align: left;">
<p>±<a class="uri" href="infinity" title="wikilink">infinity</a></p></td>
<td style="text-align: left;">
<p><a class="uri" href="NaN" title="wikilink">NaN</a> (quiet, signalling)</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>The minimum positive (denormal) value is 2<sup>−149</sup> ≈ 1.4 × 10<sup>−45</sup>. The minimum positive normal value is 2<sup>−126</sup> ≈ 1.18 × 10<sup>−38</sup>. The maximum representable value is (2−2<sup>−23</sup>) × 2<sup>127</sup> ≈ 3.402823 × 10<sup>38</sup>.</p>
<h3 id="converting-from-decimal-representation-to-binary32-format">Converting from decimal representation to binary32 format</h3>

<p>In general, refer to the IEEE 754 standard itself for the strict conversion (including the rounding behaviour) of a real number into its equivalent binary32 format.</p>

<p>Here we can show how to convert a base 10 real number into an IEEE 754 binary32 format using the following outline:</p>
<ul>
<li>consider a real number with an integer and a fraction part such as 12.375</li>
<li>convert and <a href="normalized_number" title="wikilink">normalize</a> the integer part into <a href="binary_numeral_system" title="wikilink">binary</a></li>
<li>convert the fraction part using the following technique as shown here</li>
<li>add the two results and adjust them to produce a proper final conversion</li>
</ul>

<p><strong>Conversion of the fractional part:</strong> consider 0.375, the fractional part of 12.375. To convert it into a binary fraction, multiply the fraction by 2, take the integer part and re-multiply new fraction by 2 until a fraction of zero is found or until the precision limit is reached which is 23 fraction digits for IEEE 754 binary32 format.</p>

<p>0.375 x 2 = 0.750 = 0 + 0.750 =&gt; b<sub>−1</sub> = 0, the integer part represents the binary fraction digit. Re-multiply 0.750 by 2 to proceed</p>

<p>0.750 x 2 = 1.500 = 1 + 0.500 =&gt; b<sub>−2</sub> = 1</p>

<p>0.500 x 2 = 1.000 = 1 + 0.000 =&gt; b<sub>−3</sub> = 1, fraction = 0.000, terminate</p>

<p>We see that (0.375)<sub>10</sub> can be exactly represented in binary as (0.011)<sub>2</sub>. Not all decimal fractions can be represented in a finite digit binary fraction. For example decimal 0.1 cannot be represented in binary exactly. So it is only approximated.</p>

<p>Therefore (12.375)<sub>10</sub> = (12)<sub>10</sub> + (0.375)<sub>10</sub> = (1100)<sub>2</sub> + (0.011)<sub>2</sub> = (1100.011)<sub>2</sub></p>

<p>Also IEEE 754 binary32 format requires that you represent real values in 

<math display="inline" id="Single-precision_floating-point_format:7">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1.</mn>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mn>23</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msub>
   <mo>×</mo>
   <msup>
    <mn>2</mn>
    <mi>e</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <times></times>
      <cn type="float">1.</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">23</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1.x_{1}x_{2}...x_{23})_{2}\times 2^{e}
  </annotation>
 </semantics>
</math>

 format, (see <a href="Normalized_number" title="wikilink">Normalized number</a>, <a href="Denormalized_number" title="wikilink">Denormalized number</a>) so that 1100.011 is shifted to the right by 3 digits to become 

<math display="inline" id="Single-precision_floating-point_format:8">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1.100011</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msub>
   <mo>×</mo>
   <msup>
    <mn>2</mn>
    <mn>3</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="float">1.100011</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1.100011)_{2}\times 2^{3}
  </annotation>
 </semantics>
</math>


</p>

<p>Finally we can see that

<math display="block" id="Single-precision_floating-point_format:9">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>12.375</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>10</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1.100011</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msub>
    <mo>×</mo>
    <msup>
     <mn>2</mn>
     <mn>3</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="float">12.375</cn>
     <cn type="integer">10</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="float">1.100011</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (12.375)_{10}=(1.100011)_{2}\times 2^{3}
  </annotation>
 </semantics>
</math>

</p>

<p>From which we deduce:</p>
<ul>
<li>The exponent is 3 (and in the biased form it is therefore 130 = 1000 0010)</li>
<li>The fraction is 100011 (looking to the right of the binary point)</li>
</ul>

<p>From these we can form the resulting 32 bit IEEE 754 binary32 format representation of 12.375 as: 0-10000010-10001100000000000000000 = 41460000<sub>H</sub></p>

<p><strong>Note:</strong> consider converting 68.123 into IEEE 754 binary32 format: Using the above procedure you expect to get 42883EF9<sub>H</sub> with the last 4 bits being 1001. However, due to the default rounding behaviour of IEEE 754 format, what you get is 42883EFA<sub>H</sub>, whose last 4 bits are 1010.</p>

<p><strong>Ex 1:</strong> Consider decimal 1. We can see that

<math display="block" id="Single-precision_floating-point_format:10">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>10</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1.0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msub>
    <mo>×</mo>
    <msup>
     <mn>2</mn>
     <mn>0</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <cn type="integer">10</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="float">1.0</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1)_{10}=(1.0)_{2}\times 2^{0}
  </annotation>
 </semantics>
</math>

</p>

<p>From which we deduce:</p>
<ul>
<li>The exponent is 0 (and in the biased form it is therefore 127 = 0111 1111 )</li>
<li>The fraction is 0 (looking to the right of the binary point in 1.0 is all 0 = 000...0)</li>
</ul>

<p>From these we can form the resulting 32 bit IEEE 754 binary32 format representation of real number 1 as: 0-01111111-00000000000000000000000 = 3f800000<sub>H</sub></p>

<p><strong>Ex 2:</strong> Consider a value 0.25. We can see that

<math display="block" id="Single-precision_floating-point_format:11">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0.25</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>10</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1.0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msub>
    <mo>×</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="float">0.25</cn>
     <cn type="integer">10</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="float">1.0</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0.25)_{10}=(1.0)_{2}\times 2^{-2}
  </annotation>
 </semantics>
</math>

</p>

<p>From which we deduce:</p>
<ul>
<li>The exponent is −2 (and in the biased form it is 127+(−2)= 125 = 0111 1101 )</li>
<li>The fraction is 0 (looking to the right of binary point in 1.0 is all zeros)</li>
</ul>

<p>From these we can form the resulting 32 bit IEEE 754 binary32 format representation of real number 0.25 as: 0-01111101-00000000000000000000000 = 3e800000<sub>H</sub></p>

<p><strong>Ex 3:</strong> Consider a value of 0.375. We saw that 

<math display="inline" id="Single-precision_floating-point_format:12">
 <semantics>
  <mrow>
   <mn>0.375</mn>
   <mo>=</mo>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1.1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msub>
    <mo>×</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="float">0.375</cn>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="float">1.1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0.375={(1.1)_{2}}\times 2^{-2}
  </annotation>
 </semantics>
</math>

</p>

<p>Hence after determining a representation of 0.375 as 

<math display="inline" id="Single-precision_floating-point_format:13">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1.1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msub>
   <mo>×</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="float">1.1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {(1.1)_{2}}\times 2^{-2}
  </annotation>
 </semantics>
</math>


 we can proceed as above:</p>
<ul>
<li>The exponent is −2 (and in the biased form it is 127+(−2)= 125 = 0111 1101 )</li>
<li>The fraction is 1 (looking to the right of binary point in 1.1 is a single 1 = x<sub>1</sub>)</li>
</ul>

<p>From these we can form the resulting 32 bit IEEE 754 binary32 format representation of real number 0.375 as: 0-01111101-10000000000000000000000 = 3ec00000<sub>H</sub></p>
<h3 id="single-precision-examples">Single-precision examples</h3>

<p>These examples are given in bit <em>representation</em>, in <a class="uri" href="hexadecimal" title="wikilink">hexadecimal</a>, of the floating-point value. This includes the sign, (biased) exponent, and significand.</p>

<p><code>3f80 0000  = 1</code><br/>
<code>c000 0000  = −2</code></p>

<p><code>7f7f ffff  ≈ 3.4028234 × 10</code><sup><code>38</code></sup><code> (max single precision)</code></p>

<p><code>0000 0000  = 0</code><br/>
<code>8000 0000  = −0</code></p>

<p><code>7f80 0000  = infinity</code><br/>
<code>ff80 0000  = −infinity</code></p>

<p><code>3eaa aaab  ≈ 1/3</code></p>

<p>By default, 1/3 rounds up, instead of down like <a href="double_precision" title="wikilink">double precision</a>, because of the even number of bits in the significand. The bits of 1/3 beyond the rounding point are <code>1010...</code> which is more than 1/2 of a <a href="unit_in_the_last_place" title="wikilink">unit in the last place</a>.</p>
<h3 id="converting-from-single-precision-binary-to-decimal">Converting from single-precision binary to decimal</h3>

<p>We start with the hexadecimal representation of the value, 41c80000, in this example, and convert it to binary:</p>

<p><code>41c8 0000</code><sub><code>16</code></sub><code> = 0100 0001 1100 1000 0000 0000 0000 0000</code><sub><code>2</code></sub></p>

<p>then we break it down into three parts: sign bit, exponent, and significand.</p>

<p><code>Sign bit: 0</code><br/>
<code>Exponent: 1000 0011</code><sub><code>2</code></sub><code> = 83</code><sub><code>16</code></sub><code> = 131</code><br/>
<code>Significand: 100 1000 0000 0000 0000 0000</code><sub><code>2</code></sub><code> = 480000</code><sub><code>16</code></sub></p>

<p>We then add the implicit 24th bit to the significand:</p>

<p><code>Significand: </code><strong><code>1</code></strong><code>100 1000 0000 0000 0000 0000</code><sub><code>2</code></sub><code> = C80000</code><sub><code>16</code></sub></p>

<p>and decode the exponent value by subtracting 127:</p>

<p><code>Raw exponent: 83</code><sub><code>16</code></sub><code> = 131</code><br/>
<code>Decoded exponent: 131 − 127 = </code><strong><code>4</code></strong></p>

<p>Each of the 24 bits of the significand (including the implicit 24th bit), bit 23 to bit 0, represents a value, starting at 1 and halves for each bit, as follows:</p>

<p><code>bit 23 = 1</code><br/>
<code>bit 22 = 0.5</code><br/>
<code>bit 21 = 0.25</code><br/>
<code>bit 20 = 0.125</code><br/>
<code>bit 19 = 0.0625</code><br/>
<code>.</code><br/>
<code>.</code><br/>
<code>bit 0 = 0.00000011920928955078125</code></p>

<p>The significand in this example has three bits set: bit 23, bit 22, and bit 19. We can now decode the significand by adding the values represented by these bits.</p>

<p><code>Decoded significand: 1 + 0.5 + 0.0625 = 1.5625 = C80000/2</code><sup><code>23</code></sup></p>

<p>Then we need to multiply with the base, 2, to the power of the exponent, to get the final result:</p>

<p><code>1.5625 × 2</code><sup><code>4</code></sup><code> = </code><strong><code>25</code></strong></p>

<p>Thus</p>

<p><code>41c8 0000  = 25</code></p>

<p>This is equivalent to:</p>

<p>

<math display="inline" id="Single-precision_floating-point_format:14">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>s</mi>
    </msup>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mi>m</mi>
       <mo>*</mo>
       <msup>
        <mn>2</mn>
        <mrow>
         <mo>-</mo>
         <mn>23</mn>
        </mrow>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mn>127</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>m</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <minus></minus>
         <cn type="integer">23</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <cn type="integer">127</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=(-1)^{s}\times(1+m*2^{-23})\times 2^{x-127}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Single-precision_floating-point_format:15">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is the sign bit, 

<math display="inline" id="Single-precision_floating-point_format:16">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is the exponent, and 

<math display="inline" id="Single-precision_floating-point_format:17">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is the significand.</p>
<h3 id="trivia">Trivia</h3>

<p>A fascinating example of how the floating-point format can be misused in a good way is shown in the <a href="fast_inverse_square_root" title="wikilink">fast inverse square root</a> implementation, where the complex calculation of square root and inversion are replaced (approximately) by a bit-shift and subtraction operated on the 32-bits of the floating point encoding as if it were an integer.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="IEEE_754-2008" title="wikilink">IEEE Standard for Floating-Point Arithmetic (IEEE 754)</a></li>
<li><a href="ISO/IEC_10967" title="wikilink">ISO/IEC 10967</a>, language independent arithmetic</li>
<li><a href="Primitive_data_type" title="wikilink">Primitive data type</a></li>
<li><a href="Numerical_stability" title="wikilink">Numerical stability</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.h-schmidt.net/FloatApplet/IEEE754.html">Online calculator</a></li>
<li><a href="http://www.binaryconvert.com/convert_float.html">Online converter for IEEE 754 numbers with single precision</a></li>
<li><a href="http://www.mathworks.com/matlabcentral/fileexchange/23173">C source code to convert between IEEE double, single, and half precision</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Binary_arithmetic" title="wikilink">Category:Binary arithmetic</a> <a href="Category:Computer_arithmetic" title="wikilink">Category:Computer arithmetic</a> <a href="Category:Floating_point_types" title="wikilink">Category:Floating point types</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="http://scc.ustc.edu.cn/zlsc/sugon/intel/compiler_f/main_for/lref_for/source_files/rfreals.htm">http://scc.ustc.edu.cn/zlsc/sugon/intel/compiler_f/main_for/lref_for/source_files/rfreals.htm</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://java.sun.com/docs/books/tutorial/java/nutsandbolts/datatypes.html">http://java.sun.com/docs/books/tutorial/java/nutsandbolts/datatypes.html</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a class="uri" href="https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1350006.4">https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1350006.4</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
