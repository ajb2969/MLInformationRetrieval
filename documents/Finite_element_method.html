<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="763">Finite element method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Finite element method</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>finite element method</strong> (<strong>FEM</strong>) is a <a href="numerical_analysis" title="wikilink">numerical technique</a> for finding approximate solutions to <a href="boundary_value_problem" title="wikilink">boundary value problems</a> for <a href="partial_differential_equations" title="wikilink">partial differential equations</a>. It uses subdivision of a whole problem domain into simpler parts, called finite elements, and <a href="variational_methods" title="wikilink">variational methods</a> from the <a href="calculus_of_variations" title="wikilink">calculus of variations</a> to solve the problem by minimizing an associated error function. Analogous to the idea that connecting many tiny straight lines can approximate a larger circle, FEM encompasses methods for connecting many simple element equations over many small subdomains, named finite elements, to approximate a more complex equation over a larger <a href="domain_of_a_function" title="wikilink">domain</a>.</p>
<h2 id="basic-concepts">Basic concepts</h2>

<p>The subdivision of a whole domain into simpler parts has several advantages:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<ul>
<li>Accurate representation of complex geometry</li>
<li>Inclusion of dissimilar material properties</li>
<li>Easy representation of the total solution</li>
<li>Capture of local effects.</li>
</ul>

<p>A typical work out of the method involves (1) dividing the domain of the problem into a collection of subdomains, with each subdomain represented by a set of element equations to the original problem, followed by (2) systematically recombining all sets of element equations into a global system of equations for the final calculation. The global system of equations has known solution techniques, and can be calculated from the <a href="initial_value" title="wikilink">initial values</a> of the original problem to obtain a numerical answer.</p>

<p>In the first step above, the element equations are simple equations that locally approximate the original complex equations to be studied, where the original equations are often <a href="partial_differential_equation" title="wikilink">partial differential equations</a> (PDE). To explain the approximation in this process, FEM is commonly introduced as a special case of <a href="Galerkin_method" title="wikilink">Galerkin method</a>. The process, in mathematical language, is to construct an integral of the <a href="inner_product" title="wikilink">inner product</a> of the residual and the weight functions and set the integral to zero. In simple terms, it is a procedure that minimizes the error of approximation by fitting trial functions into the PDE. The residual is the error caused by the trial functions, and the weight functions are <a class="uri" href="polynomial" title="wikilink">polynomial</a> approximation functions that project the residual. The process eliminates all the spatial derivatives from the PDE, thus approximating the PDE locally with</p>
<ul>
<li>a set of <a href="algebraic_equations" title="wikilink">algebraic equations</a> for <a href="steady_state" title="wikilink">steady state</a> problems,</li>
<li>a set of <a href="ordinary_differential_equation" title="wikilink">ordinary differential equations</a> for <a href="transient_state" title="wikilink">transient</a> problems.</li>
</ul>

<p>These equation sets are the element equations. They are <a class="uri" href="linear" title="wikilink">linear</a> if the underlying PDE is linear, and vice versa. Algebraic equation sets that arise in the steady state problems are solved using <a href="numerical_linear_algebra" title="wikilink">numerical linear algebra</a> methods, while ordinary differential equation sets that arise in the transient problems are solved by numerical integration using standard techniques such as <a href="Euler's_method" title="wikilink">Euler's method</a> or the <a class="uri" href="Runge-Kutta" title="wikilink">Runge-Kutta</a> method.</p>

<p>In step (2) above, a global system of equations is generated from the element equations through a transformation of coordinates from the subdomains' local nodes to the domain's global nodes. This spatial transformation includes appropriate <a href="Transformation_matrix" title="wikilink">orientation adjustments</a> as applied in relation to the reference <a href="coordinate_system" title="wikilink">coordinate system</a>. The process is often carried out by FEM software using <a href="coordinates" title="wikilink">coordinate</a> data generated from the subdomains.</p>

<p>FEM is best understood from its practical application, known as <strong>finite element analysis (FEA)</strong>. FEA as applied in <a class="uri" href="engineering" title="wikilink">engineering</a> is a computational tool for performing <a href="engineering_analysis" title="wikilink">engineering analysis</a>. It includes the use of <a href="mesh_generation" title="wikilink">mesh generation</a> techniques for dividing a <a href="complex_system" title="wikilink">complex problem</a> into small elements, as well as the use of <a class="uri" href="software" title="wikilink">software</a> program coded with FEM algorithm. In applying FEA, the complex problem is usually a physical system with the underlying <a class="uri" href="physics" title="wikilink">physics</a> such as the <a href="Euler-Bernoulli_beam_equation" title="wikilink">Euler-Bernoulli beam equation</a>, the <a href="heat_equation" title="wikilink">heat equation</a>, or the <a href="Navier-Stokes_equations" title="wikilink">Navier-Stokes equations</a> expressed in either PDE or <a href="integral_equation" title="wikilink">integral equations</a>, while the divided small elements of the complex problem represent different areas in the physical system.</p>

<p>FEA is a good choice for analyzing problems over complicated domains (like cars and oil pipelines), when the domain changes (as during a solid state reaction with a moving boundary), when the desired precision varies over the entire domain, or when the solution lacks smoothness. For instance, in a frontal crash simulation it is possible to increase prediction accuracy in "important" areas like the front of the car and reduce it in its rear (thus reducing cost of the simulation). Another example would be in <a href="numerical_weather_prediction" title="wikilink">numerical weather prediction</a>, where it is more important to have accurate predictions over developing highly nonlinear phenomena (such as <a href="tropical_cyclone" title="wikilink">tropical cyclones</a> in the atmosphere, or <a href="Eddy_(fluid_dynamics)" title="wikilink">eddies</a> in the ocean) rather than relatively calm areas.  </p>
<h2 id="history">History</h2>

<p>While it is difficult to quote a date of the invention of the finite element method, the method originated from the need to solve complex <a href="Elasticity_(physics)" title="wikilink">elasticity</a> and <a href="structural_analysis" title="wikilink">structural analysis</a> problems in <a href="civil_engineering" title="wikilink">civil</a> and <a href="aeronautical_engineering" title="wikilink">aeronautical engineering</a>. Its development can be traced back to the work by <a href="Alexander_Hrennikoff" title="wikilink">A. Hrennikoff</a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and <a href="Richard_Courant" title="wikilink">R. Courant</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In China, in the later 1950s and early 1960s, based on the computations of dam constructions, <a href="Feng_Kang" title="wikilink">K. Feng</a> proposed a systematic numerical method for solving <a href="partial_differential_equation" title="wikilink">partial differential equations</a>. The method was called the finite difference method based on variation principle, which was another independent invention of finite element method. Although the approaches used by these pioneers are different, they share one essential characteristic: <a href="Polygon_mesh" title="wikilink">mesh</a> <a class="uri" href="discretization" title="wikilink">discretization</a> of a continuous domain into a set of discrete sub-domains, usually called elements.</p>

<p>Hrennikoff's work discretizes the domain by using a <a href="Lattice_(group)" title="wikilink">lattice</a> analogy, while Courant's approach divides the domain into finite triangular subregions to solve <a href="second_order_equation" title="wikilink">second order</a> <a href="elliptic_equation" title="wikilink">elliptic</a> partial differential equations (PDEs) that arise from the problem of <a href="torsion_(mechanics)" title="wikilink">torsion</a> of a <a href="cylinder_(geometry)" title="wikilink">cylinder</a>. Courant's contribution was evolutionary, drawing on a large body of earlier results for PDEs developed by <a href="John_William_Strutt,_3rd_Baron_Rayleigh" title="wikilink">Rayleigh</a>, <a href="Walther_Ritz" title="wikilink">Ritz</a>, and <a href="Boris_Galerkin" title="wikilink">Galerkin</a>.</p>

<p>The finite element method obtained its real impetus in the 1960s and 1970s by the developments of <a href="John_Argyris" title="wikilink">J. H. Argyris</a> with co-workers at the <a href="University_of_Stuttgart" title="wikilink">University of Stuttgart</a>, <a href="Ray_W._Clough" title="wikilink">R. W. Clough</a> with co-workers at <a href="University_of_California,_Berkeley" title="wikilink">UC Berkeley</a>, <a href="Olgierd_Zienkiewicz" title="wikilink">O. C. Zienkiewicz</a> with co-workers <a href="Ernest_Hinton" title="wikilink">Ernest Hinton</a>, Bruce Irons<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and others at the <a href="Swansea_University" title="wikilink">University of Swansea</a>, <a href="Philippe_G._Ciarlet" title="wikilink">Philippe G. Ciarlet</a> at the University of <a href="Pierre-and-Marie-Curie_University" title="wikilink">Paris 6</a> and Richard Gallagher<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> with co-workers at <a href="Cornell_University" title="wikilink">Cornell University</a>. Further impetus was provided in these years by available open source finite element software programs. NASA sponsored the original version of <a class="uri" href="NASTRAN" title="wikilink">NASTRAN</a>, and UC Berkeley made the finite element program SAP IV<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> widely available. In Norway the ship classification society Det Norske Veritas (now <a href="DNV_GL" title="wikilink">DNV GL</a>) developed <a href="SESAM_(FEM)" title="wikilink">Sesam</a> in 1969 for use in analysis of ships.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> A rigorous mathematical basis to the finite element method was provided in 1973 with the publication by <a href="Gilbert_Strang" title="wikilink">Strang</a> and <a href="George_Fix" title="wikilink">Fix</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The method has since been generalized for the <a href="numerical_analysis" title="wikilink">numerical modeling</a> of physical systems in a wide variety of <a class="uri" href="engineering" title="wikilink">engineering</a> disciplines, e.g., <a class="uri" href="electromagnetism" title="wikilink">electromagnetism</a>, <a href="heat_transfer" title="wikilink">heat transfer</a>, and <a href="fluid_dynamics" title="wikilink">fluid dynamics</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="technical-discussion">Technical discussion</h2>
<h3 id="the-structure-of-finite-element-methods">The structure of finite element methods</h3>

<p>Finite element methods are numerical methods for approximating the solutions of mathematical problems that are usually formulated so as to precisely state an idea of some aspect of physical reality.</p>

<p>A finite element method is characterized by a <a href="Calculus_of_variations" title="wikilink">variational formulation</a>, a discretization strategy, one or more solution algorithms and post-processing procedures.</p>

<p>Examples of variational formulation are the <a href="Galerkin_method" title="wikilink">Galerkin method</a>, the discontinuous Galerkin method, mixed methods, etc.</p>

<p>A discretization strategy is understood to mean a clearly defined set of procedures that cover (a) the creation of finite element meshes, (b) the definition of basis function on reference elements (also called shape functions) and (c) the mapping of reference elements onto the elements of the mesh. Examples of discretization strategies are the h-version, <a href="p-FEM" title="wikilink">p-version</a>, <a href="Hp-FEM" title="wikilink">hp-version</a>, <a href="Extended_finite_element_method" title="wikilink">x-FEM</a>, <a href="isogeometric_analysis" title="wikilink">isogeometric analysis</a>, etc. Each discretization strategy has certain advantages and disadvantages. A reasonable criterion in selecting a discretization strategy is to realize nearly optimal performance for the broadest set of mathematical models in a particular model class.</p>

<p>There are various numerical solution algorithms that can be classified into two broad categories; direct and iterative solvers. These algorithms are designed to exploit the sparsity of matrices that depend on the choices of variational formulation and discretization strategy.</p>

<p>Postprocessing procedures are designed for the extraction of the data of interest from a finite element solution. In order to meet the requirements of solution verification, postprocessors need to provide for a posteriori error estimation in terms of the quantities of interest. When the errors of approximation are larger than what is considered acceptable then the discretization has to be changed either by an automated adaptive process or by action of the analyst. There are some very efficient postprocessors that provide for the realization of <a class="uri" href="superconvergence" title="wikilink">superconvergence</a>.</p>
<h3 id="illustrative-problems-p1-and-p2">Illustrative problems P1 and P2</h3>

<p>We will illustrate the finite element method using two sample problems from which the general method can be extrapolated. It is assumed that the reader is familiar with <a class="uri" href="calculus" title="wikilink">calculus</a> and <a href="linear_algebra" title="wikilink">linear algebra</a>.</p>

<p>P1 is a <em>' one-dimensional</em>' problem</p>

<p>

<math display="block" id="Finite_element_method:0">
 <semantics>
  <mrow>
   <mtext>P1</mtext>
   <mo>:</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <msup>
           <mi>u</mi>
           <mi>′′</mi>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mtext>in</mtext>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>0</mn>
           <mo>,</mo>
           <mn>1</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mi>u</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>0</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mi>u</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>1</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>P1</mtext>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>u</ci>
        <ci>′′</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
       <mtext>in</mtext>
       <interval closure="open">
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </interval>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>u</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <ci>u</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{ P1 }:\begin{cases}u^{\prime\prime}(x)=f(x)\mbox{ in }(0,1),\\
u(0)=u(1)=0,\end{cases}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Finite_element_method:1">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is given, 

<math display="inline" id="Finite_element_method:2">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 is an unknown function of 

<math display="inline" id="Finite_element_method:3">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Finite_element_method:4">
 <semantics>
  <msup>
   <mi>u</mi>
   <mi>′′</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>u</ci>
    <ci>′′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u^{\prime\prime}
  </annotation>
 </semantics>
</math>

 is the second derivative of 

<math display="inline" id="Finite_element_method:5">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>


 with respect to 

<math display="inline" id="Finite_element_method:6">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

.</p>

<p>P2 is a <em>' two-dimensional</em>' problem (<a href="Dirichlet_problem" title="wikilink">Dirichlet problem</a>)</p>

<p>

<math display="block" id="Finite_element_method:7">
 <semantics>
  <mrow>
   <mtext>P2</mtext>
   <mo>:</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mi>u</mi>
           <mrow>
            <mi>x</mi>
            <mi>x</mi>
           </mrow>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>y</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mrow>
          <msub>
           <mi>u</mi>
           <mrow>
            <mi>y</mi>
            <mi>y</mi>
           </mrow>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>y</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>in</mtext>
         <mi mathvariant="normal">Ω</mi>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>u</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>on</mtext>
         <mrow>
          <mo>∂</mo>
          <mi mathvariant="normal">Ω</mi>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>P2</mtext>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <apply>
          <times></times>
          <ci>x</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <apply>
          <times></times>
          <ci>y</ci>
          <ci>y</ci>
         </apply>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>in</mtext>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <eq></eq>
      <ci>u</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <mtext>on</mtext>
      <apply>
       <partialdiff></partialdiff>
       <ci>normal-Ω</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{P2 }:\begin{cases}u_{xx}(x,y)+u_{yy}(x,y)=f(x,y)&\mbox{ in }\Omega,\\
u=0&\mbox{ on }\partial\Omega,\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Finite_element_method:8">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 is a connected open region in the 

<math display="inline" id="Finite_element_method:9">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 plane whose boundary 

<math display="inline" id="Finite_element_method:10">
 <semantics>
  <mrow>
   <mo>∂</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <partialdiff></partialdiff>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial\Omega
  </annotation>
 </semantics>
</math>

 is "nice" (e.g., a <a href="smooth_manifold" title="wikilink">smooth manifold</a> or a <a class="uri" href="polygon" title="wikilink">polygon</a>), and 

<math display="inline" id="Finite_element_method:11">
 <semantics>
  <msub>
   <mi>u</mi>
   <mrow>
    <mi>x</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{xx}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_element_method:12">
 <semantics>
  <msub>
   <mi>u</mi>
   <mrow>
    <mi>y</mi>
    <mi>y</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{yy}
  </annotation>
 </semantics>
</math>

 denote the second derivatives with respect to 

<math display="inline" id="Finite_element_method:13">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_element_method:14">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, respectively.</p>

<p>The problem P1 can be solved "directly" by computing <a href="antiderivative" title="wikilink">antiderivatives</a>. However, this method of solving the <a href="boundary_value_problem" title="wikilink">boundary value problem</a> (BVP) works only when there is one spatial dimension and does not generalize to higher-dimensional problems or to problems like 

<math display="inline" id="Finite_element_method:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mo>+</mo>
    <msup>
     <mi>u</mi>
     <mi>′′</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>u</ci>
      <ci>′′</ci>
     </apply>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u+u^{\prime\prime}=f
  </annotation>
 </semantics>
</math>

. For this reason, we will develop the finite element method for P1 and outline its generalization to P2.</p>

<p>Our explanation will proceed in two steps, which mirror two essential steps one must take to solve a boundary value problem (BVP) using the FEM.</p>
<ul>
<li>In the first step, one rephrases the original BVP in its weak form. Little to no computation is usually required for this step. The transformation is done by hand on paper.</li>
<li>The second step is the discretization, where the weak form is discretized in a finite-dimensional space.</li>
</ul>

<p>After this second step, we have concrete formulae for a large but finite-dimensional linear problem whose solution will approximately solve the original BVP. This finite-dimensional problem is then implemented on a <a class="uri" href="computer" title="wikilink">computer</a>.</p>
<h3 id="weak-formulation">Weak formulation</h3>

<p>The first step is to convert P1 and P2 into their equivalent <a href="weak_formulation" title="wikilink">weak formulations</a>.</p>
<h4 id="the-weak-form-of-p1">The weak form of P1</h4>

<p>If 

<math display="inline" id="Finite_element_method:16">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 solves P1, then for any smooth function 

<math display="inline" id="Finite_element_method:17">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 that satisfies the displacement boundary conditions, i.e. 

<math display="inline" id="Finite_element_method:18">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>v</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v=0
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Finite_element_method:19">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_element_method:20">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=1
  </annotation>
 </semantics>
</math>

, we have</p>

<p>(1) 

<math display="inline" id="Finite_element_method:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mn>1</mn>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>v</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mn>1</mn>
     </msubsup>
     <mrow>
      <msup>
       <mi>u</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>v</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <ci>v</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <ci>′′</ci>
      </apply>
      <ci>x</ci>
      <ci>v</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{0}^{1}f(x)v(x)\,dx=\int_{0}^{1}u^{\prime\prime}(x)v(x)\,dx.
  </annotation>
 </semantics>
</math>

</p>

<p>Conversely, if 

<math display="inline" id="Finite_element_method:22">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Finite_element_method:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>u</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(0)=u(1)=0
  </annotation>
 </semantics>
</math>

 satisfies (1) for every smooth function 

<math display="inline" id="Finite_element_method:24">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(x)
  </annotation>
 </semantics>
</math>

 then one may show that this 

<math display="inline" id="Finite_element_method:25">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 will solve P1. The proof is easier for twice continuously differentiable 

<math display="inline" id="Finite_element_method:26">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 (<a href="mean_value_theorem" title="wikilink">mean value theorem</a>), but may be proved in a <a href="Distribution_(mathematics)" title="wikilink">distributional</a> sense as well.</p>

<p>By using <a href="integration_by_parts" title="wikilink">integration by parts</a> on the right-hand-side of (1), we obtain</p>

<p>(2)

<math display="inline" id="Finite_element_method:27">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mstyle displaystyle="true">
       <msubsup>
        <mo largeop="true" symmetric="true">∫</mo>
        <mn>0</mn>
        <mn>1</mn>
       </msubsup>
      </mstyle>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>v</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mrow>
       <mstyle displaystyle="true">
        <msubsup>
         <mo largeop="true" symmetric="true">∫</mo>
         <mn>0</mn>
         <mn>1</mn>
        </msubsup>
       </mstyle>
       <mrow>
        <msup>
         <mi>u</mi>
         <mi>′′</mi>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
        <mi>d</mi>
        <mi>x</mi>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mrow>
       <msubsup>
        <mrow>
         <mrow>
          <msup>
           <mi>u</mi>
           <mo>′</mo>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>v</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo fence="true">|</mo>
        </mrow>
        <mn>0</mn>
        <mn>1</mn>
       </msubsup>
       <mo>-</mo>
       <mrow>
        <mstyle displaystyle="true">
         <msubsup>
          <mo largeop="true" symmetric="true">∫</mo>
          <mn>0</mn>
          <mn>1</mn>
         </msubsup>
        </mstyle>
        <mrow>
         <msup>
          <mi>u</mi>
          <mo>′</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <msup>
          <mi>v</mi>
          <mo>′</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo rspace="4.2pt" stretchy="false">)</mo>
         </mrow>
         <mi>d</mi>
         <mi>x</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mstyle displaystyle="true">
          <msubsup>
           <mo largeop="true" symmetric="true">∫</mo>
           <mn>0</mn>
           <mn>1</mn>
          </msubsup>
         </mstyle>
         <mrow>
          <msup>
           <mi>u</mi>
           <mo>′</mo>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <msup>
           <mi>v</mi>
           <mo>′</mo>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo rspace="4.2pt" stretchy="false">)</mo>
          </mrow>
          <mi>d</mi>
          <mi>x</mi>
         </mrow>
        </mrow>
       </mrow>
       <mo>≡</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>ϕ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>u</mi>
          <mo>,</mo>
          <mi>v</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
       <ci>v</ci>
       <ci>x</ci>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <cn type="integer">0</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>u</ci>
         <ci>′′</ci>
        </apply>
        <ci>x</ci>
        <ci>v</ci>
        <ci>x</ci>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="latexml">evaluated-at</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>u</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>x</ci>
         <ci>v</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <int></int>
          <cn type="integer">0</cn>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>u</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>v</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>x</ci>
         <ci>d</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <int></int>
           <cn type="integer">0</cn>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>u</ci>
           <ci>normal-′</ci>
          </apply>
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>v</ci>
           <ci>normal-′</ci>
          </apply>
          <ci>x</ci>
          <ci>d</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <equivalent></equivalent>
       <share href="#.cmml">
       </share>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>ϕ</ci>
         <interval closure="open">
          <ci>u</ci>
          <ci>v</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle\int_{0}^{1}f(x)v(x)\,dx&\displaystyle=\int_{0}^{1%
}u^{\prime\prime}(x)v(x)\,dx\\
&\displaystyle=u^{\prime}(x)v(x)|_{0}^{1}-\int_{0}^{1}u^{\prime}(x)v^{\prime}(%
x)\,dx\\
&\displaystyle=-\int_{0}^{1}u^{\prime}(x)v^{\prime}(x)\,dx\equiv-\phi(u,v),%
\end{aligned}
  </annotation>
 </semantics>
</math>

</p>

<p>where we have used the assumption that 

<math display="inline" id="Finite_element_method:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>v</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(0)=v(1)=0
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="the-weak-form-of-p2">The weak form of P2</h4>

<p>If we integrate by parts using a form of <a href="Green's_identities" title="wikilink">Green's identities</a>, we see that if 

<math display="inline" id="Finite_element_method:29">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 solves P2, then for any 

<math display="inline" id="Finite_element_method:30">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Finite_element_method:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mi>f</mi>
      <mpadded width="+1.7pt">
       <mi>v</mi>
      </mpadded>
      <mi>d</mi>
      <mi>s</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi mathvariant="normal">Ω</mi>
      </msub>
      <mrow>
       <mrow>
        <mo>∇</mo>
        <mi>u</mi>
       </mrow>
       <mo>⋅</mo>
       <mrow>
        <mo>∇</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <mi>v</mi>
         </mpadded>
         <mi>d</mi>
         <mi>s</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Ω</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>v</ci>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>normal-Ω</ci>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <ci>normal-∇</ci>
         <ci>u</ci>
        </apply>
        <apply>
         <ci>normal-∇</ci>
         <apply>
          <times></times>
          <ci>v</ci>
          <ci>d</ci>
          <ci>s</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\Omega}fv\,ds=-\int_{\Omega}\nabla u\cdot\nabla v\,ds\equiv-\phi(u,v),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Finite_element_method:32">
 <semantics>
  <mo>∇</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∇</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla
  </annotation>
 </semantics>
</math>

 denotes the <a class="uri" href="gradient" title="wikilink">gradient</a> and 

<math display="inline" id="Finite_element_method:33">
 <semantics>
  <mo>⋅</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdot
  </annotation>
 </semantics>
</math>

 denotes the <a href="dot_product" title="wikilink">dot product</a> in the two-dimensional plane. Once more 

<math display="inline" id="Finite_element_method:34">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\!\phi
  </annotation>
 </semantics>
</math>

 can be turned into an inner product on a suitable space 

<math display="inline" id="Finite_element_method:35">
 <semantics>
  <mrow>
   <msubsup>
    <mi>H</mi>
    <mn>0</mn>
    <mn>1</mn>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}^{1}(\Omega)
  </annotation>
 </semantics>
</math>

 of "once differentiable" functions of 

<math display="inline" id="Finite_element_method:36">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 that are zero on 

<math display="inline" id="Finite_element_method:37">
 <semantics>
  <mrow>
   <mo>∂</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <partialdiff></partialdiff>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial\Omega
  </annotation>
 </semantics>
</math>

. We have also assumed that 

<math display="inline" id="Finite_element_method:38">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mrow>
    <msubsup>
     <mi>H</mi>
     <mn>0</mn>
     <mn>1</mn>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-Ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in H_{0}^{1}(\Omega)
  </annotation>
 </semantics>
</math>

 (see <a href="Sobolev_space" title="wikilink">Sobolev spaces</a>). Existence and uniqueness of the solution can also be shown.</p>
<h4 id="a-proof-outline-of-existence-and-uniqueness-of-the-solution">A proof outline of existence and uniqueness of the solution</h4>

<p>We can loosely think of 

<math display="inline" id="Finite_element_method:39">
 <semantics>
  <mrow>
   <msubsup>
    <mi>H</mi>
    <mn>0</mn>
    <mn>1</mn>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}^{1}(0,1)
  </annotation>
 </semantics>
</math>

 to be the <a href="absolutely_continuous" title="wikilink">absolutely continuous</a> functions of 

<math display="inline" id="Finite_element_method:40">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,1)
  </annotation>
 </semantics>
</math>

 that are 

<math display="inline" id="Finite_element_method:41">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 at 

<math display="inline" id="Finite_element_method:42">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_element_method:43">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=1
  </annotation>
 </semantics>
</math>

 (see <a href="Sobolev_spaces" title="wikilink">Sobolev spaces</a>). Such functions are (weakly) "once differentiable" and it turns out that the symmetric <a href="bilinear_map" title="wikilink">bilinear map</a> 

<math display="inline" id="Finite_element_method:44">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\,\phi
  </annotation>
 </semantics>
</math>

 then defines an <a href="inner_product" title="wikilink">inner product</a> which turns 

<math display="inline" id="Finite_element_method:45">
 <semantics>
  <mrow>
   <msubsup>
    <mi>H</mi>
    <mn>0</mn>
    <mn>1</mn>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}^{1}(0,1)
  </annotation>
 </semantics>
</math>

 into a <a href="Hilbert_space" title="wikilink">Hilbert space</a> (a detailed proof is nontrivial). On the other hand, the left-hand-side 

<math display="inline" id="Finite_element_method:46">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mn>0</mn>
    <mn>1</mn>
   </msubsup>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
     <ci>v</ci>
     <ci>x</ci>
     <ci>d</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{0}^{1}f(x)v(x)dx
  </annotation>
 </semantics>
</math>

 is also an inner product, this time on the <a href="Lp_space" title="wikilink">Lp space</a> 

<math display="inline" id="Finite_element_method:47">
 <semantics>
  <mrow>
   <msup>
    <mi>L</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{2}(0,1)
  </annotation>
 </semantics>
</math>

. An application of the <a href="Riesz_representation_theorem" title="wikilink">Riesz representation theorem</a> for Hilbert spaces shows that there is a unique 

<math display="inline" id="Finite_element_method:48">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 solving (2) and therefore P1. This solution is a-priori only a member of 

<math display="inline" id="Finite_element_method:49">
 <semantics>
  <mrow>
   <msubsup>
    <mi>H</mi>
    <mn>0</mn>
    <mn>1</mn>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}^{1}(0,1)
  </annotation>
 </semantics>
</math>

, but using <a href="elliptic_operator" title="wikilink">elliptic</a> regularity, will be smooth if 

<math display="inline" id="Finite_element_method:50">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is.</p>
<h2 id="discretization">Discretization</h2>
<figure><b>(Figure)</b>
<figcaption>A function in 

<math display="inline" id="Finite_element_method:51">
 <semantics>
  <mrow>
   <msubsup>
    <mi>H</mi>
    <mn>0</mn>
    <mn>1</mn>
   </msubsup>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}^{1},
  </annotation>
 </semantics>
</math>

 with zero values at the endpoints (blue), and a piecewise linear approximation (red)</figcaption>
</figure>

<p>P1 and P2 are ready to be discretized which leads to a common sub-problem (3). The basic idea is to replace the infinite-dimensional linear problem:</p>
<dl>
<dd>Find 

<math display="inline" id="Finite_element_method:52">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>H</mi>
    <mn>0</mn>
    <mn>1</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>u</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\in H_{0}^{1}
  </annotation>
 </semantics>
</math>

 such that
</dd>
<dd>

<math display="inline" id="Finite_element_method:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>v</mi>
    </mrow>
    <mo>∈</mo>
    <msubsup>
     <mi>H</mi>
     <mn>0</mn>
     <mn>1</mn>
    </msubsup>
   </mrow>
   <mo rspace="5.3pt">,</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>f</mi>
      <mi>v</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>v</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v\in H_{0}^{1},\;-\phi(u,v)=\int fv
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>with a finite-dimensional version:</p>
<dl>
<dd>(3) Find 

<math display="inline" id="Finite_element_method:54">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>u</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\in V
  </annotation>
 </semantics>
</math>

 such that
</dd>
<dd>

<math display="inline" id="Finite_element_method:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>v</mi>
    </mrow>
    <mo>∈</mo>
    <mi>V</mi>
   </mrow>
   <mo rspace="5.3pt">,</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>f</mi>
      <mi>v</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>v</ci>
     </apply>
     <ci>V</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <int></int>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v\in V,\;-\phi(u,v)=\int fv
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>where 

<math display="inline" id="Finite_element_method:56">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is a finite-dimensional <a href="Linear_subspace" title="wikilink">subspace</a> of 

<math display="inline" id="Finite_element_method:57">
 <semantics>
  <msubsup>
   <mi>H</mi>
   <mn>0</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}^{1}
  </annotation>
 </semantics>
</math>

. There are many possible choices for 

<math display="inline" id="Finite_element_method:58">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 (one possibility leads to the <a href="spectral_method" title="wikilink">spectral method</a>). However, for the finite element method we take 

<math display="inline" id="Finite_element_method:59">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 to be a space of piecewise polynomial functions.</p>
<h3 id="for-problem-p1">For problem P1</h3>

<p>We take the interval 

<math display="inline" id="Finite_element_method:60">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,1)
  </annotation>
 </semantics>
</math>

, choose 

<math display="inline" id="Finite_element_method:61">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 values of 

<math display="inline" id="Finite_element_method:62">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 with 

<math display="block" id="Finite_element_method:63">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>v</mi>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo>→</mo>
      <mpadded width="+2.8pt">
       <mi>ℝ</mi>
      </mpadded>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mrow>
          <mrow>
           <mi>v</mi>
           <mtext>is continuous,</mtext>
           <mi>v</mi>
          </mrow>
          <mo fence="true">|</mo>
         </mrow>
         <mrow>
          <mo stretchy="false">[</mo>
          <msub>
           <mi>x</mi>
           <mi>k</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>x</mi>
           <mrow>
            <mi>k</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mo stretchy="false">]</mo>
         </mrow>
        </msub>
        <mtext>is linear for</mtext>
        <mi>k</mi>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mn>0</mn>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mtext>, and</mtext>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>0</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>v</ci>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <ci>normal-→</ci>
       <interval closure="closed">
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </interval>
       <ci>ℝ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="latexml">evaluated-at</csymbol>
          <apply>
           <times></times>
           <ci>v</ci>
           <mtext>is continuous,</mtext>
           <ci>v</ci>
          </apply>
          <interval closure="closed">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>k</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <apply>
             <plus></plus>
             <ci>k</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
          </interval>
         </apply>
         <mtext>is linear for</mtext>
         <ci>k</ci>
        </apply>
        <list>
         <cn type="integer">0</cn>
         <ci>normal-…</ci>
        </list>
       </apply>
       <apply>
        <and></and>
        <apply>
         <eq></eq>
         <apply>
          <times></times>
          <ci>n</ci>
          <mtext>, and</mtext>
          <ci>v</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <times></times>
          <ci>v</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <eq></eq>
         <share href="#.cmml">
         </share>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=\{v:[0,1]\rightarrow\mathbb{R}\;:v\mbox{ is continuous, }v|_{[x_{k},x_{k+1}]%
}\mbox{ is linear for }k=0,\dots,n\mbox{, and }v(0)=v(1)=0\}
  </annotation>
 </semantics>
</math>

 by:</p>

<p>

<math display="inline" id="Finite_element_method:64">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}=0
  </annotation>
 </semantics>
</math>

</p>

<p>where we define 

<math display="inline" id="Finite_element_method:65">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_element_method:66">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

. Observe that functions in 

<math display="inline" id="Finite_element_method:67">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V
  </annotation>
 </semantics>
</math>

 are not differentiable according to the elementary definition of calculus. Indeed, if 

<math display="inline" id="Finite_element_method:68">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=x_{k}
  </annotation>
 </semantics>
</math>

 then the derivative is typically not defined at any 

<math display="inline" id="Finite_element_method:69">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1,\ldots,n
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Finite_element_method:70">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. However, the derivative exists at every other value of 

<math display="inline" id="Finite_element_method:71">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 and one can use this derivative for the purpose of <a href="integration_by_parts" title="wikilink">integration by parts</a>.</p>
<figure><b>(Figure)</b>
<figcaption>A piecewise linear function in two dimensions</figcaption>
</figure>
<h3 id="for-problem-p2">For problem P2</h3>

<p>We need 

<math display="inline" id="Finite_element_method:72">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 to be a set of functions of 

<math display="inline" id="Finite_element_method:73">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

. In the figure on the right, we have illustrated a <a href="Polygon_triangulation" title="wikilink">triangulation</a> of a 15 sided <a href="polygon" title="wikilink">polygonal</a> region 

<math display="inline" id="Finite_element_method:74">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 in the plane (below), and a piecewise linear function (above, in color) of this polygon which is linear on each triangle of the triangulation; the space 

<math display="inline" id="Finite_element_method:75">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi>h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{h}
  </annotation>
 </semantics>
</math>

 would consist of functions that are linear on each triangle of the chosen triangulation.</p>

<p>One often reads 

<math display="inline" id="Finite_element_method:76">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 instead of 

<math display="inline" id="Finite_element_method:77">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>h</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h>0
  </annotation>
 </semantics>
</math>

 in the literature. The reason is that one hopes that as the underlying triangular grid becomes finer and finer, the solution of the discrete problem (3) will in some sense converge to the solution of the original boundary value problem P2. The triangulation is then indexed by a real valued parameter 

<math display="inline" id="Finite_element_method:78">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 which one takes to be very small. This parameter will be related to the size of the largest or average triangle in the triangulation. As we refine the triangulation, the space of piecewise linear functions 

<math display="inline" id="Finite_element_method:79">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 must also change with 

<math display="inline" id="Finite_element_method:80">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi>h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{h}
  </annotation>
 </semantics>
</math>

, hence the notation 

<math display="inline" id="Finite_element_method:81">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

. Since we do not perform such an analysis, we will not use this notation.</p>
<h3 id="choosing-a-basis">Choosing a basis</h3>

<p>To complete the discretization, we must select a <a href="Basis_(linear_algebra)" title="wikilink">basis</a> of 

<math display="inline" id="Finite_element_method:82">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

. In the one-dimensional case, for each control point 

<math display="inline" id="Finite_element_method:83">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{k}
  </annotation>
 </semantics>
</math>

 we will choose the piecewise linear function 

<math display="inline" id="Finite_element_method:84">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Finite_element_method:85">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 whose value is 

<math display="inline" id="Finite_element_method:86">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Finite_element_method:87">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo rspace="5.3pt">,</mo>
    <mi>j</mi>
   </mrow>
   <mo>≠</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <ci>j</ci>
    </list>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j},\;j\neq k
  </annotation>
 </semantics>
</math>

 and zero at every 

<math display="block" id="Finite_element_method:88">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>v</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mstyle displaystyle="false">
        <mfrac>
         <mrow>
          <mi>x</mi>
          <mo>-</mo>
          <msub>
           <mi>x</mi>
           <mrow>
            <mi>k</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
         </mrow>
         <mrow>
          <mpadded width="+1.7pt">
           <msub>
            <mi>x</mi>
            <mi>k</mi>
           </msub>
          </mpadded>
          <mo>-</mo>
          <msub>
           <mi>x</mi>
           <mrow>
            <mi>k</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
         </mrow>
        </mfrac>
       </mstyle>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>x</mi>
         </mrow>
         <mo>∈</mo>
         <mrow>
          <mo stretchy="false">[</mo>
          <msub>
           <mi>x</mi>
           <mrow>
            <mi>k</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>x</mi>
           <mi>k</mi>
          </msub>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mstyle displaystyle="false">
        <mfrac>
         <mrow>
          <mpadded width="+1.7pt">
           <msub>
            <mi>x</mi>
            <mrow>
             <mi>k</mi>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
           </msub>
          </mpadded>
          <mo>-</mo>
          <mi>x</mi>
         </mrow>
         <mrow>
          <mpadded width="+1.7pt">
           <msub>
            <mi>x</mi>
            <mrow>
             <mi>k</mi>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
           </msub>
          </mpadded>
          <mo>-</mo>
          <msub>
           <mi>x</mi>
           <mi>k</mi>
          </msub>
         </mrow>
        </mfrac>
       </mstyle>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>x</mi>
         </mrow>
         <mo>∈</mo>
         <mrow>
          <mo stretchy="false">[</mo>
          <msub>
           <mi>x</mi>
           <mi>k</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>x</mi>
           <mrow>
            <mi>k</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mtext>otherwise</mtext>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>k</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>x</ci>
      </apply>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>x</ci>
      </apply>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </interval>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{k}(x)=\begin{cases}{x-x_{k-1}\over x_{k}\,-x_{k-1}}&\mbox{ if }x\in[x_{k-1}%
,x_{k}],\\
{x_{k+1}\,-x\over x_{k+1}\,-x_{k}}&\mbox{ if }x\in[x_{k},x_{k+1}],\\
0&\mbox{ otherwise},\end{cases}
  </annotation>
 </semantics>
</math>

, i.e.,</p>

<p>

<math display="inline" id="Finite_element_method:89">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1,\dots,n
  </annotation>
 </semantics>
</math>

</p>

<p>for 

<math display="inline" id="Finite_element_method:90">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{k}
  </annotation>
 </semantics>
</math>

; this basis is a shifted and scaled <a href="tent_function" title="wikilink">tent function</a>. For the two-dimensional case, we choose again one basis function 

<math display="inline" id="Finite_element_method:91">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 per vertex 

<math display="inline" id="Finite_element_method:92">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 of the triangulation of the planar region 

<math display="inline" id="Finite_element_method:93">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{k}
  </annotation>
 </semantics>
</math>

. The function 

<math display="inline" id="Finite_element_method:94">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is the unique function of 

<math display="inline" id="Finite_element_method:95">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 whose value is 

<math display="inline" id="Finite_element_method:96">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Finite_element_method:97">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo rspace="5.3pt">,</mo>
    <mi>j</mi>
   </mrow>
   <mo>≠</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <ci>j</ci>
    </list>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j},\;j\neq k
  </annotation>
 </semantics>
</math>

 and zero at every 

<math display="block" id="Finite_element_method:98">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>v</mi>
     <mi>j</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mn>1</mn>
    </msubsup>
    <mrow>
     <msub>
      <mi>v</mi>
      <mi>j</mi>
     </msub>
     <mpadded width="+1.7pt">
      <msub>
       <mi>v</mi>
       <mi>k</mi>
      </msub>
     </mpadded>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>k</ci>
     </apply>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>k</ci>
      </apply>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle v_{j},v_{k}\rangle=\int_{0}^{1}v_{j}v_{k}\,dx
  </annotation>
 </semantics>
</math>

.</p>

<p>Depending on the author, the word "element" in "finite element method" refers either to the triangles in the domain, the piecewise linear basis function, or both. So for instance, an author interested in curved domains might replace the triangles with curved primitives, and so might describe the elements as being curvilinear. On the other hand, some authors replace "piecewise linear" by "piecewise quadratic" or even "piecewise polynomial". The author might then say "higher order element" instead of "higher degree polynomial". Finite element method is not restricted to triangles (or tetrahedra in 3-d, or higher order simplexes in multidimensional spaces), but can be defined on quadrilateral subdomains (hexahedra, prisms, or pyramids in 3-d, and so on). Higher order shapes (curvilinear elements) can be defined with polynomial and even non-polynomial shapes (e.g. ellipse or circle).</p>

<p>Examples of methods that use higher degree piecewise polynomial basis functions are the <a class="uri" href="hp-FEM" title="wikilink">hp-FEM</a> and <a href="spectral_element_method" title="wikilink">spectral FEM</a>.</p>

<p>More advanced implementations (adaptive finite element methods) utilize a method to assess the quality of the results (based on error estimation theory) and modify the mesh during the solution aiming to achieve approximate solution within some bounds from the 'exact' solution of the continuum problem. Mesh adaptivity may utilize various techniques, the most popular are:</p>
<ul>
<li>moving nodes (r-adaptivity)</li>
<li>refining (and unrefining) elements (h-adaptivity)</li>
<li>changing order of base functions (p-adaptivity)</li>
<li>combinations of the above (<a href="hp-FEM" title="wikilink">hp-adaptivity</a>).</li>
</ul>
<h3 id="small-support-of-the-basis">Small support of the basis</h3>

<p>   The primary advantage of this choice of basis is that the inner products</p>

<p>

<math display="block" id="Finite_element_method:99">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mi>j</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>v</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mn>1</mn>
    </msubsup>
    <mrow>
     <msubsup>
      <mi>v</mi>
      <mi>j</mi>
      <mo>′</mo>
     </msubsup>
     <mpadded width="+1.7pt">
      <msubsup>
       <mi>v</mi>
       <mi>k</mi>
       <mo>′</mo>
      </msubsup>
     </mpadded>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>k</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(v_{j},v_{k})=\int_{0}^{1}v_{j}^{\prime}v_{k}^{\prime}\,dx
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="inline" id="Finite_element_method:100">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>,</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>j</ci>
    <ci>k</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j,k
  </annotation>
 </semantics>
</math>

</p>

<p>will be zero for almost all 

<math display="inline" id="Finite_element_method:101">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msub>
    <mi>v</mi>
    <mi>j</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle v_{j},v_{k}\rangle
  </annotation>
 </semantics>
</math>

. (The matrix containing 

<math display="inline" id="Finite_element_method:102">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>j</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>j</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (j,k)
  </annotation>
 </semantics>
</math>

 in the 

<math display="inline" id="Finite_element_method:103">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{k}
  </annotation>
 </semantics>
</math>

 location is known as the <a href="Gramian_matrix" title="wikilink">Gramian matrix</a>.) In the one dimensional case, the <a href="support_(mathematics)" title="wikilink">support</a> of 

<math display="inline" id="Finite_element_method:104">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x_{k-1},x_{k+1}]
  </annotation>
 </semantics>
</math>

 is the interval 

<math display="inline" id="Finite_element_method:105">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msub>
    <mi>v</mi>
    <mi>j</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle v_{j},v_{k}\rangle
  </annotation>
 </semantics>
</math>

. Hence, the integrands of 

<math display="inline" id="Finite_element_method:106">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>j</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>k</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(v_{j},v_{k})
  </annotation>
 </semantics>
</math>

 and <em>

<math display="inline" id="Finite_element_method:107">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>j</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <ci>j</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |j-k|>1
  </annotation>
 </semantics>
</math>

</em> are identically zero whenever 

<math display="inline" id="Finite_element_method:108">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

.</p>

<p>Similarly, in the planar case, if 

<math display="inline" id="Finite_element_method:109">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="block" id="Finite_element_method:110">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∫</mo>
    <mi mathvariant="normal">Ω</mi>
   </msub>
   <mrow>
    <msub>
     <mi>v</mi>
     <mi>j</mi>
    </msub>
    <mpadded width="+1.7pt">
     <msub>
      <mi>v</mi>
      <mi>k</mi>
     </msub>
    </mpadded>
    <mi>d</mi>
    <mi>s</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <int></int>
     <ci>normal-Ω</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>k</ci>
     </apply>
     <ci>d</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\Omega}v_{j}v_{k}\,ds
  </annotation>
 </semantics>
</math>

 do not share an edge of the triangulation, then the integrals</p>

<p>

<math display="block" id="Finite_element_method:111">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∫</mo>
    <mi mathvariant="normal">Ω</mi>
   </msub>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <msub>
      <mi>v</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo>∇</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <msub>
        <mi>v</mi>
        <mi>k</mi>
       </msub>
      </mpadded>
      <mi>d</mi>
      <mi>s</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <int></int>
     <ci>normal-Ω</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <ci>normal-∇</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-∇</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>k</ci>
       </apply>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\Omega}\nabla v_{j}\cdot\nabla v_{k}\,ds
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="inline" id="Finite_element_method:112">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>u</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>v</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>k</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x)=\sum_{k=1}^{n}u_{k}v_{k}(x)
  </annotation>
 </semantics>
</math>

 are both zero.</p>
<h3 id="matrix-form-of-the-problem">Matrix form of the problem</h3>

<p>If we write 

<math display="inline" id="Finite_element_method:113">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>v</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>k</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\sum_{k=1}^{n}f_{k}v_{k}(x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_element_method:114">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>v</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(x)=v_{j}(x)
  </annotation>
 </semantics>
</math>

 then problem (3), taking 

<math display="inline" id="Finite_element_method:115">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1,\dots,n
  </annotation>
 </semantics>
</math>

 for 

<math display="block" id="Finite_element_method:116">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>u</mi>
       <mi>k</mi>
      </msub>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>v</mi>
        <mi>k</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>v</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <msub>
        <mi>v</mi>
        <mi>k</mi>
       </msub>
       <msub>
        <mi>v</mi>
        <mi>j</mi>
       </msub>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>k</ci>
       </apply>
       <ci>ϕ</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>j</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <int></int>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>j</ci>
        </apply>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\sum_{k=1}^{n}u_{k}\phi(v_{k},v_{j})=\sum_{k=1}^{n}f_{k}\int v_{k}v_{j}dx
  </annotation>
 </semantics>
</math>

, becomes</p>

<p>

<math display="inline" id="Finite_element_method:117">
 <semantics>
  <mrow>
   <mrow>
    <mi>j</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1,\dots,n.
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Finite_element_method:118">
 <semantics>
  <mi>𝐮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>

 (4)</p>

<p>If we denote by 

<math display="inline" id="Finite_element_method:119">
 <semantics>
  <mi>𝐟</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐟</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{f}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_element_method:120">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>u</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>u</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>t</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>n</ci>
     </apply>
    </vector>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u_{1},\dots,u_{n})^{t}
  </annotation>
 </semantics>
</math>

 the column vectors 

<math display="inline" id="Finite_element_method:121">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>f</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>f</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>t</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
    </vector>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f_{1},\dots,f_{n})^{t}
  </annotation>
 </semantics>
</math>

 and 

<math display="block" id="Finite_element_method:122">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>L</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=(L_{ij})
  </annotation>
 </semantics>
</math>

, and if we let</p>

<p>

<math display="block" id="Finite_element_method:123">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>M</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=(M_{ij})
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Finite_element_method:124">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>v</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{ij}=\phi(v_{i},v_{j})
  </annotation>
 </semantics>
</math>

 be matrices whose entries are</p>

<p>

<math display="block" id="Finite_element_method:125">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>v</mi>
      <mi>j</mi>
     </msub>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{ij}=\int v_{i}v_{j}dx
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Finite_element_method:126">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>L</mi>
      <mi>𝐮</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>M</mi>
     <mi>𝐟</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>𝐮</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>𝐟</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -L\mathbf{u}=M\mathbf{f}.
  </annotation>
 </semantics>
</math>

 then we may rephrase (4) as</p>

<p>

<math display="inline" id="Finite_element_method:127">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>v</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>k</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\sum_{k=1}^{n}f_{k}v_{k}(x)
  </annotation>
 </semantics>
</math>

 (5)</p>

<p>It is not necessary to assume 

<math display="inline" id="Finite_element_method:128">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

. For a general function 

<math display="inline" id="Finite_element_method:129">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>v</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(x)=v_{j}(x)
  </annotation>
 </semantics>
</math>

, problem (3) with 

<math display="inline" id="Finite_element_method:130">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1,\dots,n
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Finite_element_method:131">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 becomes actually simpler, since no matrix 

<math display="block" id="Finite_element_method:132">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>L</mi>
     <mi>𝐮</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>𝐛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>𝐮</ci>
     </apply>
    </apply>
    <ci>𝐛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -L\mathbf{u}=\mathbf{b}
  </annotation>
 </semantics>
</math>

 is used,</p>

<p>

<math display="inline" id="Finite_element_method:133">
 <semantics>
  <mrow>
   <mi>𝐛</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>t</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐛</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </vector>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{b}=(b_{1},\dots,b_{n})^{t}
  </annotation>
 </semantics>
</math>

, (6) where 

<math display="inline" id="Finite_element_method:134">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mi>f</mi>
     <msub>
      <mi>v</mi>
      <mi>j</mi>
     </msub>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{j}=\int fv_{j}dx
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_element_method:135">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1,\dots,n
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Finite_element_method:136">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

.</p>

<p>As we have discussed before, most of the entries of 

<math display="inline" id="Finite_element_method:137">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_element_method:138">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{k}
  </annotation>
 </semantics>
</math>

 are zero because the basis functions 

<math display="inline" id="Finite_element_method:139">
 <semantics>
  <mi>𝐮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>

 have small support. So we now have to solve a linear system in the unknown 

<math display="inline" id="Finite_element_method:140">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 where most of the entries of the matrix 

<math display="inline" id="Finite_element_method:141">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

, which we need to invert, are zero.</p>

<p>Such matrices are known as <a href="sparse_matrix" title="wikilink">sparse matrices</a>, and there are efficient solvers for such problems (much more efficient than actually inverting the matrix.) In addition, 

<math display="inline" id="Finite_element_method:142">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is symmetric and positive definite, so a technique such as the <a href="conjugate_gradient_method" title="wikilink">conjugate gradient method</a> is favored. For problems that are not too large, sparse <a href="LU_decomposition" title="wikilink">LU decompositions</a> and <a href="Cholesky_decomposition" title="wikilink">Cholesky decompositions</a> still work well. For instance, <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>'s backslash operator (which uses sparse LU, sparse Cholesky, and other factorization methods) can be sufficient for meshes with a hundred thousand vertices.</p>

<p>The matrix 

<math display="inline" id="Finite_element_method:143">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is usually referred to as the <a href="stiffness_matrix" title="wikilink">stiffness matrix</a>, while the matrix 

<math display="inline" id="Finite_element_method:144">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 is dubbed the <a href="mass_matrix" title="wikilink">mass matrix</a>.</p>
<h3 id="general-form-of-the-finite-element-method">General form of the finite element method</h3>

<p>In general, the finite element method is characterized by the following process.</p>
<ul>
<li>One chooses a grid for 

<math display="inline" id="Finite_element_method:145">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>u</mi>
     <mrow>
      <mi>x</mi>
      <mi>x</mi>
      <mi>x</mi>
      <mi>x</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>u</mi>
     <mrow>
      <mi>y</mi>
      <mi>y</mi>
      <mi>y</mi>
      <mi>y</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>y</ci>
       <ci>y</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{xxxx}+u_{yyyy}=f
  </annotation>
 </semantics>
</math>

. In the preceding treatment, the grid consisted of triangles, but one can also use squares or curvilinear polygons.</li>
<li>Then, one chooses basis functions. In our discussion, we used piecewise linear basis functions, but it is also common to use piecewise polynomial basis functions.</li>
</ul>

<p>A separate consideration is the smoothness of the basis functions. For second order <a href="elliptic_boundary_value_problem" title="wikilink">elliptic boundary value problems</a>, piecewise polynomial basis function that are merely continuous suffice (i.e., the derivatives are discontinuous.) For higher order partial differential equations, one must use smoother basis functions. For instance, for a fourth order problem such as 

<math display="inline" id="Finite_element_method:146">
 <semantics>
  <msup>
   <mi>C</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{1}
  </annotation>
 </semantics>
</math>

, one may use piecewise quadratic basis functions that are <a href="Smooth_function#Order_of_continuity" title="wikilink">

<math display="inline" id="Finite_element_method:147">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

</a>.</p>

<p>Another consideration is the relation of the finite-dimensional space 

<math display="inline" id="Finite_element_method:148">
 <semantics>
  <msubsup>
   <mi>H</mi>
   <mn>0</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}^{1}
  </annotation>
 </semantics>
</math>

 to its infinite-dimensional counterpart, in the examples above 

<math display="inline" id="Finite_element_method:149">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

. A <a href="conforming_element_method" title="wikilink">conforming element method</a> is one in which the space 

<math display="inline" id="Finite_element_method:150">
 <semantics>
  <msubsup>
   <mi>H</mi>
   <mn>0</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}^{1}
  </annotation>
 </semantics>
</math>

 is a subspace of the element space for the continuous problem. The example above is such a method. If this condition is not satisfied, we obtain a <a href="nonconforming_element_method" title="wikilink">nonconforming element method</a>, an example of which is the space of piecewise linear functions over the mesh which are continuous at each edge midpoint. Since these functions are in general discontinuous along the edges, this finite-dimensional space is not a subspace of the original 

<math display="inline" id="Finite_element_method:151">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

.</p>

<p>Typically, one has an algorithm for taking a given mesh and subdividing it. If the main method for increasing precision is to subdivide the mesh, one has an <em>h</em>-method (<em>h</em> is customarily the diameter of the largest element in the mesh.) In this manner, if one shows that the error with a grid 

<math display="inline" id="Finite_element_method:152">
 <semantics>
  <mrow>
   <mi>C</mi>
   <msup>
    <mi>h</mi>
    <mi>p</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ch^{p}
  </annotation>
 </semantics>
</math>

 is bounded above by 

<math display="inline" id="Finite_element_method:153">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo><</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>C</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C<\infty
  </annotation>
 </semantics>
</math>

, for some 

<math display="inline" id="Finite_element_method:154">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>p</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p>0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_element_method:155">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

, then one has an order <em>p</em> method. Under certain hypotheses (for instance, if the domain is convex), a piecewise polynomial of order 

<math display="inline" id="Finite_element_method:156">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mrow>
    <mi>d</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <plus></plus>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=d+1
  </annotation>
 </semantics>
</math>

 method will have an error of order 

<math display="inline" id="Finite_element_method:157">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

.</p>

<p>If instead of making <em>h</em> smaller, one increases the degree of the polynomials used in the basis function, one has a <em>p</em>-method. If one combines these two refinement types, one obtains an <em>hp</em>-method (<a class="uri" href="hp-FEM" title="wikilink">hp-FEM</a>). In the hp-FEM, the polynomial degrees can vary from element to element. High order methods with large uniform <em>p</em> are called spectral finite element methods (<a href="spectral_element_method" title="wikilink">SFEM</a>). These are not to be confused with <a href="spectral_method" title="wikilink">spectral methods</a>.</p>

<p>For vector partial differential equations, the basis functions may take values in <span class="LaTeX">$\mathbb{R}^n$</span>.</p>
<h2 id="various-types-of-finite-element-methods">Various types of finite element methods</h2>
<h3 id="aem">AEM</h3>

<p>The Applied Element Method, or AEM combines features of both FEM and <a href="Discrete_element_method" title="wikilink">Discrete element method</a>, or (DEM). </p>
<h3 id="generalized-finite-element-method">Generalized finite element method</h3>

<p>The generalized finite element method (GFEM) uses local spaces consisting of functions, not necessarily polynomials, that reflect the available information on the unknown solution and thus ensure good local approximation. Then a <a href="partition_of_unity" title="wikilink">partition of unity</a> is used to “bond” these spaces together to form the approximating subspace. The effectiveness of GFEM has been shown when applied to problems with domains having complicated boundaries, problems with micro-scales, and problems with boundary layers.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="mixed-finite-element-method">Mixed finite element method</h3>
<h3 id="hp-fem">hp-FEM</h3>

<p>The <a class="uri" href="hp-FEM" title="wikilink">hp-FEM</a> combines adaptively, elements with variable size <em>h</em> and polynomial degree <em>p</em> in order to achieve exceptionally fast, exponential convergence rates.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="hpk-fem">hpk-FEM</h3>

<p>The <a class="uri" href="hpk-FEM" title="wikilink">hpk-FEM</a> combines adaptively, elements with variable size <em>h</em>, polynomial degree of the local approximations <em>p</em> and global differentiability of the local approximations <em>(k-1)</em> in order to achieve best convergence rates.</p>
<h3 id="xfem">XFEM</h3>
<h3 id="s-fem">S-FEM</h3>
<h3 id="fiber-beam-method">Fiber beam method</h3>
<h3 id="spectral-element-method">Spectral element method</h3>
<h3 id="meshfree-methods">Meshfree methods</h3>
<h3 id="discontinuous-galerkin-methods">Discontinuous Galerkin methods</h3>
<h3 id="finite-element-limit-analysis">Finite element limit analysis</h3>
<h3 id="stretched-grid-method">Stretched grid method</h3>
<h2 id="comparison-to-the-finite-difference-method">Comparison to the finite difference method</h2>

<p>The <a href="finite_difference_method" title="wikilink">finite difference method</a> (FDM) is an alternative way of approximating solutions of PDEs. The differences between FEM and FDM are:</p>
<ul>
<li>The most attractive feature of the FEM is its ability to handle complicated geometries (and boundaries) with relative ease. While FDM in its basic form is restricted to handle rectangular shapes and simple alterations thereof, the handling of geometries in FEM is theoretically straightforward.</li>
</ul>
<ul>
<li>The most attractive feature of finite differences is that it can be very easy to implement.</li>
</ul>
<ul>
<li>There are several ways one could consider the FDM a special case of the FEM approach. E.g., first order FEM is identical to FDM for Poisson's equation, if the problem is discretized by a regular rectangular mesh with each rectangle divided into two triangles.</li>
</ul>
<ul>
<li>There are reasons to consider the mathematical foundation of the finite element approximation more sound, for instance, because the quality of the approximation between grid points is poor in FDM.</li>
</ul>
<ul>
<li>The quality of a FEM approximation is often higher than in the corresponding FDM approach, but this is extremely problem-dependent and several examples to the contrary can be provided.</li>
</ul>

<p>Generally, FEM is the method of choice in all types of analysis in structural mechanics (i.e. solving for deformation and stresses in solid bodies or dynamics of structures) while <a href="computational_fluid_dynamics" title="wikilink">computational fluid dynamics</a> (CFD) tends to use FDM or other methods like <a href="finite_volume_method" title="wikilink">finite volume method</a> (FVM). CFD problems usually require discretization of the problem into a large number of cells/gridpoints (millions and more), therefore cost of the solution favors simpler, lower order approximation within each cell. This is especially true for 'external flow' problems, like air flow around the car or airplane, or weather simulation.</p>
<h2 id="application">Application</h2>

<p> A variety of specializations under the umbrella of the mechanical engineering discipline (such as aeronautical, biomechanical, and automotive industries) commonly use integrated FEM in design and development of their products. Several modern FEM packages include specific components such as thermal, electromagnetic, fluid, and structural working environments. In a structural simulation, FEM helps tremendously in producing stiffness and strength visualizations and also in minimizing weight, materials, and costs.</p>

<p>FEM allows detailed visualization of where structures bend or twist, and indicates the distribution of stresses and displacements. FEM software provides a wide range of simulation options for controlling the complexity of both modeling and analysis of a system. Similarly, the desired level of accuracy required and associated computational time requirements can be managed simultaneously to address most engineering applications. FEM allows entire designs to be constructed, refined, and optimized before the design is manufactured.</p>

<p>This powerful design tool has significantly improved both the standard of engineering designs and the methodology of the design process in many industrial applications.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The introduction of FEM has substantially decreased the time to take products from concept to the production line.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> It is primarily through improved initial prototype designs using FEM that testing and development have been accelerated.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> In summary, benefits of FEM include increased accuracy, enhanced design and better insight into critical design parameters, virtual prototyping, fewer hardware prototypes, a faster and less expensive design cycle, increased productivity, and increased revenue.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>FEA has also been proposed to use in stochastic modelling for numerically solving probability models.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Applied_element_method" title="wikilink">Applied element method</a></li>
<li><a href="Boundary_element_method" title="wikilink">Boundary element method</a></li>
<li><a href="Computer_experiment" title="wikilink">Computer experiment</a></li>
<li><a href="Direct_stiffness_method" title="wikilink">Direct stiffness method</a></li>
<li><a href="Discontinuity_layout_optimization" title="wikilink">Discontinuity layout optimization</a></li>
<li><a href="Discrete_element_method" title="wikilink">Discrete element method</a></li>
<li><a href="Finite_element_machine" title="wikilink">Finite element machine</a></li>
<li><a href="Finite_element_method_in_structural_mechanics" title="wikilink">Finite element method in structural mechanics</a></li>
<li><a href="Finite_volume_method_for_unsteady_flow" title="wikilink">Finite volume method for unsteady flow</a></li>
<li><a href="Interval_finite_element" title="wikilink">Interval finite element</a></li>
<li><a href="Isogeometric_analysis" title="wikilink">Isogeometric analysis</a></li>
<li><a href="Lattice_Boltzmann_methods" title="wikilink">Lattice Boltzmann methods</a></li>
<li><a href="List_of_finite_element_software_packages" title="wikilink">List of finite element software packages</a></li>
<li><a href="Movable_cellular_automaton" title="wikilink">Movable cellular automaton</a></li>
<li><a href="Multidisciplinary_design_optimization" title="wikilink">Multidisciplinary design optimization</a></li>
<li><a class="uri" href="Multiphysics" title="wikilink">Multiphysics</a></li>
<li><a href="Patch_test_(finite_elements)" title="wikilink">Patch test</a></li>
<li><a href="Rayleigh–Ritz_method" title="wikilink">Rayleigh–Ritz method</a></li>
<li><a href="Weakened_weak_form" title="wikilink">Weakened weak form</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>G. Allaire and A. Craig: <em>Numerical Analysis and Optimization:An Introduction to Mathematical Modelling and Numerical Simulation</em></li>
<li>K. J. Bathe : <em>Numerical methods in finite element analysis</em>, Prentice-Hall (1976).</li>
<li>J. Chaskalovic, <em>Finite Elements Methods for Engineering Sciences</em>, Springer Verlag, (2008).</li>
<li>O. C. Zienkiewicz, R. L. Taylor, J. Z. Zhu : <em>The Finite Element Method: Its Basis and Fundamentals</em>, Butterworth-Heinemann, (2005).</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://homepage.usask.ca/~ijm451/finite/fe_resources/">IFER</a> Internet Finite Element Resources - Describes and provides access to finite element analysis software via the Internet.</li>
<li><a href="http://ocw.mit.edu/resources/res-2-002-finite-element-procedures-for-solids-and-structures-spring-2010/linear/">MIT Open Course-ware</a> on Linear finite element method (With video lectures)</li>
<li><a href="http://www.nafems.org">NAFEMS</a>—The International Association for the Engineering Analysis Community</li>
<li><a href="http://www.feadomain.com">Finite Element Analysis Resources</a>- Finite Element news, articles and tips</li>
<li><a href="http://www.fieldp.com/femethods.html">Finite-element Methods for Electromagnetics</a> - free 320-page text</li>
<li><a href="http://www.solid.ikp.liu.se/fe/index.html">Finite Element Books</a>- books bibliography</li>
<li><a href="http://math.nist.gov/mcsd/savg/tutorial/ansys/FEM/">Mathematics of the Finite Element Method</a></li>
<li><a href="http://people.maths.ox.ac.uk/suli/fem.pdf">Finite Element Methods for Partial Differential Equations</a> - Lecture notes by <a href="Endre_Süli" title="wikilink">Endre Süli</a></li>
<li><a href="http://www.cvel.clemson.edu/modeling/">Electromagnetic Modeling web site at Clemson University</a> (includes list of currently available software)</li>
</ul>

<p>"</p>

<p><a href="Category:Continuum_mechanics" title="wikilink">Category:Continuum mechanics</a> <a href="Category:Finite_element_method" title="wikilink">Category:Finite element method</a> <a href="Category:Numerical_differential_equations" title="wikilink">Category:Numerical differential equations</a> <a href="Category:Partial_differential_equations" title="wikilink">Category:Partial differential equations</a> <a href="Category:Structural_analysis" title="wikilink">Category:Structural analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">P. Solin, K. Segeth, I. Dolezel: Higher-Order Finite Element Methods, Chapman &amp; Hall/CRC Press, 2003<a href="#fnref12">↩</a></li>
<li id="fn13">Hastings, J. K., Juds, M. A., Brauer, J. R., <em>Accuracy and Economy of Finite Element Magnetic Analysis</em>, 33rd Annual National Relay Conference, April 1985.<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
</ol>
</section>
</body>
</html>
