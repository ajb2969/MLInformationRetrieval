   Embedded pushdown automaton      Embedded pushdown automaton   An embedded pushdown automaton or EPDA is a computational model for parsing languages generated by tree-adjoining grammars (TAGs). It is similar to the context-free grammar -parsing pushdown automaton , except that instead of using a plain stack to store symbols, it has a stack of iterated stacks that store symbols, giving TAGs a generative capacity between context-free grammars and context-sensitive grammars , or a subset of the mildly context-sensitive grammars . Embedded pushdown automata should not be confused with nested stack automata which have more computational power.  History and applications  EPDAs were first described by K. Vijay-Shanker in his 1988 doctoral thesis. 1 They have since been applied to more complete descriptions of classes of mildly context-sensitive grammars and have had important roles in refining the Chomsky hierarchy . Various subgrammars, such as the linear indexed grammar , can thus be defined. 2 EPDAs are also beginning to play an important role in natural language processing.  While natural languages have traditionally been analyzed using context-free grammars (see transformational-generative grammar and computational linguistics ), this model does not work well for languages with crossed dependencies, such as Dutch, situations for which an EPDA is well suited. A detailed linguistic analysis is available in Joshi, Schabes (1997). 3  Theory  An EPDA is a finite state machine with a set of stacks that can be themselves accessed through the embedded stack . Each stack contains elements of the stack alphabet     Γ    normal-Γ   \,\Gamma   , and so we define an element of a stack by      σ   i   ∈   Γ  *        subscript  σ  i    superscript  normal-Γ      \,\sigma_{i}\in\Gamma^{*}   , where the star is the Kleene closure of the alphabet.  Each stack can then be defined in terms of its elements, so we denote the    j    j   \,j   th stack in the automaton using a double-dagger symbol      Υ   j   =  ‡   σ  j   =   {   σ   j  ,  k    ,   σ   j  ,   k  -  1     ,  …  ,   σ   j  ,  1    }      fragments   subscript  normal-Υ  j    normal-‡   subscript  σ  j     fragments  normal-{   subscript  σ   j  k    normal-,   subscript  σ   j    k  1     normal-,  normal-…  normal-,   subscript  σ   j  1    normal-}     \,\Upsilon_{j}=\ddagger\sigma_{j}=\{\sigma_{j,k},\sigma_{j,k-1},\ldots,\sigma_%
 {j,1}\}   , where     σ    j  ,  k      subscript  σ   j  k     \,\sigma_{j,k}   would be the next accessible symbol in the stack. The embedded stack of    m    m   \,m   stacks can thus be denoted by     {   Υ  j   }   =   {  ‡   σ  m   ,  ‡   σ   m  -  1    ,  …  ,  ‡   σ  1   }   ∈    (  ‡   Γ  +   )   *      fragments   fragments  normal-{   subscript  normal-Υ  j   normal-}     fragments  normal-{  normal-‡   subscript  σ  m   normal-,  normal-‡   subscript  σ    m  1    normal-,  normal-…  normal-,  normal-‡   subscript  σ  1   normal-}     superscript   fragments  normal-(  normal-‡   superscript  normal-Γ    normal-)       \,\{\Upsilon_{j}\}=\{\ddagger\sigma_{m},\ddagger\sigma_{m-1},\ldots,\ddagger%
 \sigma_{1}\}\in(\ddagger\Gamma^{+})^{*}   .  We define an EPDA by the septuple (7-tuple)       M   =   (  Q  ,  Σ  ,  Γ  ,  δ  ,   q  0   ,   Q  F   ,   σ  0   )       M   Q  normal-Σ  normal-Γ  δ   subscript  q  0    subscript  Q  F    subscript  σ  0      \,M=(Q,\Sigma,\Gamma,\delta,q_{0},Q_{\textrm{F}},\sigma_{0})   where       Q    Q   \,Q   is a finite set of states ;      Σ    normal-Σ   \,\Sigma   is the finite set of the input alphabet ;      Γ    normal-Γ   \,\Gamma   is the finite stack alphabet ;        q   0   ∈  Q       subscript  q  0   Q    \,q_{0}\in Q   is the start state ;        Q   F   ⊆  Q       subscript  Q  F   Q    \,Q_{\textrm{F}}\subseteq Q   is the set of final states ;        σ   0   ∈  Γ       subscript  σ  0   normal-Γ    \,\sigma_{0}\in\Gamma   is the initial stack symbol       δ   :    Q  ×  Σ  ×  Γ   →  S      normal-:  δ   normal-→    Q  normal-Σ  normal-Γ   S     \,\delta:Q\times\Sigma\times\Gamma\rightarrow S   is the transition function , where    S    S   \,S   are finite subsets of     Q   ×    (  ‡   Γ  +   )   *   ×   Γ  *   ×    (  ‡   Γ  +   )   *      fragments  Q    superscript   fragments  normal-(  normal-‡   superscript  normal-Γ    normal-)       superscript  normal-Γ      superscript   fragments  normal-(  normal-‡   superscript  normal-Γ    normal-)       \,Q\times(\ddagger\Gamma^{+})^{*}\times\Gamma^{*}\times(\ddagger\Gamma^{+})^{*}   .   Thus the transition function takes a state, the next symbol of the input string, and the top symbol of the current stack and generates the next state, the stacks to be pushed and popped onto the embedded stack , the pushing and popping of the current stack, and the stacks to be considered the current stacks in the next transition. More conceptually, the embedded stack is pushed and popped, the current stack is optionally pushed back onto the embedded stack , and any other stacks one would like are pushed on top of that, with the last stack being the one read from in the next iteration. Therefore, stacks can be pushed both above and below the current stack.  A given configuration is defined by       C    (  M  )   =   {  q  ,   Υ  m   …   Υ  1   ,   x  1   ,   x  2   }   ∈  Q  ×    (  ‡   Γ  +   )   *   ×   Σ  *   ×   Σ  *      fragments  C   fragments  normal-(  M  normal-)     fragments  normal-{  q  normal-,   subscript  normal-Υ  m   normal-…   subscript  normal-Υ  1   normal-,   subscript  x  1   normal-,   subscript  x  2   normal-}    Q    superscript   fragments  normal-(  normal-‡   superscript  normal-Γ    normal-)       superscript  normal-Σ      superscript  normal-Σ      \,C(M)=\{q,\Upsilon_{m}\ldots\Upsilon_{1},x_{1},x_{2}\}\in Q\times(\ddagger%
 \Gamma^{+})^{*}\times\Sigma^{*}\times\Sigma^{*}     where    q    q   \,q   is the current state, the    Υ    normal-Υ   \,\Upsilon   s are the stacks in the embedded stack , with     Υ   m     subscript  normal-Υ  m    \,\Upsilon_{m}   the current stack, and for an input string     x   =    x  1    x  2    ∈   Σ  *         x     subscript  x  1    subscript  x  2          superscript  normal-Σ       \,x=x_{1}x_{2}\in\Sigma^{*}   ,     x   1     subscript  x  1    \,x_{1}   is the portion of the string already processed by the machine and     x   2     subscript  x  2    \,x_{2}   is the portion to be processed, with its head being the current symbol read. Note that the empty string     ϵ   ∈  Σ      ϵ  normal-Σ    \,\epsilon\in\Sigma   is implicitly defined as a terminating symbol, where if the machine is at a final state when the empty string is read, the entire input string is accepted , and if not it is rejected . Such accepted strings are elements of the language        L    (  M  )    =   {  x  |    {   q  0   ,   Υ  0   ,  ϵ  ,  x  }    →  M  *    {   q  F   ,    Υ  m   …   Υ  1    ,  x  ,  ϵ  }    }         L  M    conditional-set  x    superscript   subscript  normal-→  M       subscript  q  0    subscript  normal-Υ  0   ϵ  x     subscript  q  F      subscript  normal-Υ  m   normal-…   subscript  normal-Υ  1    x  ϵ       \,L(M)=\left\{x|\{q_{0},\Upsilon_{0},\epsilon,x\}\rightarrow_{M}^{*}\{q_{%
 \textrm{F}},\Upsilon_{m}\ldots\Upsilon_{1},x,\epsilon\}\right\}     where      q   F   ∈   Q  F        subscript  q  F    subscript  Q  F     \,q_{\textrm{F}}\in Q_{\textrm{F}}   and    →  M  *     superscript   subscript  normal-→  M      \,\rightarrow_{M}^{*}   defines the transition function applied over as many times as necessary to parse the string.  An informal description of EPDA can also be found in Joshi, Schabes (1997), 4 Sect.7, p.23-25.  k -order EPDA and the Weir hierarchy  A more precisely defined hierarchy of languages that correspond to the mildly context-sensitive class was defined by David J. Weir. 5 Based on the work of Nabil A. Khabbaz, 6 7 Weir's Control Language Hierarchy is a containment  where the Level-1 is defined as context-free, and Level-2 is the class of tree-adjoining and the other three grammars.  Following are some of the properties of Level- k languages in the hierarchy:   Level- k languages are properly contained in the Level-( k + 1) language class  Level- k languages can be parsed in    O   (   n   3  ⋅   2   k  -  1      )       O   superscript  n   normal-⋅  3   superscript  2    k  1        O(n^{3\cdot 2^{k-1}})   time  Level- k contains the language    {    a  1  n   …   a   2  k   n    |   n  ≥  0   }     conditional-set     superscript   subscript  a  1   n   normal-…   superscript   subscript  a   superscript  2  k    n      n  0     \{a_{1}^{n}\ldots a_{2^{k}}^{n}|n\geq 0\}   , but not    {    a  1  n   …   a   2   k  +  1    n    |   n  ≥  0   }     conditional-set     superscript   subscript  a  1   n   normal-…   superscript   subscript  a   superscript  2    k  1     n      n  0     \{a_{1}^{n}\ldots a_{2^{k+1}}^{n}|n\geq 0\}     Level- k contains the language    {   w   2   k  -  1     |   w  ∈    {  a  ,  b  }   *    }     conditional-set   superscript  w   superscript  2    k  1       w   superscript   a  b        \{w^{2^{k-1}}|w\in\{a,b\}^{*}\}   , but not    {   w    2   k  -  1    +  1    |   w  ∈    {  a  ,  b  }   *    }     conditional-set   superscript  w     superscript  2    k  1    1      w   superscript   a  b        \{w^{2^{k-1}+1}|w\in\{a,b\}^{*}\}      Those properties correspond well (at least for small k > 1) to the conditions of mildly context-sensitive languages imposed by Joshi, and as k gets bigger, the language class becomes, in a sense, less mildly context-sensitive.  See also   combinatory categorial grammar   References  Further reading     "  Category:Models of computation  Category:Automata theory     ↩  ↩  ↩   ↩  ↩  ↩     