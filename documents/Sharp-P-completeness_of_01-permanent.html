<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1791">Sharp-P-completeness of 01-permanent</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sharp-P-completeness of 01-permanent</h1>
<hr/>

<p>The <strong>#P-completeness of 01-permanent</strong>, sometimes known as <strong>Valiant's theorem</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is a <a href="mathematical_proof" title="wikilink">mathematical proof</a> about the <a class="uri" href="permanent" title="wikilink">permanent</a> of <a href="matrix_(mathematics)" title="wikilink">matrices</a>, considered a seminal result in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In a 1979 <a href="scholarly_paper" title="wikilink">scholarly paper</a>, <a href="Leslie_Valiant" title="wikilink">Leslie Valiant</a> proved<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> that the <a href="computational_problem" title="wikilink">computational problem</a> of computing the permanent of a matrix is <a href="Sharp-P-complete" title="wikilink">#P-hard</a>, even if the matrix is restricted to have entries that are all 0 or 1. In this restricted case, computing the <a class="uri" href="permanent" title="wikilink">permanent</a> is even <a href="Sharp-P-complete" title="wikilink">#P-complete</a>, because it corresponds to the <a href="Sharp-P" title="wikilink">#P problem</a> of counting the number of permutation matrices one can get by changing ones into zeroes.</p>

<p>Valiant's 1979 paper also introduced <a href="Sharp-P" title="wikilink">#P</a> as a <a href="complexity_class" title="wikilink">complexity class</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="significance">Significance</h2>

<p>One reason for interest in the computational complexity of the permanent is that it provides an example of a problem where constructing a single solution can be done efficiently but where counting all solutions is hard.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> As Papadimitriou writes in his book <em>Computational Complexity</em>: <mtpl></mtpl> Specifically, <a href="Computation_of_the_permanent_of_a_matrix" title="wikilink">computing the permanent</a> (shown to be difficult by Valiant's results) is closely connected with finding a <a href="perfect_matching" title="wikilink">perfect matching</a> in a <a href="bipartite_graph" title="wikilink">bipartite graph</a>, which is solvable in polynomial time by the <a href="Hopcroft–Karp_algorithm" title="wikilink">Hopcroft–Karp algorithm</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> For a bipartite graph with <em>2n</em> vertices partitioned into two parts with <em>n</em> vertices each, the number of perfect matchings equals the permanent of its <a href="biadjacency_matrix" title="wikilink">biadjacency matrix</a> and the square of the number of perfect matchings is equal to the permanent of its <a href="adjacency_matrix" title="wikilink">adjacency matrix</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Since any 0–1 matrix is the biadjacency matrix of some bipartite graph, Valiant's theorem implies<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> that the problem of counting the number of perfect matchings in a bipartite graph is <a href="Sharp-P-complete" title="wikilink">#P-complete</a>, and in conjunction with <a href="Toda's_theorem" title="wikilink">Toda's theorem</a> this implies that it is hard for the entire <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>The computational complexity of the permanent also has some significance in other aspects of complexity theory: it is not known whether <a href="NC_(complexity)" title="wikilink">NC</a> equals P (informally, whether every polynomially-solvable problem can be solved by a polylogarithmic-time <a href="parallel_algorithm" title="wikilink">parallel algorithm</a>) and <a href="Ketan_Mulmuley" title="wikilink">Ketan Mulmuley</a> has suggested an approach to resolving this question that relies on writing the permanent as the determinant of a matrix.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Hartmann <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> proved a generalization of Valiant's theorem concerning the complexity of computing <a href="immanant_of_a_matrix" title="wikilink">immanants of matrices</a> that generalize both the determinant and the permanent.</p>
<h2 id="ben-dor-and-halevis-proof">Ben-Dor and Halevi's proof</h2>

<p>Below, the proof that computing the permanent of a 01-matrix is <a href="Sharp-P-complete" title="wikilink">#P-complete</a> is described. It mainly follows the proof by .<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h3 id="overview">Overview</h3>

<p>Any square matrix 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:0">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=(a_{ij})
  </annotation>
 </semantics>
</math>

 can be viewed as the <a href="adjacency_matrix" title="wikilink">adjacency matrix</a> of a directed graph, with 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:1">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{ij}
  </annotation>
 </semantics>
</math>

 representing the weight of the edge from vertex <em>i</em> to vertex <em>j</em>. Then, the permanent of A is equal to the sum of the weights of all cycle-covers of the graph; this is a <a href="Permanent#Cycle_covers" title="wikilink">graph-theoretic interpretation of the permanent</a>.</p>

<p><a href="Sharp-SAT" title="wikilink">#SAT</a>, a <a href="function_problem" title="wikilink">function problem</a> related to the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a>, is the problem of counting the number of satisfying assignments of a given Boolean formula. It is a <a href="Sharp-P-complete" title="wikilink">#P-complete</a> problem (by definition), as any NP machine can be encoded into a Boolean formula by a process similar to that in <a href="Cook's_theorem" title="wikilink">Cook's theorem</a>, such that the number of satisfying assignments of the Boolean formula is equal to the number of accepting paths of the NP machine. Any formula in SAT <a href="3SAT" title="wikilink">can be rewritten</a> as a formula in 3-<a href="conjunctive_normal_form" title="wikilink">CNF</a> form preserving the number of satisfying assignments, and so #SAT and #3SAT are equivalent and #3SAT is <a href="Sharp-P-complete" title="wikilink">#P-complete</a> as well.</p>

<p>In order to prove that 01-Permanent is <a href="Sharp-P-complete" title="wikilink">#P-hard</a>, it is therefore sufficient to show that the number of satisfying assignments for a 3-CNF formula can be expressed succinctly as a function of the permanent of a matrix that contains only the values 0 and 1. This is usually accomplished in two steps:</p>
<ol>
<li>Given a 3-CNF formula φ, construct a directed integer-weighted graph 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:2">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

, such that the sum of the weights of cycle covers of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:3">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

 (or equivalently, the permanent of its adjacency matrix) is equal to the number of satisfying assignments of φ. This establishes that Permanent is #P-hard.</li>
<li>Through a series of reductions, reduce Permanent to 01-Permanent, the problem of computing the permanent of a matrix all entries 0 or 1. This establishes that 01-permanent is #P-hard as well.</li>
</ol>
<h3 id="constructing-the-integer-graph">Constructing the integer graph</h3>

<p>Given a 3CNF-formula 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:4">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 with <em>m</em> clauses and <em>n</em> variables, one can construct a weighted, directed graph 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:5">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

 such that</p>
<ol>
<li>each satisfying assignment for 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:6">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 will have a corresponding set of cycle covers in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:7">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

 where the sum of the weights of cycle covers in this set will be 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:8">
 <semantics>
  <msup>
   <mn>12</mn>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">12</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   12^{m}
  </annotation>
 </semantics>
</math>

 ; and</li>
<li>all other cycle covers in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:9">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

 will have weights summing to 0.</li>
</ol>

<p>Thus if 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:10">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">#</mi>
    <mi>ϕ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-#</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\#\phi)
  </annotation>
 </semantics>
</math>

 is the number of satisfying assignments for 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:11">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

, the permanent of this graph will be 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:12">
 <semantics>
  <mrow>
   <msup>
    <mn>12</mn>
    <mi>m</mi>
   </msup>
   <mo>⋅</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">#</mi>
     <mi>ϕ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">12</cn>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-#</ci>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   12^{m}\cdot(\#\phi)
  </annotation>
 </semantics>
</math>

. (Valiant's original proof constructs a graph with entries in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:13">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <cn type="integer">3</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{-1,0,1,2,3\}
  </annotation>
 </semantics>
</math>

 whose permanent is 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:14">
 <semantics>
  <mrow>
   <msup>
    <mn>4</mn>
    <mrow>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ϕ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>⋅</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">#</mi>
     <mi>ϕ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">4</cn>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>ϕ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>normal-#</ci>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4^{t(\phi)}\cdot(\#\phi)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:15">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(\phi)
  </annotation>
 </semantics>
</math>

 is "twice the number of occurrences of literals in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:16">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

" – 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:17">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

.)</p>

<p>The graph construction makes use of a component that is treated as a "black box." To keep the explanation simple, the properties of this component are given without actually defining the structure of the component.</p>

<p>To specify <em>G</em><sub><em>φ</em></sub>, one first constructs a variable node in <em>G</em><sub><em>φ</em></sub> for each of the <em>n</em> variables in <em>φ</em>. Additionally, for each of the <em>m</em> clauses in <em>φ</em>, one constructs a clause component <em>C</em><sub><em>j</em></sub> in <em>G</em><sub><em>φ</em></sub> that functions as a sort of "black box." All that needs to be noted about <em>C</em><sub><em>j</em></sub> is that it has three input edges and three output edges. The input edges come either from variable nodes or from previous clause components (e.g., <em>C</em><sub><em>o</em></sub> for some <em>o</em> <em>o</em> for some 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:18">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mo>></mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>o</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o>j
  </annotation>
 </semantics>
</math>

). The first input and output edges correspond with the first variable of the clause <em>j</em>, and so on. Thus far, all of the nodes that will appear in the graph <em>G</em><sub><em>φ</em></sub> have been specified.</p>

<p>Next, one would consider the edges. For each variable 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:19">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:20">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

, one makes a true cycle (T-cycle) and a false cycle (F-cycle) in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:21">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

. To create the T-cycle, one starts at the variable node for 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:22">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 and draw an edge to the clause component 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:23">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}
  </annotation>
 </semantics>
</math>

 that corresponds to the first clause in which 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:24">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 appears. If 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:25">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 is the first variable in the clause of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:26">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 corresponding to 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:27">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}
  </annotation>
 </semantics>
</math>

, this edge will be the first input edge of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:28">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}
  </annotation>
 </semantics>
</math>

, and so on. Thence, draw an edge to the next clause component corresponding to the next clause of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:29">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 in which 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:30">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 appears, connecting it from the appropriate output edge of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:31">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}
  </annotation>
 </semantics>
</math>

 to the appropriate input edge of the next clause component, and so on. After the last clause in which 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:32">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 appears, we connect the appropriate output edge of the corresponding clause component back to 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:33">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

's variable node. Of course, this completes the cycle. To create the F-cycle, one would follow the same procedure, but connect 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:34">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

's variable node to those clause components in which ~

<math display="inline" id="Sharp-P-completeness_of_01-permanent:35">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 appears, and finally back to 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:36">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

's variable node. All of these edges outside the clause components are termed <em>external edges</em>, all of which have weight 1. Inside the clause components, the edges are termed <em>internal edges</em>. Every external edge is part of a T-cycle or an F-cycle (but not both—that would force inconsistency).</p>

<p>Note that the graph 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:37">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

 is of size linear in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:38">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>ϕ</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi|
  </annotation>
 </semantics>
</math>

, so the construction can be done in polytime (assuming that the clause components do not cause trouble).</p>
<h4 id="notable-properties-of-the-graph">Notable properties of the graph</h4>

<p>A useful property of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:39">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

 is that its cycle covers correspond to variable assignments for 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:40">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

. For a cycle cover <strong>Z</strong> of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:41">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

, one can say that <strong>Z</strong> induces an assignment of values for the variables in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:42">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 just in case <strong>Z</strong> contains all of the external edges in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:43">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

's T-cycle and none of the external edges in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:44">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

's F-cycle for all variables 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:45">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 that the assignment makes true, and vice versa for all variables 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:46">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 that the assignment makes false. Although any given cycle cover <strong>Z</strong> need not induce an assignment for 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:47">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

, any one that does induces exactly one assignment, and the same assignment induced depends only on the external edges of <strong>Z</strong>. The term <strong>Z</strong> is considered an incomplete cycle cover at this stage, because one talks only about its external edges, M. In the section below, one considers M-completions to show that one has a set of cycle covers corresponding to each M that have the necessary properties.</p>

<p>The sort of <strong>Z</strong>'s that don't induce assignments are the ones with cycles that "jump" inside the clause components. That is, if for every 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:48">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}
  </annotation>
 </semantics>
</math>

, at least one of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:49">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}
  </annotation>
 </semantics>
</math>

's input edges is in <strong>Z</strong>, and every output edge of the clause components is in <strong>Z</strong> when the corresponding input edge is in <strong>Z</strong>, then <strong>Z</strong> is proper with respect to each clause component, and <strong>Z</strong> will produce a satisfying assignment for 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:50">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

. This is because proper <strong>Z</strong>'s contain either the complete T-cycle or the complete F-cycle of every variable 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:51">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:52">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 as well as each including edges going into and coming out of each clause component. Thus, these <strong>Z</strong>'s assign either true or false (but never both) to each 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:53">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 and ensure that each clause is satisfied. Further, the sets of cycle covers corresponding to all such <strong>Z</strong>'s have weight 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:54">
 <semantics>
  <msup>
   <mn>12</mn>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">12</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   12^{m}
  </annotation>
 </semantics>
</math>

, and any other <strong>Z</strong>'s have weight 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:55">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

. The reasons for this depend on the construction of the clause components, and are outlined below.</p>
<h4 id="the-clause-component">The clause component</h4>

<p>To understand the relevant properties of the clause components 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:56">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}
  </annotation>
 </semantics>
</math>

, one needs the notion of an M-completion. A cycle cover <strong>Z</strong> induces a satisfying assignment just in case its external edges satisfy certain properties. For any cycle cover of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:57">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

, consider only its external edges, the subset M. Let M be a set of external edges. A set of internal edges L is an M-completion just in case 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:58">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>∪</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>M</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\cup L
  </annotation>
 </semantics>
</math>

 is a cycle cover of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:59">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

. Further, denote the set of all M-completions by 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:60">
 <semantics>
  <msup>
   <mi>L</mi>
   <mi>M</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{M}
  </annotation>
 </semantics>
</math>

 and the set of all resulting cycle covers of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:61">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:62">
 <semantics>
  <msup>
   <mi>Z</mi>
   <mi>M</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Z</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{M}
  </annotation>
 </semantics>
</math>

.</p>

<p>Recall that construction of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:63">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

 was such that each external edge had weight 1, so the weight of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:64">
 <semantics>
  <msup>
   <mi>Z</mi>
   <mi>M</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Z</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{M}
  </annotation>
 </semantics>
</math>

, the cycle covers resulting from any M, depends only on the internal edges involved. We add here the premise that the construction of the clause components is such that the sum over possible M-completions of the weight of the internal edges in each clause component, where M is proper relative to the clause component, is 12. Otherwise the weight of the internal edges is 0. Since there are <em>m</em> clause components, and the selection of sets of internal edges, L, within each clause component is independent of the selection of sets of internal edges in other clause components, so one can multiply everything to get the weight of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:65">
 <semantics>
  <msup>
   <mi>Z</mi>
   <mi>M</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Z</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{M}
  </annotation>
 </semantics>
</math>

. So, the weight of each 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:66">
 <semantics>
  <msup>
   <mi>Z</mi>
   <mi>M</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Z</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{M}
  </annotation>
 </semantics>
</math>

, where M induces a satisfying assignment, is 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:67">
 <semantics>
  <msup>
   <mn>12</mn>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">12</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   12^{m}
  </annotation>
 </semantics>
</math>

. Further, where M does not induce a satisfying assignment, M is not proper with respect to some 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:68">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}
  </annotation>
 </semantics>
</math>

, so the product of the weights of internal edges in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:69">
 <semantics>
  <msup>
   <mi>Z</mi>
   <mi>M</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Z</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{M}
  </annotation>
 </semantics>
</math>

 will be 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:70">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

.</p>

<p>The clause component is a weighted, directed graph with 7 nodes with edges weighted and nodes arranged to yield the properties specified above, and is given in Appendix A of Ben-Dor and Halevi (1993). Note that the internal edges here have weights drawn from the set 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:71">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <cn type="integer">3</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{-1,0,1,2,3\}
  </annotation>
 </semantics>
</math>

; not all edges have 0–1 weights.</p>

<p>Finally, since the sum of weights of all the sets of cycle covers inducing any particular satisfying assignment is 12<sup><em>m</em></sup>, and the sum of weights of all other sets of cycle covers is 0, one has Perm(<em>G</em><sub><em>φ</em></sub>) = 12<sup><em>m</em></sup>·(<em>#φ</em>). The following section reduces computing Perm(

<math display="inline" id="Sharp-P-completeness_of_01-permanent:72">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>ϕ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\phi}
  </annotation>
 </semantics>
</math>

) to the permanent of a 01 matrix.</p>
<h3 id="matrix">01-Matrix</h3>

<p>The above section has shown that Permanent is #P-hard. Through a series of reductions, any permanent can be reduced to the permanent of a matrix with entries only 0 or 1. This will prove that 01-Permanent is #P-hard as well.</p>
<h4 id="reduction-to-a-non-negative-matrix">Reduction to a non-negative matrix</h4>

<p>Using <a href="modular_arithmetic" title="wikilink">modular arithmetic</a>, convert an integer matrix <em>A</em> into an equivalent non-negative matrix 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:73">
 <semantics>
  <msup>
   <mi>A</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}
  </annotation>
 </semantics>
</math>

 so that the permanent of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:74">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 can be computed easily from the permanent of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:75">
 <semantics>
  <msup>
   <mi>A</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}
  </annotation>
 </semantics>
</math>

, as follows:</p>

<p>Let 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:76">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 be an 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:77">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 integer matrix where no entry has a magnitude larger than 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:78">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

.</p>
<ul>
<li>Compute 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:79">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mi>n</mi>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <msup>
      <mi>μ</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <factorial></factorial>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>μ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=2n!\cdot\mu^{n}+1
  </annotation>
 </semantics>
</math>

. The choice of Q is due to the fact that 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:80">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo>Perm</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
    <mo>⋅</mo>
    <msup>
     <mi>μ</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <ci>Perm</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <factorial></factorial>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>μ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\operatorname{Perm}(A)|\leq n!\cdot\mu^{n}
  </annotation>
 </semantics>
</math>

</li>
<li>Compute 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:81">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>A</mi>
    </mpadded>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <ci>A</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}=A\,\bmod\,Q
  </annotation>
 </semantics>
</math>

</li>
<li>Compute 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:82">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>Perm</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>A</mi>
       <mo>′</mo>
      </msup>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <ci>Perm</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\operatorname{Perm}(A^{\prime})\,\bmod\,Q
  </annotation>
 </semantics>
</math>

</li>
<li>If 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:83">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo><</mo>
   <mrow>
    <mi>Q</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>P</ci>
    <apply>
     <divide></divide>
     <ci>Q</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P<Q/2
  </annotation>
 </semantics>
</math>

 then Perm(<em>A</em>) = <em>P</em>. Otherwise 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:84">
 <semantics>
  <mrow>
   <mrow>
    <mo>Perm</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mo>-</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Perm</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>P</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Perm}(A)=P-Q
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The transformation of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:85">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:86">
 <semantics>
  <msup>
   <mi>A</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}
  </annotation>
 </semantics>
</math>

 is polynomial in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:87">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:88">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>μ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>μ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log(\mu)
  </annotation>
 </semantics>
</math>

, since the number of bits required to represent 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:89">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is polynomial in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:90">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:91">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>μ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>μ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log(\mu)
  </annotation>
 </semantics>
</math>

</p>

<p>An example of the transformation and why it works is given below.</p>

<p>

<math display="block" id="Sharp-P-completeness_of_01-permanent:92">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\begin{bmatrix}2&-2\\
-2&1\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Sharp-P-completeness_of_01-permanent:93">
 <semantics>
  <mrow>
   <mrow>
    <mo>Perm</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <mn>1</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>6</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>Perm</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">6</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Perm}(A)=2\cdot 1+(-2)\cdot(-2)=6
  </annotation>
 </semantics>
</math>

.</p>

<p>Here, 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:94">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=2
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:95">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>μ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu=2
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:96">
 <semantics>
  <mrow>
   <msup>
    <mi>μ</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>μ</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{n}=4
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:97">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mn>17</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <cn type="integer">17</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=17
  </annotation>
 </semantics>
</math>

. Thus</p>

<p>

<math display="block" id="Sharp-P-completeness_of_01-permanent:98">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>A</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>A</mi>
     </mpadded>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mn>17</mn>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>2</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>15</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>15</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <ci>A</ci>
      <cn type="float">17</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <cn type="integer">2</cn>
       <cn type="integer">15</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">15</cn>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}=A\,\bmod\,17=\begin{bmatrix}2&15\\
15&1\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>Note how the elements are non-negative because of the modular arithmetic. It is simple to compute the permanent</p>

<p>

<math display="block" id="Sharp-P-completeness_of_01-permanent:99">
 <semantics>
  <mrow>
   <mrow>
    <mo>Perm</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>A</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <mn>1</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>15</mn>
     <mo>⋅</mo>
     <mn>15</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>227</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>Perm</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">15</cn>
       <cn type="integer">15</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">227</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Perm}(A^{\prime})=2\cdot 1+15\cdot 15=227
  </annotation>
 </semantics>
</math>

</p>

<p>so 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:100">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>227</mn>
    </mpadded>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mn>17</mn>
   </mrow>
   <mo>=</mo>
   <mn>6</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>P</ci>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <cn type="integer">227</cn>
      <cn type="float">17</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">6</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=227\,\bmod\,17=6
  </annotation>
 </semantics>
</math>

. Then 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:101">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo><</mo>
   <mrow>
    <mi>Q</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>P</ci>
    <apply>
     <divide></divide>
     <ci>Q</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P<Q/2
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:102">
 <semantics>
  <mrow>
   <mrow>
    <mo>Perm</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mo>=</mo>
   <mn>6.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>Perm</ci>
      <ci>A</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">6.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Perm}(A)=P=6.
  </annotation>
 </semantics>
</math>

</p>
<h4 id="reduction-to-powers-of-2">Reduction to powers of 2</h4>
<figure><b>(Figure)</b>
<figcaption>Figure 1: Construction of 2Power from NonNeg</figcaption>
</figure>

<p>Note that any number can be <a href="Binary_numeral_system" title="wikilink">decomposed into a sum of powers of 2</a>. For example,</p>

<p>

<math display="block" id="Sharp-P-completeness_of_01-permanent:103">
 <semantics>
  <mrow>
   <mn>13</mn>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mn>2</mn>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mn>2</mn>
     <mn>0</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">13</cn>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   13=2^{3}+2^{2}+2^{0}
  </annotation>
 </semantics>
</math>

</p>

<p>This fact is used to convert a non-negative matrix into an equivalent matrix whose entries are all powers of 2. The reduction can be expressed in terms of graphs equivalent to the matrices.</p>

<p>Let 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:104">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 be a 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:105">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-node weighted directed graph with non-negative weights, where largest weight is 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:106">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

. Every edge 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:107">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 with weight 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:108">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 is converted into an equivalent edge with weights in powers of 2 as follows:</p>

<p>

<math display="block" id="Sharp-P-completeness_of_01-permanent:109">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </msup>
    <mo>+</mo>
    <msup>
     <mn>2</mn>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
    </msup>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msup>
     <mn>2</mn>
     <msub>
      <mi>x</mi>
      <mi>r</mi>
     </msub>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=2^{x_{1}}+2^{x_{2}}+\cdots+2^{x_{r}}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:110">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>≤</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mi>r</mi>
   </msub>
   <mo>≤</mo>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <log></log>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq x_{1}\leq x_{2}\leq\cdots\leq x_{r}\leq\log(w)
  </annotation>
 </semantics>
</math>

</p>

<p>This can be seen graphically in the Figure 1. The subgraph that replaces the existing edge contains 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:111">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 nodes and 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:112">
 <semantics>
  <mrow>
   <mn>3</mn>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">3</cn>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3r
  </annotation>
 </semantics>
</math>

 edges.</p>

<p>To prove that this produces an equivalent graph 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:113">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

 that has the same permanent as the original, one must show the correspondence between the cycle covers of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:114">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:115">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>Consider some cycle-cover 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:116">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:117">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>
<ul>
<li>If an edge 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:118">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is not in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:119">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, then to cover all the nodes in the new sub graph, one must use the self-loops. Since all self-loops have a weight of 1, the weight of cycle-covers in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:120">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:121">
 <semantics>
  <msup>
   <mi>R</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{\prime}
  </annotation>
 </semantics>
</math>

 match.</li>
<li>If 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:122">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:123">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, then in all the corresponding cycle-covers in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:124">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

, there must be a path from 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:125">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:126">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, where <em>u</em> and <em>v</em> are the nodes of edge <em>e</em>. From the construction, one can see that there are 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:127">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 different paths and sum of all these paths equal to the weight of the edge in the original graph 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:128">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. So the weight of corresponding cycle-covers in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:129">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:130">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

 match.</li>
</ul>

<p>Note that the size of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:131">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

 is polynomial in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:132">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:133">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log W
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="reduction-to-01">Reduction to 0–1</h4>
<figure><b>(Figure)</b>
<figcaption>Figure 2: Construction of a 01-matrix from 2Power</figcaption>
</figure>

<p>The objective here is to reduce a matrix whose entries are powers of 2 into an equivalent matrix containing only zeros and ones (i.e. a directed graph where each edge has a weight of 1).</p>

<p>Let G be a 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:134">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-node directed graph where all the weights on edges are powers of two. Construct a graph, 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:135">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

, where the weight of each edge is 1 and Perm(G) = Perm(G'). The size of this new graph, G', is polynomial in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:136">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:137">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 where the maximal weight of any edge in graph G is 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:138">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>p</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{p}
  </annotation>
 </semantics>
</math>

.</p>

<p>This reduction is done locally at each edge in G that has a weight larger than 1. Let 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:139">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=(u,v)
  </annotation>
 </semantics>
</math>

 be an edge in G with a weight 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:140">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mi>r</mi>
   </msup>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=2^{r}>1
  </annotation>
 </semantics>
</math>

. It is replaced by a subgraph 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:141">
 <semantics>
  <msub>
   <mi>J</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>J</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{e}
  </annotation>
 </semantics>
</math>

 that is made up of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:142">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2r
  </annotation>
 </semantics>
</math>

 nodes and 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:143">
 <semantics>
  <mrow>
   <mn>6</mn>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">6</cn>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   6r
  </annotation>
 </semantics>
</math>

 edges as seen in Figure 2. Each edge in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:144">
 <semantics>
  <msub>
   <mi>J</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>J</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{e}
  </annotation>
 </semantics>
</math>

 has a weight of 1. Thus, the resulting graph G' contains only edges with a weight of 1.</p>

<p>Consider some cycle-cover 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:145">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:146">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>
<ul>
<li>If an original edge 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:147">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 from graph G is not in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:148">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, one cannot create a path through the new subgraph 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:149">
 <semantics>
  <msub>
   <mi>J</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>J</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{e}
  </annotation>
 </semantics>
</math>

. The only way to form a cycle cover over 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:150">
 <semantics>
  <msub>
   <mi>J</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>J</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{e}
  </annotation>
 </semantics>
</math>

 in such a case is for each node in the subgraph to take its self-loop. As each edge has a weight of one, the weight of the resulting cycle cover is equal to that of the original cycle cover.</li>
<li>However, if the edge in G is a part of the cycle cover then in any cycle cover of 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:151">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

 there must be a path from 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:152">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:153">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 in the subgraph. At each step down the subgraph there are two choices one can make to form such a path. One must make this choice 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:154">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 times, resulting in 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:155">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>r</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{r}
  </annotation>
 </semantics>
</math>

 possible paths from 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:156">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:157">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

. Thus, there are 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:158">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>r</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{r}
  </annotation>
 </semantics>
</math>

 possible cycle covers and since each path has a weight of 1, the sum of the weights of all these cycle covers equals the weight of the original cycle cover.</li>
</ul>
<h2 id="aaronsons-proof">Aaronson's proof</h2>

<p>Quantum computer scientist Scott Aaronson<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> has proved #P-hardness of permanent using quantum methods.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Computational_problems" title="wikilink">Category:Computational problems</a> <a class="uri" href="Category:Combinatorics" title="wikilink">Category:Combinatorics</a> <a href="Category:Article_proofs" title="wikilink">Category:Article proofs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Christos_Papadimitriou" title="wikilink">Christos H. Papadimitriou</a>. <em>Computational Complexity.</em> <a class="uri" href="Addison-Wesley" title="wikilink">Addison-Wesley</a>, 1994. ISBN 0-201-53082-1. Page 443<a href="#fnref1">↩</a></li>
<li id="fn2">Allen Kent, James G. Williams, Rosalind Kent and Carolyn M. Hall (editors). [<a class="uri" href="http://books.google.com/books?id=uDegDR4ikTQC&amp;pg">http://books.google.com/books?id=uDegDR4ikTQC&amp;pg;</a>;=PA34&amp;dq;=%22permanent+of+a+matrix%22+valiant&amp;lr;=&amp;as;_brr=3&amp;ei;=M8NKSa7LH4G4M8mVyNoI <em>Encyclopedia of microcomputers</em>.]<a href="Marcel_Dekker" title="wikilink">Marcel Dekker</a>, 1999. ISBN 978-0-8247-2722-2; p. 34<a href="#fnref2">↩</a></li>
<li id="fn3">Jin-Yi Cai, A. Pavan and D. Sivakumar, [<a class="uri" href="http://books.google.com/books?id=fIAMFv4doooC&amp;pg">http://books.google.com/books?id=fIAMFv4doooC&amp;pg;</a>;=PA90&amp;dq;=%22permanent+of+a+matrix%22+valiant&amp;as;_brr=3&amp;ei;=h8BKScClJYOUMtTP6LEO <em>On the Hardness of Permanent.</em>] In: STACS, '99: 16th Annual Symposium on Theoretical Aspects of Computer Science, Trier, Germany, March 4–6, 1999 Proceedings. pp. 90–99. <a class="uri" href="Springer-Verlag" title="wikilink">Springer-Verlag</a>, New York, LLC Pub. Date: October 2007. ISBN 978-3-540-65691-3; p. 90.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="Lance_Fortnow" title="wikilink">Lance Fortnow</a>. [<a class="uri" href="http://books.google.com/books?id=JWOA9M9CcX8C&amp;pg">http://books.google.com/books?id=JWOA9M9CcX8C&amp;pg;</a>;=PA265&amp;dq;=permanent+Valiant <em>My Favorite Ten Complexity Theorems of the Past Decade.</em>] Foundations of Software Technology and Theoretical Computer Science: Proceedings of the 14th Conference, Madras, India, December 15–17, 1994. P. S. Thiagarajan (editor), pp. 256–275, <a class="uri" href="Springer-Verlag" title="wikilink">Springer-Verlag</a>, New York, 2007. ISBN 978-3-540-58715-6; p. 265<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="John_Hopcroft" title="wikilink">John E. Hopcroft</a>, <a href="Richard_Karp" title="wikilink">Richard M. Karp</a>: <em>An 

<math display="inline" id="Sharp-P-completeness_of_01-permanent:159">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mn>5</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <divide></divide>
     <cn type="integer">5</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{5/2}
  </annotation>
 </semantics>
</math>

 Algorithm for Maximum Matchings in Bipartite Graphs.</em> SIAM J. Comput. 2(4), 225–231 (1973)<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="Dexter_Kozen" title="wikilink">Dexter Kozen</a>. [<a class="uri" href="http://books.google.com/books?id=L_AMnf9UF9QC&amp;pg">http://books.google.com/books?id=L_AMnf9UF9QC&amp;pg;</a>;=PA141&amp;dq;=%22permanent+of+a+matrix%22+valiant&amp;as;_brr=3&amp;ei;=h8BKScClJYOUMtTP6LEO#PPA142,M1 <em>The Design and Analysis of Algorithms.</em>] <a class="uri" href="Springer-Verlag" title="wikilink">Springer-Verlag</a>, New York, 1991. ISBN 978-0-387-97687-7; pp. 141–142<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="Seinosuke_Toda" title="wikilink">Seinosuke Toda</a>. [<a class="uri" href="http://siamdl.aip.org/getabs/servlet/GetabsServlet?prog=normal&amp;id">http://siamdl.aip.org/getabs/servlet/GetabsServlet?prog=normal&amp;id;</a>;=SMJCAT000020000005000865000001&amp;idtype;=cvips&amp;gifs;=Yes PP is as Hard as the Polynomial-Time Hierarchy.] <a href="SIAM_Journal_on_Computing" title="wikilink">SIAM Journal on Computing</a>, Volume 20 (1991), Issue 5, pp. 865–877.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="http://sigact.acm.org/prizes/godel/1998.html">1998 Gödel Prize. Seinosuke Toda</a><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="Ketan_Mulmuley" title="wikilink">Ketan Mulmuley</a>. <a href="http://dx.doi.org/10.1137/S0097539794282930">Lower Bounds in a Parallel Model without Bit Operations.</a> <a href="SIAM_Journal_on_Computing" title="wikilink">SIAM Journal on Computing</a>, Volume 28 (1999), Issue 4, pp. 1460–1509.<a href="#fnref13">↩</a></li>
<li id="fn14">W. Hartmann. <a href="http://www.informaworld.com/smpp/content~content=a778402740~db=all">On the complexity of immanants.</a> Linear and Multilinear Algebra 18 (1985), no. 2, pp. 127–140.<a href="#fnref14">↩</a></li>
<li id="fn15">.<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="Scott_Aaronson" title="wikilink">S. Aaronson</a>, <a href="http://eccc.hpi-web.de/report/2011/043/download">A Linear-Optical Proof that the Permanent is #P-Hard</a><a href="#fnref16">↩</a></li>
</ol>
</section>
</body>
</html>
