<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="405">Backpropagation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Backpropagation</h1>
<hr/>

<p><strong>Backpropagation</strong>, an abbreviation for "backward propagation of errors", is a common method of training <a href="artificial_neural_networks" title="wikilink">artificial neural networks</a> used in conjunction with an <a href="Mathematical_optimization" title="wikilink">optimization method</a> such as <a href="gradient_descent" title="wikilink">gradient descent</a>. The method calculates the gradient of a <a href="loss_function" title="wikilink">loss function</a> with respect to all the weights in the network. The gradient is fed to the optimization method which in turn uses it to update the weights, in an attempt to minimize the loss function.</p>

<p>Backpropagation requires a known, desired output for each input value in order to calculate the loss function gradient. It is therefore usually considered to be a <a href="supervised_learning" title="wikilink">supervised learning</a> method, although it is also used in some <a href="Unsupervised_learning" title="wikilink">unsupervised</a> networks such as <a href="autoencoder" title="wikilink">autoencoders</a>. It is a generalization of the <a href="delta_rule" title="wikilink">delta rule</a> to multi-layered <a href="Feedforward_neural_network" title="wikilink">feedforward networks</a>, made possible by using the <a href="chain_rule" title="wikilink">chain rule</a> to iteratively compute gradients for each layer. Backpropagation requires that the <a href="activation_function" title="wikilink">activation function</a> used by the <a href="artificial_neuron" title="wikilink">artificial neurons</a> (or "nodes") be <a class="uri" href="differentiable" title="wikilink">differentiable</a>.</p>
<h2 id="motivation">Motivation</h2>

<p>The goal of any <a href="supervised_learning" title="wikilink">supervised learning</a> algorithm is to find a function that best maps a set of inputs to its correct output. An example would be a simple <a href="Classification_(machine_learning)" title="wikilink">classification</a> task, where the input is an image of an animal, and the correct output would be the name of the animal. Some input and output patterns can be easily learned by single-layer neural networks (i.e. <a class="uri" href="perceptrons" title="wikilink">perceptrons</a>). However, these single-layer perceptrons cannot learn some relatively simple patterns, such as those that are not <a href="linearly_separable" title="wikilink">linearly separable</a>. For example, a human may classify an image of an animal by recognizing certain features such as the number of limbs, the texture of the skin (whether it is furry, feathered, scaled, etc.), the size of the animal, and the list goes on. A single-layer neural network however, must learn a function that outputs a label solely using the intensity of the pixels in the image. There is no way for it to learn any abstract features of the input since it is limited to having only one layer. A multi-layered network overcomes this limitation as it can create internal representations and learn different features in each layer.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The first layer may be responsible for learning the orientations of lines using the inputs from the individual pixels in the image. The second layer may combine the features learned in the first layer and learn to identify simple shapes such as circles. Each higher layer learns more and more abstract features such as those mentioned above that can be used to classify the image. Each layer finds patterns in the layer below it and it is this ability to create internal representations that are independent of outside input that gives multi-layered networks their power. The goal and motivation for developing the backpropagation algorithm was to find a way to train a multi-layered neural network such that it can learn the appropriate internal representations to allow it to learn any arbitrary mapping of input to output.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="summary">Summary</h2>

<p>The backpropagation learning algorithm can be divided into two phases: propagation and weight update.</p>
<h3 id="phase-1-propagation">Phase 1: Propagation</h3>

<p>Each propagation involves the following steps:</p>
<ol>
<li>Forward propagation of a training pattern's input through the neural network in order to generate the propagation's output activations.</li>
<li>Backward propagation of the propagation's output activations through the neural network using the training pattern target in order to generate the deltas of all output and hidden neurons.</li>
</ol>
<h3 id="phase-2-weight-update">Phase 2: Weight update</h3>

<p>For each weight-synapse follow the following steps:</p>
<ol>
<li>Multiply its output delta and input activation to get the gradient of the weight.</li>
<li>Subtract a ratio (percentage) of the gradient from the weight.</li>
</ol>

<p>This ratio (percentage) influences the speed and quality of learning; it is called the <em>learning rate</em>. The greater the ratio, the faster the neuron trains; the lower the ratio, the more accurate the training is. The sign of the gradient of a weight indicates where the error is increasing, this is why the weight must be updated in the opposite direction.</p>

<p>Repeat phase 1 and 2 until the performance of the network is satisfactory.</p>
<h2 id="algorithm">Algorithm</h2>
<section begin="algorithm">
</section>

<p>Algorithm for a 3-layer network (only one hidden layer):</p>

<p><code>  initialize network weights (often small random values)</code><br/>
<code>  </code><strong><code>do</code></strong><br/>
<code>     </code><strong><code>forEach</code></strong><code> training example ex</code><br/>
<code>        prediction = </code><u><code>neural-net-output</code></u><code>(network, ex)  </code><em><code>//</code> <code>forward</code> <code>pass</code></em><br/>
<code>        actual = </code><u><code>teacher-output</code></u><code>(ex)</code><br/>
<code>        compute error (prediction - actual) at the output units</code><br/>
<code>        compute </code>

<math display="inline" id="Backpropagation:0">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <msub>
    <mi>w</mi>
    <mi>h</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta w_{h}
  </annotation>
 </semantics>
</math>

<code> for all weights from hidden layer to output layer  </code><em><code>//</code> <code>backward</code> <code>pass</code></em><br/>
<code>        compute </code>

<math display="inline" id="Backpropagation:1">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta w_{i}
  </annotation>
 </semantics>
</math>

<code> for all weights from input layer to hidden layer   </code><em><code>//</code> <code>backward</code> <code>pass</code> <code>continued</code></em><br/>
<code>        update network weights </code><em><code>//</code> <code>input</code> <code>layer</code> <code>not</code> <code>modified</code> <code>by</code> <code>error</code> <code>estimate</code></em><br/>
<code>  </code><strong><code>until</code></strong><code> all examples classified correctly or another stopping criterion satisfied</code><br/>
<code>  </code><strong><code>return</code></strong><code> the network</code></p>

<p>As the <a class="uri" href="algorithm" title="wikilink">algorithm</a>'s name implies, the errors propagate backwards from the output nodes to the input nodes. Technically speaking, backpropagation calculates the gradient of the error of the network regarding the network's modifiable weights.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This gradient is almost always used in a simple <a href="stochastic_gradient_descent" title="wikilink">stochastic gradient descent</a> algorithm to find weights that minimize the error. Often the term "backpropagation" is used in a more general sense, to refer to the entire procedure encompassing both the calculation of the gradient and its use in stochastic gradient descent. Backpropagation usually allows quick convergence on satisfactory <a href="Maxima_and_minima" title="wikilink">local minima</a> for error in the kind of networks to which it is suited.</p>

<p>Backpropagation networks are necessarily <a href="multilayer_perceptron" title="wikilink">multilayer perceptrons</a> (usually with one input, one hidden, and one output layer). In order for the hidden layer to serve any useful function, multilayer networks must have non-linear activation functions for the multiple layers: a multilayer network using only linear activation functions is equivalent to some single layer, linear network. Non-linear activation functions that are commonly used include the <a href="logistic_function" title="wikilink">logistic function</a>, the <a href="softmax_activation_function" title="wikilink">softmax function</a>, and the <a href="gaussian_function" title="wikilink">gaussian function</a>.</p>

<p>The backpropagation algorithm for calculating a gradient has been rediscovered a number of times, and is a special case of a more general technique called <a href="automatic_differentiation" title="wikilink">automatic differentiation</a> in the reverse accumulation mode.</p>

<p>It is also closely related to the <a href="Gauss–Newton_algorithm" title="wikilink">Gauss–Newton algorithm</a>, and is also part of continuing research in <a href="neural_backpropagation" title="wikilink">neural backpropagation</a>.</p>
<section end="algorithm">
</section>
<h2 id="intuition">Intuition</h2>
<h3 id="learning-as-an-optimization-problem">Learning as an optimization problem</h3>

<p>Before showing the mathematical derivation of the backpropagation algorithm, it helps to develop some intuitions about the relationship between the actual output of a neuron and the correct output for a particular training case. Consider a simple neural network with two input units, one output unit and no hidden units. Each neuron uses a <a href="Artificial_neuron#Linear_combination" title="wikilink">linear output</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> that is the weighted sum of its input. </p>

<p>Initially, before training, the weights will be set randomly. Then the neuron learns from <a href="Training_set" title="wikilink">training examples</a>, which in this case consists of a set of tuples (

<math display="inline" id="Backpropagation:2">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Backpropagation:3">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Backpropagation:4">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

) where 

<math display="inline" id="Backpropagation:5">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpropagation:6">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

 are the inputs to the network and 

<math display="inline" id="Backpropagation:7">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is the correct output (the output the network should eventually produce given the identical inputs). The network given 

<math display="inline" id="Backpropagation:8">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpropagation:9">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

 will compute an output 

<math display="inline" id="Backpropagation:10">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 which very likely differs from 

<math display="inline" id="Backpropagation:11">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 (since the weights are initially random). A common method for measuring the discrepancy between the expected output 

<math display="inline" id="Backpropagation:12">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and the actual output 

<math display="inline" id="Backpropagation:13">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is using the squared error measure:</p>

<p>

<math display="block" id="Backpropagation:14">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <ci>y</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=(t-y)^{2}\,
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Backpropagation:15">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is the discrepancy or error.</p>

<p>As an example, consider the network on a single training case

<math display="block" id="Backpropagation:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>0</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">1</cn>
    <cn type="integer">1</cn>
    <cn type="integer">0</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,1,0)
  </annotation>
 </semantics>
</math>

, thus the input 

<math display="inline" id="Backpropagation:17">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpropagation:18">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

 are 1 and 1 respectively and the correct output, 

<math display="inline" id="Backpropagation:19">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is 0. Now if the actual output 

<math display="inline" id="Backpropagation:20">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is plotted on the x-axis against the error 

<math display="inline" id="Backpropagation:21">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 on the 

<math display="inline" id="Backpropagation:22">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

-axis, the result is a parabola. The <a href="Maxima_and_minima" title="wikilink">minimum</a> of the <a class="uri" href="parabola" title="wikilink">parabola</a> corresponds to the output 

<math display="inline" id="Backpropagation:23">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 which minimizes the error 

<math display="inline" id="Backpropagation:24">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

. For a single training case, the minimum also touches the 

<math display="inline" id="Backpropagation:25">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

-axis, which means the error will be zero and the network can produce an output 

<math display="inline" id="Backpropagation:26">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 that exactly matches the expected output 

<math display="inline" id="Backpropagation:27">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. Therefore, the problem of mapping inputs to outputs can be reduced to an <a href="optimization_problem" title="wikilink">optimization problem</a> of finding a function that will produce the minimal error. </p>

<p>However, the output of a neuron depends on the weighted sum of all its inputs:</p>

<p>

<math display="block" id="Backpropagation:28">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>w</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>w</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=x_{1}w_{1}+x_{2}w_{2}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Backpropagation:29">
 <semantics>
  <msub>
   <mi>w</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpropagation:30">
 <semantics>
  <msub>
   <mi>w</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{2}
  </annotation>
 </semantics>
</math>

 are the weights on the connection from the input units to the output unit. Therefore, the error also depends on the incoming weights to the neuron, which is ultimately what needs to be changed in the network to enable learning. If each weight is plotted on a separate horizontal axis and the error on the vertical axis, the result is a <a href="Paraboloid" title="wikilink">parabolic bowl</a> (If a neuron has 

<math display="inline" id="Backpropagation:31">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 weights, then the <a href="Dimension_(mathematics_and_physics)" title="wikilink">dimension</a> of the error surface would be 

<math display="inline" id="Backpropagation:32">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k+1
  </annotation>
 </semantics>
</math>

, thus a 

<math display="inline" id="Backpropagation:33">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k+1
  </annotation>
 </semantics>
</math>

 dimensional equivalent of the 2D parabola). </p>

<p>The backpropagation algorithm aims to find the set of weights that minimizes the error. There are several methods for finding the minima of a parabola or any function in any dimension. One way is analytically by solving <a href="System_of_polynomial_equations" title="wikilink">systems of equations</a>, however this relies on the network being a <a href="linear_system" title="wikilink">linear system</a>, and the goal is to be able to also train multi-layer, <a href="Nonlinear_system" title="wikilink">non-linear</a> networks (since a multi-layered linear network is equivalent to a single-layer network). The method used in backpropagation is <a href="gradient_descent" title="wikilink">gradient descent</a>.</p>
<h3 id="an-analogy-for-understanding-gradient-descent">An analogy for understanding gradient descent</h3>

<p>The basic intuition behind <a href="gradient_descent" title="wikilink">gradient descent</a> can be illustrated by a hypothetical scenario. A person is stuck in the mountains is trying to get down (i.e. trying to find the minima). There is heavy fog such that visibility is extremely low. Therefore, the path down the mountain is not visible, so he must use local information to find the minima. He can use the method of gradient descent, which involves looking at the steepness of the hill at his current position, then proceeding in the direction with the most negative steepness (i.e. downhill). If he was trying to find the top of the mountain (i.e. the maxima), then he would proceed in the direction with most positive steepness (i.e. uphill). Using this method, he would eventually find his way down the mountain. However, assume also that the steepness of the hill is not immediately obvious with simple observation, but rather it requires a sophisticated instrument to measure, which the person happens to have at the moment. It takes quite some time to measure the steepness of the hill with the instrument, thus he should minimize his use of the instrument if he wanted to get down the mountain before sunset. The difficulty then is choosing the frequency at which he should measure the steepness of the hill so not to go off track.</p>

<p>In this analogy, the person represents the backpropagation algorithm, and the path down the mountain represents the set of weights that will minimize the error. The steepness of the hill represents the <a class="uri" href="slope" title="wikilink">slope</a> of the error surface at that point. The direction he must travel in corresponds to the <a class="uri" href="gradient" title="wikilink">gradient</a> of the error surface at that point. The instrument used to measure steepness is <a href="Differentiation_(mathematics)" title="wikilink">differentiation</a> (the slope of the error surface can be calculated by taking the <a class="uri" href="derivative" title="wikilink">derivative</a> of the squared error function at that point). The distance he travels in between measurements (which is also proportional to the frequency as which he takes measurement) is the learning rate of the algorithm. See the <a href="backpropagation#Limitations" title="wikilink">limitation section</a> for a discussion of the limitations of this type of "hill climbing" algorithm.</p>
<h2 id="derivation">Derivation</h2>

<p>Since backpropagation uses the gradient descent method, one needs to calculate the derivative of the squared error function with respect to the weights of the network. Assuming one output neuron,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> the squared error function is:</p>

<p>

<math display="block" id="Backpropagation:34">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <mstyle displaystyle="false">
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </mstyle>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <ci>y</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=\tfrac{1}{2}(t-y)^{2}
  </annotation>
 </semantics>
</math>

, where</p>

<p>

<math display="block" id="Backpropagation:35">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is the squared error,</p>

<p>

<math display="block" id="Backpropagation:36">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is the target output for a training sample, and</p>

<p>

<math display="block" id="Backpropagation:37">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is the actual output of the output neuron.</p>

<p>The factor of 

<math display="inline" id="Backpropagation:38">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\frac{1}{2}
  </annotation>
 </semantics>
</math>

 is included to cancel the exponent when differentiating. Later, the expression will be multiplied with an arbitrary learning rate, so that it doesn't matter if a constant coefficient is introduced now.</p>

<p>For each neuron 

<math display="inline" id="Backpropagation:39">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

, its output 

<math display="inline" id="Backpropagation:40">
 <semantics>
  <msub>
   <mi>o</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{j}
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>

<math display="block" id="Backpropagation:41">
 <semantics>
  <mrow>
   <msub>
    <mi>o</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>net</mtext>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>w</mi>
        <mrow>
         <mi>k</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>o</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <ci>φ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>net</mtext>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>φ</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <apply>
          <times></times>
          <ci>k</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{j}=\varphi(\mbox{net}_{j})=\varphi\left(\sum_{k=1}^{n}w_{kj}x_{k}\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>The input 

<math display="inline" id="Backpropagation:42">
 <semantics>
  <msub>
   <mtext>net</mtext>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>net</mtext>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{net}_{j}
  </annotation>
 </semantics>
</math>

 to a neuron is the weighted sum of outputs 

<math display="inline" id="Backpropagation:43">
 <semantics>
  <msub>
   <mi>o</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{k}
  </annotation>
 </semantics>
</math>

 of previous neurons. If the neuron is in the first layer after the input layer, the 

<math display="inline" id="Backpropagation:44">
 <semantics>
  <msub>
   <mi>o</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{k}
  </annotation>
 </semantics>
</math>

 of the input layer are simply the inputs 

<math display="inline" id="Backpropagation:45">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 to the network. The number of input units to the neuron is 

<math display="inline" id="Backpropagation:46">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. The variable 

<math display="inline" id="Backpropagation:47">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{ij}
  </annotation>
 </semantics>
</math>

 denotes the weight between neurons 

<math display="inline" id="Backpropagation:48">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Backpropagation:49">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

.</p>

<p>The <a href="activation_function" title="wikilink">activation function</a> 

<math display="inline" id="Backpropagation:50">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is in general <a class="uri" href="non-linear" title="wikilink">non-linear</a> and <a class="uri" href="differentiable" title="wikilink">differentiable</a>. A commonly used activation function is the <a href="logistic_function" title="wikilink">logistic function</a>:</p>

<p>

<math display="block" id="Backpropagation:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mi>z</mi>
      </mrow>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(z)=\frac{1}{1+e^{-z}}
  </annotation>
 </semantics>
</math>

 which has a nice derivative of:</p>

<p>

<math display="block" id="Backpropagation:52">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>φ</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>z</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>φ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>φ</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>φ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>φ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial\varphi}{\partial z}=\varphi(1-\varphi)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="finding-the-derivative-of-the-error">Finding the derivative of the error</h3>

<p>Calculating the <a href="partial_derivative" title="wikilink">partial derivative</a> of the error with respect to a weight 

<math display="inline" id="Backpropagation:53">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{ij}
  </annotation>
 </semantics>
</math>

 is done using the <a href="chain_rule" title="wikilink">chain rule</a> twice:</p>

<p>

<math display="block" id="Backpropagation:54">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>E</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <mi>E</mi>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>o</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mfrac>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>o</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>net</mi>
       <mi mathvariant="normal">j</mi>
      </msub>
     </mrow>
    </mfrac>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>net</mi>
       <mi mathvariant="normal">j</mi>
      </msub>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>w</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>E</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>E</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>o</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>o</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>net</ci>
        <ci>normal-j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>net</ci>
        <ci>normal-j</ci>
       </apply>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial E}{\partial w_{ij}}=\frac{\partial E}{\partial o_{j}}\frac{%
\partial o_{j}}{\partial\mathrm{net_{j}}}\frac{\partial\mathrm{net_{j}}}{%
\partial w_{ij}}
  </annotation>
 </semantics>
</math>

</p>

<p>In the last term of the right-hand side, only one term in the sum 

<math display="inline" id="Backpropagation:55">
 <semantics>
  <msub>
   <mi>net</mi>
   <mi mathvariant="normal">j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>net</ci>
    <ci>normal-j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{net_{j}}
  </annotation>
 </semantics>
</math>

 depends on 

<math display="inline" id="Backpropagation:56">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{ij}
  </annotation>
 </semantics>
</math>

, so that</p>

<p>

<math display="block" id="Backpropagation:57">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>net</mi>
      <mi mathvariant="normal">j</mi>
     </msub>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mo>∂</mo>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>w</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>w</mi>
        <mrow>
         <mi>k</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>net</ci>
        <ci>normal-j</ci>
       </apply>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <apply>
          <times></times>
          <ci>k</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial\mathrm{net_{j}}}{\partial w_{ij}}=\frac{\partial}{\partial w_{%
ij}}\left(\sum_{k=1}^{n}w_{kj}x_{k}\right)=x_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>The derivative of the output of neuron 

<math display="inline" id="Backpropagation:58">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 with respect to its input is simply the partial derivative of the activation function (assuming here that the logistic function is used):</p>

<p>

<math display="block" id="Backpropagation:59">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>o</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>net</mi>
      <mi mathvariant="normal">j</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mo>∂</mo>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>net</mi>
       <mi mathvariant="normal">j</mi>
      </msub>
     </mrow>
    </mfrac>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>net</mi>
      <mi mathvariant="normal">j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>net</mi>
      <mi mathvariant="normal">j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mi>φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>net</mi>
         <mi mathvariant="normal">j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>o</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>net</ci>
        <ci>normal-j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>net</ci>
         <ci>normal-j</ci>
        </apply>
       </apply>
      </apply>
      <ci>φ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>net</ci>
       <ci>normal-j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>φ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>net</ci>
       <ci>normal-j</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>φ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>net</ci>
         <ci>normal-j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial o_{j}}{\partial\mathrm{net_{j}}}=\frac{\partial}{\partial%
\mathrm{net_{j}}}\varphi(\mathrm{net_{j}})=\varphi(\mathrm{net_{j}})(1-\varphi%
(\mathrm{net_{j}}))
  </annotation>
 </semantics>
</math>

 This is the reason why backpropagation requires the activation function to be <a class="uri" href="differentiable" title="wikilink">differentiable</a>.</p>

<p>The first term is straightforward to evaluate if the neuron is in the output layer, because then 

<math display="inline" id="Backpropagation:60">
 <semantics>
  <mrow>
   <msub>
    <mi>o</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>o</ci>
     <ci>j</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{j}=y
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Backpropagation:61">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>E</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>o</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>E</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>y</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mo>∂</mo>
     <mrow>
      <mo>∂</mo>
      <mi>y</mi>
     </mrow>
    </mfrac>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>y</mi>
    <mo>-</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>E</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>o</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>E</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <ci>y</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial E}{\partial o_{j}}=\frac{\partial E}{\partial y}=\frac{\partial%
}{\partial y}\frac{1}{2}(t-y)^{2}=y-t
  </annotation>
 </semantics>
</math>

</p>

<p>However, if 

<math display="inline" id="Backpropagation:62">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 is in an arbitrary inner layer of the network, finding the derivative 

<math display="inline" id="Backpropagation:63">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 with respect to 

<math display="inline" id="Backpropagation:64">
 <semantics>
  <msub>
   <mi>o</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{j}
  </annotation>
 </semantics>
</math>

 is less obvious.</p>

<p>Considering 

<math display="inline" id="Backpropagation:65">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 as a function of the inputs of all neurons 

<math display="inline" id="Backpropagation:66">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>w</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <list>
     <ci>u</ci>
     <ci>v</ci>
     <ci>normal-…</ci>
     <ci>w</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L={u,v,\dots,w}
  </annotation>
 </semantics>
</math>

 receiving input from neuron 

<math display="inline" id="Backpropagation:67">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Backpropagation:68">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo>∂</mo>
      <mi>E</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>o</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>o</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo>∂</mo>
      <mi>E</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>net</mi>
       <mi>u</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>net</mi>
       <mi>v</mi>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>net</mi>
       <mi>w</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>o</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <partialdiff></partialdiff>
       <ci>E</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>o</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>o</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <partialdiff></partialdiff>
       <ci>E</ci>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>net</ci>
        <ci>u</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>net</ci>
        <ci>v</ci>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>net</ci>
        <ci>w</ci>
       </apply>
      </vector>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>o</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial E(o_{j})}{\partial o_{j}}=\frac{\partial E(\mathrm{net}_{u},%
\mathrm{net}_{v},\dots,\mathrm{net}_{w})}{\partial o_{j}}
  </annotation>
 </semantics>
</math>

 and taking the <a href="total_derivative" title="wikilink">total derivative</a> with respect to 

<math display="inline" id="Backpropagation:69">
 <semantics>
  <msub>
   <mi>o</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{j}
  </annotation>
 </semantics>
</math>

, a recursive expression for the derivative is obtained:</p>

<p>

<math display="block" id="Backpropagation:70">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>E</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>o</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>l</mi>
      <mo>∈</mo>
      <mi>L</mi>
     </mrow>
    </munder>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>E</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>net</mi>
         <mi>l</mi>
        </msub>
       </mrow>
      </mfrac>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>net</mi>
         <mi>l</mi>
        </msub>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>o</mi>
         <mi>j</mi>
        </msub>
       </mrow>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>l</mi>
      <mo>∈</mo>
      <mi>L</mi>
     </mrow>
    </munder>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>E</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>o</mi>
         <mi>l</mi>
        </msub>
       </mrow>
      </mfrac>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>o</mi>
         <mi>l</mi>
        </msub>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>net</mi>
         <mi>l</mi>
        </msub>
       </mrow>
      </mfrac>
      <msub>
       <mi>w</mi>
       <mrow>
        <mi>j</mi>
        <mi>l</mi>
       </mrow>
      </msub>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>E</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>o</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>l</ci>
        <ci>L</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <ci>E</ci>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>net</ci>
          <ci>l</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>net</ci>
          <ci>l</ci>
         </apply>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>o</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>l</ci>
        <ci>L</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <ci>E</ci>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>o</ci>
          <ci>l</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>o</ci>
          <ci>l</ci>
         </apply>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>net</ci>
          <ci>l</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>l</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial E}{\partial o_{j}}=\sum_{l\in L}\left(\frac{\partial E}{%
\partial\mathrm{net}_{l}}\frac{\partial\mathrm{net}_{l}}{\partial o_{j}}\right%
)=\sum_{l\in L}\left(\frac{\partial E}{\partial o_{l}}\frac{\partial o_{l}}{%
\partial\mathrm{net}_{l}}w_{jl}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, the derivative with respect to 

<math display="inline" id="Backpropagation:71">
 <semantics>
  <msub>
   <mi>o</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{j}
  </annotation>
 </semantics>
</math>

 can be calculated if all the derivatives with respect to the outputs 

<math display="inline" id="Backpropagation:72">
 <semantics>
  <msub>
   <mi>o</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{l}
  </annotation>
 </semantics>
</math>

 of the next layer – the one closer to the output neuron – are known.</p>

<p>Putting it all together:</p>

<p>

<math display="block" id="Backpropagation:73">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>E</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>δ</mi>
     <mi>j</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>E</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dfrac{\partial E}{\partial w_{ij}}=\delta_{j}x_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>with</p>

<p>

<math display="block" id="Backpropagation:74">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <mi>E</mi>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>o</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mfrac>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>o</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>net</mi>
       <mi mathvariant="normal">j</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>o</mi>
           <mi>j</mi>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>t</mi>
           <mi>j</mi>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>φ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mtext>net</mtext>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mrow>
           <mi>φ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mtext>net</mtext>
             <mi>j</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mtext>if</mtext>
        <mi>j</mi>
        <mtext>is an output neuron,</mtext>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mstyle displaystyle="false">
           <msub>
            <mo largeop="true" symmetric="true">∑</mo>
            <mrow>
             <mi>l</mi>
             <mo>∈</mo>
             <mi>L</mi>
            </mrow>
           </msub>
          </mstyle>
          <mrow>
           <msub>
            <mi>δ</mi>
            <mi>l</mi>
           </msub>
           <msub>
            <mi>w</mi>
            <mrow>
             <mi>j</mi>
             <mi>l</mi>
            </mrow>
           </msub>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>φ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mtext>net</mtext>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mrow>
           <mi>φ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mtext>net</mtext>
             <mi>j</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mtext>if</mtext>
        <mi>j</mi>
        <mtext>is an inner neuron.</mtext>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>E</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>o</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>o</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>net</ci>
         <ci>normal-j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">cases</csymbol>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>o</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>φ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>net</mtext>
        <ci>j</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>φ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <mtext>net</mtext>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>j</ci>
       <mtext>is an output neuron,</mtext>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <in></in>
          <ci>l</ci>
          <ci>L</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>δ</ci>
          <ci>l</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <apply>
           <times></times>
           <ci>j</ci>
           <ci>l</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>φ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>net</mtext>
        <ci>j</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>φ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <mtext>net</mtext>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>j</ci>
       <mtext>is an inner neuron.</mtext>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{j}=\frac{\partial E}{\partial o_{j}}\frac{\partial o_{j}}{\partial%
\mathrm{net_{j}}}=\begin{cases}(o_{j}-t_{j})\varphi(\mbox{net}_{j})(1-\varphi(%
\mbox{net}_{j}))&\mbox{if }j\mbox{ is an output neuron,}\\
(\sum_{l\in L}\delta_{l}w_{jl})\varphi(\mbox{net}_{j})(1-\varphi(\mbox{net}_{j%
}))&\mbox{if }j\mbox{ is an inner neuron.}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>To update the weight 

<math display="inline" id="Backpropagation:75">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{ij}
  </annotation>
 </semantics>
</math>

 using gradient descent, one must choose a learning rate, 

<math display="inline" id="Backpropagation:76">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

. The change in weight, which is added to the old weight, is equal to the product of the learning rate and the gradient, multiplied by 

<math display="inline" id="Backpropagation:77">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -1
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Backpropagation:78">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>α</mi>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>E</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>w</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>α</ci>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>E</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta w_{ij}=-\alpha\frac{\partial E}{\partial w_{ij}}
  </annotation>
 </semantics>
</math>

</p>

<p>The 

<math display="inline" id="Backpropagation:79">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle-1
  </annotation>
 </semantics>
</math>

 is required in order to update in the direction of a minimum, not a maximum, of the error function.</p>

<p>For a single-layer network, this expression becomes the <a href="Delta_Rule" title="wikilink">Delta Rule</a>. To better understand how backpropagation works, here is an example to illustrate it: <a href="https://www4.rgu.ac.uk/files/chapter3%20-%20bp.pdf">The Back Propagation Algorithm</a>, page 20.</p>
<h2 id="modes-of-learning">Modes of learning</h2>

<p>There are three modes of learning to choose from: <a href="online_machine_learning" title="wikilink">on-line</a>, batch and <a href="stochastic_gradient_descent" title="wikilink">stochastic</a>. In on-line and stochastic learning, each propagation is followed immediately by a weight update. In batch learning, many propagations occur before updating the weights. On-line learning is used for dynamic environments that provide a continuous stream of new patterns. Stochastic learning and batch learning both make use of a training set of static patterns. Stochastic goes through the data set in a random order in order to reduce its chances of getting stuck in local minima. Stochastic learning is also much faster than batch learning since weights are updated immediately after each propagation. Yet batch learning will yield a much more stable descent to a local minimum since each update is performed based on all patterns.</p>
<h2 id="limitations">Limitations</h2>
<ul>
<li>The result may converge to a <a href="Maxima_and_minima" title="wikilink">local minimum</a>. The "hill climbing" strategy of gradient descent is guaranteed to work if there is only one minimum. However, often the error surface has many local minima and maxima. If the starting point of the gradient descent happens to be somewhere between a local maximum and local minimum, then going down the direction with the most negative gradient will lead to the local minimum. </li>
<li>The convergence obtained from backpropagation learning is very slow.</li>
<li>The convergence in backpropagation learning is not guaranteed.
<ul>
<li>However, convergence to the global minimum is said to be guaranteed using the adaptive stopping criterion.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
</ul></li>
<li>Backpropagation learning does not require normalization of input vectors; however, normalization could improve performance.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
</ul>
<h2 id="history">History</h2>

<p><a class="uri" href="Vapnik" title="wikilink">Vapnik</a> cites (Bryson, A.E.; W.F. Denham; S.E. Dreyfus. Optimal programming problems with inequality constraints. I: Necessary conditions for extremal solutions. AIAA J. 1, 11 (1963) 2544-2550) as the first publication of the backpropagation algorithm in his book "Support Vector Machines.". <a href="Arthur_E._Bryson" title="wikilink">Arthur E. Bryson</a> and <a href="Yu-Chi_Ho" title="wikilink">Yu-Chi Ho</a> described it as a multi-stage dynamic system optimization method in 1969.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> It wasn't until 1974 and later, when applied in the context of neural networks and through the work of <a href="Paul_Werbos" title="wikilink">Paul Werbos</a>,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> <a href="David_E._Rumelhart" title="wikilink">David E. Rumelhart</a>, <a href="Geoffrey_E._Hinton" title="wikilink">Geoffrey E. Hinton</a> and <a href="Ronald_J._Williams" title="wikilink">Ronald J. Williams</a>,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> that it gained recognition, and it led to a “renaissance” in the field of artificial neural network research. During the 2000s it fell out of favour but has returned again in the 2010s, now able to train much larger networks using huge modern computing power such as <a href="GPU" title="wikilink">GPUs</a>. For example, in 2013 top speech recognisers now use backpropagation-trained neural networks.</p>
<h2 id="notes">Notes</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Artificial_neural_network" title="wikilink">Artificial neural network</a></li>
<li><a href="Biological_neural_network" title="wikilink">Biological neural network</a></li>
<li><a href="Catastrophic_interference" title="wikilink">Catastrophic interference</a></li>
<li><a href="Ensemble_learning" title="wikilink">Ensemble learning</a></li>
<li><a class="uri" href="AdaBoost" title="wikilink">AdaBoost</a></li>
<li><a class="uri" href="Overfitting" title="wikilink">Overfitting</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://numericinsight.com/uploads/A_Gentle_Introduction_to_Backpropagation.pdf">A Gentle Introduction to Backpropagation - An intuitive tutorial by Shashi Sathyanarayana</a> The article contains pseudocode ("Training Wheels for Training Neural Networks") for implementing the algorithm.</li>
<li><a href="http://msdn.microsoft.com/en-us/magazine/jj658979.aspx">Neural Network Back-Propagation for Programmers (a tutorial)</a></li>
<li><a href="http://www.matematica.ciens.ucv.ve/dcrespin/Pub/backprop.pdf">Backpropagation for mathematicians</a></li>
<li>Chapter 7 <a href="http://page.mi.fu-berlin.de/rojas/neural/chapter/K7.pdf">The backpropagation algorithm</a> of <a href="http://page.mi.fu-berlin.de/rojas/neural/index.html.html"><em>Neural Networks - A Systematic Introduction</em></a> by <a href="Raúl_Rojas" title="wikilink">Raúl Rojas</a> (ISBN 978-3540605058)</li>
<li><a href="http://www.codeproject.com/KB/recipes/BP.aspx">Implementation of BackPropagation in C++</a></li>
<li><a href="http://www.codeproject.com/KB/cs/BackPropagationNeuralNet.aspx">Implementation of BackPropagation in C#</a></li>
<li><a href="https://github.com/guycole/BackProp1">Implementation of BackPropagation in Java</a></li>
<li><a href="https://github.com/agibsonccc/java-deeplearning/blob/67ffee2c431f5fdbf3be9f393279c98caaa35f76/deeplearning4j-core/src/main/java/org/deeplearning4j/nn/BaseMultiLayerNetwork.java">Another Implementation of BackPropagation in Java</a></li>
<li><a href="http://ai4r.org/neuralNetworks.html">Implementation of BackPropagation in Ruby</a></li>
<li><a href="http://arctrix.com/nas/python/bpnn.py">Implementation of BackPropagation in Python</a></li>
<li><a href="http://freedelta.free.fr/r/php-code-samples/artificial-intelligence-neural-network-backpropagation/">Implementation of BackPropagation in PHP</a></li>
<li><a href="http://www.tek271.com/documents/others/into-to-neural-networks">Quick explanation of the backpropagation algorithm</a></li>
<li><a href="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop.html">Graphical explanation of the backpropagation algorithm</a></li>
<li><a href="http://pandamatak.com/people/anand/771/html/node37.html">Concise explanation of the backpropagation algorithm using math notation</a> by Anand Venkataraman</li>
<li><a href="http://en.wikiversity.org/wiki/Learning_and_Neural_Networks">Backpropagation neural network tutorial at the Wikiversity</a></li>
</ul>

<p>"</p>

<p><a href="Category:Machine_learning_algorithms" title="wikilink">Category:Machine learning algorithms</a> <a href="Category:Artificial_neural_networks" title="wikilink">Category:Artificial neural networks</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3">Paul J. Werbos (1994). The Roots of Backpropagation. From Ordered Derivatives to Neural Networks and Political Forecasting. New York, NY: John Wiley &amp; Sons, Inc.<a href="#fnref3">↩</a></li>
<li id="fn4">One may notice that multi-layer neural networks use non-linear activation functions, so an example with linear neurons seems obscure. However, even though the error surface of multi-layer networks are much more complicated, locally they can be approximated by a paraboloid. Therefore, linear neurons are used for simplicity and easier understanding.<a href="#fnref4">↩</a></li>
<li id="fn5">There can be multiple output neurons, in which case the error is the squared norm of the difference vector.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">ISBN 1-931841-08-X,<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">Paul J. Werbos. Beyond Regression: New Tools for Prediction and Analysis in the Behavioral Sciences. PhD thesis, Harvard University, 1974<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
</ol>
</section>
</body>
</html>
