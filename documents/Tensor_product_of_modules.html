<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1620">Tensor product of modules</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Tensor product of modules</h1>
<hr>In [[mathematics]], the '''tensor product of modules''' is a construction that allows arguments about [[bilinear map|bilinear]] maps (e.g. multiplication) to be carried out in terms of linear maps ([[mo
<p>dule homomorphism]]s). The module construction is analogous to the construction of the <a href="tensor_product" title="wikilink">tensor product</a> of <a href="vector_space" title="wikilink">vector spaces</a>, but can be carried out for a pair of <a href="module_(mathematics)" title="wikilink">modules</a> over a <a href="commutative_ring" title="wikilink">commutative ring</a> resulting in a third module, and also for a pair of a right-module and a left-module over any <a href="ring_(mathematics)" title="wikilink">ring</a>, with result an <a href="abelian_group" title="wikilink">abelian group</a>. Tensor products are important in areas of <a href="abstract_algebra" title="wikilink">abstract algebra</a>, <a href="homological_algebra" title="wikilink">homological algebra</a>, <a href="algebraic_topology" title="wikilink">algebraic topology</a> and <a href="algebraic_geometry" title="wikilink">algebraic geometry</a>. The <a href="universal_property" title="wikilink">universal property</a> of the tensor product of vector spaces extends to more general situations in abstract algebra. It allows the study of bilinear or multilinear operations via <a href="linear_operator" title="wikilink">linear operations</a>. The tensor product of an algebra and a module can be used for <a href="extension_of_scalars" title="wikilink">extension of scalars</a>. For a commutative ring, the tensor product of modules can be iterated to form the <a href="tensor_algebra" title="wikilink">tensor algebra</a> of a module, allowing one to define multiplication in the module in a universal way.</p>
<h2 id="balanced-product">Balanced product</h2>

<p>For a ring <em>R</em>, a right <em>R</em>-module <em>M</em>, a left <em>R</em>-module <em>N</em>, and an abelian group <em>G</em>, a map  is said to be <strong><em>R</em>-balanced</strong>, <strong><em>R</em>-middle-linear</strong> or an <strong><em>R</em>-balanced product</strong> if for all <em>m</em>, <em>m</em>′ in <em>M</em>, <em>n</em>, <em>n</em>′ in <em>N</em>, and <em>r</em> in <em>R</em> the following hold:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>φ</em>(<em>m</em>, <em>n</em> + <em>n</em>′) = <em>φ</em>(<em>m</em>, <em>n</em>) + <em>φ</em>(<em>m</em>, <em>n</em>′)</p></td>
<td style="text-align: left;">
<p>(Dl<sub><em>φ</em></sub>)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>φ</em>(<em>m</em> + <em>m</em>′, <em>n</em>) = <em>φ</em>(<em>m</em>, <em>n</em>) + <em>φ</em>(<em>m</em>′, <em>n</em>)</p></td>
<td style="text-align: left;">
<p>(Dr<sub><em>φ</em></sub>)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>φ</em>(<em>m</em> ⋅ <em>r</em>, <em>n</em>) = <em>φ</em>(<em>m</em>, <em>r</em> ⋅ <em>n</em>)</p></td>
<td style="text-align: left;">
<p>(A<sub><em>φ</em></sub>)</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>The set of all such balanced products over <em>R</em> from  to <em>G</em> is denoted by <mtpl></mtpl>.</p>

<p>If <em>φ</em>, <em>ψ</em> are balanced products, then the operations  and −<em>φ</em> defined <a class="uri" href="pointwise" title="wikilink">pointwise</a> are each a balanced product. This turns the set <mtpl></mtpl> into an abelian group.</p>

<p>For <em>M</em> and <em>N</em> fixed, the map <mtpl></mtpl> is a <a class="uri" href="functor" title="wikilink">functor</a> from the <a href="category_of_abelian_groups" title="wikilink">category of abelian groups</a> to the <a href="category_of_sets" title="wikilink">category of sets</a>. The morphism part is given by mapping a group homomorphism  to the function , which goes from <mtpl></mtpl> to <mtpl></mtpl>.</p>
<dl>
<dt>Remarks:</dt>
</dl>
<ol>
<li>Property (Dl) states the left and property (Dr) the right <a href="Distributive_property" title="wikilink">distributivity</a> of <em>φ</em> over addition.</li>
<li>Property (A) resembles some <a href="associative_property" title="wikilink">associative property</a> of <em>φ</em>.</li>
<li>Every ring <em>R</em> is an <em>R</em>-<em>R</em>-<a class="uri" href="bimodule" title="wikilink">bimodule</a>. So the ring multiplication  in <em>R</em> is an <em>R</em>-balanced product .</li>
</ol>
<h2 id="definition">Definition</h2>

<p>For a ring <em>R</em>, a right <em>R</em>-module <em>M</em>, a left <em>R</em>-module <em>N</em>, the <strong>tensor product</strong> over <em>R</em></p>

<p>

<math display="block" id="Tensor_product_of_modules:0">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N
  </annotation>
 </semantics>
</math>

</p>

<p>is an <a href="abelian_group" title="wikilink">abelian group</a> together with a balanced product (as defined above)</p>

<p>

<math display="block" id="Tensor_product_of_modules:1">
 <semantics>
  <mrow>
   <mo>⊗</mo>
   <mo>:</mo>
   <mi>M</mi>
   <mo>×</mo>
   <mi>N</mi>
   <mo>→</mo>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">M</csymbol>
    <times></times>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">M</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <csymbol cd="unknown">N</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes:M\times N\to M\otimes_{R}N
  </annotation>
 </semantics>
</math>

</p>

<p>which is <a href="universal_property" title="wikilink">universal</a> in the following sense:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>Tensor product of modules2.svg</figcaption>
</figure>
<dl>
<dd>For every abelian group <em>G</em> and every balanced product

<p>

<math display="block" id="Tensor_product_of_modules:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mo>×</mo>
     <mi>N</mi>
    </mrow>
    <mo>→</mo>
    <mpadded width="+1.7pt">
     <mi>G</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:M\times N\to G\,
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>there is a <strong>unique</strong> group homomorphism

<p>

<math display="block" id="Tensor_product_of_modules:3">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>f</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>M</mi>
     <msub>
      <mo>⊗</mo>
      <mi>R</mi>
     </msub>
     <mi>N</mi>
    </mrow>
    <mo>→</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <ci>normal-~</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}:M\otimes_{R}N\to G
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>such that

<p>

<math display="block" id="Tensor_product_of_modules:4">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>f</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>∘</mo>
   <mo>⊗</mo>
   <mo>=</mo>
   <mi>f</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>f</ci>
    </apply>
    <compose></compose>
    <csymbol cd="latexml">tensor-product</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}\circ\otimes=f.
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>

<p>As with all <a href="Universal_property#Existence_and_uniqueness" title="wikilink">universal properties</a>, the above property defines the tensor product uniquely <a href="up_to" title="wikilink">up to</a> a unique isomorphism: any other object and balanced product with the same properties will be isomorphic to <mtpl></mtpl> and ⊗. Indeed, the mapping ⊗ is called <em>canonical</em>, or more explicitly: the canonical mapping (or balanced product) of the tensor product.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The definition does not prove the existence of <mtpl></mtpl>; see below for a construction.</p>

<p>The tensor product can also be defined as a <a href="representable_functor" title="wikilink">representing object</a> for the functor <mtpl></mtpl>; explicitly, this means there is a <a href="natural_isomorphism" title="wikilink">natural isomorphism</a>:</p>

<p>

<math display="block" id="Tensor_product_of_modules:5">
 <semantics>
  <mrow>
   <msub>
    <mo>Hom</mo>
    <mi>ℤ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>N</mi>
    <mo>,</mo>
    <mi>G</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≃</mo>
   <msub>
    <mo>L</mo>
    <mi>R</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo>;</mo>
    <mi>G</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mi>g</mi>
   <mo>↦</mo>
   <mi>g</mi>
   <mo>∘</mo>
   <mo>⊗</mo>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Hom</ci>
     <ci>ℤ</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-L</ci>
     <ci>R</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-;</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">g</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <compose></compose>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}_{\mathbb{Z}}(M\otimes_{R}N,G)\simeq\operatorname{L}_{R}(M,N%
;G),\,g\mapsto g\circ\otimes.
  </annotation>
 </semantics>
</math>

 This is a succinct way of stating the universal mapping property given above. (A priori, if one is given this is natural isomorphism, then 

<math display="inline" id="Tensor_product_of_modules:6">
 <semantics>
  <mo>⊗</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">tensor-product</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes
  </annotation>
 </semantics>
</math>

 can be recovered by taking 

<math display="inline" id="Tensor_product_of_modules:7">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=M\otimes_{R}N
  </annotation>
 </semantics>
</math>

 and then mapping the identity map.)</p>

<p>Similarly, given the natural identification 

<math display="inline" id="Tensor_product_of_modules:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>L</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mi>N</mi>
     <mo>;</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>Hom</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mo>Hom</mo>
       <mi>ℤ</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>N</mi>
       <mo>,</mo>
       <mi>G</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-L</ci>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <ci>N</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>ℤ</ci>
      </apply>
      <ci>N</ci>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{L}_{R}(M,N;G)=\operatorname{Hom}_{R}(M,\operatorname{Hom}_{%
\mathbb{Z}}(N,G))
  </annotation>
 </semantics>
</math>


,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> one can also define <mtpl></mtpl> by the formula</p>

<p>

<math display="block" id="Tensor_product_of_modules:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>Hom</mo>
     <mi>ℤ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>N</mi>
     </mrow>
     <mo>,</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <msub>
     <mo>Hom</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mo>Hom</mo>
       <mi>ℤ</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>N</mi>
       <mo>,</mo>
       <mi>G</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <ci>ℤ</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <ci>G</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>ℤ</ci>
      </apply>
      <ci>N</ci>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}_{\mathbb{Z}}(M\otimes_{R}N,G)\simeq\operatorname{Hom}_{R}(M%
,\operatorname{Hom}_{\mathbb{Z}}(N,G))
  </annotation>
 </semantics>
</math>

. This is known as the <a href="tensor-hom_adjunction" title="wikilink">tensor-hom adjunction</a>; see also .</p>

<p>For each <em>x</em> in <em>M</em>, <em>y</em> in <em>N</em>, one writes</p>
<dl>
<dd><em>x</em> ⊗ <em>y</em>
</dd>
</dl>

<p>for the image of (<em>x</em>, <em>y</em>) under the canonical map 

<math display="inline" id="Tensor_product_of_modules:10">
 <semantics>
  <mrow>
   <mo>⊗</mo>
   <mo>:</mo>
   <mi>M</mi>
   <mo>×</mo>
   <mi>N</mi>
   <mo>→</mo>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">M</csymbol>
    <times></times>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">M</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <csymbol cd="unknown">N</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes:M\times N\to M\otimes_{R}N
  </annotation>
 </semantics>
</math>

. It is often called a <a href="pure_tensor" title="wikilink">pure tensor</a>. Strictly speaking, the correct notation would be <em>x</em> ⊗<sub><em>R</em></sub> <em>y</em> but it is conventional to drop <em>R</em> here. Then, immediately from the definition, there are relations:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>x</em> ⊗ (<em>y</em> + <em>y</em>′) = <em>x</em> ⊗ <em>y</em> + <em>x</em> ⊗ <em>y</em>′</p></td>
<td style="text-align: left;">
<p>(Dl<sub>⊗</sub>)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>(<em>x</em> + <em>x</em>′) ⊗ <em>y</em> = <em>x</em> ⊗ <em>y</em> + <em>x</em>′ ⊗ <em>y</em></p></td>
<td style="text-align: left;">
<p>(Dr<sub>⊗</sub>)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>(<em>x</em> ⋅ <em>r</em>) ⊗ <em>y</em> = <em>x</em> ⊗ (<em>r</em> ⋅ <em>y</em>)</p></td>
<td style="text-align: left;">
<p>(A<sub>⊗</sub>)</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>The universal property of a tensor product has the following important consequence:  Proof: For the first statement, let <em>L</em> be the subgroup of 

<math display="inline" id="Tensor_product_of_modules:11">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N
  </annotation>
 </semantics>
</math>

 generated by elements of the form in question, 

<math display="inline" id="Tensor_product_of_modules:12">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=(M\otimes_{R}N)/L
  </annotation>
 </semantics>
</math>

 and <em>q</em> the quotient map to <em>Q</em>. We have

<math display="block" id="Tensor_product_of_modules:13">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>=</mo>
   <mi>q</mi>
   <mo>∘</mo>
   <mo>⊗</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cn type="integer">0</cn>
    <eq></eq>
    <csymbol cd="unknown">q</csymbol>
    <compose></compose>
    <csymbol cd="latexml">tensor-product</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=q\circ\otimes
  </annotation>
 </semantics>
</math>

 as well as 

<math display="inline" id="Tensor_product_of_modules:14">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>=</mo>
   <mn>0</mn>
   <mo>∘</mo>
   <mo>⊗</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cn type="integer">0</cn>
    <eq></eq>
    <cn type="integer">0</cn>
    <compose></compose>
    <csymbol cd="latexml">tensor-product</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=0\circ\otimes
  </annotation>
 </semantics>
</math>

. Hence, by the uniqueness part of the universal property, <em>q</em> = 0. The second statement is because to define a <a href="module_homomorphism" title="wikilink">module homomorphism</a>, it is enough to define it on the generating set of the module. 

<math display="inline" id="Tensor_product_of_modules:15">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

</p>

<p>The proposition says that one can work with explicit elements of the tensor products instead of invoking the universal property directly each time. This is very convenient in practice. For example, if <em>R</em> is commutative, then 

<math display="inline" id="Tensor_product_of_modules:16">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N
  </annotation>
 </semantics>
</math>

 can naturally be furnished with the <em>R</em>-scalar multiplication by extending</p>

<p>

<math display="block" id="Tensor_product_of_modules:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>⊗</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mi>r</mi>
     <mi>x</mi>
    </mrow>
    <mo>⊗</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>⊗</mo>
     <mi>r</mi>
    </mrow>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <ci>r</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>x</ci>
       <ci>r</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\cdot(x\otimes y):=rx\otimes y=x\otimes ry
  </annotation>
 </semantics>
</math>

, to the whole 

<math display="inline" id="Tensor_product_of_modules:18">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N
  </annotation>
 </semantics>
</math>


 by the previous proposition (strictly speaking, what is needed is a bimodule structure not commutativity; see a paragraph below). Equipped with this <em>R</em>-module structure, 

<math display="inline" id="Tensor_product_of_modules:19">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N
  </annotation>
 </semantics>
</math>

 satisfies a universal property similar to the above: for any <em>R</em>-module <em>G</em>, there is a natural isomorphism:</p>

<p>

<math display="block" id="Tensor_product_of_modules:20">
 <semantics>
  <mrow>
   <msub>
    <mo>Hom</mo>
    <mi>R</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>N</mi>
    <mo>,</mo>
    <mi>G</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≃</mo>
   <mo stretchy="false">{</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Hom</ci>
     <ci>R</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <ci>normal-{</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}_{R}(M\otimes_{R}N,G)\simeq\{
  </annotation>
 </semantics>
</math>

 <em>R</em>-bilinear maps from 

<math display="inline" id="Tensor_product_of_modules:21">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\times N
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Tensor_product_of_modules:22">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo stretchy="false">}</mo>
   <mo rspace="4.2pt">,</mo>
   <mi>g</mi>
   <mo>↦</mo>
   <mi>g</mi>
   <mo>∘</mo>
   <mo>⊗</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">G</csymbol>
    <ci>normal-}</ci>
    <ci>normal-,</ci>
    <csymbol cd="unknown">g</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <compose></compose>
    <csymbol cd="latexml">tensor-product</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\},\,g\mapsto g\circ\otimes
  </annotation>
 </semantics>
</math>

.</p>

<p>If <em>R</em> is not necessarily commutative but if <em>M</em> has a left action by a ring <em>S</em> (for example, <em>R</em>), then 

<math display="inline" id="Tensor_product_of_modules:23">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N
  </annotation>
 </semantics>
</math>


 can be given the left <em>S</em>-module structure, like above, by the formula</p>

<p>

<math display="block" id="Tensor_product_of_modules:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>⊗</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mi>x</mi>
    </mrow>
    <mo>⊗</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <ci>normal-⋅</ci>
     <ci>s</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\cdot(x\otimes y):=sx\otimes y
  </annotation>
 </semantics>
</math>

. If <em>N</em> has a right action by a ring <em>S</em>, then, in the analogous way, 

<math display="inline" id="Tensor_product_of_modules:25">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N
  </annotation>
 </semantics>
</math>

 becomes a right <em>S</em>-module.</p>
<h3 id="tensor-product-of-linear-maps-and-a-change-of-base-ring">Tensor product of linear maps and a change of base ring</h3>

<p>Given linear maps 

<math display="inline" id="Tensor_product_of_modules:26">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>M</mi>
    <mo>→</mo>
    <msup>
     <mi>M</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>M</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:M\to M^{\prime}
  </annotation>
 </semantics>
</math>

 of right modules over a ring <em>R</em> and 

<math display="inline" id="Tensor_product_of_modules:27">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mi>N</mi>
    <mo>→</mo>
    <msup>
     <mi>N</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:N\to N^{\prime}
  </annotation>
 </semantics>
</math>

 of left modules, there is a unique group homomorphism</p>

<p>

<math display="block" id="Tensor_product_of_modules:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>⊗</mo>
    <mi>g</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>M</mi>
     <msub>
      <mo>⊗</mo>
      <mi>R</mi>
     </msub>
     <mi>N</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msup>
      <mi>M</mi>
      <mo>′</mo>
     </msup>
     <msub>
      <mo>⊗</mo>
      <mi>R</mi>
     </msub>
     <msup>
      <mi>N</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>f</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>M</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\otimes g:M\otimes_{R}N\to M^{\prime}\otimes_{R}N^{\prime}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Tensor_product_of_modules:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>⊗</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>⊗</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <mi>g</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <ci>g</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f\otimes g)(x\otimes y)=f(x)\otimes g(y)
  </annotation>
 </semantics>
</math>

.</p>

<p>The construction has a consequence that tensoring is a functor: each right <em>R</em>-module <em>M</em> determines the functor</p>

<p>

<math display="block" id="Tensor_product_of_modules:30">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mo>-</mo>
   <mo>:</mo>
   <mi>R</mi>
   <mo>-</mo>
   <mi>𝐌𝐨𝐝</mi>
   <mo>→</mo>
   <mi>𝐀𝐛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">M</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <minus></minus>
    <ci>normal-:</ci>
    <csymbol cd="unknown">R</csymbol>
    <minus></minus>
    <csymbol cd="unknown">Mod</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">Ab</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}-:R-\mathbf{Mod}\to\mathbf{Ab}
  </annotation>
 </semantics>
</math>

 from the <a href="category_of_modules" title="wikilink">category of left modules</a> to the category of abelian groups that sends <em>N</em> to  and a module homomorphism <em>f</em> to the group homomorphism .</p>

<p>If 

<math display="inline" id="Tensor_product_of_modules:31">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>R</mi>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>R</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:R\to S
  </annotation>
 </semantics>
</math>

 is a ring homomorphism and if <em>M</em> is a right <em>S</em>-module and <em>N</em> a left <em>S</em>-module, then there is the canonical <em>surjective</em> homomorphism:</p>

<p>

<math display="block" id="Tensor_product_of_modules:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>N</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>S</mi>
    </msub>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>S</ci>
     </apply>
     <ci>M</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N\to M\otimes_{S}N
  </annotation>
 </semantics>
</math>

 induced by 

<math display="inline" id="Tensor_product_of_modules:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mo>×</mo>
     <mi>N</mi>
    </mrow>
    <mover accent="true">
     <mo>→</mo>
     <msub>
      <mo>⊗</mo>
      <mi>S</mi>
     </msub>
    </mover>
    <mi>M</mi>
   </mrow>
   <msub>
    <mo>⊗</mo>
    <mi>S</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>S</ci>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\times N\overset{\otimes_{S}}{\to}M\otimes_{S}N
  </annotation>
 </semantics>
</math>


.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> (The resulting map is surjective since pure tensors  generate the whole module.) In particular, taking <em>R</em> to be <strong>Z</strong>, this shows every tensor product of modules is a quotient of a tensor product of abelian groups.</p>

<p>See also: .</p>
<h3 id="several-modules">Several modules</h3>

<p>(This section need to be updated. For now, see  for the more general discussion.)</p>

<p>It is possible to extend the definition to a tensor product of any number of modules over the same commutative ring. For example, the universal property of</p>
<dl>
<dd><em>M</em><sub>1</sub> ⊗ <em>M</em><sub>2</sub> ⊗ <em>M</em><sub>3</sub>
</dd>
</dl>

<p>is that each trilinear map on</p>
<dl>
<dd><em>M</em><sub>1</sub> × <em>M</em><sub>2</sub> × <em>M</em><sub>3</sub> → <em>Z</em>
</dd>
</dl>

<p>corresponds to a unique linear map</p>
<dl>
<dd><em>M</em><sub>1</sub> ⊗ <em>M</em><sub>2</sub> ⊗ <em>M</em><sub>3</sub> → <em>Z</em>.
</dd>
</dl>

<p>The binary tensor product is associative: (<em>M</em><sub>1</sub> ⊗ <em>M</em><sub>2</sub>) ⊗ <em>M</em><sub>3</sub> is naturally isomorphic to <em>M</em><sub>1</sub> ⊗ (<em>M</em><sub>2</sub> ⊗ <em>M</em><sub>3</sub>). The tensor product of three modules defined by the universal property of trilinear maps is isomorphic to both of these iterated tensor products.</p>
<h2 id="properties">Properties</h2>

<p>Let <em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, <em>R</em><sub>3</sub>, <em>R</em> be rings, not necessarily commutative.</p>
<ul>
<li>For a <em>R</em><sub>1</sub>-<em>R</em><sub>2</sub>-<a class="uri" href="bimodule" title="wikilink">bimodule</a> <em>M</em><sub>12</sub> and a left <em>R</em><sub>2</sub>-module <em>M</em><sub>20</sub> the tensor product</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:34">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>12</mn>
   </msub>
   <msub>
    <mo>⊗</mo>
    <msub>
     <mi>R</mi>
     <mn>2</mn>
    </msub>
   </msub>
   <msub>
    <mi>M</mi>
    <mn>20</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">12</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">20</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{12}\otimes_{R_{2}}M_{20}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>is a left <em>R</em><sub>1</sub>-module.
</dd>
</dl>
<ul>
<li>For a right <em>R</em><sub>2</sub>-module <em>M</em><sub>02</sub> and an <em>R</em><sub>2</sub>-<em>R</em><sub>3</sub>-<a class="uri" href="bimodule" title="wikilink">bimodule</a> <em>M</em><sub>23</sub> the tensor product</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:35">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>02</mn>
   </msub>
   <msub>
    <mo>⊗</mo>
    <msub>
     <mi>R</mi>
     <mn>2</mn>
    </msub>
   </msub>
   <msub>
    <mi>M</mi>
    <mn>23</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">02</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">23</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{02}\otimes_{R_{2}}M_{23}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>is a right <em>R</em><sub>3</sub>-module.
</dd>
</dl>
<ul>
<li>(associativity) For a right <em>R</em><sub>1</sub>-module <em>M</em><sub>01</sub>, an <em>R</em><sub>1</sub>-<em>R</em><sub>2</sub>-bimodule <em>M</em><sub>12</sub>, and a left <em>R</em><sub>2</sub>-module <em>M</em><sub>20</sub> we have</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>M</mi>
       <mn>01</mn>
      </msub>
      <msub>
       <mo>⊗</mo>
       <msub>
        <mi>R</mi>
        <mn>1</mn>
       </msub>
      </msub>
      <msub>
       <mi>M</mi>
       <mn>12</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mo>⊗</mo>
     <msub>
      <mi>R</mi>
      <mn>2</mn>
     </msub>
    </msub>
    <msub>
     <mi>M</mi>
     <mn>20</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mn>01</mn>
    </msub>
    <msub>
     <mo>⊗</mo>
     <msub>
      <mi>R</mi>
      <mn>1</mn>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>M</mi>
       <mn>12</mn>
      </msub>
      <msub>
       <mo>⊗</mo>
       <msub>
        <mi>R</mi>
        <mn>2</mn>
       </msub>
      </msub>
      <msub>
       <mi>M</mi>
       <mn>20</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">01</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">12</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">20</cn>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">01</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">12</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <cn type="integer">20</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M_{01}\otimes_{R_{1}}M_{12})\otimes_{R_{2}}M_{20}=M_{01}\otimes_{R_{1}}(M_{12%
}\otimes_{R_{2}}M_{20})
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>Since <em>R</em> is an <em>R</em>-<em>R</em>-bimodule, we have the tensor product</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>R</ci>
     <ci>R</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\otimes_{R}R=R
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>with the ring multiplication

<p>

<math display="block" id="Tensor_product_of_modules:38">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>n</mi>
   <mo>=</mo>
   <mo>:</mo>
   <mi>m</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <eq></eq>
    <ci>normal-:</ci>
    <csymbol cd="unknown">m</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <csymbol cd="unknown">n</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   mn=:m\otimes_{R}n
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>as its canonical balanced product.
</dd>
</dl>

<p>Let <em>R</em> be a commutative ring, and <em>M</em>, <em>N</em> and <em>P</em> be <em>R</em>-modules. Then</p>
<ul>
<li>(identity)</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>R</ci>
     <ci>M</ci>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\otimes_{R}M=M
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>(associativity)</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>N</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M\otimes_{R}N)\otimes_{R}P=M\otimes_{R}(N\otimes_{R}P)
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a>
</dd>
</dl>
</dd>
<dd>Thus

<p>

<math display="block" id="Tensor_product_of_modules:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>N</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>P</mi>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <ci>N</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>N</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N\otimes_{R}P:=M\otimes_{R}(N\otimes_{R}P)
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>is well-defined.
</dd>
</dl>
<ul>
<li>(symmetry)</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>N</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>N</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N=N\otimes_{R}M
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>In fact, for any permutation σ of the set { 1, 2, …, <em>n</em> }, there is a unique isomorphism

<p>

<math display="block" id="Tensor_product_of_modules:43">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>M</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi mathvariant="normal">⋯</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <msub>
     <mi>M</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi mathvariant="normal">⋯</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <msub>
     <mi>M</mi>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <ci>σ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{1}\otimes_{R}\cdots\otimes_{R}M_{n}\to M_{\sigma(1)}\otimes_{R}\cdots%
\otimes_{R}M_{\sigma(n)}
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>under which 

<math display="inline" id="Tensor_product_of_modules:44">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>⊗</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>⊗</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\otimes\cdots\otimes x_{n}
  </annotation>
 </semantics>
</math>

 maps to 

<math display="inline" id="Tensor_product_of_modules:45">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <mo>⊗</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>⊗</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>σ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>σ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\sigma(1)}\otimes\cdots\otimes x_{\sigma(n)}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<ul>
<li>(distributive property)</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>⊕</mo>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>N</ci>
      <ci>P</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}(N\oplus P)=(M\otimes_{R}N)\oplus(M\otimes_{R}P)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>In fact,

<p>

<math display="block" id="Tensor_product_of_modules:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <munder>
       <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
       <mrow>
        <mi>i</mi>
        <mo>∈</mo>
        <mi>I</mi>
       </mrow>
      </munder>
      <msub>
       <mi>N</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>I</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>M</mi>
     <msub>
      <mo>⊗</mo>
      <mi>R</mi>
     </msub>
     <msub>
      <mi>N</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}(\bigoplus_{i\in I}N_{i})=\bigoplus_{i\in I}M\otimes_{R}N_{i}
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>for an <a href="index_set" title="wikilink">index set</a> <em>I</em> of arbitrary <a class="uri" href="cardinality" title="wikilink">cardinality</a>.
</dd>
</dl>
<ul>
<li>(commutes with finite product) for any finitely many 

<math display="inline" id="Tensor_product_of_modules:48">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i}
  </annotation>
 </semantics>
</math>


,</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∏</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <msub>
      <mi>N</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mi>M</mi>
     <msub>
      <mo>⊗</mo>
      <mi>R</mi>
     </msub>
     <msub>
      <mi>N</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}\prod_{i=1}^{n}N_{i}=\prod_{i=1}^{n}M\otimes_{R}N_{i}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>(commutes with <a href="localization_of_a_module" title="wikilink">localization</a>) for any multiplicatively closed subset <em>S</em> of <em>R</em>,</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:50">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>S</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>S</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>M</mi>
     </mrow>
     <msub>
      <mo>⊗</mo>
      <mrow>
       <msup>
        <mi>S</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mi>R</mi>
      </mrow>
     </msub>
     <msup>
      <mi>S</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>R</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>S</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{-1}(M\otimes_{R}N)=S^{-1}M\otimes_{S^{-1}R}S^{-1}N
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>as 

<math display="inline" id="Tensor_product_of_modules:51">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{-1}R
  </annotation>
 </semantics>
</math>

-module. Since 

<math display="inline" id="Tensor_product_of_modules:52">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{-1}R
  </annotation>
 </semantics>
</math>

 is an <em>R</em>-algebra and 

<math display="inline" id="Tensor_product_of_modules:53">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>-</mo>
   <mo>=</mo>
   <msup>
    <mi>S</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>R</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mo>-</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <minus></minus>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">R</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <minus></minus>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{-1}-=S^{-1}R\otimes_{R}-
  </annotation>
 </semantics>
</math>


, this is a special case of:
</dd>
</dl>
<ul>
<li>(commutes with base extension) If <em>S</em> is an <em>R</em>-algebra, writing 

<math display="inline" id="Tensor_product_of_modules:54">
 <semantics>
  <mrow>
   <msub>
    <mo>-</mo>
    <mi>S</mi>
   </msub>
   <mo>=</mo>
   <mi>S</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mo>-</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <minus></minus>
     <ci>S</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">S</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <minus></minus>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -_{S}=S\otimes_{R}-
  </annotation>
 </semantics>
</math>

,</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:55">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>M</mi>
       <msub>
        <mo>⊗</mo>
        <mi>R</mi>
       </msub>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>S</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>M</mi>
      <mi>S</mi>
     </msub>
     <msub>
      <mo>⊗</mo>
      <mi>S</mi>
     </msub>
     <msub>
      <mi>N</mi>
      <mi>S</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M\otimes_{R}N)_{S}=M_{S}\otimes_{S}N_{S};
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a>
</dd>
</dl>
</dd>
<dd>cf. .
</dd>
</dl>
<ul>
<li>(commutes with direct limit) for any direct system of <em>R</em>-modules <em>M</em><sub><em>i</em></sub>,</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:56">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <munder accentunder="true">
        <mo>lim</mo>
        <mo>→</mo>
       </munder>
       <msub>
        <mi>M</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mo>⊗</mo>
      <mi>R</mi>
     </msub>
     <mi>N</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder accentunder="true">
      <mo>lim</mo>
      <mo>→</mo>
     </munder>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>M</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mo>⊗</mo>
        <mi>R</mi>
       </msub>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">injective-limit</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">injective-limit</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>i</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\underrightarrow{\lim}M_{i})\otimes_{R}N=\underrightarrow{\lim}(M_{i}\otimes_%
{R}N).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>(tensoring is right exact) if 

<math display="inline" id="Tensor_product_of_modules:57">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>N</mi>
     <mo>′</mo>
    </msup>
    <mover accent="true">
     <mo>→</mo>
     <mo>𝑓</mo>
    </mover>
    <mi>N</mi>
    <mover accent="true">
     <mo>→</mo>
     <mo>𝑔</mo>
    </mover>
    <msup>
     <mi>N</mi>
     <mi>′′</mi>
    </msup>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <ci>f</ci>
       <ci>normal-→</ci>
      </apply>
      <ci>N</ci>
      <apply>
       <ci>g</ci>
       <ci>normal-→</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <ci>′′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to N^{\prime}\overset{f}{\to}N\overset{g}{\to}N^{\prime\prime}\to 0
  </annotation>
 </semantics>
</math>

 is an exact sequence of <em>R</em>-modules, then</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:58">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi>M</mi>
        <msub>
         <mo>⊗</mo>
         <mi>R</mi>
        </msub>
        <msup>
         <mi>N</mi>
         <mo>′</mo>
        </msup>
       </mrow>
       <mover accent="true">
        <mo>→</mo>
        <mrow>
         <mn>1</mn>
         <mo>⊗</mo>
         <mi>f</mi>
        </mrow>
       </mover>
       <mi>M</mi>
      </mrow>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>N</mi>
     </mrow>
     <mover accent="true">
      <mo>→</mo>
      <mrow>
       <mn>1</mn>
       <mo>⊗</mo>
       <mi>g</mi>
      </mrow>
     </mover>
     <mi>M</mi>
    </mrow>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <msup>
     <mi>N</mi>
     <mi>′′</mi>
    </msup>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>R</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">tensor-product</csymbol>
          <ci>R</ci>
         </apply>
         <ci>M</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>N</ci>
          <ci>normal-′</ci>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="latexml">tensor-product</csymbol>
          <cn type="integer">1</cn>
          <ci>f</ci>
         </apply>
         <ci>normal-→</ci>
        </apply>
        <ci>M</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <cn type="integer">1</cn>
        <ci>g</ci>
       </apply>
       <ci>normal-→</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <ci>′′</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N^{\prime}\overset{1\otimes f}{\to}M\otimes_{R}N\overset{1\otimes g%
}{\to}M\otimes_{R}N^{\prime\prime}\to 0
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
<dd>is an exact sequence of <em>R</em>-modules, where 

<math display="inline" id="Tensor_product_of_modules:59">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>⊗</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>⊗</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mo>⊗</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <cn type="integer">1</cn>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>x</ci>
      <ci>f</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1\otimes f)(x\otimes y)=x\otimes f(y).
  </annotation>
 </semantics>
</math>

 This is a consequence of:
</dd>
</dl>
<ul>
<li>(<a href="tensor-hom_adjunction" title="wikilink">adjoint relation</a>) 

<math display="inline" id="Tensor_product_of_modules:60">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>Hom</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>N</mi>
     </mrow>
     <mo>,</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>Hom</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mo>Hom</mo>
       <mi>R</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>N</mi>
       <mo>,</mo>
       <mi>P</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>R</ci>
      </apply>
      <ci>N</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}_{R}(M\otimes_{R}N,P)=\operatorname{Hom}_{R}(M,\operatorname%
{Hom}_{R}(N,P))
  </annotation>
 </semantics>
</math>

.</li>
<li>(tensor-hom relation) there is a canonical <em>R</em>-linear map:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Tensor_product_of_modules:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mo>Hom</mo>
       <mi>R</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo>,</mo>
       <mi>N</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <mi>P</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>R</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mrow>
       <mi>N</mi>
       <mo>⊗</mo>
       <mi>P</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>N</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}_{R}(M,N)\otimes P\to\operatorname{Hom}_{R}(M,N\otimes P),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>which is an isomorphism if either <em>M</em> or <em>P</em> is a <a href="finitely_generated_projective_module" title="wikilink">finitely generated projective module</a> (see  for the non-commutative case);<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> more generally, there is a canonical <em>R</em>-linear map:

<p>

<math display="block" id="Tensor_product_of_modules:62">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>R</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊗</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>R</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>M</mi>
       <mo>′</mo>
      </msup>
      <mo>,</mo>
      <msup>
       <mi>N</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mo>Hom</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <mo>⊗</mo>
      <msup>
       <mi>M</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>N</mi>
      <mo>⊗</mo>
      <msup>
       <mi>N</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>M</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>M</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}_{R}(M,N)\otimes\operatorname{Hom}_{R}(M^{\prime},N^{\prime}%
)\to\operatorname{Hom}_{R}(M\otimes M^{\prime},N\otimes N^{\prime})
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>which is an isomorphism if either 

<math display="inline" id="Tensor_product_of_modules:63">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>M</mi>
   <mo>,</mo>
   <mi>N</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>M</ci>
    <ci>N</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M,N)
  </annotation>
 </semantics>
</math>


 or 

<math display="inline" id="Tensor_product_of_modules:64">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>M</mi>
   <mo>,</mo>
   <msup>
    <mi>M</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-′</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M,M^{\prime})
  </annotation>
 </semantics>
</math>

 is a pair of finitely generated projective modules.
</dd>
</dl>

<p>To give a practical example, suppose <em>M</em>, <em>N</em> are free modules with bases 

<math display="inline" id="Tensor_product_of_modules:65">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <mi>i</mi>
   </mrow>
   <mo>∈</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>i</ci>
     </apply>
     <ci>i</ci>
    </list>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i},i\in I
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tensor_product_of_modules:66">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>j</mi>
    </msub>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
   <mo>∈</mo>
   <mi>J</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>j</ci>
     </apply>
     <ci>j</ci>
    </list>
    <ci>J</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{j},j\in J
  </annotation>
 </semantics>
</math>

. Then <em>M</em> is the <a href="direct_sum_of_modules" title="wikilink">direct sum</a> 

<math display="inline" id="Tensor_product_of_modules:67">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⊕</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>I</mi>
     </mrow>
    </msub>
    <mrow>
     <mi>R</mi>
     <msub>
      <mi>e</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\bigoplus_{i\in I}Re_{i}
  </annotation>
 </semantics>
</math>

 and the same for <em>N</em>. By the distributive property, one has:</p>

<p>

<math display="block" id="Tensor_product_of_modules:68">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>N</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>e</mi>
        <mi>i</mi>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>f</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N=\bigoplus_{i,j}R(e_{i}\otimes f_{j})
  </annotation>
 </semantics>
</math>

; i.e., 

<math display="inline" id="Tensor_product_of_modules:69">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>e</mi>
       <mi>i</mi>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>f</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo rspace="4.2pt">,</mo>
     <mi>i</mi>
    </mrow>
    <mo>∈</mo>
    <mi>I</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>j</mi>
    <mo>∈</mo>
    <mi>J</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>i</ci>
     </list>
     <ci>I</ci>
    </apply>
    <apply>
     <in></in>
     <ci>j</ci>
     <ci>J</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{i}\otimes f_{j},\,i\in I,j\in J
  </annotation>
 </semantics>
</math>

 are the <em>R</em>-basis of 

<math display="inline" id="Tensor_product_of_modules:70">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N
  </annotation>
 </semantics>
</math>

. Even if <em>M</em> is not free, a <a href="free_presentation" title="wikilink">free presentation</a> of <em>M</em> can be used to compute tensor products.</p>

<p>The tensor product, in general, does not commute with <a href="inverse_limit" title="wikilink">inverse limit</a>: on the one hand,</p>

<p>

<math display="block" id="Tensor_product_of_modules:71">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ℚ</mi>
     <msub>
      <mo>⊗</mo>
      <mi>ℤ</mi>
     </msub>
     <mi>ℤ</mi>
    </mrow>
    <mo>/</mo>
    <msup>
     <mi>p</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ℤ</ci>
      </apply>
      <ci>ℚ</ci>
      <ci>ℤ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}\otimes_{\mathbb{Z}}\mathbb{Z}/p^{n}=0
  </annotation>
 </semantics>
</math>

 (cf. "examples"). On the other hand,</p>

<p>

<math display="block" id="Tensor_product_of_modules:72">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <munder accentunder="true">
       <mo movablelimits="false">lim</mo>
       <mo>←</mo>
      </munder>
      <mrow>
       <mi>ℤ</mi>
       <mo>/</mo>
       <msup>
        <mi>p</mi>
        <mi>n</mi>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mo>⊗</mo>
     <mi>ℤ</mi>
    </msub>
    <mi>ℚ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ℤ</mi>
     <mi>p</mi>
    </msub>
    <msub>
     <mo>⊗</mo>
     <mi>ℤ</mi>
    </msub>
    <mi>ℚ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ℤ</mi>
     <mi>p</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <msup>
      <mi>p</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>ℚ</mi>
    <mi>p</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ℤ</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">projective-limit</csymbol>
       <apply>
        <divide></divide>
        <ci>ℤ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <ci>ℚ</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ℤ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℤ</ci>
       <ci>p</ci>
      </apply>
      <ci>ℚ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℤ</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℚ</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\underleftarrow{\lim}\mathbb{Z}/p^{n})\otimes_{\mathbb{Z}}\mathbb{Q}=\mathbb{%
Z}_{p}\otimes_{\mathbb{Z}}\mathbb{Q}=\mathbb{Z}_{p}[p^{-1}]=\mathbb{Q}_{p}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Tensor_product_of_modules:73">
 <semantics>
  <mrow>
   <msub>
    <mi>ℤ</mi>
    <mi>p</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>ℚ</mi>
    <mi>p</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℤ</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℚ</ci>
     <ci>p</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{p},\mathbb{Q}_{p}
  </annotation>
 </semantics>
</math>


 are the <a href="ring_of_p-adic_integers" title="wikilink">ring of p-adic integers</a> and the <a href="field_of_p-adic_numbers" title="wikilink">field of p-adic numbers</a>. See also "<a href="profinite_integer" title="wikilink">profinite integer</a>" for an example in the similar spirit.</p>

<p>If <em>R</em> is not commutative, the order of tensor products could matter in the following way: we "use up" the right action of <em>M</em> and the left action of <em>N</em> to form the tensor product 

<math display="inline" id="Tensor_product_of_modules:74">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N
  </annotation>
 </semantics>
</math>

; in particular, 

<math display="inline" id="Tensor_product_of_modules:75">
 <semantics>
  <mrow>
   <mi>N</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>N</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\otimes_{R}M
  </annotation>
 </semantics>
</math>

 would not even be defined. If <em>M</em>, <em>N</em> are bi-modules, then 

<math display="inline" id="Tensor_product_of_modules:76">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N
  </annotation>
 </semantics>
</math>

 has the left action coming from the left action of <em>M</em> and the right action coming from the right action of <em>N</em>; those actions need not be the same as the left and right actions of 

<math display="inline" id="Tensor_product_of_modules:77">
 <semantics>
  <mrow>
   <mi>N</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>N</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\otimes_{R}M
  </annotation>
 </semantics>
</math>

.</p>

<p>The associativity holds more generally for non-commutative rings: if <em>M</em> is a right <em>R</em>-module, <em>N</em> a (<em>R</em>, <em>S</em>)-module and <em>P</em> a left <em>S</em>-module, then</p>

<p>

<math display="block" id="Tensor_product_of_modules:78">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mo>⊗</mo>
     <mi>S</mi>
    </msub>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <msub>
       <mo>⊗</mo>
       <mi>S</mi>
      </msub>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>S</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>S</ci>
      </apply>
      <ci>N</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M\otimes_{R}N)\otimes_{S}P=M\otimes_{R}(N\otimes_{S}P)
  </annotation>
 </semantics>
</math>

 as abelian group.</p>

<p>The general form of adjoint relation of tensor products says: if <em>R</em> is not necessarily commutative, <em>M</em> is a right <em>R</em>-module, <em>N</em> is a (<em>R</em>, <em>S</em>)-module, <em>P</em> is a right <em>S</em>-module, then as abelian group</p>

<p>

<math display="block" id="Tensor_product_of_modules:79">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>M</mi>
       <msub>
        <mo>⊗</mo>
        <mi>R</mi>
       </msub>
       <mi>N</mi>
      </mrow>
      <mo>,</mo>
      <mi>P</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>R</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mrow>
       <msub>
        <mo>Hom</mo>
        <mi>S</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>N</mi>
        <mo>,</mo>
        <mi>P</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mi>f</mi>
    <mo>↦</mo>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>R</ci>
       </apply>
       <ci>M</ci>
       <ci>N</ci>
      </apply>
      <ci>P</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Hom</ci>
        <ci>S</ci>
       </apply>
       <ci>N</ci>
       <ci>P</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}_{S}(M\otimes_{R}N,P)=\operatorname{Hom}_{R}(M,\operatorname%
{Hom}_{S}(N,P)),\,f\mapsto f^{\prime}
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> where 

<math display="inline" id="Tensor_product_of_modules:80">
 <semantics>
  <msup>
   <mi>f</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}
  </annotation>
 </semantics>
</math>

 is given by 

<math display="inline" id="Tensor_product_of_modules:81">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>⊗</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)(y)=f(x\otimes y).
  </annotation>
 </semantics>
</math>

 See also: <a href="tensor-hom_adjunction" title="wikilink">tensor-hom adjunction</a>.</p>
<h3 id="extension-of-scalars">Extension of scalars</h3>

<p>The adjoint relation in the general form has an important special case: for any <em>R</em>-algebra <em>S</em>, <em>M</em> a right <em>R</em>-module, <em>P</em> a right <em>S</em>-module, using 

<math display="inline" id="Tensor_product_of_modules:82">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>Hom</mo>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mo>-</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>-</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <ci>S</ci>
     </apply>
     <ci>S</ci>
     <minus></minus>
    </apply>
    <minus></minus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}_{S}(S,-)=-
  </annotation>
 </semantics>
</math>

, we have the natural isomorphism:</p>

<p>

<math display="block" id="Tensor_product_of_modules:83">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>S</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>M</mi>
       <msub>
        <mo>⊗</mo>
        <mi>R</mi>
       </msub>
       <mi>S</mi>
      </mrow>
      <mo>,</mo>
      <mi>P</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>R</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mrow>
       <msub>
        <mo>Res</mo>
        <mi>R</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>P</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>S</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Res</ci>
       <ci>R</ci>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}_{S}(M\otimes_{R}S,P)=\operatorname{Hom}_{R}(M,\operatorname%
{Res}_{R}(P)).
  </annotation>
 </semantics>
</math>

 This says that the functor 

<math display="inline" id="Tensor_product_of_modules:84">
 <semantics>
  <mrow>
   <mo>-</mo>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <csymbol cd="unknown">S</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\otimes_{R}S
  </annotation>
 </semantics>
</math>

 is a <a href="left_adjoint" title="wikilink">left adjoint</a> to the forgetful functor 

<math display="inline" id="Tensor_product_of_modules:85">
 <semantics>
  <msub>
   <mo>Res</mo>
   <mi>R</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Res</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Res}_{R}
  </annotation>
 </semantics>
</math>

, which restricts an <em>S</em>-action to an <em>R</em>-action. Because of this, 

<math display="inline" id="Tensor_product_of_modules:86">
 <semantics>
  <mrow>
   <mo>-</mo>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <csymbol cd="unknown">S</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\otimes_{R}S
  </annotation>
 </semantics>
</math>

 is often called the <a href="extension_of_scalars" title="wikilink">extension of scalars</a> from <em>R</em> to <em>S</em>. In the <a href="representation_theory" title="wikilink">representation theory</a>, when <em>R</em>, <em>S</em> are group algebras, the above relation becomes the <a href="Frobenius_reciprocity" title="wikilink">Frobenius reciprocity</a>.</p>

<p>Example

<math display="block" id="Tensor_product_of_modules:87">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>R</mi>
     <mi>n</mi>
    </msup>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>S</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>S</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>n</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{n}\otimes_{R}S=S^{n}
  </annotation>
 </semantics>
</math>

 for any <em>R</em>-algebra <em>S</em> (i.e., a free module remains free after extending scalars.)</p>

<p>Example: For a commutative ring 

<math display="inline" id="Tensor_product_of_modules:88">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>


 and a commutative <em>R</em>-algebra <em>S</em>, we have:</p>
<ul>
<li>

<math display="inline" id="Tensor_product_of_modules:89">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <msub>
      <mo>⊗</mo>
      <mi>R</mi>
     </msub>
     <mi>R</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>S</ci>
      <ci>R</ci>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>S</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\otimes_{R}R[x_{1},\dots,x_{n}]=S[x_{1},\dots,x_{n}]
  </annotation>
 </semantics>
</math>

; in fact, more generally,</li>
<li>

<math display="inline" id="Tensor_product_of_modules:90">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>R</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <mi>I</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <mi>I</mi>
     </mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo rspace="4.2pt">,</mo>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>S</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>R</ci>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </list>
      </apply>
      <ci>I</ci>
     </apply>
    </apply>
    <list>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>S</ci>
        <list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
        </list>
       </apply>
       <ci>I</ci>
      </apply>
      <ci>S</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </list>
     </apply>
     <ci>I</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\otimes_{R}(R[x_{1},\dots,x_{n}]/I)=S[x_{1},\dots,x_{n}]/IS[x_{1},\dots,x_{n}%
],\,I
  </annotation>
 </semantics>
</math>

 an ideal.</li>
</ul>

<p>Example: Using the fact 

<math display="inline" id="Tensor_product_of_modules:91">
 <semantics>
  <mrow>
   <mi>ℂ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>ℝ</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ℂ</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>ℝ</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}=\mathbb{R}[x]/(x^{2}+1)
  </annotation>
 </semantics>
</math>

, by the previous example and the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a>, we have: as ring</p>

<p>

<math display="block" id="Tensor_product_of_modules:92">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℂ</mi>
    <msub>
     <mo>⊗</mo>
     <mi>ℝ</mi>
    </msub>
    <mi>ℂ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>ℂ</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi>ℂ</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>x</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo>/</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>+</mo>
         <mi mathvariant="normal">i</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>×</mo>
      <mi>ℂ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi mathvariant="normal">i</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>ℂ</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ℝ</ci>
      </apply>
      <ci>ℂ</ci>
      <ci>ℂ</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>ℂ</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>ℂ</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <ci>x</ci>
          </apply>
         </apply>
         <apply>
          <plus></plus>
          <ci>x</ci>
          <ci>normal-i</ci>
         </apply>
        </apply>
        <ci>ℂ</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>normal-i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}\otimes_{\mathbb{R}}\mathbb{C}=\mathbb{C}[x]/(x^{2}+1)=\mathbb{C}[x]%
/(x+\mathrm{i})\times\mathbb{C}[x]/(x-\mathrm{i})=\mathbb{C}^{2}
  </annotation>
 </semantics>
</math>

 (this gives an example when a tensor product is a <a href="direct_product" title="wikilink">direct product</a>.)</p>

<p>Example

<math display="block" id="Tensor_product_of_modules:93">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ℝ</mi>
     <msub>
      <mo>⊗</mo>
      <mi>ℤ</mi>
     </msub>
     <mi>ℤ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi mathvariant="normal">i</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ℂ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi mathvariant="normal">i</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>ℂ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>ℤ</ci>
       </apply>
       <ci>ℝ</ci>
       <ci>ℤ</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>normal-i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>ℂ</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>normal-i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>ℂ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}\otimes_{\mathbb{Z}}\mathbb{Z}[\mathrm{i}]=\mathbb{C}[\mathrm{i}]=%
\mathbb{C}
  </annotation>
 </semantics>
</math>

 where <strong>i</strong> is the <a href="imaginary_unit" title="wikilink">imaginary unit</a>.</p>

<p>See also: <a href="Weil_restriction" title="wikilink">Weil restriction</a>.</p>
<h2 id="examples">Examples</h2>

<p>Let <em>G</em> be an abelian group in which every element has finite order (that is <em>G</em> is a <a href="torsion_abelian_group" title="wikilink">torsion abelian group</a>; for example <em>G</em> can be a finite abelian group or <strong>Q</strong>/<strong>Z</strong>). Then</p>

<p>

<math display="block" id="Tensor_product_of_modules:94">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℚ</mi>
    <msub>
     <mo>⊗</mo>
     <mi>ℤ</mi>
    </msub>
    <mi>G</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>ℤ</ci>
     </apply>
     <ci>ℚ</ci>
     <ci>G</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}\otimes_{\mathbb{Z}}G=0
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Indeed, any element <em>x</em> of 

<math display="inline" id="Tensor_product_of_modules:95">
 <semantics>
  <mrow>
   <mi>ℚ</mi>
   <msub>
    <mo>⊗</mo>
    <mi>ℤ</mi>
   </msub>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>ℤ</ci>
    </apply>
    <ci>ℚ</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}\otimes_{\mathbb{Z}}G
  </annotation>
 </semantics>
</math>

 is of the form</p>

<p>

<math display="block" id="Tensor_product_of_modules:96">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mi>g</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\sum_{i}r_{i}\otimes g_{i}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Tensor_product_of_modules:97">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
    <mo>∈</mo>
    <mi>ℚ</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>i</mi>
    </msub>
    <mo>∈</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <ci>ℚ</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>i</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}\in\mathbb{Q},g_{i}\in G
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Tensor_product_of_modules:98">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}
  </annotation>
 </semantics>
</math>


 is the order of 

<math display="inline" id="Tensor_product_of_modules:99">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}
  </annotation>
 </semantics>
</math>

, then we compute:</p>

<p>

<math display="block" id="Tensor_product_of_modules:100">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>r</mi>
         <mi>i</mi>
        </msub>
        <mo>/</mo>
        <msub>
         <mi>n</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>n</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>⊗</mo>
     <msub>
      <mi>g</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>r</mi>
        <mi>i</mi>
       </msub>
       <mo>/</mo>
       <msub>
        <mi>n</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo>⊗</mo>
      <msub>
       <mi>n</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <msub>
      <mi>g</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <apply>
      <sum></sum>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <sum></sum>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\sum(r_{i}/n_{i})n_{i}\otimes g_{i}=\sum r_{i}/n_{i}\otimes n_{i}g_{i}=0.
  </annotation>
 </semantics>
</math>

 Similarly, one sees</p>

<p>

<math display="block" id="Tensor_product_of_modules:101">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>ℚ</mi>
      <mo>/</mo>
      <mi>ℤ</mi>
     </mrow>
     <msub>
      <mo>⊗</mo>
      <mi>ℤ</mi>
     </msub>
     <mi>ℚ</mi>
    </mrow>
    <mo>/</mo>
    <mi>ℤ</mi>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ℤ</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>ℚ</ci>
       <ci>ℤ</ci>
      </apply>
      <ci>ℚ</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}/\mathbb{Z}\otimes_{\mathbb{Z}}\mathbb{Q}/\mathbb{Z}=0.
  </annotation>
 </semantics>
</math>

</p>

<p>Here are some useful identities: Let <em>R</em> be a commutative ring, <em>I</em>, <em>J</em> ideals, <em>M</em>, <em>N</em> <em>R</em>-modules. Then</p>
<ol>
<li>

<math display="inline" id="Tensor_product_of_modules:102">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mo>/</mo>
     <mi>I</mi>
    </mrow>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mo>/</mo>
     <mi>I</mi>
    </mrow>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>R</ci>
      <ci>I</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>M</ci>
      <ci>I</ci>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R/I\otimes_{R}M=M/IM
  </annotation>
 </semantics>
</math>

. If <em>M</em> is <a href="flat_module" title="wikilink">flat</a>, 

<math display="inline" id="Tensor_product_of_modules:103">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>I</mi>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <ci>I</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IM=I\otimes_{R}M
  </annotation>
 </semantics>
</math>


.</li>
<li>

<math display="inline" id="Tensor_product_of_modules:104">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mi>M</mi>
         <mo>/</mo>
         <mi>I</mi>
        </mrow>
        <mi>M</mi>
       </mrow>
       <msub>
        <mo>⊗</mo>
        <mrow>
         <mi>R</mi>
         <mo>/</mo>
         <mi>I</mi>
        </mrow>
       </msub>
       <mi>N</mi>
      </mrow>
      <mo>/</mo>
      <mi>I</mi>
     </mrow>
     <mi>N</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>M</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>N</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>R</mi>
     </mrow>
     <mo>/</mo>
     <mi>I</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <divide></divide>
         <ci>R</ci>
         <ci>I</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <ci>M</ci>
         <ci>I</ci>
        </apply>
        <ci>M</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>I</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
      <ci>N</ci>
      <ci>R</ci>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M/IM\otimes_{R/I}N/IN=M\otimes_{R}N\otimes_{R}R/I.
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Tensor_product_of_modules:105">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>R</mi>
      <mo>/</mo>
      <mi>I</mi>
     </mrow>
     <msub>
      <mo>⊗</mo>
      <mi>R</mi>
     </msub>
     <mi>R</mi>
    </mrow>
    <mo>/</mo>
    <mi>J</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>I</mi>
      <mo>+</mo>
      <mi>J</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>R</ci>
       <ci>I</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <ci>J</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>R</ci>
     <apply>
      <plus></plus>
      <ci>I</ci>
      <ci>J</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R/I\otimes_{R}R/J=R/(I+J)
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Proof: Tensoring with <em>M</em> the exact sequence 

<math display="inline" id="Tensor_product_of_modules:106">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>I</mi>
   <mo>→</mo>
   <mi>R</mi>
   <mo>→</mo>
   <mrow>
    <mi>R</mi>
    <mo>/</mo>
    <mi>I</mi>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>I</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>R</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <ci>R</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to I\to R\to R/I\to 0
  </annotation>
 </semantics>
</math>

 gives</p>

<p>

<math display="block" id="Tensor_product_of_modules:107">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>I</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>M</mi>
     </mrow>
     <mover accent="true">
      <mo>→</mo>
      <mo>𝑓</mo>
     </mover>
     <mi>R</mi>
    </mrow>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mi>M</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mo>/</mo>
     <mi>I</mi>
    </mrow>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">tensor-product</csymbol>
         <ci>R</ci>
        </apply>
        <ci>I</ci>
        <ci>M</ci>
       </apply>
       <apply>
        <ci>f</ci>
        <ci>normal-→</ci>
       </apply>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>R</ci>
       <ci>I</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\otimes_{R}M\overset{f}{\to}R\otimes_{R}M=M\to R/I\otimes_{R}M\to 0
  </annotation>
 </semantics>
</math>

 where <em>f</em> is given by 

<math display="inline" id="Tensor_product_of_modules:108">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>⊗</mo>
    <mi>x</mi>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mi>i</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>i</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\otimes x\mapsto ix
  </annotation>
 </semantics>
</math>


. Since the image of <em>f</em> is <em>IM</em>, we get the first part of 1. If <em>M</em> is flat, <em>f</em> is injective and so is an isomorphism onto its image. 2. follows from 1. and 3. is because</p>

<p>

<math display="block" id="Tensor_product_of_modules:109">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>R</mi>
      <mo>/</mo>
      <mi>I</mi>
     </mrow>
     <msub>
      <mo>⊗</mo>
      <mi>R</mi>
     </msub>
     <mi>R</mi>
    </mrow>
    <mo>/</mo>
    <mi>J</mi>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>R</mi>
     <mo>/</mo>
     <mi>J</mi>
    </mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>R</mi>
       <mo>/</mo>
       <mi>J</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>R</mi>
     <mo>/</mo>
     <mi>J</mi>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>I</mi>
       <mo>+</mo>
       <mi>J</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mi>J</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>I</mi>
      <mo>+</mo>
      <mi>J</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>R</ci>
       </apply>
       <apply>
        <divide></divide>
        <ci>R</ci>
        <ci>I</ci>
       </apply>
       <ci>R</ci>
      </apply>
      <ci>J</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <divide></divide>
       <ci>R</ci>
       <ci>J</ci>
      </apply>
      <apply>
       <times></times>
       <ci>I</ci>
       <apply>
        <divide></divide>
        <ci>R</ci>
        <ci>J</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <divide></divide>
       <ci>R</ci>
       <ci>J</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <ci>I</ci>
        <ci>J</ci>
       </apply>
       <ci>J</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <ci>R</ci>
      <apply>
       <plus></plus>
       <ci>I</ci>
       <ci>J</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R/I\otimes_{R}R/J={R/J\over I(R/J)}={R/J\over(I+J)/J}=R/(I+J)
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Tensor_product_of_modules:110">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

</p>

<p>Example: If <em>G</em> is an abelian group, 

<math display="inline" id="Tensor_product_of_modules:111">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <msub>
      <mo>⊗</mo>
      <mi>ℤ</mi>
     </msub>
     <mi>ℤ</mi>
    </mrow>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ℤ</ci>
      </apply>
      <ci>G</ci>
      <ci>ℤ</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>G</ci>
      <ci>n</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\otimes_{\mathbb{Z}}\mathbb{Z}/n=G/nG
  </annotation>
 </semantics>
</math>

; this follows from 1.</p>

<p>Example

<math display="block" id="Tensor_product_of_modules:112">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>ℤ</mi>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
     <msub>
      <mo>⊗</mo>
      <mi>ℤ</mi>
     </msub>
     <mi>ℤ</mi>
    </mrow>
    <mo>/</mo>
    <mi>m</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mrow>
     <mo>gcd</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ℤ</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>ℤ</ci>
       <ci>n</ci>
      </apply>
      <ci>ℤ</ci>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <apply>
      <ci>gcd</ci>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\otimes_{\mathbb{Z}}\mathbb{Z}/m=\mathbb{Z}/{\operatorname{gcd}(n,%
m)}
  </annotation>
 </semantics>
</math>

; this follows from 3.</p>

<p>Example: Let 

<math display="inline" id="Tensor_product_of_modules:113">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{n}
  </annotation>
 </semantics>
</math>


 be the group of <em>n</em>-th roots of unity. It is a <a href="cyclic_group" title="wikilink">cyclic group</a> and cyclic groups are classified by orders. Thus, non-canonically, 

<math display="inline" id="Tensor_product_of_modules:114">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>n</mi>
   </msub>
   <mo>≈</mo>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{n}\approx\mathbb{Z}/n
  </annotation>
 </semantics>
</math>

 and thus, when <em>g</em> is the gcd of <em>n</em> and <em>m</em>,</p>

<p>

<math display="block" id="Tensor_product_of_modules:115">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>μ</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mo>⊗</mo>
      <mi>ℤ</mi>
     </msub>
     <msub>
      <mi>μ</mi>
      <mi>m</mi>
     </msub>
    </mrow>
    <mo>≈</mo>
    <msub>
     <mi>μ</mi>
     <mi>g</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>ℤ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{n}\otimes_{\mathbb{Z}}\mu_{m}\approx\mu_{g}.
  </annotation>
 </semantics>
</math>

</p>

<p>Example: Consider 

<math display="inline" id="Tensor_product_of_modules:116">
 <semantics>
  <mrow>
   <mi>ℚ</mi>
   <msub>
    <mo>⊗</mo>
    <mi>ℤ</mi>
   </msub>
   <mi>ℚ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>ℤ</ci>
    </apply>
    <ci>ℚ</ci>
    <ci>ℚ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}\otimes_{\mathbb{Z}}\mathbb{Q}
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Tensor_product_of_modules:117">
 <semantics>
  <mrow>
   <mi>ℚ</mi>
   <msub>
    <mo>⊗</mo>
    <mi>ℚ</mi>
   </msub>
   <mi>ℚ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>ℚ</ci>
    </apply>
    <ci>ℚ</ci>
    <ci>ℚ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}\otimes_{\mathbb{Q}}\mathbb{Q}
  </annotation>
 </semantics>
</math>

 is obtained from 

<math display="inline" id="Tensor_product_of_modules:118">
 <semantics>
  <mrow>
   <mi>ℚ</mi>
   <msub>
    <mo>⊗</mo>
    <mi>ℤ</mi>
   </msub>
   <mi>ℚ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>ℤ</ci>
    </apply>
    <ci>ℚ</ci>
    <ci>ℚ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}\otimes_{\mathbb{Z}}\mathbb{Q}
  </annotation>
 </semantics>
</math>


 by imposing 

<math display="inline" id="Tensor_product_of_modules:119">
 <semantics>
  <mi>ℚ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℚ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}
  </annotation>
 </semantics>
</math>

-linearity on the middle, we have the surjection</p>

<p>

<math display="block" id="Tensor_product_of_modules:120">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℚ</mi>
    <msub>
     <mo>⊗</mo>
     <mi>ℤ</mi>
    </msub>
    <mi>ℚ</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>ℚ</mi>
    <msub>
     <mo>⊗</mo>
     <mi>ℚ</mi>
    </msub>
    <mi>ℚ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>ℤ</ci>
     </apply>
     <ci>ℚ</ci>
     <ci>ℚ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>ℚ</ci>
     </apply>
     <ci>ℚ</ci>
     <ci>ℚ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}\otimes_{\mathbb{Z}}\mathbb{Q}\to\mathbb{Q}\otimes_{\mathbb{Q}}%
\mathbb{Q}
  </annotation>
 </semantics>
</math>

 whose kernel is generated by elements of the form 

<math display="inline" id="Tensor_product_of_modules:121">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mi>r</mi>
      <mi>s</mi>
     </mfrac>
     <mi>x</mi>
    </mrow>
    <mo>⊗</mo>
    <mi>y</mi>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>⊗</mo>
     <mfrac>
      <mi>r</mi>
      <mi>s</mi>
     </mfrac>
    </mrow>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>r</ci>
       <ci>s</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>x</ci>
      <apply>
       <divide></divide>
       <ci>r</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {r\over s}x\otimes y-x\otimes{r\over s}y
  </annotation>
 </semantics>
</math>

 where <em>r</em>, <em>s</em>, <em>x</em>, <em>u</em> are integers and <em>s</em> is nonzero. Since</p>

<p>

<math display="block" id="Tensor_product_of_modules:122">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mfrac>
       <mi>r</mi>
       <mi>s</mi>
      </mfrac>
      <mi>x</mi>
     </mrow>
     <mo>⊗</mo>
     <mi>y</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mfrac>
        <mi>r</mi>
        <mi>s</mi>
       </mfrac>
       <mi>x</mi>
      </mrow>
      <mo>⊗</mo>
      <mfrac>
       <mi>s</mi>
       <mi>s</mi>
      </mfrac>
     </mrow>
     <mi>y</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mo>⊗</mo>
      <mfrac>
       <mi>r</mi>
       <mi>s</mi>
      </mfrac>
     </mrow>
     <mi>y</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>r</ci>
        <ci>s</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <ci>r</ci>
         <ci>s</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <divide></divide>
        <ci>s</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>x</ci>
       <apply>
        <divide></divide>
        <ci>r</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {r\over s}x\otimes y={r\over s}x\otimes{s\over s}y=x\otimes{r\over s}y,
  </annotation>
 </semantics>
</math>

 the kernel actually vanishes; hence, 

<math display="inline" id="Tensor_product_of_modules:123">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ℚ</mi>
     <msub>
      <mo>⊗</mo>
      <mi>ℤ</mi>
     </msub>
     <mi>ℚ</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>ℚ</mi>
     <msub>
      <mo>⊗</mo>
      <mi>ℚ</mi>
     </msub>
     <mi>ℚ</mi>
    </mrow>
    <mo>=</mo>
    <mi>ℚ</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ℤ</ci>
      </apply>
      <ci>ℚ</ci>
      <ci>ℚ</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ℚ</ci>
      </apply>
      <ci>ℚ</ci>
      <ci>ℚ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>ℚ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}\otimes_{\mathbb{Z}}\mathbb{Q}=\mathbb{Q}\otimes_{\mathbb{Q}}\mathbb%
{Q}=\mathbb{Q}.
  </annotation>
 </semantics>
</math>


</p>

<p>Example: We propose to compare 

<math display="inline" id="Tensor_product_of_modules:124">
 <semantics>
  <mrow>
   <mi>ℝ</mi>
   <msub>
    <mo>⊗</mo>
    <mi>ℤ</mi>
   </msub>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>ℤ</ci>
    </apply>
    <ci>ℝ</ci>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}\otimes_{\mathbb{Z}}\mathbb{R}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tensor_product_of_modules:125">
 <semantics>
  <mrow>
   <mi>ℝ</mi>
   <msub>
    <mo>⊗</mo>
    <mi>ℝ</mi>
   </msub>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>ℝ</ci>
    </apply>
    <ci>ℝ</ci>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}\otimes_{\mathbb{R}}\mathbb{R}
  </annotation>
 </semantics>
</math>

. Like in the previous example, we have

<math display="block" id="Tensor_product_of_modules:126">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℝ</mi>
    <msub>
     <mo>⊗</mo>
     <mi>ℤ</mi>
    </msub>
    <mi>ℝ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ℝ</mi>
    <msub>
     <mo>⊗</mo>
     <mi>ℚ</mi>
    </msub>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>ℤ</ci>
     </apply>
     <ci>ℝ</ci>
     <ci>ℝ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>ℚ</ci>
     </apply>
     <ci>ℝ</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}\otimes_{\mathbb{Z}}\mathbb{R}=\mathbb{R}\otimes_{\mathbb{Q}}\mathbb%
{R}
  </annotation>
 </semantics>
</math>

 as abelian group and thus as <strong>Q</strong>-vector space (any <strong>Z</strong>-linear map between <strong>Q</strong>-vector spaces is <strong>Q</strong>-linear). As <strong>Q</strong>-vector space, 

<math display="inline" id="Tensor_product_of_modules:127">
 <semantics>
  <mi>ℝ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℝ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}
  </annotation>
 </semantics>
</math>

 has dimension (cardinarity of a basis) of <a class="uri" href="continuum" title="wikilink">continuum</a>. Hence, 

<math display="inline" id="Tensor_product_of_modules:128">
 <semantics>
  <mrow>
   <mi>ℝ</mi>
   <msub>
    <mo>⊗</mo>
    <mi>ℚ</mi>
   </msub>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>ℚ</ci>
    </apply>
    <ci>ℝ</ci>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}\otimes_{\mathbb{Q}}\mathbb{R}
  </annotation>
 </semantics>
</math>


 has a <strong>Q</strong>-basis indexed by a product of continuums; thus its <strong>Q</strong>-dimension is continuum. Hence, for dimension reason, there is a non-canonical isomorphism of <strong>Q</strong>-vector spaces:</p>

<p>

<math display="block" id="Tensor_product_of_modules:129">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℝ</mi>
    <msub>
     <mo>⊗</mo>
     <mi>ℤ</mi>
    </msub>
    <mi>ℝ</mi>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mi>ℝ</mi>
    <msub>
     <mo>⊗</mo>
     <mi>ℝ</mi>
    </msub>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>ℤ</ci>
     </apply>
     <ci>ℝ</ci>
     <ci>ℝ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>ℝ</ci>
     </apply>
     <ci>ℝ</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}\otimes_{\mathbb{Z}}\mathbb{R}\approx\mathbb{R}\otimes_{\mathbb{R}}%
\mathbb{R}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="construction">Construction</h2>

<p>The construction of  takes a quotient of a <a href="free_abelian_group" title="wikilink">free abelian group</a> with basis the symbols , used here to denote the <a href="ordered_pair" title="wikilink">ordered pair</a> , for <em>m</em> in <em>M</em> and <em>n</em> in <em>N</em> by the subgroup generated by all elements of the form</p>
<ol>
<li>−<em>m</em> ∗ (<em>n</em> + <em>n</em>′) + <em>m</em> ∗ <em>n</em> + <em>m</em> ∗ <em>n</em>′</li>
<li>−(<em>m</em> + <em>m</em>′) ∗ <em>n</em> + <em>m</em> ∗ <em>n</em> + <em>m</em>′ ∗ <em>n</em></li>
<li>(<em>m</em> · <em>r</em>) ∗ <em>n</em> − <em>m</em> ∗ (<em>r</em> · <em>n</em>)</li>
</ol>

<p>where <em>m</em>, <em>m</em>′ in <em>M</em>, <em>n</em>, <em>n</em>′ in <em>N</em>, and <em>r</em> in <em>R</em>. The quotient map which takes <mtpl></mtpl> to the coset containing ; that is,</p>

<p>

<math display="block" id="Tensor_product_of_modules:130">
 <semantics>
  <mrow>
   <mo>⊗</mo>
   <mo>:</mo>
   <mi>M</mi>
   <mo>×</mo>
   <mi>N</mi>
   <mo>→</mo>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>m</mi>
    <mo>*</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">M</csymbol>
    <times></times>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">M</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">m</csymbol>
     <times></times>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes:M\times N\to M\otimes_{R}N,\,(m,n)\mapsto[m*n]
  </annotation>
 </semantics>
</math>

 is balanced, and the subgroup has been chosen minimally so that this map is balanced. The universal property of ⊗ follows from the universal properties of a free abelian group and a quotient.</p>

<p>More category-theoretically, let σ be the given right action of <em>R</em> on <em>M</em>; i.e., σ(<em>m</em>, <em>r</em>) = <em>m</em> · <em>r</em> and τ the left action of <em>R</em> of <em>N</em>. Then the tensor product of <em>M</em> and <em>N</em> over <em>R</em> can be defined as the <a class="uri" href="coequalizer" title="wikilink">coequalizer</a>:</p>

<p>

<math display="block" id="Tensor_product_of_modules:131">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi>M</mi>
        <mo>×</mo>
        <mi>R</mi>
        <mo>×</mo>
        <mi>N</mi>
       </mrow>
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mstyle displaystyle="false">
           <mstyle scriptlevel="+1">
            <mtable columnspacing="0.4em" rowspacing="0.2ex">
             <mtr>
              <mtd>
               <mi></mi>
              </mtd>
             </mtr>
             <mtr>
              <mtd>
               <mover accent="true">
                <mo>→</mo>
                <mrow>
                 <mi>σ</mi>
                 <mo>×</mo>
                 <mn>1</mn>
                </mrow>
               </mover>
              </mtd>
             </mtr>
            </mtable>
           </mstyle>
          </mstyle>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mstyle displaystyle="false">
           <mstyle scriptlevel="+1">
            <mtable columnspacing="0.4em" rowspacing="0.2ex">
             <mtr>
              <mtd>
               <munder accentunder="true">
                <mo>→</mo>
                <mrow>
                 <mn>1</mn>
                 <mo>×</mo>
                 <mi>τ</mi>
                </mrow>
               </munder>
              </mtd>
             </mtr>
             <mtr>
              <mtd>
               <mi></mi>
              </mtd>
             </mtr>
            </mtable>
           </mstyle>
          </mstyle>
         </mtd>
        </mtr>
       </mtable>
       <mi>M</mi>
      </mrow>
      <mo>×</mo>
      <mi>N</mi>
     </mrow>
     <mover accent="true">
      <mo>→</mo>
      <mo>⊗</mo>
     </mover>
     <mi>M</mi>
    </mrow>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>N</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>M</ci>
        <ci>R</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <ci>STACKED</ci>
        <apply>
         <ci>STACKED</ci>
         <csymbol cd="latexml">absent</csymbol>
         <apply>
          <apply>
           <times></times>
           <ci>σ</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>normal-→</ci>
         </apply>
        </apply>
        <apply>
         <ci>STACKED</ci>
         <apply>
          <apply>
           <times></times>
           <cn type="integer">1</cn>
           <ci>τ</ci>
          </apply>
          <ci>normal-→</ci>
         </apply>
         <csymbol cd="latexml">absent</csymbol>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>normal-→</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\times R\times N{{{}\atop\overset{\sigma\times 1}{\rightarrow}}\atop{%
\underset{1\times\tau}{\rightarrow}\atop{}}}M\times N\overset{\otimes}{\to}M%
\otimes_{R}N,
  </annotation>
 </semantics>
</math>

 together with the requirements</p>

<p>

<math display="block" id="Tensor_product_of_modules:132">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <msup>
        <mi>n</mi>
        <mo>′</mo>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>m</mi>
      <mo>⊗</mo>
      <mi>n</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>m</mi>
      <mo>⊗</mo>
      <msup>
       <mi>n</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>m</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>m</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\otimes(n+n^{\prime})=m\otimes n+m\otimes n^{\prime},
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Tensor_product_of_modules:133">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>+</mo>
       <msup>
        <mi>m</mi>
        <mo>′</mo>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⊗</mo>
     <mi>n</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>m</mi>
      <mo>⊗</mo>
      <mi>n</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>m</mi>
       <mo>′</mo>
      </msup>
      <mo>⊗</mo>
      <mi>n</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <plus></plus>
      <ci>m</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m+m^{\prime})\otimes n=m\otimes n+m^{\prime}\otimes n.
  </annotation>
 </semantics>
</math>

</p>

<p>If <em>S</em> is a subring of a ring <em>R</em>, then 

<math display="inline" id="Tensor_product_of_modules:134">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}N
  </annotation>
 </semantics>
</math>

 is the quotient group of 

<math display="inline" id="Tensor_product_of_modules:135">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>S</mi>
   </msub>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>S</ci>
    </apply>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{S}N
  </annotation>
 </semantics>
</math>

 by the subgroup generated by 

<math display="inline" id="Tensor_product_of_modules:136">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mi>r</mi>
       </mrow>
       <msub>
        <mo>⊗</mo>
        <mi>S</mi>
       </msub>
       <mi>y</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mrow>
        <mi>x</mi>
        <msub>
         <mo>⊗</mo>
         <mi>S</mi>
        </msub>
        <mi>r</mi>
       </mrow>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo rspace="4.2pt">,</mo>
     <mi>r</mi>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>M</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>y</mi>
     <mo>∈</mo>
     <mi>N</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <apply>
       <minus></minus>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">tensor-product</csymbol>
         <ci>S</ci>
        </apply>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>r</ci>
        </apply>
        <ci>y</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">tensor-product</csymbol>
          <ci>S</ci>
         </apply>
         <ci>x</ci>
         <ci>r</ci>
        </apply>
        <ci>y</ci>
       </apply>
      </apply>
      <ci>r</ci>
     </list>
     <ci>R</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <in></in>
      <ci>y</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xr\otimes_{S}y-x\otimes_{S}ry,\,r\in R,x\in M,y\in N
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Tensor_product_of_modules:137">
 <semantics>
  <mrow>
   <mi>x</mi>
   <msub>
    <mo>⊗</mo>
    <mi>S</mi>
   </msub>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>S</ci>
    </apply>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\otimes_{S}y
  </annotation>
 </semantics>
</math>

 is the image of 

<math display="inline" id="Tensor_product_of_modules:138">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>


 under 

<math display="inline" id="Tensor_product_of_modules:139">
 <semantics>
  <mrow>
   <mo>⊗</mo>
   <mo>:</mo>
   <mi>M</mi>
   <mo>×</mo>
   <mi>N</mi>
   <mo>→</mo>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>S</mi>
   </msub>
   <mi>N</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">M</csymbol>
    <times></times>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">M</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>S</ci>
    </apply>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes:M\times N\to M\otimes_{S}N.
  </annotation>
 </semantics>
</math>

 In particular, any tensor product of <em>R</em>-modules can be constructed, if so desired, as a quotient of a tensor product of abelian groups by imposing the <em>R</em>-balanced product property.</p>

<p>In the construction of the tensor product over a commutative ring <em>R</em>, the <em>R</em>-module structure can be built in from the start by forming the quotient of a free <em>R</em>-module by the submodule generated by the elements given above for the general construction, augmented by the elements . Alternately, the general construction can be given a Z(<em>R</em>)-module structure by defining the scalar action by  when this is well-defined, which is precisely when <em>r</em> ∈ Z(<em>R</em>), the <a href="Center_(algebra)" title="wikilink">centre</a> of <em>R</em>.</p>

<p>The <a href="direct_product" title="wikilink">direct product</a> of <em>M</em> and <em>N</em> is rarely isomorphic to the tensor product of <em>M</em> and <em>N</em>. When <em>R</em> is not commutative, then the tensor product requires that <em>M</em> and <em>N</em> be modules on opposite sides, while the direct product requires they be modules on the same side. In all cases the only function from  to <em>G</em> that is both linear and bilinear is the zero map.</p>
<h2 id="as-linear-maps">As linear maps</h2>

<p>In the general case, not all the properties of a <a href="tensor_product_of_vector_spaces" title="wikilink">tensor product of vector spaces</a> extend to modules. Yet, some useful properties of the tensor product, considered as <a href="module_homomorphism" title="wikilink">module homomorphisms</a>, remain.</p>
<h3 id="dual-module">Dual module</h3>

<p>The <strong>dual module</strong> of a right <em>R</em>-module <em>E</em>, is defined as <mtpl></mtpl> with the canonical left <em>R</em>-module structure, and is denoted <em>E</em><sup>∗</sup>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> The canonical structure is the <a class="uri" href="pointwise" title="wikilink">pointwise</a> operations of addition and scalar multiplication. Thus, <em>E</em><sup>∗</sup> is the set of all <em>R</em>-linear maps  (also called <em>linear forms</em>), with operations</p>

<p>

<math display="block" id="Tensor_product_of_modules:140">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ϕ</mi>
       <mo>+</mo>
       <mi>ψ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>ψ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="12.5pt">,</mo>
     <mi>ϕ</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>ψ</mi>
     <mo>∈</mo>
     <msup>
      <mi>E</mi>
      <mo>*</mo>
     </msup>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>u</mi>
     <mo>∈</mo>
     <mi>E</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <ci>ϕ</ci>
       <ci>ψ</ci>
      </apply>
      <ci>u</ci>
     </apply>
     <list>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>ϕ</ci>
        <ci>u</ci>
       </apply>
       <apply>
        <times></times>
        <ci>ψ</ci>
        <ci>u</ci>
       </apply>
      </apply>
      <ci>ϕ</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>ψ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>E</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>u</ci>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi+\psi)(u)=\phi(u)+\psi(u),\quad\phi,\psi\in E^{*},u\in E
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Tensor_product_of_modules:141">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>r</mi>
        <mo>⋅</mo>
        <mi>ϕ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi>r</mi>
       <mo>⋅</mo>
       <mi>ϕ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>ϕ</mi>
      <mo>∈</mo>
      <msup>
       <mi>E</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>u</mi>
       <mo>∈</mo>
       <mi>E</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>r</mi>
       <mo>∈</mo>
       <mi>R</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>r</ci>
       <ci>ϕ</ci>
      </apply>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>r</ci>
       <ci>ϕ</ci>
      </apply>
      <ci>u</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>ϕ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>E</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>u</ci>
       <ci>E</ci>
      </apply>
      <apply>
       <in></in>
       <ci>r</ci>
       <ci>R</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (r\cdot\phi)(u)=r\cdot\phi(u),\quad\phi\in E^{*},u\in E,r\in R,
  </annotation>
 </semantics>
</math>

 The dual of a left <em>R</em>-module is defined analogously, with the same notation.</p>

<p>There is always a canonical homomorphism <mtpl></mtpl> from <em>E</em> to its second dual. It is an isomorphism if <em>E</em> is a free module of finite rank. In general, <em>E</em> is called a <a href="reflexive_module" title="wikilink">reflexive module</a> if the canonical homomorphism is an isomorphism.</p>
<h3 id="duality-pairing">Duality pairing</h3>

<p>We denote the <a href="natural_pairing" title="wikilink">natural pairing</a> of its dual <em>E</em><sup>∗</sup> and a right <em>R</em>-module <em>E</em>, or of a left <em>R</em>-module <em>F</em> and its dual <em>F</em><sup>∗</sup> as</p>

<p>

<math display="block" id="Tensor_product_of_modules:142">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mo>⋅</mo>
    <mo>,</mo>
    <mo>⋅</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>E</mi>
      <mo>*</mo>
     </msup>
     <mo>×</mo>
     <mi>E</mi>
    </mrow>
    <mo>→</mo>
    <mi>R</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>e</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↦</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msup>
      <mi>e</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi>e</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>e</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>e</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <list>
      <ci>normal-⋅</ci>
      <ci>normal-⋅</ci>
     </list>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>E</ci>
        <times></times>
       </apply>
       <ci>E</ci>
      </apply>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">maps-to</csymbol>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>e</ci>
       </interval>
       <list>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>e</ci>
       </list>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>e</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdot,\cdot\rangle:E^{*}\times E\to R:(e^{\prime},e)\mapsto\langle e^{%
\prime},e\rangle=e^{\prime}(e)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Tensor_product_of_modules:143">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mo>⋅</mo>
     <mo>,</mo>
     <mo>⋅</mo>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>F</mi>
      <mo>×</mo>
      <msup>
       <mi>F</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mo>→</mo>
     <mi>R</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo>,</mo>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>↦</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>f</mi>
      <mo>,</mo>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <list>
      <ci>normal-⋅</ci>
      <ci>normal-⋅</ci>
     </list>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>F</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>F</ci>
        <times></times>
       </apply>
      </apply>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">maps-to</csymbol>
       <interval closure="open">
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
       </interval>
       <list>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>f</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdot,\cdot\rangle:F\times F^{*}\to R:(f,f^{\prime})\mapsto\langle f,f^%
{\prime}\rangle=f^{\prime}(f).
  </annotation>
 </semantics>
</math>

 The pairing is left <em>R</em>-linear in its left argument, and right <em>R</em>-linear in its right argument:</p>

<p>

<math display="block" id="Tensor_product_of_modules:144">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <mi>r</mi>
       <mo>⋅</mo>
       <mi>g</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>h</mi>
       <mo>⋅</mo>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi>r</mi>
       <mo>⋅</mo>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mi>g</mi>
        <mo>,</mo>
        <mi>h</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>⋅</mo>
       <mi>s</mi>
      </mrow>
      <mo rspace="12.5pt">,</mo>
      <mi>r</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mi>R</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <ci>normal-⋅</ci>
       <ci>r</ci>
       <ci>g</ci>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>h</ci>
       <ci>s</ci>
      </apply>
     </list>
     <list>
      <apply>
       <ci>normal-⋅</ci>
       <ci>r</ci>
       <list>
        <ci>g</ci>
        <ci>h</ci>
       </list>
       <ci>s</ci>
      </apply>
      <ci>r</ci>
     </list>
    </apply>
    <apply>
     <in></in>
     <ci>s</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle r\cdot g,h\cdot s\rangle=r\cdot\langle g,h\rangle\cdot s,\quad r,s\in R.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="an-element-as-a-bilinear-map">An element as a (bi)linear map</h3>

<p>In the general case, each element of the tensor product of modules gives rise to a left <em>R</em>-linear map, to a right <em>R</em>-linear map, and to an <em>R</em>-bilinear form. Unlike the commutative case, in the general case the tensor product is not an <em>R</em>-module, and thus does not support scalar multiplication.</p>
<ul>
<li>Given right <em>R</em>-module <em>E</em> and right <em>R</em>-module <em>F</em>, there is a canonical homomorphism <mtpl></mtpl> such that  is the map .<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
<li>Given left <em>R</em>-module <em>E</em> and right <em>R</em>-module <em>F</em>, there is a canonical homomorphism <mtpl></mtpl> such that  is the map .<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
</ul>

<p>Both cases hold for general modules, and become isomorphisms if the modules <em>E</em> and <em>F</em> are restricted to being <a href="finitely_generated_projective_module" title="wikilink">finitely generated projective modules</a> (in particular free modules of finite ranks). Thus, an element of a tensor product of modules over a ring <em>R</em> maps canonically onto an <em>R</em>-linear map, though as with vector spaces, constraints apply to the modules for this to be equivalent to the full space of such linear maps.</p>
<ul>
<li>Given right <em>R</em>-module <em>E</em> and left <em>R</em>-module <em>F</em>, there is a canonical homomorphism <mtpl></mtpl> such that  is the map . Thus, an element of a tensor product <em>ξ</em> ∈ <em>F</em><sup>∗</sup> ⊗<sub><em>R</em></sub> <em>E</em><sup>∗</sup> may be thought of giving rise to or acting as an <em>R</em>-bilinear map .</li>
</ul>
<h3 id="trace">Trace</h3>

<p>Let <em>R</em> be a commutative ring and <em>E</em> an <em>R</em>-module. Then there is a canonical <em>R</em>-linear map:</p>

<p>

<math display="block" id="Tensor_product_of_modules:145">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>E</mi>
     <mo>*</mo>
    </msup>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>E</mi>
   </mrow>
   <mo>→</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <times></times>
     </apply>
     <ci>E</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{*}\otimes_{R}E\to R
  </annotation>
 </semantics>
</math>

 induced by 

<math display="inline" id="Tensor_product_of_modules:146">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mo>⊗</mo>
    <mi>x</mi>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\otimes x\mapsto\phi(x)
  </annotation>
 </semantics>
</math>

; it is the unique <em>R</em>-linear corresponding to the duality pairing.</p>

<p>If <em>E</em> is a finitely generated projective <em>R</em>-module, then one can identify 

<math display="inline" id="Tensor_product_of_modules:147">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>E</mi>
     <mo>*</mo>
    </msup>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>E</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>End</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <times></times>
     </apply>
     <ci>E</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>End</ci>
      <ci>R</ci>
     </apply>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{*}\otimes_{R}E=\operatorname{End}_{R}(E)
  </annotation>
 </semantics>
</math>

 through the canonical homomorphism mentioned above and then the above is the <strong>trace map</strong>:</p>

<p>

<math display="block" id="Tensor_product_of_modules:148">
 <semantics>
  <mrow>
   <mrow>
    <mo>tr</mo>
    <mo>:</mo>
    <mrow>
     <mrow>
      <msub>
       <mo>End</mo>
       <mi>R</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>E</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>→</mo>
     <mi>R</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>tr</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>End</ci>
       <ci>R</ci>
      </apply>
      <ci>E</ci>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{tr}:\operatorname{End}_{R}(E)\to R.
  </annotation>
 </semantics>
</math>

 When <em>R</em> is a field, this is the usual <a href="Trace_(linear_algebra)" title="wikilink">trace</a> of a linear transformation.</p>
<h2 id="example-from-differential-geometry-tensor-field">Example from differential geometry: tensor field</h2>

<p>The most prominent example of a tensor product of modules in differential geometry is the tensor product of the spaces of vector fields and differential forms. More precisely, if <em>R</em> is the (commutative) ring of smooth functions on a smooth manifold <em>M</em>, then one puts</p>

<p>

<math display="block" id="Tensor_product_of_modules:149">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝔗</mi>
    <mi>q</mi>
    <mi>p</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>M</mi>
        <mo>,</mo>
        <mrow>
         <mi>T</mi>
         <mi>M</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi></mi>
        <mo>⊗</mo>
        <mi>p</mi>
       </mrow>
      </msup>
     </mrow>
     <msub>
      <mo>⊗</mo>
      <mi>R</mi>
     </msub>
     <mi mathvariant="normal">Γ</mi>
    </mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mrow>
       <msup>
        <mi>T</mi>
        <mo>*</mo>
       </msup>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mi>q</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝔗</ci>
      <ci>p</ci>
     </apply>
     <ci>q</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Γ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <interval closure="open">
         <ci>M</ci>
         <apply>
          <times></times>
          <ci>T</ci>
          <ci>M</ci>
         </apply>
        </interval>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
      <ci>normal-Γ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <interval closure="open">
       <ci>M</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>T</ci>
         <times></times>
        </apply>
        <ci>M</ci>
       </apply>
      </interval>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{T}^{p}_{q}=\Gamma(M,TM)^{\otimes p}\otimes_{R}\Gamma(M,T^{*}M)^{%
\otimes q}
  </annotation>
 </semantics>
</math>

 where Γ means the <a href="space_of_sections" title="wikilink">space of sections</a> and the superscript 

<math display="inline" id="Tensor_product_of_modules:150">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊗</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes p
  </annotation>
 </semantics>
</math>

 means tensoring <em>p</em> times over <em>R</em>. By definition, an element of 

<math display="inline" id="Tensor_product_of_modules:151">
 <semantics>
  <msubsup>
   <mi>𝔗</mi>
   <mi>q</mi>
   <mi>p</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝔗</ci>
     <ci>p</ci>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{T}^{p}_{q}
  </annotation>
 </semantics>
</math>

 is a <a href="tensor_field" title="wikilink">tensor field</a> of type (<em>p</em>, <em>q</em>).</p>

<p>As <em>R</em>-modules, 

<math display="inline" id="Tensor_product_of_modules:152">
 <semantics>
  <msubsup>
   <mi>𝔗</mi>
   <mi>p</mi>
   <mi>q</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝔗</ci>
     <ci>q</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{T}^{q}_{p}
  </annotation>
 </semantics>
</math>

 is the dual module of 

<math display="inline" id="Tensor_product_of_modules:153">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝔗</mi>
    <mi>q</mi>
    <mi>p</mi>
   </msubsup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝔗</ci>
     <ci>p</ci>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{T}^{p}_{q}.
  </annotation>
 </semantics>
</math>


<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>To lighten the notation, put 

<math display="inline" id="Tensor_product_of_modules:154">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mrow>
      <mi>T</mi>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <times></times>
     <ci>normal-Γ</ci>
     <interval closure="open">
      <ci>M</ci>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>M</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=\Gamma(M,TM)
  </annotation>
 </semantics>
</math>

 and so 

<math display="inline" id="Tensor_product_of_modules:155">
 <semantics>
  <mrow>
   <msup>
    <mi>E</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>T</mi>
       <mo>*</mo>
      </msup>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>E</ci>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Γ</ci>
     <interval closure="open">
      <ci>M</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <times></times>
       </apply>
       <ci>M</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{*}=\Gamma(M,T^{*}M)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> When <em>p</em>, <em>q</em> ≥ 1, for each (<em>k</em>, <em>l</em>) with 1 ≤ k ≤ p, 1 ≤ l ≤ q, there is an <em>R</em>-multilinear map:</p>

<p>

<math display="block" id="Tensor_product_of_modules:156">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>E</mi>
      <mi>p</mi>
     </msup>
     <mo>×</mo>
     <mmultiscripts>
      <mi>E</mi>
      <none></none>
      <mo>*</mo>
      <none></none>
      <mi>q</mi>
     </mmultiscripts>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msup>
      <mi>E</mi>
      <mrow>
       <mi>p</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo>×</mo>
     <mmultiscripts>
      <mi>E</mi>
      <none></none>
      <mo>*</mo>
      <none></none>
      <mrow>
       <mi>q</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mmultiscripts>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>X</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>X</mi>
      <mi>p</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>ω</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>ω</mi>
      <mi>q</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↦</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>X</mi>
       <mi>k</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>ω</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>X</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mover accent="true">
       <msub>
        <mi>X</mi>
        <mi>l</mi>
       </msub>
       <mo>^</mo>
      </mover>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>X</mi>
       <mi>p</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>ω</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mover accent="true">
       <msub>
        <mi>ω</mi>
        <mi>l</mi>
       </msub>
       <mo>^</mo>
      </mover>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>ω</mi>
       <mi>q</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>E</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>E</ci>
        <times></times>
       </apply>
       <ci>q</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>E</ci>
       <apply>
        <minus></minus>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>E</ci>
        <times></times>
       </apply>
       <apply>
        <minus></minus>
        <ci>q</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>q</ci>
      </apply>
     </vector>
     <apply>
      <times></times>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>l</ci>
       </apply>
      </list>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <ci>normal-^</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>l</ci>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <ci>normal-^</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>l</ci>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>q</ci>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{p}\times{E^{*}}^{q}\to E^{p-1}\times{E^{*}}^{q-1},\,(X_{1},\dots,X_{p},%
\omega_{1},\dots,\omega_{q})\mapsto\langle X_{k},\omega_{l}\rangle(X_{1},\dots%
,\widehat{X_{l}},\dots,X_{p},\omega_{1},\dots,\widehat{\omega_{l}},\dots,%
\omega_{q})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Tensor_product_of_modules:157">
 <semantics>
  <msup>
   <mi>E</mi>
   <mi>p</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>E</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{p}
  </annotation>
 </semantics>
</math>

 means 

<math display="inline" id="Tensor_product_of_modules:158">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∏</mo>
    <mn>1</mn>
    <mi>p</mi>
   </msubsup>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <cn type="integer">1</cn>
     </apply>
     <ci>p</ci>
    </apply>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{1}^{p}E
  </annotation>
 </semantics>
</math>


 and the hat means a term is omitted. By the universal property, it corresponds to a unique <em>R</em>-linear map:</p>

<p>

<math display="block" id="Tensor_product_of_modules:159">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>C</mi>
     <mi>l</mi>
     <mi>k</mi>
    </msubsup>
    <mo>:</mo>
    <mrow>
     <msubsup>
      <mi>𝔗</mi>
      <mi>q</mi>
      <mi>p</mi>
     </msubsup>
     <mo>→</mo>
     <msubsup>
      <mi>𝔗</mi>
      <mrow>
       <mi>q</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>p</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>k</ci>
     </apply>
     <ci>l</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝔗</ci>
       <ci>p</ci>
      </apply>
      <ci>q</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝔗</ci>
       <apply>
        <minus></minus>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>q</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{k}_{l}:\mathfrak{T}^{p}_{q}\to\mathfrak{T}^{p-1}_{q-1}.
  </annotation>
 </semantics>
</math>

 It is called the <a href="tensor_contraction" title="wikilink">contraction</a> of tensors in the index (<em>k</em>, <em>l</em>). Unwinding what the universal property says one sees:</p>

<p>

<math display="block" id="Tensor_product_of_modules:160">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>C</mi>
      <mi>l</mi>
      <mi>k</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>X</mi>
        <mn>1</mn>
       </msub>
       <mo>⊗</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>⊗</mo>
       <msub>
        <mi>X</mi>
        <mi>p</mi>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>ω</mi>
        <mn>1</mn>
       </msub>
       <mo>⊗</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>⊗</mo>
       <msub>
        <mi>ω</mi>
        <mi>q</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mrow>
          <mrow>
           <mo stretchy="false">⟨</mo>
           <msub>
            <mi>X</mi>
            <mi>k</mi>
           </msub>
           <mo>,</mo>
           <msub>
            <mi>ω</mi>
            <mi>l</mi>
           </msub>
           <mo stretchy="false">⟩</mo>
          </mrow>
          <msub>
           <mi>X</mi>
           <mn>1</mn>
          </msub>
         </mrow>
         <mo>⊗</mo>
         <mi mathvariant="normal">⋯</mi>
        </mrow>
        <mover accent="true">
         <msub>
          <mi>X</mi>
          <mi>l</mi>
         </msub>
         <mo>^</mo>
        </mover>
        <mi mathvariant="normal">⋯</mi>
       </mrow>
       <mo>⊗</mo>
       <msub>
        <mi>X</mi>
        <mi>p</mi>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>ω</mi>
        <mn>1</mn>
       </msub>
       <mo>⊗</mo>
       <mi mathvariant="normal">⋯</mi>
      </mrow>
      <mover accent="true">
       <msub>
        <mi>ω</mi>
        <mi>l</mi>
       </msub>
       <mo>^</mo>
      </mover>
      <mi mathvariant="normal">⋯</mi>
     </mrow>
     <mo>⊗</mo>
     <msub>
      <mi>ω</mi>
      <mi>q</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>C</ci>
       <ci>k</ci>
      </apply>
      <ci>l</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <apply>
          <times></times>
          <list>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>X</ci>
            <ci>k</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ω</ci>
            <ci>l</ci>
           </apply>
          </list>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>normal-⋯</ci>
        </apply>
        <apply>
         <ci>normal-^</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>l</ci>
         </apply>
        </apply>
        <ci>normal-⋯</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-⋯</ci>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>l</ci>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{k}_{l}(X_{1}\otimes\cdots\otimes X_{p}\otimes\omega_{1}\otimes\cdots\otimes%
\omega_{q})=\langle X_{k},\omega_{l}\rangle X_{1}\otimes\cdots\widehat{X_{l}}%
\cdots\otimes X_{p}\otimes\omega_{1}\otimes\cdots\widehat{\omega_{l}}\cdots%
\otimes\omega_{q}.
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Remark</strong>: The preceding discussion is standard in textbooks on differential geometry (e.g., Helgason). In a way, the sheaf-theoretic construction (i.e., the language of <a href="sheaf_of_modules" title="wikilink">sheaf of modules</a>) is more natural and increasingly more common; for that, see the section .</p>
<h2 id="relationship-to-flat-modules">Relationship to flat modules</h2>

<p>In general, 

<math display="inline" id="Tensor_product_of_modules:161">
 <semantics>
  <mrow>
   <mo>-</mo>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mo>-</mo>
   <mo>:</mo>
   <mi>Mod</mi>
   <mtext>–</mtext>
   <mi>R</mi>
   <mo>×</mo>
   <mi>R</mi>
   <mtext>–</mtext>
   <mi>Mod</mi>
   <mo>→</mo>
   <mi>Ab</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <minus></minus>
    <ci>normal-:</ci>
    <csymbol cd="unknown">Mod</csymbol>
    <mtext>–</mtext>
    <csymbol cd="unknown">R</csymbol>
    <times></times>
    <csymbol cd="unknown">R</csymbol>
    <mtext>–</mtext>
    <csymbol cd="unknown">Mod</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">Ab</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\otimes_{R}-:\mathrm{Mod}\mbox{--}R\times R\mbox{--}\mathrm{Mod}\rightarrow%
\mathrm{Ab}
  </annotation>
 </semantics>
</math>

 is a <a class="uri" href="bifunctor" title="wikilink">bifunctor</a> which accepts a right and a left <em>R</em> module pair as input, and assigns them to the tensor product in the <a href="category_of_abelian_groups" title="wikilink">category of abelian groups</a>.</p>

<p>By fixing a right <em>R</em> module <em>M</em>, a functor 

<math display="inline" id="Tensor_product_of_modules:162">
 <semantics>
  <mrow>
   <mi>M</mi>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mo>-</mo>
   <mo>:</mo>
   <mi>R</mi>
   <mtext>–</mtext>
   <mi>Mod</mi>
   <mo>→</mo>
   <mi>Ab</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">M</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <minus></minus>
    <ci>normal-:</ci>
    <csymbol cd="unknown">R</csymbol>
    <mtext>–</mtext>
    <csymbol cd="unknown">Mod</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">Ab</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes_{R}-:R\mbox{--}\mathrm{Mod}\rightarrow\mathrm{Ab}
  </annotation>
 </semantics>
</math>

 arises, and symmetrically a left <em>R</em> module <em>N</em> could be fixed to create a functor 

<math display="inline" id="Tensor_product_of_modules:163">
 <semantics>
  <mrow>
   <mo>-</mo>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>N</mi>
   <mo>:</mo>
   <mi>Mod</mi>
   <mtext>–</mtext>
   <mi>R</mi>
   <mo>→</mo>
   <mi>Ab</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <csymbol cd="unknown">N</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">Mod</csymbol>
    <mtext>–</mtext>
    <csymbol cd="unknown">R</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">Ab</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\otimes_{R}N:\mathrm{Mod}\mbox{--}R\rightarrow\mathrm{Ab}
  </annotation>
 </semantics>
</math>


. Unlike the <a href="Hom_bifunctor" title="wikilink">Hom bifunctor</a> 

<math display="inline" id="Tensor_product_of_modules:164">
 <semantics>
  <mrow>
   <msub>
    <mi>Hom</mi>
    <mi>R</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>-</mo>
    <mo>,</mo>
    <mo>-</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Hom</ci>
     <ci>R</ci>
    </apply>
    <interval closure="open">
     <minus></minus>
     <minus></minus>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Hom}_{R}(-,-)
  </annotation>
 </semantics>
</math>

, the tensor functor is <a href="covariant_functor" title="wikilink">covariant</a> in both inputs.</p>

<p>It can be shown that <em>M</em>⊗- and -⊗<em>N</em> are always <a href="right_exact_functor" title="wikilink">right exact functors</a>, but not necessarily left exact. By definition, a module <em>T</em> is a <a href="flat_module" title="wikilink">flat module</a> if <em>T</em>⊗- is an exact functor.</p>

<p>If {<em>m</em><sub><em>i</em></sub>}<sub><em>i</em>∈<em>I</em></sub> and {<em>n</em><sub><em>j</em></sub>}<sub><em>j</em>∈<em>J</em></sub> are generating sets for <em>M</em> and <em>N</em>, respectively, then {<em>m</em><sub><em>i</em></sub>⊗<em>n</em><sub><em>j</em></sub>}<sub><em>i</em>∈<em>I</em>,<em>j</em>∈<em>J</em></sub> will be a generating set for <em>M</em>⊗<em>N</em>. Because the tensor functor <em>M</em>⊗<sub><em>R</em></sub>- sometimes fails to be left exact, this may not be a minimal generating set, even if the original generating sets are minimal. If <em>M</em> is a <a href="flat_module" title="wikilink">flat module</a>, the functor <mtpl></mtpl> is exact by the very definition of a flat module. If the tensor products are taken over a field <em>F</em>, we are in the case of vector spaces as above. Since all <em>F</em> modules are flat, the <a class="uri" href="bifunctor" title="wikilink">bifunctor</a> <mtpl></mtpl> is exact in both positions, and the two given generating sets are bases, then 

<math display="inline" id="Tensor_product_of_modules:165">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mi>i</mi>
    </msub>
    <mo>⊗</mo>
    <msub>
     <mi>n</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>j</mi>
     <mo>∈</mo>
     <mi>J</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <in></in>
      <ci>j</ci>
      <ci>J</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{m_{i}\otimes n_{j}\mid i\in I,j\in J\}
  </annotation>
 </semantics>
</math>

 indeed forms a basis for <mtpl></mtpl>.</p>

<p>When the tensor products are taken over a field <em>F</em> so that -⊗- is exact in both positions, and the generating sets are bases of <em>M</em> and <em>N</em>, it is true that 

<math display="inline" id="Tensor_product_of_modules:166">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mi>i</mi>
    </msub>
    <mo>⊗</mo>
    <msub>
     <mi>n</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>j</mi>
     <mo>∈</mo>
     <mi>J</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <in></in>
      <ci>j</ci>
      <ci>J</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{m_{i}\otimes n_{j}\mid i\in I,j\in J\}
  </annotation>
 </semantics>
</math>

 indeed forms a basis for <em>M</em>⊗<sub><em>F</em></sub> <em>N</em>.</p>

<p>See also: <a href="pure_submodule" title="wikilink">pure submodule</a>.</p>
<h2 id="additional-structure">Additional structure</h2>

<p>If <em>S</em> and <em>T</em> are commutative <em>R</em>-algebras, then <em>S</em> ⊗<sub>R</sub> <em>T</em> will be a commutative <em>R</em>-algebra as well, with the multiplication map defined by <mtpl></mtpl> and extended by linearity. In this setting, the tensor product become a <a href="fibered_coproduct" title="wikilink">fibered coproduct</a> in the category of <em>R</em>-algebras.</p>

<p>If <em>M</em> and <em>N</em> are both <em>R</em>-modules over a commutative ring, then their tensor product is again an <em>R</em>-module. If <em>R</em> is a ring, <em><sub>R</sub>M</em> is a left <em>R</em>-module, and the <a class="uri" href="commutator" title="wikilink">commutator</a></p>
<dl>
<dd><em>rs</em> − <em>sr</em>
</dd>
</dl>

<p>of any two elements <em>r</em> and <em>s</em> of <em>R</em> is in the <a href="Annihilator_(ring_theory)" title="wikilink">annihilator</a> of <em>M</em>, then we can make <em>M</em> into a right <em>R</em> module by setting</p>
<dl>
<dd><em>mr</em> = <em>rm</em>.
</dd>
</dl>

<p>The action of <em>R</em> on <em>M</em> factors through an action of a quotient commutative ring. In this case the tensor product of <em>M</em> with itself over <em>R</em> is again an <em>R</em>-module. This is a very common technique in commutative algebra.</p>
<h2 id="generalization">Generalization</h2>
<h3 id="tensor-product-of-complexes-of-modules">Tensor product of complexes of modules</h3>

<p>If <em>X</em>, <em>Y</em> are complexes of <em>R</em>-modules (<em>R</em> a commutative ring), then their tensor product is the complex given by</p>

<p>

<math display="block" id="Tensor_product_of_modules:167">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <msub>
        <mo>⊗</mo>
        <mi>R</mi>
       </msub>
       <mi>Y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mi>j</mi>
       </mrow>
       <mo>=</mo>
       <mi>n</mi>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>X</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <msub>
       <mi>Y</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X\otimes_{R}Y)_{n}=\sum_{i+j=n}X_{i}\otimes_{R}Y_{i}.
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>For example, if <em>C</em> is a chain complex of flat abelian groups and if <em>G</em> is an abelian group, then the homology group of 

<math display="inline" id="Tensor_product_of_modules:168">
 <semantics>
  <mrow>
   <mi>C</mi>
   <msub>
    <mo>⊗</mo>
    <mi>ℤ</mi>
   </msub>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>ℤ</ci>
    </apply>
    <ci>C</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\otimes_{\mathbb{Z}}G
  </annotation>
 </semantics>
</math>


 is the homology group of <em>C</em> with coefficients in <em>G</em> (see also: <a href="universal_coefficient_theorem" title="wikilink">universal coefficient theorem</a>.)</p>
<h3 id="tensor-product-of-sheaves-of-modules">Tensor product of sheaves of modules</h3>

<p>In this setup, for example, one can define a <a href="tensor_field" title="wikilink">tensor field</a> on a smooth manifold <em>M</em> as a (global or local) section of the tensor product (called <strong>tensor bundle</strong>)</p>

<p>

<math display="block" id="Tensor_product_of_modules:169">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mi>p</mi>
    </mrow>
   </msup>
   <msub>
    <mo>⊗</mo>
    <mi>O</mi>
   </msub>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>T</mi>
       <mo>*</mo>
      </msup>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mi>q</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>O</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <times></times>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (TM)^{\otimes p}\otimes_{O}(T^{*}M)^{\otimes q}
  </annotation>
 </semantics>
</math>

 where <em>O</em> is the <a href="sheaf_of_rings" title="wikilink">sheaf of rings</a> of smooth functions on <em>M</em> and the bundles 

<math display="inline" id="Tensor_product_of_modules:170">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mi>M</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msup>
     <mi>T</mi>
     <mo>*</mo>
    </msup>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <times></times>
     </apply>
     <ci>M</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TM,T^{*}M
  </annotation>
 </semantics>
</math>

 are viewed as <a href="locally_free_sheaf" title="wikilink">locally free sheaves</a> on <em>M</em>. See also: <a class="uri" href="http://www.encyclopediaofmath.org/index.php/Tensor_bundle">http://www.encyclopediaofmath.org/index.php/Tensor_bundle</a></p>

<p>The <strong>exterior bundle</strong> on <em>M</em> is the <a class="uri" href="subbundle" title="wikilink">subbundle</a> of the tensor bundle consisting of all antisymmetric covariant tensors. <a href="Section_(fiber_bundle)" title="wikilink">Sections</a> of the exterior bundle are <a href="differential_forms" title="wikilink">differential forms</a> on <em>M</em>.</p>

<p>See also: <a href="Tensor_product_bundle" title="wikilink">Tensor product bundle</a>.</p>

<p>One important case when one forms a tensor product over a sheaf of non-commutative rings appears in theory of <a href="D-modules" title="wikilink"><em>D</em>-modules</a>; this sheaf of rings over which tensor products are formed is the <a href="sheaf_of_differential_operators" title="wikilink">sheaf of differential operators</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Tor_functor" title="wikilink">Tor functor</a></li>
<li><a href="Tensor_product_of_algebras" title="wikilink">Tensor product of algebras</a></li>
<li><a href="Tensor_product_of_fields" title="wikilink">Tensor product of fields</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>Bourbaki, <em>Algebra</em></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>Peter May (1999), <a href="http://www.maths.ed.ac.uk/~aar/papers/maybook.pdf"><em>A concise course in algebraic topology</em></a>, University of Chicago Press.</li>
</ul>

<p>"</p>

<p><a href="Category:Module_theory" title="wikilink">Category:Module theory</a> <a href="Category:Multilinear_algebra" title="wikilink">Category:Multilinear algebra</a> <a href="Category:Homological_algebra" title="wikilink">Category:Homological algebra</a> <a href="Category:Binary_operations" title="wikilink">Category:Binary operations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Hazewinkel, et al. (2004), [<a class="uri" href="http://books.google.com.br/books?id=AibpdVNkFDYC&amp;pg">http://books.google.com.br/books?id=AibpdVNkFDYC&amp;pg;</a>;=PA95 p. 95], Prop. 4.5.1<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">First, if , then the claimed identification is given by 

<math display="inline" id="Tensor_product_of_modules:171">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>↦</mo>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\mapsto f^{\prime}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Tensor_product_of_modules:172">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)(y)=f(x,y)
  </annotation>
 </semantics>
</math>

. In general, 

<math display="inline" id="Tensor_product_of_modules:173">
 <semantics>
  <mrow>
   <msub>
    <mo>Hom</mo>
    <mi>ℤ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mi>G</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Hom</ci>
     <ci>ℤ</ci>
    </apply>
    <ci>N</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}_{\mathbb{Z}}(N,G)
  </annotation>
 </semantics>
</math>


 has the structure of a right <em>R</em>-module by 

<math display="inline" id="Tensor_product_of_modules:174">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mo>⋅</mo>
      <mi>r</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <ci>g</ci>
      <ci>r</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (g\cdot r)(y)=g(ry)
  </annotation>
 </semantics>
</math>

. Thus, for any <strong>Z</strong>-bilinear map <em>f</em>, <em>f</em>′ is <em>R</em>-linear 

<math display="inline" id="Tensor_product_of_modules:175">
 <semantics>
  <mrow>
   <mo>⇔</mo>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mi>r</mi>
   <mo>⇔</mo>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mi>r</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-⇔</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">r</csymbol>
    <ci>normal-⇔</ci>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow f^{\prime}(xr)=f^{\prime}(x)\cdot r\Leftrightarrow f(xr,y)=f(x%
,ry).
  </annotation>
 </semantics>
</math>

<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">The first three properties (plus identities on morphisms) say that the category of <em>R</em>-modules, with <em>R</em> commutative, forms a <a href="symmetric_monoidal_category" title="wikilink">symmetric monoidal category</a>.<a href="#fnref6">↩</a></li>
<li id="fn7">Proof: (using associativity in a general form) 

<math display="inline" id="Tensor_product_of_modules:176">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>M</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>S</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <msub>
       <mo>⊗</mo>
       <mi>S</mi>
      </msub>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>N</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mi>S</mi>
    </msub>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>N</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>M</mi>
      <mi>S</mi>
     </msub>
     <msub>
      <mo>⊗</mo>
      <mi>S</mi>
     </msub>
     <mi>S</mi>
    </mrow>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>N</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mi>S</mi>
    </msub>
    <msub>
     <mo>⊗</mo>
     <mi>S</mi>
    </msub>
    <msub>
     <mi>N</mi>
     <mi>S</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>R</ci>
       </apply>
       <ci>M</ci>
       <ci>N</ci>
      </apply>
      <ci>S</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>S</ci>
       </apply>
       <ci>S</ci>
       <ci>M</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>S</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>S</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>S</ci>
       </apply>
       <ci>S</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M\otimes_{R}N)_{S}=(S\otimes_{S}M)\otimes_{R}N=M_{S}\otimes_{R}N=M_{S}\otimes%
_{S}S\otimes_{R}N=M_{S}\otimes_{S}N_{S}
  </annotation>
 </semantics>
</math>

<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">Example 3.6 of <a class="uri" href="http://www.math.uconn.edu/~kconrad/blurbs/linmultialg/tensorprod.pdf">http://www.math.uconn.edu/~kconrad/blurbs/linmultialg/tensorprod.pdf</a><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">This is actually the <em>definition</em> of differential one-forms, global sections of 

<math display="inline" id="Tensor_product_of_modules:177">
 <semantics>
  <mrow>
   <msup>
    <mi>T</mi>
    <mo>*</mo>
   </msup>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <times></times>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{*}M
  </annotation>
 </semantics>
</math>

, in Helgason, but is equivalent to the usual definition that does not use module theory.<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
</ol>
</section>
</hr></body>
</html>
