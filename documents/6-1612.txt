   Church encoding      Church encoding  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     In mathematics , Church encoding is a means of representing data and operators in the lambda calculus . The data and operators form a mathematical structure which is embedded in the lambda calculus. The Church numerals are a representation of the natural numbers using lambda notation. The method is named for Alonzo Church , who first encoded data in the lambda calculus this way.  Terms that are usually considered primitive in other notations (such as integers, booleans, pairs, lists, and tagged unions) are mapped to higher-order functions under Church encoding. The Church-Turing thesis asserts that any computable operator (and its operands) can be represented under Church encoding. In the untyped lambda calculus the only primitive data type is the function.  The Church encoding is not intended as a practical implementation of primitive data types. Its use is to show that other primitives data types are not required to represent any calculation. The completeness is representational. Additional functions are needed to translate the representation into common data types, for display to people. It is not possible in general to decide if two functions are extensionally equal due to the undecidability of equivalence from Church's theorem . The translation may apply the function in some way to retrieve the value it represents, or look up its value as a literal lambda term.  Lambda calculus is usually interpreted as using intensional equality . There are potential problems with the interpretation of results because of the difference between the intensional and extensional definition of equality.  Church numerals  Church numerals are the representations of natural numbers under Church encoding. The higher-order function that represents natural number   n   n   n   is a function that maps any function   f   f   f   to its n -fold composition . In simpler terms, the "value" of the numeral is equivalent to the number of times the function encapsulates its argument.        f  n   =     f  ∘  f  ∘  ⋯  ∘  f   ⏟    n  times     .       superscript  f  n    subscript   normal-⏟    f  f  normal-⋯  f      n  times      f^{n}=\underbrace{f\circ f\circ\cdots\circ f}_{n\text{ times}}.\,     All Church numerals are functions that take two parameters. Church numerals 0 , 1 , 2 , ..., are defined as follows in the lambda calculus .  Starting with  zero  not applying the function at all, proceed with  one  applying the function once, ... :      Number   Function definition   Lambda expression       0         0    f   x   =  x        0  f  x   x    0\ f\ x=x           0  =   λ  f    .   λ  x   .  x     formulae-sequence    0    λ  f      λ  x   x    0=\lambda f.\lambda x.x        1         1    f   x   =    f   x         1  f  x     f  x     1\ f\ x=f\ x           1  =   λ  f    .   λ  x   .    f   x      formulae-sequence    1    λ  f      λ  x     f  x     1=\lambda f.\lambda x.f\ x        2         2    f   x   =    f    (    f   x   )          2  f  x     f    f  x      2\ f\ x=f\ (f\ x)           2  =   λ  f    .   λ  x   .    f    (    f   x   )       formulae-sequence    2    λ  f      λ  x     f    f  x      2=\lambda f.\lambda x.f\ (f\ x)        3         3    f   x   =    f    (    f    (    f   x   )    )          3  f  x     f    f    f  x       3\ f\ x=f\ (f\ (f\ x))           3  =   λ  f    .   λ  x   .    f    (    f    (    f   x   )    )       formulae-sequence    3    λ  f      λ  x     f    f    f  x       3=\lambda f.\lambda x.f\ (f\ (f\ x))        ...     n         n    f   x   =     f  n    x         n  f  x      superscript  f  n   x     n\ f\ x=f^{n}\ x           n  =   λ  f    .   λ  x   .     f  n    x      formulae-sequence    n    λ  f      λ  x      superscript  f  n   x     n=\lambda f.\lambda x.f^{n}\ x        The Church numeral 3 represents the action of applying any given function three times to a value. The supplied function is first applied to a supplied parameter and then successively to its own result. The end result is not the numeral 3 (unless the supplied parameter happens to be 0 and the function is a successor function). The function itself, and not its end result, is the Church numeral 3 . The Church numeral 3 means simply to do anything three times. It is an ostensive demonstration of what is meant by "three times".  Calculation with Church numerals  Arithmetic operations on numbers may be represented by functions on Church numerals. These functions may be defined in lambda calculus , or implemented in most functional programming languages (see converting lambda expressions to functions ).  The addition function     plus   (  m  ,  n  )    =   m  +  n        plus  m  n     m  n     \operatorname{plus}(m,n)=m+n   uses the identity      f   (   m  +  n   )     (  x  )    =    f  m    (    f  n    (  x  )    )           superscript  f    m  n    x      superscript  f  m      superscript  f  n   x      f^{(m+n)}(x)=f^{m}(f^{n}(x))   .       plus  ≡   λ  m    .   λ  n   .   λ  f   .   λ  x   .    m    f    (    n    f   x   )       formulae-sequence    plus    λ  m      λ  n     λ  f     λ  x     m  f    n  f  x      \operatorname{plus}\equiv\lambda m.\lambda n.\lambda f.\lambda x.m\ f\ (n\ f\ x)     The successor function     succ   (  n  )    =   n  +  1        succ  n     n  1     \operatorname{succ}(n)=n+1   is β-equivalent to    (   plus  1   )     plus  1    (\operatorname{plus}\ 1)   .       succ  ≡   λ  n    .   λ  f   .   λ  x   .    f    (    n    f   x   )       formulae-sequence    succ    λ  n      λ  f     λ  x     f    n  f  x      \operatorname{succ}\equiv\lambda n.\lambda f.\lambda x.f\ (n\ f\ x)     The multiplication function     mult   (  m  ,  n  )    =   m  *  n        mult  m  n     m  n     \operatorname{mult}(m,n)=m*n   uses the identity      f   (   m  *  n   )     (  x  )    =     (   f  n   )   m    (  x  )           superscript  f    m  n    x      superscript   superscript  f  n   m   x     f^{(m*n)}(x)=(f^{n})^{m}(x)   .       mult  ≡   λ  m    .   λ  n   .   λ  f   .    m    (    n   f   )       formulae-sequence    mult    λ  m      λ  n     λ  f     m    n  f      \operatorname{mult}\equiv\lambda m.\lambda n.\lambda f.m\ (n\ f)     The exponentiation function     exp   (  m  ,  n  )    =   m  n        exp  m  n    superscript  m  n     \operatorname{exp}(m,n)=m^{n}   is given by the definition of Church numerals;      n    f   x   =     f  n    x         n  f  x      superscript  f  n   x     n\ f\ x=f^{n}\ x   . In the definition substitute     f  →  m   ,   x  →  f      formulae-sequence   normal-→  f  m    normal-→  x  f     f\to m,x\to f   to get      n    m   f   =     m  n    f         n  m  f      superscript  m  n   f     n\ m\ f=m^{n}\ f   and,       exp    m   n    =   m  n   =    n   m          exp    m  n     superscript  m  n          n  m      \operatorname{exp}\ m\ n=m^{n}=n\ m   which gives the lambda expression,       exp  ≡   λ  m    .   λ  n   .    n   m      formulae-sequence    exp    λ  m      λ  n     n  m     \operatorname{exp}\equiv\lambda m.\lambda n.n\ m     The    pred   (  n  )      pred  n    \operatorname{pred}(n)   function is more difficult to understand.      pred  ≡  λ  n  .  λ  f  .  λ  x  .   n    (  λ  g  .  λ  h  .   h    (   g   f  )   )    (  λ  u  .  x  )    (  λ  u  .  u  )      fragments  pred   λ  n  normal-.  λ  f  normal-.  λ  x  normal-.  n   fragments  normal-(  λ  g  normal-.  λ  h  normal-.  h   fragments  normal-(  g  f  normal-)   normal-)    fragments  normal-(  λ  u  normal-.  x  normal-)    fragments  normal-(  λ  u  normal-.  u  normal-)     \operatorname{pred}\equiv\lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h%
 .h\ (g\ f))\ (\lambda u.x)\ (\lambda u.u)     A Church numeral applies a function n times. The predecessor function must return a function that applies its parameter n - 1 times. This is achieved by building a container around f and x , which is initialized in a way that omits the application of the function the first time. See predecessor for a more detailed explanation.  The subtraction function can be written based on the predecessor function.       minus  ≡   λ  m    .   λ  n   .    (   n  pred   )   m      formulae-sequence    minus    λ  m      λ  n       n  pred   m     \operatorname{minus}\equiv\lambda m.\lambda n.(n\operatorname{pred})\ m     Table of functions on Church numerals      Function   Algebra   Identity   Function definition   Lambda expressions       Successor       n  +  1      n  1    n+1             f   n  +  1     x   =   f   (    f  n   x   )           superscript  f    n  1    x     f     superscript  f  n   x      f^{n+1}\ x=f(f^{n}x)           succ    n    f   x    =    f    (    n    f   x   )         succ    n  f  x      f    n  f  x      \operatorname{succ}\ n\ f\ x=f\ (n\ f\ x)           λ  n   .   λ  f   .   λ  x   .    f    (    n    f   x   )       formulae-sequence    λ  n     λ  f     λ  x     f    n  f  x      \lambda n.\lambda f.\lambda x.f\ (n\ f\ x)        Addition       m  +  n      m  n    m+n             f   m  +  n     x   =    f  m    (    f  n   x   )           superscript  f    m  n    x      superscript  f  m      superscript  f  n   x      f^{m+n}\ x=f^{m}(f^{n}x)           plus    m    n    f   x    =    m    f    (    n    f   x   )         plus    m  n  f  x      m  f    n  f  x      \operatorname{plus}\ m\ n\ f\ x=m\ f\ (n\ f\ x)           λ  m   .   λ  n   .   λ  f   .   λ  x   .    m    f    (    n    f   x   )       formulae-sequence    λ  m     λ  n     λ  f     λ  x     m  f    n  f  x      \lambda m.\lambda n.\lambda f.\lambda x.m\ f\ (n\ f\ x)        Multiplication       m  *  n      m  n    m*n             f   m  *  n     x   =      (   f  m   )   n    x          superscript  f    m  n    x      superscript   superscript  f  m   n   x     f^{m*n}\ x=(f^{m})^{n}\ x           multiply    m    n    f   x    =    m    (    n   f   )   x        multiply    m  n  f  x      m    n  f   x     \operatorname{multiply}\ m\ n\ f\ x=m\ (n\ f)\ x           λ  m   .   λ  n   .   λ  f   .   λ  x   .    m    (    n   f   )   x      formulae-sequence    λ  m     λ  n     λ  f     λ  x     m    n  f   x     \lambda m.\lambda n.\lambda f.\lambda x.m\ (n\ f)\ x        Exponentiation       m  n     superscript  m  n    m^{n}            n    m   f   =     m  n    f         n  m  f      superscript  m  n   f     n\ m\ f=m^{n}\ f    1        exp    m    n    f   x    =    (    n   m   )    f   x        exp    m  n  f  x        n  m   f  x     \operatorname{exp}\ m\ n\ f\ x=(n\ m)\ f\ x           λ  m   .   λ  n   .   λ  f   .   λ  x   .    (    n   m   )    f   x      formulae-sequence    λ  m     λ  n     λ  f     λ  x       n  m   f  x     \lambda m.\lambda n.\lambda f.\lambda x.(n\ m)\ f\ x        Predecessor *       n  -  1      n  1    n-1            inc  n   con   =   val   (    f   n  -  1    x   )          superscript  inc  n   con    val     superscript  f    n  1    x      \operatorname{inc}^{n}\operatorname{con}=\operatorname{val}(f^{n-1}x)         pred   pred   \operatorname{pred}   ...       λ  n  .  λ  f  .  λ  x  .   n    (  λ  g  .  λ  h  .   h    (   g   f  )   )    (  λ  u  .  x  )    (  λ  u  .  u  )      fragments  λ  n  normal-.  λ  f  normal-.  λ  x  normal-.  n   fragments  normal-(  λ  g  normal-.  λ  h  normal-.  h   fragments  normal-(  g  f  normal-)   normal-)    fragments  normal-(  λ  u  normal-.  x  normal-)    fragments  normal-(  λ  u  normal-.  u  normal-)     \lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (g\ f))\ (\lambda u.x%
 )\ (\lambda u.u)        Subtraction *       m  -  n      m  n    m-n             f   m  -  n     x   =     (   f   -  1    )   n    (    f  m   x   )           superscript  f    m  n    x      superscript   superscript  f    1    n      superscript  f  m   x      f^{m-n}\ x=(f^{-1})^{n}(f^{m}x)           minus    m   n    =    (   n  pred   )   m        minus    m  n        n  pred   m     \operatorname{minus}\ m\ n=(n\operatorname{pred})\ m      ...     * Note that in the Church encoding,        pred   (  0  )    =  0       pred  0   0    \operatorname{pred}(0)=0         m  <  n  →   m  -  n   =  0        m  n    normal-→      m  n        0     m      Translation with other representations  Most real-world languages have support for machine-native integers; the church and unchurch functions convert between nonnegative integers and their corresponding Church numerals. The functions are given here in Haskell , where the \ corresponds to the λ of Lambda calculus. Implementations in other languages are similar.   type  Church a = (a -> a) -> a -> a church ::  Integer  ->  Church  Integer church 0  = \f -> \x -> x
 church n = \f -> \x -> f (church (n - 1 ) f x) unchurch ::  Church  Integer  ->  Integer unchurch cn = cn ( +  1 ) 0  Church Booleans  Church Booleans are the Church encoding of the Boolean values true and false. Some programming languages use these as an implementation model for Boolean arithmetic; examples are Smalltalk and Pico .  Boolean logic may be considered as a choice. The Church encoding of true and false are functions of two parameters;   true chooses the first parameter.  false chooses the second parameter.   The two definitions are known as Church Booleans;       true  ≡   λ  a    .   λ  b   .  a     formulae-sequence    true    λ  a      λ  b   a    \operatorname{true}\equiv\lambda a.\lambda b.a          false  ≡   λ  a    .   λ  b   .  b     formulae-sequence    false    λ  a      λ  b   b    \operatorname{false}\equiv\lambda a.\lambda b.b     This definition allows predicates (i.e. functions returning logical values ) to directly act as if-clauses. A function returning a Boolean, which is then applied to two parameters, returns either the first or the second parameter;       predicate   x       then  -  clause     else  -  clause         predicate  x      then  clause     else  clause      \operatorname{predicate}\ x\ \operatorname{then-clause}\ \operatorname{else-clause}   evaluates to then-clause if predicate x evaluates to true , and to else-clause if predicate x evaluates to false .  Because true and false choose the first or second parameter they may be combined to provide logic operators,       and  =   λ  p    .   λ  q   .    p    q   p      formulae-sequence    and    λ  p      λ  q     p  q  p     \operatorname{and}=\lambda p.\lambda q.p\ q\ p          or  =   λ  p    .   λ  q   .    p    p   q      formulae-sequence    or    λ  p      λ  q     p  p  q     \operatorname{or}=\lambda p.\lambda q.p\ p\ q           not  1   =   λ  p    .   λ  a   .   λ  b   .    p    b   a      formulae-sequence     subscript  not  1     λ  p      λ  a     λ  b     p  b  a     \operatorname{not}_{1}=\lambda p.\lambda a.\lambda b.p\ b\ a   - This is only a correct implementation if the evaluation strategy is applicative order.       not  2   =  λ  p  .   p    (  λ  a  .  λ  b  .  b  )    (  λ  a  .  λ  b  .  a  )   =  λ  p  .  p  false  true     fragments   subscript  not  2    λ  p  normal-.  p   fragments  normal-(  λ  a  normal-.  λ  b  normal-.  b  normal-)    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)    λ  p  normal-.  p  false  true    \operatorname{not}_{2}=\lambda p.p\ (\lambda a.\lambda b.b)\ (\lambda a.%
 \lambda b.a)=\lambda p.p\operatorname{false}\operatorname{true}   - This is only a correct implementation if the evaluation strategy is normal order.       xor  =   λ  a    .   λ  b   .    a    (   not  b   )   b      formulae-sequence    xor    λ  a      λ  b     a   not  b   b     \operatorname{xor}=\lambda a.\lambda b.a\ (\operatorname{not}\ b)\ b          if  =   λ  p    .   λ  a   .   λ  b   .    p    a   b      formulae-sequence    if    λ  p      λ  a     λ  b     p  a  b     \operatorname{if}=\lambda p.\lambda a.\lambda b.p\ a\ b     Some examples:      and  true  false  =   (  λ  p  .  λ  q  .   p    q   p  )   true  false  =  true  false  true  =   (  λ  a  .  λ  b  .  a  )   false  true  =  false     fragments  and  true  false    fragments  normal-(  λ  p  normal-.  λ  q  normal-.  p  q  p  normal-)   true  false   true  false  true    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)   false  true   false    \operatorname{and}\operatorname{true}\operatorname{false}=(\lambda p.\lambda q%
 .p\ q\ p)\ \operatorname{true}\ \operatorname{false}=\operatorname{true}%
 \operatorname{false}\operatorname{true}=(\lambda a.\lambda b.a)\operatorname{%
 false}\operatorname{true}=\operatorname{false}         or  true  false  =   (  λ  p  .  λ  q  .   p    p   q  )    (  λ  a  .  λ  b  .  a  )    (  λ  a  .  λ  b  .  b  )   =   (  λ  a  .  λ  b  .  a  )    (  λ  a  .  λ  b  .  a  )    (  λ  a  .  λ  b  .  b  )   =   (  λ  a  .  λ  b  .  a  )   =  true     fragments  or  true  false    fragments  normal-(  λ  p  normal-.  λ  q  normal-.  p  p  q  normal-)    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  b  normal-)     fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  b  normal-)     fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)    true    \operatorname{or}\operatorname{true}\operatorname{false}=(\lambda p.\lambda q.%
 p\ p\ q)\ (\lambda a.\lambda b.a)\ (\lambda a.\lambda b.b)=(\lambda a.\lambda b%
 .a)\ (\lambda a.\lambda b.a)\ (\lambda a.\lambda b.b)=(\lambda a.\lambda b.a)=%
 \operatorname{true}           not  1    true  =   (  λ  p  .  λ  a  .  λ  b  .   p    b   a  )    (  λ  a  .  λ  b  .  a  )   =  λ  a  .  λ  b  .   (  λ  a  .  λ  b  .  a  )    b   a  =  λ  a  .  λ  b  .   (  λ  x  .  b  )   a  =  λ  a  .  λ  b  .  b  =  false     fragments   subscript  not  1   true    fragments  normal-(  λ  p  normal-.  λ  a  normal-.  λ  b  normal-.  p  b  a  normal-)    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)    λ  a  normal-.  λ  b  normal-.   fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)   b  a   λ  a  normal-.  λ  b  normal-.   fragments  normal-(  λ  x  normal-.  b  normal-)   a   λ  a  normal-.  λ  b  normal-.  b   false    \operatorname{not}_{1}\ \operatorname{true}=(\lambda p.\lambda a.\lambda b.p\ %
 b\ a)(\lambda a.\lambda b.a)=\lambda a.\lambda b.(\lambda a.\lambda b.a)\ b\ a%
 =\lambda a.\lambda b.(\lambda x.b)\ a=\lambda a.\lambda b.b=\operatorname{false}           not  2    true  =   (  λ  p  .   p    (  λ  a  .  λ  b  .  b  )    (  λ  a  .  λ  b  .  a  )   )    (  λ  a  .  λ  b  .  a  )   =   (  λ  a  .  λ  b  .  a  )    (  λ  a  .  λ  b  .  b  )    (  λ  a  .  λ  b  .  a  )   =   (  λ  b  .   (  λ  a  .  λ  b  .  b  )   )    (  λ  a  .  λ  b  .  a  )   =  λ  a  .  λ  b  .  b  =  false     fragments   subscript  not  2   true    fragments  normal-(  λ  p  normal-.  p   fragments  normal-(  λ  a  normal-.  λ  b  normal-.  b  normal-)    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)   normal-)    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)     fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  b  normal-)    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)     fragments  normal-(  λ  b  normal-.   fragments  normal-(  λ  a  normal-.  λ  b  normal-.  b  normal-)   normal-)    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)    λ  a  normal-.  λ  b  normal-.  b   false    \operatorname{not}_{2}\ \operatorname{true}=(\lambda p.p\ (\lambda a.\lambda b%
 .b)(\lambda a.\lambda b.a))(\lambda a.\lambda b.a)=(\lambda a.\lambda b.a)(%
 \lambda a.\lambda b.b)(\lambda a.\lambda b.a)=(\lambda b.(\lambda a.\lambda b.%
 b))\ (\lambda a.\lambda b.a)=\lambda a.\lambda b.b=\operatorname{false}     Predicates  A predicate is a function that returns a Boolean value. The most fundamental predicate is   IsZero   IsZero   \operatorname{IsZero}   , which returns   true   true   \operatorname{true}   if its argument is the Church numeral   0   0    , and   false   false   \operatorname{false}   if its argument is any other Church numeral:      IsZero  =  λ  n  .   n    (  λ  x  .  false  )   true     fragments  IsZero   λ  n  normal-.  n   fragments  normal-(  λ  x  normal-.  false  normal-)   true    \operatorname{IsZero}=\lambda n.n\ (\lambda x.\operatorname{false})\ %
 \operatorname{true}     The following predicate tests whether the first argument is less-than-or-equal-to the second:       LEQ  =   λ  m    .   λ  n   .   IsZero   (   minus    m   n    )       formulae-sequence    LEQ    λ  m      λ  n    IsZero   minus    m  n       \operatorname{LEQ}=\lambda m.\lambda n.\operatorname{IsZero}\ (\operatorname{%
 minus}\ m\ n)   ,  Because of the identity,      x  =  y  ≡   (  x  ≤  y  and  y  ≤  x  )      fragments  x   y    fragments  normal-(  x   y  and  y   x  normal-)     x=y\equiv(x<=y\and y<=x)   The test for equality may be implemented as,       EQ  =   λ  m    .   λ  n   .    and   (   LEQ    m   n    )     (   LEQ    n   m    )       formulae-sequence    EQ    λ  m      λ  n     and   LEQ    m  n      LEQ    n  m       \operatorname{EQ}=\lambda m.\lambda n.\operatorname{and}\ (\operatorname{LEQ}%
 \ m\ n)\ (\operatorname{LEQ}\ n\ m)     Church pairs  Church pairs are the Church encoding of the pair (two-tuple) type. The pair is represented as a function that takes a function argument. When given its argument it will apply the argument to the two components of the pair. The definition in lambda calculus is,       pair  ≡   λ  x    .   λ  y   .   λ  z   .    z    x   y      formulae-sequence    pair    λ  x      λ  y     λ  z     z  x  y     \operatorname{pair}\equiv\lambda x.\lambda y.\lambda z.z\ x\ y         first  ≡  λ  p  .   p    (  λ  x  .  λ  y  .  x  )      fragments  first   λ  p  normal-.  p   fragments  normal-(  λ  x  normal-.  λ  y  normal-.  x  normal-)     \operatorname{first}\equiv\lambda p.p\ (\lambda x.\lambda y.x)         second  ≡  λ  p  .   p    (  λ  x  .  λ  y  .  y  )      fragments  second   λ  p  normal-.  p   fragments  normal-(  λ  x  normal-.  λ  y  normal-.  y  normal-)     \operatorname{second}\equiv\lambda p.p\ (\lambda x.\lambda y.y)     For example,      first   (   pair    a   b    )      first   pair    a  b      \operatorname{first}\ (\operatorname{pair}\ a\ b)           =   (  λ  p  .   p    (  λ  x  .  λ  y  .  x  )   )    (   (  λ  x  .  λ  y  .  λ  z  .   z    x   y  )    a   b  )      fragments    fragments  normal-(  λ  p  normal-.  p   fragments  normal-(  λ  x  normal-.  λ  y  normal-.  x  normal-)   normal-)    fragments  normal-(   fragments  normal-(  λ  x  normal-.  λ  y  normal-.  λ  z  normal-.  z  x  y  normal-)   a  b  normal-)     =(\lambda p.p\ (\lambda x.\lambda y.x))\ ((\lambda x.\lambda y.\lambda z.z\ x%
 \ y)\ a\ b)         =   (  λ  p  .   p    (  λ  x  .  λ  y  .  x  )   )    (  λ  z  .   z    a   b  )      fragments    fragments  normal-(  λ  p  normal-.  p   fragments  normal-(  λ  x  normal-.  λ  y  normal-.  x  normal-)   normal-)    fragments  normal-(  λ  z  normal-.  z  a  b  normal-)     =(\lambda p.p\ (\lambda x.\lambda y.x))\ (\lambda z.z\ a\ b)         =   (  λ  z  .   z    a   b  )    (  λ  x  .  λ  y  .  x  )      fragments    fragments  normal-(  λ  z  normal-.  z  a  b  normal-)    fragments  normal-(  λ  x  normal-.  λ  y  normal-.  x  normal-)     =(\lambda z.z\ a\ b)\ (\lambda x.\lambda y.x)         =   (  λ  x  .  λ  y  .  x  )    a   b  =  a     fragments    fragments  normal-(  λ  x  normal-.  λ  y  normal-.  x  normal-)   a  b   a    =(\lambda x.\lambda y.x)\ a\ b=a        List encodings  An ( immutable ) list is constructed from list nodes. The basic operations on the list are;      Function   Description       nil   Construct an empty list.     isnil   Test if list is empty.     cons   Prepend a given value to a (possibly empty) list.     head   Get the first element of the list.     tail   Get the rest of the list.     Three different representations of lists are given.   Build each list node from two pairs (to allow for empty lists).  Build each list node from one pair.  Represent the list using the right fold function .   Two pairs as a list node  A nonempty list can implemented by a Church pair;   First contains the head.  Second contains the tail.   However this does not give a representation of the empty list, because there is no "null" pointer. To represent null, the pair may be wrapped in another pair, giving free values,   First - Is the null pointer (empty list).  Second.First contains the head.  Second.Second contains the tail.   Using this idea the basic list operations can be defined like this: 2      Expression   Description           nil  ≡   pair   true  true        nil   pair   true  true      \operatorname{nil}\equiv\operatorname{pair}\ \operatorname{true}\ %
 \operatorname{true}      The first element of the pair is true meaning the list is null.         isnil  ≡  first      isnil  first    \operatorname{isnil}\equiv\operatorname{first}      Retrieve the null (or empty list) indicator.          cons  ≡   λ  h    .   λ  t   .   pair   false   (   pair    h   t    )        formulae-sequence    cons    λ  h      λ  t    pair   false   pair    h  t        \operatorname{cons}\equiv\lambda h.\lambda t.\operatorname{pair}\operatorname{%
 false}\ (\operatorname{pair}h\ t)      Create a list node, which is not null, and give it a head h and a tail t .          head  ≡   λ  z    .   first   (   second  z   )       formulae-sequence    head    λ  z     first   second  z      \operatorname{head}\equiv\lambda z.\operatorname{first}\ (\operatorname{second%
 }z)      second.first is the head.          tail  ≡   λ  z    .   second   (   second  z   )       formulae-sequence    tail    λ  z     second   second  z      \operatorname{tail}\equiv\lambda z.\operatorname{second}\ (\operatorname{%
 second}z)      second.second is the tail.     In a nil node second is never accessed, provided that head and tail are only applied to nonempty lists.  One pair as a list node  Alternatively, define 3      cons  ≡  pair      cons  pair    \operatorname{cons}\equiv\operatorname{pair}         head  ≡  first      head  first    \operatorname{head}\equiv\operatorname{first}         tail  ≡  second      tail  second    \operatorname{tail}\equiv\operatorname{second}         nil  ≡  false      nil  false    \operatorname{nil}\equiv\operatorname{false}         isnil  ≡  λ  l  .  l   (  λ  h  .  λ  t  .  λ  d  .  false  )   true     fragments  isnil   λ  l  normal-.  l   fragments  normal-(  λ  h  normal-.  λ  t  normal-.  λ  d  normal-.  false  normal-)   true    \operatorname{isnil}\equiv\lambda l.l(\lambda h.\lambda t.\lambda d.%
 \operatorname{false})\operatorname{true}   where the last definition is a special case of the general       process  -  list   ≡  λ  l  .  l   (  λ  h  .  λ  t  .  λ  d  .   head  -  and  -  tail  -  clause   )    nil  -  clause      fragments    process  list    λ  l  normal-.  l   fragments  normal-(  λ  h  normal-.  λ  t  normal-.  λ  d  normal-.    head  and  tail  clause   normal-)     nil  clause     \operatorname{process-list}\equiv\lambda l.l(\lambda h.\lambda t.\lambda d.%
 \operatorname{head-and-tail-clause})\operatorname{nil-clause}     Represent the list using right fold  As an alternative to the encoding using Church pairs, a list can be encoded by identifying it with its right fold function . For example, a list of three elements x, y and z can be encoded by a higher-order function that when applied to a combinator c and a value n returns c x (c y (c z n)).       nil  ≡   λ  c    .   λ  n   .  n     formulae-sequence    nil    λ  c      λ  n   n    \operatorname{nil}\equiv\lambda c.\lambda n.n         isnil  ≡  λ  l  .   l    (  λ  h  .  λ  t  .  false  )   true     fragments  isnil   λ  l  normal-.  l   fragments  normal-(  λ  h  normal-.  λ  t  normal-.  false  normal-)   true    \operatorname{isnil}\equiv\lambda l.l\ (\lambda h.\lambda t.\operatorname{%
 false})\ \operatorname{true}          cons  ≡   λ  h    .   λ  t   .   λ  c   .   λ  n   .    c    h    (    t    c   n   )       formulae-sequence    cons    λ  h      λ  t     λ  c     λ  n     c  h    t  c  n      \operatorname{cons}\equiv\lambda h.\lambda t.\lambda c.\lambda n.c\ h\ (t\ c\ n)         head  ≡  λ  l  .   l    (  λ  h  .  λ  t  .  h  )   false     fragments  head   λ  l  normal-.  l   fragments  normal-(  λ  h  normal-.  λ  t  normal-.  h  normal-)   false    \operatorname{head}\equiv\lambda l.l\ (\lambda h.\lambda t.h)\ \operatorname{false}         tail  ≡  λ  l  .  λ  c  .  λ  n  .   l    (  λ  h  .  λ  t  .  λ  g  .   g    h    (   t   c  )   )    (  λ  t  .  n  )    (  λ  h  .  λ  t  .  t  )      fragments  tail   λ  l  normal-.  λ  c  normal-.  λ  n  normal-.  l   fragments  normal-(  λ  h  normal-.  λ  t  normal-.  λ  g  normal-.  g  h   fragments  normal-(  t  c  normal-)   normal-)    fragments  normal-(  λ  t  normal-.  n  normal-)    fragments  normal-(  λ  h  normal-.  λ  t  normal-.  t  normal-)     \operatorname{tail}\equiv\lambda l.\lambda c.\lambda n.l\ (\lambda h.\lambda t%
 .\lambda g.g\ h\ (t\ c))\ (\lambda t.n)\ (\lambda h.\lambda t.t)     Derivation of predecessor function  The predecessor function used in the Church encoding is,       pred   (  n  )    =   {     0       if  n   =  0   ,        n  -  1     otherwise           pred  n    cases  0      if  n   0     n  1   otherwise     \operatorname{pred}(n)=\begin{cases}0&\mbox{if }n=0,\\
 n-1&\mbox{otherwise}\end{cases}   .  To build the predecessor we need a way of applying the function 1 fewer time. A numeral n applies the function f  n times to x . The predecessor function must use the numeral n to apply the function n-1 times.  Before implementing the predecessor function, here is a scheme that wraps the value in a container function. We will define new functions to use in place of f and x , called inc and init . The container function is called value . The left hand side of the table shows a numeral n applied to inc and init .      Number   Using init   Using const       0       init  =   value  x       init   value  x     \operatorname{init}=\operatorname{value}\ x         1        inc  init   =   value   (    f   x   )         inc  init    value    f  x      \operatorname{inc}\ \operatorname{init}=\operatorname{value}\ (f\ x)           inc  const   =   value  x        inc  const    value  x     \operatorname{inc}\ \operatorname{const}=\operatorname{value}\ x        2        inc   (   inc  init   )    =   value   (    f    (    f   x   )    )         inc   inc  init     value    f    f  x       \operatorname{inc}\ (\operatorname{inc}\ \operatorname{init})=\operatorname{%
 value}\ (f\ (f\ x))           inc   (   inc  const   )    =   value   (    f   x   )         inc   inc  const     value    f  x      \operatorname{inc}\ (\operatorname{inc}\ \operatorname{const})=\operatorname{%
 value}\ (f\ x)        3        inc   (   inc   (   inc  init   )    )    =   value   (    f    (    f    (    f   x   )    )    )         inc   inc   inc  init      value    f    f    f  x        \operatorname{inc}\ (\operatorname{inc}\ (\operatorname{inc}\ \operatorname{%
 init}))=\operatorname{value}\ (f\ (f\ (f\ x)))           inc   (   inc   (   inc  const   )    )    =   value   (    f    (    f   x   )    )         inc   inc   inc  const      value    f    f  x       \operatorname{inc}\ (\operatorname{inc}\ (\operatorname{inc}\ \operatorname{%
 const}))=\operatorname{value}\ (f\ (f\ x))        ...     n        n   inc  init    =   value   (     f  n    x   )    =   value   (    n    f   x   )            n   inc  init     value     superscript  f  n   x          value    n  f  x       n\operatorname{inc}\ \operatorname{init}=\operatorname{value}\ (f^{n}\ x)=%
 \operatorname{value}\ (n\ f\ x)           n   inc  const    =   value   (     f   n  -  1     x   )    =   value   (    (   n  -  1   )    f   x   )            n   inc  const     value     superscript  f    n  1    x          value      n  1   f  x       n\operatorname{inc}\ \operatorname{const}=\operatorname{value}\ (f^{n-1}\ x)=%
 \operatorname{value}\ ((n-1)\ f\ x)        The general recurrence rule is,       inc   (   value  v   )    =   value   (    f   v   )         inc   value  v     value    f  v      \operatorname{inc}\ (\operatorname{value}\ v)=\operatorname{value}\ (f\ v)     If there is also a function to retrieve the value from the container (called extract ),       extract   (   value  v   )    =  v       extract   value  v    v    \operatorname{extract}\ (\operatorname{value}\ v)=v     Then extract may be used to define the samenum function as,       samenum  =   λ  n    .   λ  f   .   λ  x   .    extract   (   n   inc  init    )    =   λ  n    .   λ  f   .   λ  x   .    extract   (   value   (    n    f   x   )    )    =   λ  n    .   λ  f   .   λ  x   .     n    f   x   =   λ  n    .  n     formulae-sequence    samenum    λ  n      λ  f     λ  x      extract    n   inc  init       λ  n      λ  f     λ  x      extract   value    n  f  x       λ  n      λ  f     λ  x       n  f  x     λ  n    n    \operatorname{samenum}=\lambda n.\lambda f.\lambda x.\operatorname{extract}\ (%
 n\operatorname{inc}\operatorname{init})=\lambda n.\lambda f.\lambda x.%
 \operatorname{extract}\ (\operatorname{value}\ (n\ f\ x))=\lambda n.\lambda f.%
 \lambda x.n\ f\ x=\lambda n.n     The samenum function is not intrinsically useful. However, as inc delegates calling of f to its container argument, we can arrange that on the first application inc receives a special container that ignores its argument allowing to skip the first application of f . Call this new initial container const . The right hand side of the above table shows the expansions of n  inc  const . Then by replacing init with const in the expression for the same function we get the predecessor function,       pred  =   λ  n    .   λ  f   .   λ  x   .    extract   (   n   inc  const    )    =   λ  n    .   λ  f   .   λ  x   .    extract   (   value   (    (   n  -  1   )    f   x   )    )    =   λ  n    .   λ  f   .   λ  x   .     (   n  -  1   )    f   x   =   λ  n    .   (   n  -  1   )      formulae-sequence    pred    λ  n      λ  f     λ  x      extract    n   inc  const       λ  n      λ  f     λ  x      extract   value      n  1   f  x       λ  n      λ  f     λ  x         n  1   f  x     λ  n      n  1     \operatorname{pred}=\lambda n.\lambda f.\lambda x.\operatorname{extract}\ (n%
 \operatorname{inc}\operatorname{const})=\lambda n.\lambda f.\lambda x.%
 \operatorname{extract}\ (\operatorname{value}\ ((n-1)\ f\ x))=\lambda n.%
 \lambda f.\lambda x.(n-1)\ f\ x=\lambda n.(n-1)     As explained below the functions inc , init , const , value and extract may be defined as,         value   value   \operatorname{value}          extract  k     extract  k    \operatorname{extract}\ k         inc   inc   \operatorname{inc}         init   init   \operatorname{init}         const   const   \operatorname{const}              λ  v  .   (  λ  h  .   h   v  )      fragments  λ  v  normal-.   fragments  normal-(  λ  h  normal-.  h  v  normal-)     \lambda v.(\lambda h.h\ v)            k   λ  u   .  u     formulae-sequence    k  λ  u   u    k\ \lambda u.u           λ  g   .   λ  h   .    h    (    g   f   )       formulae-sequence    λ  g     λ  h     h    g  f      \lambda g.\lambda h.h\ (g\ f)           λ  h   .    h   x      formulae-sequence    λ  h     h  x     \lambda h.h\ x           λ  u   .  x     formulae-sequence    λ  u   x    \lambda u.x        Which gives the lambda expression for pred as,      pred  =  λ  n  .  λ  f  .  λ  x  .   n    (  λ  g  .  λ  h  .   h    (   g   f  )   )    (  λ  u  .  x  )    (  λ  u  .  u  )      fragments  pred   λ  n  normal-.  λ  f  normal-.  λ  x  normal-.  n   fragments  normal-(  λ  g  normal-.  λ  h  normal-.  h   fragments  normal-(  g  f  normal-)   normal-)    fragments  normal-(  λ  u  normal-.  x  normal-)    fragments  normal-(  λ  u  normal-.  u  normal-)     \operatorname{pred}=\lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (%
 g\ f))\ (\lambda u.x)\ (\lambda u.u)        Value container  The value container applies a function to its value. It is defined by,       value    v   h    =    h   v        value    v  h      h  v     \operatorname{value}\ v\ h=h\ v   so,      value  =  λ  v  .   (  λ  h  .   h   v  )      fragments  value   λ  v  normal-.   fragments  normal-(  λ  h  normal-.  h  v  normal-)     \operatorname{value}=\lambda v.(\lambda h.h\ v)     Inc  The inc function should take a value containing v , and return a new value containing f v .       inc   (   value  v   )    =   value   (    f   v   )         inc   value  v     value    f  v      \operatorname{inc}\ (\operatorname{value}\ v)=\operatorname{value}\ (f\ v)   Letting g be the value container,      g  =   value  v       g   value  v     g=\operatorname{value}\ v   then,        g   f   =   value    v   f    =    f   v           g  f    value    v  f           f  v      g\ f=\operatorname{value}\ v\ f=f\ v   so,       inc  g   =   value   (    g   f   )         inc  g    value    g  f      \operatorname{inc}\ g=\operatorname{value}\ (g\ f)          inc  =   λ  g    .   λ  h   .    h    (    g   f   )       formulae-sequence    inc    λ  g      λ  h     h    g  f      \operatorname{inc}=\lambda g.\lambda h.h\ (g\ f)     Extract  The value may be extracted by applying the identity function,       I  =   λ  u    .  u     formulae-sequence    I    λ  u    u    I=\lambda u.u   Using I ,       value    v   I    =  v       value    v  I    v    \operatorname{value}\ v\ I=v   so,       extract  k   =    k   I        extract  k     k  I     \operatorname{extract}\ k=k\ I     Const  To implement pred the init function is replaced with the const that does not apply f . We need const to satisfy,       inc  const   =   value  x        inc  const    value  x     \operatorname{inc}\ \operatorname{const}=\operatorname{value}\ x          λ  h   .     h    (   const  f   )    =   λ  h    .    h   x      formulae-sequence    λ  h       h   const  f      λ  h      h  x     \lambda h.h\ (\operatorname{const}\ f)=\lambda h.h\ x   Which is satisfied if,       const  f   =  x       const  f   x    \operatorname{const}\ f=x   Or as a lambda expression,       const  =   λ  u    .  x     formulae-sequence    const    λ  u    x    \operatorname{const}=\lambda u.x        Division  Division of natural numbers may be implemented by, 4       n  /  m   =   if  n   ≥     m    then  1    +     (   n  -  m   )   /   m     else  0             n  m    if  n            m   then  1          n  m   m    else  0        n/m=\operatorname{if}\ n>=m\ \operatorname{then}\ 1+(n-m)/m\ \operatorname{%
 else}\ 0     Calculating    n  -  m      n  m    n-m   takes many beta reductions. Unless doing the reduction by hand, this doesn't matter that much, but it is preferable to not have to do this calculation twice. The simplest predicate for testing numbers is IsZero so consider the condition.      IsZero   (   minus    n   m    )      IsZero   minus    n  m      \operatorname{IsZero}\ (\operatorname{minus}\ n\ m)   But this condition is equivalent to    n  >  m      n  m    n>m   , not    n  ≥  m      n  m    n>=m   . If this expression is used then the mathematical definition of division given above is translated into function on Church numerals as,      divide1   n    m    f   x  =   (  λ  d  .  IsZero   d    (   0    f   x  )    (   f    (  divide1   d    m    f   x  )   )   )    (  minus   n   m  )      fragments  divide1  n  m  f  x    fragments  normal-(  λ  d  normal-.  IsZero  d   fragments  normal-(  0  f  x  normal-)    fragments  normal-(  f   fragments  normal-(  divide1  d  m  f  x  normal-)   normal-)   normal-)    fragments  normal-(  minus  n  m  normal-)     \operatorname{divide1}\ n\ m\ f\ x=(\lambda d.\operatorname{IsZero}\ d\ (0\ f%
 \ x)\ (f\ (\operatorname{divide1}\ d\ m\ f\ x)))\ (\operatorname{minus}\ n\ m)     As desired, this definition has a single call to    minus    n   m      minus    n  m     \operatorname{minus}\ n\ m   . However the result is that this formula gives the value of     (   n  -  1   )   /  m        n  1   m    (n-1)/m   .  This problem may be corrected by adding 1 to n before calling divide .The definition of divide is then,       divide  n   =   divide1   (   succ  n   )         divide  n    divide1   succ  n      \operatorname{divide}\ n=\operatorname{divide1}\ (\operatorname{succ}\ n)     divide1 is a recursive definition. The Y combinator may be used to implement the recursion. Create a new function called div by;   In the left hand side    divide1  →   div  c      normal-→  divide1   div  c     \operatorname{divide1}\rightarrow\operatorname{div}\ c     In the right hand side    divide1  →  c     normal-→  divide1  c    \operatorname{divide1}\rightarrow c      to get,      div  =  λ  c  .  λ  n  .  λ  m  .  λ  f  .  λ  x  .   (  λ  d  .  IsZero   d    (   0    f   x  )    (   f    (   c    d    m    f   x  )   )   )    (  minus   n   m  )      fragments  div   λ  c  normal-.  λ  n  normal-.  λ  m  normal-.  λ  f  normal-.  λ  x  normal-.   fragments  normal-(  λ  d  normal-.  IsZero  d   fragments  normal-(  0  f  x  normal-)    fragments  normal-(  f   fragments  normal-(  c  d  m  f  x  normal-)   normal-)   normal-)    fragments  normal-(  minus  n  m  normal-)     \operatorname{div}=\lambda c.\lambda n.\lambda m.\lambda f.\lambda x.(\lambda d%
 .\operatorname{IsZero}\ d\ (0\ f\ x)\ (f\ (c\ d\ m\ f\ x)))\ (\operatorname{%
 minus}\ n\ m)     Then,       divide  =   λ  n    .   divide1   (   succ  n   )       formulae-sequence    divide    λ  n     divide1   succ  n      \operatorname{divide}=\lambda n.\operatorname{divide1}\ (\operatorname{succ}\ n)   where,      divide1  =    Y   div       divide1    Y  div     \operatorname{divide1}=Y\ \operatorname{div}          succ  =   λ  n    .   λ  f   .   λ  x   .    f    (    n    f   x   )       formulae-sequence    succ    λ  n      λ  f     λ  x     f    n  f  x      \operatorname{succ}=\lambda n.\lambda f.\lambda x.f\ (n\ f\ x)         Y  =  λ  f  .   (  λ  x  .   x   x  )    (  λ  x  .   f    (   x   x  )   )      fragments  Y   λ  f  normal-.   fragments  normal-(  λ  x  normal-.  x  x  normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)     Y=\lambda f.(\lambda x.x\ x)\ (\lambda x.f\ (x\ x))          0  =   λ  f    .   λ  x   .  x     formulae-sequence    0    λ  f      λ  x   x    0=\lambda f.\lambda x.x         IsZero  =  λ  n  .   n    (  λ  x  .  false  )   true     fragments  IsZero   λ  n  normal-.  n   fragments  normal-(  λ  x  normal-.  false  normal-)   true    \operatorname{IsZero}=\lambda n.n\ (\lambda x.\operatorname{false})\ %
 \operatorname{true}          true  ≡   λ  a    .   λ  b   .  a     formulae-sequence    true    λ  a      λ  b   a    \operatorname{true}\equiv\lambda a.\lambda b.a          false  ≡   λ  a    .   λ  b   .  b     formulae-sequence    false    λ  a      λ  b   b    \operatorname{false}\equiv\lambda a.\lambda b.b          minus  =   λ  m    .   λ  n   .   n   pred  m       formulae-sequence    minus    λ  m      λ  n     n   pred  m      \operatorname{minus}=\lambda m.\lambda n.n\operatorname{pred}m         pred  =  λ  n  .  λ  f  .  λ  x  .   n    (  λ  g  .  λ  h  .   h    (   g   f  )   )    (  λ  u  .  x  )    (  λ  u  .  u  )      fragments  pred   λ  n  normal-.  λ  f  normal-.  λ  x  normal-.  n   fragments  normal-(  λ  g  normal-.  λ  h  normal-.  h   fragments  normal-(  g  f  normal-)   normal-)    fragments  normal-(  λ  u  normal-.  x  normal-)    fragments  normal-(  λ  u  normal-.  u  normal-)     \operatorname{pred}=\lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (%
 g\ f))\ (\lambda u.x)\ (\lambda u.u)   Gives,      divide  =  λ  n  .   (   (  λ  f  .   (  λ  x  .   x   x  )    (  λ  x  .   f    (   x   x  )   )   )    (  λ  c  .  λ  n  .  λ  m  .  λ  f  .  λ  x  .   (  λ  d  .   (  λ  n  .   n    (  λ  x  .   (  λ  a  .  λ  b  .  b  )   )    (  λ  a  .  λ  b  .  a  )   )    d    (   (  λ  f  .  λ  x  .  x  )    f   x  )    (   f    (   c    d    m    f   x  )   )   )    (   (  λ  m  .  λ  n  .  n   (  λ  n  .  λ  f  .  λ  x  .   n    (  λ  g  .  λ  h  .   h    (   g   f  )   )    (  λ  u  .  x  )    (  λ  u  .  u  )   )   m  )    n   m  )   )   )    (   (  λ  n  .  λ  f  .  λ  x  .   f    (   n    f   x  )   )   n  )      fragments  divide   λ  n  normal-.   fragments  normal-(   fragments  normal-(  λ  f  normal-.   fragments  normal-(  λ  x  normal-.  x  x  normal-)    fragments  normal-(  λ  x  normal-.  f   fragments  normal-(  x  x  normal-)   normal-)   normal-)    fragments  normal-(  λ  c  normal-.  λ  n  normal-.  λ  m  normal-.  λ  f  normal-.  λ  x  normal-.   fragments  normal-(  λ  d  normal-.   fragments  normal-(  λ  n  normal-.  n   fragments  normal-(  λ  x  normal-.   fragments  normal-(  λ  a  normal-.  λ  b  normal-.  b  normal-)   normal-)    fragments  normal-(  λ  a  normal-.  λ  b  normal-.  a  normal-)   normal-)   d   fragments  normal-(   fragments  normal-(  λ  f  normal-.  λ  x  normal-.  x  normal-)   f  x  normal-)    fragments  normal-(  f   fragments  normal-(  c  d  m  f  x  normal-)   normal-)   normal-)    fragments  normal-(   fragments  normal-(  λ  m  normal-.  λ  n  normal-.  n   fragments  normal-(  λ  n  normal-.  λ  f  normal-.  λ  x  normal-.  n   fragments  normal-(  λ  g  normal-.  λ  h  normal-.  h   fragments  normal-(  g  f  normal-)   normal-)    fragments  normal-(  λ  u  normal-.  x  normal-)    fragments  normal-(  λ  u  normal-.  u  normal-)   normal-)   m  normal-)   n  m  normal-)   normal-)   normal-)    fragments  normal-(   fragments  normal-(  λ  n  normal-.  λ  f  normal-.  λ  x  normal-.  f   fragments  normal-(  n  f  x  normal-)   normal-)   n  normal-)     \operatorname{divide}=\lambda n.((\lambda f.(\lambda x.x\ x)\ (\lambda x.f\ (x%
 \ x)))\ (\lambda c.\lambda n.\lambda m.\lambda f.\lambda x.(\lambda d.(\lambda
 n%
 .n\ (\lambda x.(\lambda a.\lambda b.b))\ (\lambda a.\lambda b.a))\ d\ ((%
 \lambda f.\lambda x.x)\ f\ x)\ (f\ (c\ d\ m\ f\ x)))\ ((\lambda m.\lambda n.n(%
 \lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (g\ f))\ (\lambda u.x%
 )\ (\lambda u.u))m)\ n\ m)))\ ((\lambda n.\lambda f.\lambda x.f\ (n\ f\ x))\ n)     Or as text, using \ for   λ   λ   \lambda   ,  divide = (\n.((\f.(\x.x x) (\x.f (x x))) (\c.\n.\m.\f.\x.(\d.(\n.n (\x.(\a.\b.b)) (\a.\b.a)) d ((\f.\x.x) f x) (f (c d m f x))) ((\m.\n.n (\n.\f.\x.n (\g.\h.h (g f)) (\u.x) (\u.u)) m) n m))) ((\n.\f.\x. f (n f x)) n))  For example, 9/3 is represented by  divide (\f.\x.f (f (f (f (f (f (f (f (f x))))))))) (\f.\x.f (f (f x)))  Using a lambda calculus calculator, the above expression reduces to 3, using normal order.  \f.\x.f (f (f (x)))  Signed numbers  One simple approach for extending Church Numerals to signed numbers is to use a Church pair, containing Church numerals representing a positive and a negative value. 5 The integer value is the difference between the two Church numerals.  A natural number is converted to a signed number by,        convert  s   =   λ  x    .   pair   x  0       formulae-sequence     subscript  convert  s     λ  x     pair    x  0      \operatorname{convert}_{s}=\lambda x.\operatorname{pair}\ x\ 0     Negation is performed by swapping the values.        neg  s   =   λ  x    .    pair   (   second  x   )     (   first  x   )       formulae-sequence     subscript  neg  s     λ  x      pair   second  x     first  x      \operatorname{neg}_{s}=\lambda x.\operatorname{pair}\ (\operatorname{second}\ %
 x)\ (\operatorname{first}\ x)     The integer value is more naturally represented if one of the pair is zero. The OneZero function achieves this condition,       OneZero  =   λ  x    .     IsZero   (   first  x   )     x     (     IsZero   (   second  x   )     x     (    OneZero   pair   (   pred   (   first  x   )    )      (   pred   (   second  x   )    )    )    )       formulae-sequence    OneZero    λ  x        IsZero   first  x    x       IsZero   second  x    x     OneZero   pair   pred   first  x       pred   second  x         \operatorname{OneZero}=\lambda x.\operatorname{IsZero}\ (\operatorname{first}%
 \ x)\ x\ (\operatorname{IsZero}\ (\operatorname{second}\ x)\ x\ (\operatorname%
 {OneZero}\ \operatorname{pair}\ (\operatorname{pred}\ (\operatorname{first}\ x%
 ))\ (\operatorname{pred}\ (\operatorname{second}\ x))))     The recursion may be implemented using the Y combinator,       OneZ  =   λ  c    .   λ  x   .     IsZero   (   first  x   )     x     (     IsZero   (   second  x   )     x     (    c     pair   (   pred   (   first  x   )    )     (   pred   (   second  x   )    )     )    )       formulae-sequence    OneZ    λ  c      λ  x       IsZero   first  x    x       IsZero   second  x    x     c    pair   pred   first  x      pred   second  x          \operatorname{OneZ}=\lambda c.\lambda x.\operatorname{IsZero}\ (\operatorname{%
 first}\ x)\ x\ (\operatorname{IsZero}\ (\operatorname{second}\ x)\ x\ (c\ %
 \operatorname{pair}\ (\operatorname{pred}\ (\operatorname{first}\ x))\ (%
 \operatorname{pred}\ (\operatorname{second}\ x))))         OneZero  =   Y  OneZ       OneZero    Y  OneZ     \operatorname{OneZero}=Y\operatorname{OneZ}     Plus and minus  Addition is defined mathematically on the pair by,       x  +  y   =    [   x  p   ,   x  n   ]   +   [   y  p   ,   y  n   ]    =      x  p   -   x  n    +   y  p    -   y  n    =    (    x  p   +   y  p    )   -   (    x  n   +   y  n    )    =   [    x  p   +   y  p    ,    x  n   +   y  n    ]           x  y       subscript  x  p    subscript  x  n      subscript  y  p    subscript  y  n                 subscript  x  p    subscript  x  n     subscript  y  p     subscript  y  n              subscript  x  p    subscript  y  p       subscript  x  n    subscript  y  n              subscript  x  p    subscript  y  p       subscript  x  n    subscript  y  n        x+y=[x_{p},x_{n}]+[y_{p},y_{n}]=x_{p}-x_{n}+y_{p}-y_{n}=(x_{p}+y_{p})-(x_{n}+y%
 _{n})=[x_{p}+y_{p},x_{n}+y_{n}]     The last expression is translated into lambda calculus as,        plus  s   =   λ  x    .   λ  y   .   OneZero   (    pair   (    plus   (   first  x   )     (   first  y   )    )     (    plus   (   second  x   )     (   second  y   )    )    )       formulae-sequence     subscript  plus  s     λ  x      λ  y    OneZero    pair    plus   first  x     first  y       plus   second  x     second  y        \operatorname{plus}_{s}=\lambda x.\lambda y.\operatorname{OneZero}\ (%
 \operatorname{pair}\ (\operatorname{plus}\ (\operatorname{first}\ x)\ (%
 \operatorname{first}\ y))\ (\operatorname{plus}\ (\operatorname{second}\ x)\ (%
 \operatorname{second}\ y)))     Similarly subtraction is defined,       x  -  y   =    [   x  p   ,   x  n   ]   -   [   y  p   ,   y  n   ]    =     x  p   -   x  n   -   y  p    +   y  n    =    (    x  p   +   y  n    )   -   (    x  n   +   y  p    )    =   [    x  p   +   y  n    ,    x  n   +   y  p    ]           x  y       subscript  x  p    subscript  x  n      subscript  y  p    subscript  y  n               subscript  x  p    subscript  x  n    subscript  y  p     subscript  y  n              subscript  x  p    subscript  y  n       subscript  x  n    subscript  y  p              subscript  x  p    subscript  y  n       subscript  x  n    subscript  y  p        x-y=[x_{p},x_{n}]-[y_{p},y_{n}]=x_{p}-x_{n}-y_{p}+y_{n}=(x_{p}+y_{n})-(x_{n}+y%
 _{p})=[x_{p}+y_{n},x_{n}+y_{p}]     giving,        minus  s   =   λ  x    .   λ  y   .   OneZero   (    pair   (    plus   (   first  x   )     (   second  y   )    )     (    plus   (   second  x   )     (   first  y   )    )    )       formulae-sequence     subscript  minus  s     λ  x      λ  y    OneZero    pair    plus   first  x     second  y       plus   second  x     first  y        \operatorname{minus}_{s}=\lambda x.\lambda y.\operatorname{OneZero}\ (%
 \operatorname{pair}\ (\operatorname{plus}\ (\operatorname{first}\ x)\ (%
 \operatorname{second}\ y))\ (\operatorname{plus}\ (\operatorname{second}\ x)\ %
 (\operatorname{first}\ y)))     Multiply and divide  Multiplication may be defined by,       x  *  y   =    [   x  p   ,   x  n   ]   *   [   y  p   ,   y  n   ]    =    (    x  p   -   x  n    )   *   (    y  p   -   y  n    )    =    (     x  p   *   y  p    +    x  n   *   y  n     )   -   (     x  p   *   y  n    +    x  n   *   y  p     )    =   [     x  p   *   y  p    +    x  n   *   y  n     ,     x  p   *   y  n    +    x  n   *   y  p     ]           x  y       subscript  x  p    subscript  x  n      subscript  y  p    subscript  y  n               subscript  x  p    subscript  x  n       subscript  y  p    subscript  y  n                 subscript  x  p    subscript  y  p       subscript  x  n    subscript  y  n          subscript  x  p    subscript  y  n       subscript  x  n    subscript  y  p                 subscript  x  p    subscript  y  p       subscript  x  n    subscript  y  n          subscript  x  p    subscript  y  n       subscript  x  n    subscript  y  p         x*y=[x_{p},x_{n}]*[y_{p},y_{n}]=(x_{p}-x_{n})*(y_{p}-y_{n})=(x_{p}*y_{p}+x_{n}%
 *y_{n})-(x_{p}*y_{n}+x_{n}*y_{p})=[x_{p}*y_{p}+x_{n}*y_{n},x_{p}*y_{n}+x_{n}*y%
 _{p}]   The last expression is translated into lambda calculus as,        mult  s   =   λ  x    .   λ  y   .    pair   (    plus   (    mult   (   first  x   )     (   first  y   )    )     (    mult   (   second  x   )     (   second  y   )    )    )     (    plus   (    mult   (   first  x   )     (   second  y   )    )     (    mult   (   second  x   )     (   first  y   )    )    )       formulae-sequence     subscript  mult  s     λ  x      λ  y     pair    plus    mult   first  x     first  y       mult   second  x     second  y        plus    mult   first  x     second  y       mult   second  x     first  y        \operatorname{mult}_{s}=\lambda x.\lambda y.\operatorname{pair}\ (%
 \operatorname{plus}\ (\operatorname{mult}\ (\operatorname{first}\ x)\ (%
 \operatorname{first}\ y))\ (\operatorname{mult}\ (\operatorname{second}\ x)\ (%
 \operatorname{second}\ y)))\ (\operatorname{plus}\ (\operatorname{mult}\ (%
 \operatorname{first}\ x)\ (\operatorname{second}\ y))\ (\operatorname{mult}\ (%
 \operatorname{second}\ x)\ (\operatorname{first}\ y)))     A similar definition is given here for division, except in this definition, one value in each pair must be zero (see OneZero above). The divZ function allows us to ignore the value that has a zero component.       divZ  =   λ  x    .   λ  y   .    IsZero   y   0      (   divide    x   y    )       formulae-sequence    divZ    λ  x      λ  y      IsZero    y  0     divide    x  y       \operatorname{divZ}=\lambda x.\lambda y.\operatorname{IsZero}\ y\ 0\ (%
 \operatorname{divide}\ x\ y)     divZ is then used in the following formula, which is the same as for multiplication, but with mult replaced by divZ .        divide  s   =   λ  x    .   λ  y   .    pair   (    plus   (    divZ   (   first  x   )     (   first  y   )    )     (    divZ   (   second  x   )     (   second  y   )    )    )     (    plus   (    divZ   (   first  x   )     (   second  y   )    )     (    divZ   (   second  x   )     (   first  y   )    )    )       formulae-sequence     subscript  divide  s     λ  x      λ  y     pair    plus    divZ   first  x     first  y       divZ   second  x     second  y        plus    divZ   first  x     second  y       divZ   second  x     first  y        \operatorname{divide}_{s}=\lambda x.\lambda y.\operatorname{pair}\ (%
 \operatorname{plus}\ (\operatorname{divZ}\ (\operatorname{first}\ x)\ (%
 \operatorname{first}\ y))\ (\operatorname{divZ}\ (\operatorname{second}\ x)\ (%
 \operatorname{second}\ y)))\ (\operatorname{plus}\ (\operatorname{divZ}\ (%
 \operatorname{first}\ x)\ (\operatorname{second}\ y))\ (\operatorname{divZ}\ (%
 \operatorname{second}\ x)\ (\operatorname{first}\ y)))     Rational and real numbers  Rational and real numbers may also be encoded in lambda calculus. Rational numbers may be encoded as a pair of signed numbers. Real numbers may be encoded by a limiting process that guarantees that the difference from the real value differs by a number which may be made as small as we need 6 . 7 The references given describe software that could, in theory, be translated into lambda calculus. Once real numbers are defined, complex numbers are naturally encoded as a pair of real numbers.  The data types and functions described above demonstrate that any data type or calculation may be encoded in lambda calculus. This is the Church-Turing thesis .  See also   Lambda calculus  System F for Church numerals in a typed calculus  Mogensen–Scott encoding  Von Neumann definition of ordinals — another way to encode natural numbers: as sets   References   Directly Reﬂective Meta-Programming  Church numerals and booleans explained by Robert Cartwright at Rice University  Theoretical Foundations For Practical 'Totally Functional Programming' (Chapters 2 and 5) All about Church and other similar encodings, including how to derive them and operations on them, from first principles  Some interactive examples of Church numerals     "  Category:Lambda calculus     This formula is the definition of a Church numeral n with f -> m, x -> f. ↩  ↩  John Tromp, Binary Lambda Calculus and Combinatory Logic, in Randomness And Complexity, from Leibniz To Chaitin , ed. Cristian S. Calude, World Scientific Publishing Company, October 2008. (pdf version) ↩  ↩  ↩  ↩  ↩    