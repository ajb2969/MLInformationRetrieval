<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1731">Transitive closure</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Transitive closure</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>transitive closure</strong> of a <a href="binary_relation" title="wikilink">binary relation</a> <em>R</em> on a <a href="Set_(mathematics)" title="wikilink">set</a> <em>X</em> is the <a href="transitive_relation" title="wikilink">transitive relation</a> <em>R</em><sup>+</sup> on <a href="Set_(mathematics)" title="wikilink">set</a> <em>X</em> such that <em>R</em><sup>+</sup> contains <em>R</em> and <em>R</em><sup>+</sup> is minimal (Lidl and Pilz 1998:337). If the binary relation itself is <a href="transitive_relation" title="wikilink">transitive</a>, then the transitive closure is that same binary relation; otherwise, the transitive closure is a different relation. For example, if <em>X</em> is a set of airports and <em>x R y</em> means "there is a direct flight from airport <em>x</em> to airport <em>y</em>", then the transitive closure of <em>R</em> on <em>X</em> is the relation <em>R</em><sup>+</sup>: "it is possible to fly from <em>x</em> to <em>y</em> in one or more flights."</p>
<h2 id="transitive-relations-and-examples">Transitive relations and examples</h2>

<p>A relation <em>R</em> on a set <em>X</em> is transitive if, for all <em>x</em>, <em>y</em>, <em>z</em> in <em>X</em>, whenever  and  then . Examples of transitive relations include the equality relation on any set, the "less than or equal" relation on any linearly ordered set, and the relation "<em>x</em> was born before <em>y</em>" on the set of all people. Symbolically, this can be denoted as: if  and  then .</p>

<p>One example of a non-transitive relation is "city <em>x</em> can be reached via a direct flight from city <em>y</em>" on the set of all cities. Simply because there is a direct flight from one city to a second city, and a direct flight from the second city to the third, does not imply there is a direct flight from the first city to the third. The transitive closure of this relation is a different relation, namely "there is a sequence of direct flights that begins at city <em>x</em> and ends at city <em>y</em>". Every relation can be extended in a similar way to a transitive relation.</p>

<p>An example of a non-transitive relation with a less meaningful transitive closure is "<em>x</em> is the <a href="day_of_the_week" title="wikilink">day of the week</a> after <em>y</em>". The transitive closure of this relation is "some day <em>x</em> comes after a day <em>y</em> on the calendar", which is trivially true for all days of the week <em>x</em> and <em>y</em> (and thus equivalent to the <a href="Cartesian_product" title="wikilink">Cartesian square</a>, which is "<em>x</em> and <em>y</em> are both days of the week").</p>
<h2 id="existence-and-description">Existence and description</h2>

<p>For any relation <em>R</em>, the transitive closure of <em>R</em> always exists. To see this, note that the <a href="intersection_(set_theory)" title="wikilink">intersection</a> of any <a href="indexed_family" title="wikilink">family</a> of transitive relations is again transitive. Furthermore, <a href="there_exists" title="wikilink">there exists</a> at least one transitive relation containing <em>R</em>, namely the trivial one: <em>X</em> × <em>X</em>. The transitive closure of <em>R</em> is then given by the intersection of all transitive relations containing <em>R</em>.</p>

<p>For finite sets, we can construct the transitive closure step by step, starting from <em>R</em> and adding transitive edges. This gives the intuition for a general construction. For any set <em>X</em>, we can prove that transitive closure is given by the following expression</p>

<p>

<math display="block" id="Transitive_closure:0">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>R</mi>
     <mo>+</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋃</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>1</mn>
        <mo>,</mo>
        <mn>2</mn>
        <mo>,</mo>
        <mn>3</mn>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
     </munder>
     <msup>
      <mi>R</mi>
      <mi>i</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <plus></plus>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <in></in>
       <ci>i</ci>
       <set>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
        <cn type="integer">3</cn>
        <ci>normal-…</ci>
       </set>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{+}=\bigcup_{i\in\{1,2,3,\ldots\}}R^{i}.
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Transitive_closure:1">
 <semantics>
  <msup>
   <mi>R</mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{i}
  </annotation>
 </semantics>
</math>

 is the <em>i</em>-th power of <em>R</em>, defined inductively by</p>

<p>

<math display="block" id="Transitive_closure:2">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mn>1</mn>
   </msup>
   <mo>=</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{1}=R\,\!
  </annotation>
 </semantics>
</math>

 and, for 

<math display="inline" id="Transitive_closure:3">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>i</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i>0
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Transitive_closure:4">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mo>∘</mo>
    <msup>
     <mi>R</mi>
     <mi>i</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <compose></compose>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{i+1}=R\circ R^{i}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Transitive_closure:5">
 <semantics>
  <mo>∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ
  </annotation>
 </semantics>
</math>

 denotes <a href="composition_of_relations" title="wikilink">composition of relations</a>.</p>

<p>To show that the above definition of <em>R</em><sup>+</sup> is the least transitive relation containing <em>R</em>, we show that it contains <em>R</em>, that it is transitive, and that it is the smallest set with both of those characteristics.</p>
<ul>
<li>

<math display="inline" id="Transitive_closure:6">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>⊆</mo>
   <msup>
    <mi>R</mi>
    <mo>+</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>R</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\subseteq R^{+}
  </annotation>
 </semantics>
</math>



<math display="block" id="Transitive_closure:7">
 <semantics>
  <msup>
   <mi>R</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R^{+}
  </annotation>
 </semantics>
</math>

 contains all of the 

<math display="inline" id="Transitive_closure:8">
 <semantics>
  <msup>
   <mi>R</mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R^{i}
  </annotation>
 </semantics>
</math>

, so in particular 

<math display="inline" id="Transitive_closure:9">
 <semantics>
  <msup>
   <mi>R</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R^{+}
  </annotation>
 </semantics>
</math>

 contains 

<math display="inline" id="Transitive_closure:10">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Transitive_closure:11">
 <semantics>
  <msup>
   <mi>R</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R^{+}
  </annotation>
 </semantics>
</math>

 is transitive: every element of 

<math display="inline" id="Transitive_closure:12">
 <semantics>
  <msup>
   <mi>R</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R^{+}
  </annotation>
 </semantics>
</math>

 is in one of the 

<math display="inline" id="Transitive_closure:13">
 <semantics>
  <msup>
   <mi>R</mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R^{i}
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="Transitive_closure:14">
 <semantics>
  <msup>
   <mi>R</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R^{+}
  </annotation>
 </semantics>
</math>

 must be transitive by the following reasoning: if 

<math display="inline" id="Transitive_closure:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>s</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mi>j</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s_{1},s_{2})\in R^{j}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Transitive_closure:16">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>s</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">3</cn>
     </apply>
    </interval>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s_{2},s_{3})\in R^{k}
  </annotation>
 </semantics>
</math>

, then from composition's associativity, 

<math display="inline" id="Transitive_closure:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>s</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>3</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mi>k</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">3</cn>
     </apply>
    </interval>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s_{1},s_{3})\in R^{j+k}
  </annotation>
 </semantics>
</math>

 (and thus in 

<math display="inline" id="Transitive_closure:18">
 <semantics>
  <msup>
   <mi>R</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R^{+}
  </annotation>
 </semantics>
</math>

) because of the definition of 

<math display="inline" id="Transitive_closure:19">
 <semantics>
  <msup>
   <mi>R</mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R^{i}
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Transitive_closure:20">
 <semantics>
  <msup>
   <mi>R</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R^{+}
  </annotation>
 </semantics>
</math>

 is minimal: Let 

<math display="inline" id="Transitive_closure:21">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle G
  </annotation>
 </semantics>
</math>

 be any transitive relation containing 

<math display="inline" id="Transitive_closure:22">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R
  </annotation>
 </semantics>
</math>

, we want to show that 

<math display="inline" id="Transitive_closure:23">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mo>+</mo>
   </msup>
   <mo>⊆</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <plus></plus>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{+}\subseteq G
  </annotation>
 </semantics>
</math>

. It is sufficient to show that for every 

<math display="inline" id="Transitive_closure:24">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>i</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i>0
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Transitive_closure:25">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mi>i</mi>
   </msup>
   <mo>⊆</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>i</ci>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{i}\subseteq G
  </annotation>
 </semantics>
</math>

. Well, since 

<math display="inline" id="Transitive_closure:26">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle G
  </annotation>
 </semantics>
</math>

 contains 

<math display="inline" id="Transitive_closure:27">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Transitive_closure:28">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mn>1</mn>
   </msup>
   <mo>⊆</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{1}\subseteq G
  </annotation>
 </semantics>
</math>

. And since 

<math display="inline" id="Transitive_closure:29">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle G
  </annotation>
 </semantics>
</math>

 is transitive, whenever 

<math display="inline" id="Transitive_closure:30">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mi>i</mi>
   </msup>
   <mo>⊆</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>i</ci>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{i}\subseteq G
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Transitive_closure:31">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>⊆</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{i+1}\subseteq G
  </annotation>
 </semantics>
</math>

 according to the construction of 

<math display="inline" id="Transitive_closure:32">
 <semantics>
  <msup>
   <mi>R</mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{i}\,\!
  </annotation>
 </semantics>
</math>

 and what it means to be transitive. Therefore, by induction, 

<math display="inline" id="Transitive_closure:33">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle G
  </annotation>
 </semantics>
</math>

 contains every 

<math display="inline" id="Transitive_closure:34">
 <semantics>
  <msup>
   <mi>R</mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{i}\,\!
  </annotation>
 </semantics>
</math>

, and thus also 

<math display="inline" id="Transitive_closure:35">
 <semantics>
  <msup>
   <mi>R</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle R^{+}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="properties">Properties</h2>

<p>The <a href="Intersection_(set_theory)" title="wikilink">intersection</a> of two transitive relations is transitive.</p>

<p>The <a href="union_(set_theory)" title="wikilink">union</a> of two transitive relations need not be transitive. To preserve transitivity, one must take the transitive closure. This occurs, for example, when taking the union of two <a href="equivalence_relation" title="wikilink">equivalence relations</a> or two <a href="preorder" title="wikilink">preorders</a>. To obtain a new equivalence relation or preorder one must take the transitive closure (reflexivity and symmetry—in the case of equivalence relations—are automatic).</p>
<h2 id="in-graph-theory">In graph theory</h2>

<p> In <a href="computer_science" title="wikilink">computer science</a>, the concept of transitive closure can be thought of as constructing a data structure that makes it possible to answer <a class="uri" href="reachability" title="wikilink">reachability</a> questions. That is, can one get from node <em>a</em> to node <em>d</em> in one or more hops? A binary relation tells you only that node a is connected to node <em>b</em>, and that node <em>b</em> is connected to node <em>c</em>, etc. After the transitive closure is constructed, as depicted in the following figure, in an O(1) operation one may determine that node <em>d</em> is reachable from node <em>a</em>. The data structure is typically stored as a matrix, so if matrix[1][4] = 1, then it is the case that node 1 can reach node 4 through one or more hops.</p>

<p>The transitive closure of a <a href="directed_acyclic_graph" title="wikilink">directed acyclic graph</a> (DAG) is the reachability relation of the DAG and a <a href="strict_partial_order" title="wikilink">strict partial order</a>.</p>
<h2 id="in-logic-and-computational-complexity">In logic and computational complexity</h2>

<p>The transitive closure of a binary relation cannot, in general, be expressed in <a href="first-order_logic" title="wikilink">first-order logic</a> (FO). This means that one cannot write a formula using predicate symbols <em>R</em> and <em>T</em> that will be satisfied in any model if and only if <em>T</em> is the transitive closure of <em>R</em>. In <a href="finite_model_theory" title="wikilink">finite model theory</a>, first-order logic (FO) extended with a transitive closure operator is usually called <strong>transitive closure logic</strong>, and abbreviated FO(TC) or just TC. TC is a sub-type of <a href="fixpoint_logic" title="wikilink">fixpoint logics</a>. The fact that FO(TC) is strictly more expressive than FO was discovered by <a href="Ronald_Fagin" title="wikilink">Ronald Fagin</a> in 1974; the result was then rediscovered by <a href="Alfred_Aho" title="wikilink">Alfred Aho</a> and <a href="Jeffrey_Ullman" title="wikilink">Jeffrey Ullman</a> in 1979, who proposed to use fixpoint logic as a <a href="database_query_language" title="wikilink">database query language</a> (Libkin 2004:vii). With more recent concepts of finite model theory, proof that FO(TC) is strictly more expressive than FO follows immediately from the fact that FO(TC) is not <a class="uri" href="Gaifman-local" title="wikilink">Gaifman-local</a> (Libkin 2004:49).</p>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, the <a href="complexity_class" title="wikilink">complexity class</a> <a href="NL_(complexity)" title="wikilink">NL</a> corresponds precisely to the set of logical sentences expressible in TC. This is because the transitive closure property has a close relationship with the <a class="uri" href="NL-complete" title="wikilink">NL-complete</a> problem <a class="uri" href="STCON" title="wikilink">STCON</a> for finding <a href="directed_path" title="wikilink">directed paths</a> in a graph. Similarly, the class <a href="L_(complexity)" title="wikilink">L</a> is first-order logic with the commutative, transitive closure. When transitive closure is added to <a href="second-order_logic" title="wikilink">second-order logic</a> instead, we obtain <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>.</p>
<h2 id="in-database-query-languages">In database query languages</h2>

<p>Since the 1980s <a href="Oracle_Database" title="wikilink">Oracle Database</a> has implemented a proprietary <a class="uri" href="SQL" title="wikilink">SQL</a> extension CONNECT BY... START WITH that allows the computation of a transitive closure as part of a declarative query. The <a href="SQL_3" title="wikilink">SQL 3</a> (1999) standard added a more general WITH RECURSIVE construct also allowing transitive closures to be computed inside the query processor; as of 2011 the latter is implemented in <a href="IBM_DB2" title="wikilink">IBM DB2</a>, <a href="Microsoft_SQL_Server" title="wikilink">Microsoft SQL Server</a>, and <a class="uri" href="PostgreSQL" title="wikilink">PostgreSQL</a>, although not in <a class="uri" href="MySQL" title="wikilink">MySQL</a> (Benedikt and Senellart 2011:189).</p>

<p><a class="uri" href="Datalog" title="wikilink">Datalog</a> also implements transitive closure computations (Silberschatz et al. 2010:C.3.6).</p>
<h2 id="algorithms">Algorithms</h2>

<p>Efficient algorithms for computing the transitive closure of a graph can be found in Nuutila (1995). The fastest worst-case methods, which are not practical, reduce the problem to <a href="matrix_multiplication" title="wikilink">matrix multiplication</a>. The problem can also be solved by the <a href="Floyd–Warshall_algorithm" title="wikilink">Floyd–Warshall algorithm</a>, or by repeated <a href="breadth-first_search" title="wikilink">breadth-first search</a> or <a href="depth-first_search" title="wikilink">depth-first search</a> starting from each node of the graph.</p>

<p>More recent research has explored efficient ways of computing transitive closure on distributed systems based on the <a class="uri" href="MapReduce" title="wikilink">MapReduce</a> paradigm (Afrati et al. 2011).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Deductive_closure" title="wikilink">Deductive closure</a></li>
<li><a href="Transitive_reduction" title="wikilink">Transitive reduction</a> (a smallest relation having the transitive closure of <em>R</em> as its transitive closure)</li>
<li><a href="Symmetric_closure" title="wikilink">Symmetric closure</a></li>
<li><a href="Reflexive_closure" title="wikilink">Reflexive closure</a></li>
<li><a href="Ancestral_relation" title="wikilink">Ancestral relation</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Lidl, R. and Pilz, G., 1998, <em>Applied abstract algebra</em>, 2nd edition, Undergraduate Texts in Mathematics, Springer, ISBN 0-387-98290-6</li>
<li>Keller, U., 2004, <em><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.127.8266">Some Remarks on the Definability of Transitive Closure in First-order Logic and Datalog</a></em> (unpublished manuscript)</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Nuutila, E., <a href="http://www.cs.hut.fi/~enu/thesis.html">Efficient Transitive Closure Computation in Large Digraphs.</a> Acta Polytechnica Scandinavica, Mathematics and Computing in Engineering Series No. 74, Helsinki 1995, 124 pages. Published by the Finnish Academy of Technology. ISBN 951-666-451-2, ISSN 1237-2404, UDC 681.3.</li>
<li>

<p><a href="http://codex.cs.yale.edu/avi/db-book/db6/appendices-dir/c.pdf">Appendix C</a> (online only)</p></li>
<li>Foto N. Afrati, Vinayak Borkar, Michael Carey, Neoklis Polyzotis, Jeffrey D. Ullman, <a href="http://www.edbt.org/Proceedings/2011-Uppsala/papers/edbt/a1-afrati.pdf">Map-Reduce Extensions and Recursive Queries</a>, EDBT 2011, March 22–24, 2011, Uppsala, Sweden, ISBN 978-1-4503-0528-0</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>"<a href="http://www.cs.sunysb.edu/~algorith/files/transitive-closure.shtml">Transitive closure and reduction</a>", The Stony Brook Algorithm Repository, Steven Skiena .</li>
<li>"<a href="http://www.cs.up.ac.za/cs/vpieterse/AptiAlgo/AptiAlgoritmi.html">Apti Algoritmi</a>", An example and some C++ implementations of algorithms that calculate the transitive closure of a given binary relation, Vreda Pieterse.</li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_relations" title="wikilink">Category:Mathematical relations</a> <a href="Category:Closure_operators" title="wikilink">Category:Closure operators</a> <a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a></p>
</body>
</html>
