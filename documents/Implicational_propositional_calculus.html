<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="584">Implicational propositional calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Implicational propositional calculus</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, the <strong>implicational propositional calculus</strong> is a version of <a href="classical_logic" title="wikilink">classical</a> <a href="propositional_calculus" title="wikilink">propositional calculus</a> which uses only one <a href="logical_connective" title="wikilink">connective</a>, called <a href="material_conditional" title="wikilink">implication or conditional</a>. In <a href="formula" title="wikilink">formulas</a>, this <a href="binary_operation" title="wikilink">binary operation</a> is indicated by "implies", "if ..., then ...", "→", "

<math display="inline" id="Implicational_propositional_calculus:0">
 <semantics>
  <mo rspace="0.8pt">→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow\!
  </annotation>
 </semantics>
</math>

", etc..</p>
<h2 id="virtual-completeness-as-an-operator">Virtual completeness as an operator</h2>

<p>Implication alone is not <a href="Functional_completeness" title="wikilink">functionally complete</a> as a <a href="logical_operator" title="wikilink">logical operator</a> because one cannot form all other two-valued <a href="truth_function" title="wikilink">truth functions</a> from it. However, if one has a <a href="propositional_formula" title="wikilink">propositional formula</a> which is known to be <a href="False_(logic)" title="wikilink">false</a> and uses that as if it were a nullary connective for falsity, then one can define all other truth functions. So implication is virtually complete as an operator. If <em>P</em>,<em>Q</em>, and <em>F</em> are propositions and <em>F</em> is known to be false, then:</p>
<ul>
<li>¬<em>P</em> is <a href="logical_equivalence" title="wikilink">equivalent</a> to <em>P</em> → <em>F</em></li>
<li><em>P</em> ∧ <em>Q</em> is equivalent to (<em>P</em> → (<em>Q</em> → <em>F</em>)) → <em>F</em></li>
<li><em>P</em> ∨ <em>Q</em> is equivalent to (<em>P</em> → <em>Q</em>) → <em>Q</em></li>
<li><em>P</em> ↔ <em>Q</em> is equivalent to ((<em>P</em> → <em>Q</em>) → ((<em>Q</em> → <em>P</em>) → <em>F</em>)) → <em>F</em></li>
</ul>

<p>More generally, since the above operators are known to be functionally complete, it follows that any truth function can be expressed in terms of "→" and "<em>F</em>", if we have a proposition <em>F</em> which is known to be false.</p>

<p>It is worth noting that <em>F</em> is not definable from → and arbitrary sentence variables: any formula constructed from → and propositional variables must receive the value true when all of its variables are evaluated to true. It follows as a corollary that {→} is not functionally complete. It cannot, for example, be used to define the two-place truth function that always returns <em>false</em>.</p>
<h2 id="axiom-system">Axiom system</h2>
<ul>
<li><a href="Axiom_schema" title="wikilink">Axiom schema</a> 1 is <em>P</em> → (<em>Q</em> → <em>P</em>).</li>
<li>Axiom schema 2 is (<em>P</em> → (<em>Q</em> → <em>R</em>)) → ((<em>P</em> → <em>Q</em>) → (<em>P</em> → <em>R</em>)).</li>
<li>Axiom schema 3 (<a href="Peirce's_law" title="wikilink">Peirce's law</a>) is ((<em>P</em> → <em>Q</em>) → <em>P</em>) → <em>P</em>.</li>
<li>The one non-nullary <a href="rule_of_inference" title="wikilink">rule of inference</a> (<a href="modus_ponens" title="wikilink">modus ponens</a>) is: from <em>P</em> and <em>P</em> → <em>Q</em> infer <em>Q</em>.</li>
</ul>

<p>Where in each <a href="case_analysis" title="wikilink">case</a>, <em>P</em>, <em>Q</em>, and <em>R</em> may be replaced by any formulas which contain only "→" as a connective. If Γ is a set of formulas and <em>A</em> a formula, then 

<math display="inline" id="Implicational_propositional_calculus:1">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash A
  </annotation>
 </semantics>
</math>

 means that <em>A</em> is derivable using the axioms and rules above and formulas from Γ as additional hypotheses.</p>

<p>Łukasiewicz (1948) found an axiom system for the implicational calculus, which replaces the schemas 1–3 above with a single schema</p>
<ul>
<li>((<em>P</em> → <em>Q</em>) → <em>R</em>) → ((<em>R</em> → <em>P</em>) → (<em>S</em> → <em>P</em>)).</li>
</ul>

<p>He also argued that there is no shorter axiom system.</p>
<h2 id="basic-properties-of-derivation">Basic properties of derivation</h2>

<p>Since all axioms and rules of the calculus are schemata, derivation is closed under <a href="substitution_(logic)" title="wikilink">substitution</a>:</p>
<dl>
<dd>If 

<math display="inline" id="Implicational_propositional_calculus:2">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mi>A</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash A,
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Implicational_propositional_calculus:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Γ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊢</mo>
    <mrow>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>normal-Γ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\Gamma)\vdash\sigma(A),
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>where σ is any substitution (of formulas using only implication).</p>

<p>The implicational propositional calculus also satisfies the <a href="deduction_theorem" title="wikilink">deduction theorem</a>:</p>
<dl>
<dd>If 

<math display="inline" id="Implicational_propositional_calculus:4">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>,</mo>
    <mi>A</mi>
   </mrow>
   <mo>⊢</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <ci>normal-Γ</ci>
     <ci>A</ci>
    </list>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma,A\vdash B
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Implicational_propositional_calculus:5">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mi>A</mi>
     <mo>→</mo>
     <mi>B</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash A\to B.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>As explained in the <a href="deduction_theorem" title="wikilink">deduction theorem</a> article, this holds for any axiomatic extension of the system containing axiom schemas 1 and 2 above and modus ponens.</p>
<h2 id="completeness">Completeness</h2>

<p>The implicational propositional calculus is <a href="completeness_(logic)" title="wikilink">semantically complete</a> with respect to the usual two-valued semantics of classical propositional logic. That is, if Γ is a set of implicational formulas, and <em>A</em> is an implicational formula <a href="entailment" title="wikilink">entailed</a> by Γ, then 

<math display="inline" id="Implicational_propositional_calculus:6">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash A
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="proof">Proof</h3>

<p>A proof of the completeness theorem is outlined below. First, using the <a href="compactness_theorem" title="wikilink">compactness theorem</a> and the deduction theorem, we may reduce the completeness theorem to its special case with empty Γ, i.e., we only need to show that every tautology is derivable in the system.</p>

<p>The proof is similar to completeness of full propositional logic, but it also uses the following idea to overcome the functional incompleteness of implication. If <em>A</em> and <em>F</em> are formulas, then  is equivalent to  where <em>A*</em> is the result of replacing in <em>A</em> all, some, or none of the occurrences of <em>F</em> by falsity. Similarly,  is equivalent to  So under some conditions, one can use them as substitutes for saying <em>A*</em> is false or <em>A*</em> is true respectively.</p>

<p>We first observe some basic facts about derivability: <mtpl></mtpl></p>
<dl>
<dd><dl>
<dd>Indeed, we can derive <em>A</em> → (<em>B</em> → <em>C</em>) using Axiom 1, and then derive <em>A</em> → <em>C</em> by modus ponens (twice) from Ax. 2.
</dd>
</dl>
</dd>
</dl>

<p><mtpl></mtpl></p>
<dl>
<dd><dl>
<dd>This follows from (1) by the deduction theorem.
</dd>
</dl>
</dd>
</dl>

<p><mtpl></mtpl></p>
<dl>
<dd><dl>
<dd>If we further assume <em>C</em> → <em>B</em>, we can derive  using (1), then we derive <em>C</em> by modus ponens. This shows 

<math display="inline" id="Implicational_propositional_calculus:7">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>C</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>C</mi>
   <mo>,</mo>
   <mi>C</mi>
   <mo>→</mo>
   <mi>B</mi>
   <mo>⊢</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">B</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="unknown">C</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to C,(A\to B)\to C,C\to B\vdash C
  </annotation>
 </semantics>
</math>

, and the deduction theorem gives 

<math display="inline" id="Implicational_propositional_calculus:8">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>C</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>C</mi>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">C</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to C,(A\to B)\to C\vdash(C\to B)\to C
  </annotation>
 </semantics>
</math>

. We apply Ax. 3 to obtain (3).
</dd>
</dl>
</dd>
</dl>

<p>Let <em>F</em> be an arbitrary fixed formula. For any formula <em>A</em>, we define <mtpl> (<em>A</em> → <em>F</em>)}}</mtpl> and <mtpl> ((<em>A</em> → <em>F</em>) → <em>F</em>).}}</mtpl> Let us consider only formulas in propositional variables <em>p</em><sub>1</sub>, ..., <em>p<sub>n</sub></em>. We claim that for every formula <em>A</em> in these variables and every <a href="Valuation_(logic)" title="wikilink">truth assignment</a> <em>e</em>,  We prove (4) by induction on <em>A</em>. The base case <em>A</em> = <em>p<sub>i</sub></em> is trivial. Let  We distinguish three cases:</p>
<ol>
<li><em>e</em>(<em>C</em>) = 1. Then also <em>e</em>(<em>A</em>) = 1. We have
<dl>
<dd><dl>
<dd>

<math display="inline" id="Implicational_propositional_calculus:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo>→</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>F</mi>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">F</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (C\to F)\to F\vdash((B\to C)\to F)\to F
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>by applying (2) twice to the axiom  Since we have derived  by the induction hypothesis, we can infer 
</dd>
</dl></li>
<li><em>e</em>(<em>B</em>) = 0. Then again <em>e</em>(<em>A</em>) = 1. The deduction theorem applied to (3) gives
<dl>
<dd><dl>
<dd>

<math display="inline" id="Implicational_propositional_calculus:10">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>→</mo>
   <mi>F</mi>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>F</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">B</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">F</csymbol>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\to F\vdash((B\to C)\to F)\to F.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>Since we have derived  by the induction hypothesis, we can infer 
</dd>
</dl></li>
<li><em>e</em>(<em>B</em>) = 1 and <em>e</em>(<em>C</em>) = 0. Then <em>e</em>(<em>A</em>) = 0. We have
<dl>
<dd><dl>
<dd>

<math display="inline" id="Implicational_propositional_calculus:11">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo>→</mo>
       <mi>F</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>→</mo>
      <mi>F</mi>
      <mo>,</mo>
      <mi>C</mi>
      <mo>→</mo>
      <mi>F</mi>
      <mo>,</mo>
      <mi>B</mi>
      <mo>→</mo>
      <mi>C</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>⊢</mo>
      <mrow>
       <mi>B</mi>
       <mo>→</mo>
       <mi>F</mi>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd columnalign="left">
     <mtext>by (1)</mtext>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>⊢</mo>
      <mi>F</mi>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd columnalign="left">
     <mtext>by modus ponens,</mtext>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">F</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">F</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">C</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>B</ci>
       <ci>F</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <mtext>by (1)</mtext>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>F</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <mtext>by modus ponens,</mtext>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle(B\to F)\to F,C\to F,B\to C&\displaystyle\vdash B%
\to F&&\displaystyle\text{by (1)}\\
&\displaystyle\vdash F&&\displaystyle\text{by modus ponens,}\end{aligned}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>thus 

<math display="inline" id="Implicational_propositional_calculus:12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>F</mi>
   <mo>,</mo>
   <mi>C</mi>
   <mo>→</mo>
   <mi>F</mi>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">F</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">F</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B\to F)\to F,C\to F\vdash(B\to C)\to F
  </annotation>
 </semantics>
</math>

 by the deduction theorem. We have derived  and  by the induction hypothesis, hence we can infer  This completes the proof of (4).
</dd>
</dl></li>
</ol>

<p>Now let <em>A</em> be a tautology in variables <em>p</em><sub>1</sub>, ..., <em>p<sub>n</sub></em>. We will prove by reverse induction on <em>k</em> = <em>n</em>,...,0 that for every assignment <em>e</em>,  The base case <em>k</em> = <em>n</em> is a special case of (4). Assume that (5) holds for <em>k</em> + 1, we will show it for <em>k</em>. By applying deduction theorem to the induction hypothesis, we obtain</p>

<p>

<math display="inline" id="Implicational_propositional_calculus:13">
 <semantics>
  <mrow>
   <msubsup>
    <mi>p</mi>
    <mn>1</mn>
    <mrow>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>p</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msubsup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msubsup>
    <mi>p</mi>
    <mi>k</mi>
    <mrow>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>p</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle p_{1}^{e(p_{1})},\dots,p_{k}^{e(p_{k})}
  </annotation>
 </semantics>
</math>


 by first setting <em>e</em>(<em>p</em><sub><em>k</em>+1</sub>) = 0 and second setting <em>e</em>(<em>p</em><sub><em>k</em>+1</sub>) = 1. From this we derive (5) using (3).</p>

<p>For <em>k</em> = 0 we obtain that the formula <em>A</em><sup>1</sup>, i.e.,  is provable without assumptions. Recall that <em>F</em> was an arbitrary formula, thus we can choose <em>F</em> = <em>A</em>, which gives us provability of the formula  Since  is provable by the deduction theorem, we can infer <em>A</em>.</p>

<p>This proof is constructive. That is, given a tautology, one could actually follow the instructions and create a proof of it from the axioms. However, the length of such a proof increases exponentially with the number of propositional variables in the tautology, hence it is not a practical method for any but the very shortest tautologies.</p>
<h2 id="the-bernaystarski-axiom-system">The Bernays–Tarski axiom system</h2>

<p>The Bernays–Tarski axiom system is often used. In particular, Łukasiewicz's paper derives the Bernays–Tarski axioms from Łukasiewicz's sole axiom as a means of showing its completeness.<br/>
It differs from the axiom schemas above by replacing axiom schema 2, (<em>P</em>→(<em>Q</em>→<em>R</em>))→((<em>P</em>→<em>Q</em>)→(<em>P</em>→<em>R</em>)), with</p>
<ul>
<li>Axiom schema 2': (<em>P</em>→<em>Q</em>)→((<em>Q</em>→<em>R</em>)→(<em>P</em>→<em>R</em>))</li>
</ul>

<p>which is called <em><a href="hypothetical_syllogism" title="wikilink">hypothetical syllogism</a></em>. This makes derivation of the deduction meta-theorem a little more difficult, but it can still be done.</p>

<p>We show that from <em>P</em>→(<em>Q</em>→<em>R</em>) and <em>P</em>→<em>Q</em> one can derive <em>P</em>→<em>R</em>. This fact can be used in lieu of axiom schema 2 to get the meta-theorem.</p>
<ol>
<li><em>P</em>→(<em>Q</em>→<em>R</em>) given</li>
<li><em>P</em>→<em>Q</em> given</li>
<li>(<em>P</em>→<em>Q</em>)→((<em>Q</em>→<em>R</em>))→(<em>P</em>→<em>R</em>)) ax 2'</li>
<li>(<em>Q</em>→<em>R</em>)→(<em>P</em>→<em>R</em>) mp 2,3</li>
<li>(<em>P</em>→(<em>Q</em>→<em>R</em>))→(((<em>Q</em>→<em>R</em>)→(<em>P</em>→<em>R</em>))→(<em>P</em>→(<em>P</em>→<em>R</em>))) ax 2'</li>
<li>((<em>Q</em>→<em>R</em>)→(<em>P</em>→<em>R</em>))→(<em>P</em>→(<em>P</em>→<em>R</em>)) mp 1,5</li>
<li><em>P</em>→(<em>P</em>→<em>R</em>) mp 4,6</li>
<li>(<em>P</em>→(<em>P</em>→<em>R</em>))→(((<em>P</em>→<em>R</em>)→<em>R</em>)→(<em>P</em>→<em>R</em>)) ax 2'</li>
<li>((<em>P</em>→<em>R</em>)→<em>R</em>)→(<em>P</em>→<em>R</em>) mp 7,8</li>
<li>(((<em>P</em>→<em>R</em>)→<em>R</em>)→(<em>P</em>→<em>R</em>))→(<em>P</em>→<em>R</em>) ax 3</li>
<li><em>P</em>→<em>R</em> mp 9,10 qed</li>
</ol>
<h2 id="testing-whether-a-formula-of-the-implicational-propositional-calculus-is-a-tautology">Testing whether a formula of the implicational propositional calculus is a tautology</h2>

<p>In this case, a useful technique is to presume that the formula is not a tautology and attempt to find a valuation which makes it false. If one succeeds, then it is indeed not a tautology. If one fails, then it is a tautology.</p>

<p><strong>Example of a non-tautology</strong>:</p>

<p>Suppose [(<em>A</em>→<em>B</em>)→((<em>C</em>→<em>A</em>)→<em>E</em>)]→([<em>F</em>→((<em>C</em>→<em>D</em>)→<em>E</em>)]→[(<em>A</em>→<em>F</em>)→(<em>D</em>→<em>E</em>)]) is false.</p>

<p>Then (<em>A</em>→<em>B</em>)→((<em>C</em>→<em>A</em>)→<em>E</em>) is true; <em>F</em>→((<em>C</em>→<em>D</em>)→<em>E</em>) is true; <em>A</em>→<em>F</em> is true; <em>D</em> is true; and <em>E</em> is false.</p>

<p>Since <em>D</em> is true, <em>C</em>→<em>D</em> is true. So the truth of <em>F</em>→((<em>C</em>→<em>D</em>)→<em>E</em>) is equivalent to the truth of <em>F</em>→<em>E</em>.</p>

<p>Then since <em>E</em> is false and <em>F</em>→<em>E</em> is true, we get that <em>F</em> is false.</p>

<p>Since <em>A</em>→<em>F</em> is true, <em>A</em> is false. Thus <em>A</em>→<em>B</em> is true and (<em>C</em>→<em>A</em>)→<em>E</em> is true.</p>

<p><em>C</em>→<em>A</em> is false, so <em>C</em> is true.</p>

<p>The value of <em>B</em> does not matter, so we can arbitrarily choose it to be true.</p>

<p>Summing up, the valuation which sets <em>B</em>, <em>C</em> and <em>D</em> to be true and <em>A</em>, <em>E</em> and <em>F</em> to be false will make [(<em>A</em>→<em>B</em>)→((<em>C</em>→<em>A</em>)→<em>E</em>)]→([<em>F</em>→((<em>C</em>→<em>D</em>)→<em>E</em>)]→[(<em>A</em>→<em>F</em>)→(<em>D</em>→<em>E</em>)]) false. So it is not a tautology.</p>

<p><strong>Example of a tautology</strong>:</p>

<p>Suppose ((<em>A</em>→<em>B</em>)→<em>C</em>)→((<em>C</em>→<em>A</em>)→(<em>D</em>→<em>A</em>)) is false.</p>

<p>Then (<em>A</em>→<em>B</em>)→<em>C</em> is true; <em>C</em>→<em>A</em> is true; <em>D</em> is true; and <em>A</em> is false.</p>

<p>Since <em>A</em> is false, <em>A</em>→<em>B</em> is true. So <em>C</em> is true. Thus <em>A</em> must be true, contradicting the fact that it is false.</p>

<p>Thus there is no valuation which makes ((<em>A</em>→<em>B</em>)→<em>C</em>)→((<em>C</em>→<em>A</em>)→(<em>D</em>→<em>A</em>)) false. Consequently, it is a tautology.</p>
<h2 id="adding-an-axiom-schema">Adding an axiom schema</h2>

<p>What would happen if another axiom schema were added to those listed above? There are two cases: (1) it is a tautology; or (2) it is not a tautology.</p>

<p>If it is a tautology, then the set of theorems remains the set of tautologies as before. However, in some cases it may be possible to find significantly shorter proofs for theorems. Nevertheless, the minimum length of proofs of theorems will remain unbounded, that is, for any natural number <em>n</em> there will still be theorems which cannot be proved in <em>n</em> or fewer steps.</p>

<p>If the new axiom schema is not a tautology, then every formula becomes a theorem (which makes the concept of a theorem useless in this case). What is more, there is then an upper bound on the minimum length of a proof of every formula, because there is a common method for proving every formula. For example, suppose the new axiom schema were ((<em>B</em>→<em>C</em>)→<em>C</em>)→<em>B</em>. Then ((<em>A</em>→(<em>A</em>→<em>A</em>))→(<em>A</em>→<em>A</em>))→<em>A</em> is an instance (one of the new axioms) and also not a tautology. But [((<em>A</em>→(<em>A</em>→<em>A</em>))→(<em>A</em>→<em>A</em>))→<em>A</em>]→<em>A</em> is a tautology and thus a theorem due to the old axioms (using the completeness result above). Applying modus ponens, we get that <em>A</em> is a theorem of the extended system. Then all one has to do to prove any formula is to replace <em>A</em> by the desired formula throughout the proof of <em>A</em>. This proof will have the same number of steps as the proof of <em>A</em>.</p>
<h2 id="an-alternative-axiomatization">An alternative axiomatization</h2>

<p>The axioms listed above primarily work through the deduction metatheorem to arrive at completeness. Here is another axiom system which aims directly at completeness without going through the deduction metatheorem.</p>

<p>First we have axiom schemas which are designed to efficiently prove the subset of tautologies which contain only one propositional variable.</p>
<ul>
<li>aa 1: ꞈ<em>A</em>→<em>A</em></li>
<li>aa 2: (<em>A</em>→<em>B</em>)→ꞈ(<em>A</em>→(<em>C</em>→<em>B</em>))</li>
<li>aa 3: <em>A</em>→((<em>B</em>→<em>C</em>)→ꞈ((<em>A</em>→<em>B</em>)→<em>C</em>))</li>
<li>aa 4: <em>A</em>→ꞈ(<em>B</em>→<em>A</em>)</li>
</ul>

<p>The proof of each such tautology would begin with two parts (hypothesis and conclusion) which are the same. Then insert additional hypotheses between them. Then insert additional tautological hypotheses (which are true even when the sole variable is false) into the original hypothesis. Then add more hypotheses outside (on the left). This procedure will quickly give every tautology containing only one variable. (The symbol "ꞈ" in each axiom schema indicates where the conclusion used in the completeness proof begins. It is merely a comment, not a part of the formula.)</p>

<p>Consider any formula Φ which may contain <em>A</em>, <em>B</em>, <em>C</em><sub>1</sub>, ..., <em>C</em><sub><em>n</em></sub> '''and ends with <em>A</em> ''' as its final conclusion. Then we take</p>
<ul>
<li>aa 5: Φ<sub>−</sub>→(Φ<sub>+</sub>→ꞈΦ)</li>
</ul>

<p>as an axiom schema where Φ<sub>−</sub> is the result of replacing <em>B</em> by <em>A</em> throughout Φ and Φ<sub>+</sub> is the result of replacing <em>B</em> by (<em>A</em>→<em>A</em>) throughout Φ. This is a schema for axiom schemas since there are two level of substitution: in the first Φ is substituted (with variations); in the second, any of the variables (including both <em>A</em> and <em>B</em>) may be replaced by arbitrary formulas of the implicational propositional calculus. This schema allows one to prove tautologies with more than one variable by considering the case when <em>B</em> is false Φ<sub>−</sub> and the case when <em>B</em> is true Φ<sub>+</sub>.</p>

<p>If the variable which is the final conclusion of a formula takes the value true, then the whole formula takes the value true regardless of the values of the other variables. Consequently if <em>A</em> is true, then Φ, Φ<sub>−</sub>, Φ<sub>+</sub> and Φ<sub>−</sub>→(Φ<sub>+</sub>→Φ) are all true. So without loss of generality, we may assume that <em>A</em> is false. Notice that Φ is a tautology if and only if both Φ<sub>−</sub> and Φ<sub>+</sub> are tautologies. But while Φ has <em>n</em>+2 distinct variables, Φ<sub>−</sub> and Φ<sub>+</sub> both have <em>n</em>+1. So the question of whether a formula is a tautology has been reduced to the question of whether certain formulas with one variable each are all tautologies. Also notice that Φ<sub>−</sub>→(Φ<sub>+</sub>→Φ) is a tautology regardless of whether Φ is, because if Φ is false then either Φ<sub>−</sub> or Φ<sub>+</sub> will be false depending on whether <em>B</em> is false or true.</p>

<p>Examples:</p>

<p>Deriving Peirce's law</p>
<ol>
<li>[((<em>P</em>→<em>P</em>)→<em>P</em>)→<em>P</em>]→([((<em>P</em>→(<em>P</em>→<em>P</em>))→<em>P</em>)→<em>P</em>]→[((<em>P</em>→<em>Q</em>)→<em>P</em>)→<em>P</em>]) aa 5</li>
<li><em>P</em>→<em>P</em> aa 1</li>
<li>(<em>P</em>→<em>P</em>)→((<em>P</em>→<em>P</em>)→(((<em>P</em>→<em>P</em>)→<em>P</em>)→<em>P</em>)) aa 3</li>
<li>(<em>P</em>→<em>P</em>)→(((<em>P</em>→<em>P</em>)→<em>P</em>)→<em>P</em>) mp 2,3</li>
<li>((<em>P</em>→<em>P</em>)→<em>P</em>)→<em>P</em> mp 2,4</li>
<li>[((<em>P</em>→(<em>P</em>→<em>P</em>))→<em>P</em>)→<em>P</em>]→[((<em>P</em>→<em>Q</em>)→<em>P</em>)→<em>P</em>] mp 5,1</li>
<li><em>P</em>→(<em>P</em>→<em>P</em>) aa 4</li>
<li>(<em>P</em>→(<em>P</em>→<em>P</em>))→((<em>P</em>→<em>P</em>)→(((<em>P</em>→(<em>P</em>→<em>P</em>))→<em>P</em>)→<em>P</em>)) aa 3</li>
<li>(<em>P</em>→<em>P</em>)→(((<em>P</em>→(<em>P</em>→<em>P</em>))→<em>P</em>)→<em>P</em>) mp 7,8</li>
<li>((<em>P</em>→(<em>P</em>→<em>P</em>))→<em>P</em>)→<em>P</em> mp 2,9</li>
<li>((<em>P</em>→<em>Q</em>)→<em>P</em>)→<em>P</em> mp 10,6 qed</li>
</ol>

<p>Deriving Łukasiewicz' sole axiom</p>
<ol>
<li>[((<em>P</em>→<em>Q</em>)→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))]→([((<em>P</em>→<em>Q</em>)→(<em>P</em>→<em>P</em>))→(((<em>P</em>→<em>P</em>)→<em>P</em>)→(<em>S</em>→<em>P</em>))]→[((<em>P</em>→<em>Q</em>)→<em>R</em>)→((<em>R</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))]) aa 5</li>
<li>[((<em>P</em>→<em>P</em>)→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))]→([((<em>P</em>→(<em>P</em>→<em>P</em>))→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))]→[((<em>P</em>→<em>Q</em>)→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))]) aa 5</li>
<li><em>P</em>→(<em>S</em>→<em>P</em>) aa 4</li>
<li>(<em>P</em>→(<em>S</em>→<em>P</em>))→(<em>P</em>→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))) aa 2</li>
<li><em>P</em>→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>)) mp 3,4</li>
<li><em>P</em>→<em>P</em> aa 1</li>
<li>(<em>P</em>→<em>P</em>)→((<em>P</em>→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>)))→[((<em>P</em>→<em>P</em>)→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))]) aa 3</li>
<li>(<em>P</em>→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>)))→[((<em>P</em>→<em>P</em>)→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))] mp 6,7</li>
<li>((<em>P</em>→<em>P</em>)→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>)) mp 5,8</li>
<li>[((<em>P</em>→(<em>P</em>→<em>P</em>))→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))]→[((<em>P</em>→<em>Q</em>)→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))] mp 9,2</li>
<li><em>P</em>→(<em>P</em>→<em>P</em>) aa 4</li>
<li>(<em>P</em>→(<em>P</em>→<em>P</em>))→((<em>P</em>→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>)))→[((<em>P</em>→(<em>P</em>→<em>P</em>))→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))]) aa 3</li>
<li>(<em>P</em>→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>)))→[((<em>P</em>→(<em>P</em>→<em>P</em>))→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))] mp 11,12</li>
<li>((<em>P</em>→(<em>P</em>→<em>P</em>))→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>)) mp 5,13</li>
<li>((<em>P</em>→<em>Q</em>)→<em>P</em>)→((<em>P</em>→<em>P</em>)→(<em>S</em>→<em>P</em>)) mp 14,10</li>
<li>[((<em>P</em>→<em>Q</em>)→(<em>P</em>→<em>P</em>))→(((<em>P</em>→<em>P</em>)→<em>P</em>)→(<em>S</em>→<em>P</em>))]→[((<em>P</em>→<em>Q</em>)→<em>R</em>)→((<em>R</em>→<em>P</em>)→(<em>S</em>→<em>P</em>))] mp 15,1</li>
<li>(<em>P</em>→<em>P</em>)→((<em>P</em>→(<em>S</em>→<em>P</em>))→[((<em>P</em>→<em>P</em>)→<em>P</em>)→(<em>S</em>→<em>P</em>)]) aa 3</li>
<li>(<em>P</em>→(<em>S</em>→<em>P</em>))→[((<em>P</em>→<em>P</em>)→<em>P</em>)→(<em>S</em>→<em>P</em>)] mp 6,17</li>
<li>((<em>P</em>→<em>P</em>)→<em>P</em>)→(<em>S</em>→<em>P</em>) mp 3,18</li>
<li>(((<em>P</em>→<em>P</em>)→<em>P</em>)→(<em>S</em>→<em>P</em>))→[((<em>P</em>→<em>Q</em>)→(<em>P</em>→<em>P</em>))→(((<em>P</em>→<em>P</em>)→<em>P</em>)→(<em>S</em>→<em>P</em>))] aa 4</li>
<li>((<em>P</em>→<em>Q</em>)→(<em>P</em>→<em>P</em>))→(((<em>P</em>→<em>P</em>)→<em>P</em>)→(<em>S</em>→<em>P</em>)) mp 19,20</li>
<li>((<em>P</em>→<em>Q</em>)→<em>R</em>)→((<em>R</em>→<em>P</em>)→(<em>S</em>→<em>P</em>)) mp 21,16 qed</li>
</ol>

<p>Using a truth table to verify Łukasiewicz' sole axiom would require consideration of 16=2<sup>4</sup> cases since it contains 4 distinct variables. In this derivation, we were able to restrict consideration to merely 3 cases: <em>R</em> is false and <em>Q</em> is false, <em>R</em> is false and <em>Q</em> is true, and <em>R</em> is true. However because we are working within the formal system of logic (instead of outside it, informally), each case required much more effort.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Deduction_theorem" title="wikilink">Deduction theorem</a></li>
<li><a href="List_of_logic_systems#Implicational_propositional_calculus" title="wikilink">List of logic systems#Implicational propositional calculus</a></li>
<li><a href="Peirce's_law" title="wikilink">Peirce's law</a></li>
<li><a href="Propositional_calculus" title="wikilink">Propositional calculus</a></li>
<li><a href="Tautology_(logic)" title="wikilink">Tautology (logic)</a></li>
<li><a href="Truth_table" title="wikilink">Truth table</a></li>
<li><a href="Valuation_(logic)" title="wikilink">Valuation (logic)</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Mendelson, Elliot (1997) <a href="http://worldcat.org/oclc/259359"><em>Introduction to Mathematical Logic</em>, 4th ed.</a> London: Chapman &amp; Hall.</li>
<li>Łukasiewicz, Jan (1948) <a href="http://www.jstor.org/stable/20488489"><em>The shortest axiom of the implicational calculus of propositions</em></a>, Proc. Royal Irish Academy, vol. 52, sec. A, no. 3, pp. 25–33.</li>
</ul>

<p>"</p>

<p><a href="Category:Systems_of_formal_logic" title="wikilink">Category:Systems of formal logic</a> <a href="Category:Propositional_calculus" title="wikilink">Category:Propositional calculus</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a> <a class="uri" href="Category:Conditionals" title="wikilink">Category:Conditionals</a></p>
</body>
</html>
