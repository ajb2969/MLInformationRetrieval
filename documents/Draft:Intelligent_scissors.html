<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1501">Draft:Intelligent scissors</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Draft:Intelligent scissors</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption><code>Intelligent</code> <code>scissors</code> <code>segmentation</code></figcaption>
</figure>

<p><strong>Intelligent scissors</strong> is an effective tool used for image segmentation and composition, which is raised by Eric Mortensen and William Barrett in 1990s. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is based on <a href="Livewire_Segmentation_Technique" title="wikilink">Livewire Segmentation Technique</a> and made some useful extensions, such like on-the-fly training and boundary cooling. Intelligent Scissors allow objects within digital images to be extracted quickly and accurately using simple gesture motions with a mouse. It applies the <a href="shortest_path_algorithm" title="wikilink">shortest path algorithm</a>, by <a href="Edsger_W._Dijkstra" title="wikilink">Edsger W. Dijkstra</a> for optimal graph search.</p>
<h2 id="shortest-path-algorithm">Shortest Path Algorithm</h2>

<p>In a 2D digital picture, pixels represent nodes and edges are created between each pixel and its 8 neighbors. <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>The cumulative cost of a path is the sum of the local edge (or link) costs on the path. Shortest path algorithm, or optical graph search, is aimed to minimum cumulative cost path from a start pixel to a goal pixel.</p>
<h2 id="local-cost">Local Cost</h2>

<p>A minimum cost path should correspond to an image component boundary. Pixels that exhibit strong edge features have low local costs and vice-versa. The local component costs are created from the various edge features:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Image feature</p></th>
<th style="text-align: left;">
<p>Formulation</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Laplacian Zero-Crossing</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Draft:Intelligent_scissors:0">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>Z</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>Z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{Z}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Gradient magnitude</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Draft:Intelligent_scissors:1">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>G</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{G}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Gradient direction</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Draft:Intelligent_scissors:2">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>D</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{D}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>The local costs are computed as weighted sum of these component functional. Letting l(p,q) represents the local cost on the directed link from pixel p to a neighboring pixel q, the local cost function is</p>

<p>

<math display="inline" id="Draft:Intelligent_scissors:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>Ï‰</mi>
       <mi>z</mi>
      </msub>
      <mo>â‹…</mo>
      <msub>
       <mi>f</mi>
       <mi>Z</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>Ï‰</mi>
       <mi>D</mi>
      </msub>
      <mo>â‹…</mo>
      <msub>
       <mi>f</mi>
       <mi>D</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo>,</mo>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>Ï‰</mi>
       <mi>G</mi>
      </msub>
      <mo>â‹…</mo>
      <msub>
       <mi>f</mi>
       <mi>G</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>l</ci>
     <interval closure="open">
      <ci>p</ci>
      <ci>q</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-â‹…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Ï‰</ci>
        <ci>z</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>Z</ci>
       </apply>
      </apply>
      <ci>q</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-â‹…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Ï‰</ci>
        <ci>D</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>D</ci>
       </apply>
      </apply>
      <interval closure="open">
       <ci>p</ci>
       <ci>q</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-â‹…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Ï‰</ci>
        <ci>G</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>G</ci>
       </apply>
      </apply>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(p,q)=\omega_{z}\cdot f_{Z}(q)+\omega_{D}\cdot f_{D}(p,q)+\omega_{G}\cdot f_{%
G}(q)
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Where each ğœ” is the weight of the corresponding feature function.</p>
<h2 id="live-wire-2-d-dp-graph-search-algorithm-in-pseudocode">Live-Wire 2-D DP Graph Search Algorithm in Pseudocode<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></h2>

<p><code>Â Â Â Â Input:</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â sÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {StartÂ (orÂ seed)Â pixel.}</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â l(</code><strong><code>q,r</code></strong><code>)Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {LocalÂ costÂ functionÂ forÂ linkÂ betweenÂ pixelsÂ qÂ andÂ r.}Â </code><br/>
<code>Â Â Â Â DataÂ Structures:</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â LÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {ListÂ ofÂ activeÂ pixelsÂ sortedÂ byÂ totalÂ costÂ (initiallyÂ empty).}</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â N(</code><strong><code>q</code></strong><code>)Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {NeighborhoodÂ setÂ ofÂ qÂ (containsÂ 8Â neighborsÂ ofÂ pixel).}Â </code><br/>
<code>Â Â Â Â Â Â Â Â Â Â e(</code><strong><code>q</code></strong><code>)Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {BooleanÂ functionÂ indicatingÂ ifÂ qÂ hasÂ beenÂ expanded/processed.}</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â g(</code><strong><code>q</code></strong><code>)Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {TotalÂ costÂ functionÂ fromÂ seedÂ pointÂ toÂ q.}</code><br/>
<code>Â Â Â Â Output:Â </code><br/>
<code>Â Â Â Â Â Â Â Â Â Â pÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {PointersÂ fromÂ eachÂ pixelÂ indicatingÂ theÂ minimumÂ costÂ path.}</code><br/>
<code>Â Â Â Â Algorithm:</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â g(s)Â â†Â 0;Â LÂ â†Â s;Â Â Â Â Â Â Â {InitializeÂ activeÂ listÂ withÂ zeroÂ costÂ seedÂ pixel.}</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â </code><strong><em><code>while</code></em></strong><code>Â Lâ‰ âˆ…Â </code><strong><em><code>do</code> <code>begin</code></em></strong><code>Â Â Â Â Â Â {WhileÂ stillÂ pointsÂ toÂ expand.}</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </code><strong><code>q</code></strong><code>Â â†Â min(L);Â Â Â Â Â Â Â Â Â Â Â Â Â {RemoveÂ minimumÂ costÂ pixelÂ qÂ fromÂ activeÂ list.}</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â e(</code><strong><code>q</code></strong><code>)Â â†TRUE;Â Â Â Â Â Â Â Â Â Â Â Â Â {MarkÂ qÂ asÂ expandedÂ (i.e.,Â processed).}</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </code><strong><em><code>for</code> <code>each</code></em></strong><code>Â râˆˆN(q)Â </code><em><strong><code>such</code> <code>that</code></strong></em><code>Â notÂ e(</code><strong><code>r</code></strong><code>)Â </code><strong><em><code>do</code> <code>begin</code></em></strong><br/>
<code>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â gtmpÂ â†g(</code><strong><code>q</code></strong><code>)+l(</code><strong><code>q,r</code></strong><code>);Â Â Â Â Â Â Â Â Â Â Â {ComputeÂ totalÂ costÂ toÂ neighbor.}</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </code><strong><em><code>if</code></em> <code>r</code></strong><code>âˆˆLÂ </code><em><strong><code>and</code></strong></em><code>Â gtmp<g(< code=""><strong><code>r</code></strong><code>)Â </code><strong><em><code>end</code></em></strong><code>="Implementation"Â </code><strong><em><code>if</code></em></strong><code>=""Â </code><em><code>'</code></em><code>then=""Â </code><strong><em><code>then</code></em></strong><code>=""Â (image=""Â (or=""Â =="<mtpl"Â < code=""><a href="segmentation=&quot;&quot;_active=&quot;&quot;_also=&quot;*&quot;_back=&quot;&quot;_begin'''''=&quot;&quot;_cost=&quot;&quot;_cost,=&quot;&quot;_creation=&quot;See&quot;_from=&quot;&quot;_g('''r''')â†gtmp;=&quot;&quot;_higher=&quot;&quot;_in=&quot;&quot;_intelligence=&quot;&quot;_list,=&quot;&quot;_list.}=&quot;&quot;_lâ†'''r''';=&quot;&quot;_matlab=&quot;http://www.mathworks.com/matlabcentral/fileexchange/41084-livewire--intelligent-scissors--roi-&quot;_neighbor=&quot;&quot;_neighborâ€™s=&quot;&quot;_not=&quot;&quot;_on=&quot;&quot;_p('''r''')â†'''q''';=&quot;&quot;_place=&quot;&quot;_pointer,=&quot;&quot;_processing)" title="wikilink"><code>segmentation</code></a><code>="References"Â reset)=""Â return=""Â râ†l;=""Â râˆ‰l=""Â scissors=""Â to)=""Â total=""Â {and=""Â {assign=""Â {if=""Â {remove=""Â {set=""Â }=""&gt;</code></mtpl"Â <></code></g(<></code></p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://ivussnakes.sourceforge.net">Open Source Java implementation of Livewire Image Segmentation Tool for ImageJ - Daniel Lelis Baggio</a></li>
<li><a href="http://ivussnakes.sourceforge.net/?q=node/22">Coronary Segmentation video</a></li>
</ul>

<p><a href=":Category:Image_segmentation" title="wikilink">:Category:Image segmentation</a></p>
<h2 id="intelligent-scissors">Intelligent Scissors</h2>

<p>"</p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">MORTENSEN, E. N.; BARRETT, W. A. Intelligent scissors for image composition. In: SIGGRAPH â€™95: Proceedings of the 22nd annual conference on Computer graphics and interactive techniques. New York, NY, USA: ACM Press, 1995. p.Â 191â€“198. ISBN 0-89791-701-4.<a href="#fnref1">â†©</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
</ol>
</section>
</body>
</html>
