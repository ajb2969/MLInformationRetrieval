<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1480">Neural decoding</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Neural decoding</h1>
<hr/>

<p><strong>Neural decoding</strong> is a <a class="uri" href="neuroscience" title="wikilink">neuroscience</a>-related field concerned with the reconstruction of sensory and other stimuli from information that has already been encoded and represented in the <a class="uri" href="brain" title="wikilink">brain</a> by <a href="neural_network" title="wikilink">networks</a> of <a class="uri" href="neurons" title="wikilink">neurons</a>. Reconstruction refers to the ability of the researcher to predict what sensory stimuli the subject is receiving based purely on neuron <a href="action_potential" title="wikilink">action potentials</a>. Therefore, the main goal of neural decoding is to characterize how the electrical activity of neurons elicit activity and responses in the brain.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>This article specifically refers to neural decoding as it pertains to the mammalian <a class="uri" href="neocortex" title="wikilink">neocortex</a>.</p>
<h2 id="overview">Overview</h2>

<p>When looking at a picture, our brains are constantly making decisions about what object we are looking at, where we need to move our eyes next, and what we find to be the most salient aspects of the input stimulus. As these images hit the back of our retina, these stimuli are converted from varying wavelengths to a series of neural spikes called <a href="action_potential" title="wikilink">action potentials</a>. These pattern of action potentials are different for different objects and different colors; we therefore say that the neurons are encoding objects and colors by varying their spike rates or temporal pattern. Now, if someone were to probe the brain by placing <a class="uri" href="electrodes" title="wikilink">electrodes</a> in the <a href="visual_cortex" title="wikilink">primary visual cortex</a>, they may find what appears to be random electrical activity. These neurons are actually firing in response to the lower level features of visual input, possibly the edges of a picture frame. This highlights the crux of the neural decoding hypothesis: that is possible to reconstruct a stimulus from the response of the ensemble of neurons that represent it. By this we mean, it is possible to look at spike train data and say that the person or animal we are recording from is looking at a red ball.</p>

<p>With the recent breakthrough in large-scale neural recording and decoding technologies, researchers have begun to crack the neural code and already provided the first glimpse into the real-time neural code of memory traces as memory is formed and recalled in the hippocampus, a brain region known to be central for memory formation.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Neuroscientists have initiated large-scale brain activity mapping or brain decoding project <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> to construct the brain-wide neural codes.</p>
<h2 id="encoding-to-decoding">Encoding to decoding</h2>

<p>Implicit about the decoding hypothesis is the assumption that neural spiking in the brain somehow represents stimuli in the external world. The decoding of neural data would be impossible if the neurons were firing randomly: nothing would be represented. This process of decoding neural data forms a loop with <a href="Neural_coding" title="wikilink">neural encoding</a>. First, the organism must be able to perceive a set of stimuli in the world - say a picture of a hat. Seeing the stimuli must result in some internal learning: the <a href="Neural_code" title="wikilink">encoding stage</a>. After varying the range of stimuli that is presented to the observer, we expect the neurons to adapt to the statistical properties of the <a href="Signal_processing" title="wikilink">signals</a>, encoding those that occur most frequently:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> the <a href="Efficient_coding_hypothesis" title="wikilink">efficient-coding hypothesis</a>. Now neural decoding is the process of taking these statistical consistencies, a <a href="statistical_model" title="wikilink">statistical model</a> of the world, and reproducing the stimuli. This may map to the process of thinking and acting, which in turn guide what stimuli we receive, and thus, completing the loop.</p>

<p>In order to build a model of neural spike data, one must both understand how information is originally stored in the brain and how this information is used at a later point in time. This <a href="neural_coding" title="wikilink">neural coding</a> and decoding loop is a symbiotic relationship and the crux of the brain's learning algorithm. Furthermore, the processes that underlie neural decoding and encoding are very tightly coupled and may lead to varying levels of representative ability<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="spatial-resolutions">Spatial resolutions</h2>

<p>Much of the neural decoding problem depends on the <a href="spatial_resolution" title="wikilink">spatial resolution</a> of the data being collected. The number of neurons needed to reconstruct the stimulus with reasonable accuracy depends on the means by which data is collected and the area being recorded. For example, <a href="rods_and_cones" title="wikilink">rods and cones</a> (which respond to colors of small visual areas) in the retina may require more recordings than <a href="simple_cell" title="wikilink">simple cells</a> (which respond to orientation of lines) in the primary visual cortex.</p>

<p>Previous recording methods relied on <a href="Neurostimulation" title="wikilink">stimulating single neurons</a> over a repeated series of tests in order to generalize this neuron's behavior.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> New techniques such as high-density <a href="Multielectrode_array" title="wikilink">multi-electrode array recordings</a> and <a href="Two-photon_excitation_microscopy" title="wikilink">multi-photon calcium imaging techniques</a> now make it possible to record from upwards of a few hundred neurons. Even with better recording techniques, the focus of these recordings must be on an area of the brain that is both manageable and qualitatively understood. Many studies look at spike train data gathered from the <a href="Retinal_ganglion_cell" title="wikilink">ganglion cells</a> in the retina, since this area has the benefits of being strictly <a href="Feedforward_neural_network" title="wikilink">feedforward</a>, <a href="Retinotopy" title="wikilink">retinotopic</a>, and amenable to current recording granularities. The duration, intensity, and location of the stimulus can be controlled to sample, for example, a particular subset of ganglion cells within a structure of the visual system.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Other studies use spike trains to evaluate the discriminatory ability of non-visual senses such as rat facial whiskers<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> and the olfactory coding of moth pheromone receptor neurons.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>Even with ever-improving recording techniques, one will always run into the limited sampling problem: given a limited number of recording trials, it is impossible to completely account for the error associated with noisy data obtained from stochastically functioning neurons (for example, a neuron's <a href="electric_potential" title="wikilink">electric potential</a> fluctuates around its <a href="resting_potential" title="wikilink">resting potential</a> due to a constant influx and efflux of <a href="Voltage-gated_sodium_channel" title="wikilink">sodium</a> and <a href="Voltage-gated_potassium_channel" title="wikilink">potassium</a> ions). Therefore, it is not possible to perfectly reconstruct a stimulus from spike data. Luckily, even with noisy data, the stimulus can still be reconstructed within acceptable error bounds.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="temporal-resolutions">Temporal resolutions</h2>

<p>Timescales and frequencies of stimuli being presented to the observer are also of importance to decoding the neural code. Quicker timescales and higher frequencies demand faster and more precise responses in neural spike data. In humans, millisecond precision has been observed throughout the <a href="visual_cortex" title="wikilink">visual cortex</a>, the <a class="uri" href="retina" title="wikilink">retina</a>,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> and the <a href="lateral_geniculate_nucleus" title="wikilink">lateral geniculate nucleus</a>, so one would suspect this to be the appropriate measuring frequency. This has been confirmed in studies that quantify the responses of neurons in the <a href="lateral_geniculate_nucleus" title="wikilink">lateral geniculate nucleus</a> to white-noise and naturalistic movie stimuli.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> At the cellular level, <a href="spike-timing-dependent_plasticity" title="wikilink">spike-timing-dependent plasticity</a> operates at millisecond timescales;<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> therefore, models seeking biological relevance should be able to perform at these temporal scales.</p>
<h2 id="probabilistic-decoding">Probabilistic decoding</h2>

<p>When decoding neural data, arrival times of each spike 

<math display="inline" id="Neural_decoding:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mrow>
     <mrow></mrow>
     <msub>
      <mi>t</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow></mrow>
     <mi mathvariant="normal">…</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow></mrow>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
     <mrow></mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow></mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>t</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <mtext></mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext></mtext>
      <ci>normal-…</ci>
     </apply>
     <apply>
      <times></times>
      <mtext></mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
      <mtext></mtext>
     </apply>
    </list>
    <apply>
     <times></times>
     <mtext></mtext>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>i</ci>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{1},\text{ }t_{2},\text{ }...,\text{ }t_{n}\text{ }=\text{ }\{t_{i}\}
  </annotation>
 </semantics>
</math>

, and the <a class="uri" href="probability" title="wikilink">probability</a> of seeing a certain stimulus, 

<math display="inline" id="Neural_decoding:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P[s(t)]
  </annotation>
 </semantics>
</math>

 may be the extent of the available data. The <a href="Prior_probability" title="wikilink">prior distribution</a> 

<math display="inline" id="Neural_decoding:2">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P[s(t)]
  </annotation>
 </semantics>
</math>

 defines an ensemble of signals, and represents the <a href="Likelihood_function" title="wikilink">likelihood</a> of seeing a stimulus in the world based on previous experience. The spike times may also be drawn from a <a href="Probability_distribution" title="wikilink">distribution</a> 

<math display="inline" id="Neural_decoding:3">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>t</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>i</ci>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P[\{t_{i}\}]
  </annotation>
 </semantics>
</math>

; however, what we want to know is the <a href="probability_distribution" title="wikilink">probability distribution</a> over a set of stimuli given a series of spike trains 

<math display="inline" id="Neural_decoding:4">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>t</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">s</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P[s(t)|\{t_{i}\}]
  </annotation>
 </semantics>
</math>

, which is called the <a href="Conditional_probability" title="wikilink">response-conditional</a> ensemble. What remains is the characterization of the neural code by translating stimuli into spikes, 

<math display="inline" id="Neural_decoding:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>t</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P[\{t_{i}\}|s(t)]
  </annotation>
 </semantics>
</math>

; the traditional approach to calculating this probability distribution has been to fix the stimulus and examine the responses of the neuron. Combining everything using <a href="Bayes'_Rule" title="wikilink">Bayes' Rule</a> results in the simplified probabilistic characterization of neural decoding

<math display="block" id="Neural_decoding:6">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>t</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>t</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>*</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>/</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <msub>
       <mi>t</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">s</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <times></times>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">s</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <divide></divide>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P[s(t)|\{t_{i}\}]=P[\{t_{i}\}|s(t)]*(P[s(t)]/P[\{t_{i}\}])
  </annotation>
 </semantics>
</math>

. An area of active research consists of finding better ways of representing and determining 

<math display="inline" id="Neural_decoding:7">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>t</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P[\{t_{i}\}|s(t)]
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> The following are some such examples.</p>
<h3 id="spike-train-number">Spike train number</h3>

<p>The simplest coding strategy is the <a href="Neural_coding#Spike-count_rate" title="wikilink">spike train number coding</a>. This method assumes that the spike number is the most important quantification of spike train data. In spike train number coding, each stimulus is represented by a unique firing rate across the sampled neurons. The color red may be signified by 5 total spikes across the entire set of neurons, while the color green may be 10 spikes; each spike is pooled together into an overall count. This is represented by:</p>

<p>

<math display="inline" id="Neural_decoding:8">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo largeop="true" symmetric="true">∏</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="latexml">product</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(r|s)=\prod P(n_{ij}|s)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Neural_decoding:9">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mi>n</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>r</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">absent</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=n=
  </annotation>
 </semantics>
</math>

 the number of spikes, 

<math display="inline" id="Neural_decoding:10">
 <semantics>
  <msub>
   <mi>n</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{ij}
  </annotation>
 </semantics>
</math>

 is the number of spikes of neuron 

<math display="inline" id="Neural_decoding:11">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 at stimulus presentation time 

<math display="inline" id="Neural_decoding:12">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

, and s is the stimulus.</p>
<h3 id="instantaneous-rate-code">Instantaneous rate code</h3>

<p>Adding a small temporal component results in the <a href="Neural_coding#Time-dependent_firing_rate" title="wikilink">spike timing coding</a> strategy. Here, the main quantity measured is the number of spikes that occur within a predefined <a href="Window_function" title="wikilink">window</a> of time T. This method adds another dimension to the previous. This timing code is given by:</p>

<p>

<math display="inline" id="Neural_decoding:13">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mo largeop="true" symmetric="true">∏</mo>
    <mi>l</mi>
   </msub>
   <mrow>
    <mo>[</mo>
    <msub>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
       <mi>l</mi>
      </mrow>
     </msub>
     <mo stretchy="false">|</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
    <mi>t</mi>
    <mo>]</mo>
   </mrow>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo>[</mo>
    <mo>-</mo>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi>T</mi>
    </msubsup>
    <mi>d</mi>
    <mi>t</mi>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">|</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <ci>l</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
        <ci>l</ci>
       </apply>
      </apply>
      <ci>normal-|</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">d</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <ci>T</ci>
     </apply>
     <csymbol cd="unknown">d</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(r|s)=\prod_{l}\left[\prod_{i,j}v_{i}(t_{ijl}|s)dt\right]exp\left[-\sum_{i}%
\int_{0}^{T}dtv_{i}(t|s)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Neural_decoding:14">
 <semantics>
  <msub>
   <mi>t</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
    <mi>l</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{ijl}
  </annotation>
 </semantics>
</math>

 is the jth spike on the lth presentation of neuron i, 

<math display="inline" id="Neural_decoding:15">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}(t|s)
  </annotation>
 </semantics>
</math>

 is the firing rate of neuron i at time t, and 0 to T is the start to stop times of each trial.</p>
<h3 id="temporal-correlation">Temporal correlation</h3>

<p><a href="Neural_coding#Temporal_coding" title="wikilink">Temporal correlation code</a>, as the name states, adds <a class="uri" href="correlations" title="wikilink">correlations</a> between individual spikes. This means that the time between a spike 

<math display="inline" id="Neural_decoding:16">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{i}
  </annotation>
 </semantics>
</math>

 and its preceding spike 

<math display="inline" id="Neural_decoding:17">
 <semantics>
  <msub>
   <mi>t</mi>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{i-1}
  </annotation>
 </semantics>
</math>

 is included. This is given by:</p>

<p>

<math display="inline" id="Neural_decoding:18">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mo largeop="true" symmetric="true">∏</mo>
    <mi>l</mi>
   </msub>
   <mrow>
    <mo>[</mo>
    <msub>
     <mo largeop="true" symmetric="true">∏</mo>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
       <mi>l</mi>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
        <mi>l</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">|</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
    <mi>t</mi>
    <mo>]</mo>
   </mrow>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo>[</mo>
    <mo>-</mo>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi>T</mi>
    </msubsup>
    <mi>d</mi>
    <mi>t</mi>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>τ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">|</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <ci>l</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
        <ci>l</ci>
       </apply>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">τ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
         <ci>l</ci>
        </apply>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-|</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">d</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <ci>T</ci>
     </apply>
     <csymbol cd="unknown">d</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">τ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-|</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(r|s)=\prod_{l}\left[\prod_{i,j}v_{i}(t_{ijl},\tau(t_{ijl})|s)dt\right]exp%
\left[-\sum_{i}\int_{0}^{T}dtv_{i}(t,\tau(t)|s)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Neural_decoding:19">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>τ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(t)
  </annotation>
 </semantics>
</math>

 is the time interval between a neurons spike and the one preceding it.</p>
<h3 id="ising-decoder">Ising decoder</h3>

<p>Another description of neural spike train data uses the <a href="Ising_model" title="wikilink">Ising model</a> borrowed from the physics of magnetic spins. Because neural spike trains effectively binarized(either on or off) at small time scales (10 to 20 ms), the <a href="Ising_model" title="wikilink">Ising model</a> is able to effectively capture the present pairwise correlations,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> and is given by:</p>

<p>

<math display="inline" id="Neural_decoding:20">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">|</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Zeta</mtext>
     </merror>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>h</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>≠</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <msub>
     <mi>J</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>r</mi>
     <mi>j</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <mtext>\Zeta</mtext>
      <ci>s</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <neq></neq>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>J</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(r|s)=\frac{1}{\Zeta(s)}exp\left(\sum_{i}h_{i}(s)r_{i}+\frac{1}{2}\sum_{i\neq
j%
}J_{ij}(s)r_{i}r_{j}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Neural_decoding:21">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>r</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>r</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>n</ci>
      </apply>
     </vector>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=(r_{1},r_{2},...,r_{n})^{T}
  </annotation>
 </semantics>
</math>

 is the set of binary responses of neuron i, 

<math display="inline" id="Neural_decoding:22">
 <semantics>
  <msub>
   <mi>h</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{i}
  </annotation>
 </semantics>
</math>

 is the <a href="Mean_field_theory" title="wikilink">external fields function</a>, 

<math display="inline" id="Neural_decoding:23">
 <semantics>
  <msub>
   <mi>J</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>J</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{ij}
  </annotation>
 </semantics>
</math>

 is the <a href="Ising_model#Pairwise_correlated_bits" title="wikilink">pairwise couplings function</a>, and 

<math display="inline" id="Neural_decoding:24">
 <semantics>
  <mrow>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\Zeta</mtext>
   </merror>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>\Zeta</mtext>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Zeta(s)
  </annotation>
 </semantics>
</math>

 is the <a href="partition_function" title="wikilink">partition function</a>.</p>
<h2 id="agent-based-decoding">Agent-based decoding</h2>

<p>In addition to the probabilistic approach, <a href="agent-based_model" title="wikilink">agent-based models</a> exist that capture the spatial dynamics of the neural system under scrutiny. One such model is <a href="hierarchical_temporal_memory" title="wikilink">hierarchical temporal memory</a>, which is a <a href="machine_learning" title="wikilink">machine learning</a> framework that organizes visual perception problem into a <a class="uri" href="hierarchy" title="wikilink">hierarchy</a> of interacting nodes (neurons). The connections between nodes on the same levels and a lower levels are termed <a href="Chemical_synapse" title="wikilink">synapses</a>, and their interactions are subsequently learning. Synapse strengths modulate learning and are altered based on the temporal and spatial firing of nodes in response to input patterns.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>While it is possible to take the firing rates of these modeled neurons, and transform them into the probabilistic and mathematical frameworks described above, agent-based models provide the ability to observe the behavior of the entire population of modeled neurons. Researchers can circumvent the limitations implicit with lab-based recording techniques. Because this approach does rely on modeling biological systems, error arises in the assumptions made by the researcher and in the data used in <a href="parameter_estimation" title="wikilink">parameter estimation</a>.</p>
<h2 id="applicability">Applicability</h2>

<p>The advancement in our understanding of neural decoding benefits the development of <a href="brain-machine_interfaces" title="wikilink">brain-machine interfaces</a>, <a class="uri" href="prosthetics" title="wikilink">prosthetics</a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> and the understanding of neurological disorders such as <a class="uri" href="epilepsy" title="wikilink">epilepsy</a>.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Rate_coding" title="wikilink">Rate coding</a></li>
<li><a href="Sparse_coding" title="wikilink">Sparse coding</a></li>
<li><a href="Phase-of-firing_code" title="wikilink">Phase-of-firing code</a></li>
<li><a href="Population_coding" title="wikilink">Population coding</a></li>
<li><a href="Temporal_coding" title="wikilink">Temporal coding</a></li>
<li><a href="Correlation_coding" title="wikilink">Correlation coding</a></li>
<li><a href="Independent-spike_coding" title="wikilink">Independent-spike coding</a></li>
<li><a class="uri" href="NeuroElectroDynamics" title="wikilink">NeuroElectroDynamics</a></li>
<li><a href="Neural_synchronization" title="wikilink">Neural synchronization</a></li>
<li><a href="Multielectrode_array" title="wikilink">Multielectrode array</a></li>
<li><a href="Patch_clamp" title="wikilink">Patch clamp</a></li>
<li><a href="Grandmother_Cell" title="wikilink">Grandmother Cell</a></li>
<li><a href="Nervous_system_network_models" title="wikilink">Nervous system network models</a></li>
<li><a class="uri" href="Bursting" title="wikilink">Bursting</a></li>
<li><a href="Neural_coding" title="wikilink">Neural coding</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Neural_coding" title="wikilink"> </a> <a href="Category:Computational_neuroscience" title="wikilink">Category:Computational neuroscience</a> <a class="uri" href="Category:Neuroscience" title="wikilink">Category:Neuroscience</a> <a href="Category:Neural_networks" title="wikilink">Category:Neural networks</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Chen G, Wang LP, Tsien JZ. Neural population-level memory traces in the mouse hippocampus. PLoS One. 2009 Dec 16;4(12):e8256. doi: 10.1371/journal.pone.0008256.PMID 20016843. <a href="http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0008256">http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0008256</a> <a href="#fnref2">↩</a></li>
<li id="fn3">Zhang H, Chen G, Kuang H, Tsien JZ.Mapping and deciphering neural codes of NMDA receptor-dependent fear memory engrams in the hippocampus.PLoS One. 2013 Nov 26;8(11):e79454. doi: 10.1371/journal.pone.0079454. eCollection 2013.PMID: <a href="http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.007945424302990">http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.007945424302990</a> <a href="#fnref3">↩</a></li>
<li id="fn4">The Brain Decoding Project. <a class="uri" href="http://braindecodingproject.org/">http://braindecodingproject.org/</a><a href="#fnref4">↩</a></li>
<li id="fn5">Barlow, H. (1961). Possible principles underlying the transformation of sensory messages. Sensory communication.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"> <a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16">Rieke, F. (1999). Spikes: exploring the neural code. exploring the neural code (p. 395). The MIT Press.<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18">Hawkins, J., Ahmad, S., &amp; Dubinsky, D. (2006). Hierarchical temporal memory: Concepts, theory and terminology. Whitepaper.<a href="#fnref18">↩</a></li>
<li id="fn19">Hawkins, J., &amp; Blakeslee, S. (2005). On intelligence. Owl Books.<a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
</ol>
</section>
</body>
</html>
