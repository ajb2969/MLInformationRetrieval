   Verlet integration      Verlet integration   Verlet integration () is a numerical method used to integrate  Newton's  equations of motion . 1 It is frequently used to calculate trajectories of particles in molecular dynamics simulations and computer graphics . The algorithm was first used in 1791 by Delambre , and has been rediscovered many times since then, most recently by Loup Verlet in the 1960s for use in molecular dynamics. It was also used by Cowell and Crommelin in 1909 to compute the orbit of Halley's Comet , and by Carl Størmer in 1907 to study the motion of electrical particles in a magnetic field . The Verlet integrator provides good numerical stability , as well as other properties that are important in physical systems such as time-reversibility and preservation of the symplectic form on phase space , at no significant additional computational cost over the simple Euler method . Verlet integration was used by Carl Størmer to compute the trajectories of particles moving in a magnetic field (hence it is also called Störmer's method ) 2 and was popularized in molecular dynamics by French physicist Loup Verlet in 1967.  Basic Störmer–Verlet  For a differential equation of second order of the type       x  →   ¨    (  t  )    =    A  →    (    x  →    (  t  )    )           normal-¨   normal-→  x    t      normal-→  A      normal-→  x   t      \ddot{\vec{x}}(t)=\vec{A}(\vec{x}(t))   with initial conditions      x  →    (   t  0   )    =    x  →   0          normal-→  x    subscript  t  0     subscript   normal-→  x   0     \vec{x}(t_{0})=\vec{x}_{0}   and       x  →   ˙    (   t  0   )    =    v  →   0          normal-˙   normal-→  x     subscript  t  0     subscript   normal-→  v   0     \dot{\vec{x}}(t_{0})=\vec{v}_{0}   , an approximate numerical solution      x  →   n   ≈    x  →    (   t  n   )         subscript   normal-→  x   n      normal-→  x    subscript  t  n      \vec{x}_{n}\approx\vec{x}(t_{n})   at the times     t  n   =    t  0   +    n   Δ  t         subscript  t  n      subscript  t  0     n  normal-Δ  t      t_{n}=t_{0}+n\,\Delta t   with step size     Δ  t   >  0        normal-Δ  t   0    \Delta t>0   can be obtained by the following method:   set      x  →   1   =     x  →   0   +      v  →   0    Δ  t   +    1  2   A   (    x  →   0   )   Δ   t  2          subscript   normal-→  x   1      subscript   normal-→  x   0      subscript   normal-→  v   0   normal-Δ  t       1  2   A   subscript   normal-→  x   0   normal-Δ   superscript  t  2       \vec{x}_{1}=\vec{x}_{0}+\vec{v}_{0}\,\Delta t+\frac{1}{2}A(\vec{x}_{0})\,%
 \Delta t^{2}     for n=1,2,... iterate          \vec x_{n+1}=2 \vec x_n- \vec x_{n-1}+ A(\vec x_n)\,\Delta t^2.  Equations of motion  Newton's equation of motion for conservative physical systems is       M    x  →   ¨    (  t  )    =   F   (    x  →    (  t  )    )    =   -    ∇  V    (    x  →    (  t  )    )             M   normal-¨   normal-→  x    t     F     normal-→  x   t              normal-∇  V      normal-→  x   t        M\ddot{\vec{x}}(t)=F(\vec{x}(t))=-\nabla V(\vec{x}(t))   or individually        m  k      x  →   ¨   k    (  t  )    =    F  k    (    x  →    (  t  )    )    =   -     ∇    x  →   k    V    (    x  →    (  t  )    )              subscript  m  k    subscript   normal-¨   normal-→  x    k   t      subscript  F  k      normal-→  x   t               subscript  normal-∇   subscript   normal-→  x   k    V      normal-→  x   t        m_{k}\ddot{\vec{x}}_{k}(t)=F_{k}(\vec{x}(t))=-\nabla_{\vec{x}_{k}}V(\vec{x}(t))   where   t is the time,        x  →    (  t  )    =   (     x  →   1    (  t  )    ,  …  ,     x  →   N    (  t  )    )          normal-→  x   t       subscript   normal-→  x   1   t   normal-…     subscript   normal-→  x   N   t      \vec{x}(t)=(\vec{x}_{1}(t),\ldots,\vec{x}_{N}(t))   is the ensemble of the position vector of N objects,  V is the scalar potential function,  F is the negative gradient of the potential giving the ensemble of forces on the particles,  M is the mass matrix , typically diagonal with blocks with mass    m  k     subscript  m  k    m_{k}   for every particle.   This equation, for various choices of the potential function V , can be used to describe the evolution of diverse physical systems, from the motion of interacting molecules to the orbit of the planets .  After a transformation to bring the mass to the right side and forgetting the structure of multiple particles, the equation may be simplified to         x  →   ¨    (  t  )    =   A   (    x  →    (  t  )    )           normal-¨   normal-→  x    t     A     normal-→  x   t      \ddot{\vec{x}}(t)=A(\vec{x}(t))   with some suitable vector valued function A representing the position dependent acceleration. Typically, an initial position      x  →    (  0  )    =    x  →   0          normal-→  x   0    subscript   normal-→  x   0     \vec{x}(0)=\vec{x}_{0}   and an initial velocity      v  →    (  0  )    =     x  →   ˙    (  0  )    =    v  →   0            normal-→  v   0      normal-˙   normal-→  x    0         subscript   normal-→  v   0      \vec{v}(0)=\dot{\vec{x}}(0)=\vec{v}_{0}   are also given.  Verlet integration (without velocities)  To discretize and numerically solve this initial value problem , a time step     Δ  t   >  0        normal-Δ  t   0    \Delta t>0   is chosen and the sampling point sequence     t  n   =   n  Δ  t        subscript  t  n     n  normal-Δ  t     t_{n}=n\Delta t   considered. The task is to construct a sequence of points     x  →   n     subscript   normal-→  x   n    \vec{x}_{n}   that closely follow the points     x  →    (   t  n   )        normal-→  x    subscript  t  n     \vec{x}(t_{n})   on the trajectory of the exact solution.  Where Euler's method uses the forward difference approximation to the first derivative in differential equations of order one, Verlet Integration can be seen as using the central difference approximation to the second derivative:         Δ  2     x  →   n     Δ   t  2     =        x  →    n  +  1    -    x  →   n     Δ  t    -      x  →   n   -    x  →    n  -  1      Δ  t      Δ  t    =       x  →    n  +  1    -   2    x  →   n     +    x  →    n  -  1      Δ   t  2     =    a  →   n   =   A   (    x  →   n   )               superscript  normal-Δ  2    subscript   normal-→  x   n      normal-Δ   superscript  t  2              subscript   normal-→  x     n  1     subscript   normal-→  x   n      normal-Δ  t         subscript   normal-→  x   n    subscript   normal-→  x     n  1       normal-Δ  t       normal-Δ  t                subscript   normal-→  x     n  1      2   subscript   normal-→  x   n      subscript   normal-→  x     n  1       normal-Δ   superscript  t  2           subscript   normal-→  a   n          A   subscript   normal-→  x   n       \frac{\Delta^{2}\vec{x}_{n}}{\Delta t^{2}}=\frac{\frac{\vec{x}_{n+1}-\vec{x}_{%
 n}}{\Delta t}-\frac{\vec{x}_{n}-\vec{x}_{n-1}}{\Delta t}}{\Delta t}=\frac{\vec%
 {x}_{n+1}-2\vec{x}_{n}+\vec{x}_{n-1}}{\Delta t^{2}}=\vec{a}_{n}=A(\vec{x}_{n})     Verlet integration in the form used as the Störmer method 3 uses this equation to obtain the next position vector from the previous two without using the velocity as          x  →    n  +  1    =     2    x  →   n    -    x  →    n  -  1     +      a  →   n    Δ   t  2      ,     a  →   n   =   A   (    x  →   n   )      .     formulae-sequence     subscript   normal-→  x     n  1          2   subscript   normal-→  x   n     subscript   normal-→  x     n  1        subscript   normal-→  a   n   normal-Δ   superscript  t  2         subscript   normal-→  a   n     A   subscript   normal-→  x   n       \vec{x}_{n+1}=2\vec{x}_{n}-\vec{x}_{n-1}+\vec{a}_{n}\,\Delta t^{2},\qquad\vec{%
 a}_{n}=A(\vec{x}_{n}).     Discretization error  The time symmetry inherent in the method reduces the level of local errors introduced into the integration by the discretization by removing all odd degree terms, here the terms in    Δ  t      normal-Δ  t    \Delta t   of degree three. The local error is quantified by inserting the exact values      x  →    (   t   n  -  1    )    ,    x  →    (   t  n   )    ,    x  →    (   t   n  +  1    )          normal-→  x    subscript  t    n  1        normal-→  x    subscript  t  n       normal-→  x    subscript  t    n  1       \vec{x}(t_{n-1}),\vec{x}(t_{n}),\vec{x}(t_{n+1})   into the iteration and computing the Taylor expansions at time    t  =   t  n       t   subscript  t  n     t=t_{n}   of the position vector     x  →    (   t  ±   Δ  t    )        normal-→  x    plus-or-minus  t    normal-Δ  t      \vec{x}(t\pm\Delta t)   in different time directions.       x  →    (   t  +   Δ  t    )        normal-→  x     t    normal-Δ  t      \displaystyle\vec{x}(t+\Delta t)   where    x  →     normal-→  x    \vec{x}   is the position,     v  →   =    x  →   ˙        normal-→  v    normal-˙   normal-→  x      \vec{v}=\dot{\vec{x}}   the velocity,     a  →   =    x  →   ¨        normal-→  a    normal-¨   normal-→  x      \vec{a}=\ddot{\vec{x}}   the acceleration and    b  →     normal-→  b    \vec{b}   the jerk (third derivative of the position with respect to the time)   t   t   t   .  Adding these two expansions gives         x  →    (   t  +   Δ  t    )    =     2   x  →    (  t  )    -    x  →    (   t  -   Δ  t    )     +    a  →    (  t  )   Δ   t  2    +   𝒪   (   Δ   t  4    )      .         normal-→  x     t    normal-Δ  t           2   normal-→  x   t      normal-→  x     t    normal-Δ  t         normal-→  a   t  normal-Δ   superscript  t  2      𝒪    normal-Δ   superscript  t  4        \vec{x}(t+\Delta t)=2\vec{x}(t)-\vec{x}(t-\Delta t)+\vec{a}(t)\Delta t^{2}+%
 \mathcal{O}(\Delta t^{4}).\,   We can see that the first and third-order terms from the Taylor expansion cancel out, thus making the Verlet integrator an order more accurate than integration by simple Taylor expansion alone.  Caution should be applied to the fact that the acceleration here is computed from the exact solution,      a  →    (  t  )    =   A   (    x  →    (  t  )    )           normal-→  a   t     A     normal-→  x   t      \vec{a}(t)=A(\vec{x}(t))   , whereas in the iteration it is computed at the central iteration point,      a  →   n   =   A   (    x  →   n   )         subscript   normal-→  a   n     A   subscript   normal-→  x   n      \vec{a}_{n}=A(\vec{x}_{n})   . In computing the global error, that is the distance between exact solution and approximation sequence, those two terms do not cancel exactly, influencing the order of the global error.  A simple example  To gain insight into the relation of local and global errors it is helpful to examine simple examples where the exact as well as the approximative solution can be expressed in explicit formulas. The standard example for this task is the exponential function .  Consider the linear differential equation      x  ¨    (  t  )    =    w  2   x   (  t  )           normal-¨  x   t      superscript  w  2   x  t     \ddot{x}(t)=w^{2}x(t)   with a constant w . Its exact basis solutions are    e   w  t      superscript  e    w  t     e^{wt}   and    e   -   w  t       superscript  e      w  t      e^{-wt}   .  The Störmer method applied to this differential equation leads to a linear recurrence relation        x   n  +  1    -   2   x  n     +   x   n  -  1           subscript  x    n  1      2   subscript  x  n      subscript  x    n  1      \displaystyle x_{n+1}-2x_{n}+x_{n-1}   It can be solved by finding the roots of its characteristic polynomial       q  2   -   2   (   1  +    1  2     (   w  h   )   2     )   q    +  1   =  0           superscript  q  2     2    1      1  2    superscript    w  h   2     q    1   0    q^{2}-2(1+\tfrac{1}{2}(wh)^{2})q+1=0   . These are       q  ±   =    1  +     1  2      (   w  h   )   2     ±   w  h    1  +     1  4      (   w  h   )   2             subscript  q  plus-or-minus    plus-or-minus    1      1  2    superscript    w  h   2       w  h      1      1  4    superscript    w  h   2          q_{\pm}=1+\tfrac{1}{2}(wh)^{2}\pm wh\sqrt{1+\tfrac{1}{4}(wh)^{2}}   . The basis solutions of the linear recurrence are     x  n   =   q  +   n         subscript  x  n    superscript   subscript  q    n     x_{n}=q_{+}^{\;n}   and     x  n   =   q  -   n         subscript  x  n    superscript   subscript  q    n     x_{n}=q_{-}^{\;n}   . To compare them with the exact solutions, Taylor expansions are computed.      q  +     subscript  q     \displaystyle q_{+}   The quotient of this series with the one of the exponential    e   w  h      superscript  e    w  h     e^{wh}   starts with     1  -    1  24     (   w  h   )   3     +   𝒪   (   h  5   )          1      1  24    superscript    w  h   3       𝒪   superscript  h  5      1-\tfrac{1}{24}(wh)^{3}+\mathcal{O}(h^{5})   , so      q  +     subscript  q     \displaystyle q_{+}   From there it follows that for the first basis solution the error can be computed as       x  n   =   q  +   n         subscript  x  n    superscript   subscript  q    n     \displaystyle x_{n}=q_{+}^{\;n}   That is, although the local discretization error is of order 4, due to the second order of the differential equation the global error is of order 2, with a constant that grows exponentially in time.  Starting the iteration  Note that at the start of the Verlet-iteration at step    n  =  1      n  1    n=1   , time    t  =   t  1   =   Δ  t         t   subscript  t  1          normal-Δ  t      t=t_{1}=\Delta t   , computing     x  →   2     subscript   normal-→  x   2    \vec{x}_{2}   , one already needs the position vector     x  →   1     subscript   normal-→  x   1    \vec{x}_{1}   at time    t  =   t  1       t   subscript  t  1     t=t_{1}   . At first sight this could give problems, because the initial conditions are known only at the initial time     t  0   =  0       subscript  t  0   0    t_{0}=0   . However, from these the acceleration      a  →   0   =   A   (    x  →   0   )         subscript   normal-→  a   0     A   subscript   normal-→  x   0      \vec{a}_{0}=A(\vec{x}_{0})   is known, and a suitable approximation for the first time step position can be obtained using the Taylor polynomial of degree two:         x  →   1   =     x  →   0   +     v  →   0   Δ  t   +     1  2      a  →   0   Δ   t  2     ≈     x  →    (   Δ  t   )    +   𝒪   (   Δ   t  3    )      .         subscript   normal-→  x   1      subscript   normal-→  x   0      subscript   normal-→  v   0   normal-Δ  t       1  2    subscript   normal-→  a   0   normal-Δ   superscript  t  2               normal-→  x     normal-Δ  t      𝒪    normal-Δ   superscript  t  3         \vec{x}_{1}=\vec{x}_{0}+\vec{v}_{0}\Delta t+\tfrac{1}{2}\vec{a}_{0}\Delta t^{2%
 }\approx\vec{x}(\Delta t)+\mathcal{O}(\Delta t^{3}).\,     The error on the first time step calculation then is of order    𝒪   (   Δ   t  3    )       𝒪    normal-Δ   superscript  t  3      \mathcal{O}(\Delta t^{3})   . This is not considered a problem because on a simulation of over a large amount of timesteps, the error on the first timestep is only a negligibly small amount of the total error, which at time    t  n     subscript  t  n    t_{n}   is of the order    𝒪   (    e   L   t  n     Δ   t  2    )       𝒪     superscript  e    L   subscript  t  n     normal-Δ   superscript  t  2      \mathcal{O}(e^{Lt_{n}}\Delta t^{2})   , both for the distance of the position vectors     x  →   n     subscript   normal-→  x   n    \vec{x}_{n}   to     x  →    (   t  n   )        normal-→  x    subscript  t  n     \vec{x}(t_{n})   as for the distance of the divided differences       x  →    n  +  1    -    x  →   n     Δ  t          subscript   normal-→  x     n  1     subscript   normal-→  x   n      normal-Δ  t     \tfrac{\vec{x}_{n+1}-\vec{x}_{n}}{\Delta t}   to       x  →    (   t   n  +  1    )    -    x  →    (   t  n   )      Δ  t            normal-→  x    subscript  t    n  1        normal-→  x    subscript  t  n       normal-Δ  t     \tfrac{\vec{x}(t_{n+1})-\vec{x}(t_{n})}{\Delta t}   . Moreover, to obtain this second order global error, the initial error needs to be of at least third order.  Non-constant time differences  A disadvantage of the Störmer–Verlet method is that if the time-step (    Δ  t      normal-Δ  t    \Delta t   ) changes, the method does not approximate the solution to the differential equation. This is particularly an issue for game designers, who may be integrating at a variable framerate.  This can be corrected using the formula: 4        x  →    i  +  1    =     x  →   i   +    (     x  →   i   -    x  →    i  -  1     )    (     Δ   t  i    /  Δ    t   i  -  1     )    +    a  →   Δ   t  i  2          subscript   normal-→  x     i  1       subscript   normal-→  x   i        subscript   normal-→  x   i    subscript   normal-→  x     i  1           normal-Δ   subscript  t  i    normal-Δ    subscript  t    i  1         normal-→  a   normal-Δ   superscript   subscript  t  i   2       \vec{x}_{i+1}=\vec{x}_{i}+(\vec{x}_{i}-\vec{x}_{i-1})(\Delta t_{i}/\Delta t_{i%
 -1})+\vec{a}\Delta t_{i}^{2}     A more exact derivation uses the Taylor series (to second order) at    t  i     subscript  t  i    t_{i}   for times     t   i  +  1    =    t  i   +   Δ   t  i          subscript  t    i  1       subscript  t  i     normal-Δ   subscript  t  i       t_{i+1}=t_{i}+\Delta t_{i}   and     t   i  -  1    =    t  i   -   Δ   t   i  -  1           subscript  t    i  1       subscript  t  i     normal-Δ   subscript  t    i  1        t_{i-1}=t_{i}-\Delta t_{i-1}   to obtain after elimination of     v  →   i     subscript   normal-→  v   i    \vec{v}_{i}              x  →    i  +  1    -    x  →   i     Δ   t  i     +      x  →    i  -  1    -    x  →   i     Δ   t   i  -  1       =      a  →   i       Δ   t  i    +   Δ   t   i  -  1      2               subscript   normal-→  x     i  1     subscript   normal-→  x   i      normal-Δ   subscript  t  i          subscript   normal-→  x     i  1     subscript   normal-→  x   i      normal-Δ   subscript  t    i  1          subscript   normal-→  a   i         normal-Δ   subscript  t  i      normal-Δ   subscript  t    i  1      2      \frac{\vec{x}_{i+1}-\vec{x}_{i}}{\Delta t_{i}}+\frac{\vec{x}_{i-1}-\vec{x}_{i}%
 }{\Delta t_{i-1}}=\vec{a}_{i}\,\frac{\Delta t_{i}+\Delta t_{i-1}}{2}   so that the iteration formula becomes        x  →    i  +  1    =     x  →   i   +    (     x  →   i   -    x  →    i  -  1     )     Δ   t  i     Δ   t   i  -  1       +      a  →   i        Δ   t  i    +   Δ   t   i  -  1      2    Δ   t  i          subscript   normal-→  x     i  1       subscript   normal-→  x   i        subscript   normal-→  x   i    subscript   normal-→  x     i  1         normal-Δ   subscript  t  i      normal-Δ   subscript  t    i  1          subscript   normal-→  a   i         normal-Δ   subscript  t  i      normal-Δ   subscript  t    i  1      2   normal-Δ   subscript  t  i       \vec{x}_{i+1}=\vec{x}_{i}+(\vec{x}_{i}-\vec{x}_{i-1})\frac{\Delta t_{i}}{%
 \Delta t_{i-1}}+\vec{a}_{i}\,\frac{\Delta t_{i}+\Delta t_{i-1}}{2}\,\Delta t_{i}     Computing velocities – Störmer–Verlet method  The velocities are not explicitly given in the basic Störmer equation, but often they are necessary for the calculation of certain physical quantities like the kinetic energy. This can create technical challenges in molecular dynamics simulations, because kinetic energy and instantaneous temperatures at time   t   t   t   cannot be calculated for a system until the positions are known at time    t  +   Δ  t       t    normal-Δ  t     t+\Delta t   . This deficiency can either be dealt with using the Velocity Verlet algorithm, or estimating the velocity using the position terms and the mean value theorem :         v  →    (  t  )    =       x  →    (   t  +   Δ  t    )    -    x  →    (   t  -   Δ  t    )      2  Δ  t    +   𝒪   (   Δ   t  2    )      .         normal-→  v   t            normal-→  x     t    normal-Δ  t        normal-→  x     t    normal-Δ  t        2  normal-Δ  t      𝒪    normal-Δ   superscript  t  2        \vec{v}(t)=\frac{\vec{x}(t+\Delta t)-\vec{x}(t-\Delta t)}{2\Delta t}+\mathcal{%
 O}(\Delta t^{2}).     Note that this velocity term is a step behind the position term, since this is for the velocity at time   t   t   t   , not    t  +   Δ  t       t    normal-Δ  t     t+\Delta t   , meaning that      v  →   n   =      x  →    n  +  1    -    x  →    n  -  1      2  Δ  t         subscript   normal-→  v   n        subscript   normal-→  x     n  1     subscript   normal-→  x     n  1       2  normal-Δ  t      \vec{v}_{n}=\tfrac{\vec{x}_{n+1}-\vec{x}_{n-1}}{2\Delta t}   is an order two approximation to     v  →    (   t  n   )        normal-→  v    subscript  t  n     \vec{v}(t_{n})   . With the same argument, but halving the time step,      v  →    n  +   1  /  2     =      x  →    n  +  1    -    x  →   n     Δ  t         subscript   normal-→  v     n    1  2          subscript   normal-→  x     n  1     subscript   normal-→  x   n      normal-Δ  t      \vec{v}_{n+1/2}=\tfrac{\vec{x}_{n+1}-\vec{x}_{n}}{\Delta t}   is an order two approximation to     v  →    (   t   n  +   1  /  2     )        normal-→  v    subscript  t    n    1  2       \vec{v}(t_{n+1/2})   , with     t   n  +   1  /  2     =    t  n   +    1  2   Δ  t         subscript  t    n    1  2        subscript  t  n       1  2   normal-Δ  t      t_{n+1/2}=t_{n}+\tfrac{1}{2}\Delta t   .  One can shorten the interval to approximate the velocity at time    t  +   Δ  t       t    normal-Δ  t     t+\Delta t   at the cost of accuracy:         v  →    (   t  +   Δ  t    )    =       x  →    (   t  +   Δ  t    )    -    x  →    (  t  )      Δ  t    +   𝒪   (   Δ  t   )      .         normal-→  v     t    normal-Δ  t              normal-→  x     t    normal-Δ  t        normal-→  x   t      normal-Δ  t      𝒪    normal-Δ  t       \vec{v}(t+\Delta t)=\frac{\vec{x}(t+\Delta t)-\vec{x}(t)}{\Delta t}+\mathcal{O%
 }(\Delta t).     Velocity Verlet  A related, and more commonly used, algorithm is the Velocity Verlet algorithm, 5 similar to the leapfrog method , except that the velocity and position are calculated at the same value of the time variable (Leapfrog does not, as the name suggests). This uses a similar approach but explicitly incorporates velocity, solving the first-timestep problem in the Basic Verlet algorithm:        x  →    (   t  +   Δ  t    )    =     x  →    (  t  )    +    v  →    (  t  )   Δ  t   +     1  2     a  →    (  t  )   Δ    t  2             normal-→  x     t    normal-Δ  t          normal-→  x   t      normal-→  v   t  normal-Δ  t       1  2    normal-→  a   t  normal-Δ   superscript  t  2       \vec{x}(t+\Delta t)=\vec{x}(t)+\vec{v}(t)\,\Delta t+\frac{1}{2}\,\vec{a}(t)%
 \Delta t^{2}\,           v  →    (   t  +   Δ  t    )    =     v  →    (  t  )    +       a  →    (  t  )    +    a  →    (   t  +   Δ  t    )     2   Δ   t            normal-→  v     t    normal-Δ  t          normal-→  v   t            normal-→  a   t      normal-→  a     t    normal-Δ  t      2   normal-Δ  t      \vec{v}(t+\Delta t)=\vec{v}(t)+\frac{\vec{a}(t)+\vec{a}(t+\Delta t)}{2}\Delta t\,     It can be shown that the error on the Velocity Verlet is of the same order as the Basic Verlet. Note that the Velocity algorithm is not necessarily more memory consuming, because it's not necessary to keep track of the velocity at every timestep during the simulation. The standard implementation scheme of this algorithm is:   Calculate      v  →    (   t  +      1  2     Δ  t    )    =     v  →    (  t  )    +      1  2      a  →    (  t  )   Δ   t            normal-→  v     t      1  2   normal-Δ  t          normal-→  v   t       1  2    normal-→  a   t  normal-Δ  t      \vec{v}\left(t+\tfrac{1}{2}\,\Delta t\right)=\vec{v}(t)+\tfrac{1}{2}\,\vec{a}(%
 t)\,\Delta t\,     Calculate      x  →    (   t  +   Δ  t    )    =     x  →    (  t  )    +    v  →    (   t  +      1  2     Δ  t    )   Δ   t            normal-→  x     t    normal-Δ  t          normal-→  x   t      normal-→  v     t      1  2   normal-Δ  t    normal-Δ  t      \vec{x}(t+\Delta t)=\vec{x}(t)+\vec{v}\left(t+\tfrac{1}{2}\,\Delta t\right)\,%
 \Delta t\,     Derive     a  →    (   t  +   Δ  t    )        normal-→  a     t    normal-Δ  t      \vec{a}(t+\Delta t)   from the interaction potential using     x  →    (   t  +   Δ  t    )        normal-→  x     t    normal-Δ  t      \vec{x}(t+\Delta t)     Calculate       v  →    (   t  +   Δ  t    )    =     v  →    (   t  +      1  2     Δ  t    )    +      1  2      a  →    (   t  +   Δ  t    )   Δ  t     ,         normal-→  v     t    normal-Δ  t          normal-→  v     t      1  2   normal-Δ  t         1  2    normal-→  a     t    normal-Δ  t    normal-Δ  t      \vec{v}(t+\Delta t)=\vec{v}\left(t+\tfrac{1}{2}\,\Delta t\right)+\tfrac{1}{2}%
 \,\vec{a}(t+\Delta t)\Delta t,      Eliminating the half-step velocity, this algorithm may be shortened to   Calculate      x  →    (   t  +   Δ  t    )    =     x  →    (  t  )    +    v  →    (  t  )   Δ  t   +      1  2      a  →    (  t  )   Δ   t  2            normal-→  x     t    normal-Δ  t          normal-→  x   t      normal-→  v   t  normal-Δ  t       1  2    normal-→  a   t  normal-Δ   superscript  t  2       \vec{x}(t+\Delta t)=\vec{x}(t)+\vec{v}(t)\,\Delta t+\tfrac{1}{2}\,\vec{a}(t)\,%
 \Delta t^{2}     Derive     a  →    (   t  +   Δ  t    )        normal-→  a     t    normal-Δ  t      \vec{a}(t+\Delta t)   from the interaction potential using     x  →    (   t  +   Δ  t    )        normal-→  x     t    normal-Δ  t      \vec{x}(t+\Delta t)     Calculate      v  →    (   t  +   Δ  t    )    =     v  →    (  t  )    +      1  2      (     a  →    (  t  )    +    a  →    (   t  +   Δ  t    )     )   Δ   t            normal-→  v     t    normal-Δ  t          normal-→  v   t       1  2        normal-→  a   t      normal-→  a     t    normal-Δ  t      normal-Δ  t      \vec{v}(t+\Delta t)=\vec{v}(t)+\tfrac{1}{2}\,\left(\vec{a}(t)+\vec{a}(t+\Delta
 t%
 )\right)\Delta t\,      Note, however, that this algorithm assumes that acceleration     a  →    (   t  +   Δ  t    )        normal-→  a     t    normal-Δ  t      \vec{a}(t+\Delta t)   only depends on position     x  →    (   t  +   Δ  t    )        normal-→  x     t    normal-Δ  t      \vec{x}(t+\Delta t)   , and does not depend on velocity     v  →    (   t  +   Δ  t    )        normal-→  v     t    normal-Δ  t      \vec{v}(t+\Delta t)   .  One might note that the long-term results of Velocity Verlet , and similarly of Leapfrog are one order better than the semi-implicit Euler method . The algorithms are almost identical up to a shifted by half of a timestep in the velocity. This is easily proven by rotating the above loop to start at Step 3 and then noticing that the acceleration term in Step 1 could be eliminated by combining Steps 2 and 4. The only difference is that the midpoint velocity in velocity Verlet is considered the final velocity in semi-implicit Euler method.  The global error of all Euler methods is of order one, whereas the global error of this method is, similar to the midpoint method , of order two. Additionally, if the acceleration indeed results from the forces in a conservative mechanical or Hamiltonian system , the energy of the approximation essentially oscillates around the constant energy of the exactly solved system, with a global error bound again of order one for semi-explicit Euler and order two for Verlet-leapfrog. The same goes for all other conservered quantities of the system like linear or angular momentum, that are always preserved or nearly preserved in a symplectic integrator . 6  The Velocity Verlet method is a special case of the Newmark-beta method with    β  =  0      β  0    \beta=0   and    γ  =   1  /  2       γ    1  2     \gamma=1/2   .  Error terms  The local error in position of the Verlet integrator is    O   (   Δ   t  4    )       O    normal-Δ   superscript  t  4      O(\Delta t^{4})   as described above, and the local error in velocity is    O   (   Δ   t  2    )       O    normal-Δ   superscript  t  2      O(\Delta t^{2})   .  The global error in position, in contrast, is    O   (   Δ   t  2    )       O    normal-Δ   superscript  t  2      O(\Delta t^{2})   and the global error in velocity is    O   (   Δ   t  2    )       O    normal-Δ   superscript  t  2      O(\Delta t^{2})   . These can be derived by noting the following:       error   (   x   (    t  0   +   Δ  t    )    )    =   O   (   Δ   t  4    )          error    x     subscript  t  0     normal-Δ  t        O    normal-Δ   superscript  t  4       \mathrm{error}\bigl(x(t_{0}+\Delta t)\bigr)=O(\Delta t^{4})     and       x   (    t  0   +   2  Δ  t    )    =     2  x   (    t  0   +   Δ  t    )    -   x   (   t  0   )     +   Δ   t  2    x  ′′    (    t  0   +   Δ  t    )    +   O   (   Δ   t  4    )           x     subscript  t  0     2  normal-Δ  t           2  x     subscript  t  0     normal-Δ  t       x   subscript  t  0       normal-Δ   superscript  t  2    superscript  x  ′′      subscript  t  0     normal-Δ  t       O    normal-Δ   superscript  t  4        x(t_{0}+2\Delta t)=2x(t_{0}+\Delta t)-x(t_{0})+\Delta t^{2}x^{\prime\prime}(t_%
 {0}+\Delta t)+O(\Delta t^{4})\,     Therefore:       error   (   x   (    t  0   +   2  Δ  t    )    )    =    2  e  r  r  o  r   (   x   (    t  0   +   Δ  t    )    )    +   O   (   Δ   t  4    )     =    3   O   (   Δ   t  4    )            error    x     subscript  t  0     2  normal-Δ  t          2  normal-e  normal-r  normal-r  normal-o  normal-r    x     subscript  t  0     normal-Δ  t        O    normal-Δ   superscript  t  4             3  O    normal-Δ   superscript  t  4        \mathrm{error}\bigl(x(t_{0}+2\Delta t)\bigr)=2\mathrm{error}\bigl(x(t_{0}+%
 \Delta t)\bigr)+O(\Delta t^{4})=3\,O(\Delta t^{4})     Similarly:      error   (  x   (   t  0   +  3  Δ  t  )    )  =   6   O   (  Δ   t  4   )        fragments  error   fragments  normal-(  x   fragments  normal-(   subscript  t  0    3  Δ  t  normal-)    fragments  normal-)   6  O   fragments  normal-(  Δ   superscript  t  4   normal-)       \mathrm{error}\bigl(x(t_{0}+3\Delta t)\bigl)=6\,O(\Delta t^{4})         error   (  x   (   t  0   +  4  Δ  t  )    )  =   10   O   (  Δ   t  4   )        fragments  error   fragments  normal-(  x   fragments  normal-(   subscript  t  0    4  Δ  t  normal-)    fragments  normal-)   10  O   fragments  normal-(  Δ   superscript  t  4   normal-)       \mathrm{error}\bigl(x(t_{0}+4\Delta t)\bigl)=10\,O(\Delta t^{4})         error   (  x   (   t  0   +  5  Δ  t  )    )  =   15   O   (  Δ   t  4   )        fragments  error   fragments  normal-(  x   fragments  normal-(   subscript  t  0    5  Δ  t  normal-)    fragments  normal-)   15  O   fragments  normal-(  Δ   superscript  t  4   normal-)       \mathrm{error}\bigl(x(t_{0}+5\Delta t)\bigl)=15\,O(\Delta t^{4})     Which can be generalized to (it can be shown by induction, but it is given here without proof):       error   (   x   (    t  0   +   n  Δ  t    )    )    =      n   (   n  +  1   )    2    O   (   Δ   t  4    )          error    x     subscript  t  0     n  normal-Δ  t            n    n  1    2   O    normal-Δ   superscript  t  4       \mathrm{error}\bigl(x(t_{0}+n\Delta t)\bigr)=\frac{n(n+1)}{2}\,O(\Delta t^{4})     If we consider the global error in position between    x   (  t  )       x  t    x(t)   and    x   (   t  +  T   )       x    t  T     x(t+T)   , where    T  =   n  Δ  t       T    n  normal-Δ  t     T=n\Delta t   , it is clear that:       error   (   x   (    t  0   +  T   )    )    =    (     T  2    2  Δ   t  2     +   T   2  Δ  t     )   O   (   Δ   t  4    )          error    x     subscript  t  0   T            superscript  T  2     2  normal-Δ   superscript  t  2       T    2  normal-Δ  t     O    normal-Δ   superscript  t  4       \mathrm{error}\bigl(x(t_{0}+T)\bigr)=\left(\frac{T^{2}}{2\Delta t^{2}}+\frac{T%
 }{2\Delta t}\right)O(\Delta t^{4})     And therefore, the global (cumulative) error over a constant interval of time is given by:      error  (  x  (   t  0   +  T  )  )  =  O   (  Δ   t  2   )      fragments  error  normal-(  x  normal-(   subscript  t  0    T  normal-)  normal-)   O   fragments  normal-(  Δ   superscript  t  2   normal-)     \mathrm{error}\bigr(x(t_{0}+T)\bigl)=O(\Delta t^{2})     Because the velocity is determined in a non-cumulative way from the positions in the Verlet integrator, the global error in velocity is also    O   (   Δ   t  2    )       O    normal-Δ   superscript  t  2      O(\Delta t^{2})   .  In molecular dynamics simulations, the global error is typically far more important than the local error, and the Verlet integrator is therefore known as a second-order integrator.  Constraints  The most notable thing that is now easier due to using Verlet integration rather than Eulerian is that constraints between particles are very easy to do. A constraint is a connection between multiple points that limits them in some way, perhaps setting them at a specific distance or keeping them apart, or making sure they are closer than a specific distance. Often physics systems use springs between the points in order to keep them in the locations they are supposed to be. However, using springs of infinite stiffness between two points usually gives the best results coupled with the verlet algorithm. Here's how:       d  1   =    x  2   (  t  )    -    x  1   (  t  )           subscript  d  1      superscript   subscript  x  2   t    superscript   subscript  x  1   t      d_{1}=x_{2}^{(t)}-x_{1}^{(t)}\,          d  2   =   ∥   d  1   ∥        subscript  d  2    norm   subscript  d  1      d_{2}=\|d_{1}\|\,          d  3   =      d  2   -  r    d  2          subscript  d  3        subscript  d  2   r    subscript  d  2      d_{3}=\frac{d_{2}-r}{d_{2}}\,          x  1   (   t  +   Δ  t    )    =     x  ~   1   (   t  +   Δ  t    )    +    1  2    d  1     d  3           superscript   subscript  x  1     t    normal-Δ  t        superscript   subscript   normal-~  x   1     t    normal-Δ  t         1  2    subscript  d  1    subscript  d  3       x_{1}^{(t+\Delta t)}=\tilde{x}_{1}^{(t+\Delta t)}+\frac{1}{2}d_{1}d_{3}\,          x  2   (   t  +   Δ  t    )    =     x  ~   2   (   t  +   Δ  t    )    -    1  2    d  1     d  3           superscript   subscript  x  2     t    normal-Δ  t        superscript   subscript   normal-~  x   2     t    normal-Δ  t         1  2    subscript  d  1    subscript  d  3       x_{2}^{(t+\Delta t)}=\tilde{x}_{2}^{(t+\Delta t)}-\frac{1}{2}d_{1}d_{3}\,     The    x  i   (  t  )      superscript   subscript  x  i   t    x_{i}^{(t)}   variables are the positions of the points i at time t , the     x  ~   i   (  t  )      superscript   subscript   normal-~  x   i   t    \tilde{x}_{i}^{(t)}   are the unconstrained positions ( i.e. the point positions before applying the constraints) of the points i at time t , the d variables are temporary (they are added for optimization as the results of their expressions are needed multiple times), and r is the distance that is supposed to be between the two points. Currently this is in one dimension; however, it is easily expanded to two or three. Simply find the delta (first equation) of each dimension, and then add the deltas squared to the inside of the square root of the second equation ( Pythagorean theorem ). Then, duplicate the last two equations for the number of dimensions there are. This is where verlet makes constraints simple – instead of say, applying a velocity to the points that would eventually satisfy the constraint, you can simply position the point where it should be and the verlet integrator takes care of the rest.  Problems, however, arise when multiple constraints position a vertex. One way to solve this is to loop through all the vertices in a simulation in a criss cross manner, so that at every vertex the constraint relaxation of the last vertex is already used to speed up the spread of the information. Either use fine time steps for the simulation, use a fixed number of constraint solving steps per time step, or solve constraints until they are met by a specific deviation.  When approximating the constraints locally to first order this is the same as the Gauss–Seidel method . For small matrices it is known that LU decomposition is faster. Large systems can be divided into clusters (for example: each ragdoll = cluster). Inside clusters the LU method is used, between clusters the Gauss–Seidel method is used. The matrix code can be reused: The dependency of the forces on the positions can be approximated locally to first order, and the verlet integration can be made more implicit.  For big matrices sophisticated solvers (look especially for "The sizes of these small dense matrices can be tuned to match the sweet spot" in 1 ) for sparse matrices exist, any self made Verlet integration has to compete with these. The usage of (clusters of) matrices is not generally more precise or stable, but addresses the specific problem, that a force on one vertex of a sheet of cloth should reach any other vertex in a low number of time steps even if a fine grid is used for the cloth 2 (link needs refinement) and not form a sound wave .  Another way to solve holonomic constraints is to use constraint algorithms .  Collision reactions  One way of reacting to collisions is to use a penalty-based system which basically applies a set force to a point upon contact. The problem with this is that it is very difficult to choose the force imparted. Use too strong a force and objects will become unstable, too weak and the objects will penetrate each other. Another way is to use projection collision reactions which takes the offending point and attempts to move it the shortest distance possible to move it out of the other object.  The Verlet integration would automatically handle the velocity imparted via the collision in the latter case, however note that this is not guaranteed to do so in a way that is consistent with collision physics (that is, changes in momentum are not guaranteed to be realistic). Instead of implicitly changing the velocity term, one would need to explicitly control the final velocities of the objects colliding (by changing the recorded position from the previous time step).  The two simplest methods for deciding on a new velocity are perfectly elastic collisions and inelastic collisions . A slightly more complicated strategy that offers more control would involve using the coefficient of restitution .  See also   Courant–Friedrichs–Lewy condition  Energy drift  Symplectic integrator  Leapfrog integration  Beeman's algorithm   Literature   7  8   External links   Verlet Integration Demo and Code as a Java Applet  Advanced Character Physics by Thomas Jakobsen  The Verlet algorithm  Theory of Molecular Dynamics Simulations – bottom of page   "  Category:Numerical differential equations      ↩  webpage with a description of the Störmer method ↩  ↩  ↩   ↩  ↩     