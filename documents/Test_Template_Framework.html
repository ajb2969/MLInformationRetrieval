<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1945">Test Template Framework</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Test Template Framework</h1>
<hr/>

<p>The <strong>Test Template Framework</strong> (<strong>TTF</strong>) is a <a href="model-based_testing" title="wikilink">model-based testing</a> (MBT) framework proposed by Phil Stocks and David Carrington in  for the purpose of <a href="software_testing" title="wikilink">software testing</a>. Although the TTF was meant to be notation-independent, the original presentation was made using the <a href="Z_notation" title="wikilink">Z formal notation</a>. It is one of the few MBT frameworks approaching <a href="unit_testing" title="wikilink">unit testing</a>.</p>
<h2 id="introduction">Introduction</h2>

<p>The TTF is a specific proposal of <a href="model-based_testing" title="wikilink">model-based testing</a> (MBT). It considers models to be <a href="Z_notation" title="wikilink">Z specifications</a>. Each operation within the specification is analyzed to derive or generate <a href="#Abstract_test_case" title="wikilink"><em>abstract test cases</em></a>. This analysis consists of the following steps:</p>
<ol>
<li>Define the <a href="#Input_space" title="wikilink"><em>input space</em></a> (IS) of each operation.</li>
<li>Derive the <a href="#Valid_input_space" title="wikilink"><em>valid input space</em></a> (VIS) from the <a href="#Input_space" title="wikilink">IS</a> of each operation.</li>
<li>Apply one or more <a href="#Testing_tactic" title="wikilink"><em>testing tactics</em></a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> starting from each <a href="#Valid_input_space" title="wikilink">VIS</a>, to build a <a href="#Testing_tree" title="wikilink"><em>testing tree</em></a> for each operation. Testing trees are populated with nodes called <a href="#Test_class" title="wikilink"><em>test classes</em></a>.</li>
<li><a href="#Pruning_testing_trees" title="wikilink"><em>Prune</em></a> each of the resulting <a href="#Testing_tree" title="wikilink">testing trees</a>.</li>
<li>Find one or more <a href="#Abstract_test_case" title="wikilink"><em>abstract test cases</em></a> from each leaf in each <a href="#Testing_tree" title="wikilink">testing tree</a>.</li>
</ol>

<p>One of the main advantages of the TTF is that all of these concepts are expressed in the same notation of the specification, i.e. the <a href="Z_notation" title="wikilink">Z notation</a>. Hence, the engineer has to know only one notation to perform the analysis down to the generation of <a href="#Abstract_test_case" title="wikilink">abstract test cases</a>.</p>
<h2 id="important-concepts">Important concepts</h2>

<p>In this section the main concepts defined by the TTF are described.</p>
<h3 id="input-space">Input space</h3>

<p>Let 

<math display="inline" id="Test_Template_Framework:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

 be a Z operation. Let 

<math display="inline" id="Test_Template_Framework:1">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\dots x_{n}
  </annotation>
 </semantics>
</math>

 be all the input and (non-primed) state variables referenced in 

<math display="inline" id="Test_Template_Framework:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Test_Template_Framework:3">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>T</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}\dots T_{n}
  </annotation>
 </semantics>
</math>

 their corresponding types. The <em>Input Space</em> (IS) of 

<math display="inline" id="Test_Template_Framework:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

, written 

<math display="inline" id="Test_Template_Framework:5">
 <semantics>
  <mrow>
   <mi>I</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>O</mi>
     <mi>p</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IS_{Op}
  </annotation>
 </semantics>
</math>

, is the Z schema box defined by 

<math display="inline" id="Test_Template_Framework:6">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <mrow>
     <msub>
      <mi>T</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>:</mo>
    <msub>
     <mi>T</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <and></and>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x_{1}:T_{1}\dots x_{n}:T_{n}]
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="valid-input-space">Valid input space</h3>

<p>Let 

<math display="inline" id="Test_Template_Framework:7">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

 be a Z operation. Let 

<math display="inline" id="Test_Template_Framework:8">
 <semantics>
  <mrow>
   <mtext>pre</mtext>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>pre</mtext>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{pre }Op
  </annotation>
 </semantics>
</math>

 be the <a class="uri" href="precondition" title="wikilink">precondition</a> of 

<math display="inline" id="Test_Template_Framework:9">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

. The <em>Valid Input Space</em> (VIS) of 

<math display="inline" id="Test_Template_Framework:10">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

, written 

<math display="inline" id="Test_Template_Framework:11">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi>I</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>O</mi>
     <mi>p</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VIS_{Op}
  </annotation>
 </semantics>
</math>

, is the Z schema box defined by 

<math display="inline" id="Test_Template_Framework:12">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>I</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>O</mi>
     <mi>p</mi>
    </mrow>
   </msub>
   <mo stretchy="false">|</mo>
   <mtext>pre</mtext>
   <mi>O</mi>
   <mi>p</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-[</ci>
    <csymbol cd="unknown">I</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <mtext>pre</mtext>
    <csymbol cd="unknown">O</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [IS_{Op}|\text{pre }Op]
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="test-class">Test class</h3>

<p>Let 

<math display="inline" id="Test_Template_Framework:13">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

 be a Z operation and let 

<math display="inline" id="Test_Template_Framework:14">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 be any <a href="Predicate_(mathematical_logic)" title="wikilink">predicate</a> depending on one or more of the variables defined in 

<math display="inline" id="Test_Template_Framework:15">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi>I</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>O</mi>
     <mi>p</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VIS_{Op}
  </annotation>
 </semantics>
</math>

. Then, the Z schema box 

<math display="inline" id="Test_Template_Framework:16">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>V</mi>
   <mi>I</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>O</mi>
     <mi>p</mi>
    </mrow>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>P</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-[</ci>
    <csymbol cd="unknown">V</csymbol>
    <csymbol cd="unknown">I</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [VIS_{Op}|P]
  </annotation>
 </semantics>
</math>

 is a <em>test class</em> of 

<math display="inline" id="Test_Template_Framework:17">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

. Note that this schema is equivalent to 

<math display="inline" id="Test_Template_Framework:18">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>I</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>O</mi>
     <mi>p</mi>
    </mrow>
   </msub>
   <mo stretchy="false">|</mo>
   <mtext>pre</mtext>
   <mi>O</mi>
   <mi>p</mi>
   <mo>∧</mo>
   <mi>P</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-[</ci>
    <csymbol cd="unknown">I</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <mtext>pre</mtext>
    <csymbol cd="unknown">O</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <and></and>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [IS_{Op}|\text{pre }Op\land P]
  </annotation>
 </semantics>
</math>

. This observation can be generalized by saying that if 

<math display="inline" id="Test_Template_Framework:19">
 <semantics>
  <msub>
   <mi>C</mi>
   <mrow>
    <mi>O</mi>
    <mi>p</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{Op}
  </annotation>
 </semantics>
</math>

 is a test class of 

<math display="inline" id="Test_Template_Framework:20">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

, then the Z schema box defined by 

<math display="inline" id="Test_Template_Framework:21">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>O</mi>
     <mi>p</mi>
    </mrow>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>P</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-[</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [C_{Op}|P]
  </annotation>
 </semantics>
</math>

 is also a test class of 

<math display="inline" id="Test_Template_Framework:22">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

. According to this definition the VIS is also a test class.</p>

<p>If 

<math display="inline" id="Test_Template_Framework:23">
 <semantics>
  <msub>
   <mi>C</mi>
   <mrow>
    <mi>O</mi>
    <mi>p</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{Op}
  </annotation>
 </semantics>
</math>

 is a test class of 

<math display="inline" id="Test_Template_Framework:24">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

, then the predicate 

<math display="inline" id="Test_Template_Framework:25">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Test_Template_Framework:26">
 <semantics>
  <mrow>
   <msubsup>
    <mi>C</mi>
    <mrow>
     <mi>O</mi>
     <mi>p</mi>
    </mrow>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>O</mi>
      <mi>p</mi>
     </mrow>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>P</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <eq></eq>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>O</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\prime}_{Op}==[C_{Op}|P]
  </annotation>
 </semantics>
</math>

 is said to be the <em>characteristic</em> predicate of 

<math display="inline" id="Test_Template_Framework:27">
 <semantics>
  <msubsup>
   <mi>C</mi>
   <mrow>
    <mi>O</mi>
    <mi>p</mi>
   </mrow>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>C</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\prime}_{Op}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Test_Template_Framework:28">
 <semantics>
  <msubsup>
   <mi>C</mi>
   <mrow>
    <mi>O</mi>
    <mi>p</mi>
   </mrow>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>C</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\prime}_{Op}
  </annotation>
 </semantics>
</math>

 is <em>characterized</em> by 

<math display="inline" id="Test_Template_Framework:29">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</p>

<p>Test classes are also called test objectives , test templates  and test specifications.</p>
<h3 id="testing-tactic">Testing tactic</h3>

<p>In the context of the TTF a <em>testing tactic</em><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is a means to <a href="Partition_of_a_set" title="wikilink">partition</a> any <a href="#Test_class" title="wikilink">test class</a> of any operation. However, some of the testing tactics used in practice actually do not always generate a partition of some test classes.</p>

<p>Some testing tactics originally proposed for the TTF are the following:</p>
<ul>
<li><a href="Disjunctive_Normal_Form" title="wikilink">Disjunctive Normal Form</a> (DNF). By applying this tactic the operation is written in <a href="Disjunctive_Normal_Form" title="wikilink">Disjunctive Normal Form</a> and the <a href="#Test_class" title="wikilink">test class</a> is divided in as many test classes as terms are in the resulting operation's predicate. The predicate added to each new test class is the <a class="uri" href="precondition" title="wikilink">precondition</a> of one of the terms in the operation's predicate.</li>
</ul>
<ul>
<li>Standard Partitions (SP). This tactic uses a predefined partition of some mathematical operator . For example, the following is a good partition for expressions of the form 

<math display="inline" id="Test_Template_Framework:30">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi mathvariant="normal">♠</mi>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>normal-♠</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\spadesuit T
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Test_Template_Framework:31">
 <semantics>
  <mi mathvariant="normal">♠</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-♠</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \spadesuit
  </annotation>
 </semantics>
</math>

 is one of 

<math display="inline" id="Test_Template_Framework:32">
 <semantics>
  <mo>∪</mo>
  <annotation-xml encoding="MathML-Content">
   <union></union>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cup
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Test_Template_Framework:33">
 <semantics>
  <mo>∩</mo>
  <annotation-xml encoding="MathML-Content">
   <intersect></intersect>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cap
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Test_Template_Framework:34">
 <semantics>
  <mo>∖</mo>
  <annotation-xml encoding="MathML-Content">
   <setdiff></setdiff>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \setminus
  </annotation>
 </semantics>
</math>

 (see <a href="Set_theory" title="wikilink">Set theory</a>).</li>
</ul>
<center>

<p>

<math display="inline" id="Test_Template_Framework:35">
 <semantics>
  <mtable>
   <mtr>
    <mtd class="ltx_border_r" columnalign="left">
     <mrow>
      <mrow>
       <mi>S</mi>
       <mo>=</mo>
       <mi mathvariant="normal">∅</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>T</mi>
       <mo>=</mo>
       <mi mathvariant="normal">∅</mi>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>S</mi>
       <mo>≠</mo>
       <mi mathvariant="normal">∅</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mrow>
        <mi>T</mi>
        <mo>≠</mo>
        <mi mathvariant="normal">∅</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>S</mi>
        <mo>⊂</mo>
        <mi>T</mi>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd class="ltx_border_r ltx_border_t" columnalign="left">
     <mrow>
      <mrow>
       <mi>S</mi>
       <mo>=</mo>
       <mi mathvariant="normal">∅</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>T</mi>
       <mo>≠</mo>
       <mi mathvariant="normal">∅</mi>
      </mrow>
     </mrow>
    </mtd>
    <mtd class="ltx_border_t" columnalign="left">
     <mrow>
      <mrow>
       <mi>S</mi>
       <mo>≠</mo>
       <mi mathvariant="normal">∅</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mrow>
        <mi>T</mi>
        <mo>≠</mo>
        <mi mathvariant="normal">∅</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>T</mi>
        <mo>⊂</mo>
        <mi>S</mi>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd class="ltx_border_r ltx_border_t" columnalign="left">
     <mrow>
      <mrow>
       <mi>S</mi>
       <mo>≠</mo>
       <mi mathvariant="normal">∅</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>T</mi>
       <mo>=</mo>
       <mi mathvariant="normal">∅</mi>
      </mrow>
     </mrow>
    </mtd>
    <mtd class="ltx_border_t" columnalign="left">
     <mrow>
      <mrow>
       <mi>S</mi>
       <mo>≠</mo>
       <mi mathvariant="normal">∅</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mrow>
        <mi>T</mi>
        <mo>≠</mo>
        <mi mathvariant="normal">∅</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>T</mi>
        <mo>=</mo>
        <mi>S</mi>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd class="ltx_border_r ltx_border_t" columnalign="left">
     <mrow>
      <mrow>
       <mi>S</mi>
       <mo>≠</mo>
       <mi mathvariant="normal">∅</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mrow>
        <mi>T</mi>
        <mo>≠</mo>
        <mi mathvariant="normal">∅</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mrow>
         <mi>S</mi>
         <mo>∩</mo>
         <mi>T</mi>
        </mrow>
        <mo>=</mo>
        <mi mathvariant="normal">∅</mi>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
    <mtd class="ltx_border_t" columnalign="left">
     <mrow>
      <mrow>
       <mi>S</mi>
       <mo>≠</mo>
       <mi mathvariant="normal">∅</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mrow>
        <mi>T</mi>
        <mo>≠</mo>
        <mi mathvariant="normal">∅</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mrow>
         <mrow>
          <mi>S</mi>
          <mo>∩</mo>
          <mi>T</mi>
         </mrow>
         <mo>≠</mo>
         <mrow>
          <mi mathvariant="normal">∅</mi>
          <mo>,</mo>
          <mrow>
           <mi mathvariant="normal">¬</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>S</mi>
             <mo>⊆</mo>
             <mi>T</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi mathvariant="normal">¬</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>T</mi>
             <mo>⊆</mo>
             <mi>S</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>S</mi>
         <mo>≠</mo>
         <mi>T</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <ci>S</ci>
       <emptyset></emptyset>
      </apply>
      <apply>
       <eq></eq>
       <ci>T</ci>
       <emptyset></emptyset>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <neq></neq>
       <ci>S</ci>
       <emptyset></emptyset>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <neq></neq>
        <ci>T</ci>
        <emptyset></emptyset>
       </apply>
       <apply>
        <subset></subset>
        <ci>S</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <ci>S</ci>
       <emptyset></emptyset>
      </apply>
      <apply>
       <neq></neq>
       <ci>T</ci>
       <emptyset></emptyset>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <neq></neq>
       <ci>S</ci>
       <emptyset></emptyset>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <neq></neq>
        <ci>T</ci>
        <emptyset></emptyset>
       </apply>
       <apply>
        <subset></subset>
        <ci>T</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <neq></neq>
       <ci>S</ci>
       <emptyset></emptyset>
      </apply>
      <apply>
       <eq></eq>
       <ci>T</ci>
       <emptyset></emptyset>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <neq></neq>
       <ci>S</ci>
       <emptyset></emptyset>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <neq></neq>
        <ci>T</ci>
        <emptyset></emptyset>
       </apply>
       <apply>
        <eq></eq>
        <ci>T</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <neq></neq>
       <ci>S</ci>
       <emptyset></emptyset>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <neq></neq>
        <ci>T</ci>
        <emptyset></emptyset>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <intersect></intersect>
         <ci>S</ci>
         <ci>T</ci>
        </apply>
        <emptyset></emptyset>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <neq></neq>
       <ci>S</ci>
       <emptyset></emptyset>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <neq></neq>
        <ci>T</ci>
        <emptyset></emptyset>
       </apply>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <neq></neq>
         <apply>
          <intersect></intersect>
          <ci>S</ci>
          <ci>T</ci>
         </apply>
         <list>
          <emptyset></emptyset>
          <apply>
           <not></not>
           <apply>
            <subset></subset>
            <ci>S</ci>
            <ci>T</ci>
           </apply>
          </apply>
          <apply>
           <not></not>
           <apply>
            <subset></subset>
            <ci>T</ci>
            <ci>S</ci>
           </apply>
          </apply>
         </list>
        </apply>
        <apply>
         <neq></neq>
         <ci>S</ci>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{l|l}S=\emptyset,T=\emptyset&S\neq\emptyset,T\neq\emptyset,S%
\subset T\\
\hline S=\emptyset,T\neq\emptyset&S\neq\emptyset,T\neq\emptyset,T\subset S\\
\hline S\neq\emptyset,T=\emptyset&S\neq\emptyset,T\neq\emptyset,T=S\\
\hline S\neq\emptyset,T\neq\emptyset,S\cap T=\emptyset&S\neq\emptyset,T\neq%
\emptyset,S\cap T\neq\emptyset,\lnot(S\subseteq T),\lnot(T\subseteq S),S\neq T%
\end{array}
  </annotation>
 </semantics>
</math>

</p>
</center>
<dl>
<dd>As can be noticed, standard partitions might change according to how much testing the engineer wants to perform.
</dd>
</dl>
<ul>
<li>Sub-domain Propagation (SDP). This tactic is applied to expressions containing:</li>
</ul>
<ol>
<li>Two or more mathematical operators for which there are already defined standard partitions, or</li>
<li>Mathematical operators which are defined in terms of other mathematical operators.</li>
</ol>
<dl>
<dd>In any of these cases, the standard partitions of the operators appearing in the expression or in the definition of a complex one, are combined to produce a partition for the expression. If the tactic is applied to the second case, then the resulting partition can be considered as the standard partition for that operator. Stocks and Carrington in  illustrate this situation with 

<math display="inline" id="Test_Template_Framework:36">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>⊕</mo>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>dom</mtext>
    <mi>G</mi>
    <mo>⋪</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∪</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <csymbol cd="latexml">direct-sum</csymbol>
    <csymbol cd="unknown">G</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>dom</mtext>
     <csymbol cd="unknown">G</csymbol>
     <csymbol cd="latexml">not-subgroup-of</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <union></union>
    <csymbol cd="unknown">G</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\oplus G=(\text{dom }G\ntriangleleft R)\cup G
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Test_Template_Framework:37">
 <semantics>
  <mo>⋪</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">not-subgroup-of</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ntriangleleft
  </annotation>
 </semantics>
</math>

 means <a href="Restriction_(mathematics)" title="wikilink">domain anti-restriction</a>, by giving standard partitions for 

<math display="inline" id="Test_Template_Framework:38">
 <semantics>
  <mo>⋪</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">not-subgroup-of</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ntriangleleft
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Test_Template_Framework:39">
 <semantics>
  <mo>∪</mo>
  <annotation-xml encoding="MathML-Content">
   <union></union>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cup
  </annotation>
 </semantics>
</math>

 and propagating them to calculate a partition for 

<math display="inline" id="Test_Template_Framework:40">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<ul>
<li>Specification Mutation (SM). The first step of this tactic consists in generating a <em>mutant</em> of the Z operation. A mutant of a Z operation is similar in concept to a <a href="Mutation_testing" title="wikilink">mutant of a program</a>, i.e. it is a modified version of the operation. The modification is introduced by the engineer with the intention of uncovering an error in the implementation. The mutant should be the specification that the engineer guesses the programmer has implemented. Then, the engineer has to calculate the subset of the VIS that yields different results in both specifications. The predicate of this set is used to derive a new test class.</li>
</ul>

<p>Some other testing tactics that may also be used are the following:</p>
<ul>
<li>In Set Extension (ISE). It applies to predicates of the form 

<math display="inline" id="Test_Template_Framework:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mi>r</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>e</mi>
     <mi>x</mi>
     <mi>p</mi>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>e</mi>
     <mi>x</mi>
     <mi>p</mi>
     <msub>
      <mi>r</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <ci>r</ci>
    </apply>
    <set>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   expr\in\{expr_{1},\dots,expr_{n}\}
  </annotation>
 </semantics>
</math>

. In this case, it generates 

<math display="inline" id="Test_Template_Framework:42">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 test classes such that a predicate of the form 

<math display="inline" id="Test_Template_Framework:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mi>r</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   expr=expr_{i}
  </annotation>
 </semantics>
</math>

 is added to each of them.</li>
</ul>
<ul>
<li>Mandatory Test Set (MTS). This tactic associates a set of constant values to a VIS' variable and generates as many test classes as elements are in the set. Each test class is characterized by a predicate of the form 

<math display="inline" id="Test_Template_Framework:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mi>a</mi>
    <mi>r</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>v</mi>
    <mi>a</mi>
    <mi>l</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>a</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>a</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   var=val
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Test_Template_Framework:45">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mi>a</mi>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <ci>a</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   var
  </annotation>
 </semantics>
</math>

 is the name of the variable and 

<math display="inline" id="Test_Template_Framework:46">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mi>a</mi>
   <mi>l</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <ci>a</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   val
  </annotation>
 </semantics>
</math>

 is one of the values of the set.</li>
</ul>
<ul>
<li>Numeric Ranges (NR). This tactic applies only to VIS' variables of type 

<math display="inline" id="Test_Template_Framework:47">
 <semantics>
  <mi>ℤ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℤ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}
  </annotation>
 </semantics>
</math>

 (or its "subtype" 

<math display="inline" id="Test_Template_Framework:48">
 <semantics>
  <mi>ℕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

). It consists in associating a range to a variable and deriving test classes by comparing the variable with the limits of the range in some ways. More formally, let 

<math display="inline" id="Test_Template_Framework:49">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 be a variable of type 

<math display="inline" id="Test_Template_Framework:50">
 <semantics>
  <mi>ℤ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℤ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Test_Template_Framework:51">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <ci>i</ci>
    <ci>j</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [i,j]
  </annotation>
 </semantics>
</math>

 be the associated range. Then, the tactic generates the test classes characterized by the following predicates

<math display="inline" id="Test_Template_Framework:52">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>j
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Test_Template_Framework:53">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>O</mi>
   <mi>L</mi>
   <mi>O</mi>
   <mi>U</mi>
   <mi>R</mi>
   <mo>:</mo>
   <mo>:=</mo>
   <mi>r</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mo stretchy="false">|</mo>
   <mi>b</mi>
   <mi>l</mi>
   <mi>u</mi>
   <mi>e</mi>
   <mo stretchy="false">|</mo>
   <mi>g</mi>
   <mi>r</mi>
   <mi>e</mi>
   <mi>e</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">O</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <csymbol cd="unknown">O</csymbol>
    <csymbol cd="unknown">U</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <csymbol cd="unknown">u</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">g</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">n</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   COLOUR::=red|blue|green
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Test_Template_Framework:54">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>Free Type (FT). This tactic generates as many test classes as elements a free (enumerated) type has. In other words, if a model defines type 

<math display="inline" id="Test_Template_Framework:55">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>O</mi>
   <mi>L</mi>
   <mi>O</mi>
   <mi>U</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>O</ci>
    <ci>L</ci>
    <ci>O</ci>
    <ci>U</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   COLOUR
  </annotation>
 </semantics>
</math>

 and some operation uses 

<math display="inline" id="Test_Template_Framework:56">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 of type 

<math display="inline" id="Test_Template_Framework:57">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mi>e</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>e</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   red
  </annotation>
 </semantics>
</math>

, then by applying this tactic each test class will by divided into three new test classes: one in which 

<math display="inline" id="Test_Template_Framework:58">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 equals 

<math display="inline" id="Test_Template_Framework:59">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mi>l</mi>
   <mi>u</mi>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <ci>l</ci>
    <ci>u</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   blue
  </annotation>
 </semantics>
</math>

, the other in which 

<math display="inline" id="Test_Template_Framework:60">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 equals 

<math display="inline" id="Test_Template_Framework:61">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mi>r</mi>
   <mi>e</mi>
   <mi>e</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>r</ci>
    <ci>e</ci>
    <ci>e</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   green
  </annotation>
 </semantics>
</math>

, and the third where 

<math display="inline" id="Test_Template_Framework:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mi>r</mi>
   </mrow>
   <mo>⊂</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>e</mi>
     <mi>x</mi>
     <mi>p</mi>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>e</mi>
     <mi>x</mi>
     <mi>p</mi>
     <msub>
      <mi>r</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <ci>r</ci>
    </apply>
    <set>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   expr\subset\{expr_{1},\dots,expr_{n}\}
  </annotation>
 </semantics>
</math>

 equals 

<math display="inline" id="Test_Template_Framework:63">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}-1
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>Proper Subset of Set Extension (PSSE). This tactic uses the same concept of ISE but applied to set inclusions. PSSE helps to test operations including predicates like 

<math display="inline" id="Test_Template_Framework:64">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mi>r</mi>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   expr=A_{i}
  </annotation>
 </semantics>
</math>

. When PSSE is applied it generates 

<math display="inline" id="Test_Template_Framework:65">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <interval closure="closed">
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in[1,2^{n}-1]
  </annotation>
 </semantics>
</math>

 test classes where a predicate of the form 

<math display="inline" id="Test_Template_Framework:66">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mi>ℙ</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>e</mi>
       <mi>x</mi>
       <mi>p</mi>
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mrow>
       <mi>e</mi>
       <mi>x</mi>
       <mi>p</mi>
       <msub>
        <mi>r</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>∖</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>e</mi>
       <mi>x</mi>
       <mi>p</mi>
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mrow>
       <mi>e</mi>
       <mi>x</mi>
       <mi>p</mi>
       <msub>
        <mi>r</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <setdiff></setdiff>
     <apply>
      <times></times>
      <ci>ℙ</ci>
      <set>
       <apply>
        <times></times>
        <ci>e</ci>
        <ci>x</ci>
        <ci>p</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <ci>e</ci>
        <ci>x</ci>
        <ci>p</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </set>
     </apply>
     <set>
      <set>
       <apply>
        <times></times>
        <ci>e</ci>
        <ci>x</ci>
        <ci>p</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <ci>e</ci>
        <ci>x</ci>
        <ci>p</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </set>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}\in\mathbb{P}\{expr_{1},\dots,expr_{n}\}\setminus\{\{expr_{1},\dots,expr_%
{n}\}\}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Test_Template_Framework:67">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <msub>
     <mi>r</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{expr_{1},\dots,expr_{n}\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Test_Template_Framework:68">
 <semantics>
  <mrow>
   <mi>ℙ</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>e</mi>
     <mi>x</mi>
     <mi>p</mi>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>e</mi>
     <mi>x</mi>
     <mi>p</mi>
     <msub>
      <mi>r</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℙ</ci>
    <set>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{P}\{expr_{1},\dots,expr_{n}\}
  </annotation>
 </semantics>
</math>

, is added to each class. 

<math display="inline" id="Test_Template_Framework:69">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>x</ci>
    <ci>p</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   expr
  </annotation>
 </semantics>
</math>

 is excluded from 

<math display="inline" id="Test_Template_Framework:70">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <msub>
     <mi>r</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{expr_{1},\dots,expr_{n}\}
  </annotation>
 </semantics>
</math>

 because 

<math display="inline" id="Test_Template_Framework:71">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mi>r</mi>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>e</mi>
     <mi>x</mi>
     <mi>p</mi>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>e</mi>
     <mi>x</mi>
     <mi>p</mi>
     <msub>
      <mi>r</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <ci>r</ci>
    </apply>
    <set>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   expr\subseteq\{expr_{1},\dots,expr_{n}\}
  </annotation>
 </semantics>
</math>

 is a proper subset of 

<math display="inline" id="Test_Template_Framework:72">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>Subset of Set Extension (SSE). It is identical to PSSE but it applies to predicates of the form 

<math display="inline" id="Test_Template_Framework:73">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <msub>
     <mi>r</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{expr_{1},\dots,expr_{n}\}
  </annotation>
 </semantics>
</math>

 in which case it generates 

<math display="inline" id="Test_Template_Framework:74">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>V</mi>
      <mi>I</mi>
      <mi>S</mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>=</mo>
      <mo>=</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>I</mi>
       <mi>S</mi>
       <mo stretchy="false">|</mo>
       <mi>P</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>T</mi>
      <mi>C</mi>
      <msubsup>
       <mi>L</mi>
       <msub>
        <mi>T</mi>
        <mn>1</mn>
       </msub>
       <mn>1</mn>
      </msubsup>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>=</mo>
      <mo>=</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>V</mi>
       <mi>I</mi>
       <mi>S</mi>
       <mo stretchy="false">|</mo>
       <msubsup>
        <mi>P</mi>
        <msub>
         <mi>T</mi>
         <mn>1</mn>
        </msub>
        <mn>1</mn>
       </msubsup>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mi mathvariant="normal">…</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>T</mi>
      <mi>C</mi>
      <msubsup>
       <mi>L</mi>
       <msub>
        <mi>T</mi>
        <mn>1</mn>
       </msub>
       <mi>n</mi>
      </msubsup>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>=</mo>
      <mo>=</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>V</mi>
       <mi>I</mi>
       <mi>S</mi>
       <mo stretchy="false">|</mo>
       <msubsup>
        <mi>P</mi>
        <msub>
         <mi>T</mi>
         <mn>1</mn>
        </msub>
        <mi>n</mi>
       </msubsup>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>T</mi>
      <mi>C</mi>
      <msubsup>
       <mi>L</mi>
       <msub>
        <mi>T</mi>
        <mn>2</mn>
       </msub>
       <mn>1</mn>
      </msubsup>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>=</mo>
      <mo>=</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>T</mi>
       <mi>C</mi>
       <msubsup>
        <mi>L</mi>
        <msub>
         <mi>T</mi>
         <mn>1</mn>
        </msub>
        <mi>i</mi>
       </msubsup>
       <mo stretchy="false">|</mo>
       <msubsup>
        <mi>P</mi>
        <msub>
         <mi>T</mi>
         <mn>2</mn>
        </msub>
        <mn>1</mn>
       </msubsup>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mi mathvariant="normal">…</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>T</mi>
      <mi>C</mi>
      <msubsup>
       <mi>L</mi>
       <msub>
        <mi>T</mi>
        <mn>2</mn>
       </msub>
       <mi>m</mi>
      </msubsup>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>=</mo>
      <mo>=</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>T</mi>
       <mi>C</mi>
       <msubsup>
        <mi>L</mi>
        <msub>
         <mi>T</mi>
         <mn>1</mn>
        </msub>
        <mi>i</mi>
       </msubsup>
       <mo stretchy="false">|</mo>
       <msubsup>
        <mi>P</mi>
        <msub>
         <mi>T</mi>
         <mn>2</mn>
        </msub>
        <mi>m</mi>
       </msubsup>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mi mathvariant="normal">…</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>T</mi>
      <mi>C</mi>
      <msubsup>
       <mi>L</mi>
       <msub>
        <mi>T</mi>
        <mn>3</mn>
       </msub>
       <mn>1</mn>
      </msubsup>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>=</mo>
      <mo>=</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>T</mi>
       <mi>C</mi>
       <msubsup>
        <mi>L</mi>
        <msub>
         <mi>T</mi>
         <mn>2</mn>
        </msub>
        <mi>j</mi>
       </msubsup>
       <mo stretchy="false">|</mo>
       <msubsup>
        <mi>P</mi>
        <msub>
         <mi>T</mi>
         <mn>3</mn>
        </msub>
        <mn>1</mn>
       </msubsup>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mi mathvariant="normal">…</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>T</mi>
      <mi>C</mi>
      <msubsup>
       <mi>L</mi>
       <msub>
        <mi>T</mi>
        <mn>3</mn>
       </msub>
       <mi>k</mi>
      </msubsup>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>=</mo>
      <mo>=</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>T</mi>
       <mi>C</mi>
       <msubsup>
        <mi>L</mi>
        <msub>
         <mi>T</mi>
         <mn>2</mn>
        </msub>
        <mi>j</mi>
       </msubsup>
       <mo stretchy="false">|</mo>
       <msubsup>
        <mi>P</mi>
        <msub>
         <mi>T</mi>
         <mn>3</mn>
        </msub>
        <mi>k</mi>
       </msubsup>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mi mathvariant="normal">…</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mi mathvariant="normal">…</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mi mathvariant="normal">…</mi>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>I</ci>
      <ci>S</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <eq></eq>
      <eq></eq>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">I</csymbol>
       <csymbol cd="unknown">S</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">P</csymbol>
       <ci>normal-]</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>C</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <eq></eq>
      <eq></eq>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">V</csymbol>
       <csymbol cd="unknown">I</csymbol>
       <csymbol cd="unknown">S</csymbol>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-]</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-…</ci>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>C</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <eq></eq>
      <eq></eq>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">V</csymbol>
       <csymbol cd="unknown">I</csymbol>
       <csymbol cd="unknown">S</csymbol>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <ci>normal-]</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>C</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <eq></eq>
      <eq></eq>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">T</csymbol>
       <csymbol cd="unknown">C</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>i</ci>
       </apply>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-]</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-…</ci>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>C</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <eq></eq>
      <eq></eq>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">T</csymbol>
       <csymbol cd="unknown">C</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>i</ci>
       </apply>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <ci>normal-]</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-…</ci>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>C</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <eq></eq>
      <eq></eq>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">T</csymbol>
       <csymbol cd="unknown">C</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>j</ci>
       </apply>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">3</cn>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-]</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-…</ci>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>C</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <eq></eq>
      <eq></eq>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">T</csymbol>
       <csymbol cd="unknown">C</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>j</ci>
       </apply>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <cn type="integer">3</cn>
         </apply>
        </apply>
        <ci>k</ci>
       </apply>
       <ci>normal-]</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-…</ci>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-…</ci>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-…</ci>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle VIS&\displaystyle==[IS|P]\\
\displaystyle TCL_{T_{1}}^{1}&\displaystyle==[VIS|P_{T_{1}}^{1}]\\
&\displaystyle\dots\\
\displaystyle TCL_{T_{1}}^{n}&\displaystyle==[VIS|P_{T_{1}}^{n}]\\
\displaystyle TCL_{T_{2}}^{1}&\displaystyle==[TCL_{T_{1}}^{i}|P_{T_{2}}^{1}]\\
&\displaystyle\dots\\
\displaystyle TCL_{T_{2}}^{m}&\displaystyle==[TCL_{T_{1}}^{i}|P_{T_{2}}^{m}]\\
&\displaystyle\dots\\
\displaystyle TCL_{T_{3}}^{1}&\displaystyle==[TCL_{T_{2}}^{j}|P_{T_{3}}^{1}]\\
&\displaystyle\dots\\
\displaystyle TCL_{T_{3}}^{k}&\displaystyle==[TCL_{T_{2}}^{j}|P_{T_{3}}^{k}]\\
&\displaystyle\dots\\
&\displaystyle\dots\\
&\displaystyle\dots\end{aligned}
  </annotation>
 </semantics>
</math>

 by considering also 

<math display="inline" id="Test_Template_Framework:75">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h3 id="testing-tree">Testing tree&amp;</h3>

<p>The application of a testing tactic to the VIS generates some test classes. If some of these test classes are further partitioned by applying one or more testing tactics, a new set of test classes is obtained. This process can continue by applying testing tactics to the test classes generated so far. Evidently, the result of this process can be drawn as a <a href="Tree_(data_structure)" title="wikilink">tree</a> with the VIS as the root node, the test classes generated by the first testing tactic as its children, and so on. Furthermore, Stocks and Carrington in  propose to use the Z notation to build the tree, as follows.</p>

<p>

<math display="inline" id="Test_Template_Framework:76">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi>I</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>O</mi>
     <mi>p</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VIS_{Op}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="pruning-testing-trees">Pruning testing trees</h3>

<p>In general a test class' predicate is a conjunction of two or more predicates. It is likely, then, that some test classes are empty because their predicates are contradictions. These test classes must be pruned from the testing tree because they represent impossible combinations of input values, i.e. no <a href="#Abstract_test_case" title="wikilink">abstract test case</a> can be derived out of them.</p>
<h3 id="abstract-test-case">Abstract test case</h3>

<p>An abstract test case is an element belonging to a <a href="#Test_class" title="wikilink">test class</a>. The TTF prescribes that abstract test cases should be derived only from the leaves of the <a href="#Testing_tree" title="wikilink">testing tree</a>. Abstract test cases can also be written as Z schema boxes. Let 

<math display="inline" id="Test_Template_Framework:77">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

 be some operation, let 

<math display="inline" id="Test_Template_Framework:78">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>T</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>:</mo>
   <msub>
    <mi>T</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}:T_{1}\dots x_{n}:T_{n}
  </annotation>
 </semantics>
</math>

 be the <a href="#Valid_input_space" title="wikilink">VIS</a> of 

<math display="inline" id="Test_Template_Framework:79">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi>I</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>O</mi>
     <mi>p</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VIS_{Op}
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Test_Template_Framework:80">
 <semantics>
  <msub>
   <mi>C</mi>
   <mrow>
    <mi>O</mi>
    <mi>p</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{Op}
  </annotation>
 </semantics>
</math>

 be all the variables declared in 

<math display="inline" id="Test_Template_Framework:81">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Op
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Test_Template_Framework:82">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>P</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}\dots P_{m}
  </annotation>
 </semantics>
</math>

 be a (leaf) test class of the testing tree associated to 

<math display="inline" id="Test_Template_Framework:83">
 <semantics>
  <msub>
   <mi>C</mi>
   <mrow>
    <mi>O</mi>
    <mi>p</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{Op}
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Test_Template_Framework:84">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi>I</mi>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>O</mi>
     <mi>p</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VIS_{Op}
  </annotation>
 </semantics>
</math>

 be the <a href="#Test_class" title="wikilink">characteristic predicates</a> of each test class from 

<math display="inline" id="Test_Template_Framework:85">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>T</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>:</mo>
   <msub>
    <mi>T</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1}:T_{1}\dots v_{n}:T_{n}
  </annotation>
 </semantics>
</math>

 up to 

<math display="inline" id="Test_Template_Framework:86">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 (by following the <a href="Tree_(data_structure)" title="wikilink">edges from child to parent</a>), and let 

<math display="inline" id="Test_Template_Framework:87">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>∧</mo>
   <mi mathvariant="normal">…</mi>
   <mo>∧</mo>
   <msub>
    <mi>P</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}\land\dots\land P_{m}
  </annotation>
 </semantics>
</math>

 be 

<math display="inline" id="Test_Template_Framework:88">
 <semantics>
  <msub>
   <mi>C</mi>
   <mrow>
    <mi>O</mi>
    <mi>p</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{Op}
  </annotation>
 </semantics>
</math>

 constant values satisfying 

<math display="inline" id="Test_Template_Framework:89">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>O</mi>
     <mi>p</mi>
    </mrow>
   </msub>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>∧</mo>
   <mi mathvariant="normal">…</mi>
   <mo>∧</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>v</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-[</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <and></and>
    <ci>normal-…</ci>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [C_{Op}|x_{1}=v_{1}\land\dots\land x_{n}=v_{n}]
  </annotation>
 </semantics>
</math>

. Then, an abstract test case of <span class="LaTeX">$C_{Op}$</span> is the Z schema box defined by <span class="LaTeX">$[C_{Op} | x_{1} = v_{1} \land \dots \land x_{n} = v_{n}]$</span>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Model-based_testing" title="wikilink">Model-based testing</a></li>
<li><a class="uri" href="Fastest" title="wikilink">Fastest</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="notes">Notes</h2>

<p>"</p>

<p><a href="Category:1996_introductions" title="wikilink">Category:1996 introductions</a> <a href="Category:Software_testing" title="wikilink">Category:Software testing</a> <a href="Category:Z_notation" title="wikilink">Category:Z notation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Stocks and Carrington use the term <em>testing strategies</em> in .<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
</ol>
</section>
</body>
</html>
