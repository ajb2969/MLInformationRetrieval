<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1281">Kernelization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Kernelization</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>kernelization</strong> is a technique for designing efficient <a href="algorithm" title="wikilink">algorithms</a> that achieve their efficiency by a preprocessing stage in which inputs to the algorithm are replaced by a smaller input, called a "kernel". The result of solving the problem on the kernel should either be the same as on the original input, or it should be easy to transform the output on the kernel to the desired output for the original problem.</p>

<p>Kernelization is often achieved by applying a set of reduction rules that cut away parts of the instance that are easy to handle. In <a href="parameterized_complexity" title="wikilink">parameterized complexity theory</a>, it is often possible to prove that a kernel with guaranteed bounds on the size of a kernel (as a function of some parameter associated to the problem) can be found in <a href="polynomial_time" title="wikilink">polynomial time</a>. When this is possible, it results in a <a href="fixed-parameter_tractability" title="wikilink">fixed-parameter tractable</a> algorithm whose running time is the sum of the (polynomial time) kernelization step and the (non-polynomial but bounded by the parameter) time to solve the kernel. Indeed, every problem that can be solved by a fixed-parameter tractable algorithm can be solved by a kernelization algorithm of this type.</p>
<h2 id="example-vertex-cover">Example: vertex cover</h2>

<p>A standard example for a kernelization algorithm is the kernelization of the <a href="vertex_cover" title="wikilink">vertex cover problem</a> by S. Buss.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In this problem, the input is an <a href="undirected_graph" title="wikilink">undirected graph</a> 

<math display="inline" id="Kernelization:0">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 together with a number 

<math display="inline" id="Kernelization:1">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. The output is a set of at most 

<math display="inline" id="Kernelization:2">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 vertices that includes the endpoint of every edge in the graph, if such a set exists, or a failure exception if no such set exists. This problem is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>. However, the following reduction rules may be used to kernelize it:</p>
<ol>
<li>If 

<math display="inline" id="Kernelization:3">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k>0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kernelization:4">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is a vertex of degree greater than 

<math display="inline" id="Kernelization:5">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, remove 

<math display="inline" id="Kernelization:6">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 from the graph and decrease 

<math display="inline" id="Kernelization:7">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 by one. Every vertex cover of size 

<math display="inline" id="Kernelization:8">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 must contain 

<math display="inline" id="Kernelization:9">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 since otherwise too many of its neighbors would have to be picked to cover the incident edges. Thus, an optimal vertex cover for the original graph may be formed from a cover of the reduced problem by adding 

<math display="inline" id="Kernelization:10">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 back to the cover.</li>
<li>If 

<math display="inline" id="Kernelization:11">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is an isolated vertex, remove it. An isolated vertex cannot cover any edges, so in this case 

<math display="inline" id="Kernelization:12">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 cannot be part of any minimal cover.</li>
<li>If more than 

<math display="inline" id="Kernelization:13">
 <semantics>
  <msup>
   <mi>k</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{2}
  </annotation>
 </semantics>
</math>

 edges remain in the graph, and neither of the previous two rules can be applied, then the graph cannot contain a vertex cover of size 

<math display="inline" id="Kernelization:14">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. For, after eliminating all vertices of degree greater than 

<math display="inline" id="Kernelization:15">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, each remaining vertex can only cover at most 

<math display="inline" id="Kernelization:16">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 edges and a set of 

<math display="inline" id="Kernelization:17">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 vertices could only cover at most 

<math display="inline" id="Kernelization:18">
 <semantics>
  <msup>
   <mi>k</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{2}
  </annotation>
 </semantics>
</math>

 edges. In this case, the instance may be replaced by an instance with two vertices, one edge, and 

<math display="inline" id="Kernelization:19">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=0
  </annotation>
 </semantics>
</math>

 , which also has no solution.</li>
</ol>

<p>An algorithm that applies these rules repeatedly until no more reductions can be made necessarily terminates with a kernel that has at most 

<math display="inline" id="Kernelization:20">
 <semantics>
  <msup>
   <mi>k</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{2}
  </annotation>
 </semantics>
</math>

 edges and (because each edge has at most two endpoints and there are no isolated vertices) at most 

<math display="inline" id="Kernelization:21">
 <semantics>
  <mrow>
   <mn>2</mn>
   <msup>
    <mi>k</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k^{2}
  </annotation>
 </semantics>
</math>

 vertices. This kernelization may be implemented in <a href="linear_time" title="wikilink">linear time</a>. Once the kernel has been constructed, the vertex cover problem may be solved by a <a href="brute_force_search" title="wikilink">brute force search</a> algorithm that tests whether each subset of the kernel is a cover of the kernel. Thus, the vertex cover problem can be solved in time 

<math display="inline" id="Kernelization:22">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mn>2</mn>
       <msup>
        <mi>k</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </msup>
     <mo>+</mo>
     <mi>n</mi>
     <mo>+</mo>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>k</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>n</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(2^{2k^{2}}+n+m)
  </annotation>
 </semantics>
</math>

 for a graph with 

<math display="inline" id="Kernelization:23">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 vertices and 

<math display="inline" id="Kernelization:24">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 edges, allowing it to be solved efficiently when 

<math display="inline" id="Kernelization:25">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is small even if 

<math display="inline" id="Kernelization:26">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kernelization:27">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 are both large.</p>

<p>Although this bound is fixed-parameter tractable, its dependence on the parameter is higher than might be desired. More complex kernelization procedures can improve this bound, by finding smaller kernels, at the expense of greater running time in the kernelization step. In the vertex cover example, kernelization algorithms are known that produce kernels with at most 

<math display="inline" id="Kernelization:28">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k
  </annotation>
 </semantics>
</math>

 vertices. One algorithm that achieves this improved bound exploits the half-integrality of the <a href="Vertex_cover#ILP_formulation" title="wikilink">linear program relaxation of vertex cover</a> due to <a href="George_Nemhauser" title="wikilink">Nemhauser</a> and Trotter.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Another kernelization algorithm achieving that bound is based on what is known as the crown reduction rule and uses <a href="Matching_(graph_theory)" title="wikilink">alternating path</a> arguments.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The currently best known kernelization algorithm in terms of the number of vertices is due to  and achieves 

<math display="inline" id="Kernelization:29">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>k</mi>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mi>log</mi>
     <mi>k</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <apply>
      <log></log>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k-c\log k
  </annotation>
 </semantics>
</math>

 vertices for any fixed constant 

<math display="inline" id="Kernelization:30">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

.</p>

<p>It is not possible, in this problem, to find a kernel of size 

<math display="inline" id="Kernelization:31">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>k</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log k)
  </annotation>
 </semantics>
</math>

, unless P = NP, for such a kernel would lead to a polynomial-time algorithm for the NP-hard vertex cover problem. However, much stronger bounds on the kernel size can be proven in this case: unless <a class="uri" href="coNP" title="wikilink">coNP</a> 

<math display="inline" id="Kernelization:32">
 <semantics>
  <mo>⊆</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subseteq
  </annotation>
 </semantics>
</math>

 <a class="uri" href="NP/poly" title="wikilink">NP/poly</a> (believed unlikely by <a href="computational_complexity_theory" title="wikilink">complexity theorists</a>), for every 

<math display="inline" id="Kernelization:33">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

 it is impossible in polynomial time to find kernels with 

<math display="inline" id="Kernelization:34">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mrow>
      <mn>2</mn>
      <mo>-</mo>
      <mi>ϵ</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>ϵ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{2-\epsilon})
  </annotation>
 </semantics>
</math>

 edges.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It is unknown for vertex cover whether kernels with 

<math display="inline" id="Kernelization:35">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>2</mn>
     <mo>-</mo>
     <mi>ϵ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <minus></minus>
     <cn type="integer">2</cn>
     <ci>ϵ</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2-\epsilon)k
  </annotation>
 </semantics>
</math>

 vertices for some 

<math display="inline" id="Kernelization:36">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

 would have any unlikely complexity-theoretic consequences.</p>
<h2 id="definition">Definition</h2>

<p>In the literature, there is no clear consensus on how kernelization should be formally defined and there are subtle differences in the uses of that expression.</p>
<h3 id="downey-fellows-notation">Downey-Fellows Notation</h3>

<p>In the Notation of , a <em>parameterized problem</em> is a subset 

<math display="inline" id="Kernelization:37">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>⊆</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mo>*</mo>
    </msup>
    <mo>×</mo>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>L</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <times></times>
     </apply>
     <ci>𝒩</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\subseteq\Sigma^{*}\times\mathcal{N}
  </annotation>
 </semantics>
</math>

 describing a <a href="decision_problem" title="wikilink">decision problem</a>.</p>

<p>A <strong>kernelization</strong> for a parameterized problem 

<math display="inline" id="Kernelization:38">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is an algorithm that takes an instance 

<math display="inline" id="Kernelization:39">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,k)
  </annotation>
 </semantics>
</math>

 and maps it in time polynomial in 

<math display="inline" id="Kernelization:40">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x|
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kernelization:41">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 to an instance 

<math display="inline" id="Kernelization:42">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>k</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <ci>normal-′</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x^{\prime},k^{\prime})
  </annotation>
 </semantics>
</math>

 such that</p>
<ul>
<li>

<math display="inline" id="Kernelization:43">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,k)
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Kernelization:44">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kernelization:45">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>k</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <ci>normal-′</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x^{\prime},k^{\prime})
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Kernelization:46">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

,</li>
<li>the size of 

<math display="inline" id="Kernelization:47">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 is bounded by a computable function 

<math display="inline" id="Kernelization:48">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Kernelization:49">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, and</li>
<li>

<math display="inline" id="Kernelization:50">
 <semantics>
  <msup>
   <mi>k</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{\prime}
  </annotation>
 </semantics>
</math>

 is bounded by a function in 

<math display="inline" id="Kernelization:51">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The output 

<math display="inline" id="Kernelization:52">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>k</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <ci>normal-′</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x^{\prime},k^{\prime})
  </annotation>
 </semantics>
</math>

 of kernelization is called a kernel. In this general context, the <em>size</em> of the string 

<math display="inline" id="Kernelization:53">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

 just refers to its length. Some authors prefer to use the number of vertices or the number of edges as the size measure in the context of graph problems.</p>
<h3 id="flum-grohe-notation">Flum-Grohe Notation</h3>

<p>In the Notation of , a <em>parameterized problem</em> consists of a decision problem 

<math display="inline" id="Kernelization:54">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>⊆</mo>
   <msup>
    <mi mathvariant="normal">Σ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>L</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\subseteq\Sigma^{*}
  </annotation>
 </semantics>
</math>

 and a function 

<math display="inline" id="Kernelization:55">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mo>*</mo>
    </msup>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>κ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <times></times>
     </apply>
     <ci>𝒩</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa:\Sigma^{*}\to\mathcal{N}
  </annotation>
 </semantics>
</math>

, the parameterization. The <em>parameter</em> of an instance 

<math display="inline" id="Kernelization:56">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is the number 

<math display="inline" id="Kernelization:57">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>κ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>A <strong>kernelization</strong> for a parameterized problem 

<math display="inline" id="Kernelization:58">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is an algorithm that takes an instance 

<math display="inline" id="Kernelization:59">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 with parameter 

<math display="inline" id="Kernelization:60">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and maps it in polynomial time to an instance 

<math display="inline" id="Kernelization:61">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 such that</p>
<ul>
<li>

<math display="inline" id="Kernelization:62">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Kernelization:63">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kernelization:64">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Kernelization:65">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 and</li>
<li>the size of 

<math display="inline" id="Kernelization:66">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is bounded by a computable function 

<math display="inline" id="Kernelization:67">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Kernelization:68">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Note that in this notation, the bound on the size of 

<math display="inline" id="Kernelization:69">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 implies that the parameter of 

<math display="inline" id="Kernelization:70">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is also bounded by a function in 

<math display="inline" id="Kernelization:71">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.</p>

<p>The function 

<math display="inline" id="Kernelization:72">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is often referred to as the size of the kernel. If 

<math display="inline" id="Kernelization:73">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <msup>
    <mi>k</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=k^{O(1)}
  </annotation>
 </semantics>
</math>

, it is said that 

<math display="inline" id="Kernelization:74">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 admits a polynomial kernel. Similarly, for 

<math display="inline" id="Kernelization:75">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f={O(k)}
  </annotation>
 </semantics>
</math>

, the problem admits linear kernel.</p>
<h2 id="kernelizability-and-fixed-parameter-tractability-are-equivalent">Kernelizability and fixed-parameter tractability are equivalent</h2>

<p>A problem is fixed-parameter tractable if and only if it is kernelizable and <a href="recursive_language" title="wikilink">decidable</a>.</p>

<p>That a kernelizable and decidable problem is fixed-parameter tractable can be seen from the definition above: First the kernelization algorithm, which runs in time 

<math display="inline" id="Kernelization:76">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mi>c</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|x|^{c})
  </annotation>
 </semantics>
</math>

 for some c, is invoked to generate a kernel of size 

<math display="inline" id="Kernelization:77">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)
  </annotation>
 </semantics>
</math>

. The kernel is then solved by the algorithm that proves that the problem is decidable. The total running time of this procedure is 

<math display="inline" id="Kernelization:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>x</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mi>c</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <ci>x</ci>
      </apply>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(f(k))+O(|x|^{c})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Kernelization:79">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(n)
  </annotation>
 </semantics>
</math>

 is the running time for the algorithm used to solve the kernels. Since 

<math display="inline" id="Kernelization:80">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(f(k))
  </annotation>
 </semantics>
</math>

 is computable, e.g. by using the assumption that 

<math display="inline" id="Kernelization:81">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)
  </annotation>
 </semantics>
</math>

 is computable and testing all possible inputs of length 

<math display="inline" id="Kernelization:82">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)
  </annotation>
 </semantics>
</math>

, this implies that the problem is fixed-parameter tractable.</p>

<p>The other direction, that a fixed-parameter tractable problem is kernelizable and decidable is a bit more involved. Assume that the question is non-trivial, meaning that there is at least one instance that is in the language, called 

<math display="inline" id="Kernelization:83">
 <semantics>
  <msub>
   <mi>I</mi>
   <mrow>
    <mi>y</mi>
    <mi>e</mi>
    <mi>s</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>e</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{yes}
  </annotation>
 </semantics>
</math>

, and at least one instance that is not in the language, called 

<math display="inline" id="Kernelization:84">
 <semantics>
  <msub>
   <mi>I</mi>
   <mrow>
    <mi>n</mi>
    <mi>o</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>o</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{no}
  </annotation>
 </semantics>
</math>

; otherwise, replacing any instance by the empty string is a valid kernelization. Assume also that the problem is fixed-parameter tractable, ie., it has an algorithm that runs in at most 

<math display="inline" id="Kernelization:85">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⋅</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)\cdot|x|^{c}
  </annotation>
 </semantics>
</math>

 steps on instances 

<math display="inline" id="Kernelization:86">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,k)
  </annotation>
 </semantics>
</math>

, for some constant 

<math display="inline" id="Kernelization:87">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 and some function 

<math display="inline" id="Kernelization:88">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)
  </annotation>
 </semantics>
</math>

. To kernelize an input, run this algorithm on the given input for at most 

<math display="inline" id="Kernelization:89">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mrow>
    <mi>c</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x|^{c+1}
  </annotation>
 </semantics>
</math>

 steps. If it terminates with an answer, use that answer to select either 

<math display="inline" id="Kernelization:90">
 <semantics>
  <msub>
   <mi>I</mi>
   <mrow>
    <mi>y</mi>
    <mi>e</mi>
    <mi>s</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>e</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{yes}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Kernelization:91">
 <semantics>
  <msub>
   <mi>I</mi>
   <mrow>
    <mi>n</mi>
    <mi>o</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>o</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{no}
  </annotation>
 </semantics>
</math>

 as the kernel. If, instead, it exceeds the 

<math display="inline" id="Kernelization:92">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mrow>
    <mi>c</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x|^{c+1}
  </annotation>
 </semantics>
</math>

 bound on the number of steps without terminating, then return 

<math display="inline" id="Kernelization:93">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,k)
  </annotation>
 </semantics>
</math>

 itself as the kernel. Because 

<math display="inline" id="Kernelization:94">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,k)
  </annotation>
 </semantics>
</math>

 is only returned as a kernel for inputs with 

<math display="inline" id="Kernelization:95">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⋅</mo>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mi>c</mi>
    </msup>
   </mrow>
   <mo>></mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mi>c</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <ci>x</ci>
      </apply>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)\cdot|x|^{c}>|x|^{c+1}
  </annotation>
 </semantics>
</math>

, it follows that the size of the kernel produced in this way is at most 

<math display="inline" id="Kernelization:96">
 <semantics>
  <mrow>
   <mi>max</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>I</mi>
      <mrow>
       <mi>y</mi>
       <mi>e</mi>
       <mi>s</mi>
      </mrow>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>I</mi>
      <mrow>
       <mi>n</mi>
       <mi>o</mi>
      </mrow>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <max></max>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>e</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>o</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\{|I_{yes}|,|I_{no}|,f(k)\}
  </annotation>
 </semantics>
</math>

. This size bound is computable, by the assumption from fixed-parameter tractability that 

<math display="inline" id="Kernelization:97">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)
  </annotation>
 </semantics>
</math>

 is computable.</p>
<h2 id="more-examples">More Examples</h2>
<ul>
<li><strong>Vertex Cover:</strong> The <a href="vertex_cover" title="wikilink">vertex cover</a> problem has kernels with at most 

<math display="inline" id="Kernelization:98">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k
  </annotation>
 </semantics>
</math>

 vertices and 

<math display="inline" id="Kernelization:99">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{2})
  </annotation>
 </semantics>
</math>

 edges.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Furthermore, for any 

<math display="inline" id="Kernelization:100">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ε</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon>0
  </annotation>
 </semantics>
</math>

, vertex cover does not have kernels with 

<math display="inline" id="Kernelization:101">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mrow>
      <mn>2</mn>
      <mo>-</mo>
      <mi>ε</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>ε</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{2-\varepsilon})
  </annotation>
 </semantics>
</math>

 edges unless 

<math display="inline" id="Kernelization:102">
 <semantics>
  <mrow>
   <mtext>coNP</mtext>
   <mo>⊆</mo>
   <mtext>NP/poly</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <mtext>coNP</mtext>
    <mtext>NP/poly</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{coNP}\subseteq\text{NP/poly}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The vertex cover problems in 

<math display="inline" id="Kernelization:103">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

-uniform hypergraphs has kernels with 

<math display="inline" id="Kernelization:104">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mi>d</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{d})
  </annotation>
 </semantics>
</math>

 edges using the <a href="sunflower_lemma" title="wikilink">sunflower lemma</a>, and it does not have kernels of size 

<math display="inline" id="Kernelization:105">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mrow>
      <mi>d</mi>
      <mo>-</mo>
      <mi>ε</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <minus></minus>
      <ci>d</ci>
      <ci>ε</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{d-\varepsilon})
  </annotation>
 </semantics>
</math>

 unless 

<math display="inline" id="Kernelization:106">
 <semantics>
  <mrow>
   <mtext>coNP</mtext>
   <mo>⊆</mo>
   <mtext>NP/poly</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <mtext>coNP</mtext>
    <mtext>NP/poly</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{coNP}\subseteq\text{NP/poly}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
<li><strong>Feedback Vertex Set:</strong> The <a href="feedback_vertex_set" title="wikilink">feedback vertex set</a> problem has kernels with 

<math display="inline" id="Kernelization:107">
 <semantics>
  <mrow>
   <mn>4</mn>
   <msup>
    <mi>k</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">4</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4k^{2}
  </annotation>
 </semantics>
</math>

 vertices and 

<math display="inline" id="Kernelization:108">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{2})
  </annotation>
 </semantics>
</math>

 edges.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Furthermore, it does not have kernels with 

<math display="inline" id="Kernelization:109">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>k</mi>
     <mrow>
      <mn>2</mn>
      <mo>-</mo>
      <mi>ε</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>k</ci>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>ε</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(k^{2-\varepsilon})
  </annotation>
 </semantics>
</math>

 edges unless 

<math display="inline" id="Kernelization:110">
 <semantics>
  <mrow>
   <mtext>coNP</mtext>
   <mo>⊆</mo>
   <mtext>NP/poly</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <mtext>coNP</mtext>
    <mtext>NP/poly</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{coNP}\subseteq\text{NP/poly}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></li>
<li><strong>k-Path:</strong> The k-path problem is to decide whether a given graph has a <a href="Path_(graph_theory)" title="wikilink">path</a> of length at least 

<math display="inline" id="Kernelization:111">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. This problem has kernels of size exponential in 

<math display="inline" id="Kernelization:112">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, and it does not have kernels of size polynomial in 

<math display="inline" id="Kernelization:113">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 unless 

<math display="inline" id="Kernelization:114">
 <semantics>
  <mrow>
   <mtext>coNP</mtext>
   <mo>⊆</mo>
   <mtext>NP/poly</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <mtext>coNP</mtext>
    <mtext>NP/poly</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{coNP}\subseteq\text{NP/poly}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
<li><strong>Bidimensional problems:</strong> Many parameterized versions of <a href="Bidimensionality" title="wikilink">bidimensional</a> problems have linear kernels on planar graphs, and more generally, on graphs excluding some fixed graph as a <a href="Minor_(graph_theory)" title="wikilink">minor</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Parameterized_complexity" title="wikilink">Category:Parameterized complexity</a> <a href="Category:Analysis_of_algorithms" title="wikilink">Category:Analysis of algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">This unpublished observation is acknowledged in a paper of <a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"> give a kernel based on the crown reduction that has 

<math display="inline" id="Kernelization:115">
 <semantics>
  <mrow>
   <mn>3</mn>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">3</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3k
  </annotation>
 </semantics>
</math>

 vertices. The 

<math display="inline" id="Kernelization:116">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k
  </annotation>
 </semantics>
</math>

 vertex bound is a bit more involved and folklore.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
