<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="284">Conjunctive query</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Conjunctive query</h1>
<hr/>

<p>In <a href="database_theory" title="wikilink">database theory</a>, a <strong>conjunctive query</strong> is a restricted form of <a href="first-order_logic" title="wikilink">first-order</a> queries. Many first-order queries can be written as conjunctive queries. In particular, a large part of queries issued on <a href="relational_database" title="wikilink">relational databases</a> can be expressed in this way. Conjunctive queries also have a number of desirable theoretical properties that larger classes of queries (e.g., the <a href="relational_algebra" title="wikilink">relational algebra</a> queries) do not share.</p>
<h2 id="definition">Definition</h2>

<p>The conjunctive queries are simply the fragment of (domain independent) <a href="first-order_logic" title="wikilink">first-order logic</a> given by the set of formulae that can be constructed from <a href="atomic_formula" title="wikilink">atomic formulae</a> using <a href="Logical_conjunction" title="wikilink">conjunction</a> 

<math display="inline" id="Conjunctive_query:0">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 and <a href="existential_quantification" title="wikilink">existential quantification</a> 

<math display="inline" id="Conjunctive_query:1">
 <semantics>
  <mo>∃</mo>
  <annotation-xml encoding="MathML-Content">
   <exists></exists>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists
  </annotation>
 </semantics>
</math>

, but not using <a class="uri" href="disjunction" title="wikilink">disjunction</a> 

<math display="inline" id="Conjunctive_query:2">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

, <a class="uri" href="negation" title="wikilink">negation</a> 

<math display="inline" id="Conjunctive_query:3">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg
  </annotation>
 </semantics>
</math>

, or <a href="universal_quantification" title="wikilink">universal quantification</a> 

<math display="inline" id="Conjunctive_query:4">
 <semantics>
  <mo>∀</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall
  </annotation>
 </semantics>
</math>

. Each such formula can be rewritten (efficiently) into an equivalent formula in <a href="prenex_normal_form" title="wikilink">prenex normal form</a>, thus this form is usually simply assumed.</p>

<p>Thus conjunctive queries are of the following general form:</p>

<p>

<math display="block" id="Conjunctive_query:5">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>m</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">…</mi>
    <mo>∧</mo>
    <msub>
     <mi>A</mi>
     <mi>r</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </vector>
    <list>
     <apply>
      <exists></exists>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </list>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},\ldots,x_{k}).\exists x_{k+1},\ldots x_{m}.A_{1}\wedge\ldots\wedge A_{r}
  </annotation>
 </semantics>
</math>

,</p>

<p>with the <a href="Free_variables_and_bound_variables" title="wikilink">free variables</a> 

<math display="inline" id="Conjunctive_query:6">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{k}
  </annotation>
 </semantics>
</math>

 being called distinguished variables, and the <a href="Free_variables_and_bound_variables" title="wikilink">bound variables</a> 

<math display="inline" id="Conjunctive_query:7">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1},\ldots,x_{m}
  </annotation>
 </semantics>
</math>

 being called undistinguished variables. 

<math display="inline" id="Conjunctive_query:8">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>A</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>r</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1},\ldots,A_{r}
  </annotation>
 </semantics>
</math>

 are <a href="atomic_formula" title="wikilink">atomic formulae</a>. Conjunctive queries without distinguished variables are called <a href="boolean_conjunctive_query" title="wikilink">boolean conjunctive queries</a>.</p>

<p>As an example of why the restriction to domain independent first-order logic is important, consider 

<math display="inline" id="Conjunctive_query:9">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>.</mo>
   <mrow>
    <mo>∃</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}.\exists x_{2}.R(x_{2})
  </annotation>
 </semantics>
</math>

, which is not domain independent; see <a href="Codd's_theorem" title="wikilink">Codd's theorem</a>. This formula cannot be implemented in the select-project-join fragment of relational algebra, and hence should not be considered a conjunctive query.</p>

<p>Conjunctive queries can express a large part of queries, which are frequently issued on <a href="relational_database" title="wikilink">relational databases</a>. To give an example, imagine a relational database for storing information about students, their address, the courses they visit and their gender. Finding all male students and their addresses who attend a course that is also attended by a female student is expressed by the following conjunctive query:</p>

<p><code>
  (student, address) . <math>\exists</math>(student2, course) .
     attends(student, course) <math>\wedge</math> gender(student, 'male') <math>\wedge</math> 
     attends(student2, course) <math>\wedge</math>
     gender(student2, 'female') <math>\wedge</math> lives(student, address)
</code></p>

<p>Note that since the only entity of interest is the male student and his address, these are the only distinguished variables, while the variables <code>course</code>, <code>student2</code> are only <a href="existential_quantification" title="wikilink">existentially quantified</a>, i.e. undistinguished.</p>
<h2 id="relationship-to-other-query-languages">Relationship to other query languages</h2>

<p>Conjunctive queries also correspond to select-project-join queries in <a href="relational_algebra" title="wikilink">relational algebra</a> (i.e., relational algebra queries that do not use the operations union or difference) and to select-from-where queries in <a class="uri" href="SQL" title="wikilink">SQL</a> in which the where-condition uses exclusively conjunctions of atomic equality conditions, i.e. conditions constructed from column names and constants using no comparison operators other than "=", combined using "and". Notably, this excludes the use of aggregation and subqueries. For example, the above query can be written as an SQL query of the conjunctive query fragment as <code>
  select l.student, l.address
  from attends a1, gender g1,
       attends a2, gender g2,
       lives l
  where a1.student=g1.student
  and   a2.student=g2.student
  and   l.student=g1.student
  and   a1.course=a2.course
  and   g1.gender='male'
  and   g2.gender='female';
</code></p>
<h2 id="conjunctive-queries-and-datalog">Conjunctive queries and datalog</h2>

<p>Besides their logical notation, conjunctive queries can also be written as <a class="uri" href="datalog" title="wikilink">datalog</a> rules. Many authors in fact prefer the following datalog notation for the query above:</p>

<p><code>
  result(student, address) :- attends(student, course),  gender(student, male),
                              attends(student2, course), gender(student2, female),
                              lives(student, address).
</code></p>

<p>Although there are no quantifiers in this notation, variables appearing in the head of the rule are still implicitly <a href="universal_quantification" title="wikilink">universally quantified</a>, while variables only appearing in the body of the rule are still implicitly existentially quantified.</p>

<p>While any conjunctive query can be written as a datalog rule, not every datalog program can be written as a conjunctive query. In fact, only single rules over extensional predicate symbols can be easily rewritten as an equivalent conjunctive query. The problem of deciding whether for a given datalog program there is an equivalent <a href="recursion" title="wikilink">nonrecursive program</a> (corresponding to a positive relational algebra query, or, equivalently, a formula of positive existential <a href="first-order_logic" title="wikilink">first-order logic</a>, or, as a special case, a conjunctive query) is known as the <a href="datalog_boundedness" title="wikilink">datalog boundedness</a> problem and is undecidable.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="extensions-of-conjunctive-queries">Extensions of conjunctive queries</h2>

<p>Extensions of conjunctive queries capturing more <a href="expressive_power_(computer_science)" title="wikilink">expressive power</a> include unions of conjunctive queries, which are equivalent to positive (i.e., <a class="uri" href="negation" title="wikilink">negation</a>-free) <a href="relational_algebra" title="wikilink">relational algebra</a>, conjunctive queries extended by union and <a class="uri" href="negation" title="wikilink">negation</a>, which by <a href="Codd's_theorem" title="wikilink">Codd's theorem</a> correspond to <a href="relational_algebra" title="wikilink">relational algebra</a> and <a href="first-order_logic" title="wikilink">first-order logic</a>, conjunctive queries with built-in predicates and conjunctive queries with <a href="aggregate_function" title="wikilink">aggregate functions</a>. The formal study of all of these extensions is justified by their application in <a href="relational_databases" title="wikilink">relational databases</a> and is in the realm of <a href="database_theory" title="wikilink">database theory</a>.</p>
<h2 id="complexity-of-conjunctive-queries">Complexity of conjunctive queries</h2>

<p>For the study of the <a href="Analysis_of_algorithms" title="wikilink">computational complexity</a> of evaluating conjunctive queries, two problems have to be distinguished. The first is the problem of evaluating a conjunctive query on a <a href="relational_database" title="wikilink">relational database</a> where both the query and the database are considered part of the input. The complexity of this problem is usually referred to as <strong>combined complexity</strong>, while the complexity of the problem of evaluating a query on a relational database, where the query is assumed fixed, is called <strong>data complexity</strong>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Conjunctive queries are <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> with respect to combined complexity,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> while the data complexity of conjunctive queries is very low, in the parallel complexity class <a class="uri" href="AC0" title="wikilink">AC0</a>, which is contained in <a class="uri" href="LOGSPACE" title="wikilink">LOGSPACE</a> and thus in <a href="polynomial_time" title="wikilink">polynomial time</a>. The <a href="NP-hard" title="wikilink">NP-hardness</a> of conjunctive queries may appear surprising, since <a href="relational_algebra" title="wikilink">relational algebra</a> and <a class="uri" href="SQL" title="wikilink">SQL</a> strictly subsume the conjunctive queries and are thus at least as hard (in fact, relational algebra is <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>-complete with respect to combined complexity and is therefore even harder under widely held complexity-theoretic assumptions). However, in the usual application scenario, databases are large, while queries are very small, and the data complexity model may be appropriate for studying and describing their difficulty.</p>
<h2 id="formal-properties-of-conjunctive-queries">Formal properties of conjunctive queries</h2>

<p>Conjunctive queries are one of the great success stories of <a href="database_theory" title="wikilink">database theory</a> in that many interesting problems that are computationally hard or <a href="undecidable_problem" title="wikilink">undecidable</a> for larger classes of queries are feasible for conjunctive queries.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> For example, consider the query containment problem. We write 

<math display="inline" id="Conjunctive_query:10">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>⊆</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>R</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\subseteq S
  </annotation>
 </semantics>
</math>

 for two <a href="database_relation" title="wikilink">database relations</a> 

<math display="inline" id="Conjunctive_query:11">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>,</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>R</ci>
    <ci>S</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R,S
  </annotation>
 </semantics>
</math>

 of the same <a href="database_schema" title="wikilink">schema</a> if and only if each tuple occurring in 

<math display="inline" id="Conjunctive_query:12">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 also occurs in 

<math display="inline" id="Conjunctive_query:13">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. Given a query 

<math display="inline" id="Conjunctive_query:14">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 and a <a href="relational_database" title="wikilink">relational database</a> instance 

<math display="inline" id="Conjunctive_query:15">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

, we write the result relation of evaluating the query on the instance simply as 

<math display="inline" id="Conjunctive_query:16">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(I)
  </annotation>
 </semantics>
</math>

. Given two queries 

<math display="inline" id="Conjunctive_query:17">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Conjunctive_query:18">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{2}
  </annotation>
 </semantics>
</math>

 and a <a href="database_schema" title="wikilink">database schema</a>, the query containment problem is the problem of deciding whether for all possible database instances 

<math display="inline" id="Conjunctive_query:19">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 over the input database schema, 

<math display="inline" id="Conjunctive_query:20">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>I</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{1}(I)\subseteq Q_{2}(I)
  </annotation>
 </semantics>
</math>

. The main application of query containment is in query optimization: Deciding whether two queries are equivalent is possible by simply checking mutual containment.</p>

<p>The query containment problem is undecidable for <a href="relational_algebra" title="wikilink">relational algebra</a> and <a class="uri" href="SQL" title="wikilink">SQL</a> but is decidable and <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> for conjunctive queries. In fact, it turns out that the query containment problem for conjunctive queries is exactly the same problem as the query evaluation problem.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Since queries tend to be small, <a class="uri" href="NP-completeness" title="wikilink">NP-completeness</a> here is usually considered acceptable. The query containment problem for conjunctive queries is also equivalent to the <a href="constraint_satisfaction_problem" title="wikilink">constraint satisfaction problem</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>An important class of conjunctive queries that have polynomial-time combined complexity are the <strong>acyclic</strong> conjunctive queries.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The query evaluation, and thus query containment, is <a class="uri" href="LOGCFL" title="wikilink">LOGCFL</a>-complete and thus in <a href="polynomial_time" title="wikilink">polynomial time</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Acyclicity of conjunctive queries is a structural property of queries that is defined with respect to the query's <a class="uri" href="hypergraph" title="wikilink">hypergraph</a>:<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> a conjunctive query is acyclic if and only if it has hypertree-width 1. For the special case of conjunctive queries in which all relations used are binary, this notion corresponds to the treewidth of the <a href="dependency_graph" title="wikilink">dependency graph</a> of the variables in the query (i.e., the graph having the variables of the query as nodes and an undirected edge 

<math display="inline" id="Conjunctive_query:21">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>x</ci>
    <ci>y</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x,y\}
  </annotation>
 </semantics>
</math>

 between two variables if and only if there is an atomic formula 

<math display="inline" id="Conjunctive_query:22">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x,y)
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Conjunctive_query:23">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <interval closure="open">
     <ci>y</ci>
     <ci>x</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(y,x)
  </annotation>
 </semantics>
</math>

 in the query) and the conjunctive query is acyclic if and only if its dependency graph is <a href="Graph_(mathematics)" title="wikilink">acyclic</a>.</p>

<p>An important generalization of acyclicity is the notion of <a href="hypertree_decomposition" title="wikilink">bounded hypertree-width</a>, which is a measure of how close to acyclic a hypergraph is, analogous to bounded <a class="uri" href="treewidth" title="wikilink">treewidth</a> in <a href="graph_(mathematics)" title="wikilink">graphs</a>. Conjunctive queries of bounded tree-width have <a class="uri" href="LOGCFL" title="wikilink">LOGCFL</a> combined complexity.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>Unrestricted conjunctive queries over tree data (i.e., a relational database consisting of a binary child relation of a tree as well as unary relations for labeling the tree nodes) have polynomial time combined complexity.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li>[<a href="http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6V1G-43G4RRN-2&amp;_user=5423704&amp;_coverDate=05/28/2000&amp;_rdoc=2&amp;_fmt=summary&amp;_orig=browse&amp;_srch=doc-info(%23toc%235674%232000%23997609997%23255297%23FLP%23display%23Volume)&amp;_cdi=5674&amp;_sort=d&amp;_docanchor">http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6V1G-43G4RRN-2&amp;_user=5423704&amp;_coverDate=05/28/2000&amp;_rdoc=2&amp;_fmt=summary&amp;_orig=browse&amp;_srch=doc-info(%23toc%235674%232000%23997609997%23255297%23FLP%23display%23Volume)&amp;_cdi=5674&amp;_sort=d&amp;_docanchor</a>=&amp;_ct=8&amp;_acct=C000007438&amp;_version=1&amp;_urlVersion=0&amp;_userid=5423704&amp;md5;=adc35b17aaf28963cc6925a017813785 Ullman, J. D. <em>Information integration using logical views Theoretical Computer Science</em>, 2000, 239, 189-210]</li>
</ul>
<ul>
<li><a href="Georg_Gottlob" title="wikilink">Georg Gottlob</a>, <a href="http://www.dis.uniroma1.it/~lenzerin/homepagine/didattica/viewbasedqueryprocessing/ConjunctiveQueries.pdf">Presentation on structural decomposition methods for the efficient evaluation of conjunctive queries (PDF)</a></li>
</ul>

<p>"</p>

<p><a href="Category:Database_theory" title="wikilink">Category:Database theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Gerd_G._Hillebrand" title="wikilink">Gerd G. Hillebrand</a>, <a href="Paris_C._Kanellakis" title="wikilink">Paris C. Kanellakis</a>, <a href="Harry_G._Mairson" title="wikilink">Harry G. Mairson</a>, <a href="Moshe_Y._Vardi" title="wikilink">Moshe Y. Vardi</a>: Undecidable Boundedness Problems for Datalog Programs. J. Log. Program. 25(2): 163-190 (1995)<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="Ashok_K._Chandra" title="wikilink">Ashok K. Chandra</a> and <a href="Philip_M._Merlin" title="wikilink">Philip M. Merlin</a>, 1977. <em>Optimal Implementation of Conjunctive Queries in Relational Data Bases</em>. STOC '77: Proceedings of the ninth annual ACM symposium on Theory of computing [<a class="uri" href="http://portal.acm.org/citation.cfm?id=803397&amp;coll">http://portal.acm.org/citation.cfm?id=803397&amp;coll;</a>;=portal&amp;dl;=ACM]<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="Serge_Abiteboul" title="wikilink">Serge Abiteboul</a>, <a href="Richard_B._Hull" title="wikilink">Richard B. Hull</a>, <a href="Victor_Vianu" title="wikilink">Victor Vianu</a>: Foundations of Databases. Addison-Wesley, 1995.<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="Mihalis_Yannakakis" title="wikilink">Mihalis Yannakakis</a>: Algorithms for Acyclic Database Schemes . Proc. VLDB 1981: 82-94.<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="Georg_Gottlob" title="wikilink">Georg Gottlob</a>, <a href="Nicola_Leone" title="wikilink">Nicola Leone</a>, and <a href="Francesco_Scarcello" title="wikilink">Francesco Scarcello</a> (2001). "The complexity of acyclic conjunctive queries". Journal of the ACM (JACM) 48 (3): 431–498. .<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="Georg_Gottlob" title="wikilink">Georg Gottlob</a>, <a href="Nicola_Leone" title="wikilink">Nicola Leone</a>, and <a href="Francesco_Scarcello" title="wikilink">Francesco Scarcello</a>: Hypertree Decompositions and Tractable Queries. J. Comput. Syst. Sci. 64(3): 579-627 (2002)<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="Georg_Gottlob" title="wikilink">Georg Gottlob</a>, <a href="Christoph_Koch" title="wikilink">Christoph Koch</a>, <a href="Klaus_U._Schulz" title="wikilink">Klaus U. Schulz</a>: Conjunctive queries over trees. J. ACM 53(2): 238-272 (2006)<a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
