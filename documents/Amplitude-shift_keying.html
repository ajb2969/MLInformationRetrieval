<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1166">Amplitude-shift keying</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Amplitude-shift keying</h1>
<hr/>

<p><strong>Amplitude-shift keying</strong> (<strong>ASK</strong>) is a form of <a href="amplitude_modulation" title="wikilink">amplitude modulation</a> that represents <a href="Digital_data" title="wikilink">digital</a> <a class="uri" href="data" title="wikilink">data</a> as variations in the <a class="uri" href="amplitude" title="wikilink">amplitude</a> of a <a href="carrier_wave" title="wikilink">carrier wave</a>. In an ASK system, the binary symbol 1 is represented by transmitting a fixed-amplitude carrier wave and fixed frequency for a bit duration of T seconds. If the signal value is 1 then the carrier signal will be transmitted; otherwise, a signal value of 0 will be transmitted.</p>

<p>Any digital modulation scheme uses a <a href="wiktionary:finite" title="wikilink">finite</a> number of distinct signals to represent digital data. ASK uses a finite number of amplitudes, each assigned a unique pattern of <a href="bit" title="wikilink">binary digits</a>. Usually, each amplitude encodes an equal number of bits. Each pattern of bits forms the <a href="Symbol_(data)" title="wikilink">symbol</a> that is represented by the particular amplitude. The <a class="uri" href="demodulator" title="wikilink">demodulator</a>, which is designed specifically for the symbol-set used by the modulator, determines the amplitude of the received signal and maps it back to the symbol it represents, thus recovering the original data. <a class="uri" href="Frequency" title="wikilink">Frequency</a> and <a href="Phase_(waves)" title="wikilink">phase</a> of the carrier are kept constant.</p>

<p>Like <a href="Amplitude_modulation" title="wikilink">AM</a>, ASK is also linear and sensitive to atmospheric noise, distortions, propagation conditions on different routes in <a class="uri" href="PSTN" title="wikilink">PSTN</a>, etc. Both ASK modulation and demodulation processes are relatively inexpensive. The ASK technique is also commonly used to transmit <a href="digital_data" title="wikilink">digital data</a> over optical fiber. For LED transmitters, binary 1 is represented by a short pulse of light and binary 0 by the absence of light. Laser transmitters normally have a fixed "bias" current that causes the device to emit a low light level. This low level represents binary 0, while a higher-amplitude lightwave represents binary 1.</p>

<p>The simplest and most common form of ASK operates as a switch, using the presence of a carrier wave to indicate a binary one and its absence to indicate a binary zero. This type of modulation is called <a href="on-off_keying" title="wikilink">on-off keying</a> (OOK), and is used at radio frequencies to transmit Morse code (referred to as continuous wave operation),</p>

<p>More sophisticated encoding schemes have been developed which represent data in groups using additional amplitude levels. For instance, a four-level encoding scheme can represent two bits with each shift in amplitude; an eight-level scheme can represent three bits; and so on. These forms of amplitude-shift keying require a high signal-to-noise ratio for their recovery, as by their nature much of the signal is transmitted at reduced power.</p>
<figure><b>(Figure)</b>
<figcaption>ASK diagram</figcaption>
</figure>

<p>ASK system can be divided into three blocks. The first one represents the transmitter, the second one is a linear model of the effects of the channel, the third one shows the structure of the receiver. The following notation is used:</p>
<ul>
<li><em>ht</em><sub>(f)</sub> is the carrier signal for the transmission</li>
<li><em>hc</em><sub>(f)</sub> is the impulse response of the channel</li>
<li><em>n</em><sub>(t)</sub> is the noise introduced by the channel</li>
<li><em>hr</em><sub>(f)</sub> is the filter at the receiver</li>
<li><em>L</em> is the number of levels that are used for transmission</li>
<li><em>T</em><sub>s</sub> is the time between the generation of two symbols</li>
</ul>

<p>Different symbols are represented with different voltages. If the maximum allowed value for the voltage is A, then all the possible values are in the range [−A, A] and they are given by:</p>

<p>

<math display="inline" id="Amplitude-shift_keying:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mfrac>
       <mrow>
        <mn>2</mn>
        <mi>A</mi>
       </mrow>
       <mrow>
        <mi>L</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mfrac>
      <mi>i</mi>
     </mrow>
     <mo>-</mo>
     <mi>A</mi>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">;</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>L</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>A</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>L</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <apply>
       <minus></minus>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}=\frac{2A}{L-1}i-A;\quad i=0,1,\dots,L-1
  </annotation>
 </semantics>
</math>

</p>

<p>the difference between one voltage and the other is:</p>

<p>

<math display="inline" id="Amplitude-shift_keying:1">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>2</mn>
     <mi>A</mi>
    </mrow>
    <mrow>
     <mi>L</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Δ</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>A</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>L</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta=\frac{2A}{L-1}
  </annotation>
 </semantics>
</math>

</p>

<p>Considering the picture, the symbols v[n] are generated randomly by the source S, then the impulse generator creates impulses with an area of v[n]. These impulses are sent to the filter ht to be sent through the channel. In other words, for each symbol a different carrier wave is sent with the relative amplitude.</p>

<p>Out of the transmitter, the signal s(t) can be expressed in the form:</p>

<p>

<math display="inline" id="Amplitude-shift_keying:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mrow>
      <mrow>
       <mi>v</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>n</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <msub>
       <mi>h</mi>
       <mi>t</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mrow>
        <mi>n</mi>
        <msub>
         <mi>T</mi>
         <mi>s</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>v</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(t)=\sum_{n=-\infty}^{\infty}v[n]\cdot h_{t}(t-nT_{s})
  </annotation>
 </semantics>
</math>

</p>

<p>In the receiver, after the filtering through hr (t) the signal is:</p>

<p>

<math display="inline" id="Amplitude-shift_keying:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>r</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mrow>
       <mrow>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>n</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <mi>g</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mrow>
         <mi>n</mi>
         <msub>
          <mi>T</mi>
          <mi>s</mi>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>r</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <apply>
          <minus></minus>
          <infinity></infinity>
         </apply>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <times></times>
         <ci>v</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>g</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <ci>s</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(t)=n_{r}(t)+\sum_{n=-\infty}^{\infty}v[n]\cdot g(t-nT_{s})
  </annotation>
 </semantics>
</math>

</p>

<p>where we use the notation:</p>

<p>

<math display="inline" id="Amplitude-shift_keying:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>n</mi>
     <mi>r</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>*</mo>
     <msub>
      <mi>h</mi>
      <mi>r</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>r</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>r</ci>
      </apply>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{r}(t)=n(t)*h_{r}(f)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Amplitude-shift_keying:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mi>h</mi>
         <mi>t</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>*</mo>
       <msub>
        <mi>h</mi>
        <mi>c</mi>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>*</mo>
     <msub>
      <mi>h</mi>
      <mi>r</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <ci>t</ci>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>c</ci>
        </apply>
       </apply>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>r</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(t)=h_{t}(t)*h_{c}(f)*h_{r}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>where * indicates the convolution between two signals. After the A/D conversion the signal z[k] can be expressed in the form:</p>

<p>

<math display="inline" id="Amplitude-shift_keying:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>k</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>r</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>k</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>k</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>0</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≠</mo>
       <mi>k</mi>
      </mrow>
     </msub>
     <mrow>
      <mi>v</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>z</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>v</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>k</ci>
      </apply>
      <ci>g</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>v</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
       <ci>g</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z[k]=n_{r}[k]+v[k]g[0]+\sum_{n\neq k}v[n]g[k-n]
  </annotation>
 </semantics>
</math>

</p>

<p>In this relationship, the second term represents the symbol to be extracted. The others are unwanted: the first one is the effect of noise, the third one is due to the intersymbol interference.</p>

<p>If the filters are chosen so that g(t) will satisfy the Nyquist ISI criterion, then there will be no intersymbol interference and the value of the sum will be zero, so:</p>

<p>

<math display="inline" id="Amplitude-shift_keying:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>k</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>r</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>k</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>k</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>0</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>z</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>v</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>k</ci>
      </apply>
      <ci>g</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z[k]=n_{r}[k]+v[k]g[0]
  </annotation>
 </semantics>
</math>

</p>

<p>the transmission will be affected only by noise.</p>
<h2 id="probability-of-error">Probability of error</h2>

<p>The probability density function of having an error of a given size can be modelled by a Gaussian function; the mean value will be the relative sent value, and its variance will be given by:</p>

<p>

<math display="inline" id="Amplitude-shift_keying:8">
 <semantics>
  <mrow>
   <msubsup>
    <mi>σ</mi>
    <mi>N</mi>
    <mn>2</mn>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mrow>
      <mo>+</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msubsup>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi mathvariant="normal">Φ</mi>
        <mi>N</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <msub>
          <mi>H</mi>
          <mi>r</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>f</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
     <mi>d</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>N</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Φ</ci>
         <ci>N</ci>
        </apply>
        <ci>f</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>H</ci>
           <ci>r</ci>
          </apply>
          <ci>f</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{N}^{2}=\int_{-\infty}^{+\infty}\Phi_{N}(f)\cdot|H_{r}(f)|^{2}df
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Amplitude-shift_keying:9">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Φ</mi>
    <mi>N</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Φ</ci>
     <ci>N</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{N}(f)
  </annotation>
 </semantics>
</math>

 is the spectral density of the noise within the band and Hr (f) is the continuous Fourier transform of the impulse response of the filter hr (f).</p>

<p>The probability of making an error is given by:</p>

<p>

<math display="inline" id="Amplitude-shift_keying:10">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>e</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mrow>
       <mi>e</mi>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>H</mi>
        <mn>0</mn>
       </msub>
      </mrow>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>P</mi>
      <msub>
       <mi>H</mi>
       <mn>0</mn>
      </msub>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mrow>
       <mi>e</mi>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>H</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>P</mi>
      <msub>
       <mi>H</mi>
       <mn>1</mn>
      </msub>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mrow>
       <mi>e</mi>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>H</mi>
        <mrow>
         <mi>L</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>P</mi>
      <msub>
       <mi>H</mi>
       <mrow>
        <mi>L</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">e</csymbol>
        <ci>normal-|</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <cn type="integer">0</cn>
        </apply>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">e</csymbol>
        <ci>normal-|</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <cn type="integer">1</cn>
        </apply>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">e</csymbol>
        <ci>normal-|</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <apply>
          <minus></minus>
          <ci>L</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </cerror>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <apply>
         <minus></minus>
         <ci>L</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{e}=P_{e|H_{0}}\cdot P_{H_{0}}+P_{e|H_{1}}\cdot P_{H_{1}}+\cdots+P_{e|H_{L-1%
}}\cdot P_{H_{L-1}}
  </annotation>
 </semantics>
</math>

</p>

<p>where, for example, 

<math display="inline" id="Amplitude-shift_keying:11">
 <semantics>
  <msub>
   <mi>P</mi>
   <mrow>
    <mi>e</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>H</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{e|H_{0}}
  </annotation>
 </semantics>
</math>

 is the conditional probability of making an error given that a symbol v0 has been sent and 

<math display="inline" id="Amplitude-shift_keying:12">
 <semantics>
  <msub>
   <mi>P</mi>
   <msub>
    <mi>H</mi>
    <mn>0</mn>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{H_{0}}
  </annotation>
 </semantics>
</math>

 is the probability of sending a symbol v0.</p>

<p>If the probability of sending any symbol is the same, then:</p>

<p>

<math display="inline" id="Amplitude-shift_keying:13">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <msub>
     <mi>H</mi>
     <mi>i</mi>
    </msub>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>L</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{H_{i}}=\frac{1}{L}
  </annotation>
 </semantics>
</math>

</p>

<p>If we represent all the probability density functions on the same plot against the possible value of the voltage to be transmitted, we get a picture like this (the particular case of L = 4 is shown):</p>
<figure><b>(Figure)</b>
<figcaption>Ask dia calc prob.png</figcaption>
</figure>

<p>The probability of making an error after a single symbol has been sent is the area of the Gaussian function falling under the functions for the other symbols. It is shown in cyan for just one of them. If we call P+ the area under one side of the Gaussian, the sum of all the areas will be: 2 L P^+ - 2 P^+. The total probability of making an error can be expressed in the form:</p>

<p>

<math display="inline" id="Amplitude-shift_keying:14">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>e</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mfrac>
       <mn>1</mn>
       <mi>L</mi>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
    <msup>
     <mi>P</mi>
     <mo>+</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>L</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{e}=2\left(1-\frac{1}{L}\right)P^{+}
  </annotation>
 </semantics>
</math>

</p>

<p>We have now to calculate the value of P+. In order to do that, we can move the origin of the reference wherever we want: the area below the function will not change. We are in a situation like the one shown in the following picture:</p>
<figure><b>(Figure)</b>
<figcaption>Ask dia calc prob 2.png</figcaption>
</figure>

<p>it does not matter which Gaussian function we are considering, the area we want to calculate will be the same. The value we are looking for will be given by the following integral:</p>

<p>

<math display="inline" id="Amplitude-shift_keying:15">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mo>+</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mfrac>
      <mrow>
       <mi>A</mi>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>L</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <msqrt>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
        </mrow>
       </msqrt>
       <msub>
        <mi>σ</mi>
        <mi>N</mi>
       </msub>
      </mrow>
     </mfrac>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mfrac>
        <msup>
         <mi>x</mi>
         <mn>2</mn>
        </msup>
        <mrow>
         <mn>2</mn>
         <msubsup>
          <mi>σ</mi>
          <mi>N</mi>
          <mn>2</mn>
         </msubsup>
        </mrow>
       </mfrac>
      </mrow>
     </msup>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo>erfc</mo>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mi>A</mi>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>0</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msqrt>
         <mn>2</mn>
        </msqrt>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>L</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>σ</mi>
         <mi>N</mi>
        </msub>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <plus></plus>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>A</ci>
          <ci>g</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <minus></minus>
          <ci>L</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <root></root>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>π</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>σ</ci>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>σ</ci>
             <ci>N</ci>
            </apply>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <ci>erfc</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>g</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <root></root>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <minus></minus>
          <ci>L</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>σ</ci>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{+}=\int_{\frac{Ag(0)}{L-1}}^{\infty}\frac{1}{\sqrt{2\pi}\sigma_{N}}e^{-%
\frac{x^{2}}{2\sigma_{N}^{2}}}dx=\frac{1}{2}\operatorname{erfc}\left(\frac{Ag(%
0)}{\sqrt{2}(L-1)\sigma_{N}}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where erfc() is the complementary error function. Putting all these results together, the probability to make an error is:</p>

<p>from this formula we can easily understand that the probability to make an error decreases if the maximum amplitude of the transmitted signal or the amplification of the system becomes greater; on the other hand, it increases if the number of levels or the power of noise becomes greater.</p>

<p>This relationship is valid when there is no intersymbol interference, i.e. g(t) is a Nyquist function.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Frequency-shift_keying" title="wikilink">Frequency-shift keying</a> (FSK)</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.maxim-ic.com/appnotes.cfm/an_pk/2815/CMP/WP-21">Calculating the Sensitivity of an Amplitude Shift Keying (ASK) Receiver</a></li>
</ul>

<p>"</p>

<p><a href="Category:Quantized_radio_modulation_modes" title="wikilink">Category:Quantized radio modulation modes</a> <a href="Category:Applied_probability" title="wikilink">Category:Applied probability</a> <a href="Category:Fault_tolerance" title="wikilink">Category:Fault tolerance</a></p>
</body>
</html>
