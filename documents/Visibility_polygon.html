<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1746">Visibility polygon</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Visibility polygon</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Visibility polygon shown in yellow. Four obstacles are shown in blue.</figcaption>
</figure>

<p>In <a href="computational_geometry" title="wikilink">computational geometry</a>, the <strong>visibility polygon</strong> or <strong>visibility region</strong> for a point <em>p</em> in the plane among obstacles is the possibly unbounded <a href="polygonal_region" title="wikilink">polygonal region</a> of all points of the plane <a href="visible_(geometry)" title="wikilink">visible</a> from <em>p</em>. The visibility polygon can also be defined for visibility from a segment, or a polygon. Visibility polygons are useful in <a class="uri" href="robotics" title="wikilink">robotics</a>, <a href="video_games" title="wikilink">video games</a>, and in determining positions to <a href="facility_location" title="wikilink">locate facilities</a>, such as <a href="art_gallery_problem" title="wikilink">the best placement of security guards in an art gallery</a>.</p>

<p>If the visibility polygon is bounded then it is a <a href="star-shaped_polygon" title="wikilink">star-shaped polygon</a>. A visibility polygon is bounded if all rays shooting from the point eventually terminate in some obstacle. This is the case, e.g., if the obstacles are the edges of a <a href="simple_polygon" title="wikilink">simple polygon</a> and <em>p</em> is inside the polygon. In the latter case the visibility polygon may be found in linear time. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="definitions">Definitions</h2>

<p>Formally, we can define the planar visibility polygon problem as such. Let 

<math display="inline" id="Visibility_polygon:0">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 be a set of obstacles (either segments, or polygons) in 

<math display="inline" id="Visibility_polygon:1">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{2}
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Visibility_polygon:2">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 be a point in 

<math display="inline" id="Visibility_polygon:3">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{2}
  </annotation>
 </semantics>
</math>

 that is not within an obstacle. Then, the <em>point visibility polygon</em> 

<math display="inline" id="Visibility_polygon:4">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is the set of points in 

<math display="inline" id="Visibility_polygon:5">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{2}
  </annotation>
 </semantics>
</math>

, such that for every point 

<math display="inline" id="Visibility_polygon:6">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Visibility_polygon:7">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

, the segment 

<math display="inline" id="Visibility_polygon:8">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pq
  </annotation>
 </semantics>
</math>

 does not intersect any obstacle in 

<math display="inline" id="Visibility_polygon:9">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</p>

<p>Likewise, the <em>segment visibility polygon</em> or <em>edge visibility polygon</em> is the portion visible to any point along a <a href="line_segment" title="wikilink">line segment</a>.</p>
<h2 id="applications">Applications</h2>

<p>Visibility polygons are useful in <a class="uri" href="robotics" title="wikilink">robotics</a>. For example, in <a href="robot_localization" title="wikilink">robot localization</a>, a robot using sensors such as a <a class="uri" href="lidar" title="wikilink">lidar</a> will detect obstacles that it can see, which is similar to a visibility polygon.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>They are also useful in <a href="video_games" title="wikilink">video games</a>, with numerous online tutorials explaining simple algorithms for implementing it.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="algorithms-for-point-visibility-polygons">Algorithms for point visibility polygons</h2>

<p>Numerous algorithms have been proposed for computing the point visibility polygon. For different variants of the problem (e.g. different types of obstacles), algorithms vary in time complexity.</p>
<h3 id="naive-algorithms">Naive algorithms</h3>

<p>Naive algorithms are easy to understand and implement, but they are not <a href="asymptotically_optimal_algorithm" title="wikilink">optimal</a>, since they can be much slower than other algorithms.</p>
<h4 id="uniform-ray-casting-physical-algorithm">Uniform ray casting "physical" algorithm</h4>

<p>In real life, a glowing point illuminates the region visible to it because it emits <a class="uri" href="light" title="wikilink">light</a> in every direction. This can be simulated by shooting <a href="ray_(optics)" title="wikilink">rays</a> in many directions. Suppose that the point is 

<math display="inline" id="Visibility_polygon:10">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and the set of obstacles is 

<math display="inline" id="Visibility_polygon:11">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. Then, the <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> may be expressed in the following way:</p>

<p><code>   </code><strong><code>Algorithm</code> <code>naive_bad_algorithm</code></strong><code>(</code>

<math display="inline" id="Visibility_polygon:12">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

<code>, </code>

<math display="inline" id="Visibility_polygon:13">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

<code>)</code><br/>
<code>       </code>

<math display="inline" id="Visibility_polygon:14">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

<code> := </code>

<math display="inline" id="Visibility_polygon:15">
 <semantics>
  <mi mathvariant="normal">∅</mi>
  <annotation-xml encoding="MathML-Content">
   <emptyset></emptyset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset
  </annotation>
 </semantics>
</math>

<br/>
<code>       for </code>

<math display="inline" id="Visibility_polygon:16">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>θ</ci>
    <list>
     <cn type="integer">0</cn>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta=0,\cdots,2\pi
  </annotation>
 </semantics>
</math>

<code>:</code><br/>
<code>           // shoot a ray with angle </code>

<math display="inline" id="Visibility_polygon:17">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Visibility_polygon:18">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Visibility_polygon:19">
 <semantics>
  <mi mathvariant="normal">∞</mi>
  <annotation-xml encoding="MathML-Content">
   <infinity></infinity>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \infty
  </annotation>
 </semantics>
</math>

</p>

<p><code>           for each obstacle in </code>

<math display="inline" id="Visibility_polygon:20">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

<code>:</code><br/>
<code>               </code>

<math display="inline" id="Visibility_polygon:21">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

<code> := min(</code>

<math display="inline" id="Visibility_polygon:22">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

<code>, distance from </code>

<math display="inline" id="Visibility_polygon:23">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

<code> to the obstacle in this direction)</code><br/>
<code>           add vertex </code>

<math display="inline" id="Visibility_polygon:24">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>θ</mi>
   <mo>,</mo>
   <mi>r</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>θ</ci>
    <ci>r</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\theta,r)
  </annotation>
 </semantics>
</math>

<code> to </code>

<math display="inline" id="Visibility_polygon:25">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

<br/>
<code>       return </code>

<math display="inline" id="Visibility_polygon:26">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

</p>

<p>Now, if it were possible to try all the infinitely many angles, the result would be correct. Unfortunately, it is impossible to really try every single direction due to the limitations of computers. An approximation can be created by casting many, say, 50 rays spaced uniformly apart. However, this is not an exact solution, since small obstacles might be missed by two adjacent rays entirely. Furthermore, it is very slow, since one may have to shoot many rays to gain a roughly similar solution, and the output visibility polygon may have many more vertices in it than necessary.</p>
<h4 id="ray-casting-to-every-vertex">Ray casting to every vertex</h4>

<p>The previously described algorithm can be significantly improved in both speed and correctness by making the observation that it suffices to only shoot rays to every obstacle's vertices. This is because any bends or corners along the boundary of a visibility polygon must be due to some corner (i.e. a vertex) in an obstacle.</p>

<p><code>   </code><strong><code>Algorithm</code> <code>naive_better_algorithm</code></strong><code>(</code>

<math display="inline" id="Visibility_polygon:27">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

<code>, </code>

<math display="inline" id="Visibility_polygon:28">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

<code>)</code><br/>
<code>       </code>

<math display="inline" id="Visibility_polygon:29">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

<code> := </code>

<math display="inline" id="Visibility_polygon:30">
 <semantics>
  <mi mathvariant="normal">∅</mi>
  <annotation-xml encoding="MathML-Content">
   <emptyset></emptyset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset
  </annotation>
 </semantics>
</math>

<br/>
<code>       for each obstacle </code>

<math display="inline" id="Visibility_polygon:31">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

<code> in </code>

<math display="inline" id="Visibility_polygon:32">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

<code>:</code><br/>
<code>           for each vertex </code>

<math display="inline" id="Visibility_polygon:33">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

<code> of </code>

<math display="inline" id="Visibility_polygon:34">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

<code>:</code><br/>
<code>               // shoot a ray from </code>

<math display="inline" id="Visibility_polygon:35">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

<code> to </code>

<math display="inline" id="Visibility_polygon:36">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Visibility_polygon:37">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 := distance from 

<math display="inline" id="Visibility_polygon:38">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Visibility_polygon:39">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Visibility_polygon:40">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 := angle of 

<math display="inline" id="Visibility_polygon:41">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 with respect to 

<math display="inline" id="Visibility_polygon:42">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

</p>

<p><code>               for each obstacle </code>

<math display="inline" id="Visibility_polygon:43">
 <semantics>
  <msup>
   <mi>b</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>b</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{\prime}
  </annotation>
 </semantics>
</math>

<code> in </code>

<math display="inline" id="Visibility_polygon:44">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

<code>:</code><br/>
<code>                   </code>

<math display="inline" id="Visibility_polygon:45">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

<code> := min(</code>

<math display="inline" id="Visibility_polygon:46">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

<code>, distance from </code>

<math display="inline" id="Visibility_polygon:47">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

<code> to </code>

<math display="inline" id="Visibility_polygon:48">
 <semantics>
  <msup>
   <mi>b</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>b</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{\prime}
  </annotation>
 </semantics>
</math>

<code>)</code><br/>
<code>               add vertex </code>

<math display="inline" id="Visibility_polygon:49">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>θ</mi>
   <mo>,</mo>
   <mi>r</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>θ</ci>
    <ci>r</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\theta,r)
  </annotation>
 </semantics>
</math>

<code> to </code>

<math display="inline" id="Visibility_polygon:50">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

<br/>
<code>       return </code>

<math display="inline" id="Visibility_polygon:51">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

</p>

<p>The time complexity of this algorithm is 

<math display="inline" id="Visibility_polygon:52">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

. This is because the algorithm shoots a ray to every one of the 

<math display="inline" id="Visibility_polygon:53">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 vertices, and to check where the ray ends, it has to check for intersection with every one of the 

<math display="inline" id="Visibility_polygon:54">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 obstacles. This is sufficient for many simple applications such as video games, and as such many online tutorials teach this method.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> However, as we shall see later, there are faster 

<math display="inline" id="Visibility_polygon:55">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log n)
  </annotation>
 </semantics>
</math>

 algorithms (or even faster ones if the obstacle is a simple polygon or if there are a fixed number of polygonal holes).</p>
<h3 id="optimal-algorithms-for-a-point-in-a-simple-polygon">Optimal algorithms for a point in a simple polygon</h3>

<p> Given a simple polygon 

<math display="inline" id="Visibility_polygon:56">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 and a point 

<math display="inline" id="Visibility_polygon:57">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, a <a href="linear_time" title="wikilink">linear time</a> algorithm is optimal for computing the region in 

<math display="inline" id="Visibility_polygon:58">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 that is visible from 

<math display="inline" id="Visibility_polygon:59">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. Such an algorithm was first proposed in 1981.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> However, it is quite complicated. In 1983, a conceptually simpler algorithm was proposed,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> which had a minor error that was corrected in 1987.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>The latter algorithm will be briefly explained here. It simply walks around the boundary of the polygon 

<math display="inline" id="Visibility_polygon:60">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

, processing the vertices in the order in which they appear, while maintaining a <a href="Stack_(abstract_data_type)" title="wikilink">stack</a> of vertices 

<math display="inline" id="Visibility_polygon:61">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>s</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mi>t</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒮</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}=s_{0},s_{1},\cdots,s_{t}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Visibility_polygon:62">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{t}
  </annotation>
 </semantics>
</math>

 is the top of the stack. The stack constitutes the vertices encountered so far which are visible to 

<math display="inline" id="Visibility_polygon:63">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. If, later during the execution of the algorithm, some new vertices are encountered that obscure part of 

<math display="inline" id="Visibility_polygon:64">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

, then the obscured vertices in 

<math display="inline" id="Visibility_polygon:65">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 will be popped from the stack. By the time the algorithm terminates, 

<math display="inline" id="Visibility_polygon:66">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 will consist of all the visible vertices, i.e. the desired visibility polygon. An efficient implementation was published in 2014.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="optimal-algorithms-for-a-point-in-a-polygon-with-holes">Optimal algorithms for a point in a polygon with holes</h3>

<p>For a point in a polygon with 

<math display="inline" id="Visibility_polygon:67">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 holes and 

<math display="inline" id="Visibility_polygon:68">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 vertices in total, it can be shown that in the worst case, a 

<math display="inline" id="Visibility_polygon:69">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mi>log</mi>
       <mi>h</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <log></log>
       <ci>h</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n+h\log h)
  </annotation>
 </semantics>
</math>

 algorithm is optimal. Such an algorithm was proposed in 1995 together with its proof of optimality.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> However, it relies on the linear time <a href="polygon_triangulation" title="wikilink">polygon triangulation</a> algorithm by Chazelle, which is extremely complex.</p>
<h3 id="optimal-algorithms-for-a-point-among-segments">Optimal algorithms for a point among segments</h3>
<h4 id="segments-that-do-not-intersect-except-at-their-endpoints">Segments that do not intersect except at their endpoints</h4>

<p> For a point among a set of 

<math display="inline" id="Visibility_polygon:70">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 segments that do not intersect except at their endpoints, it can be shown that in the worst case, a 

<math display="inline" id="Visibility_polygon:71">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n\log n)
  </annotation>
 </semantics>
</math>

 algorithm is optimal. This is because a visibility polygon algorithm must output the vertices of the visibility polygon in sorted order, hence the problem of <a href="sorting_algorithm" title="wikilink">sorting</a> can be reduced to computing a visibility polygon.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>Notice that any algorithm that computes a visibility polygon for a point among segments can be used to compute a visibility polygon for all other kinds of polygonal obstacles, since any polygon can be decomposed into segments.</p>
<h5 id="divide-and-conquer">Divide and conquer</h5>

<p>A <a href="divide_and_conquer_algorithm" title="wikilink">divide and conquer algorithm</a> to compute the visibility polygon was proposed in 1987.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h5 id="angular-sweep">Angular sweep</h5>

<p>An <em>angular sweep</em>, i.e. rotational <a href="sweep_line_algorithm" title="wikilink">plane sweep</a> algorithm to compute the visibility polygon was proposed in 1985<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> and 1986.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> The idea is to first sort all the segment endpoints by polar angle, and then iterate over them in that order. During the iteration, the event line is maintained as a <a href="heap_(data_structure)" title="wikilink">heap</a>. An efficient implementation was published in 2014.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h4 id="generally-intersecting-segments">Generally intersecting segments</h4>

<p>For a point among generally intersecting segments, the visibility polygon problem is reducible, in linear time, to the <a href="lower_envelope" title="wikilink">lower envelope</a> problem. By the <a href="Davenport–Schinzel_sequence#Application_to_lower_envelopes" title="wikilink">Davenport–Schinzel argument</a>, the lower envelope in the worst case has 

<math display="inline" id="Visibility_polygon:72">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>α</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>α</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n\alpha(n))
  </annotation>
 </semantics>
</math>

 number of vertices, where 

<math display="inline" id="Visibility_polygon:73">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(n)
  </annotation>
 </semantics>
</math>

 is the <a href="inverse_Ackermann_function" title="wikilink">inverse Ackermann function</a>. A worst case optimal divide-and-conquer algorithm running in 

<math display="inline" id="Visibility_polygon:74">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n\log n)
  </annotation>
 </semantics>
</math>

 time was created by <a href="John_Hershberger" title="wikilink">John Hershberger</a> in 1989.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="external-links">External links</h2>

<p><a class="uri" href="http://web.informatik.uni-bonn.de/I/GeomLab/VisPolygon/index.html.en">http://web.informatik.uni-bonn.de/I/GeomLab/VisPolygon/index.html.en</a> (visibility in simple polygons - applets)</p>
<h3 id="software">Software</h3>
<ul>
<li><a href="http://www.VisiLibity.org">VisiLibity: A free open source C++ library of floating-point visibility algorithms and supporting data types</a>, calculates visibility polygons in polygonal environments with polygonal holes</li>
<li><a href="https://github.com/byronknoll/visibility-polygon-js">visibility-polygon-js: A public domain Javascript library for computing a visibility polygon for a point among segments using the angular sweep method</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a class="uri" href="Category:Polygons" title="wikilink">Category:Polygons</a> <a href="Category:Geometric_algorithms" title="wikilink">Category:Geometric algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
