   Intuitionistic type theory      Intuitionistic type theory   Intuitionistic type theory (also known as constructive type theory , or Martin-L√∂f type theory ) is a type theory and an alternative foundation of mathematics based on the principles of mathematical constructivism . Intuitionistic type theory was introduced by Per Martin-L√∂f , a Swedish  mathematician and philosopher , in 1972. Martin-L√∂f has modified his proposal a few times; his 1971 impredicative formulation was inconsistent as demonstrated by Girard's paradox . Later formulations were predicative . He proposed both intensional and extensional variants of the theory.  Intuitionistic type theory is based on a certain analogy or isomorphism between propositions and types : a proposition is identified with the type of its proofs. This identification is usually called the Curry‚ÄìHoward isomorphism , which was originally formulated for intuitionistic logic and simply typed lambda calculus . Type theory extends this identification to predicate logic by introducing dependent types , that is types which contain values.  Type theory internalizes the interpretation of intuitionistic logic proposed by Brouwer , Heyting and Kolmogorov , the so-called BHK interpretation . The types in type theory play a similar role to sets in set theory but functions definable in type theory are always computable.  Connectives of type theory  In the context of type theory a connective is a way of constructing types, possibly using already given types. The basic connectives of type theory are:  Œ†-types  Œ†-types, also called dependent product types, are analogous to the indexed products of sets. As such, they generalize the normal function space to model functions whose result type may vary on their input. E.g. writing    Vec   (  ‚Ñù  ,  n  )      Vec  ‚Ñù  n    \operatorname{Vec}({\mathbb{R}},n)   for the type of n -tuples of real numbers and   ‚Ñï   ‚Ñï   \mathbb{N}   for the type of natural numbers ,       ‚àè   :   n  ,  ‚Ñï      Vec   (  ‚Ñù  ,  n  )        subscript  product   normal-:  n  ‚Ñï     Vec  ‚Ñù  n     \prod_{n\mathbin{:}{\mathbb{N}}}\operatorname{Vec}({\mathbb{R}},n)     stands for the type of a function that, given a natural number n , returns an n -tuple of real numbers. The usual function space arises as a special case when the range type does not actually depend on the input, e.g.,     ‚àè   :   n  ,  ‚Ñï     ‚Ñù      subscript  product   normal-:  n  ‚Ñï    ‚Ñù    \prod_{n\mathbin{:}{\mathbb{N}}}{\mathbb{R}}   is the type of functions from natural numbers to the real numbers, which is also written as    ‚Ñï  ‚Üí  ‚Ñù     normal-‚Üí  ‚Ñï  ‚Ñù    {\mathbb{N}}\to{\mathbb{R}}   .  Using the Curry‚ÄìHoward isomorphism Œ†-types also serve to model implication and universal quantification : e.g., a term inhabiting       ‚àè   m  ,   :   n  ,  ‚Ñï       (  m  +  n  =  n  +  m  )      fragments   subscript  product   m   normal-:  n  ‚Ñï      fragments  normal-(  m   n   n   m  normal-)     \prod_{m,n\mathbin{:}{\mathbb{N}}}(m+n=n+m)     is a function which assigns to any pair of natural numbers a proof that addition is commutative for that pair and hence can be considered as a proof that addition is commutative for all natural numbers. (Here we have used the equality type (    x  =  y      x  y    x=y   ) as explained below.)  Œ£-types  Œ£-types, also called dependent sum types, are analogous to the indexed disjoint unions of sets. As such, they generalize the usual Cartesian product to model pairs where the type of the second component depends on the first. For example, the type     ‚àë   :   n  ,  ‚Ñï      Vec   (  ‚Ñù  ,  n  )        subscript    normal-:  n  ‚Ñï     Vec  ‚Ñù  n     \sum_{n\mathbin{:}{\mathbb{N}}}\operatorname{Vec}({\mathbb{R}},n)   stands for the type of pairs of a natural number   n   n   n   and an   n   n   n   -tuple of real numbers, i.e., this type can be used to model sequences of arbitrary but finite length (usually called lists). The conventional Cartesian product type arises as a special case when the type of the second component doesn't actually depend on the first, e.g.,     ‚àë   :   n  ,  ‚Ñï     ‚Ñù      subscript    normal-:  n  ‚Ñï    ‚Ñù    \sum_{n\mathbin{:}{\mathbb{N}}}{\mathbb{R}}   is the type of pairs of a natural number and a real number , which is also written as    ‚Ñï  √ó  ‚Ñù      ‚Ñï  ‚Ñù    {\mathbb{N}}\times{\mathbb{R}}   .  Again, using the Curry‚ÄìHoward isomorphism , Œ£-types also serve to model conjunction and existential quantification .  Finite types  Of special importance are 0 or ‚ä• (the empty type ), 1 or ‚ä§ (the unit type ) and 2 (the type of Booleans or classical truth values ). Invoking the Curry‚ÄìHoward isomorphism again, ‚ä• stands for false and ‚ä§ for true .  Using finite types we can define negation as        ¬¨  A   ‚â°  A  ‚Üí  ‚ä•   .           A   A    normal-‚Üí    bottom     \neg A\equiv A\to\bot.     Equality type  Given    a  ,   :   b  ,  A       a   normal-:  b  A     a,b\mathbin{:}A   , the expression    a  =  b      a  b    a=b   denotes the type of equality proofs for   a   a   a   is equal to   b   b   b   . That is, if    a  =  b      a  b    a=b   is inhabited, then   a   a   a   is said to be equal to   b   b   b   . There is only one (canonical) inhabitant of    a  =  a      a  a    a=a   and this is the proof of reflexivity      refl  :   ‚àè   :   a  ,  A      (  a  =  a  )   .     fragments  refl  normal-:   subscript  product   normal-:  a  A     fragments  normal-(  a   a  normal-)   normal-.    \operatorname{refl}\mathbin{:}\prod_{a\mathbin{:}A}(a=a).     Examination of the properties of the equality type, or rather, extending it to a notion of equivalence, lead to homotopy type theory .  Inductive types  A prime example of an inductive type is the type of natural numbers    ‚Ñï   ‚Ñï   \mathbb{N}   which is generated by    :   0  ,  ‚Ñï      normal-:  0  ‚Ñï    0\mathbin{:}{\mathbb{N}}   and     :   succ  ,  ‚Ñï    ‚Üí  ‚Ñï     normal-‚Üí   normal-:  succ  ‚Ñï   ‚Ñï    \operatorname{succ}\mathbin{:}{\mathbb{N}}\to{\mathbb{N}}   . An important application of the propositions as types principle is the identification of (dependent) primitive recursion and induction by one elimination constant:        ‚Ñï  -  elim    :  P   (  0  )   ‚Üí   (   ‚àè   :   n  ,  ‚Ñï     P   (  n  )   ‚Üí  P   (  succ   (  n  )   )   )   ‚Üí   ‚àè   :   n  ,  ‚Ñï     P   (  n  )      fragments    ‚Ñï  elim   normal-:  P   fragments  normal-(  0  normal-)   normal-‚Üí   fragments  normal-(   subscript  product   normal-:  n  ‚Ñï    P   fragments  normal-(  n  normal-)   normal-‚Üí  P   fragments  normal-(  succ   fragments  normal-(  n  normal-)   normal-)   normal-)   normal-‚Üí   subscript  product   normal-:  n  ‚Ñï    P   fragments  normal-(  n  normal-)     {\operatorname{{\mathbb{N}}-elim}}\,\mathbin{:}P(0)\,\to\left(\prod_{n\mathbin%
 {:}{\mathbb{N}}}P(n)\to P(\operatorname{succ}(n))\right)\to\prod_{n\mathbin{:}%
 {\mathbb{N}}}P(n)     for any given type    P   (  n  )       P  n    P(n)   indexed by    :   n  ,  ‚Ñï      normal-:  n  ‚Ñï    n\mathbin{:}{\mathbb{N}}   . In general inductive types can be defined in terms of W-types, the type of well-founded trees.  An important class of inductive types are inductive families like the type of vectors    Vec   (  A  ,  n  )      Vec  A  n    \operatorname{Vec}(A,n)   mentioned above, which is inductively generated by the constructors    :   vnil  ,   Vec   (  A  ,  0  )        normal-:  vnil   Vec  A  0     \operatorname{vnil}\mathbin{:}\operatorname{Vec}(A,0)   and         :    vcons  ,  A    ‚Üí    ‚àè   :   n  ,  ‚Ñï      Vec   (  A  ,  n  )     ‚Üí   Vec   (  A  ,   succ   (  n  )    )     .       normal-‚Üí   normal-:  vcons  A     subscript  product   normal-:  n  ‚Ñï     Vec  A  n      normal-‚Üí     Vec  A   succ  n       \operatorname{vcons}\,\mathbin{:}\,A\to\prod_{n\mathbin{:}{\mathbb{N}}}%
 \operatorname{Vec}(A,n)\to\operatorname{Vec}(A,\operatorname{succ}(n)).     Applying the Curry‚ÄìHoward isomorphism once more, inductive families correspond to inductively defined relations.  Universes  An example of a universe is    ùí∞  0     subscript  ùí∞  0    \mathcal{U}_{0}   , the universe of all small types, which contains names for all the types introduced so far. To every name    :   a  ,   ùí∞  0       normal-:  a   subscript  ùí∞  0     a\mathbin{:}\mathcal{U}_{0}   we associate a type    El   (  a  )      El  a    \operatorname{El}(a)   , its extension or meaning. It is standard to assume a predicative hierarchy of universes    ùí∞  n     subscript  ùí∞  n    \mathcal{U}_{n}   for every natural number    :   n  ,  ‚Ñï      normal-:  n  ‚Ñï    n\mathbin{:}{\mathbb{N}}   , where the universe    ùí∞   n  +  1      subscript  ùí∞    n  1     \mathcal{U}_{n+1}   contains a code for the previous universe, i.e., we have    :    u  n   ,   ùí∞   n  +  1        normal-:   subscript  u  n    subscript  ùí∞    n  1      u_{n}\mathbin{:}\mathcal{U}_{n+1}   with     El   (   u  n   )    ‚â°   ùí∞  n        El   subscript  u  n     subscript  ùí∞  n     \operatorname{El}(u_{n})\equiv\mathcal{U}_{n}   . (A hierarchy with this property is called "cumulative".)  Stronger universe principles have been investigated, i.e., super universes and the Mahlo universe. In 1992 Huet and Coquand introduced the calculus of constructions , a type theory with an impredicative universe, thus combining type theory with Girard 's System F . This extension is not universally accepted by Intuitionists since it allows impredicative, i.e., circular, constructions, which are often identified with classical reasoning.  Formalisation of type theory  This formalization is based on the discussion in Nordstr√∂m, Petersson, and Smith.  The formal theory works with types and objects .  A type is declared by:        A   ùñ≥ùóíùóâùñæ      A  ùñ≥ùóíùóâùñæ    A\ \mathsf{Type}      An object exists and is in a type if:       :   a  ,  A      normal-:  a  A    a\mathbin{:}A      Objects can be equal       a  =  b      a  b    a=b      and types can be equal       A  =  B      A  B    A=B      A type that depends on an object from another type is declared        (   :   x  ,  A    )   B       normal-:  x  A   B    (x\mathbin{:}A)B      and removed by substitution       B   [   x  /  a   ]       B   delimited-[]    x  a      B[x/a]   , replacing the variable   x   x   x   with the object   a   a   a   in   B   B   B   .   An object that depends on an object from another type can be done two ways. If the object is "abstracted", then it is written        [  x  ]   b       delimited-[]  x   b    [x]b      and removed by substitution       b   [   x  /  a   ]       b   delimited-[]    x  a      b[x/a]   , replacing the variable   x   x   x   with the object   a   a   a   in   b   b   b   .   The object-depending-on-object can also be declared as a constant as part of a recursive type. An example of a recursive type is:       :   0  ,  ‚Ñï      normal-:  0  ‚Ñï    0\mathbin{:}\mathbb{N}          :   succ  ,  ‚Ñï    ‚Üí  ‚Ñï     normal-‚Üí   normal-:  succ  ‚Ñï   ‚Ñï    \operatorname{succ}\mathbin{:}\mathbb{N}\to\mathbb{N}      Here,   succ   succ   \operatorname{succ}   is a constant object-depending-on-object. It is not associated with an abstraction. Constants like   succ   succ   \operatorname{succ}   can be removed by defining equality. Here the relationship with addition is defined using equality and using pattern matching to handle the recursive aspect of   succ   succ   \operatorname{succ}   :     add   add   \displaystyle\operatorname{add}      succ   succ   \operatorname{succ}   is manipulated as an opaque constant - it has no internal structure for substitution.  So, objects and types and these relations are used to express formulae in the theory. The following styles of judgements are used to create new objects, types and relations from existing ones:          Œì  ‚ä¢    œÉ   ùñ≥ùóíùóâùñæ      proves  normal-Œì    œÉ  ùñ≥ùóíùóâùñæ     \Gamma\vdash\sigma\ \mathsf{Type}      œÉ is a well-formed type in the context Œì.         Œì  ‚ä¢   :   t  ,  œÉ       proves  normal-Œì   normal-:  t  œÉ     \Gamma\vdash t\mathbin{:}\sigma      t is a well-formed term of type œÉ in context Œì.         Œì  ‚ä¢   œÉ  ‚â°  œÑ      proves  normal-Œì    œÉ  œÑ     \Gamma\vdash\sigma\equiv\tau      œÉ and œÑ are equal types in context Œì.         Œì  ‚ä¢   t  ‚â°   :   u  ,  œÉ        proves  normal-Œì    t   normal-:  u  œÉ      \Gamma\vdash t\equiv u\mathbin{:}\sigma      t and u are judgmentally equal terms of type œÉ in context Œì.          ‚ä¢    Œì   ùñ¢ùóàùóáùóçùñæùóëùóç      proves  absent    normal-Œì  ùñ¢ùóàùóáùóçùñæùóëùóç     \vdash\Gamma\ \mathsf{Context}      Œì is a well-formed context of typing assumptions.     By convention, there is a type that represents all other types. It is called   ùí∞   ùí∞   \mathcal{U}   (or   Set   Set   \operatorname{Set}   ). Since   ùí∞   ùí∞   \mathcal{U}   is a type, the member of it are objects. There is a dependent type   El   El   \operatorname{El}   that maps each object to its corresponding type. In most texts   El   El   \operatorname{El}   is never written. From the context of the statement, a reader can almost always tell whether   A   A   A   refers to a type, or whether it refers to the object in   ùí∞   ùí∞   \mathcal{U}   that corresponds to the type.  This is the complete foundation of the theory. Everything else is derived.  To implement logic, each proposition is given its own type. The objects in those types represent the different possible ways to prove the proposition. Obviously, if there is no proof for the proposition, then the type has no objects in it. Operators like "and" and "or" that work on propositions introduce new types and new objects. So    A  √ó  B      A  B    A\times B   is a type that depends on the type   A   A   A   and the type   B   B   B   . The objects in that dependent type are defined to exist for every pair of objects in   A   A   A   and   B   B   B   . Obviously, if   A   A   A   or   B   B   B   has no proof and is an empty type, then the new type representing    A  √ó  B      A  B    A\times B   is also empty.  This can be done for other types (booleans, natural numbers, etc.) and their operators.  Categorical models of type theory  Using the language of category theory , R.A.G. Seely introduced the notion of a locally cartesian closed category (LCCC) as the basic model of type theory. This has been refined by Hofmann and Dybjer to Categories with Families or Categories with Attributes based on earlier work by Cartmell.  A category with families is a category C of contexts (in which the objects are contexts, and the context morphisms are substitutions), together with a functor T : C op ‚Üí Fam(Set) .  Fam(Set) is the category of families of Sets, in which objects are pairs (A,B) of an "index set" A and a function B : X ‚Üí A , and morphisms are pairs of functions f : A ‚Üí ''A' '' and g : X ‚Üí ''X' '', such that ''B' '' ¬∞  g = f  ¬∞  B - in other words, f maps B a to B' g(a) .  The functor T assigns to a context G a set Ty(G) of types, and for each A : Ty(G) , a set Tm(G,A) of terms. The axioms for a functor require that these play harmoniously with substitution. Substitution is usually written in the form Af or af , where A is a type in Ty(G) and a is a term in Tm(G,A) , and f is a substitution from D to G . Here Af : Ty(D) and af : Tm(D,Af) .  The category C must contain a terminal object (the empty context), and a final object for a form of product called comprehension, or context extension, in which the right element is a type in the context of the left element. If G is a context, and A : Ty(G) , then there should be an object (G,A) final among contexts D with mappings p : ''D ‚Üí G , q : Tm(D,Ap) .  A logical framework, such as Martin-L√∂f's takes the form of closure conditions on the context dependent sets of types and terms: that there should be a type called Set, and for each set a type, that the types should be closed under forms of dependent sum and product, and so forth.  A theory such as that of predicative set theory expresses closure conditions on the types of sets and their elements: that they should be closed under operations that reflect dependent sum and product, and under various forms of inductive definition.  Extensional versus intensional  A fundamental distinction is extensional vs intensional type theory. In extensional type theory definitional (i.e., computational) equality is not distinguished from propositional equality, which requires proof. As a consequence type checking becomes undecidable in extensional type theory because programs in the theory might not terminate. For example, such a theory allows one to give a type to Y-Combinator , a detailed example of this can be found in. 1 However, this doesn't prevent extensional type theory from being a basis for a practical tool, for example, NuPRL is based on extensional type theory. From a practical standpoint there's no difference between a program which doesn't terminate and a program which takes a million years to terminate.  In contrast in intensional type theory type checking is decidable , but the representation of standard mathematical concepts is somewhat more cumbersome, since extensional reasoning requires using setoids or similar constructions. There are many common mathematical objects, which are hard to work with or can't be represented without this, for example, integer numbers , rational numbers , and real numbers . Integers and rational numbers can be represented without setoids, but this representation isn't easy to work with. Real numbers can't be represented without this see. 2  Homotopy type theory works on resolving this problem. It allows one to define higher inductive types , which not only define first order constructors ( values or points ), but higher order constructors, i.e. equalities between elements ( paths ), equalities between equalities ( homotopies ), ad infinitum .  Implementations of type theory  Type theory has been the base of a number of proof assistants, such as NuPRL , LEGO and Coq . Recently, dependent types also featured in the design of programming languages such as ATS , Cayenne , Epigram , Agda , and Idris .  See also   Calculus of constructions  Intuitionistic logic  Per Martin-L√∂f  Type theory  Typed lambda calculus   References   Per Martin-L√∂f (1984). Intuitionistic Type Theory Bibliopolis. ISBN 88-7088-105-9.   Further reading   Bengt Nordstr√∂m; Kent Petersson; Jan M. Smith (1990). Programming in Martin-L√∂f's Type Theory . Oxford University Press. The book is out of print, but a free version can be picked up from here .  Thompson, Simon (1991). Type Theory and Functional Programming Addison-Wesley. ISBN 0-201-41667-0.  Granstr√∂m, Johan G. (2011). Treatise on Intuitionistic Type Theory Springer. ISBN 978-94-007-1735-0.   External links   EU Types Project: Tutorials - lecture notes and slides from the Types Summer School 2005  n-Categories - Sketch of a Definition - letter from John Baez and James Dolan to Ross Street, November 29, 1995   References  "  Category:Dependently typed programming  Category:Constructivism (mathematics)  Category:Type theory  Category:Logic in computer science  Category:Intuitionism     Bengt Nordstr√∂m; Kent Petersson; Jan M. Smith (1990). Programming in Martin-L√∂f's Type Theory . Oxford University Press p.90 ‚Ü©  Altenkirch, Thorsten, Thomas Anberr√©e, and Nuo Li. "Definable Quotients in Type Theory." ‚Ü©     