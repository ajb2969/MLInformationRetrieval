   Berlekamp–Massey algorithm      Berlekamp–Massey algorithm  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     The Berlekamp–Massey algorithm is an algorithm that will find the shortest linear feedback shift register (LFSR) for a given binary output sequence. The algorithm will also find the minimal polynomial of a linearly recurrent sequence in an arbitrary field . The field requirement means that the Berlekamp–Massey algorithm requires all non-zero elements to have a multiplicative inverse. 1 Reeds and Sloane offer an extension to handle a ring . 2  Elwyn Berlekamp invented an algorithm for decoding Bose–Chaudhuri–Hocquenghem (BCH) codes . 3 4  James Massey recognized its application to linear feedback shift registers and simplified the algorithm. 5 6 Massey termed the algorithm the LFSR Synthesis Algorithm (Berlekamp Iterative Algorithm), 7 but it is now known as the Berlekamp–Massey algorithm.  Description of algorithm  The Berlekamp–Massey algorithm is an alternate method to solve the set of linear equations described in Reed–Solomon Peterson decoder , which can be summarized as:        S   i  +  ν    +    Λ  1    S    i  +  ν   -  1     +  ⋯  +    Λ   ν  -  1     S   i  +  1     +    Λ  ν    S  i     =  0.         subscript  S    i  ν       subscript  normal-Λ  1    subscript  S      i  ν   1     normal-⋯     subscript  normal-Λ    ν  1     subscript  S    i  1        subscript  normal-Λ  ν    subscript  S  i     0.    S_{i+\nu}+\Lambda_{1}S_{i+\nu-1}+\cdots+\Lambda_{\nu-1}S_{i+1}+\Lambda_{\nu}S_%
 {i}=0.     In the code examples below, C(x) is a potential instance of Λ(x). The error locator polynomial C(x) for L errors is defined as:       C   (  x  )    =      C  L     x  L    +     C   L  -  1      x   L  -  1     +  ⋯  +     C  2     x  2    +     C  1    x   +  1         C  x        subscript  C  L    superscript  x  L       subscript  C    L  1     superscript  x    L  1     normal-⋯     subscript  C  2    superscript  x  2       subscript  C  1   x   1     C(x)=C_{L}\ x^{L}+C_{L-1}\ x^{L-1}+\cdots+C_{2}\ x^{2}+C_{1}\ x+1     or reversed:        C   (  x  )    =   1  +     C  1    x   +     C  2     x  2    +  ⋯  +     C   L  -  1      x   L  -  1     +     C  L     x  L      .        C  x     1     subscript  C  1   x      subscript  C  2    superscript  x  2    normal-⋯     subscript  C    L  1     superscript  x    L  1        subscript  C  L    superscript  x  L       C(x)=1+C_{1}\ x+C_{2}\ x^{2}+\cdots+C_{L-1}\ x^{L-1}+C_{L}\ x^{L}.     The goal of the algorithm is to determine the minimal degree L and C(x) which results in:        S  n   +     C  1     S   n  -  1     +  ⋯  +     C  L     S   n  -  L      =  0         subscript  S  n      subscript  C  1    subscript  S    n  1     normal-⋯     subscript  C  L    subscript  S    n  L      0    S_{n}+C_{1}\ S_{n-1}+\cdots+C_{L}\ S_{n-L}=0     for all syndromes, n = L to ( N -1).  Algorithm: C(x) is initialized to 1, L is the current number of assumed errors, and initialized to zero. N is the total number of syndromes. n is used as the main iterator and to index the syndromes from 0 to ( N -1). B(x) is a copy of the last C(x) since L was updated and initialized to 1. b is a copy of the last discrepancy d (explained below) since L was updated and initialized to 1. m is the number of iterations since L , B(x), and b were updated and initialized to 1.  Each iteration of the algorithm calculates a discrepancy d . At iteration k this would be:       d  =    S  k   +     C  1     S   k  -  1     +  ⋯  +     C  L     S   k  -  L       .      d     subscript  S  k      subscript  C  1    subscript  S    k  1     normal-⋯     subscript  C  L    subscript  S    k  L        d=S_{k}+C_{1}\ S_{k-1}+\cdots+C_{L}\ S_{k-L}.     If d is zero, the algorithm assumes that C(x) and L are correct for the moment, increments m , and continues.  If d is not zero, the algorithm adjusts C(x) so that a recalculation of d would be zero:        C   (  x  )    =    C   (  x  )    -    (   d  /  b   )     x  m    B   (  x  )      .        C  x       C  x       d  b    superscript  x  m   B  x      C(x)=C(x)\ -\ (d/b)\ x^{m}\ B(x).     The x m term shifts B(x) so it follows the syndromes corresponding to 'b'. If the previous update of L occurred on iteration j , then m = k - j , and a recalculated discrepancy would be:       d  =     S  k   +     C  1     S   k  -  1     +  ⋯   -    (   d  /  b   )    (    S  j   +     B  1     S   j  -  1     +  ⋯   )      .      d       subscript  S  k      subscript  C  1    subscript  S    k  1     normal-⋯       d  b      subscript  S  j      subscript  B  1    subscript  S    j  1     normal-⋯       d=S_{k}+C_{1}\ S_{k-1}+\cdots-(d/b)(S_{j}+B_{1}\ S_{j-1}+\cdots).     This would change a recalculated discrepancy to:      d  =   d  -    (   d  /  b   )   b    =   d  -  d   =  0.        d    d      d  b   b           d  d        0.     d=d-(d/b)b=d-d=0.     The algorithm also needs to increase L (number of errors) as needed. If L equals the actual number of errors, then during the iteration process, the discrepancies will become zero before n becomes greater than or equal to (2 L ). Otherwise L is updated and algorithm will update B(x), b, increase L, and reset m = 1. The L = (n + 1 - L) formula limits L to the number of available syndromes used to calculate discrepancies, and also handles the case where L increases by more than 1.  The algorithm for the binary field  The following is the Berlekamp–Massey algorithm specialized for the typical binary finite field F 2 and GF(2). The field elements are 0 and 1. The field operations + and − are identical and become the exclusive or operation, XOR. The multiplication operator * becomes the logical AND operation. The division operator reduces to the identity operation (i.e., field division is only defined for dividing by 1, and x/1 = x).   Let     s  0   ,   s  1   ,    s  2   ⋯   s   n  -  1         subscript  s  0    subscript  s  1      subscript  s  2   normal-⋯   subscript  s    n  1       s_{0},s_{1},s_{2}\cdots s_{n-1}   be the bits of the stream.  Initialise two arrays   b   b   b   and   c   c   c   each of length   n   n   n   to be zeroes, except      b  0   ←  1   ,    c  0   ←  1      formulae-sequence   normal-←   subscript  b  0   1    normal-←   subscript  c  0   1     b_{0}\leftarrow 1,c_{0}\leftarrow 1     assign      L  ←  0   ,   m  ←   -  1       formulae-sequence   normal-←  L  0    normal-←  m    1      L\leftarrow 0,m\leftarrow-1   .  For     N  =  0      N  0    N=0    step 1 while     N  <  n      N  n    N   :  Let   d   d   d   be     s  N   +    c  1    s   N  -  1     +    c  2    s   N  -  2     +  ⋯  +    c  L    s   N  -  L          subscript  s  N      subscript  c  1    subscript  s    N  1        subscript  c  2    subscript  s    N  2     normal-⋯     subscript  c  L    subscript  s    N  L       s_{N}+c_{1}s_{N-1}+c_{2}s_{N-2}+\cdots+c_{L}s_{N-L}   .  if     d  =  0      d  0    d=0   , then    c   c   c   is already a polynomial which annihilates the portion of the stream from    N  -  L      N  L    N-L   to   N   N   N   .  else :  Let   t   t   t   be a copy of   c   c   c   .  Set      c   N  -  m    ←    c   N  -  m    ⊕   b  0     ,    c    N  -  m   +  1    ←     c    N  -  m   +  1    ⊕   b  1    ,  …       formulae-sequence   normal-←   subscript  c    N  m     direct-sum   subscript  c    N  m     subscript  b  0      normal-←   subscript  c      N  m   1      direct-sum   subscript  c      N  m   1     subscript  b  1    normal-…      c_{N-m}\leftarrow c_{N-m}\oplus b_{0},c_{N-m+1}\leftarrow c_{N-m+1}\oplus b_{1%
 },\dots   up to     c   n  -  1    ←    c   n  -  1    ⊕   b     n  -  N   +  m   -  1        normal-←   subscript  c    n  1     direct-sum   subscript  c    n  1     subscript  b        n  N   m   1       c_{n-1}\leftarrow c_{n-1}\oplus b_{n-N+m-1}   (where   ⊕   direct-sum   \oplus   is the Exclusive or operator).  If    L  ≤   N  2       L    N  2     L\leq\frac{N}{2}   , set    L  ←    N  +  1   -  L      normal-←  L      N  1   L     L\leftarrow N+1-L   , set    m  ←  N     normal-←  m  N    m\leftarrow N   , and let    b  ←  t     normal-←  b  t    b\leftarrow t   ; otherwise leave   L   L   L   ,   m   m   m   and   b   b   b   alone.     At the end of the algorithm,   L   L   L   is the length of the minimal LFSR for the stream, and we have       c  L    s  a    +    c   L  -  1     s   a  +  1     +    c   L  -  2     s   a  +  2     +  ⋯   =  0           subscript  c  L    subscript  s  a       subscript  c    L  1     subscript  s    a  1        subscript  c    L  2     subscript  s    a  2     normal-⋯   0    c_{L}s_{a}+c_{L-1}s_{a+1}+c_{L-2}s_{a+2}+\cdots=0   for all   a   a   a   .  Code sample for the binary field in Java  The following code sample is for a binary field.   public  static  int  runTest ( int [] array) { final  int N = array. length ; int [] b = new  int [N]; int [] c = new  int [N]; int [] t = new  int [N];
         b[ 0 ] = 1 ;
         c[ 0 ] = 1 ; int l = 0 ; int m = - 1 ; for ( int n = 0 ; n < N; n++) { int d = 0 ; for ( int i = 0 ; i <= l; i++) {
                 d ^= c[i] * array[n - i];
             } if (d == 1 ) {
                 System. arraycopy (c, 0 , t, 0 , N); int N_M = n - m; for ( int j = 0 ; j < N - N_M; j++) {
                     c[N_M + j] ^= b[j];
                 } if (l <= n / 2 ) {
                     l = n + 1 - l;
                     m = n;
                     System. arraycopy (t, 0 , b, 0 , N);
                 }
             }
         } return l;
     }  Berlekamp–Massey algorithm for fields  The algorithm from .  polynomial(field K) s(x) = ... /* coeffs are s_j; output sequence as N-1 degree polynomial) */  /* connection polynomial */ polynomial(field K) C(x) = 1 ; /* coeffs are c_j */ polynomial(field K) B(x) = 1 ; int L = 0 ; int m = 1 ;
   field K b = 1 ; int n; for (n = 0 ; n < N; n++)
     { /* calculate discrepancy */ field K d = s_n + \Sigma_{i= 1 }^L c_i * s_{n-i}; if (d == 0 )
         { /* annihilation continues */ m = m + 1 ;
         } else  if ( 2 * L <= n)
         { /* temporary copy of C(x) */ polynomial(field K) T(x) = C(x);
           C(x) = C(x) - d b^{- 1 } x^m B(x);
           L = n + 1 - L;
           B(x) = T(x);
           b = d;
           m = 1 ;
         } else {
           C(x) = C(x) - d b^{- 1 } x^m B(x);
           m = m + 1 ;
         }
     } return L;  See also   Reeds–Sloane algorithm , an extension for sequences over integers mod n  Berlekamp–Welch algorithm  NLFSR , Non-Linear Feedback Shift Register   References  External links    Berlekamp–Massey algorithm at PlanetMath .   GF(2) implementation in Mathematica   Applet Berlekamp–Massey algorithm  Online GF(2) Berlekamp-Massey calculator   "  Category:Error detection and correction  Category:Cryptanalytic algorithms     ↩  ↩  ↩  . Previous publisher McGraw-Hill, New York, NY. ↩  ↩  ↩  ↩    