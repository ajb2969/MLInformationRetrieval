<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1209">Ear decomposition</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ear decomposition</h1>
<hr/>

<p> In <a href="graph_theory" title="wikilink">graph theory</a>, an <strong>ear</strong> of an <a href="undirected_graph" title="wikilink">undirected graph</a> <em>G</em> is a <a href="path_(graph_theory)" title="wikilink">path</a> <em>P</em> where the two endpoints of the path may coincide, but where otherwise no repetition of edges or vertices is allowed, so every internal vertex of <em>P</em> has <a href="degree_(graph_theory)" title="wikilink">degree</a> two in <em>P</em>. An <strong>ear decomposition</strong> of an undirected graph <em>G</em> is a <a href="Partition_of_a_set" title="wikilink">partition</a> of its set of edges into a sequence of ears, such that the one or two endpoints of each ear belong to earlier ears in the sequence and such that the internal vertices of each ear do not belong to any earlier ear. Additionally, in most cases the first ear in the sequence must be a cycle. An <strong>open ear decomposition</strong> or a <strong>proper ear decomposition</strong> is an ear decomposition in which the two endpoints of each ear after the first are distinct from each other.</p>

<p>Ear decompositions may be used to characterize several important graph classes, and as part of efficient <a href="graph_algorithm" title="wikilink">graph algorithms</a>. They may also be generalized from graphs to <a href="matroid" title="wikilink">matroids</a>.</p>
<h2 id="characterizing-graph-classes">Characterizing graph classes</h2>

<p>Several important classes of graphs may be characterized as the graphs having certain types of ear decompositions.</p>
<h3 id="graph-connectivity">Graph connectivity</h3>

<p>A graph is <a href="k-vertex-connected_graph" title="wikilink"><em>k</em>-vertex-connected</a> if the removal of any (<em>k</em> − 1) vertices leaves a connected subgraph, and <a href="k-edge-connected_graph" title="wikilink"><em>k</em>-edge-connected</a> if the removal of any (<em>k</em> − 1) edges leaves a connected subgraph.</p>

<p>The following result is due to :</p>
<dl>
<dd>A graph 

<math display="inline" id="Ear_decomposition:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Ear_decomposition:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>V</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <abs></abs>
     <ci>V</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V|\geq 2
  </annotation>
 </semantics>
</math>

 is 2-vertex-connected if and only if it has an open ear decomposition.
</dd>
</dl>

<p>The following result is due to :</p>
<dl>
<dd>A graph is 2-edge-connected if and only if it has an ear decomposition.
</dd>
</dl>

<p>In both cases the number of ears is necessarily equal to the <a href="circuit_rank" title="wikilink">circuit rank</a> of the given graph. Robbins introduced the ear decomposition of 2-edge-connected graphs as a tool for proving the <a href="Robbins_theorem" title="wikilink">Robbins theorem</a>, that these are exactly the graphs that may be given a <a href="strongly_connected" title="wikilink">strongly connected</a> orientation. Because of the pioneering work of Whitney and Robbins on ear decompositions, an ear decomposition is sometimes also called a <strong>Whitney–Robbins synthesis</strong> .</p>

<p>A <strong>non-separating ear decomposition</strong> is an open ear decomposition such that, for each vertex <em>v</em> with only one exception, <em>v</em> has a neighbor whose first appearance in the decomposition is in a later ear than the first appearance of <em>v</em>. This type of ear decomposition may be used to generalize Whitney's result:</p>
<dl>
<dd>A graph 

<math display="inline" id="Ear_decomposition:2">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Ear_decomposition:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>V</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <abs></abs>
     <ci>V</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V|\geq 2
  </annotation>
 </semantics>
</math>

 is 3-vertex-connected if and only if <em>G</em> has a non-separating ear decomposition.
</dd>
</dl>

<p>If such a decomposition exists, it can be chosen with respect to a particular edge <em>uv</em> of <em>G</em> in such a way that <em>u</em> is in the first ear, <em>v</em> is the new vertex in the last ear with more than one edge, and <em>uv</em> is a single-edge ear. This result was first stated explicitly by , but as  describes, it is equivalent to a result in the 1971 Ph.D. thesis of Lee Mondshein. Structures closely related to non-separating ear decompositions of maximal planar graphs, called canonical orderings, are also a standard tool in <a href="graph_drawing" title="wikilink">graph drawing</a>.</p>
<h3 id="strong-connectivity-of-directed-graphs">Strong connectivity of directed graphs</h3>

<p>The above definitions can also be applied to <a href="directed_graph" title="wikilink">directed graphs</a>. An <strong>ear</strong> would then be a directed path where all internal vertices have <a class="uri" href="indegree" title="wikilink">indegree</a> and <a class="uri" href="outdegree" title="wikilink">outdegree</a> equal to 1. A directed graph is <a href="strongly_connected" title="wikilink">strongly connected</a> if it contains a directed path from every vertex to every other vertex. Then we have the following theorem:</p>
<dl>
<dd>A directed graph is strongly connected if and only if it has an ear decomposition.
</dd>
</dl>

<p>Similarly, a directed graph is <a href="biconnected_graph" title="wikilink">biconnected</a> if, for every two vertices, there exists a simple cycle in the graph containing both of them. Then</p>
<dl>
<dd>A directed graph is biconnected if and only if it has an open ear decomposition.
</dd>
</dl>
<h3 id="factor-critical-graphs">Factor-critical graphs</h3>

<p>An ear decomposition is <em>odd</em> if each of its ears uses an odd number of edges. A <a href="factor-critical_graph" title="wikilink">factor-critical graph</a> is a graph with an odd number of vertices, such that for each vertex <em>v</em>, if <em>v</em> is removed from the graph then the remaining vertices have a <a href="perfect_matching" title="wikilink">perfect matching</a>.  found that:</p>
<dl>
<dd>A graph <em>G</em> is factor-critical if and only if <em>G</em> has an odd ear decomposition.
</dd>
</dl>

<p>More generally, a result of  makes it possible to find in any graph <em>G</em> the ear decomposition with the fewest even ears.</p>
<h3 id="series-parallel-graphs">Series-parallel graphs</h3>

<p>A <em>tree</em> ear decomposition is a proper ear decomposition in which the first ear is a single edge and for each subsequent ear 

<math display="inline" id="Ear_decomposition:4">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

, there is a single ear 

<math display="inline" id="Ear_decomposition:5">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{j}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Ear_decomposition:6">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>></mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>i</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i>j
  </annotation>
 </semantics>
</math>

, such that both endpoints of 

<math display="inline" id="Ear_decomposition:7">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

 lie on 

<math display="inline" id="Ear_decomposition:8">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{j}
  </annotation>
 </semantics>
</math>

 . A <em>nested</em> ear decomposition is a tree ear decomposition such that, within each ear 

<math display="inline" id="Ear_decomposition:9">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{j}
  </annotation>
 </semantics>
</math>

, the set of pairs of endpoints of other ears 

<math display="inline" id="Ear_decomposition:10">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

 that lie within 

<math display="inline" id="Ear_decomposition:11">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{j}
  </annotation>
 </semantics>
</math>

 form a set of nested intervals. A <a href="series-parallel_graph" title="wikilink">series-parallel graph</a> is a graph with two designated terminals <em>s</em> and <em>t</em> that can be formed recursively by combining smaller series-parallel graphs in one of two ways: series composition (identifying one terminal from one smaller graph with one terminal from the other smaller graph, and keeping the other two terminals as the terminals of the combined graph) and parallel composition (identifying both pairs of terminals from the two smaller graphs).</p>

<p>The following result is due to :</p>
<dl>
<dd>A 2-vertex-connected graph is series-parallel if and only if it has a nested ear decomposition.
</dd>
</dl>

<p>Moreover, any open ear decomposition of a 2-vertex-connected series-parallel graph must be nested. The result may be extended to series-parallel graphs that are not 2-vertex-connected by using open ear decompositions that start with a path between the two terminals.</p>
<h2 id="matroids">Matroids</h2>

<p>The concept of an ear decomposition can be extended from graphs to <a href="matroid" title="wikilink">matroids</a>. An ear decomposition of a matroid is defined to be a sequence of circuits of the matroid, with two properties:</p>
<ul>
<li>each circuit in the sequence has a nonempty intersection with the previous circuits, and</li>
<li>each circuit in the sequence remains a circuit even if all previous circuits in the sequence are contracted.</li>
</ul>

<p>When applied to the <a href="graphic_matroid" title="wikilink">graphic matroid</a> of a graph <em>G</em>, this definition of an ear decomposition coincides with the definition of a proper ear decomposition of <em>G</em>: improper decompositions are excluded by the requirement that each circuit include at least one edge that also belongs to previous circuits. Using this definition, a matroid may be defined as factor-critical when it has an ear decomposition in which each circuit in the sequence has an odd number of new elements .</p>
<h2 id="algorithms">Algorithms</h2>

<p>On classical computers, ear decompositions of 2-edge-connected graphs and open ear decompositions of 2-vertex-connected graphs may be found by <a href="greedy_algorithms" title="wikilink">greedy algorithms</a> that find each ear one at a time. A simple greedy approach that computes at the same time ear decompositions, open ear decompositions, st-numberings and -orientations in linear time (if exist) is given in . The approach is based on computing a special ear decomposition named <a href="chain_decomposition" title="wikilink">chain decomposition</a> by one path-generating rule.  shows that non-separating ear decompositions may also be constructed in linear time.</p>

<p>, , and  provided efficient <a href="parallel_algorithm" title="wikilink">parallel algorithms</a> for constructing ear decompositions of various types. For instance, to find an ear decomposition of a 2-edge-connected graph, the algorithm of  proceeds according to the following steps:</p>
<ol>
<li>Find a <a href="spanning_tree" title="wikilink">spanning tree</a> of the given graph and choose a root for the tree.</li>
<li>Determine, for each edge <em>uv</em> that is not part of the tree, the distance between the root and the <a href="lowest_common_ancestor" title="wikilink">lowest common ancestor</a> of <em>u</em> and <em>v</em>.</li>
<li>For each edge <em>uv</em> that is part of the tree, find the corresponding "master edge", a non-tree edge <em>wx</em> such that the cycle formed by adding <em>wx</em> to the tree passes through <em>uv</em> and such that, among such edges, <em>w</em> and <em>x</em> have a lowest common ancestor that is as close to the root as possible (with ties broken by edge identifiers).</li>
<li>Form an ear for each non-tree edge, consisting of it and the tree edges for which it is the master, and order the ears by their master edges' distance from the root (with the same tie-breaking rule).</li>
</ol>

<p>These algorithms may be used as subroutines for other problems including testing connectivity, recognizing series-parallel graphs, and constructing <em>st</em>-numberings of graphs (an important subroutine in <a href="planarity_testing" title="wikilink">planarity testing</a>).</p>

<p>An ear decomposition of a given matroid, with the additional constraint that every ear contains the same fixed element of the matroid, may be found in <a href="polynomial_time" title="wikilink">polynomial time</a> given access to an <a href="matroid_oracle" title="wikilink">independence oracle</a> for the matroid .</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Graph_theory_objects" title="wikilink">Category:Graph theory objects</a> <a href="Category:Matroid_theory" title="wikilink">Category:Matroid theory</a></p>
</body>
</html>
