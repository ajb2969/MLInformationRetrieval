   Block code      Block code   In coding theory , a block code is any member of the large and important family of error-correcting codes that encode data in blocks. There is a vast number of examples for block codes, many of which have a wide range of practical applications. Block codes are conceptually useful because they allow coding theorists, mathematicians , and computer scientists to study the limitations of all block codes in a unified way. Such limitations often take the form of bounds that relate different parameters of the block code to each other, such as its rate and its ability to detect and correct errors.  Examples of block codes are Reed‚ÄìSolomon codes , Hamming codes , Hadamard codes , Expander codes , Golay codes , and Reed‚ÄìMuller codes . These examples also belong to the class of linear codes , and hence they are called linear block codes . More particularly, these codes are known as algebraic block codes, or cyclic block codes, because they can be generated using boolean polynomials.  Algebraic block codes are typically hard-decoded using algebraic decoders.  The term block code may also refer to any error-correcting code that acts on a block of k bits of input data to produce n bits of output data (n,k). Consequently, the block coder is a memoryless device. Under this definition codes such as turbo codes, terminated convolutional codes and other iteratively decodable codes (turbo-like codes) would also be considered block codes. A non-terminated convolutional encoder would be an example of a non-block (unframed) code, which has memory and is instead classified as a tree code .  This article deals with "algebraic block codes".  The block code and its parameters  Error-correcting codes are used to reliably transmit digital data over unreliable communication channels subject to channel noise . When a sender wants to transmit a possibly very long data stream using a block code, the sender breaks the stream up into pieces of some fixed size. Each such piece is called message and the procedure given by the block code encodes each message individually into a codeword, also called a block in the context of block codes. The sender then transmits all blocks to the receiver, who can in turn use some decoding mechanism to (hopefully) recover the original messages from the possibly corrupted received blocks. The performance and success of the overall transmission depends on the parameters of the channel and the block code.  Formally, a block code is an injective mapping      C  :    Œ£  k   ‚Üí   Œ£  n       normal-:  C   normal-‚Üí   superscript  normal-Œ£  k    superscript  normal-Œ£  n      C:\Sigma^{k}\to\Sigma^{n}   . Here,   Œ£   normal-Œ£   \Sigma   is a finite and nonempty set and   k   k   k   and   n   n   n   are integers. The meaning and significance of these three parameters and other parameters related to the code are described below.  The alphabet Œ£  The data stream to be encoded is modeled as a string over some alphabet    Œ£   normal-Œ£   \Sigma   . The size    |  Œ£  |      normal-Œ£    |\Sigma|   of the alphabet is often written as   q   q   q   . If    q  =  2      q  2    q=2   , then the block code is called a binary block code. In many applications it is useful to consider   q   q   q   to be a prime power , and to identify   Œ£   normal-Œ£   \Sigma   with the finite field     ùîΩ  q     subscript  ùîΩ  q    \mathbb{F}_{q}   .  The message length k  Messages are elements   m   m   m   of    Œ£  k     superscript  normal-Œ£  k    \Sigma^{k}   , that is, strings of length   k   k   k   . Hence the number   k   k   k   is called the message length or dimension of a block code.  The block length n  The block length    n   n   n   of a block code is the number of symbols in a block. Hence, the elements   c   c   c   of    Œ£  n     superscript  normal-Œ£  n    \Sigma^{n}   are strings of length   n   n   n   and correspond to blocks that may be received by the receiver. Hence they are also called received words. If    c  =   C   (  m  )        c    C  m     c=C(m)   for some message   m   m   m   , then   c   c   c   is called the codeword of   m   m   m   .  The rate R  The rate of a block code is defined as the ratio between its message length and its block length:      R  =   k  /  n       R    k  n     R=k/n   . A large rate means that the amount of actual message per transmitted block is high. In this sense, the rate measures the transmission speed and the quantity    1  -  R      1  R    1-R   measures the overhead that occurs due to the encoding with the block code. It is a simple information theoretical fact that the rate cannot exceed   1   1   1   since data cannot in general be losslessly compressed. Formally, this follows from the fact that the code   C   C   C   is an injective map.  The distance d  The distance or minimum distance    d   d   d   of a block code is the minimum number of positions in which any two distinct codewords differ, and the relative distance    Œ¥   Œ¥   \delta   is the fraction    d  /  n      d  n    d/n   . Formally, for received words      c  1   ,   c  2    ‚àà   Œ£  n         subscript  c  1    subscript  c  2     superscript  normal-Œ£  n     c_{1},c_{2}\in\Sigma^{n}   , let    Œî   (   c  1   ,   c  2   )       normal-Œî    subscript  c  1    subscript  c  2      \Delta(c_{1},c_{2})   denote the Hamming distance between    c  1     subscript  c  1    c_{1}   and    c  2     subscript  c  2    c_{2}   , that is, the number of positions in which    c  1     subscript  c  1    c_{1}   and    c  2     subscript  c  2    c_{2}   differ. Then the minimum distance   d   d   d   of the code   C   C   C   is defined as      d  :=     min      m  1   ,   m  2    ‚àà   Œ£  k    ;    m  1   ‚â†   m  2      Œî    [   C   (   m  1   )    ,   C   (   m  2   )    ]       assign  d      subscript    formulae-sequence      subscript  m  1    subscript  m  2     superscript  normal-Œ£  k       subscript  m  1    subscript  m  2      normal-Œî      C   subscript  m  1      C   subscript  m  2        d:=\min_{m_{1},m_{2}\in\Sigma^{k};m_{1}\neq m_{2}}\Delta[C(m_{1}),C(m_{2})]   . Since any code has to be injective , any two codewords will disagree in at least one position, so the distance of any code is at least   1   1   1   . Besides, the distance equals the minimum weight for linear block codes because:         min      m  1   ,   m  2    ‚àà   Œ£  k    ;    m  1   ‚â†   m  2      Œî    [   C   (   m  1   )    ,   C   (   m  2   )    ]    =     min      m  1   ,   m  2    ‚àà   Œ£  k    ;    m  1   ‚â†   m  2      Œî    [  ùüé  ,    C   (   m  1   )    +   C   (   m  2   )     ]    =     min    m  ‚àà   Œ£  k    ;   m  ‚â†  ùüé     w    [   C   (  m  )    ]    =   w   m  i  n              subscript    formulae-sequence      subscript  m  1    subscript  m  2     superscript  normal-Œ£  k       subscript  m  1    subscript  m  2      normal-Œî      C   subscript  m  1      C   subscript  m  2          subscript    formulae-sequence      subscript  m  1    subscript  m  2     superscript  normal-Œ£  k       subscript  m  1    subscript  m  2      normal-Œî    0      C   subscript  m  1      C   subscript  m  2                subscript    formulae-sequence    m   superscript  normal-Œ£  k      m  0     w    delimited-[]    C  m           subscript  w    m  i  n       \min_{m_{1},m_{2}\in\Sigma^{k};m_{1}\neq m_{2}}\Delta[C(m_{1}),C(m_{2})]=\min_%
 {m_{1},m_{2}\in\Sigma^{k};m_{1}\neq m_{2}}\Delta[\mathbf{0},C(m_{1})+C(m_{2})]%
 =\min_{m\in\Sigma^{k};m\neq\mathbf{0}}w[C(m)]=w_{min}   .  A larger distance allows for more error correction and detection. For example, if we only consider errors that may change symbols of the sent codeword but never erase or add them, then the number of errors is the number of positions in which the sent codeword and the received word differ. A code with distance   d   d   d   allows the receiver to detect up to    d  -  1      d  1    d-1   transmission errors since changing    d  -  1      d  1    d-1   positions of a codeword can never accidentally yield another codeword. Furthermore, if no more than     (   d  -  1   )   /  2        d  1   2    (d-1)/2   transmission errors occur, the receiver can uniquely decode the received word to a codeword. This is because every received word has at most one codeword at distance     (   d  -  1   )   /  2        d  1   2    (d-1)/2   . If more than     (   d  -  1   )   /  2        d  1   2    (d-1)/2   transmission errors occur, the receiver cannot uniquely decode the received word in general as there might be several possible codewords. One way for the receiver to cope with this situation is to use list-decoding , in which the decoder outputs a list of all codewords in a certain radius.  Popular notation  The notation     (  n  ,  k  ,  d  )   q     subscript   n  k  d   q    (n,k,d)_{q}   describes a block code over an alphabet   Œ£   normal-Œ£   \Sigma   of size   q   q   q   , with a block length   n   n   n   , message length   k   k   k   , and distance   d   d   d   . If the block code is a linear block code, then the square brackets in the notation     [  n  ,  k  ,  d  ]   q     subscript   n  k  d   q    [n,k,d]_{q}   are used to represent that fact. For binary codes with    q  =  2      q  2    q=2   , the index is sometimes dropped. For maximum distance separable codes , the distance is always    d  =    n  -  k   +  1       d      n  k   1     d=n-k+1   , but sometimes the precise distance is not known, non-trivial to prove or state, or not needed. In such cases, the   d   d   d   -component may be missing.  Sometimes, especially for non-block codes, the notation     (  n  ,  M  ,  d  )   q     subscript   n  M  d   q    (n,M,d)_{q}   is used for codes that contain   M   M   M   codewords of length   n   n   n   . For block codes with messages of length   k   k   k   over an alphabet of size   q   q   q   , this number would be    M  =   q  k       M   superscript  q  k     M=q^{k}   .  Examples  As mentioned above, there are a vast number of error-correcting codes that are actually block codes. The first error-correcting code was the Hamming(7,4)-code , developed by Richard W. Hamming in 1950. This code transforms a message consisting of 4 bits into a codeword of 7 bits by adding 3 parity bits. Hence this code is a block code. It turns out that it is also a linear code and that it has distance 3. In the shorthand notation above, this means that the Hamming(7,4)-code is a     [  7  ,  4  ,  3  ]   2     subscript   7  4  3   2    [7,4,3]_{2}   -code.  Reed‚ÄìSolomon codes are a family of     [  n  ,  k  ,  d  ]   q     subscript   n  k  d   q    [n,k,d]_{q}   -codes with    d  =    n  -  k   +  1       d      n  k   1     d=n-k+1   and   q   q   q   being a prime power . Rank codes are family of     [  n  ,  k  ,  d  ]   q     subscript   n  k  d   q    [n,k,d]_{q}   -codes with    d  ‚â§    n  -  k   +  1       d      n  k   1     d\leq n-k+1   . Hadamard codes are a family of     [  n  ,  k  ,  d  ]   2     subscript   n  k  d   2    [n,k,d]_{2}   -codes with    n  =   2   k  -  1        n   superscript  2    k  1      n=2^{k-1}   and    d  =   2   k  -  2        d   superscript  2    k  2      d=2^{k-2}   .  Error detection and correction properties  A codeword    c  ‚àà   Œ£  n       c   superscript  normal-Œ£  n     c\in\Sigma^{n}   could be considered as a point in the   n   n   n   -dimension space    Œ£  n     superscript  normal-Œ£  n    \Sigma^{n}   and the code   ùíû   ùíû   \mathcal{C}   is the subset of    Œ£  n     superscript  normal-Œ£  n    \Sigma^{n}   . A code   ùíû   ùíû   \mathcal{C}   has distance   d   d   d   means that     ‚àÄ  c   ‚àà  ùíû       for-all  c   ùíû    \forall c\in\mathcal{C}   , there is no other codeword in the Hamming ball centered at   c   c   c   with radius    d  -  1      d  1    d-1   , which is defined as the collection of   n   n   n   -dimension words whose Hamming distance to   c   c   c   is no more than    d  -  1      d  1    d-1   . Similarly,   ùíû   ùíû   \mathcal{C}   with (minimum) distance   d   d   d   has the following properties:      ùíû   ùíû   \mathcal{C}   can detect    d  -  1      d  1    d-1   errors : Because a codeword   c   c   c   is the only codeword in the Hamming ball centered at itself with radius    d  -  1      d  1    d-1   , no error pattern of    d  -  1      d  1    d-1   or fewer errors could change one codeword to another. When the receiver detects that the received vector is not a codeword of   ùíû   ùíû   \mathcal{C}   , the errors are detected (but no guarantee to correct).     ùíû   ùíû   \mathcal{C}   can correct    ‚åä    d  -  1   2   ‚åã          d  1   2     \textstyle\left\lfloor{{d-1}\over 2}\right\rfloor   errors. Because a codeword   c   c   c   is the only codeword in the Hamming ball centered at itself with radius    d  -  1      d  1    d-1   , the two Hamming balls centered at two different codewords respectively with both radius    ‚åä    d  -  1   2   ‚åã          d  1   2     \textstyle\left\lfloor{{d-1}\over 2}\right\rfloor   do not overlap with each other. Therefore, if we consider the error correction as finding the codeword closest to the received word   y   y   y   , as long as the number of errors is no more than    ‚åä    d  -  1   2   ‚åã          d  1   2     \textstyle\left\lfloor{{d-1}\over 2}\right\rfloor   , there is only one codeword in the hamming ball centered at   y   y   y   with radius    ‚åä    d  -  1   2   ‚åã          d  1   2     \textstyle\left\lfloor{{d-1}\over 2}\right\rfloor   , therefore all errors could be corrected.  In order to decode in the presence of more than     (   d  -  1   )   /  2        d  1   2    (d-1)/2   errors, list-decoding or maximum likelihood decoding can be used.     ùíû   ùíû   \mathcal{C}   can correct    d  -  1      d  1    d-1    erasures . By erasure it means that the position of the erased symbol is known. Correcting could be achieved by   q   q   q   -passing decoding : In    i   t  h      superscript  i    t  h     i^{th}   passing the erased position is filled with the    i   t  h      superscript  i    t  h     i^{th}   symbol and error correcting is carried out. There must be one passing that the number of errors is no more than    ‚åä    d  -  1   2   ‚åã          d  1   2     \textstyle\left\lfloor{{d-1}\over 2}\right\rfloor   and therefore the erasures could be corrected. Lower and upper bounds of block codes  Family of codes      C  =    {   C  i   }    i  ‚â•  1        C   subscript    subscript  C  i      i  1      C=\{C_{i}\}_{i\geq 1}   is called '' family of codes'', where    C  i     subscript  C  i    C_{i}   is an     (   n  i   ,   k  i   ,   d  i   )   q     subscript    subscript  n  i    subscript  k  i    subscript  d  i    q    (n_{i},k_{i},d_{i})_{q}   code with monotonic increasing    n  i     subscript  n  i    n_{i}   .  Rate of family of codes   C   C   C   is defined as     R   (  C  )    =    lim   i  ‚Üí  ‚àû      k  i    n  i           R  C     subscript    normal-‚Üí  i        subscript  k  i    subscript  n  i       R(C)=\lim_{i\to\infty}{k_{i}\over n_{i}}     Relative distance of family of codes   C   C   C   is defined as     Œ¥   (  C  )    =    lim   i  ‚Üí  ‚àû      d  i    n  i           Œ¥  C     subscript    normal-‚Üí  i        subscript  d  i    subscript  n  i       \delta(C)=\lim_{i\to\infty}{d_{i}\over n_{i}}     To explore the relationship between    R   (  C  )       R  C    R(C)   and    Œ¥   (  C  )       Œ¥  C    \delta(C)   , a set of lower and upper bounds of block codes are known.  Hamming bound      R  ‚â§   1  -    1  n   ‚ãÖ   log  q   ‚ãÖ   [    ‚àë   i  =  0    ‚åä     Œ¥  ‚ãÖ  n   -  1   2   ‚åã      (     n      i     )     (   q  -  1   )   i     ]         R    1   normal-‚ãÖ    1  n    subscript   q    delimited-[]    superscript   subscript     i  0           normal-‚ãÖ  Œ¥  n   1   2        binomial  n  i    superscript    q  1   i          R\leq 1-{1\over n}\cdot\log_{q}\cdot\left[\sum_{i=0}^{\lfloor{{\delta\cdot n-1%
 }\over 2}\rfloor}{\left({{n}\atop{i}}\right)}(q-1)^{i}\right]     Singleton bound  The Singleton bound is that the sum of the rate and the relative distance of a block code cannot be much larger than 1:       R  +  Œ¥   ‚â§   1  +   1  n          R  Œ¥     1    1  n      R+\delta\leq 1+\frac{1}{n}   . In other words, every block code satisfies the inequality     k  +  d   ‚â§   n  +  1         k  d     n  1     k+d\leq n+1   . Reed‚ÄìSolomon codes are non-trivial examples of codes that satisfy the singleton bound with equality.  Plotkin bound  For    q  =  2      q  2    q=2   ,     R  +   2  Œ¥    ‚â§  1        R    2  Œ¥    1    R+2\delta\leq 1     For the general case, the following Plotkin bounds holds for any    C  ‚äÜ   ùîΩ  q  n       C   superscript   subscript  ùîΩ  q   n     C\subseteq\mathbb{F}_{q}^{n}   with distance   d   d   d   :  1. If     d  =    (   1  -   1  q    )   n    ,    |  C  |   ‚â§   2  q  n       formulae-sequence    d      1    1  q    n        C     2  q  n      d=(1-{1\over q})n,|C|\leq 2qn     2. If   d   d   d   >       (   1  -   1  q    )   n   ,   |  C  |    ‚â§    q  d     q  d   -    (   q  -  1   )   n              1    1  q    n     C        q  d       q  d       q  1   n       (1-{1\over q})n,|C|\leq{qd\over{qd-(q-1)n}}      For any   q   q   q   -ary code with distance   Œ¥   Œ¥   \delta   ,    R  ‚â§    1  -    (   q   q  -  1    )   Œ¥    +   o   (  1  )         R      1      q    q  1    Œ¥      o  1      R\leq 1-({q\over{q-1}})\delta+o(1)     Gilbert‚ÄìVarshamov bound      R  ‚â•   1  -    H  q    (  Œ¥  )    -  œµ       R    1     subscript  H  q   Œ¥   œµ     R\geq 1-H_{q}(\delta)-\epsilon   , where     0  ‚â§  Œ¥  ‚â§   1  -   1  q     ,   0  ‚â§  œµ  ‚â§   1  -    H  q    (  Œ¥  )         formulae-sequence      0  Œ¥         1    1  q          0  œµ         1     subscript  H  q   Œ¥        0\leq\delta\leq 1-{1\over q},0\leq\epsilon\leq 1-H_{q}(\delta)   ,      H  q    (  x  )     ‚â°   d  e  f      -   x  ‚ãÖ    log  q    x   q  -  1       -    (   1  -  x   )   ‚ãÖ    log  q    (   1  -  x   )          subscript     d  e  f       subscript  H  q   x        normal-‚ãÖ  x    subscript   q     x    q  1        normal-‚ãÖ    1  x     subscript   q     1  x        H_{q}(x)\equiv_{def}-x\cdot\log_{q}{x\over{q-1}}-(1-x)\cdot\log_{q}{(1-x)}   is the   q   q   q   -ary entropy function.  Johnson bound  Define      J  q    (  Œ¥  )     ‚â°   d  e  f      (   1  -   1  q    )    (   1  -    1  -    q  Œ¥    q  -  1       )        subscript     d  e  f       subscript  J  q   Œ¥       1    1  q      1      1      q  Œ¥     q  1          J_{q}(\delta)\equiv_{def}(1-{1\over q})(1-\sqrt{1-{q\delta\over{q-1}}})   . Let     J  q    (  n  ,  d  ,  e  )        subscript  J  q    n  d  e     J_{q}(n,d,e)   be the maximum number of codewords in a Hamming ball of radius   e   e   e   for any code    C  ‚äÜ   ùîΩ  q  n       C   superscript   subscript  ùîΩ  q   n     C\subseteq\mathbb{F}_{q}^{n}   of distance   d   d   d   .  Then we have the Johnson Bound       J  q    (  n  ,  d  ,  e  )    ‚â§   q  n  d          subscript  J  q    n  d  e      q  n  d     J_{q}(n,d,e)\leq qnd   , if     e  n   ‚â§     q  -  1   q    (   1  -     1  -    q   q  -  1    ‚ãÖ   d  n        )    =    J  q    (   d  n   )            e  n         q  1   q     1      1   normal-‚ãÖ    q    q  1      d  n                subscript  J  q     d  n       {e\over n}\leq{{q-1}\over q}\left({1-\sqrt{1-{q\over{q-1}}\cdot{d\over n}}}\,%
 \right)=J_{q}({d\over n})      Elias‚ÄìBassalygo bound      R  =     log  q    |  C  |    n   ‚â§    1  -    H  q    (    J  q    (  Œ¥  )    )     +   o   (  1  )           R      subscript   q     C    n            1     subscript  H  q      subscript  J  q   Œ¥       o  1       R={\log_{q}{|C|}\over n}\leq 1-H_{q}(J_{q}(\delta))+o(1)     Sphere packings and lattices  Block codes are tied to the sphere packing problem which has received some attention over the years. In two dimensions, it is easy to visualize. Take a bunch of pennies flat on the table and push them together. The result is a hexagon pattern like a bee's nest. But block codes rely on more dimensions which cannot easily be visualized. The powerful Golay code used in deep space communications uses 24 dimensions. If used as a binary code (which it usually is), the dimensions refer to the length of the codeword as defined above.  The theory of coding uses the N -dimensional sphere model. For example, how many pennies can be packed into a circle on a tabletop or in 3 dimensions, how many marbles can be packed into a globe. Other considerations enter the choice of a code. For example, hexagon packing into the constraint of a rectangular box will leave empty space at the corners. As the dimensions get larger, the percentage of empty space grows smaller. But at certain dimensions, the packing uses all the space and these codes are the so-called perfect codes. There are very few of these codes.  Another property is the number of neighbors a single codeword may have. 1 Again, consider pennies as an example. First we pack the pennies in a rectangular grid. Each penny will have 4 near neighbors (and 4 at the corners which are farther away). In a hexagon, each penny will have 6 near neighbors. Respectively, in three and four dimensions, the maximum packing is given by the 12-face and 24-cell with 12 and 24 neighbors, respectively. When we increase the dimensions, the number of near neighbors increases very rapidly. In general, the value is given by the kissing numbers .  The result is that the number of ways for noise to make the receiver choose a neighbor (hence an error) grows as well. This is a fundamental limitation of block codes, and indeed all codes. It may be harder to cause an error to a single neighbor, but the number of neighbors can be large enough so the total error probability actually suffers. 2  See also   Channel Capacity  Shannon‚ÄìHartley theorem  Noisy channel  List decoding  Sphere packing   Notes   Atri Rudra, CSE545 Error Correcting Codes: Combinatorics, Algorithms and Applications, State University of New York at Buffalo.  P Vijay Kumar, Error Correcting Codes, Available on-line, Video lectures , Lecture notes   References          External links   http://www.cse.buffalo.edu/~atri/courses/coding-theory/   External links   Coding Concepts and Block Coding   "  Category:Coding theory     ‚Ü©      