<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="520">Root locus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Root locus</h1>
<hr/>

<p>In <a href="control_theory" title="wikilink">control theory</a> and <a href="stability_theory" title="wikilink">stability theory</a>, <strong>root locus analysis</strong> is a graphical method for examining how the roots of a system change with variation of a certain system parameter, commonly a <a href="Loop_gain" title="wikilink">gain</a> within a <a class="uri" href="feedback" title="wikilink">feedback</a> system. This is a technique used as a <a href="stability_criterion" title="wikilink">stability criterion</a> in the field of <a href="control_systems" title="wikilink">control systems</a> developed by <a href="Walter_R._Evans" title="wikilink">Walter R. Evans</a> which can determine <a href="stable_polynomial" title="wikilink">stability</a> of the system. The root locus plots the <a href="pole_(complex_analysis)" title="wikilink">poles</a> of the <a href="closed_loop_transfer_function" title="wikilink">closed loop transfer function</a> in the complex <a href="s_plane" title="wikilink">s plane</a> as a function of a gain parameter.</p>
<h2 id="uses">Uses</h2>

<p> In addition to determining the stability of the system, the root locus can be used to design the <a href="damping_ratio" title="wikilink">damping ratio</a> (<em>ζ</em>) and <a href="natural_frequency" title="wikilink">natural frequency</a> (<em>ω</em><sub><em>n</em></sub>) of a feedback system. Lines of constant damping ratio can be drawn radially from the origin and lines of constant natural frequency can be drawn as arcs whose center points coincide with the origin. By selecting a point along the root locus that coincides with a desired damping ratio and natural frequency, a gain <em>K</em> can be calculated and implemented in the controller. More elaborate techniques of controller design using the root locus are available in most control textbooks: for instance, <a href="Lead-lag_compensator" title="wikilink">lag, lead</a>, PI, PD and <a href="PID_controller" title="wikilink">PID</a> controllers can be designed approximately with this technique.</p>

<p>The definition of the <a href="damping_ratio" title="wikilink">damping ratio</a> and <a href="natural_frequency" title="wikilink">natural frequency</a> presumes that the overall feedback system is well approximated by a second order system; i.e. the system has a dominant pair of <a href="Pole_(complex_analysis)" title="wikilink">poles</a>. This is often not the case, so it is good practice to simulate the final design to check if the project goals are satisfied.</p>
<h2 id="example">Example</h2>

<p> Suppose there is a feedback system whose input is the signal 

<math display="inline" id="Root_locus:0">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(s)
  </annotation>
 </semantics>
</math>

 and output is 

<math display="inline" id="Root_locus:1">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(s)
  </annotation>
 </semantics>
</math>

. The feedback system forward path gain is 

<math display="inline" id="Root_locus:2">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(s)
  </annotation>
 </semantics>
</math>

; the feedback path gain is 

<math display="inline" id="Root_locus:3">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(s)
  </annotation>
 </semantics>
</math>

.</p>
<figure><b>(Figure)</b>
<figcaption>General closed loop feedback system.svg</figcaption>
</figure>

<p>For this system, the overall transfer function is given by</p>

<p>

<math display="block" id="Root_locus:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>Y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>G</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>Y</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>G</ci>
        <ci>s</ci>
        <ci>H</ci>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(s)=\frac{Y(s)}{X(s)}=\frac{G(s)}{1+G(s)H(s)}
  </annotation>
 </semantics>
</math>

</p>

<p>Thus the <a href="closed-loop_pole" title="wikilink">closed-loop poles</a> (roots of the characteristic equation) of the <a href="transfer_function" title="wikilink">transfer function</a> are the solutions to the equation 

<math display="inline" id="Root_locus:5">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>s</ci>
      <ci>H</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+G(s)H(s)=0
  </annotation>
 </semantics>
</math>

. The principal feature of this equation is that roots may be found wherever 

<math display="inline" id="Root_locus:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>s</ci>
     <ci>H</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(s)H(s)=-1
  </annotation>
 </semantics>
</math>

.</p>

<p>In systems without pure delay, the product 

<math display="inline" id="Root_locus:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>s</ci>
     <ci>H</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(s)H(s)=-1
  </annotation>
 </semantics>
</math>

 is a rational polynomial function and may be expressed as</p>

<p>

<math display="block" id="Root_locus:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>+</mo>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>+</mo>
       <msub>
        <mi>z</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">⋯</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>+</mo>
       <msub>
        <mi>z</mi>
        <mi>m</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>+</mo>
       <msub>
        <mi>p</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>+</mo>
       <msub>
        <mi>p</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">⋯</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>+</mo>
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>m</mi>
         <mo>+</mo>
         <mi>n</mi>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>s</ci>
     <ci>H</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>K</ci>
      <apply>
       <plus></plus>
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <plus></plus>
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <plus></plus>
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>m</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(s)H(s)=\frac{K(s+z_{1})(s+z_{2})\cdots(s+z_{m})}{(s+p_{1})(s+p_{2})\cdots(s+%
p_{m+n})}
  </annotation>
 </semantics>
</math>

 where the <mtpl></mtpl> are the 

<math display="inline" id="Root_locus:9">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 zeros, the <mtpl></mtpl> are the 

<math display="inline" id="Root_locus:10">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>+</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m+n
  </annotation>
 </semantics>
</math>

 poles, and 

<math display="inline" id="Root_locus:11">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is a scalar gain. Typically, a root locus diagram will indicate the transfer function's pole locations for varying values of 

<math display="inline" id="Root_locus:12">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

. A root locus plot will be all those points in the 

<math display="inline" id="Root_locus:13">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

-plane where 

<math display="inline" id="Root_locus:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>s</ci>
     <ci>H</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(s)H(s)=-1
  </annotation>
 </semantics>
</math>

 for any value of 

<math display="inline" id="Root_locus:15">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

.</p>

<p>The factoring of 

<math display="inline" id="Root_locus:16">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 and the use of simple monomials means the evaluation of the rational polynomial can be done with vector techniques that add or subtract angles and multiply or divide magnitudes. The vector formulation arises from the fact that each monomial term in the factored 

<math display="inline" id="Root_locus:17">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>s</ci>
    <ci>H</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(s)H(s)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Root_locus:18">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>s</mi>
    <mi mathvariant="normal">−</mi>
    <mi>a</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>normal-−</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s−a)
  </annotation>
 </semantics>
</math>

 for example, represents the vector from 

<math display="inline" id="Root_locus:19">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Root_locus:20">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. The polynomial can be evaluated by considering the magnitudes and angles of each of these vectors. According to vector mathematics, the angle of the result is the sum of all the angles in the numerator add minus the sum of all the angles in the denominator. Similarly, the magnitude of the result is the product of all the magnitudes in the numerator divided by the product of all the magnitudes in the denominator. It turns out that the calculation of the magnitude is not needed because 

<math display="inline" id="Root_locus:21">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 varies; one of its values may result in a root. So to test whether a point in the 

<math display="inline" id="Root_locus:22">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

-plane is on the root locus, only the angles to all the open loop poles and zeros need be considered. A graphical method that uses a special protractor called a "Spirule" was once used to determine angles and draw the root loci.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>From the function 

<math display="inline" id="Root_locus:23">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(s)
  </annotation>
 </semantics>
</math>

, it can be seen that the value of 

<math display="inline" id="Root_locus:24">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 does not affect the location of the zeros. The root locus only gives the location of closed loop poles as the gain 

<math display="inline" id="Root_locus:25">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is varied. The zeros of a system do not move.</p>

<p>Using a few basic rules, the root locus method can plot the overall shape of the path (locus) traversed by the roots as the value of 

<math display="inline" id="Root_locus:26">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 varies. The plot of the root locus then gives an idea of the stability and dynamics of this feedback system for different values of 

<math display="inline" id="Root_locus:27">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="sketching-root-locus">Sketching root locus</h2>
<ul>
<li>Mark open-loop poles and zeros</li>
<li>Mark real axis portion to the left of an odd number of poles and zeros</li>
<li>Find <a href="asymptote" title="wikilink">asymptotes</a></li>
</ul>

<p>Let <em>P</em> be the number of poles and <em>Z</em> be the number of zeros:</p>

<p>

<math display="block" id="Root_locus:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>-</mo>
    <mi>Z</mi>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mtext>number of asymptotes</mtext>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>P</ci>
     <ci>Z</ci>
    </apply>
    <mtext>number of asymptotes</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P-Z=\text{number of asymptotes}\,
  </annotation>
 </semantics>
</math>

</p>

<p>The asymptotes intersect the real axis at 

<math display="inline" id="Root_locus:29">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 (which is called the centroid) and depart at angle 

<math display="inline" id="Root_locus:30">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 given by:</p>

<p>

<math display="block" id="Root_locus:31">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mi>l</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msup>
       <mn>180</mn>
       <mo>∘</mo>
      </msup>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>l</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mn>360</mn>
        <mo>∘</mo>
       </msup>
      </mrow>
     </mrow>
     <mrow>
      <mi>P</mi>
      <mo>-</mo>
      <mi>Z</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>l</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>P</mi>
      <mo>-</mo>
      <mi>Z</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">180</cn>
        <compose></compose>
       </apply>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>l</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">360</cn>
         <compose></compose>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>P</ci>
       <ci>Z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>l</ci>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
      <apply>
       <minus></minus>
       <ci>P</ci>
       <ci>Z</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{l}=\frac{180^{\circ}+(l-1)360^{\circ}}{P-Z},l=1,2,\ldots,P-Z
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Root_locus:32">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>P</mi>
     </msub>
     <mo>-</mo>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>Z</mi>
     </msub>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mo>-</mo>
     <mi>Z</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>P</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>Z</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>P</ci>
      <ci>Z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=\frac{\sum_{P}-\sum_{Z}}{P-Z}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Root_locus:33">
 <semantics>
  <msub>
   <mo largeop="true" symmetric="true">∑</mo>
   <mi>P</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <sum></sum>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{P}
  </annotation>
 </semantics>
</math>

 is the sum of all the locations of the poles, and 

<math display="inline" id="Root_locus:34">
 <semantics>
  <msub>
   <mo largeop="true" symmetric="true">∑</mo>
   <mi>Z</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <sum></sum>
    <ci>Z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{Z}
  </annotation>
 </semantics>
</math>

 is the sum of all the locations of the explicit zeros.</p>
<ul>
<li>Phase condition on test point to find angle of departure</li>
<li>Compute breakaway/break-in points</li>
</ul>

<p>The breakaway points are located at the roots of the following equation:</p>

<p>

<math display="block" id="Root_locus:35">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>d</mi>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>d</mi>
     <mi>s</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mtext>or</mtext>
    <mfrac>
     <mrow>
      <mi>d</mi>
      <mover accent="true">
       <mrow>
        <mi>G</mi>
        <mi>H</mi>
       </mrow>
       <mo>¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>d</mi>
      <mi>z</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>G</ci>
       <ci>s</ci>
       <ci>H</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <mtext>or</mtext>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>d</ci>
        <apply>
         <ci>normal-¯</ci>
         <apply>
          <times></times>
          <ci>G</ci>
          <ci>H</ci>
         </apply>
        </apply>
        <ci>z</ci>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{dG(s)H(s)}{ds}=0\text{ or }\frac{d\overline{GH}(z)}{dz}=0
  </annotation>
 </semantics>
</math>

</p>

<p>Once you solve for <em>z</em>, the real roots give you the breakaway/reentry points. Complex roots correspond to a lack of breakaway/reentry.</p>
<h2 id="z-plane-versus-s-plane"><em>z</em>-plane versus <em>s</em>-plane</h2>

<p>The root locus method can also be used for the analysis of <a href="sampled_data_systems" title="wikilink">sampled data systems</a> by computing the root locus in the <a href="z-transform" title="wikilink"><em>z</em>-plane</a>, the discrete counterpart of the <em>s</em>-plane. The equation <mtpl> <em>e</em><sup><em>sT</em></sup>}}</mtpl> maps continuous <em>s</em>-plane poles (not zeros) into the <em>z</em>-domain, where 

<math display="inline" id="Root_locus:36">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is the sampling period. The stable, left half <em>s</em>-plane maps into the interior of the unit circle of the <em>z</em>-plane, with the <em>s</em>-plane origin equating to <em>|z|</em> = 1 (because <em>e</em><sup>0</sup> = 1). A diagonal line of constant damping in the <em>s</em>-plane maps around a spiral from (1,0) in the <em>z</em> plane as it curves in toward the origin. Note also that the Nyquist <a class="uri" href="aliasing" title="wikilink">aliasing</a> criteria is expressed graphically in the <em>z</em>-plane by the <em>x</em>-axis, where 

<math display="inline" id="Root_locus:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>ω</mi>
    <mi>n</mi>
    <mi>T</mi>
   </mrow>
   <mo>=</mo>
   <mi>π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ω</ci>
     <ci>n</ci>
     <ci>T</ci>
    </apply>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ωnT=π
  </annotation>
 </semantics>
</math>

. The line of constant damping just described spirals in indefinitely but in sampled data systems, frequency content is aliased down to lower frequencies by integral multiples of the <a href="Nyquist_frequency" title="wikilink">Nyquist frequency</a>. That is, the sampled response appears as a lower frequency and better damped as well since the root in the <em>z</em>-plane maps equally well to the first loop of a different, better damped spiral curve of constant damping. Many other interesting and relevant mapping properties can be described, not least that <em>z</em>-plane controllers, having the property that they may be directly implemented from the <em>z</em>-plane transfer function (zero/pole ratio of polynomials), can be imagined graphically on a <em>z</em>-plane plot of the open loop transfer function, and immediately analyzed utilizing root locus.</p>

<p>Since root locus is a graphical angle technique, root locus rules work the same in the 

<math display="inline" id="Root_locus:38">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Root_locus:39">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 planes.</p>

<p>The idea of a root locus can be applied to many systems where a single parameter 

<math display="inline" id="Root_locus:40">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is varied. For example, it is useful to sweep any system parameter for which the exact value is uncertain in order to determine its behavior.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Phase_margin" title="wikilink">Phase margin</a></li>
<li><a href="Routh–Hurwitz_stability_criterion" title="wikilink">Routh–Hurwitz stability criterion</a></li>
<li><a href="Nyquist_stability_criterion" title="wikilink">Nyquist stability criterion</a></li>
<li><a href="Bode_plot#Gain_margin_and_phase_margin" title="wikilink">Gain and phase margin</a></li>
<li><a href="Bode_plot" title="wikilink">Bode plot</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://en.wikibooks.org/wiki/Control_Systems/Root_Locus">Wikibooks: Control Systems/Root Locus</a></li>
<li><a href="http://www.engin.umich.edu/group/ctm/rlocus/rlocus.html">Carnegie Mellon / University of Michigan Tutorial</a></li>
<li><a href="http://www.swarthmore.edu/NatSci/echeeve1/Ref/LPSA/Root_Locus/RLocusExamples.html#ex5">Excellent examples. Start with example 5 and proceed backwards through 4 to 1. Also visit the main page</a></li>
<li><a href="http://www.atp.ruhr-uni-bochum.de/rt1/syscontrol/node46.html">The root-locus method: Drawing by hand techniques</a></li>
<li><a href="http://www.coppice.myzen.co.uk">"RootLocs": A free multi-featured root-locus plotter for Mac and Windows platforms</a></li>
<li><a href="http://web.archive.org/web/20091027092528/http://geocities.com/aseldawy/root_locus.html">"Root Locus": A free root-locus plotter/analyzer for Windows</a></li>
<li><a href="http://wikis.controltheorypro.com/index.php?title=Root_Locus">Root Locus at ControlTheoryPro.com</a></li>
<li><a href="http://www.roymech.co.uk/Related/Control/root_locus.html">Root Locus Analysis of Control Systems</a></li>
<li><a href="http://www.mathworks.com/help/toolbox/control/ref/rlocus.html">MATLAB function for computing root locus of a SISO open-loop model</a></li>
<li></li>
<li><a href="http://reference.wolfram.com/mathematica/ref/RootLocusPlot.html">Mathematica function for plotting the root locus</a></li>
</ul>

<p><a href="tr:Köklerin_yer_eğrisi" title="wikilink">tr:Köklerin yer eğrisi</a>"</p>

<p><a href="Category:Control_theory" title="wikilink">Category:Control theory</a> <a href="Category:Classical_control" title="wikilink">Category:Classical control</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
