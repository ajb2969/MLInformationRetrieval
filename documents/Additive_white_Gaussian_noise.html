<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="942">Additive white Gaussian noise</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Additive white Gaussian noise</h1>
<hr/>

<p><strong>Additive white Gaussian noise</strong> (<strong>AWGN</strong>) is a basic noise model used in <a href="Information_theory" title="wikilink">Information theory</a> to mimic the effect of many random processes that occur in nature. The modifiers denote specific characteristics:</p>
<ul>
<li><strong><em>Additive</em></strong> because it is added to any noise that might be intrinsic to the information system.</li>
<li><strong><em>White</em></strong> refers to the idea that it has uniform power across the frequency band for the information system. It is an analogy to the color white which has uniform emissions at all frequencies in the <a href="visible_spectrum" title="wikilink">visible spectrum</a>.</li>
<li><strong><em>Gaussian</em></strong> because it has a <a href="normal_distribution" title="wikilink">normal distribution</a> in the time domain with an average time domain value of zero.</li>
</ul>

<p>Wideband noise comes from many natural sources, such as the thermal vibrations of atoms in conductors (referred to as <a href="thermal_noise" title="wikilink">thermal noise</a> or <a href="Johnson-Nyquist_noise" title="wikilink">Johnson-Nyquist noise</a>), <a href="shot_noise" title="wikilink">shot noise</a>, <a href="Black_body" title="wikilink">black body radiation</a> from the earth and other warm objects, and from <a href="celestial_source" title="wikilink">celestial sources</a> such as the <a class="uri" href="Sun" title="wikilink">Sun</a>. The <a href="central_limit_theorem" title="wikilink">central limit theorem</a> of <a href="probability_theory" title="wikilink">probability theory</a> indicates that the summation of many random processes will tend to have distribution called Gaussian or Normal.</p>

<p>AWGN is often used as a <a href="Channel_(communications)" title="wikilink">channel model</a> in which the only impairment to communication is a linear addition of <a class="uri" href="wideband" title="wikilink">wideband</a> or <a href="white_noise" title="wikilink">white noise</a> with a constant <a href="spectral_density" title="wikilink">spectral density</a> (expressed as <a href="watt" title="wikilink">watts</a> per <a class="uri" href="hertz" title="wikilink">hertz</a> of <a href="Bandwidth_(signal_processing)" title="wikilink">bandwidth</a>) and a <a href="Gaussian_distribution" title="wikilink">Gaussian distribution</a> of amplitude. The model does not account for <a class="uri" href="fading" title="wikilink">fading</a>, <a class="uri" href="frequency" title="wikilink">frequency</a> selectivity, <a href="Interference_(communication)" title="wikilink">interference</a>, <a class="uri" href="nonlinearity" title="wikilink">nonlinearity</a> or <a href="Dispersion_(optics)" title="wikilink">dispersion</a>. However, it produces simple and tractable mathematical models which are useful for gaining insight into the underlying behavior of a system before these other phenomena are considered.</p>

<p>The AWGN channel is a good model for many <a class="uri" href="satellite" title="wikilink">satellite</a> and deep space communication links. It is not a good model for most terrestrial links because of multipath, terrain blocking, interference, etc. However, for terrestrial path modeling, AWGN is commonly used to simulate background noise of the channel under study, in addition to multipath, terrain blocking, interference, ground clutter and self interference that modern radio systems encounter in terrestrial operation.</p>
<h2 id="channel-capacity">Channel capacity</h2>

<p>The AWGN channel is represented by a series of outputs 

<math display="inline" id="Additive_white_Gaussian_noise:0">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>

 at discrete time event index 

<math display="inline" id="Additive_white_Gaussian_noise:1">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Additive_white_Gaussian_noise:2">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>

 is the sum of the input 

<math display="inline" id="Additive_white_Gaussian_noise:3">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

 and noise, 

<math display="inline" id="Additive_white_Gaussian_noise:4">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{i}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Additive_white_Gaussian_noise:5">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{i}
  </annotation>
 </semantics>
</math>

 is <a href="Independent_and_identically_distributed_random_variables" title="wikilink">independent and identically distributed</a> and drawn from a zero-mean <a href="normal_distribution" title="wikilink">normal distribution</a> with <a class="uri" href="variance" title="wikilink">variance</a> 

<math display="inline" id="Additive_white_Gaussian_noise:6">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 (the noise). The 

<math display="inline" id="Additive_white_Gaussian_noise:7">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{i}
  </annotation>
 </semantics>
</math>

 are further assumed to not be correlated with the 

<math display="inline" id="Additive_white_Gaussian_noise:8">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:9">
 <semantics>
  <mrow>
   <msub>
    <mi>Z</mi>
    <mi>i</mi>
   </msub>
   <mo>‚àº</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ùí©</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ùí©</ci>
     <interval closure="open">
      <cn type="integer">0</cn>
      <ci>N</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{i}\sim\mathcal{N}(0,N)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Y</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>Z</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>‚àº</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ùí©</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>X</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>ùí©</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>i</ci>
       </apply>
       <ci>N</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}=X_{i}+Z_{i}\sim\mathcal{N}(X_{i},N).\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>The capacity of the channel is infinite unless the noise n is nonzero, and the 

<math display="inline" id="Additive_white_Gaussian_noise:11">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

 are sufficiently constrained. The most common constraint on the input is the so-called "power" constraint, requiring that for a codeword 

<math display="inline" id="Additive_white_Gaussian_noise:12">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},x_{2},\dots,x_{k})
  </annotation>
 </semantics>
</math>


 transmitted through the channel, we have:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>k</mi>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>k</mi>
      </munderover>
      <msubsup>
       <mi>x</mi>
       <mi>i</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
    </mrow>
    <mo>‚â§</mo>
    <mi>P</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>k</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{k}\sum_{i=1}^{k}x_{i}^{2}\leq P,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Additive_white_Gaussian_noise:14">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 represents the maximum channel power. Therefore, the <a href="channel_capacity" title="wikilink">channel capacity</a> for the power-constrained channel is given by:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:15">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mi>max</mi>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mtext>s.t.</mtext>
        <mi>E</mi>
        <mrow>
         <mo>(</mo>
         <msup>
          <mi>X</mi>
          <mn>2</mn>
         </msup>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>‚â§</mo>
       <mi>P</mi>
      </mrow>
     </munder>
     <mi>I</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>;</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <leq></leq>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>x</ci>
         <mtext>s.t.</mtext>
         <ci>E</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>X</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>P</ci>
       </apply>
      </apply>
      <ci>I</ci>
     </apply>
     <list>
      <ci>X</ci>
      <ci>Y</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\max_{f(x)\text{ s.t. }E\left(X^{2}\right)\leq P}I(X;Y)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Additive_white_Gaussian_noise:16">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is the distribution of 

<math display="inline" id="Additive_white_Gaussian_noise:17">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

. Expand 

<math display="inline" id="Additive_white_Gaussian_noise:18">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>;</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <list>
     <ci>X</ci>
     <ci>Y</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(X;Y)
  </annotation>
 </semantics>
</math>

, writing it in terms of the <a href="differential_entropy" title="wikilink">differential entropy</a>:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:19">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>I</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo>;</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>=</mo>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>-</mo>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">|</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>=</mo>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>-</mo>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo>+</mo>
       <mi>Z</mi>
       <mo stretchy="false">|</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mo>=</mo>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>-</mo>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Z</mi>
       <mo stretchy="false">|</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">I</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">X</csymbol>
       <ci>normal-;</ci>
       <csymbol cd="unknown">Y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <eq></eq>
      <csymbol cd="unknown">h</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">Y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <minus></minus>
      <csymbol cd="unknown">h</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">Y</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">X</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <eq></eq>
      <csymbol cd="unknown">h</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">Y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <minus></minus>
      <csymbol cd="unknown">h</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">X</csymbol>
       <plus></plus>
       <csymbol cd="unknown">Z</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">X</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <eq></eq>
      <csymbol cd="unknown">h</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">Y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <minus></minus>
      <csymbol cd="unknown">h</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">Z</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">X</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle I(X;Y)=h(Y)-h(Y|X)&\displaystyle=h(Y)-h(X+Z|X)&%
\displaystyle=h(Y)-h(Z|X)\end{aligned}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>But 

<math display="inline" id="Additive_white_Gaussian_noise:20">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Additive_white_Gaussian_noise:21">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 are independent, therefore:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>;</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>I</ci>
     <list>
      <ci>X</ci>
      <ci>Y</ci>
     </list>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>Z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(X;Y)=h(Y)-h(Z)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Evaluating the <a href="differential_entropy" title="wikilink">differential entropy</a> of a Gaussian gives:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>œÄ</mi>
       <mi>e</mi>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>Z</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>œÄ</ci>
       <ci>e</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(Z)=\frac{1}{2}\log(2\pi eN)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Because 

<math display="inline" id="Additive_white_Gaussian_noise:24">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Additive_white_Gaussian_noise:25">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 are independent and their sum gives 

<math display="inline" id="Additive_white_Gaussian_noise:26">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>Y</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>+</mo>
       <mi>Z</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>X</mi>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>Z</mi>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mo>+</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>X</ci>
        <ci>Z</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>E</ci>
       <ci>X</ci>
       <ci>E</ci>
       <ci>Z</ci>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Z</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <ci>P</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(Y^{2})=E(X+Z)^{2}=E(X^{2})+2E(X)E(Z)+E(Z^{2})=P+N\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>From this bound, we infer from a property of the differential entropy that</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>œÄ</mi>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>P</mi>
         <mo>+</mo>
         <mi>N</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>œÄ</ci>
       <ci>e</ci>
       <apply>
        <plus></plus>
        <ci>P</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(Y)\leq\frac{1}{2}\log(2\pi e(P+N))\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore the channel capacity is given by the highest achievable bound on the mutual information:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>;</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>œÄ</mi>
        <mi>e</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>P</mi>
          <mo>+</mo>
          <mi>N</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>œÄ</mi>
        <mi>e</mi>
        <mi>N</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>I</ci>
     <list>
      <ci>X</ci>
      <ci>Y</ci>
     </list>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <log></log>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>œÄ</ci>
        <ci>e</ci>
        <apply>
         <plus></plus>
         <ci>P</ci>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <log></log>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>œÄ</ci>
        <ci>e</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(X;Y)\leq\frac{1}{2}\log(2\pi e(P+N))-\frac{1}{2}\log(2\pi eN)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Additive_white_Gaussian_noise:30">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>;</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <list>
     <ci>X</ci>
     <ci>Y</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(X;Y)
  </annotation>
 </semantics>
</math>

 is maximized when:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:31">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>‚àº</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ùí©</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>ùí©</ci>
     <interval closure="open">
      <cn type="integer">0</cn>
      <ci>P</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\sim\mathcal{N}(0,P)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Thus the channel capacity 

<math display="inline" id="Additive_white_Gaussian_noise:32">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 for the AWGN channel is given by:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:33">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mfrac>
        <mi>P</mi>
        <mi>N</mi>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <ci>P</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\frac{1}{2}\log\left(1+\frac{P}{N}\right)\,\!
  </annotation>
 </semantics>
</math>

</p>
<h3 id="channel-capacity-and-sphere-packing">Channel capacity and sphere packing</h3>

<p>Suppose that we are sending messages through the channel with index ranging from 

<math display="inline" id="Additive_white_Gaussian_noise:34">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Additive_white_Gaussian_noise:35">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, the number of distinct possible messages. If we encode the 

<math display="inline" id="Additive_white_Gaussian_noise:36">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 messages to 

<math display="inline" id="Additive_white_Gaussian_noise:37">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 bits, then we define the rate 

<math display="inline" id="Additive_white_Gaussian_noise:38">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 as:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:39">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>log</mi>
     <mi>M</mi>
    </mrow>
    <mi>n</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <divide></divide>
     <apply>
      <log></log>
      <ci>M</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\frac{\log M}{n}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>A rate is said to be achievable if there is a sequence of codes so that the maximum probability of error tends to zero as 

<math display="inline" id="Additive_white_Gaussian_noise:40">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 approaches infinity. The capacity 

<math display="inline" id="Additive_white_Gaussian_noise:41">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is the highest achievable rate.</p>

<p>Consider a codeword of length 

<math display="inline" id="Additive_white_Gaussian_noise:42">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 sent through the AWGN channel with noise level 

<math display="inline" id="Additive_white_Gaussian_noise:43">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

. When received, the codeword vector variance is now 

<math display="inline" id="Additive_white_Gaussian_noise:44">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, and its mean is the codeword sent. The vector is very likely to be contained in a sphere of radius 

<math display="inline" id="Additive_white_Gaussian_noise:45">
 <semantics>
  <msqrt>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>+</mo>
      <mi>œµ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <plus></plus>
      <ci>N</ci>
      <ci>œµ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n(N+\epsilon)}
  </annotation>
 </semantics>
</math>

 around the codeword sent. If we decode by mapping every message received onto the codeword at the center of this sphere, then an error occurs only when the received vector is outside of this sphere, which is very unlikely.</p>

<p>Each codeword vector has an associated sphere of received codeword vectors which are decoded to it and each such sphere must map uniquely onto a codeword. Because these spheres therefore must not intersect, we are faced with the problem of <a href="sphere_packing" title="wikilink">sphere packing</a>. How many distinct codewords can we pack into our 

<math display="inline" id="Additive_white_Gaussian_noise:46">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-bit codeword vector? The received vectors have a maximum energy of 

<math display="inline" id="Additive_white_Gaussian_noise:47">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mo>+</mo>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <apply>
     <plus></plus>
     <ci>P</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(P+N)
  </annotation>
 </semantics>
</math>

 and therefore must occupy a sphere of radius 

<math display="inline" id="Additive_white_Gaussian_noise:48">
 <semantics>
  <msqrt>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mo>+</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <plus></plus>
      <ci>P</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n(P+N)}
  </annotation>
 </semantics>
</math>

. Each codeword sphere has radius 

<math display="inline" id="Additive_white_Gaussian_noise:49">
 <semantics>
  <msqrt>
   <mrow>
    <mi>n</mi>
    <mi>N</mi>
   </mrow>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{nN}
  </annotation>
 </semantics>
</math>

. The volume of an <em>n</em>-dimensional sphere is directly proportional to 

<math display="inline" id="Additive_white_Gaussian_noise:50">
 <semantics>
  <msup>
   <mi>r</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{n}
  </annotation>
 </semantics>
</math>

, so the maximum number of uniquely decodeable spheres that can be packed into our sphere with transmission power P is:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:51">
 <semantics>
  <mrow>
   <mfrac>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>P</mi>
         <mo>+</mo>
         <mi>N</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mi>n</mi>
      <mn>2</mn>
     </mfrac>
    </msup>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mi>n</mi>
      <mn>2</mn>
     </mfrac>
    </msup>
   </mfrac>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mfrac>
      <mi>n</mi>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <mi>P</mi>
         <mo>/</mo>
         <mi>N</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <plus></plus>
        <ci>P</ci>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>N</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <log></log>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <divide></divide>
         <ci>P</ci>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{(n(P+N))^{\frac{n}{2}}}{(nN)^{\frac{n}{2}}}=2^{\frac{n}{2}\log(1+P/N)}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>By this argument, the rate R can be no more than 

<math display="inline" id="Additive_white_Gaussian_noise:52">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mi>P</mi>
       <mo>/</mo>
       <mi>N</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <log></log>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <ci>P</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}\log(1+P/N)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="achievability">Achievability</h3>

<p>In this section, we show achievability of the upper bound on the rate from the last section.</p>

<p>A codebook, known to both encoder and decoder, is generated by selecting codewords of length n, i.i.d. Gaussian with variance 

<math display="inline" id="Additive_white_Gaussian_noise:53">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>-</mo>
   <mi>œµ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>P</ci>
    <ci>œµ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P-\epsilon
  </annotation>
 </semantics>
</math>

 and mean zero. For large n, the empirical variance of the codebook will be very close to the variance of its distribution, thereby avoiding violation of the power constraint probabilistically.</p>

<p>Received messages are decoded to a message in the codebook which is uniquely jointly typical. If there is no such message or if the power constraint is violated, a decoding error is declared.</p>

<p>Let 

<math display="inline" id="Additive_white_Gaussian_noise:54">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mi>n</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{n}(i)
  </annotation>
 </semantics>
</math>


 denote the codeword for message 

<math display="inline" id="Additive_white_Gaussian_noise:55">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, while 

<math display="inline" id="Additive_white_Gaussian_noise:56">
 <semantics>
  <msup>
   <mi>Y</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{n}
  </annotation>
 </semantics>
</math>

 is, as before the received vector. Define the following three events:</p>
<ol>
<li>Event 

<math display="inline" id="Additive_white_Gaussian_noise:57">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

:the power of the received message is larger than 

<math display="inline" id="Additive_white_Gaussian_noise:58">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</li>
<li>Event 

<math display="inline" id="Additive_white_Gaussian_noise:59">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>


: the transmitted and received codewords are not jointly typical.</li>
<li>Event 

<math display="inline" id="Additive_white_Gaussian_noise:60">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{j}
  </annotation>
 </semantics>
</math>



<math display="block" id="Additive_white_Gaussian_noise:61">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msup>
     <mi>X</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <msup>
    <mi>Y</mi>
    <mi>n</mi>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Y</ci>
     <ci>n</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X^{n}(j),Y^{n})
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Additive_white_Gaussian_noise:62">
 <semantics>
  <msubsup>
   <mi>A</mi>
   <mi>œµ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>œµ</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\epsilon}^{(n)}
  </annotation>
 </semantics>
</math>

, the <a href="typical_set" title="wikilink">typical set</a> where 

<math display="inline" id="Additive_white_Gaussian_noise:63">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>‚â†</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>i</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\neq j
  </annotation>
 </semantics>
</math>

, which is to say that the incorrect codeword is jointly typical with the received vector.</li>
</ol>

<p>An error therefore occurs if 

<math display="inline" id="Additive_white_Gaussian_noise:64">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Additive_white_Gaussian_noise:65">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 or any of the 

<math display="inline" id="Additive_white_Gaussian_noise:66">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{i}
  </annotation>
 </semantics>
</math>

 occur. By the law of large numbers, 

<math display="inline" id="Additive_white_Gaussian_noise:67">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>U</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(U)
  </annotation>
 </semantics>
</math>

 goes to zero as n approaches infinity, and by the joint <a href="Asymptotic_Equipartition_Property" title="wikilink">Asymptotic Equipartition Property</a> the same applies to 

<math display="inline" id="Additive_white_Gaussian_noise:68">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(V)
  </annotation>
 </semantics>
</math>

. Therefore, for a sufficiently large 

<math display="inline" id="Additive_white_Gaussian_noise:69">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


, both 

<math display="inline" id="Additive_white_Gaussian_noise:70">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>U</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(U)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Additive_white_Gaussian_noise:71">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(V)
  </annotation>
 </semantics>
</math>

 are each less than 

<math display="inline" id="Additive_white_Gaussian_noise:72">
 <semantics>
  <mi>œµ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œµ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Additive_white_Gaussian_noise:73">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mi>n</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{n}(i)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Additive_white_Gaussian_noise:74">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mi>n</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{n}(j)
  </annotation>
 </semantics>
</math>


 are independent for 

<math display="inline" id="Additive_white_Gaussian_noise:75">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>‚â†</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>i</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\neq j
  </annotation>
 </semantics>
</math>

, we have that 

<math display="inline" id="Additive_white_Gaussian_noise:76">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mi>n</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{n}(i)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Additive_white_Gaussian_noise:77">
 <semantics>
  <msup>
   <mi>Y</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{n}
  </annotation>
 </semantics>
</math>

 are also independent. Therefore, by the joint AEP, 

<math display="inline" id="Additive_white_Gaussian_noise:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>E</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>I</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo>;</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mn>3</mn>
         <mi>œµ</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>I</ci>
         <list>
          <ci>X</ci>
          <ci>Y</ci>
         </list>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">3</cn>
         <ci>œµ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(E_{j})=2^{-n(I(X;Y)-3\epsilon)}
  </annotation>
 </semantics>
</math>

. This allows us to calculate 

<math display="inline" id="Additive_white_Gaussian_noise:79">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>n</ci>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{(n)}_{e}
  </annotation>
 </semantics>
</math>


, the probability of error as follows:</p>

<p>

<math display="inline" id="Additive_white_Gaussian_noise:80">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>n</ci>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P^{(n)}_{e}
  </annotation>
 </semantics>
</math>


</p>

<p>Therefore, as <em>n</em> approaches infinity, 

<math display="inline" id="Additive_white_Gaussian_noise:81">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>n</ci>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{(n)}_{e}
  </annotation>
 </semantics>
</math>

 goes to zero and 

<math display="inline" id="Additive_white_Gaussian_noise:82">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo><</mo>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>;</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>3</mn>
     <mi>œµ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>R</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>I</ci>
      <list>
       <ci>X</ci>
       <ci>Y</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>œµ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R<I(X;Y)-3\epsilon
  </annotation>
 </semantics>
</math>

. Therefore there is a code of rate R arbitrarily close to the capacity derived earlier.</p>
<h3 id="coding-theorem-converse">Coding theorem converse</h3>

<p>Here we show that rates above the capacity 

<math display="inline" id="Additive_white_Gaussian_noise:83">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mfrac>
        <mi>P</mi>
        <mi>N</mi>
       </mfrac>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <ci>P</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\frac{1}{2}\log(1+\frac{P}{N})
  </annotation>
 </semantics>
</math>

 are not achievable.</p>

<p>Suppose that the power constraint is satisfied for a codebook, and further suppose that the messages follow a uniform distribution. Let 

<math display="inline" id="Additive_white_Gaussian_noise:84">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 be the input messages and 

<math display="inline" id="Additive_white_Gaussian_noise:85">
 <semantics>
  <mover accent="true">
   <mi>W</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{W}
  </annotation>
 </semantics>
</math>

 the output messages. Thus the information flows as:</p>

<p>

<math display="inline" id="Additive_white_Gaussian_noise:86">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>‚ü∂</mo>
   <mrow>
    <msup>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>W</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚ü∂</mo>
   <msup>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>‚ü∂</mo>
   <mover accent="true">
    <mi>W</mi>
    <mo stretchy="false">^</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-‚ü∂</ci>
     <ci>W</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
      <ci>W</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-‚ü∂</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-‚ü∂</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-^</ci>
      <ci>W</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W\longrightarrow X^{(n)}(W)\longrightarrow Y^{(n)}\longrightarrow\hat{W}
  </annotation>
 </semantics>
</math>

</p>

<p>Making use of <a href="Fano's_inequality" title="wikilink">Fano's inequality</a> gives:</p>

<p>

<math display="inline" id="Additive_white_Gaussian_noise:87">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">|</mo>
    <mover accent="true">
     <mi>W</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>‚â§</mo>
   <mn>1</mn>
   <mo>+</mo>
   <mi>n</mi>
   <mi>R</mi>
   <msubsup>
    <mi>P</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mi>n</mi>
   <msub>
    <mi>œµ</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">W</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>W</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <cn type="integer">1</cn>
    <plus></plus>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <ci>n</ci>
     </apply>
     <ci>e</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">n</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œµ</ci>
     <ci>n</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(W|\hat{W})\leq 1+nRP^{(n)}_{e}=n\epsilon_{n}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Additive_white_Gaussian_noise:88">
 <semantics>
  <mrow>
   <msub>
    <mi>œµ</mi>
    <mi>n</mi>
   </msub>
   <mo>‚Üí</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üí</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œµ</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{n}\rightarrow 0
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Additive_white_Gaussian_noise:89">
 <semantics>
  <mrow>
   <msubsup>
    <mi>P</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>‚Üí</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üí</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <ci>n</ci>
     </apply>
     <ci>e</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{(n)}_{e}\rightarrow 0
  </annotation>
 </semantics>
</math>

</p>

<p>Let 

<math display="inline" id="Additive_white_Gaussian_noise:90">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

 be the encoded message of codeword index i. Then:</p>

<p>

<math display="inline" id="Additive_white_Gaussian_noise:91">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle nR
  </annotation>
 </semantics>
</math>


</p>

<p>Let 

<math display="inline" id="Additive_white_Gaussian_noise:92">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

 be the average power of the codeword of index i:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:93">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>n</mi>
       <mi>R</mi>
      </mrow>
     </msup>
    </mfrac>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mi>w</mi>
     </munder>
     <mrow>
      <msubsup>
       <mi>x</mi>
       <mi>i</mi>
       <mn>2</mn>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>R</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>w</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>i</ci>
       </apply>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}=\frac{1}{2^{nR}}\sum_{w}x^{2}_{i}(w)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Where the sum is over all input messages 

<math display="inline" id="Additive_white_Gaussian_noise:94">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Additive_white_Gaussian_noise:95">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Additive_white_Gaussian_noise:96">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{i}
  </annotation>
 </semantics>
</math>

 are independent, thus the expectation of the power of 

<math display="inline" id="Additive_white_Gaussian_noise:97">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>

 is, for noise level 

<math display="inline" id="Additive_white_Gaussian_noise:98">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:99">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>Y</mi>
      <mi>i</mi>
      <mn>2</mn>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <ci>i</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>i</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(Y_{i}^{2})=P_{i}+N\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>And, if 

<math display="inline" id="Additive_white_Gaussian_noise:100">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
 </semantics>
</math>

 is normally distributed, we have that</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:101">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>Y</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mn>2</mn>
      <mi>œÄ</mi>
      <mi>e</mi>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi>i</mi>
      </msub>
      <mo>+</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>œÄ</ci>
       <ci>e</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(Y_{i})\leq\frac{1}{2}\log{2\pi e}(P_{i}+N)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore,</p>

<p>

<math display="inline" id="Additive_white_Gaussian_noise:102">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle nR
  </annotation>
 </semantics>
</math>


</p>

<p>We may apply Jensen's equality to 

<math display="inline" id="Additive_white_Gaussian_noise:103">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log(1+x)
  </annotation>
 </semantics>
</math>

, a concave (downward) function of <em>x</em>, to get:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:104">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <mfrac>
          <msub>
           <mi>P</mi>
           <mi>i</mi>
          </msub>
          <mi>N</mi>
         </mfrac>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mi>n</mi>
        </mfrac>
        <mrow>
         <munderover>
          <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
          <mrow>
           <mi>i</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
          <mi>n</mi>
         </munderover>
         <mfrac>
          <msub>
           <mi>P</mi>
           <mi>i</mi>
          </msub>
          <mi>N</mi>
         </mfrac>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <log></log>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>P</ci>
           <ci>i</ci>
          </apply>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>n</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>n</ci>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>P</ci>
           <ci>i</ci>
          </apply>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{n}\sum_{i=1}^{n}\frac{1}{2}\log\left(1+\frac{P_{i}}{N}\right)\leq%
\frac{1}{2}\log\left(1+\frac{1}{n}\sum_{i=1}^{n}\frac{P_{i}}{N}\right)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Because each codeword individually satisfies the power constraint, the average also satisfies the power constraint. Therefore</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:105">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mi>n</mi>
   </mfrac>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mfrac>
     <msub>
      <mi>P</mi>
      <mi>i</mi>
     </msub>
     <mi>N</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{n}\sum_{i=1}^{n}\frac{P_{i}}{N}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Which we may apply to simplify the inequality above and get:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:106">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mi>n</mi>
        </mfrac>
        <mrow>
         <munderover>
          <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
          <mrow>
           <mi>i</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
          <mi>n</mi>
         </munderover>
         <mfrac>
          <msub>
           <mi>P</mi>
           <mi>i</mi>
          </msub>
          <mi>N</mi>
         </mfrac>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mfrac>
        <mi>P</mi>
        <mi>N</mi>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>n</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>n</ci>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>P</ci>
           <ci>i</ci>
          </apply>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <ci>P</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}\log\left(1+\frac{1}{n}\sum_{i=1}^{n}\frac{P_{i}}{N}\right)\leq%
\frac{1}{2}\log\left(1+\frac{P}{N}\right)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, it must be that 

<math display="inline" id="Additive_white_Gaussian_noise:107">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>‚â§</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mfrac>
         <mi>P</mi>
         <mi>N</mi>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>œµ</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>R</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <log></log>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <divide></divide>
         <ci>P</ci>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œµ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\leq\frac{1}{2}\log\left(1+\frac{P}{N}\right)+\epsilon_{n}
  </annotation>
 </semantics>
</math>

. Therefore, R must be less than a value arbitrarily close to the capacity derived earlier, as 

<math display="inline" id="Additive_white_Gaussian_noise:108">
 <semantics>
  <mrow>
   <msub>
    <mi>œµ</mi>
    <mi>n</mi>
   </msub>
   <mo>‚Üí</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üí</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œµ</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{n}\rightarrow 0
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="effects-in-time-domain">Effects in time domain</h2>
<figure><b>(Figure)</b>
<figcaption>Zero-Crossings of a Noisy Cosine</figcaption>
</figure>

<p>In serial data communications, the AWGN mathematical model is used to model the timing error caused by random <a class="uri" href="jitter" title="wikilink">jitter</a> (RJ).</p>

<p>The graph to the right shows an example of timing errors associated with AWGN. The variable Œît represents the uncertainty in the zero crossing. As the amplitude of the AWGN is increased, the <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a> decreases. This results in increased uncertainty Œît.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>When affected by AWGN, The average number of either positive going or negative going zero-crossings per second at the output of a narrow bandpass filter when the input is a sine wave is:</p>

<p>

<math display="block" id="Additive_white_Gaussian_noise:109">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mpadded width="+5pt">
      <mi>positive</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>zero</mi>
     </mpadded>
     <mi>crossings</mi>
    </mrow>
    <mi>second</mi>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mpadded width="+5pt">
      <mi>negative</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>zero</mi>
     </mpadded>
     <mi>crossings</mi>
    </mrow>
    <mi>second</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>positive</ci>
      <ci>zero</ci>
      <ci>crossings</ci>
     </apply>
     <ci>second</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>negative</ci>
      <ci>zero</ci>
      <ci>crossings</ci>
     </apply>
     <ci>second</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\mathrm{positive\ zero\ crossings}}{\mathrm{second}}=\frac{\mathrm{%
negative\ zero\ crossings}}{\mathrm{second}}
  </annotation>
 </semantics>
</math>

<br/>


<math display="block" id="Additive_white_Gaussian_noise:110">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mn>0</mn>
    </msub>
    <msqrt>
     <mfrac>
      <mrow>
       <mi>SNR</mi>
       <mo>+</mo>
       <mn>1</mn>
       <mo>+</mo>
       <mfrac>
        <msup>
         <mi>B</mi>
         <mn>2</mn>
        </msup>
        <mrow>
         <mn>12</mn>
         <msubsup>
          <mi>f</mi>
          <mn>0</mn>
          <mn>2</mn>
         </msubsup>
        </mrow>
       </mfrac>
      </mrow>
      <mrow>
       <mi>SNR</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <ci>SNR</ci>
        <cn type="integer">1</cn>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>B</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">12</cn>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <cn type="integer">0</cn>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <ci>SNR</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =f_{0}\sqrt{\frac{\mathrm{SNR}+1+\frac{B^{2}}{12f_{0}^{2}}}{\mathrm{SNR}+1}}
  </annotation>
 </semantics>
</math>

</p>

<p>Where</p>
<ul>
<li>f<sub>0</sub> = the center frequency of the filter</li>
<li>B = the filter bandwidth</li>
<li>SNR = the signal-to-noise power ratio in linear terms</li>
</ul>
<h2 id="effects-in-phasor-domain">Effects in phasor domain</h2>
<figure><b>(Figure)</b>
<figcaption>AWGN Contributions in the Phasor Domain</figcaption>
</figure>

<p>In modern communication systems, bandlimited AWGN cannot be ignored. When modeling bandlimited AWGN in the <a class="uri" href="phasor" title="wikilink">phasor</a> domain, statistical analysis reveals that the amplitudes of the real and imaginary contributions are independent variables which follow the <a href="Gaussian_distribution" title="wikilink">Gaussian distribution</a> model. When combined, the resultant phasor's magnitude is a <a href="Rayleigh_distribution" title="wikilink">Rayleigh distributed</a> random variable while the phase is uniformly distributed from 0 to 2œÄ.</p>

<p>The graph to the right shows an example of how bandlimited AWGN can affect a coherent carrier signal. The instantaneous response of the Noise Vector cannot be precisely predicted, however its time-averaged response can be statistically predicted. As shown in the graph, we confidently predict that the noise phasor will reside inside the 1œÉ circle about 38% of the time; the noise phasor will reside inside the 2œÉ circle about 86% of the time; and the noise phasor will reside inside the 3œÉ circle about 98% of the time.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Ground_bounce" title="wikilink">Ground bounce</a></li>
<li><a href="Noisy-channel_coding_theorem" title="wikilink">Noisy-channel coding theorem</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a class="uri" href="Category:Noise" title="wikilink">Category:Noise</a> <a href="Category:Time_series_models" title="wikilink">Category:Time series models</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
