   CBC-MAC      CBC-MAC   In cryptography , a cipher block chaining message authentication code ( CBC-MAC ) is a technique for constructing a message authentication code from a block cipher . The message is encrypted with some block cipher algorithm in CBC mode to create a chain of blocks such that each block depends on the proper encryption of the previous block. This interdependence ensures that a change to any of the plaintext bits will cause the final encrypted block to change in a way that cannot be predicted or counteracted without knowing the key to the block cipher.  To calculate the CBC-MAC of message   m   m   m   one encrypts   m   m   m   in CBC mode with zero initialization vector . The following figure sketches the computation of the CBC-MAC of a message comprising blocks     m  1   ∥   m  2   ∥  ⋯  ∥   m  x      fragments   subscript  m  1   parallel-to   subscript  m  2   parallel-to  normal-⋯  parallel-to   subscript  m  x     m_{1}\|m_{2}\|\cdots\|m_{x}   using a secret key   k   k   k   and a block cipher   E   E   E   :  (Figure)  CBC-MAC structure (en).svg   Security with fixed and variable-length messages  If the block cipher used is secure (meaning that it is a pseudorandom permutation ), then CBC-MAC is secure for fixed-length messages. 1 However, by itself, it is not secure for variable-length messages. Thus, any single key must only be used for messages of a fixed and known length. This is because an attacker who knows the correct message-tag (i.e. CBC-MAC) pairs for two messages    (  m  ,     fragments  normal-(  m  normal-,    (m,       t  )     fragments  t  normal-)    t)   and    (   m  ′   ,     fragments  normal-(   superscript  m  normal-′   normal-,    (m^{\prime},        t  ′   )     fragments   superscript  t  normal-′   normal-)    t^{\prime})   can generate a third message    m  ′′     superscript  m  ′′    m^{\prime\prime}   whose CBC-MAC will also be    t  ′     superscript  t  normal-′    t^{\prime}   . This is simply done by XORing the first block of    m  ′     superscript  m  normal-′    m^{\prime}   with   t   t   t   and then concatenating   m   m   m   with this modified    m  ′     superscript  m  normal-′    m^{\prime}   ; i.e., by making     m  ′′   =  m  ∥   [   (   m  1  ′   ⊕  t  )   ∥   m  2  ′   ∥  …  ∥   m  x  ′   ]      fragments   superscript  m  ′′    m  parallel-to   fragments  normal-[   fragments  normal-(   superscript   subscript  m  1   normal-′   direct-sum  t  normal-)   parallel-to   superscript   subscript  m  2   normal-′   parallel-to  normal-…  parallel-to   superscript   subscript  m  x   normal-′   normal-]     m^{\prime\prime}=m\|[(m_{1}^{\prime}\oplus t)\|m_{2}^{\prime}\|\dots\|m_{x}^{%
 \prime}]   . When computing the MAC for the message    m  ′′     superscript  m  ′′    m^{\prime\prime}   , it follows that we compute the MAC for   m   m   m   in the usual manner as   t   t   t   , but when this value is chained forwards to the stage computing     E   K  MAC     (    m  1  ′   ⊕  t   )        subscript  E   subscript  K  MAC     direct-sum   superscript   subscript  m  1   normal-′   t     E_{K_{\text{MAC}}}(m_{1}^{\prime}\oplus t)   we will perform an exclusive OR operation with the value derived for the MAC of the first message. The presence of that tag in the new message means it will cancel, leaving no contribution to the MAC from the blocks of plain text in the first message   m   m   m         E   K  MAC     (    m  1  ′   ⊕  t  ⊕  t   )    =    E   K  MAC     (   m  1  ′   )           subscript  E   subscript  K  MAC     direct-sum   superscript   subscript  m  1   normal-′   t  t       subscript  E   subscript  K  MAC     superscript   subscript  m  1   normal-′      E_{K_{\text{MAC}}}(m_{1}^{\prime}\oplus t\oplus t)=E_{K_{\text{MAC}}}(m_{1}^{%
 \prime})   and thus the tag for    m  ′′     superscript  m  ′′    m^{\prime\prime}   is    t  ′     superscript  t  normal-′    t^{\prime}   .  This problem cannot be solved by adding a message-size block to the end. 2 There are three main ways of modifying CBC-MAC so that it is secure for variable length messages: 1) Input-length key separation; 2) Length-prepending; 3) Encrypt last block. 3 In such a case, it may also be recommended to use a different mode of operation, for example, CMAC or HMAC to protect the integrity of variable-length messages.  Length prepending  One solution is to include the length of the message in the first block; 4 in fact CBC-MAC has been proven secure as long as no two messages that are prefixes of each other are ever used and prepending the length is a special case of this. 5 This can be problematic if the message length may not be known when processing begins.  Encrypt-last-block  Encrypt-last-block CBC-MAC (ECBC-MAC) 6 is defined as     CBC-MAC-ELB   (  m  ,   (   k  1   ,   k  2   )   )    =   E   (   k  2   ,   CBC-MAC   (   k  1   ,  m  )    )          CBC-MAC-ELB   m    subscript  k  1    subscript  k  2        E    subscript  k  2     CBC-MAC    subscript  k  1   m        \text{CBC-MAC-ELB}(m,(k_{1},k_{2}))=E(k_{2},\text{CBC-MAC}(k_{1},m))   . 7 Compared to the other discussed methods of extending CBC-MAC to variable-length messages, encrypt-last-block has the advantage of not needing to know the length of the message until the end of the computation.  (Figure)  Computation of CBC-MAC Encrypt-last-block.   Attack methods  As with many cryptographic schemes, naïve use of ciphers and other protocols may lead to attacks being possible, reducing the effectiveness of the cryptographic protection (or even rendering it useless). We present attacks which are possible due to using the CBC-MAC incorrectly.  Using the same key for encryption and authentication  One common mistake is to reuse the same key   k   k   k   for CBC encryption and CBC-MAC. Although a reuse of a key for different purposes is a bad practice in general, in this particular case the mistake leads to a spectacular attack:  Suppose Alice has sent to Bob the cipher text blocks    C  =     C  1     |    |    C  2    |    |   …   |    |    C  n        C     subscript  C  1          subscript  C  2      normal-…      subscript  C  n      C=C_{1}\ ||\ C_{2}\ ||\ \dots\ ||\ C_{n}   . During the transmission process, Eve can tamper with any of the     C  1   ,  …  ,   C   n  -  1        subscript  C  1   normal-…   subscript  C    n  1      C_{1},\dots,C_{n-1}   cipher-text blocks and adjust any of the bits therein as she chooses, provided that the final block,    C  n     subscript  C  n    C_{n}   , remains the same. We assume, for the purposes of this example and without loss of generality, that the initialisation vector used for the encryption process is a vector of zeroes.  When Bob receives the message, he will first decrypt the message by reversing the encryption process which Alice applied, using the cipher text blocks    C  =     C  1     |    |    C  2    |    |   ⋯   |    |    C  n        C     subscript  C  1          subscript  C  2      normal-⋯      subscript  C  n      C=C_{1}\ ||\ C_{2}\ ||\ \cdots\ ||\ C_{n}   . During the transmission process, Eve can tamper with any of the     C  1   ,  …  ,   C   n  -  1        subscript  C  1   normal-…   subscript  C    n  1      C_{1},\dots,C_{n-1}   cipher text blocks and adjust any of the bits therein as she chooses, provided that the final block,    C  n     subscript  C  n    C_{n}   , remains the same. Her tampered version, later delivered to Bob in replacement of Alice's original, is     C  ′   =     C  1  ′     |    |   …   |    |    C   n  -  1   ′    |    |    C  n         superscript  C  normal-′      superscript   subscript  C  1   normal-′         normal-…      superscript   subscript  C    n  1    normal-′       subscript  C  n      C^{\prime}=C_{1}^{\prime}\ ||\ \dots\ ||\ C_{n-1}^{\prime}\ ||\ C_{n}   .  Bob first decrypts the message received using the shared secret key   K   K   K   to obtain corresponding plain text. Note that all plain text produced will be different from that which Alice originally sent, because Eve has modified all but the last cipher text block. In particular, the final plain text,    P  n  ′     superscript   subscript  P  n   normal-′    P_{n}^{\prime}   , differs from the original,    P  n     subscript  P  n    P_{n}   , which Alice sent; although    C  n     subscript  C  n    C_{n}   is the same,     C   n  -  1   ′   ≠   C   n  -  1         superscript   subscript  C    n  1    normal-′    subscript  C    n  1      C_{n-1}^{\prime}\not=C_{n-1}   , so a different plain text    P  n  ′     superscript   subscript  P  n   normal-′    P_{n}^{\prime}   is produced when chaining the previous cipher text block into the exclusive-OR after decryption of    C  n     subscript  C  n    C_{n}        P  n  ′   =    C   n  -  1   ′   ⊕    E  K   -  1     (   C  n   )          superscript   subscript  P  n   normal-′    direct-sum   superscript   subscript  C    n  1    normal-′      superscript   subscript  E  K     1     subscript  C  n       P_{n}^{\prime}=C_{n-1}^{\prime}\oplus E_{K}^{-1}(C_{n})   .  It follows that Bob will now compute the authentication tag using CBC-MAC over all the values of plain text which he decoded. The tag for the new message,    t  ′     superscript  t  normal-′    t^{\prime}   , is given by:       t  ′   =    E  K    (    P  n  ′   ⊕    E  K    (    P   n  -  1   ′   ⊕    E  K    (   …  ⊕    E  K    (   P  1  ′   )     )     )     )         superscript  t  normal-′      subscript  E  K    direct-sum   superscript   subscript  P  n   normal-′      subscript  E  K    direct-sum   superscript   subscript  P    n  1    normal-′      subscript  E  K    direct-sum  normal-…     subscript  E  K    superscript   subscript  P  1   normal-′            t^{\prime}=E_{K}(P_{n}^{\prime}\oplus E_{K}(P_{n-1}^{\prime}\oplus E_{K}(\dots%
 \oplus E_{K}(P_{1}^{\prime}))))     Notice that this expression is equal to       t  ′   =    E  K    (    P  n  ′   ⊕   C   n  -  1   ′    )         superscript  t  normal-′      subscript  E  K    direct-sum   superscript   subscript  P  n   normal-′    superscript   subscript  C    n  1    normal-′       t^{\prime}=E_{K}(P_{n}^{\prime}\oplus C_{n-1}^{\prime})     which is exactly    C  n     subscript  C  n    C_{n}   :       t  ′   =    E  K    (    C   n  -  1   ′   ⊕    E  K   -  1     (   C  n   )    ⊕   C   n  -  1   ′    )    =    E  K    (    E  K   -  1     (   C  n   )    )    =   C  n          superscript  t  normal-′      subscript  E  K    direct-sum   superscript   subscript  C    n  1    normal-′      superscript   subscript  E  K     1     subscript  C  n     superscript   subscript  C    n  1    normal-′             subscript  E  K      superscript   subscript  E  K     1     subscript  C  n           subscript  C  n      t^{\prime}=E_{K}(C_{n-1}^{\prime}\oplus E_{K}^{-1}(C_{n})\oplus C_{n-1}^{%
 \prime})=E_{K}(E_{K}^{-1}(C_{n}))=C_{n}     and it follows that     t  ′   =   C  n   =  t         superscript  t  normal-′    subscript  C  n        t     t^{\prime}=C_{n}=t   .  Therefore, Eve was able to modify the cipher text in transit (without necessarily knowing what plain text it corresponds to) such that an entirely different message,    P  ′     superscript  P  normal-′    P^{\prime}   , was produced, but the tag for this message matched the tag of the original, and Bob was unaware that the contents had been modified in transit. By definition, a Message Authentication Code is broken if we can find a different message (a sequence of plain-text pairs    P  ′     superscript  P  normal-′    P^{\prime}   ) which produces the same tag as the previous message,   P   P   P   , with    P  ≠   P  ′       P   superscript  P  normal-′     P\not=P^{\prime}   . It follows that the message authentication protocol, in this usage scenario, has been broken, and Bob has been deceived into believing Alice sent him a message which she did not produce.  If, instead, we use different keys for the encryption and authentication stages, say    K  1     subscript  K  1    K_{1}   and    K  2     subscript  K  2    K_{2}   , respectively, this attack is foiled. The decryption of the modified cipher-text blocks    C  i  ′     superscript   subscript  C  i   normal-′    C_{i}^{\prime}   obtains some plain text string    P  i  ′     superscript   subscript  P  i   normal-′    P_{i}^{\prime}   . However, due to the MAC's usage of a different key    K  2     subscript  K  2    K_{2}   , we cannot "undo" the decryption process in the forward step of the computation of the message authentication code so as to produce the same tag; each modified    P  i  ′     superscript   subscript  P  i   normal-′    P_{i}^{\prime}   will now be encrypted by    K  2     subscript  K  2    K_{2}   in the CBC-MAC process to some value     M  A   C  i    ≠   C  i  ′         M  A   subscript  C  i     superscript   subscript  C  i   normal-′     MAC_{i}\not=C_{i}^{\prime}   .  This example also shows that a CBC-MAC cannot be used as a collision resistant one-way function: given a key it is trivial to create a different message which "hashes" to the same tag.  Allowing the initialisation vector to vary in value  When encrypting data using a block cipher in cipher block chaining (or another) mode, it is common to introduce an initialization vector to the first stage of the encryption process. It is typically required that this vector be chosen randomly (a nonce ) and that it is not repeated for any given secret key under which the block cipher operates. This provides semantic security, by means of ensuring the same plain text is not encrypted to the same cipher text, allowing an attacker to infer a relationship exists.  When computing a message authentication code, such as by CBC-MAC, the use of an initialisation vector is a possible attack vector.  In the operation of a cipher block chaining cipher, the first block of plain text is mixed with the initialisation vector using an exclusive OR (     P  1   ⊕   I  V      direct-sum   subscript  P  1     I  V     P_{1}\oplus IV   ). The result of this operation is the input to the block cipher for encryption.  However, when performing encryption and decryption, we are required to send the initialisation vector in plain text - typically as the block immediately preceding the first block of cipher text - such that the first block of plain text can be decrypted and recovered successfully. If computing a MAC, we will also need to transmit the initialisation vector to the other party in plain text so that they can verify the tag on the message matches the value they have computed.  If we allow the initialisation vector to be selected arbitrarily, it follows that the first block of plain text can potentially be modified (transmitting a different message) while producing the same message tag.  Consider a message     M  1   =    P  1    |   P  2   |   …        subscript  M  1      subscript  P  1      subscript  P  2    normal-…     M_{1}=P_{1}|P_{2}|\dots   . In particular, when computing the message tag for CBC-MAC, suppose we choose an initialisation vector    I   V  1       I   subscript  V  1     IV_{1}   such that computation of the MAC begins with     E  K    (    I   V  1    ⊕   P  1    )        subscript  E  K    direct-sum    I   subscript  V  1     subscript  P  1      E_{K}(IV_{1}\oplus P_{1})   . This produces a (message, tag) pair    (   M  1   ,   T  1   )      subscript  M  1    subscript  T  1     (M_{1},T_{1})   .  Now produce the message     M  2   =    P  1  ′    |   P  2   |   …        subscript  M  2      superscript   subscript  P  1   normal-′      subscript  P  2    normal-…     M_{2}=P_{1}^{\prime}|P_{2}|\dots   . For each bit modified in    P  1  ′     superscript   subscript  P  1   normal-′    P_{1}^{\prime}   , flip the corresponding bit in the initialisation vector to produce the initialisation vector    I   V  1  ′       I   superscript   subscript  V  1   normal-′     IV_{1}^{\prime}   . It follows that to compute the MAC for this message, we begin the computation by     E  K    (    P  1  ′   ⊕   I   V  1  ′     )        subscript  E  K    direct-sum   superscript   subscript  P  1   normal-′     I   superscript   subscript  V  1   normal-′       E_{K}(P_{1}^{\prime}\oplus IV_{1}^{\prime})   . As bits in both the plain text and initialisation vector have been flipped in the same places, the modification is cancelled in this first stage, meaning the input to the block cipher is identical to that for    M  1     subscript  M  1    M_{1}   . If no further changes are made to the plain text, the same tag will be derived despite a different message being transmitted.  If the freedom to select an initialisation vector is removed and all implementations of CBC-MAC fix themselves on a particular initialisation vector (often the vector of zeroes, but in theory, it could be anything provided all implementations agree), this attack cannot proceed.  Standards that define the algorithm  FIPS PUB 113  Computer Data Authentication is a (now obsolete) U.S. government standard that specified the CBC-MAC algorithm using DES as the block cipher.  The CBC-MAC algorithm is equivalent to ISO/IEC 9797-1 MAC Algorithm 1.  See also   CMAC – A block-cipher–based MAC algorithm which is secure for messages of different lengths (recommended by NIST ).  OMAC and PMAC – Other methods to turn block ciphers into message authentication codes (MACs).  One-way compression function – Hash functions can be made from block ciphers. But note, there are significant differences in function and uses for security between MACs (such as CBC-MAC) and hashes .   References  "  Category:Message authentication codes  Category:Block cipher modes of operation     M. Bellare, J. Kilian and P. Rogaway. The security of the cipher block chaining message authentication code. JCSS 61(3):362–399, 2000. ↩    ISO/IEC 9797-1:1999 Information technology – Security techniques – Message Authentication Codes (MACs) – Part 1: Mechanisms using a block cipher , clause 6.1.3 Padding Method 3 ↩  C. Rackoff and S. Gorbunov. On the Security of Block Chaining Message Authentication Code. ↩  http://spark-university.s3.amazonaws.com/stanford-crypto/slides/05.3-integrity-cbc-mac-and-nmac.pptx ↩  See Section 5 of Bellare, et al. ↩     