   Modal μ-calculus      Modal μ-calculus   In theoretical computer science , the modal μ-calculus ( Lμ , L μ , sometimes just μ-calculus , although this can have a more general meaning) is an extension of propositional  modal logic (with many modalities ) by adding a least fixpoint operator μ and a greatest fixpoint operator   ν   ν   \nu   , thus a fixed-point logic .  The (propositional, modal) μ-calculus originates with Dana Scott and Jaco de Bakker , 1 and was further developed by Dexter Kozen into the version most used nowadays. It is used to describe properties of labelled transition systems and for verifying these properties. Many temporal logics can be encoded in the μ-calculus, including CTL* and its widely used fragments— linear temporal logic and computational tree logic . 2  An algebraic view is to see it as an algebra of monotonic functions over a complete lattice , with operators consisting of functional composition plus the least and greatest fixed point operators; from this viewpoint, the modal μ-calculus is over the lattice of a power set algebra . 3 The game semantics of μ-calculus is related to two-player games with perfect information , particularly infinite parity games . 4  Syntax  Let P (propositions) and A (actions) be two finite sets of symbols, and let V be a countably infinite set of variables. The set of formulas of (propositional, modal) μ-calculus is defined as follows:   each proposition and each variable is a formula;  if   ϕ   ϕ   \phi   and   ψ   ψ   \psi   are formulas, then    ϕ  ∧  ψ      ϕ  ψ    \phi\wedge\psi   is a formula.  if   ϕ   ϕ   \phi   is a formula, then    ¬  ϕ       ϕ    \neg\phi   is a formula;  if   ϕ   ϕ   \phi   is a formula and   a   a   a   is an action, then     [  a  ]   ϕ       delimited-[]  a   ϕ    [a]\phi   is a formula;(pronounced either   a   a   a   box   ϕ   ϕ   \phi   or after   a   a   a   necessarily   ϕ   ϕ   \phi   )  if   ϕ   ϕ   \phi   is a formula and   Z   Z   Z   a variable, then     ν  Z   .  ϕ     formulae-sequence    ν  Z   ϕ    \nu Z.\phi   is a formula, provided that every free occurrence of   Z   Z   Z   in   ϕ   ϕ   \phi   occurs positively, i.e. within the scope of an even number of negations.   (The notions of free and bound variables are as usual, where   ν   ν   \nu   is the only binding operator.)  Given the above definitions, we can enrich the syntax with:       ϕ  ∨  ψ      ϕ  ψ    \phi\lor\psi   meaning    ¬   (    ¬  ϕ   ∧   ¬  ψ    )            ϕ      ψ      \neg(\neg\phi\land\neg\psi)          ⟨  a  ⟩   ϕ       delimited-⟨⟩  a   ϕ    \langle a\rangle\phi   (pronounced either   a   a   a   diamond   ϕ   ϕ   \phi   or after   a   a   a   possibly   ϕ   ϕ   \phi   ) meaning     ¬   [  a  ]    ¬  ϕ        a    ϕ    \neg[a]\neg\phi          μ  Z   .  ϕ     formulae-sequence    μ  Z   ϕ    \mu Z.\phi   means    ¬  ν  Z  .  ¬  ϕ   [  Z  :=  ¬  Z  ]      fragments   ν  Z  normal-.   ϕ   fragments  normal-[  Z  assign   Z  normal-]     \neg\nu Z.\neg\phi[Z:=\neg Z]   , where    ϕ   [  Z  :=  ¬  Z  ]      fragments  ϕ   fragments  normal-[  Z  assign   Z  normal-]     \phi[Z:=\neg Z]   means substituting    ¬  Z       Z    \neg Z   for Z in all free occurrences of Z in   ϕ   ϕ   \phi   .   The first two formulas are the familiar ones from the classical propositional calculus and respectively the minimal multimodal logic  K .  The notation     μ  Z   .  ϕ     formulae-sequence    μ  Z   ϕ    \mu Z.\phi   (and its dual) are inspired from the lambda calculus ; the intent is to denote the least (and respectively greatest) fixed point of the expression   ϕ   ϕ   \phi   where the "minimization" (and respectively "maximization") are in the variable Z , much like in lambda calculus     λ  Z   .  ϕ     formulae-sequence    λ  Z   ϕ    \lambda Z.\phi   is a function with formula   ϕ   ϕ   \phi   in bound variable  Z ; 5 see the denotational semantics below for details.  Denotational semantics  Models of (propositional) μ-calculus are given as labelled transition systems     (  S  ,  R  ,  V  )     S  R  V    (S,R,V)   where:      S   S   S   is a set of states;     R   R   R   maps to each label   a   a   a   a relation on   S   S   S   ;      V  :   Var  →   2  S       normal-:  V   normal-→  Var   superscript  2  S      V:\mbox{Var}\rightarrow 2^{S}   , maps to each proposition    p  ∈  Prop      p  Prop    p\in\mbox{Prop}   the set of states where the proposition is true.   Given a labelled transition system    (  S  ,  R  ,  V  )     S  R  V    (S,R,V)   and an interpretation   i   i   i   of the formulas   ϕ   ϕ   \phi   of   μ   μ   \mu   -calculus,      [   [    ¯   ]   ]   i   :   ϕ  →   2  S       normal-:   subscript   delimited-[]   delimited-[]   normal-¯  absent     i    normal-→  ϕ   superscript  2  S      [\![\underline{~{}\,}]\!]_{i}:\phi\rightarrow 2^{S}   , is the function defined by the following rules:         [   [  p  ]   ]   i   =   V   (  p  )         subscript   delimited-[]   delimited-[]  p    i     V  p     [\![p]\!]_{i}=V(p)   ;        [   [   ϕ  ∧  ψ   ]   ]   i   =     [   [  ϕ  ]   ]   i   ∩    [   [  ψ  ]   ]   i         subscript   delimited-[]   delimited-[]    ϕ  ψ     i      subscript   delimited-[]   delimited-[]  ϕ    i    subscript   delimited-[]   delimited-[]  ψ    i      [\![\phi\wedge\psi]\!]_{i}=[\![\phi]\!]_{i}\cap[\![\psi]\!]_{i}   ;        [   [   ¬  ϕ   ]   ]   i   =   S  ∖    [   [  ϕ  ]   ]   i         subscript   delimited-[]   delimited-[]     ϕ     i     S   subscript   delimited-[]   delimited-[]  ϕ    i      [\![\neg\phi]\!]_{i}=S\smallsetminus[\![\phi]\!]_{i}   ;        [   [    [  a  ]   ϕ   ]   ]   i   =   {   s  ∈  S   ∣     ∀  t   ∈  S   ,    (  s  ,  t  )   ∈   R  a   →  t  ∈    [   [  ϕ  ]   ]   i     }        subscript   delimited-[]   delimited-[]     delimited-[]  a   ϕ     i    conditional-set    s  S    formulae-sequence     for-all  t   S        s  t    subscript  R  a     normal-→    t        subscript   delimited-[]   delimited-[]  ϕ    i         [\![[a]\phi]\!]_{i}=\{s\in S\mid\forall t\in S,(s,t)\in R_{a}\rightarrow t\in[%
 \![\phi]\!]_{i}\}   ;        [   [  ν  Z  .  ϕ  ]   ]   i   =  ⋃   {  T  ⊆  S  ∣  T  ⊆    [   [  ϕ  ]   ]    i   [  Z  :=  T  ]     }      fragments   subscript   fragments  normal-[   fragments  normal-[  ν  Z  normal-.  ϕ  normal-]   normal-]   i      fragments  normal-{  T   S  normal-∣  T    subscript   fragments  normal-[   fragments  normal-[  ϕ  normal-]   normal-]    fragments  i   fragments  normal-[  Z  assign  T  normal-]     normal-}     [\![\nu Z.\phi]\!]_{i}=\bigcup\{T\subseteq S\mid T\subseteq[\![\phi]\!]_{i[Z:=%
 T]}\}   , where    i   [  Z  :=  T  ]      fragments  i   fragments  normal-[  Z  assign  T  normal-]     i[Z:=T]   maps Z to T while preserving the mappings of   i   i   i   everywhere else.   By duality, the interpretation of the other basic formulas is:         [   [   ϕ  ∨  ψ   ]   ]   i   =     [   [  ϕ  ]   ]   i   ∪    [   [  ψ  ]   ]   i         subscript   delimited-[]   delimited-[]    ϕ  ψ     i      subscript   delimited-[]   delimited-[]  ϕ    i    subscript   delimited-[]   delimited-[]  ψ    i      [\![\phi\vee\psi]\!]_{i}=[\![\phi]\!]_{i}\cup[\![\psi]\!]_{i}   ;        [   [    ⟨  a  ⟩   ϕ   ]   ]   i   =   {   s  ∈  S   ∣     ∃  t   ∈  S   ,    (  s  ,  t  )   ∈    R  a   ∧  t   ∈    [   [  ϕ  ]   ]   i     }        subscript   delimited-[]   delimited-[]     delimited-⟨⟩  a   ϕ     i    conditional-set    s  S    formulae-sequence      t   S        s  t      subscript  R  a   t         subscript   delimited-[]   delimited-[]  ϕ    i         [\![\langle a\rangle\phi]\!]_{i}=\{s\in S\mid\exists t\in S,(s,t)\in R_{a}%
 \wedge t\in[\![\phi]\!]_{i}\}   ;        [   [  μ  Z  .  ϕ  ]   ]   i   =  ⋂   {  T  ⊆  S  ∣    [   [  ϕ  ]   ]    i   [  Z  :=  T  ]     ⊆  T  }      fragments   subscript   fragments  normal-[   fragments  normal-[  μ  Z  normal-.  ϕ  normal-]   normal-]   i      fragments  normal-{  T   S  normal-∣   subscript   fragments  normal-[   fragments  normal-[  ϕ  normal-]   normal-]    fragments  i   fragments  normal-[  Z  assign  T  normal-]      T  normal-}     [\![\mu Z.\phi]\!]_{i}=\bigcap\{T\subseteq S\mid[\![\phi]\!]_{i[Z:=T]}%
 \subseteq T\}      Less formally, this means that, for a given transition system    (  S  ,  R  ,  V  )     S  R  V    (S,R,V)   :      p   p   p   holds in the set of states    V   (  p  )       V  p    V(p)   ;      ϕ  ∧  ψ      ϕ  ψ    \phi\wedge\psi   holds in every state where   ϕ   ϕ   \phi   and   ψ   ψ   \psi   both hold;      ¬  ϕ       ϕ    \neg\phi   holds in every state where   ϕ   ϕ   \phi   does not hold.       [  a  ]   ϕ       delimited-[]  a   ϕ    [a]\phi   holds in a state   s   s   s   if every   a   a   a   -transition leading out of   s   s   s   leads to a state where   ϕ   ϕ   \phi   holds.       ⟨  a  ⟩   ϕ       delimited-⟨⟩  a   ϕ    \langle a\rangle\phi   holds in a state   s   s   s   if there exists   a   a   a   -transition leading out of   s   s   s   that leads to a state where   ϕ   ϕ   \phi   holds.       ν  Z   .  ϕ     formulae-sequence    ν  Z   ϕ    \nu Z.\phi   holds in any state in any set   T   T   T   such that, when the variable   Z   Z   Z   is set to   T   T   T   , then   ϕ   ϕ   \phi   holds for all of   T   T   T   . (From the Knaster–Tarski theorem it follows that     [   [  ν  Z  .  ϕ  ]   ]   i     subscript   fragments  normal-[   fragments  normal-[  ν  Z  normal-.  ϕ  normal-]   normal-]   i    [\![\nu Z.\phi]\!]_{i}   is the greatest fixpoint of     [   [  ϕ  ]   ]    i   [  Z  :=  T  ]       subscript   delimited-[]   delimited-[]  ϕ     fragments  i   fragments  normal-[  Z  assign  T  normal-]      [\![\phi]\!]_{i[Z:=T]}   , and     [   [  μ  Z  .  ϕ  ]   ]   i     subscript   fragments  normal-[   fragments  normal-[  μ  Z  normal-.  ϕ  normal-]   normal-]   i    [\![\mu Z.\phi]\!]_{i}   its least fixpoint.)   The interpretations of     [  a  ]   ϕ       delimited-[]  a   ϕ    [a]\phi   and     ⟨  a  ⟩   ϕ       delimited-⟨⟩  a   ϕ    \langle a\rangle\phi   are if fact the "classical" ones from dynamic logic . Additionally, the operator μ can be interpreted as liveness ("something good eventually happens") and ν as safety ("nothing bad ever happens") in Leslie Lamport 's informal classification. 6  Examples        ν  Z   .   ϕ  ∧    [  a  ]   Z       formulae-sequence    ν  Z     ϕ     delimited-[]  a   Z      \nu Z.\phi\wedge[a]Z   is interpreted as "   ϕ   ϕ   \phi   is true along every a -path". 7       μ  Z   .   ϕ  ∨    ⟨  a  ⟩   Z       formulae-sequence    μ  Z     ϕ     delimited-⟨⟩  a   Z      \mu Z.\phi\vee\langle a\rangle Z   is interpreted as the existence of a path along a -transitions to a state where   ϕ   ϕ   \phi   holds. 8  The property of a system of being deadlock -free, understood as having no states without outgoing transitions and furthermore there does not exists a path to such a state, is expressed by formula 9      ν  Z  .   (   ⋁   a  ∈  A     ⟨  a  ⟩   ⊤  ∧   ⋀   a  ∈  A     [  a  ]   Z  )      fragments  ν  Z  normal-.   fragments  normal-(   subscript     a  A     fragments  normal-⟨  a  normal-⟩   top    subscript     a  A     fragments  normal-[  a  normal-]   Z  normal-)     \nu Z.(\bigvee_{a\in A}\langle a\rangle\top\wedge\bigwedge_{a\in A}[a]Z)      Satisfiability  Satisfiability of a modal μ-calculus formula is EXPTIME-complete . 10  See also   Finite model theory  Alternation-free modal μ-calculus   Notes    References    , chapter 7, Model checking for the μ-calculus, pp. 97–108   , chapter 5, Modal μ-calculus, pp. 103–128   , chapter 6, The μ-calculus over powerset algebras, pp. 141–153 is about the modal μ-calculus  Yde Venema (2008) Lectures on the Modal μ-calculus ; was presented at The 18th European Summer School in Logic, Language and Information      External links   Sophie Pinchinat, Logic, Automata & Games video recording of a lecture at ANU Logic Summer School '09   "  Category:Modal logic  Category:Model checking     Kozen p. 333. ↩  Clarke p.108, Theorem 6; Emerson p. 196 ↩  Arnold and Niwiński, pp. viii-x and chapter 6 ↩  Arnold and Niwiński, pp. viii-x and chapter 4 ↩  Arnold and Niwiński, p. 14 ↩  Bradfield and Stirling, p. 731 ↩    ↩  ↩     