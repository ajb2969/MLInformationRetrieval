<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="513">Lagrange multiplier</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lagrange multiplier</h1>
<hr/>

<p> </p>

<p>In <a href="mathematical_optimization" title="wikilink">mathematical optimization</a>, the <strong>method of Lagrange multipliers</strong> (named after <a href="Joseph_Louis_Lagrange" title="wikilink">Joseph Louis Lagrange</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>) is a strategy for finding the local maxima and minima of a <a href="function_(mathematics)" title="wikilink">function</a> subject to <a href="constraint_(mathematics)" title="wikilink">equality constraints</a>.</p>

<p>For instance (see Figure 1), consider the <a href="optimization_problem" title="wikilink">optimization problem</a></p>
<dl>
<dd>maximize 

<math display="inline" id="Lagrange_multiplier:0">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>


</dd>
<dd>subject to 

<math display="inline" id="Lagrange_multiplier:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y)=c
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>We need both 

<math display="inline" id="Lagrange_multiplier:2">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lagrange_multiplier:3">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 to have continuous first <a href="partial_derivative" title="wikilink">partial derivatives</a>. We introduce a new variable (

<math display="inline" id="Lagrange_multiplier:4">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

) called a Lagrange multiplier and study the Lagrange function (or Lagrangian) defined by</p>

<p>

<math display="block" id="Lagrange_multiplier:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Λ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>λ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>λ</mi>
      <mo>⋅</mo>
      <mrow>
       <mo maxsize="160%" minsize="160%">(</mo>
       <mrow>
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mi>c</mi>
       </mrow>
       <mo maxsize="160%" minsize="160%">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>λ</ci>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>λ</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>g</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(x,y,\lambda)=f(x,y)+\lambda\cdot\Big(g(x,y)-c\Big),
  </annotation>
 </semantics>
</math>

</p>

<p>where the 

<math display="inline" id="Lagrange_multiplier:6">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 term may be either added or subtracted. If <mtpl></mtpl> is a maximum of 

<math display="inline" id="Lagrange_multiplier:7">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>

 for the original constrained problem, then there exists <mtpl></mtpl> such that <mtpl></mtpl> is a <a href="stationary_point" title="wikilink">stationary point</a> for the Lagrange function (stationary points are those points where the partial derivatives of 

<math display="inline" id="Lagrange_multiplier:8">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Λ
  </annotation>
 </semantics>
</math>

 are zero). However, not all stationary points yield a solution of the original problem. Thus, the method of Lagrange multipliers yields a <a href="necessary_condition" title="wikilink">necessary condition</a> for optimality in constrained problems.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><ref></ref></p>
<ul>
<li></li>
<li>

<p><ref></ref></p></li>
</ul>

<p><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Sufficient conditions for a minimum or maximum also exist.</p>
<h2 id="introduction">Introduction</h2>

<p>One of the most common problems in calculus is that of finding maxima or minima (in general, "extrema") of a function, but it is often difficult to find a closed form for the function being extremized. Such difficulties often arise when one wishes to maximize or minimize a function subject to fixed outside conditions or constraints. The method of Lagrange multipliers is a powerful tool for solving this class of problems without the need to explicitly solve the conditions and use them to eliminate extra variables.</p>

<p>Consider the two-dimensional problem introduced above:</p>
<dl>
<dd>maximize 

<math display="inline" id="Lagrange_multiplier:9">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>


</dd>
<dd>subject to 

<math display="inline" id="Lagrange_multiplier:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y)=0
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Lagrange multipliers relies on the intuition that at a maximum 

<math display="inline" id="Lagrange_multiplier:11">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>

 cannot be increasing in the direction of any neighboring point where 

<math display="inline" id="Lagrange_multiplier:12">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>g</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g=0
  </annotation>
 </semantics>
</math>

. If it were, we could walk along 

<math display="inline" id="Lagrange_multiplier:13">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>g</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g=0
  </annotation>
 </semantics>
</math>

 to get higher, meaning that the starting point wasn't actually the maximum.</p>

<p>We can visualize <a href="Contour_line" title="wikilink">contours</a> of 

<math display="inline" id="Lagrange_multiplier:14">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 given by 

<math display="inline" id="Lagrange_multiplier:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=d
  </annotation>
 </semantics>
</math>

 for various values of 

<math display="inline" id="Lagrange_multiplier:16">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

, and the contour of 

<math display="inline" id="Lagrange_multiplier:17">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 given by 

<math display="inline" id="Lagrange_multiplier:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y)=0
  </annotation>
 </semantics>
</math>

.</p>

<p>Suppose we walk along the contour line with 

<math display="inline" id="Lagrange_multiplier:19">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>g</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g=0
  </annotation>
 </semantics>
</math>

. We are interested in finding points where 

<math display="inline" id="Lagrange_multiplier:20">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 does not change as we walk, since these points might be maxima. There are two ways this could happen: First, we could be following a contour line of 

<math display="inline" id="Lagrange_multiplier:21">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, since by definition 

<math display="inline" id="Lagrange_multiplier:22">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 does not change as we walk along its contour lines. This would mean that the contour lines of 

<math display="inline" id="Lagrange_multiplier:23">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lagrange_multiplier:24">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 are parallel here. The second possibility is that we have reached a "level" part of 

<math display="inline" id="Lagrange_multiplier:25">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, meaning that 

<math display="inline" id="Lagrange_multiplier:26">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 does not change in any direction.</p>

<p>To check the first possibility, notice that since the <a class="uri" href="gradient" title="wikilink">gradient</a> of a function is perpendicular to the contour lines, the contour lines of 

<math display="inline" id="Lagrange_multiplier:27">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lagrange_multiplier:28">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 are parallel if and only if the gradients of 

<math display="inline" id="Lagrange_multiplier:29">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lagrange_multiplier:30">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 are parallel. Thus we want points 

<math display="inline" id="Lagrange_multiplier:31">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Lagrange_multiplier:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y)=0
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Lagrange_multiplier:33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∇</mo>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
     </mrow>
    </msub>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>λ</mi>
     <mrow>
      <msub>
       <mo>∇</mo>
       <mrow>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
       </mrow>
      </msub>
      <mi>g</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-∇</ci>
      <list>
       <ci>x</ci>
       <ci>y</ci>
      </list>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-∇</ci>
        <list>
         <ci>x</ci>
         <ci>y</ci>
        </list>
       </apply>
       <ci>g</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla_{x,y}f=-\lambda\nabla_{x,y}g
  </annotation>
 </semantics>
</math>

,</p>

<p>for some 

<math display="inline" id="Lagrange_multiplier:34">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Lagrange_multiplier:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mo>∇</mo>
       <mrow>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
       </mrow>
      </msub>
      <mi>f</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>f</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <mi>x</mi>
       </mrow>
      </mfrac>
      <mo>,</mo>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>f</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <mi>y</mi>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mrow>
      <msub>
       <mo>∇</mo>
       <mrow>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
       </mrow>
      </msub>
      <mi>g</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>g</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <mi>x</mi>
       </mrow>
      </mfrac>
      <mo>,</mo>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>g</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <mi>y</mi>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <list>
        <ci>x</ci>
        <ci>y</ci>
       </list>
      </apply>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>f</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>f</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>y</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <list>
        <ci>x</ci>
        <ci>y</ci>
       </list>
      </apply>
      <ci>g</ci>
     </apply>
     <interval closure="open">
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>g</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>g</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>y</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla_{x,y}f=\left(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y%
}\right),\qquad\nabla_{x,y}g=\left(\frac{\partial g}{\partial x},\frac{%
\partial g}{\partial y}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>are the respective gradients. The constant 

<math display="inline" id="Lagrange_multiplier:36">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 is required because although the two gradient vectors are parallel, the magnitudes of the gradient vectors are generally not equal. (The negative is traditional). This constant is called the Lagrange multiplier.</p>

<p>Notice that this method also solves the second possibility: if 

<math display="inline" id="Lagrange_multiplier:37">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is level, then its gradient is zero, and setting 

<math display="inline" id="Lagrange_multiplier:38">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ=0
  </annotation>
 </semantics>
</math>

 is a solution regardless of 

<math display="inline" id="Lagrange_multiplier:39">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

.</p>

<p>To incorporate these conditions into one equation, we introduce an auxiliary function</p>

<p>

<math display="block" id="Lagrange_multiplier:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Λ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>λ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mi>λ</mi>
       <mo>⋅</mo>
       <mi>g</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>λ</ci>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>λ</ci>
       <ci>g</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(x,y,\lambda)=f(x,y)+\lambda\cdot g(x,y),
  </annotation>
 </semantics>
</math>

</p>

<p>and solve</p>

<p>

<math display="block" id="Lagrange_multiplier:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mrow>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>λ</mi>
      </mrow>
     </msub>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <list>
        <ci>x</ci>
        <ci>y</ci>
        <ci>λ</ci>
       </list>
      </apply>
      <ci>normal-Λ</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>λ</ci>
     </vector>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla_{x,y,\lambda}\Lambda(x,y,\lambda)=0.
  </annotation>
 </semantics>
</math>

</p>

<p>This is the method of Lagrange multipliers. Note that 

<math display="inline" id="Lagrange_multiplier:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mi>λ</mi>
     </msub>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <ci>λ</ci>
      </apply>
      <ci>normal-Λ</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>λ</ci>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla_{\lambda}\Lambda(x,y,\lambda)=0
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Lagrange_multiplier:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y)=0
  </annotation>
 </semantics>
</math>

.</p>

<p>The constrained extrema of 

<math display="inline" id="Lagrange_multiplier:44">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 are <em><a href="Critical_point_(mathematics)" title="wikilink">critical points</a></em> of the Lagrangian 

<math display="inline" id="Lagrange_multiplier:45">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Λ
  </annotation>
 </semantics>
</math>

, but they are not necessarily <em>local extrema</em> of 

<math display="inline" id="Lagrange_multiplier:46">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Λ
  </annotation>
 </semantics>
</math>

 (see <a href="#Example_2" title="wikilink">Example 2</a> below).</p>

<p>One may <a href="Hamiltonian_mechanics#As_a_reformulation_of_Lagrangian_mechanics" title="wikilink">reformulate the Lagrangian</a> as a <a href="Hamiltonian_mechanics" title="wikilink">Hamiltonian</a>, in which case the solutions are local minima for the Hamiltonian. This is done in <a href="optimal_control" title="wikilink">optimal control</a> theory, in the form of <a href="Pontryagin's_minimum_principle" title="wikilink">Pontryagin's minimum principle</a>.</p>

<p>The fact that solutions of the Lagrangian are not necessarily extrema also poses difficulties for numerical optimization. This can be addressed by computing the <em>magnitude</em> of the gradient, as the zeros of the magnitude are necessarily local minima, as illustrated in the <a href="#Example_4:_numerical_optimization" title="wikilink">numerical optimization example</a>.</p>
<h2 id="handling-multiple-constraints">Handling multiple constraints</h2>

<p>  The method of <em>Lagrange multipliers</em> can also accommodate multiple constraints. To see how this is done, we need to reexamine the problem in a slightly different manner because the concept of “crossing” discussed above becomes rapidly unclear when we consider the types of constraints that are created when we have more than one constraint acting together.</p>

<p>As an example, consider a <a class="uri" href="paraboloid" title="wikilink">paraboloid</a> with a constraint that is a single point (as might be created if we had 2 line constraints that intersect). The <a href="level_set" title="wikilink">level set</a> (i.e., contour line) clearly appears to “cross” that point and its <a class="uri" href="gradient" title="wikilink">gradient</a> is clearly not parallel to the gradients of either of the two line constraints. Yet, it is obviously a maximum <em>and</em> a minimum because there is only one point on the paraboloid that meets the constraint.</p>

<p>While this example seems a bit odd, it is easy to understand and is representative of the sort of “effective” constraint that appears quite often when we deal with multiple constraints intersecting. Thus, we take a slightly different approach below to explain and derive the Lagrange Multipliers method with any number of constraints.</p>

<p>Throughout this section, the independent variables will be denoted by <mtpl></mtpl> and, as a group, we will denote them as <mtpl> (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ..., <em>x<sub>N</sub></em>)}}</mtpl>. Also, the function being analyzed will be denoted by 

<math display="inline" id="Lagrange_multiplier:47">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(p)
  </annotation>
 </semantics>
</math>

 and the constraints will be represented by the equations <mtpl> <em>g</em><sub>2</sub>(<em>p</em>) {{=}} ... {{=}} <em>g<sub>M</sub></em>(<em>p</em>) {{=}} 0}}</mtpl>.</p>

<p>The basic idea remains essentially the same: if we consider only the points that satisfy the constraints (i.e., are <em>in</em> the constraints), then a point 

<math display="inline" id="Lagrange_multiplier:48">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>p</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,f(p))
  </annotation>
 </semantics>
</math>

 is a stationary point (i.e., a point in a “flat” region) of 

<math display="inline" id="Lagrange_multiplier:49">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 if and only if the constraints at that point do not allow movement in a direction where 

<math display="inline" id="Lagrange_multiplier:50">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 changes value.</p>

<p>Once we have located the stationary points, we need to do further tests to see if we have found a minimum, a maximum or just a stationary point that is neither.</p>

<p>We start by considering the level set of 

<math display="inline" id="Lagrange_multiplier:51">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Lagrange_multiplier:52">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>p</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,f(p))
  </annotation>
 </semantics>
</math>

. The set of vectors  containing the directions in which we can move and still remain in the same level set are the directions where the value of 

<math display="inline" id="Lagrange_multiplier:53">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 does not change (i.e., the change equals zero). Thus, for every vector 

<math display="inline" id="Lagrange_multiplier:54">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 in , the following relation must hold:</p>

<p>

<math display="block" id="Lagrange_multiplier:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mfrac>
     <msub>
      <mi>v</mi>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mfrac>
     <msub>
      <mi>v</mi>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>x</mi>
        <mi>N</mi>
       </msub>
      </mrow>
     </mfrac>
     <msub>
      <mi>v</mi>
      <msub>
       <mi>x</mi>
       <mi>N</mi>
      </msub>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>f</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>f</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>f</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial f}{\partial x_{1}}v_{x_{1}}+\frac{\partial f}{\partial x_{2}}v_%
{x_{2}}+\cdots+\frac{\partial f}{\partial x_{N}}v_{x_{N}}=0
  </annotation>
 </semantics>
</math>

</p>

<p>where the notation <mtpl></mtpl> above means the <mtpl></mtpl>-component of the vector 

<math display="inline" id="Lagrange_multiplier:56">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

. The equation above can be rewritten in a more compact geometric form that helps our intuition:</p>

<p>

<math display="block" id="Lagrange_multiplier:57">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <munder>
      <munder accentunder="true">
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mo movablelimits="false">[</mo>
           <mtable displaystyle="true">
            <mtr>
             <mtd columnalign="center">
              <mstyle displaystyle="false">
               <mfrac>
                <mrow>
                 <mo movablelimits="false">∂</mo>
                 <mi>f</mi>
                </mrow>
                <mrow>
                 <mo movablelimits="false">∂</mo>
                 <msub>
                  <mi>x</mi>
                  <mn>1</mn>
                 </msub>
                </mrow>
               </mfrac>
              </mstyle>
             </mtd>
             <mtd columnalign="center">
              <mstyle displaystyle="false">
               <mfrac>
                <mrow>
                 <mo movablelimits="false">∂</mo>
                 <mi>f</mi>
                </mrow>
                <mrow>
                 <mo movablelimits="false">∂</mo>
                 <msub>
                  <mi>x</mi>
                  <mn>2</mn>
                 </msub>
                </mrow>
               </mfrac>
              </mstyle>
             </mtd>
             <mtd columnalign="center">
              <mi mathvariant="normal">…</mi>
             </mtd>
             <mtd columnalign="center">
              <mstyle displaystyle="false">
               <mfrac>
                <mrow>
                 <mo movablelimits="false">∂</mo>
                 <mi>f</mi>
                </mrow>
                <mrow>
                 <mo movablelimits="false">∂</mo>
                 <msub>
                  <mi>x</mi>
                  <mi>N</mi>
                 </msub>
                </mrow>
               </mfrac>
              </mstyle>
             </mtd>
            </mtr>
           </mtable>
           <mo movablelimits="false">]</mo>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi></mi>
         </mtd>
        </mtr>
       </mtable>
       <mo movablelimits="false">⏟</mo>
      </munder>
      <mrow>
       <mo>∇</mo>
       <msup>
        <mi>f</mi>
        <mi>T</mi>
       </msup>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="center">
     <munder>
      <munder accentunder="true">
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mo movablelimits="false">[</mo>
           <mtable displaystyle="true">
            <mtr>
             <mtd columnalign="center">
              <msub>
               <mi>v</mi>
               <msub>
                <mi>x</mi>
                <mn>1</mn>
               </msub>
              </msub>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="center">
              <msub>
               <mi>v</mi>
               <msub>
                <mi>x</mi>
                <mn>2</mn>
               </msub>
              </msub>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="center">
              <mi mathvariant="normal">⋮</mi>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="center">
              <msub>
               <mi>v</mi>
               <msub>
                <mi>x</mi>
                <mi>N</mi>
               </msub>
              </msub>
             </mtd>
            </mtr>
           </mtable>
           <mo movablelimits="false">]</mo>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi></mi>
         </mtd>
        </mtr>
       </mtable>
       <mo movablelimits="false">⏟</mo>
      </munder>
      <mi>v</mi>
     </munder>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-⏟</ci>
       <matrix>
        <matrixrow>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <matrix>
           <matrixrow>
            <apply>
             <divide></divide>
             <apply>
              <partialdiff></partialdiff>
              <ci>f</ci>
             </apply>
             <apply>
              <partialdiff></partialdiff>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>x</ci>
               <cn type="integer">1</cn>
              </apply>
             </apply>
            </apply>
            <apply>
             <divide></divide>
             <apply>
              <partialdiff></partialdiff>
              <ci>f</ci>
             </apply>
             <apply>
              <partialdiff></partialdiff>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>x</ci>
               <cn type="integer">2</cn>
              </apply>
             </apply>
            </apply>
            <ci>normal-…</ci>
            <apply>
             <divide></divide>
             <apply>
              <partialdiff></partialdiff>
              <ci>f</ci>
             </apply>
             <apply>
              <partialdiff></partialdiff>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>x</ci>
               <ci>N</ci>
              </apply>
             </apply>
            </apply>
           </matrixrow>
          </matrix>
         </apply>
        </matrixrow>
        <matrixrow>
         <csymbol cd="latexml">absent</csymbol>
        </matrixrow>
       </matrix>
      </apply>
      <apply>
       <ci>normal-∇</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-⏟</ci>
       <matrix>
        <matrixrow>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <matrix>
           <matrixrow>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>v</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>x</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
           </matrixrow>
           <matrixrow>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>v</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>x</ci>
              <cn type="integer">2</cn>
             </apply>
            </apply>
           </matrixrow>
           <matrixrow>
            <ci>normal-⋮</ci>
           </matrixrow>
           <matrixrow>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>v</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>x</ci>
              <ci>N</ci>
             </apply>
            </apply>
           </matrixrow>
          </matrix>
         </apply>
        </matrixrow>
        <matrixrow>
         <csymbol cd="latexml">absent</csymbol>
        </matrixrow>
       </matrix>
      </apply>
      <ci>v</ci>
     </apply>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <cn type="float">0</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}\underbrace{\begin{matrix}\left[\begin{matrix}\frac{\partial f}{%
\partial x_{1}}&\frac{\partial f}{\partial x_{2}}&...&\frac{\partial f}{%
\partial x_{N}}\end{matrix}\right]\\
\\
\end{matrix}}_{\nabla f^{T}}&\underbrace{\begin{matrix}\left[\begin{matrix}v_{%
x_{1}}\\
v_{x_{2}}\\
\vdots\\
v_{x_{N}}\\
\end{matrix}\right]\\
\\
\end{matrix}}_{v}&=\,\,0\\
\end{matrix}
  </annotation>
 </semantics>
</math>

</p>

<p>which is the same as writing</p>

<p>

<math display="block" id="Lagrange_multiplier:58">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mrow>
     <msup>
      <mi>f</mi>
      <mi>T</mi>
     </msup>
     <mo>⋅</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-∇</ci>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>T</ci>
      </apply>
      <ci>v</ci>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f^{T}\cdot v=0.
  </annotation>
 </semantics>
</math>

</p>

<p>This makes it clear that if we are at 

<math display="inline" id="Lagrange_multiplier:59">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, then <em>all</em> directions from this point that do <em>not</em> change the value of 

<math display="inline" id="Lagrange_multiplier:60">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 <em>must be perpendicular</em> to 

<math display="inline" id="Lagrange_multiplier:61">
 <semantics>
  <mrow>
   <mi mathvariant="normal">∇</mi>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-∇</ci>
    <ci>f</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∇f(p)
  </annotation>
 </semantics>
</math>

 (the gradient of 

<math display="inline" id="Lagrange_multiplier:62">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Lagrange_multiplier:63">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

).</p>

<p>Now let us consider the effect of the constraints. Each constraint limits the directions that we can move from a particular point and still satisfy the constraint. We can use the same procedure, to look for the set of vectors  containing the directions in which we can move and still satisfy the constraint. As above, for every vector 

<math display="inline" id="Lagrange_multiplier:64">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 in , the following relation must hold:</p>

<p>

<math display="block" id="Lagrange_multiplier:65">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>g</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
       </mrow>
      </mfrac>
      <msub>
       <mi>v</mi>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>g</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mrow>
      </mfrac>
      <msub>
       <mi>v</mi>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
      </msub>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>g</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>x</mi>
         <mi>N</mi>
        </msub>
       </mrow>
      </mfrac>
      <msub>
       <mi>v</mi>
       <msub>
        <mi>x</mi>
        <mi>N</mi>
       </msub>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>⇒</mo>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mrow>
      <msup>
       <mi>g</mi>
       <mi>T</mi>
      </msup>
      <mo>⋅</mo>
      <mi>v</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <ci>g</ci>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <ci>g</ci>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <ci>g</ci>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-⇒</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-∇</ci>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <ci>T</ci>
       </apply>
       <ci>v</ci>
      </apply>
     </apply>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial g}{\partial x_{1}}v_{x_{1}}+\frac{\partial g}{\partial x_{2}}v_%
{x_{2}}+\cdots+\frac{\partial g}{\partial x_{N}}v_{x_{N}}=0\quad\Rightarrow%
\quad\nabla g^{T}\cdot v=0.
  </annotation>
 </semantics>
</math>

</p>

<p>From this, we see that at point 

<math display="inline" id="Lagrange_multiplier:66">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, all directions from this point that will still satisfy this constraint must be perpendicular to 

<math display="inline" id="Lagrange_multiplier:67">
 <semantics>
  <mrow>
   <mi mathvariant="normal">∇</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-∇</ci>
    <ci>g</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∇g(p)
  </annotation>
 </semantics>
</math>

.</p>

<p>Now we are ready to refine our idea further and complete the method: <em>a point on</em> 

<math display="inline" id="Lagrange_multiplier:68">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 <em>is a constrained stationary point if and only if the direction that changes</em> 

<math display="inline" id="Lagrange_multiplier:69">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 <em>violates at least one of the constraints, i.e., has no "component" in the "legal" space perpendicular to</em> 

<math display="inline" id="Lagrange_multiplier:70">
 <semantics>
  <mrow>
   <mi mathvariant="normal">∇</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-∇</ci>
    <ci>g</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∇g(p)
  </annotation>
 </semantics>
</math>

. (We can see that this is true because if a direction that changes 

<math display="inline" id="Lagrange_multiplier:71">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 did <em>not</em> violate any constraints, then there would be a “legal” point nearby with a higher or lower value for 

<math display="inline" id="Lagrange_multiplier:72">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and the current point would then not be a stationary point.) Mathematically, this means that the gradient of 

<math display="inline" id="Lagrange_multiplier:73">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 at this constrained stationary point is perpendicular to the space spanned by the set of vectors , which in turn is perpendicular to the gradients of the constraints 

<math display="inline" id="Lagrange_multiplier:74">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="single-constraint-revisited">Single constraint revisited</h3>

<p>For a single constraint, we use the statement above to say that at stationary points the direction that changes 

<math display="inline" id="Lagrange_multiplier:75">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is in the same direction that violates the constraint. To determine if two vectors are in the same direction, we note that if two vectors start from the same point and are “in the same direction”, then one vector can always “reach” the other by changing its length and/or flipping to point the opposite way along the same direction line. In this way, we can succinctly state that two vectors point in the same direction if and only if one of them can be multiplied by some real number such that they become equal to the other. So, for our purposes, we require that:</p>

<p>

<math display="block" id="Lagrange_multiplier:76">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∇</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>λ</mi>
      </mpadded>
      <mrow>
       <mo>∇</mo>
       <mi>g</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⇒</mo>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>λ</mi>
      </mpadded>
      <mrow>
       <mo>∇</mo>
       <mi>g</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <list>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <ci>normal-∇</ci>
        <ci>g</ci>
       </apply>
       <ci>p</ci>
      </apply>
      <ci>normal-⇒</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <ci>normal-∇</ci>
        <ci>f</ci>
       </apply>
       <ci>p</ci>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <ci>normal-∇</ci>
        <ci>g</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f(p)=\lambda\,\nabla g(p)\qquad\Rightarrow\qquad\nabla f(p)-\lambda\,%
\nabla g(p)=0.
  </annotation>
 </semantics>
</math>

</p>

<p>If we now add another simultaneous equation to guarantee that we only perform this test when we are at a point that satisfies the constraint, we end up with 2 simultaneous equations that when solved, identify all constrained stationary points:</p>

<p>

<math display="block" id="Lagrange_multiplier:77">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>p</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mi>p</mi>
       <mtext>satisfies constraint</mtext>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mrow>
         <mrow>
          <mo>∇</mo>
          <mi>f</mi>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>p</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <mi>λ</mi>
         </mpadded>
         <mrow>
          <mo>∇</mo>
          <mi>g</mi>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>p</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi>p</mi>
        <mtext>is a stationary point</mtext>
       </mrow>
       <mo>.</mo>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>p</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <mtext>satisfies constraint</mtext>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <ci>normal-∇</ci>
        <ci>f</ci>
       </apply>
       <ci>p</ci>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <ci>normal-∇</ci>
        <ci>g</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <mtext>is a stationary point</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}g(p)=0&p\text{ satisfies constraint}\\
\nabla f(p)-\lambda\,\nabla g(p)=0&p\text{ is a stationary point}.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that the above is a succinct way of writing the equations. Fully expanded, there are 

<math display="inline" id="Lagrange_multiplier:78">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N+1
  </annotation>
 </semantics>
</math>

 simultaneous equations that need to be solved for the 

<math display="inline" id="Lagrange_multiplier:79">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N+1
  </annotation>
 </semantics>
</math>

 variables which are 

<math display="inline" id="Lagrange_multiplier:80">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 and <mtpl></mtpl>:</p>

<p>

<math display="inline" id="Lagrange_multiplier:81">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>N</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>N</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle g\left(x_{1},x_{2},\ldots,x_{N}\right)
  </annotation>
 </semantics>
</math>


</p>
<h3 id="multiple-constraints">Multiple constraints</h3>

<p>For more than one constraint, similar reasoning applies. Each constraint function, 

<math display="inline" id="Lagrange_multiplier:82">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

, has a space of allowable directions at 

<math display="inline" id="Lagrange_multiplier:83">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle p
  </annotation>
 </semantics>
</math>

: the space of vectors perpendicular to 

<math display="inline" id="Lagrange_multiplier:84">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>g</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-∇</ci>
     <ci>g</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\nabla g(p)
  </annotation>
 </semantics>
</math>

. The set of directions that are allowed by all constraints is thus the space of directions perpendicular to all of the constraint gradients. Denote this space of allowable moves by 

<math display="inline" id="Lagrange_multiplier:85">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle A
  </annotation>
 </semantics>
</math>

 and denote the span of the constraint gradients by 

<math display="inline" id="Lagrange_multiplier:86">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle S
  </annotation>
 </semantics>
</math>

. By the discussion above, 

<math display="inline" id="Lagrange_multiplier:87">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <msup>
    <mi>S</mi>
    <mo>⟂</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <csymbol cd="latexml">perpendicular-to</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle A=S^{\perp}
  </annotation>
 </semantics>
</math>

, the space of vectors perpendicular to every element of 

<math display="inline" id="Lagrange_multiplier:88">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle S
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Lagrange_multiplier:89">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle p
  </annotation>
 </semantics>
</math>

 is an optimum then any element not perpendicular to 

<math display="inline" id="Lagrange_multiplier:90">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>f</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-∇</ci>
     <ci>f</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\nabla f(p)
  </annotation>
 </semantics>
</math>

 is not an allowable direction. One can show that this implies 

<math display="inline" id="Lagrange_multiplier:91">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>f</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>A</mi>
    <mo>⟂</mo>
   </msup>
   <mo>=</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <csymbol cd="latexml">perpendicular-to</csymbol>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f(p)\in A^{\perp}=S
  </annotation>
 </semantics>
</math>

. Thus there are scalars <mtpl></mtpl> such that</p>

<p>

<math display="block" id="Lagrange_multiplier:92">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∇</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>M</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>k</mi>
       </msub>
       <mrow>
        <mo>∇</mo>
        <msub>
         <mi>g</mi>
         <mi>k</mi>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>p</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>⇒</mo>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>M</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>k</mi>
       </msub>
       <mrow>
        <mo>∇</mo>
        <msub>
         <mi>g</mi>
         <mi>k</mi>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>p</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <list>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>M</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <ci>normal-∇</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <ci>p</ci>
       </apply>
      </apply>
      <ci>normal-⇒</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <ci>normal-∇</ci>
        <ci>f</ci>
       </apply>
       <ci>p</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>M</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <ci>normal-∇</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f(p)=\sum_{k=1}^{M}\lambda_{k}\nabla g_{k}(p)\quad\Rightarrow\quad%
\nabla f(p)-\sum_{k=1}^{M}{\lambda_{k}\nabla g_{k}(p)}=0.
  </annotation>
 </semantics>
</math>

</p>

<p>As before, we now add simultaneous equation to guarantee that we only perform this test when we are at a point that satisfies every constraint, we end up with simultaneous equations that when solved, identify all constrained stationary points:</p>

<p>

<math display="block" id="Lagrange_multiplier:93">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <msub>
         <mi>g</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>p</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <msub>
         <mi>g</mi>
         <mn>2</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>p</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>=</mo>
       <mrow>
        <msub>
         <mi>g</mi>
         <mi>M</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>p</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mi>p</mi>
       <mtext>satisfies all constraints</mtext>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mrow>
         <mrow>
          <mo>∇</mo>
          <mi>f</mi>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>p</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mstyle displaystyle="false">
          <msubsup>
           <mo largeop="true" symmetric="true">∑</mo>
           <mrow>
            <mi>k</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi>M</mi>
          </msubsup>
         </mstyle>
         <mrow>
          <mpadded width="+1.7pt">
           <msub>
            <mi>λ</mi>
            <mi>k</mi>
           </msub>
          </mpadded>
          <mrow>
           <mo>∇</mo>
           <msub>
            <mi>g</mi>
            <mi>k</mi>
           </msub>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>p</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </mtd>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi>p</mi>
        <mtext>is a stationary point</mtext>
       </mrow>
       <mo>.</mo>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>p</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>normal-⋯</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>M</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <mtext>satisfies all constraints</mtext>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <ci>normal-∇</ci>
        <ci>f</ci>
       </apply>
       <ci>p</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>M</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <ci>normal-∇</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <mtext>is a stationary point</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}g_{1}(p)=g_{2}(p)=\cdots=g_{M}(p)=0&p\text{ satisfies all %
constraints}\\
\nabla f(p)-\sum_{k=1}^{M}{\lambda_{k}\,\nabla g_{k}(p)}=0&p\text{ is a %
stationary point}.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>The method is complete now (from the standpoint of solving the problem of finding stationary points) but as mathematicians delight in doing, these equations can be further condensed into an even more elegant and succinct form. Lagrange must have cleverly noticed that the equations above look like partial derivatives of some larger scalar function 

<math display="inline" id="Lagrange_multiplier:94">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 that takes all the <mtpl></mtpl> and all the <mtpl></mtpl> as inputs. Next, he might then have noticed that setting every equation equal to zero is exactly what one would have to do to solve for the <em>unconstrained</em> stationary points of that larger function. Finally, he showed that a larger function 

<math display="inline" id="Lagrange_multiplier:95">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 with partial derivatives that are exactly the ones we require can be constructed very simply as below:</p>

<p>

<math display="block" id="Lagrange_multiplier:96">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo>(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>N</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>λ</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>λ</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>λ</mi>
       <mi>M</mi>
      </msub>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>N</mi>
       </msub>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>M</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>k</mi>
       </msub>
       <msub>
        <mi>g</mi>
        <mi>k</mi>
       </msub>
       <mrow>
        <mo>(</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>N</mi>
        </msub>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>M</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>N</ci>
       </apply>
      </vector>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>k</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>N</ci>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\left(x_{1},x_{2},\ldots,x_{N},\lambda_{1},\lambda_{2},\ldots,\lambda_{M}%
\right)=f\left(x_{1},x_{2},\ldots,x_{N}\right)-\sum\limits_{k=1}^{M}{\lambda_{%
k}g_{k}\left(x_{1},x_{2},\ldots,x_{N}\right)}.
  </annotation>
 </semantics>
</math>

</p>

<p>Solving the equation above for its <em>unconstrained</em> stationary points generates exactly the same stationary points as solving for the <em>constrained</em> stationary points of 

<math display="inline" id="Lagrange_multiplier:97">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 under the constraints <mtpl></mtpl>.</p>

<p>In Lagrange’s honor, the function above is called a <em>Lagrangian</em>, the scalars <mtpl></mtpl> are called <em>Lagrange Multipliers</em> and this optimization method itself is called <em>The Method of Lagrange Multipliers</em>.</p>

<p>The method of Lagrange multipliers is generalized by the <a href="Karush–Kuhn–Tucker_conditions" title="wikilink">Karush–Kuhn–Tucker conditions</a>, which can also take into account inequality constraints of the form 

<math display="inline" id="Lagrange_multiplier:98">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal"></mi>
   <mi mathvariant="normal">≤</mi>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>𝐱</ci>
    <ci>normal-</ci>
    <ci>normal-≤</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(\mathbf{x}) ≤c
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="modern-formulation-via-differentiable-manifolds">Modern Formulation via Differentiable Manifolds</h2>

<p>Finding local maxima of a function 

<math display="inline" id="Lagrange_multiplier:99">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>U</mi>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>U</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:U\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Lagrange_multiplier:100">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 is an open subset of 

<math display="inline" id="Lagrange_multiplier:101">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 is done by finding all points 

<math display="inline" id="Lagrange_multiplier:102">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in U
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Lagrange_multiplier:103">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>x</mi>
    </msub>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>x</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{x}f=0
  </annotation>
 </semantics>
</math>

 then checking whether all the eigenvalues of the Hessian 

<math display="inline" id="Lagrange_multiplier:104">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>x</mi>
   </msub>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>x</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{x}f
  </annotation>
 </semantics>
</math>

 are negative. Setting 

<math display="inline" id="Lagrange_multiplier:105">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>x</mi>
    </msub>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>x</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{x}f=0
  </annotation>
 </semantics>
</math>

 is a non-linear problem and in general arbitrarily difficult. After finding the critical points, checking the eigenvalues is a linear problem and thus easy.</p>

<p>When 

<math display="inline" id="Lagrange_multiplier:106">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:\mathbb{R}^{n}\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 is a smooth function such that 

<math display="inline" id="Lagrange_multiplier:107">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>x</mi>
    </msub>
    <mi>g</mi>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>x</ci>
     </apply>
     <ci>g</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{x}g\neq 0
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Lagrange_multiplier:108">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in the level set of 

<math display="inline" id="Lagrange_multiplier:109">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Lagrange_multiplier:110">
 <semantics>
  <mrow>
   <msup>
    <mi>g</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{-1}(c)
  </annotation>
 </semantics>
</math>

 becomes an 

<math display="inline" id="Lagrange_multiplier:111">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

-dimensional smooth manifold 

<math display="inline" id="Lagrange_multiplier:112">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, by the level set theorem. Finding local maxima is by definition a local problem, so it can be done on local charts of 

<math display="inline" id="Lagrange_multiplier:113">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

: after finding a diffeomorphism 

<math display="inline" id="Lagrange_multiplier:114">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>:</mo>
   <mrow>
    <mi>V</mi>
    <mo>→</mo>
    <msup>
     <mi>ℝ</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>φ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi:V\to\mathbb{R}^{n-1}
  </annotation>
 </semantics>
</math>

 from an open subset of 

<math display="inline" id="Lagrange_multiplier:115">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>⊆</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>V</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\subseteq M
  </annotation>
 </semantics>
</math>

 onto an open subset 

<math display="inline" id="Lagrange_multiplier:116">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>⊆</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>U</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U\subseteq\mathbb{R}^{n-1}
  </annotation>
 </semantics>
</math>

, we can apply the algorithm in the previous paragraph to the function 

<math display="inline" id="Lagrange_multiplier:117">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mo>∘</mo>
     <msup>
      <mi>φ</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>U</mi>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <compose></compose>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>U</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}=f\circ\varphi^{-1}:U\to\mathbb{R}
  </annotation>
 </semantics>
</math>

.</p>

<p>While the above idea sounds good, it is difficult to compute 

<math display="inline" id="Lagrange_multiplier:118">
 <semantics>
  <msup>
   <mi>φ</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>φ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi^{-1}
  </annotation>
 </semantics>
</math>

 in practice. <em>The entire method of Lagrange multipliers reduces to the idea of skipping that step and finding the zeros of 

<math display="inline" id="Lagrange_multiplier:119">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>x</mi>
   </msub>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{x}f^{\prime}
  </annotation>
 </semantics>
</math>

 directly.</em> It follows from the construction in the level set theorem that 

<math display="inline" id="Lagrange_multiplier:120">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>x</mi>
   </msub>
   <msup>
    <mi>φ</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>φ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{x}\varphi^{-1}
  </annotation>
 </semantics>
</math>

 is the inclusion map 

<math display="inline" id="Lagrange_multiplier:121">
 <semantics>
  <mrow>
   <mrow>
    <mi>ker</mi>
    <msub>
     <mi>D</mi>
     <mrow>
      <msup>
       <mi>φ</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <mi>g</mi>
   </mrow>
   <mo>⊆</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>ker</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>φ</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>g</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{ker}D_{\varphi^{-1}(x)}g\subseteq\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

. Therefore</p>

<p>

<math display="block" id="Lagrange_multiplier:122">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>x</mi>
    </msub>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>∘</mo>
      <msup>
       <mi>φ</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>D</mi>
       <mrow>
        <msup>
         <mi>φ</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msub>
      <mi>f</mi>
     </mrow>
     <mo>∘</mo>
     <msub>
      <mi>D</mi>
      <mi>x</mi>
     </msub>
    </mrow>
    <msup>
     <mi>φ</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <compose></compose>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>φ</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <compose></compose>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>D</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>φ</ci>
           <apply>
            <minus></minus>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>x</ci>
         </apply>
        </apply>
        <ci>f</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>φ</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=D_{x}f^{\prime}=D_{x}(f\circ\varphi^{-1})=D_{\varphi^{-1}(x)}f\circ D_{x}%
\varphi^{-1}
  </annotation>
 </semantics>
</math>

 if and only if</p>

<p>

<math display="block" id="Lagrange_multiplier:123">
 <semantics>
  <mrow>
   <mrow>
    <mi>ker</mi>
    <msub>
     <mi>D</mi>
     <mi>y</mi>
    </msub>
    <mi>g</mi>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <mi>ker</mi>
    <msub>
     <mi>D</mi>
     <mi>y</mi>
    </msub>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>ker</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>y</ci>
     </apply>
     <ci>g</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ker</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>y</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{ker}D_{y}g\subseteq\mathrm{ker}D_{y}f
  </annotation>
 </semantics>
</math>

 writing 

<math display="inline" id="Lagrange_multiplier:124">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Lagrange_multiplier:125">
 <semantics>
  <mrow>
   <msup>
    <mi>φ</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>φ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi^{-1}(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>By the first isomorphism theorem this is true if and only if there exists a linear map 

<math display="inline" id="Lagrange_multiplier:126">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℝ</mi>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>L</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℝ</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L:\mathbb{R}\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Lagrange_multiplier:127">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mo>∘</mo>
     <msub>
      <mi>D</mi>
      <mi>y</mi>
     </msub>
    </mrow>
    <mi>g</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>y</mi>
    </msub>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <ci>g</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>y</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\circ D_{y}g=D_{y}f
  </annotation>
 </semantics>
</math>

. As a linear map, we must have that 

<math display="inline" id="Lagrange_multiplier:128">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x)=\lambda x
  </annotation>
 </semantics>
</math>

 for a fixed 

<math display="inline" id="Lagrange_multiplier:129">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>∈</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>λ</ci>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\in\mathbb{R}
  </annotation>
 </semantics>
</math>

. So finding a critical point of 

<math display="inline" id="Lagrange_multiplier:130">
 <semantics>
  <msup>
   <mi>f</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}
  </annotation>
 </semantics>
</math>

 is equivalent to solving the system of equations</p>

<p>

<math display="block" id="Lagrange_multiplier:131">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <msub>
     <mi>D</mi>
     <mi>y</mi>
    </msub>
    <mi>g</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>y</mi>
    </msub>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>y</ci>
     </apply>
     <ci>g</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>y</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda D_{y}g=D_{y}f
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lagrange_multiplier:132">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>y</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(y)=c
  </annotation>
 </semantics>
</math>

</p>

<p>in the variables 

<math display="inline" id="Lagrange_multiplier:133">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in\mathbb{R}^{n-1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lagrange_multiplier:134">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>∈</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>λ</ci>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\in\mathbb{R}
  </annotation>
 </semantics>
</math>

. This is in general a non-linear system of 

<math display="inline" id="Lagrange_multiplier:135">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 equations and 

<math display="inline" id="Lagrange_multiplier:136">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 unknowns.</p>

<p>In the case of several constraints, we work with 

<math display="inline" id="Lagrange_multiplier:137">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>m</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:\mathbb{R}^{n}\to\mathbb{R}^{m}
  </annotation>
 </semantics>
</math>

 and replace the condition 

<math display="inline" id="Lagrange_multiplier:138">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>x</mi>
    </msub>
    <mi>g</mi>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>x</ci>
     </apply>
     <ci>g</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{x}g\neq 0
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Lagrange_multiplier:139">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in g^{-1}(c)
  </annotation>
 </semantics>
</math>

 with the requirement that 

<math display="inline" id="Lagrange_multiplier:140">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>x</mi>
   </msub>
   <mi>g</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>x</ci>
    </apply>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{x}g
  </annotation>
 </semantics>
</math>

 be surjective at all such points. In this case 

<math display="inline" id="Lagrange_multiplier:141">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 will be a linear map 

<math display="inline" id="Lagrange_multiplier:142">
 <semantics>
  <mrow>
   <msup>
    <mi>ℝ</mi>
    <mi>m</mi>
   </msup>
   <mo>→</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>m</ci>
    </apply>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{m}\to\mathbb{R}
  </annotation>
 </semantics>
</math>

, ie a row vector with 

<math display="inline" id="Lagrange_multiplier:143">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 entries.</p>
<h2 id="interpretation-of-the-lagrange-multipliers">Interpretation of the Lagrange multipliers</h2>

<p>Often the Lagrange multipliers have an interpretation as some quantity of interest. For example, if the Lagrangian expression is</p>

<p>

<math display="block" id="Lagrange_multiplier:144">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>;</mo>
     <msub>
      <mi>λ</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>λ</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>λ</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>c</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>g</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>x</mi>
          <mn>2</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>λ</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>c</mi>
        <mn>2</mn>
       </msub>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>g</mi>
         <mn>2</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>x</mi>
          <mn>2</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-…</ci>
      </vector>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">1</cn>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>normal-…</ci>
        </vector>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">2</cn>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>normal-…</ci>
        </vector>
       </apply>
      </apply>
     </apply>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x_{1},x_{2},\dots;\lambda_{1},\lambda_{2},\dots)=f(x_{1},x_{2},\dots)+%
\lambda_{1}(c_{1}-g_{1}(x_{1},x_{2},\dots))+\lambda_{2}(c_{2}-g_{2}(x_{1},x_{2%
},\dots))+\dots
  </annotation>
 </semantics>
</math>

</p>

<p>then</p>

<p>

<math display="block" id="Lagrange_multiplier:145">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <mi>L</mi>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>c</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <msub>
     <mi>λ</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>L</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial L}{\partial{c_{k}}}=\lambda_{k}.
  </annotation>
 </semantics>
</math>

</p>

<p>So, <mtpl></mtpl> is the rate of change of the quantity being optimized as a function of the constraint variable. As examples, in <a href="Lagrangian_mechanics" title="wikilink">Lagrangian mechanics</a> the equations of motion are derived by finding stationary points of the <a href="Action_(physics)" title="wikilink">action</a>, the time integral of the difference between kinetic and potential energy. Thus, the force on a particle due to a scalar potential, 

<math display="inline" id="Lagrange_multiplier:146">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">−</mi>
    <mi mathvariant="normal">∇</mi>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <times></times>
     <ci>normal-−</ci>
     <ci>normal-∇</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=−∇V
  </annotation>
 </semantics>
</math>

, can be interpreted as a Lagrange multiplier determining the change in action (transfer of potential to kinetic energy) following a variation in the particle's constrained trajectory. In control theory this is formulated instead as <a href="costate_equations" title="wikilink">costate equations</a>.</p>

<p>Moreover, by the <a href="envelope_theorem" title="wikilink">envelope theorem</a> the optimal value of a Lagrange multiplier has an interpretation as the marginal effect of the corresponding constraint constant upon the optimal attainable value of the original objective function: if we denote values at the optimum with an asterisk, then it can be shown that</p>

<p>

<math display="block" id="Lagrange_multiplier:147">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mtext>d</mtext>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msubsup>
         <mi>x</mi>
         <mn>1</mn>
         <mo>*</mo>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>c</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>c</mi>
          <mn>2</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msubsup>
         <mi>x</mi>
         <mn>2</mn>
         <mo>*</mo>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>c</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>c</mi>
          <mn>2</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mtext>d</mtext>
      <msub>
       <mi>c</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <msubsup>
     <mi>λ</mi>
     <mi>k</mi>
     <mo>*</mo>
    </msubsup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <mtext>d</mtext>
      <ci>f</ci>
      <vector>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <times></times>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>normal-…</ci>
        </vector>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
         <times></times>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>normal-…</ci>
        </vector>
       </apply>
       <ci>normal-…</ci>
      </vector>
     </apply>
     <apply>
      <times></times>
      <mtext>d</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>k</ci>
     </apply>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\text{d}f(x_{1}^{*}(c_{1},c_{2},\dots),x_{2}^{*}(c_{1},c_{2},\dots),%
\dots)}{\text{d}c_{k}}=\lambda_{k}^{*}.
  </annotation>
 </semantics>
</math>

</p>

<p>For example, in economics the optimal profit to a player is calculated subject to a constrained space of actions, where a Lagrange multiplier is the change in the optimal value of the objective function (profit) due to the relaxation of a given constraint (e.g. through a change in income); in such a context 

<math display="inline" id="Lagrange_multiplier:148">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ*
  </annotation>
 </semantics>
</math>

 is the <a href="marginal_cost" title="wikilink">marginal cost</a> of the constraint, and is referred to as the <a href="shadow_price" title="wikilink">shadow price</a>.</p>
<h2 id="sufficient-conditions">Sufficient conditions</h2>

<p>Sufficient conditions for a constrained local maximum or minimum can be stated in terms of a sequence of principal minors (determinants of upper-left-justified sub-matrices) of the bordered <a href="Hessian_matrix" title="wikilink">Hessian matrix</a> of second derivatives of the Lagrangian expression.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="examples">Examples</h2>
<h3 id="example-1">Example 1</h3>
<figure><b>(Figure)</b>
<figcaption>Fig. 3. Illustration of the constrained optimization problem</figcaption>
</figure>

<p>Suppose we wish to maximize 

<math display="inline" id="Lagrange_multiplier:149">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=x+y
  </annotation>
 </semantics>
</math>

 subject to the constraint 

<math display="inline" id="Lagrange_multiplier:150">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}+y^{2}=1
  </annotation>
 </semantics>
</math>

. The <a href="Candidate_solution" title="wikilink">feasible set</a> is the unit circle, and the <a href="level_set" title="wikilink">level sets</a> of 

<math display="inline" id="Lagrange_multiplier:151">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 are diagonal lines (with slope -1), so we can see graphically that the maximum occurs at 

<math display="inline" id="Lagrange_multiplier:152">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mfrac>
    <msqrt>
     <mn>2</mn>
    </msqrt>
    <mn>2</mn>
   </mfrac>
   <mo>,</mo>
   <mfrac>
    <msqrt>
     <mn>2</mn>
    </msqrt>
    <mn>2</mn>
   </mfrac>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <divide></divide>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\tfrac{\sqrt{2}}{2},\tfrac{\sqrt{2}}{2}\right)
  </annotation>
 </semantics>
</math>

, and that the minimum occurs at 

<math display="inline" id="Lagrange_multiplier:153">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <msqrt>
      <mn>2</mn>
     </msqrt>
     <mn>2</mn>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <msqrt>
      <mn>2</mn>
     </msqrt>
     <mn>2</mn>
    </mfrac>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(-\tfrac{\sqrt{2}}{2},-\tfrac{\sqrt{2}}{2}\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>Using the method of Lagrange multipliers, we have 

<math display="inline" id="Lagrange_multiplier:154">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mi>c</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mi>y</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>g</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y)-c=x^{2}+y^{2}-1
  </annotation>
 </semantics>
</math>

, hence</p>

<p>

<math display="block" id="Lagrange_multiplier:155">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Λ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>λ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mi>c</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mo>+</mo>
     <mi>y</mi>
     <mo>+</mo>
     <mrow>
      <mi>λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <msup>
          <mi>x</mi>
          <mn>2</mn>
         </msup>
         <mo>+</mo>
         <msup>
          <mi>y</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Λ</ci>
      <vector>
       <ci>x</ci>
       <ci>y</ci>
       <ci>λ</ci>
      </vector>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>g</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>y</ci>
         </interval>
        </apply>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>y</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(x,y,\lambda)=f(x,y)+\lambda(g(x,y)-c)=x+y+\lambda(x^{2}+y^{2}-1).
  </annotation>
 </semantics>
</math>

</p>

<p>Setting the gradient 

<math display="inline" id="Lagrange_multiplier:156">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mrow>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>λ</mi>
      </mrow>
     </msub>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <list>
        <ci>x</ci>
        <ci>y</ci>
        <ci>λ</ci>
       </list>
      </apply>
      <ci>normal-Λ</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>λ</ci>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla_{x,y,\lambda}\Lambda(x,y,\lambda)=0
  </annotation>
 </semantics>
</math>

 yields the system of equations</p>

<p>

<math display="inline" id="Lagrange_multiplier:157">
 <semantics>
  <mstyle displaystyle="true">
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>x</mi>
    </mrow>
   </mfrac>
  </mstyle>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <partialdiff></partialdiff>
     <ci>normal-Λ</ci>
    </apply>
    <apply>
     <partialdiff></partialdiff>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\frac{\partial\Lambda}{\partial x}
  </annotation>
 </semantics>
</math>


</p>

<p>where the last equation is the original constraint.</p>

<p>The first two equations yield</p>

<p>

<math display="block" id="Lagrange_multiplier:158">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mi>y</mi>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>λ</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mi>λ</mi>
    <mo>≠</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>λ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <neq></neq>
     <ci>λ</ci>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y=-\frac{1}{2\lambda},\qquad\lambda\neq 0.
  </annotation>
 </semantics>
</math>

</p>

<p>Substituting into the last equation yields 

<math display="inline" id="Lagrange_multiplier:159">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>4</mn>
       <msup>
        <mi>λ</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>4</mn>
       <msup>
        <mi>λ</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>λ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/(4\lambda^{2})+1/(4\lambda^{2})=1
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="Lagrange_multiplier:160">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mrow>
    <mo>∓</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <csymbol cd="latexml">minus-or-plus</csymbol>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=\mp 1/\sqrt{2}
  </annotation>
 </semantics>
</math>

, which implies that the stationary points are 

<math display="inline" id="Lagrange_multiplier:161">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msqrt>
     <mn>2</mn>
    </msqrt>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msqrt>
     <mn>2</mn>
    </msqrt>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <divide></divide>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sqrt{2}/2,\sqrt{2}/2)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lagrange_multiplier:162">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msqrt>
      <mn>2</mn>
     </msqrt>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msqrt>
      <mn>2</mn>
     </msqrt>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (-\sqrt{2}/2,-\sqrt{2}/2)
  </annotation>
 </semantics>
</math>


. Evaluating the objective function 

<math display="inline" id="Lagrange_multiplier:163">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 at these points yields</p>

<p>

<math display="block" id="Lagrange_multiplier:164">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msqrt>
        <mn>2</mn>
       </msqrt>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msqrt>
        <mn>2</mn>
       </msqrt>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msqrt>
      <mn>2</mn>
     </msqrt>
     <mtext>and</mtext>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <msqrt>
         <mn>2</mn>
        </msqrt>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <msqrt>
         <mn>2</mn>
        </msqrt>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <divide></divide>
        <apply>
         <root></root>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <root></root>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
      <mtext>and</mtext>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <apply>
          <root></root>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <apply>
          <root></root>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\sqrt{2}/2,\sqrt{2}/2)=\sqrt{2}\mbox{ and }f(-\sqrt{2}/2,-\sqrt{2}/2)=-\sqrt%
{2},
  </annotation>
 </semantics>
</math>

</p>

<p>thus the maximum is 

<math display="inline" id="Lagrange_multiplier:165">
 <semantics>
  <msqrt>
   <mn>2</mn>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{2}
  </annotation>
 </semantics>
</math>

, which is attained at 

<math display="inline" id="Lagrange_multiplier:166">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msqrt>
     <mn>2</mn>
    </msqrt>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msqrt>
     <mn>2</mn>
    </msqrt>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <divide></divide>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sqrt{2}/2,\sqrt{2}/2)
  </annotation>
 </semantics>
</math>

, and the minimum is 

<math display="inline" id="Lagrange_multiplier:167">
 <semantics>
  <mrow>
   <mo>-</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\sqrt{2}
  </annotation>
 </semantics>
</math>


, which is attained at 

<math display="inline" id="Lagrange_multiplier:168">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msqrt>
      <mn>2</mn>
     </msqrt>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msqrt>
      <mn>2</mn>
     </msqrt>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (-\sqrt{2}/2,-\sqrt{2}/2)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="example-2">Example 2</h3>
<figure><b>(Figure)</b>
<figcaption>Fig. 4. Illustration of the constrained optimization problem</figcaption>
</figure>

<p>Suppose we want to find the maximum values of</p>

<p>

<math display="block" id="Lagrange_multiplier:169">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=x^{2}y
  </annotation>
 </semantics>
</math>

</p>

<p>with the condition that the 

<math display="inline" id="Lagrange_multiplier:170">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lagrange_multiplier:171">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 coordinates lie on the circle around the origin with radius √3, that is, subject to the constraint</p>

<p>

<math display="block" id="Lagrange_multiplier:172">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>3.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">3.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y)=x^{2}+y^{2}=3.
  </annotation>
 </semantics>
</math>

</p>

<p>As there is just a single constraint, we will use only one multiplier, say 

<math display="inline" id="Lagrange_multiplier:173">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

.</p>

<p>The constraint 

<math display="inline" id="Lagrange_multiplier:174">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y)-3
  </annotation>
 </semantics>
</math>

 is identically zero on the circle of radius √3. So any multiple of 

<math display="inline" id="Lagrange_multiplier:175">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y)-3
  </annotation>
 </semantics>
</math>

 may be added to 

<math display="inline" id="Lagrange_multiplier:176">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>

 leaving 

<math display="inline" id="Lagrange_multiplier:177">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>


 unchanged in the region of interest (above the circle where our original constraint is satisfied). Let</p>

<p>

<math display="block" id="Lagrange_multiplier:178">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Λ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>λ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mn>3</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
      <mi>y</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <msup>
          <mi>x</mi>
          <mn>2</mn>
         </msup>
         <mo>+</mo>
         <msup>
          <mi>y</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo>-</mo>
        <mn>3</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Λ</ci>
      <vector>
       <ci>x</ci>
       <ci>y</ci>
       <ci>λ</ci>
      </vector>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>g</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>y</ci>
         </interval>
        </apply>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>y</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(x,y,\lambda)=f(x,y)+\lambda(g(x,y)-3)=x^{2}y+\lambda(x^{2}+y^{2}-3).
  </annotation>
 </semantics>
</math>

</p>

<p>The critical values of 

<math display="inline" id="Lagrange_multiplier:179">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Λ
  </annotation>
 </semantics>
</math>

 occur where its gradient is zero. The partial derivatives are</p>

<p>

<math display="inline" id="Lagrange_multiplier:180">
 <semantics>
  <mstyle displaystyle="true">
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>x</mi>
    </mrow>
   </mfrac>
  </mstyle>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <partialdiff></partialdiff>
     <ci>normal-Λ</ci>
    </apply>
    <apply>
     <partialdiff></partialdiff>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\frac{\partial\Lambda}{\partial x}
  </annotation>
 </semantics>
</math>


</p>

<p>Equation (iii) is just the original constraint. Equation (i) implies 

<math display="inline" id="Lagrange_multiplier:181">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=0
  </annotation>
 </semantics>
</math>

 <em>or</em> 

<math display="inline" id="Lagrange_multiplier:182">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">−</mi>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <times></times>
     <ci>normal-−</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ=−y
  </annotation>
 </semantics>
</math>

. In the first case, if 

<math display="inline" id="Lagrange_multiplier:183">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=0
  </annotation>
 </semantics>
</math>

 then we must have 

<math display="inline" id="Lagrange_multiplier:184">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <msqrt>
     <mn>3</mn>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <apply>
      <root></root>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\pm\sqrt{3}
  </annotation>
 </semantics>
</math>

 by (iii) and then by (ii) λ = 0. In the second case, if 

<math display="inline" id="Lagrange_multiplier:185">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">−</mi>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <times></times>
     <ci>normal-−</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ=−y
  </annotation>
 </semantics>
</math>

 and substituting into equation (ii) we have that,</p>

<p>

<math display="block" id="Lagrange_multiplier:186">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <msup>
      <mi>y</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}-2y^{2}=0.
  </annotation>
 </semantics>
</math>

</p>

<p>Then <mtpl> 2<em>y</em><sup>2</sup>}}</mtpl>. Substituting into equation (iii) and solving for 

<math display="inline" id="Lagrange_multiplier:187">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 gives 

<math display="inline" id="Lagrange_multiplier:188">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">±</mi>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>normal-±</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=±1
  </annotation>
 </semantics>
</math>

. Thus there are six critical points:</p>

<p>

<math display="block" id="Lagrange_multiplier:189">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msqrt>
      <mn>2</mn>
     </msqrt>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="12.5pt">;</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="12.5pt">;</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msqrt>
      <mn>2</mn>
     </msqrt>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="12.5pt">;</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="12.5pt">;</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <msqrt>
      <mn>3</mn>
     </msqrt>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="12.5pt">;</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <msqrt>
       <mn>3</mn>
      </msqrt>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">1</cn>
    </interval>
    <interval closure="open">
     <apply>
      <minus></minus>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </interval>
    <interval closure="open">
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <interval closure="open">
     <apply>
      <minus></minus>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <interval closure="open">
     <cn type="integer">0</cn>
     <apply>
      <root></root>
      <cn type="integer">3</cn>
     </apply>
    </interval>
    <interval closure="open">
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <apply>
       <root></root>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sqrt{2},1);\quad(-\sqrt{2},1);\quad(\sqrt{2},-1);\quad(-\sqrt{2},-1);\quad(0%
,\sqrt{3});\quad(0,-\sqrt{3}).
  </annotation>
 </semantics>
</math>

</p>

<p>Evaluating the objective at these points, we find that</p>

<p>

<math display="block" id="Lagrange_multiplier:190">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>±</mo>
       <msqrt>
        <mn>2</mn>
       </msqrt>
      </mrow>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>2</mn>
   </mrow>
   <mo rspace="12.5pt">;</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>±</mo>
        <msqrt>
         <mn>2</mn>
        </msqrt>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">;</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mrow>
        <mo>±</mo>
        <msqrt>
         <mn>3</mn>
        </msqrt>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>0.</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="latexml">plus-or-minus</csymbol>
        <apply>
         <root></root>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </interval>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="latexml">plus-or-minus</csymbol>
         <apply>
          <root></root>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <cn type="integer">0</cn>
        <apply>
         <csymbol cd="latexml">plus-or-minus</csymbol>
         <apply>
          <root></root>
          <cn type="integer">3</cn>
         </apply>
        </apply>
       </interval>
      </apply>
      <cn type="float">0.</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\pm\sqrt{2},1)=2;\quad f(\pm\sqrt{2},-1)=-2;\quad f(0,\pm\sqrt{3})=0.
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, the objective function attains the <a href="global_maximum" title="wikilink">global maximum</a> (subject to the constraints) at 

<math display="inline" id="Lagrange_multiplier:191">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>±</mo>
    <msqrt>
     <mn>2</mn>
    </msqrt>
   </mrow>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\pm\sqrt{2},1)
  </annotation>
 </semantics>
</math>

 and the <a href="global_minimum" title="wikilink">global minimum</a> at 

<math display="inline" id="Lagrange_multiplier:192">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>±</mo>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\pm\sqrt{2},-1).
  </annotation>
 </semantics>
</math>

 The point 

<math display="inline" id="Lagrange_multiplier:193">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <msqrt>
    <mn>3</mn>
   </msqrt>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <apply>
     <root></root>
     <cn type="integer">3</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,\sqrt{3})
  </annotation>
 </semantics>
</math>

 is a <a href="local_minimum" title="wikilink">local minimum</a> and 

<math display="inline" id="Lagrange_multiplier:194">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <msqrt>
     <mn>3</mn>
    </msqrt>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <apply>
     <minus></minus>
     <apply>
      <root></root>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,-\sqrt{3})
  </annotation>
 </semantics>
</math>

 is a <a href="local_maximum" title="wikilink">local maximum</a>, as may be determined by consideration of the <a href="Hessian_(mathematics)#Bordered_Hessian" title="wikilink">Hessian matrix</a> of 

<math display="inline" id="Lagrange_multiplier:195">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Λ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Λ</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(x,y,0)
  </annotation>
 </semantics>
</math>

.</p>

<p>Note that while 

<math display="inline" id="Lagrange_multiplier:196">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sqrt{2},1,-1)
  </annotation>
 </semantics>
</math>

 is a critical point of 

<math display="inline" id="Lagrange_multiplier:197">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Λ
  </annotation>
 </semantics>
</math>

, it is not a local extremum. We have 

<math display="inline" id="Lagrange_multiplier:198">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msqrt>
       <mn>2</mn>
      </msqrt>
      <mo>+</mo>
      <mi>ϵ</mi>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo>+</mo>
      <mi>δ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>+</mo>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>ϵ</mi>
        <mn>2</mn>
       </msup>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>2</mn>
          <msqrt>
           <mn>2</mn>
          </msqrt>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>ϵ</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <vector>
      <apply>
       <plus></plus>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
       <ci>ϵ</ci>
      </apply>
      <cn type="integer">1</cn>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>δ</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>δ</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ϵ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <root></root>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>ϵ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(\sqrt{2}+\epsilon,1,-1+\delta)=2+\delta(\epsilon^{2}+(2\sqrt{2})\epsilon)
  </annotation>
 </semantics>
</math>

. Given any neighborhood of 

<math display="inline" id="Lagrange_multiplier:199">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msqrt>
    <mn>2</mn>
   </msqrt>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <root></root>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sqrt{2},1,-1)
  </annotation>
 </semantics>
</math>

, we can choose a small positive 

<math display="inline" id="Lagrange_multiplier:200">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 and a small 

<math display="inline" id="Lagrange_multiplier:201">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 of either sign to get 

<math display="inline" id="Lagrange_multiplier:202">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Λ
  </annotation>
 </semantics>
</math>

 values both greater and less than 

<math display="inline" id="Lagrange_multiplier:203">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="example-3-entropy">Example 3: Entropy</h3>

<p>Suppose we wish to find the <a href="Probability_distribution#Discrete_probability_distribution" title="wikilink">discrete probability distribution</a> on the points 

<math display="inline" id="Lagrange_multiplier:204">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{p_{1},p_{2},\ldots,p_{n}\}
  </annotation>
 </semantics>
</math>

 with maximal <a href="information_entropy" title="wikilink">information entropy</a>. This is the same as saying that we wish to find the <a href="Bias_of_an_estimator" title="wikilink">least biased</a> probability distribution on the points 

<math display="inline" id="Lagrange_multiplier:205">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{p_{1},p_{2},\ldots,p_{n}\}
  </annotation>
 </semantics>
</math>

. In other words, we wish to maximize the <a href="Shannon_entropy" title="wikilink">Shannon entropy</a> equation:</p>

<p>

<math display="block" id="Lagrange_multiplier:206">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>p</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>p</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>p</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <msub>
         <mi>log</mi>
         <mn>2</mn>
        </msub>
        <msub>
         <mi>p</mi>
         <mi>j</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(p_{1},p_{2},\ldots,p_{n})=-\sum_{j=1}^{n}p_{j}\log_{2}p_{j}.
  </annotation>
 </semantics>
</math>

</p>

<p>For this to be a probability distribution the sum of the probabilities 

<math display="inline" id="Lagrange_multiplier:207">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 at each point 

<math display="inline" id="Lagrange_multiplier:208">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 must equal 1, so our constraint is:</p>

<p>

<math display="block" id="Lagrange_multiplier:209">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>p</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>p</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(p_{1},p_{2},\ldots,p_{n})=\sum_{j=1}^{n}p_{j}=1.
  </annotation>
 </semantics>
</math>

</p>

<p>We use Lagrange multipliers to find the point of maximum entropy, 

<math display="inline" id="Lagrange_multiplier:210">
 <semantics>
  <msup>
   <mover accent="true">
    <mi>p</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo lspace="4.2pt">*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>p</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{p}^{\,*}
  </annotation>
 </semantics>
</math>

, across all discrete probability distributions 

<math display="inline" id="Lagrange_multiplier:211">
 <semantics>
  <mover accent="true">
   <mi>p</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{p}
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Lagrange_multiplier:212">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{1},x_{2},\ldots,x_{n}\}
  </annotation>
 </semantics>
</math>

. We require that:</p>

<p>

<math display="block" id="Lagrange_multiplier:213">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mrow>
       <mfrac>
        <mo>∂</mo>
        <mrow>
         <mo>∂</mo>
         <mover accent="true">
          <mi>p</mi>
          <mo stretchy="false">→</mo>
         </mover>
        </mrow>
       </mfrac>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>f</mi>
         <mo>+</mo>
         <mrow>
          <mi>λ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>g</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo fence="true">|</mo>
     </mrow>
     <mrow>
      <mover accent="true">
       <mi>p</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>=</mo>
      <msup>
       <mover accent="true">
        <mi>p</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo lspace="4.2pt">*</mo>
      </msup>
     </mrow>
    </msub>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <ci>normal-→</ci>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>f</ci>
       <apply>
        <times></times>
        <ci>λ</ci>
        <apply>
         <minus></minus>
         <ci>g</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <ci>normal-→</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>p</ci>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left.\frac{\partial}{\partial\vec{p}}(f+\lambda(g-1))\right|_{\vec{p}=\vec{p}%
^{\,*}}=0,
  </annotation>
 </semantics>
</math>

</p>

<p>which gives a system of 

<math display="inline" id="Lagrange_multiplier:214">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 equations, 

<math display="inline" id="Lagrange_multiplier:215">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k={1,\ldots,n}
  </annotation>
 </semantics>
</math>

, such that:</p>

<p>

<math display="block" id="Lagrange_multiplier:216">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mrow>
      <mfrac>
       <mo>∂</mo>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>p</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mfrac>
      <mrow>
       <mo>{</mo>
       <mrow>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mo>(</mo>
          <mrow>
           <munderover>
            <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
            <mrow>
             <mi>j</mi>
             <mo>=</mo>
             <mn>1</mn>
            </mrow>
            <mi>n</mi>
           </munderover>
           <mrow>
            <msub>
             <mi>p</mi>
             <mi>j</mi>
            </msub>
            <mrow>
             <msub>
              <mi>log</mi>
              <mn>2</mn>
             </msub>
             <msub>
              <mi>p</mi>
              <mi>j</mi>
             </msub>
            </mrow>
           </mrow>
          </mrow>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>λ</mi>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mrow>
            <munderover>
             <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
             <mrow>
              <mi>j</mi>
              <mo>=</mo>
              <mn>1</mn>
             </mrow>
             <mi>n</mi>
            </munderover>
            <msub>
             <mi>p</mi>
             <mi>j</mi>
            </msub>
           </mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo>)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>}</mo>
      </mrow>
     </mrow>
     <mo fence="true">|</mo>
    </mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>k</mi>
     </msub>
     <mo>=</mo>
     <msubsup>
      <mi>p</mi>
      <mi>k</mi>
      <mo>*</mo>
     </msubsup>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <set>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <sum></sum>
            <apply>
             <eq></eq>
             <ci>j</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <ci>n</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>p</ci>
            <ci>j</ci>
           </apply>
           <apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <log></log>
             <cn type="integer">2</cn>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>p</ci>
             <ci>j</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>λ</ci>
         <apply>
          <minus></minus>
          <apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <sum></sum>
             <apply>
              <eq></eq>
              <ci>j</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <ci>n</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>p</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </set>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <times></times>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left.\frac{\partial}{\partial p_{k}}\left\{-\left(\sum_{j=1}^{n}p_{j}\log_{2}%
p_{j}\right)+\lambda\left(\sum_{j=1}^{n}p_{j}-1\right)\right\}\right|_{p_{k}=p%
^{*}_{k}}=0.
  </annotation>
 </semantics>
</math>

</p>

<p>Carrying out the differentiation of these 

<math display="inline" id="Lagrange_multiplier:217">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 equations, we get</p>

<p>

<math display="block" id="Lagrange_multiplier:218">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mi>ln</mi>
         <mn>2</mn>
        </mrow>
       </mfrac>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>log</mi>
         <mn>2</mn>
        </msub>
        <msubsup>
         <mi>p</mi>
         <mi>k</mi>
         <mo>*</mo>
        </msubsup>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>λ</mi>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <ln></ln>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>p</ci>
          <times></times>
         </apply>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>λ</ci>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\left(\frac{1}{\ln 2}+\log_{2}p^{*}_{k}\right)+\lambda=0.
  </annotation>
 </semantics>
</math>

</p>

<p>This shows that all 

<math display="inline" id="Lagrange_multiplier:219">
 <semantics>
  <msubsup>
   <mi>p</mi>
   <mi>k</mi>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <times></times>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{*}_{k}
  </annotation>
 </semantics>
</math>

 are equal (because they depend on 

<math display="inline" id="Lagrange_multiplier:220">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 only). By using the constraint</p>

<p>

<math display="block" id="Lagrange_multiplier:221">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <msub>
      <mi>p</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j}p_{j}=1,
  </annotation>
 </semantics>
</math>

</p>

<p>we find</p>

<p>

<math display="block" id="Lagrange_multiplier:222">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>p</mi>
     <mi>k</mi>
     <mo>*</mo>
    </msubsup>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <times></times>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{*}_{k}=\frac{1}{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>Hence, the uniform distribution is the distribution with the greatest entropy, among distributions on 

<math display="inline" id="Lagrange_multiplier:223">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 points.</p>
<h3 id="example-4-numerical-optimization">Example 4: Numerical optimization</h3>
<figure><b>(Figure)</b>
<figcaption>Lagrange multipliers cause the critical points to occur at saddle points.</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>The magnitude of the gradient can be used to force the critical points to occur at local minima.</figcaption>
</figure>

<p>The critical points of Lagrangians occur at <a href="saddle_point" title="wikilink">saddle points</a>, rather than at local maxima (or minima).<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Unfortunately, many numerical optimization techniques, such as <a href="hill_climbing" title="wikilink">hill climbing</a>, <a href="gradient_descent" title="wikilink">gradient descent</a>, some of the <a href="quasi-Newton_method" title="wikilink">quasi-Newton methods</a>, among others, are designed to find local maxima (or minima) and not saddle points. For this reason, one must either modify the formulation to ensure that it's a minimization problem (for example, by extremizing the square of the <a class="uri" href="gradient" title="wikilink">gradient</a> of the Lagrangian as below), or else use an optimization technique that finds <a href="stationary_points" title="wikilink">stationary points</a> (such as <a href="Newton's_method_in_optimization" title="wikilink">Newton's method</a> without an extremum seeking <a href="line_search" title="wikilink">line search</a>) and not necessarily extrema.</p>

<p>As a simple example, consider the problem of finding the value of 

<math display="inline" id="Lagrange_multiplier:224">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 that minimizes 

<math display="inline" id="Lagrange_multiplier:225">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{2}
  </annotation>
 </semantics>
</math>

, constrained such that 

<math display="inline" id="Lagrange_multiplier:226">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}=1
  </annotation>
 </semantics>
</math>

. (This problem is somewhat pathological because there are only two values that satisfy this constraint, but it is useful for illustration purposes because the corresponding unconstrained function can be visualized in three dimensions.)</p>

<p>Using Lagrange multipliers, this problem can be converted into an unconstrained optimization problem:</p>

<p>

<math display="block" id="Lagrange_multiplier:227">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Λ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>λ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mi>λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>x</mi>
         <mn>2</mn>
        </msup>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>λ</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(x,\lambda)=x^{2}+\lambda(x^{2}-1).
  </annotation>
 </semantics>
</math>

</p>

<p>The two critical points occur at saddle points where 

<math display="inline" id="Lagrange_multiplier:228">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lagrange_multiplier:229">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">−</mi>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>normal-−</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=−1
  </annotation>
 </semantics>
</math>

.</p>

<p>In order to solve this problem with a numerical optimization technique, we must first transform this problem such that the critical points occur at local minima. This is done by computing the magnitude of the gradient of the unconstrained optimization problem.</p>

<p>First, we compute the partial derivative of the unconstrained problem with respect to each variable:</p>

<p>

<math display="block" id="Lagrange_multiplier:230">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>x</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>x</mi>
     <mi>λ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>normal-Λ</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>x</ci>
      <ci>λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial\Lambda}{\partial x}=2x+2x\lambda
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lagrange_multiplier:231">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>λ</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>normal-Λ</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>λ</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial\Lambda}{\partial\lambda}=x^{2}-1.
  </annotation>
 </semantics>
</math>

</p>

<p>If the target function is not easily differentiable, the differential with respect to each variable can be approximated as</p>

<p>

<math display="block" id="Lagrange_multiplier:232">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>x</mi>
    </mrow>
   </mfrac>
   <mo>≈</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <mi>ϵ</mi>
       </mrow>
       <mo>,</mo>
       <mi>λ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>λ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mi>ϵ</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>normal-Λ</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <interval closure="open">
        <apply>
         <plus></plus>
         <ci>x</ci>
         <ci>ϵ</ci>
        </apply>
        <ci>λ</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>λ</ci>
       </interval>
      </apply>
     </apply>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial\Lambda}{\partial x}\approx\frac{\Lambda(x+\epsilon,\lambda)-%
\Lambda(x,\lambda)}{\epsilon}
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Lagrange_multiplier:233">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>λ</mi>
    </mrow>
   </mfrac>
   <mo>≈</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mrow>
        <mi>λ</mi>
        <mo>+</mo>
        <mi>ϵ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>λ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mi>ϵ</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>normal-Λ</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>λ</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <interval closure="open">
        <ci>x</ci>
        <apply>
         <plus></plus>
         <ci>λ</ci>
         <ci>ϵ</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>λ</ci>
       </interval>
      </apply>
     </apply>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial\Lambda}{\partial\lambda}\approx\frac{\Lambda(x,\lambda+\epsilon%
)-\Lambda(x,\lambda)}{\epsilon}
  </annotation>
 </semantics>
</math>

,</p>

<p>where 

<math display="inline" id="Lagrange_multiplier:234">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 is a small value.</p>

<p>Next, we compute the magnitude of the gradient, which is the square root of the sum of the squares of the partial derivatives:</p>

<p>

<math display="block" id="Lagrange_multiplier:235">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>λ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mn>2</mn>
          <mi>x</mi>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mn>2</mn>
          <mi>x</mi>
          <mi>λ</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>x</mi>
          <mn>2</mn>
         </msup>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </msqrt>
    <mo>≈</mo>
    <msqrt>
     <mrow>
      <msup>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mrow>
          <mrow>
           <mi mathvariant="normal">Λ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>x</mi>
             <mo>+</mo>
             <mi>ϵ</mi>
            </mrow>
            <mo>,</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>-</mo>
          <mrow>
           <mi mathvariant="normal">Λ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo>,</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mi>ϵ</mi>
        </mfrac>
        <mo>)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <msup>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mrow>
          <mrow>
           <mi mathvariant="normal">Λ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo>,</mo>
            <mrow>
             <mi>λ</mi>
             <mo>+</mo>
             <mi>ϵ</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>-</mo>
          <mrow>
           <mi mathvariant="normal">Λ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo>,</mo>
            <mi>λ</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mi>ϵ</mi>
        </mfrac>
        <mo>)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </msqrt>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>h</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>λ</ci>
      </interval>
     </apply>
     <apply>
      <root></root>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>x</ci>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>x</ci>
          <ci>λ</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <root></root>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>normal-Λ</ci>
           <interval closure="open">
            <apply>
             <plus></plus>
             <ci>x</ci>
             <ci>ϵ</ci>
            </apply>
            <ci>λ</ci>
           </interval>
          </apply>
          <apply>
           <times></times>
           <ci>normal-Λ</ci>
           <interval closure="open">
            <ci>x</ci>
            <ci>λ</ci>
           </interval>
          </apply>
         </apply>
         <ci>ϵ</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>normal-Λ</ci>
           <interval closure="open">
            <ci>x</ci>
            <apply>
             <plus></plus>
             <ci>λ</ci>
             <ci>ϵ</ci>
            </apply>
           </interval>
          </apply>
          <apply>
           <times></times>
           <ci>normal-Λ</ci>
           <interval closure="open">
            <ci>x</ci>
            <ci>λ</ci>
           </interval>
          </apply>
         </apply>
         <ci>ϵ</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x,\lambda)=\sqrt{(2x+2x\lambda)^{2}+(x^{2}-1)^{2}}\approx\sqrt{\left(\frac{%
\Lambda(x+\epsilon,\lambda)-\Lambda(x,\lambda)}{\epsilon}\right)^{2}+\left(%
\frac{\Lambda(x,\lambda+\epsilon)-\Lambda(x,\lambda)}{\epsilon}\right)^{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>(Since magnitude is always non-negative, optimizing over the squared-magnitude is equivalent to optimizing over the magnitude. Thus, the ``square root" may be omitted from these equations with no expected difference in the results of optimization.)</p>

<p>The critical points of 

<math display="inline" id="Lagrange_multiplier:236">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 occur at 

<math display="inline" id="Lagrange_multiplier:237">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lagrange_multiplier:238">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">−</mi>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>normal-−</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=−1
  </annotation>
 </semantics>
</math>

, just as in 

<math display="inline" id="Lagrange_multiplier:239">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Λ
  </annotation>
 </semantics>
</math>

. Unlike the critical points in 

<math display="inline" id="Lagrange_multiplier:240">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Λ
  </annotation>
 </semantics>
</math>

, however, the critical points in 

<math display="inline" id="Lagrange_multiplier:241">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 occur at local minima, so numerical optimization techniques can be used to find them.</p>
<h2 id="applications">Applications</h2>
<h3 id="economics">Economics</h3>

<p>Constrained optimization plays a central role in <a class="uri" href="economics" title="wikilink">economics</a>. For example, the choice problem for a <a href="consumer_theory" title="wikilink">consumer</a> is represented as one of maximizing a <a href="utility_function" title="wikilink">utility function</a> subject to a <a href="budget_constraint" title="wikilink">budget constraint</a>. The Lagrange multiplier has an economic interpretation as the <a href="shadow_price" title="wikilink">shadow price</a> associated with the constraint, in this example the <a href="marginal_utility" title="wikilink">marginal utility</a> of <a class="uri" href="income" title="wikilink">income</a>. Other examples include <a href="profit_maximization" title="wikilink">profit maximization</a> for a firm, along with various <a href="macroeconomics" title="wikilink">macroeconomic</a> applications.</p>
<h3 id="control-theory">Control theory</h3>

<p>In <a href="optimal_control" title="wikilink">optimal control</a> theory, the Lagrange multipliers are interpreted as <a class="uri" href="costate" title="wikilink">costate</a> variables, and Lagrange multipliers are reformulated as the minimization of the <a href="Hamiltonian_(control_theory)" title="wikilink">Hamiltonian</a>, in <a href="Pontryagin's_minimum_principle" title="wikilink">Pontryagin's minimum principle</a>.</p>
<h3 id="nonlinear-programming">Nonlinear programming</h3>

<p>The Lagrange multiplier method has several generalizations. In <a href="nonlinear_programming" title="wikilink">nonlinear programming</a> there are several multiplier rules, <em>e.g.</em>, the Carathéodory-John Multiplier Rule and the Convex Multiplier Rule, for inequality constraints.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Adjustment_of_observations" title="wikilink">Adjustment of observations</a></li>
<li><a href="Duality_(optimization)" title="wikilink">Duality</a></li>
<li><a href="Karush–Kuhn–Tucker_conditions" title="wikilink">Karush–Kuhn–Tucker conditions</a>: generalization of the method of Lagrange multipliers.</li>
<li><a href="Lagrange_multipliers_on_Banach_spaces" title="wikilink">Lagrange multipliers on Banach spaces</a>: another generalization of the method of Lagrange multipliers.</li>
<li><a href="Lagrangian_relaxation" title="wikilink">Lagrangian relaxation</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>

<p>Exposition</p>
<ul>
<li><a href="http://www.slimy.com/~steuard/teaching/tutorials/Lagrange.html">Conceptual introduction</a> (plus a brief discussion of Lagrange multipliers in the <a href="calculus_of_variations" title="wikilink">calculus of variations</a> as used in physics)</li>
<li><a href="http://ece.k-state.edu/people/faculty/carpenter/documents/lagrange.pdf">Lagrange Multipliers for Quadratic Forms With Linear Constraints</a> by Kenneth H. Carpenter</li>
</ul>

<p>For additional text and interactive applets</p>
<ul>
<li><a href="http://www.umiacs.umd.edu/~resnik/ling848_fa2004/lagrange.html">Simple explanation with an example of governments using taxes as Lagrange multipliers</a></li>
<li><a href="http://nlp.cs.berkeley.edu/tutorials/lagrange-multipliers.pdf">Lagrange Multipliers without Permanent Scarring</a> Explanation with focus on the intuition by Dan Klein</li>
<li><a href="http://demonstrations.wolfram.com/GeometricRepresentationOfMethodOfLagrangeMultipliers">Geometric Representation of Method of Lagrange Multipliers</a> Provides compelling insight in 2 dimensions that at a minimizing point, the direction of steepest descent must be perpendicular to the tangent of the constraint curve at that point. [Needs InternetExplorer/Firefox/Safari] <em>Mathematica</em> demonstration by Shashi Sathyanarayana</li>
<li><a href="http://ocw.mit.edu/ans7870/18/18.02/f07/tools/LagrangeMultipliersTwoVariables.html">Applet</a></li>
<li><a href="http://midnighttutor.com/Lagrange_multiplier.html">Video Lecture of Lagrange Multipliers</a></li>
<li><a href="http://ocw.mit.edu/courses/mathematics/18-02-multivariable-calculus-fall-2007/video-lectures/lecture-13-lagrange-multipliers/">MIT OpenCourseware Video Lecture on Lagrange Multipliers from Multivariable Calculus course</a></li>
<li><a href="http://www.athenasc.com/NLP_Slides.pdf">Slides accompanying Bertsekas's nonlinear optimization text</a>, with details on Lagrange multipliers (lectures 11 and 12)</li>
<li><a href="http://www-mtl.mit.edu/Courses/6.050/2004/unit9/wyatt.apr.7.pdf">Geometric idea behind Lagrange multipliers</a></li>
</ul>

<p>"</p>

<p><a href="Category:Multivariable_calculus" title="wikilink">Category:Multivariable calculus</a> <a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Mathematical_and_quantitative_methods_(economics)" title="wikilink">Category:Mathematical and quantitative methods (economics)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Mécanique Analytique sect. IV, 2 vols. Paris, 1811 <a class="uri" href="https://archive.org/details/mcaniqueanalyt01lagr">https://archive.org/details/mcaniqueanalyt01lagr</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="Alpha_Chiang" title="wikilink">Chiang, Alpha C.</a>, <em>Fundamental Methods of Mathematical Economics</em>, McGraw-Hill, third edition, 1984: p. 386. <a class="uri" href="isbn:9757860069">isbn:9757860069</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
