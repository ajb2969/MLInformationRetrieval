   Interpolation attack      Interpolation attack   In cryptography , an interpolation attack is a type of cryptanalytic attack against block ciphers .  After the two attacks, differential cryptanalysis and linear cryptanalysis , were presented on block ciphers, some new block ciphers were introduced, which were proven secure against differential and linear attacks. Among these there were some iterated block ciphers such as the KN-Cipher and the SHARK cipher. However, Thomas Jakobsen and Lars Knudsen showed in the late 90's that these ciphers were easy to break by introducing a new attack called the interpolation attack.  In the attack, an algebraic function is used to represent an S-box . This may be a simple quadratic , or a polynomial or rational function over a Galois field . Its coefficients can be determined by standard Lagrange interpolation techniques, using known plaintexts as data points. Alternatively, chosen plaintexts can be used to simplify the equations and optimize the attack.  In its simplest version an interpolation attack expresses the ciphertext as a polynomial of the plaintext. If the polynomial has a relative low number of unknown coefficients, then with a collection of plaintext/ciphertext (p/c) pairs, the polynomial can be reconstructed. With the polynomial reconstructed the attacker then has a representation of the encryption, without exact knowledge of the secret key.  The interpolation attack can also be used to recover the secret key.  It is easiest to describe the method with an example.  Example  Let an iterated cipher be given by        c  i   =    (    c   i  -  1    ⊕   k  i    )   3    ,       subscript  c  i    superscript   direct-sum   subscript  c    i  1     subscript  k  i    3     c_{i}=(c_{i-1}\oplus k_{i})^{3},   where    c  0     subscript  c  0    c_{0}   is the plaintext,     k  i   ∈  K       subscript  k  i   K    k_{i}\in K   is the secret round key, and for a   r   r   r   -round iterated cipher,    c  r     subscript  c  r    c_{r}   is the ciphertext.  Consider the 2-round cipher. Let   x   x   x   denote the message, and   c   c   c   denote the ciphertext.  Then the output of round 1 becomes        c  1   =    (   x  +   k  1    )   3   =    (    x  2   +   k  1  2    )    (   x  +   k  1    )    =    x  3   +    k  1  2   x   +    x  2    k  1    +   k  1  3     ,         subscript  c  1    superscript    x   subscript  k  1    3             superscript  x  2    superscript   subscript  k  1   2      x   subscript  k  1             superscript  x  3      superscript   subscript  k  1   2   x      superscript  x  2    subscript  k  1     superscript   subscript  k  1   3       c_{1}=(x+k_{1})^{3}=(x^{2}+k_{1}^{2})(x+k_{1})=x^{3}+k_{1}^{2}x+x^{2}k_{1}+k_{%
 1}^{3},   and the output of round 2 becomes       c  2   =  c  =    (    c  1   +   k  2    )   3   =    (    x  3   +    k  1  2   x   +    x  2    k  1    +   k  1  3   +   k  2    )   3          subscript  c  2   c        superscript     subscript  c  1    subscript  k  2    3         superscript     superscript  x  3      superscript   subscript  k  1   2   x      superscript  x  2    subscript  k  1     superscript   subscript  k  1   3    subscript  k  2    3      c_{2}=c=(c_{1}+k_{2})^{3}=(x^{3}+k_{1}^{2}x+x^{2}k_{1}+k_{1}^{3}+k_{2})^{3}           =    x  9   +    x  8    k  1    +    x  6    k  2    +    x  4    k  1  2    k  2    +    x  3    k  2  2    +    x  2    (     k  1    k  2  2    +    k  1  4    k  2     )    +   x   (     k  1  2    k  2  2    +   k  1  8    )    +    k  1  3    k  2  2    +   k  1  9   +   k  2  3     ,      absent     superscript  x  9      superscript  x  8    subscript  k  1       superscript  x  6    subscript  k  2       superscript  x  4    superscript   subscript  k  1   2    subscript  k  2       superscript  x  3    superscript   subscript  k  2   2       superscript  x  2        subscript  k  1    superscript   subscript  k  2   2       superscript   subscript  k  1   4    subscript  k  2        x       superscript   subscript  k  1   2    superscript   subscript  k  2   2     superscript   subscript  k  1   8        superscript   subscript  k  1   3    superscript   subscript  k  2   2     superscript   subscript  k  1   9    superscript   subscript  k  2   3      =x^{9}+x^{8}k_{1}+x^{6}k_{2}+x^{4}k_{1}^{2}k_{2}+x^{3}k_{2}^{2}+x^{2}(k_{1}k_{%
 2}^{2}+k_{1}^{4}k_{2})+x(k_{1}^{2}k_{2}^{2}+k_{1}^{8})+k_{1}^{3}k_{2}^{2}+k_{1%
 }^{9}+k_{2}^{3},   Express the ciphertext as a polynomial of the plaintext yields        p   (  x  )    =     a  1    x  9    +    a  2    x  8    +    a  3    x  6    +    a  4    x  4    +    a  5    x  3    +    a  6    x  2    +    a  7   x   +   a  8     ,        p  x        subscript  a  1    superscript  x  9       subscript  a  2    superscript  x  8       subscript  a  3    superscript  x  6       subscript  a  4    superscript  x  4       subscript  a  5    superscript  x  3       subscript  a  6    superscript  x  2       subscript  a  7   x    subscript  a  8      p(x)=a_{1}x^{9}+a_{2}x^{8}+a_{3}x^{6}+a_{4}x^{4}+a_{5}x^{3}+a_{6}x^{2}+a_{7}x+%
 a_{8},   where the    a  i     subscript  a  i    a_{i}   's are key dependent constants.  Using as many plaintext/ciphertext pairs as the number of unknown coefficients in the polynomial    p   (  x  )       p  x    p(x)   , then we can construct the polynomial. This can for example be done by Lagrange Interpolation (see Lagrange polynomial ). When the unknown coefficients have been determined, then we have an representation    p   (  x  )       p  x    p(x)   of the encryption, without knowledge of the secret key   K   K   K   .  Existence  Considering an   m   m   m   -bit block cipher, then there are    2  m     superscript  2  m    2^{m}   possible plaintexts, and therefore    2  m     superscript  2  m    2^{m}   distinct    p  /  c      p  c    p/c   pairs. Let there be   n   n   n   unknown coefficients in    p   (  x  )       p  x    p(x)   . Since we require as many    p  /  c      p  c    p/c   pairs as the number of unknown coefficients in the polynomial, then an interpolation attack exist only if    n  ≤   2  m       n   superscript  2  m     n\leq 2^{m}   .  Time complexity  Assume that the time to construct the polynomial    p   (  x  )       p  x    p(x)   using    p  /  c      p  c    p/c   pairs are small, in comparison to the time to encrypt the required plaintexts. Let there be   n   n   n   unknown coefficients in    p   (  x  )       p  x    p(x)   . Then the time complexity for this attack is   n   n   n   , requiring   n   n   n   known distinct    p  /  c      p  c    p/c   pairs.  Interpolation attack by Meet-In-The-Middle  Often this method is more efficient. Here is how it is done.  Given an   r   r   r   round iterated cipher with block length   m   m   m   , let   z   z   z   be the output of the cipher after   s   s   s   rounds with   x   x   x   as a polynomial of the plaintext   c   c   c   , and as a polynomial of the ciphertext     g   (  x  )    ∈   G  F   (   2  m   )    [  x  ]          g  x     G  F   superscript  2  m    delimited-[]  x      g(x)\in GF(2^{m})[x]   . Let   z   z   z   be the expression of   x   x   x   via     h   (  c  )    ∈   G  F   (   2  m   )    [  c  ]          h  c     G  F   superscript  2  m    delimited-[]  c      h(c)\in GF(2^{m})[c]   , and let   z   z   z   be the expression of   c   c   c   via    g   (  x  )       g  x    g(x)   . The polynomial   s   s   s   is obtain by computing forward using the iterated formula of the cipher until round    h   (  c  )       h  c    h(c)   , and the polynomial   r   r   r   is obtain by computing backwards from the iterated formula of the cipher starting from round    s  +  1      s  1    s+1   until round      g   (  x  )    =   h   (  c  )     ,        g  x     h  c     g(x)=h(c),   .  So it should hold that     g   g   g   and if both   h   h   h   and    g   (  x  )       g  x    g(x)   are polynomials with a low number of coefficients, then we can solve the equation for the unknown coefficients.  Time complexity  Assume that   p   p   p   can be expressed by    h   (  c  )       h  c    h(c)   coefficients, and   q   q   q   can be expressed by    p  +  q      p  q    p+q   coefficients. Then we would need    p  /  c      p  c    p/c   known distinct     p  +  q   -  2        p  q   2    p+q-2   pairs to solve the equation by setting it up as a matrix equation. However, this matrix equation is solvable up to a multiplication and an addition. So to make sure that we get a unique and non-zero solution, we set the coefficient corresponding to the highest degree to one, and the constant term to zero. Therefore    p  /  c      p  c    p/c   known distinct     p  +  q   -  2        p  q   2    p+q-2   pairs are required. So the time complexity for this attack is     p  +  q   -  2        p  q   2    p+q-2   , requiring    p  /  c      p  c    p/c   known distinct    p  /  c      p  c    p/c   pairs.  By the Meet-In-The-Middle approach the total number of coefficients is usually smaller than using the normal method. This makes the method more efficient, since less   K   K   K   pairs are required.  Key-recovery  We can also use the interpolation attack to recover the secret key   r   r   r   .  If we remove the last round of an   m   m   m   -round iterated cipher with block length     y  ~   =   c   r  -  1         normal-~  y    subscript  c    r  1      \tilde{y}=c_{r-1}   , the output of the cipher becomes    k  r     subscript  k  r    k_{r}   . Call the cipher the reduced cipher. The idea is to make a guess on the last round key    y  ~     normal-~  y    \tilde{y}   , such that we can decrypt one round to obtain the output    y  ~     normal-~  y    \tilde{y}   of the reduced cipher. Then to verify the guess we use the interpolation attack on the reduced cipher either by the normal method or by the Meet-In-The-Middle method. Here is how it is done.  By the normal method we express the output   x   x   x   of the reduced cipher as a polynomial of the plaintext     p   (  x  )    ∈   G  F   (   2  m   )    [  x  ]          p  x     G  F   superscript  2  m    delimited-[]  x      p(x)\in GF(2^{m})[x]   . Call the polynomial    p   (  x  )       p  x    p(x)   . Then if we can express   n   n   n   with   n   n   n   coefficients, then using    p  /  c      p  c    p/c   known distinct    p  /  c      p  c    p/c   pairs, we can construct the polynomial. To verify the guess of the last round key, then check with one extra      p   (  x  )    =   y  ~    .        p  x    normal-~  y     p(x)=\tilde{y}.   pair if it holds that     z   z   z   If yes, then with high probability the guess of the last round key was correct. If no, then make another guess of the key.  By the Meet-In-The-Middle method we express the output    y  ~     normal-~  y    \tilde{y}   from round    g   (  x  )       g  x    g(x)   and as a polynomial of the output of the reduced cipher    h   (   y  ~   )       h   normal-~  y     h(\tilde{y})   . Call the polynomials   p   p   p   and   q   q   q   , and let them be expressed by     q  +  p   -  2        q  p   2    q+p-2   and    p  /  c      p  c    p/c   coefficients, respectively. Then with    p  /  c      p  c    p/c   known distinct      g   (  x  )    =   h   (   y  ~   )     .        g  x     h   normal-~  y      g(x)=h(\tilde{y}).   pairs we can find the coefficients. To verify the guess of the last round key, then check with one extra   m   m   m   pair if it holds that      2  m     superscript  2  m    2^{m}   If yes, then with high probability the guess of the last round key was correct. If no, then make another guess of the key.  Once we have found the correct last round key, then we can continue in a similar fashion on the remaining round keys.  Time complexity  With a secret round key of length    1  /   2  m       1   superscript  2  m     1/2^{m}   , then there are     1  /  2   ⋅   2  m      normal-⋅    1  2    superscript  2  m     1/2\cdot 2^{m}   different keys. Each with probability     2   m  -  1     (   n  +  1   )        superscript  2    m  1      n  1     2^{m-1}(n+1)   to be correct if chosen at random. Therefore we will on average have to make    n  +  1      n  1    n+1   guesses before finding the correct key.  Hence, the normal method have average time complexity    c  /  p      c  p    c/p   , requiring     2   m  -  1     (    p  +  q   -  1   )        superscript  2    m  1        p  q   1     2^{m-1}(p+q-1)   known distinct     p  +  q   -  1        p  q   1    p+q-1   pairs, and the Meet-In-The-Middle method have average time complexity    c  /  p      c  p    c/p   , requiring   m   m   m   known distinct    S  :    f   (  x  )    =   x   -  1    =   x    2  m   -  2        normal-:  S        f  x    superscript  x    1          superscript  x     superscript  2  m   2        S:f(x)=x^{-1}=x^{2^{m}-2}   pairs.  Real world application  The Meet-in-the-middle attack can be used in a variant to attack S-boxes, which uses the inverse function, because with an    G  F   (   2  m   )       G  F   superscript  2  m     GF(2^{m})   -bit S-box then    S  :    f   (  x  )    =   x   -  1        normal-:  S      f  x    superscript  x    1       S:f(x)=x^{-1}   in    (  n  ,  m  ,  r  )     n  m  r    (n,m,r)   .  The block cipher SHARK uses SP-network with S-box    n  m      n  m    nm   . The cipher is resistant against differential and linear cryptanalysis after a small number of rounds. However it was broken in 1996 by Thomas Jakobsen and Lars Knudsen, using interpolation attack. Denote by SHARK   n   n   n   a version of SHARK with block size   m   m   m   bits using   r   r   r   parallel    (  8  ,  8  ,  4  )     8  8  4    (8,8,4)   -bit S-boxes in    2  21     superscript  2  21    2^{21}   rounds. Jakobsen and Knudsen found that there exist an interpolation attack on SHARK    (  8  ,  16  ,  7  )     8  16  7    (8,16,7)   (64-bit block cipher) using about    2  61     superscript  2  61    2^{61}   chosen plaintexts, and an interpolation attack on SHARK $(8,16,7)$ (128-bit block cipher) using about $2^{61}$ chosen plaintexts.  Also Thomas Jakobsen introduced a probabilistic version of the interpolation attack using Madhu Sudan 's algorithm for improved decoding of Reed-Solomon codes . This attack can work even when an algebraic relationship between plaintexts and ciphertexts holds for only a fraction of values.  References     ([ http://video.google.com/videoplay?docid=-502705185794473481&hl; ;=en Video of presentation] at Google Video —uses Flash )      "  Category:Cryptographic attacks   