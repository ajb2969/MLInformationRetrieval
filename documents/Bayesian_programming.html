<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="600">Bayesian programming</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bayesian programming</h1>
<hr/>

<p><strong>Bayesian programming</strong> is a formalism and a methodology to specify probabilistic models and solve problems when all the necessary information is not available.</p>

<p><a href="Edwin_Thompson_Jaynes" title="wikilink">Edwin T. Jaynes</a> proposed that probability could be considered as an alternative and an extension of logic for rational reasoning with incomplete and uncertain information. In his founding book <em>Probability Theory: The Logic of Science</em><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> he developed this theory and proposed what he called “the robot,” which was not a physical device, but an inference engine to automate probabilistic reasoning—a kind of <a class="uri" href="Prolog" title="wikilink">Prolog</a> for probability instead of logic. Bayesian programming<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is a formal and concrete implementation of this "robot".</p>

<p>Bayesian programming may also be seen as an algebraic formalism to specify <a href="graphical_model" title="wikilink">graphical models</a> such as, for instance, <a href="Bayesian_network" title="wikilink">Bayesian networks</a>, <a href="dynamic_Bayesian_network" title="wikilink">dynamic Bayesian networks</a>, <a href="Kalman_filter" title="wikilink">Kalman filters</a> or <a href="hidden_Markov_model" title="wikilink">hidden Markov models</a>. Indeed, Bayesian Programming is more general than <a href="Bayesian_network" title="wikilink">Bayesian networks</a> and has a power of expression equivalent to probabilistic <a href="factor_graph" title="wikilink">factor graphs</a>.</p>
<h2 id="formalism">Formalism</h2>

<p>A Bayesian program is a means of specifying a family of probability distributions.</p>

<p>The constituent elements of a Bayesian program are presented below:</p>

<p>

<math display="block" id="Bayesian_programming:0">
 <semantics>
  <mrow>
   <mtext>Program</mtext>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mtext>Description</mtext>
        <mrow>
         <mo>{</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mtext>Specification</mtext>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>π</mi>
              <mo stretchy="false">)</mo>
             </mrow>
             <mrow>
              <mo>{</mo>
              <mtable displaystyle="true">
               <mtr>
                <mtd columnalign="left">
                 <mtext>Variables</mtext>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mtext>Decomposition</mtext>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mtext>Forms</mtext>
                </mtd>
                <mtd></mtd>
               </mtr>
              </mtable>
             </mrow>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mtext>Identification (based on</mtext>
             <mi>δ</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
         </mtable>
        </mrow>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mtext>Question</mtext>
      </mtd>
      <mtd></mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Program</mtext>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <mtext>Description</mtext>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <apply>
        <times></times>
        <mtext>Specification</mtext>
        <ci>π</ci>
        <apply>
         <csymbol cd="latexml">cases</csymbol>
         <mtext>Variables</mtext>
         <mtext>otherwise</mtext>
         <mtext>Decomposition</mtext>
         <mtext>otherwise</mtext>
         <mtext>Forms</mtext>
         <mtext>otherwise</mtext>
        </apply>
       </apply>
       <mtext>otherwise</mtext>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <mtext>Identification (based on</mtext>
        <csymbol cd="unknown">δ</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <mtext>otherwise</mtext>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
     <mtext>Question</mtext>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Program}\begin{cases}\text{Description}\begin{cases}\text{Specification}%
(\pi)\begin{cases}\text{Variables}\\
\text{Decomposition}\\
\text{Forms}\\
\end{cases}\\
\text{Identification (based on }\delta)\end{cases}\\
\text{Question}\end{cases}
  </annotation>
 </semantics>
</math>

</p>
<ol>
<li>A program is constructed from a description and a question.</li>
<li>A description is constructed using some specification (

<math display="inline" id="Bayesian_programming:1">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

) as given by the programmer and an identification or learning process for the parameters not completely specified by the specification, using a data set (

<math display="inline" id="Bayesian_programming:2">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

).</li>
<li>A specification is constructed from a set of pertinent variables, a decomposition and a set of forms.</li>
<li>Forms are either parametric forms or questions to other Bayesian programs.</li>
<li>A question specifies which probability distribution has to be computed.</li>
</ol>
<h3 id="description">Description</h3>

<p>The purpose of a description is to specify an effective method of computing a <a href="joint_probability_distribution" title="wikilink">joint probability distribution</a> on a set of <a href="Random_variable" title="wikilink">variables</a> 

<math display="inline" id="Bayesian_programming:3">
 <semantics>
  <mrow>
   <mo>{</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mi>N</mi>
   </msub>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>N</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{X_{1},X_{2},\cdots,X_{N}\right\}
  </annotation>
 </semantics>
</math>

 given a set of experimental data 

<math display="inline" id="Bayesian_programming:4">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 and some specification 

<math display="inline" id="Bayesian_programming:5">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

. This <a href="Joint_probability_distribution" title="wikilink">joint distribution</a> is denoted as

<math display="block" id="Bayesian_programming:6">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>∧</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msub>
     <mi>X</mi>
     <mi>N</mi>
    </msub>
    <mo>∣</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <and></and>
     <ci>normal-⋯</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(X_{1}\wedge X_{2}\wedge\cdots\wedge X_{N}\mid\delta\wedge\pi\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>To specify preliminary knowledge 

<math display="inline" id="Bayesian_programming:7">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

, the programmer must undertake the following:</p>
<ol>
<li>Define the set of relevant <a href="Random_variable" title="wikilink">variables</a> 

<math display="inline" id="Bayesian_programming:8">
 <semantics>
  <mrow>
   <mo>{</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mi>N</mi>
   </msub>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>N</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{X_{1},X_{2},\cdots,X_{N}\right\}
  </annotation>
 </semantics>
</math>

 on which the joint distribution is defined.</li>
<li>Decompose the joint distribution (break it into relevant <a href="Independence_(probability_theory)" title="wikilink">independent</a> or <a href="Conditional_probability" title="wikilink">conditional probabilities</a>).</li>
<li>Define the forms of each of the distributions (e.g., for each variable, one of the <a href="list_of_probability_distributions" title="wikilink">list of probability distributions</a>).</li>
</ol>
<h4 id="decomposition">Decomposition</h4>

<p>Given a partition 

<math display="inline" id="Bayesian_programming:9">
 <semantics>
  <mrow>
   <mo>{</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mi>N</mi>
   </msub>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>N</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{X_{1},X_{2},\ldots,X_{N}\right\}
  </annotation>
 </semantics>
</math>

 containing 

<math display="inline" id="Bayesian_programming:10">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 subsets, 

<math display="inline" id="Bayesian_programming:11">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 variables are defined 

<math display="inline" id="Bayesian_programming:12">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>L</mi>
    <mi>K</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>K</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1},\cdots,L_{K}
  </annotation>
 </semantics>
</math>

, each corresponding to one of these subsets. Each variable 

<math display="inline" id="Bayesian_programming:13">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{k}
  </annotation>
 </semantics>
</math>

 is obtained as the conjunction of the variables 

<math display="inline" id="Bayesian_programming:14">
 <semantics>
  <mrow>
   <mo>{</mo>
   <msub>
    <mi>X</mi>
    <msub>
     <mi>k</mi>
     <mn>1</mn>
    </msub>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <msub>
     <mi>k</mi>
     <mn>2</mn>
    </msub>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{X_{k_{1}},X_{k_{2}},\cdots\right\}
  </annotation>
 </semantics>
</math>

 belonging to the 

<math display="inline" id="Bayesian_programming:15">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>

 subset. Recursive application of <a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a> leads to:</p>

<p>

<math display="inline" id="Bayesian_programming:16">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>∧</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msub>
     <mi>X</mi>
     <mi>N</mi>
    </msub>
    <mo>∣</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <and></and>
     <ci>normal-⋯</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P\left(X_{1}\wedge X_{2}\wedge\cdots\wedge X_{N}\mid\delta\wedge%
\pi\right)
  </annotation>
 </semantics>
</math>


</p>

<p><a href="Conditional_independance" title="wikilink">Conditional independence</a> hypotheses then allow further simplifications. A conditional independence hypothesis for variable 

<math display="inline" id="Bayesian_programming:17">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{k}
  </annotation>
 </semantics>
</math>

 is defined by choosing some variable 

<math display="inline" id="Bayesian_programming:18">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}
  </annotation>
 </semantics>
</math>

 among the variables appearing in the conjunction 

<math display="inline" id="Bayesian_programming:19">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>∧</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>∧</mo>
   <msub>
    <mi>L</mi>
    <mn>2</mn>
   </msub>
   <mo>∧</mo>
   <msub>
    <mi>L</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{k-1}\wedge\cdots\wedge L_{2}\wedge L_{1}
  </annotation>
 </semantics>
</math>

, labelling 

<math display="inline" id="Bayesian_programming:20">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{k}
  </annotation>
 </semantics>
</math>

 as the conjunction of these chosen variables and setting:</p>

<p>

<math display="block" id="Bayesian_programming:21">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>L</mi>
     <mi>k</mi>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>L</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msub>
     <mi>L</mi>
     <mn>1</mn>
    </msub>
    <mo>∧</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>L</mi>
     <mi>k</mi>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>R</mi>
     <mi>k</mi>
    </msub>
    <mo>∧</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <and></and>
     <ci>normal-⋯</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <cn type="integer">1</cn>
     </apply>
     <and></and>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>k</ci>
     </apply>
     <and></and>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(L_{k}\mid L_{k-1}\wedge\cdots\wedge L_{1}\wedge\delta\wedge\pi\right)=P%
\left(L_{k}\mid R_{k}\wedge\delta\wedge\pi\right)
  </annotation>
 </semantics>
</math>

</p>

<p>We then obtain:</p>

<p>

<math display="inline" id="Bayesian_programming:22">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>∧</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msub>
     <mi>X</mi>
     <mi>N</mi>
    </msub>
    <mo>∣</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <and></and>
     <ci>normal-⋯</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P\left(X_{1}\wedge X_{2}\wedge\cdots\wedge X_{N}\mid\delta\wedge%
\pi\right)
  </annotation>
 </semantics>
</math>


</p>

<p>Such a simplification of the joint distribution as a product of simpler distributions is called a decomposition, derived using the <a href="Chain_rule_(probability)" title="wikilink">chain rule</a>.</p>

<p>This ensures that each variable appears at the most once on the left of a conditioning bar, which is the necessary and sufficient condition to write mathematically valid decompositions.</p>
<h4 id="forms">Forms</h4>

<p>Each distribution 

<math display="inline" id="Bayesian_programming:23">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>L</mi>
     <mi>k</mi>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>R</mi>
     <mi>k</mi>
    </msub>
    <mo>∧</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>k</ci>
     </apply>
     <and></and>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(L_{k}\mid R_{k}\wedge\delta\wedge\pi\right)
  </annotation>
 </semantics>
</math>

 appearing in the product is then associated with either a parametric form (i.e., a function 

<math display="inline" id="Bayesian_programming:24">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>μ</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>L</mi>
     <mi>k</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>μ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{\mu}\left(L_{k}\right)
  </annotation>
 </semantics>
</math>

) or a question to another Bayesian program 

<math display="inline" id="Bayesian_programming:25">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>L</mi>
     <mi>k</mi>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>R</mi>
     <mi>k</mi>
    </msub>
    <mo>∧</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <mi>L</mi>
    <mo>∣</mo>
    <mi>R</mi>
    <mo>∧</mo>
    <mover accent="true">
     <mi>δ</mi>
     <mo>^</mo>
    </mover>
    <mo>∧</mo>
    <mover accent="true">
     <mi>π</mi>
     <mo>^</mo>
    </mover>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>k</ci>
     </apply>
     <and></and>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">R</csymbol>
     <and></and>
     <apply>
      <ci>normal-^</ci>
      <ci>δ</ci>
     </apply>
     <and></and>
     <apply>
      <ci>normal-^</ci>
      <ci>π</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(L_{k}\mid R_{k}\wedge\delta\wedge\pi\right)=P\left(L\mid R\wedge%
\widehat{\delta}\wedge\widehat{\pi}\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>When it is a form 

<math display="inline" id="Bayesian_programming:26">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>μ</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>L</mi>
     <mi>k</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>μ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{\mu}\left(L_{k}\right)
  </annotation>
 </semantics>
</math>

, in general, 

<math display="inline" id="Bayesian_programming:27">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 is a vector of parameters that may depend on 

<math display="inline" id="Bayesian_programming:28">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{k}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Bayesian_programming:29">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 or both. Learning takes place when some of these parameters are computed using the data set 

<math display="inline" id="Bayesian_programming:30">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

.</p>

<p>An important feature of Bayesian Programming is this capacity to use questions to other Bayesian programs as components of the definition of a new Bayesian program. 

<math display="inline" id="Bayesian_programming:31">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>L</mi>
     <mi>k</mi>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>R</mi>
     <mi>k</mi>
    </msub>
    <mo>∧</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>k</ci>
     </apply>
     <and></and>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(L_{k}\mid R_{k}\wedge\delta\wedge\pi\right)
  </annotation>
 </semantics>
</math>

 is obtained by some inferences done by another Bayesian program defined by the specifications 

<math display="inline" id="Bayesian_programming:32">
 <semantics>
  <mover accent="true">
   <mi>π</mi>
   <mo>^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\pi}
  </annotation>
 </semantics>
</math>

 and the data 

<math display="inline" id="Bayesian_programming:33">
 <semantics>
  <mover accent="true">
   <mi>δ</mi>
   <mo>^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{\delta}
  </annotation>
 </semantics>
</math>

. This is similar to calling a subroutine in classical programming and provides an easy way to build <a href="Bayesian_network#Hierarchical_models" title="wikilink">hierarchical models</a>.</p>
<h3 id="question">Question</h3>

<p>Given a description (i.e., 

<math display="inline" id="Bayesian_programming:34">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>∧</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msub>
     <mi>X</mi>
     <mi>N</mi>
    </msub>
    <mo>∣</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <and></and>
     <ci>normal-⋯</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(X_{1}\wedge X_{2}\wedge\cdots\wedge X_{N}\mid\delta\wedge\pi\right)
  </annotation>
 </semantics>
</math>

), a question is obtained by partitioning 

<math display="inline" id="Bayesian_programming:35">
 <semantics>
  <mrow>
   <mo>{</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mi>N</mi>
   </msub>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>N</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{X_{1},X_{2},\cdots,X_{N}\right\}
  </annotation>
 </semantics>
</math>

 into three sets: the searched variables, the known variables and the free variables.</p>

<p>The 3 variables 

<math display="inline" id="Bayesian_programming:36">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>e</mi>
   <mi>a</mi>
   <mi>r</mi>
   <mi>c</mi>
   <mi>h</mi>
   <mi>e</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>e</ci>
    <ci>a</ci>
    <ci>r</ci>
    <ci>c</ci>
    <ci>h</ci>
    <ci>e</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Searched
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Bayesian_programming:37">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mi>n</mi>
   <mi>o</mi>
   <mi>w</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>n</ci>
    <ci>o</ci>
    <ci>w</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Known
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bayesian_programming:38">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>r</mi>
   <mi>e</mi>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>r</ci>
    <ci>e</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Free
  </annotation>
 </semantics>
</math>

 are defined as the conjunction of the variables belonging to these sets.</p>

<p>A question is defined as the set of distributions:</p>

<p>

<math display="block" id="Bayesian_programming:39">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <mi>S</mi>
    <mi>e</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>c</mi>
    <mi>h</mi>
    <mi>e</mi>
    <mi>d</mi>
    <mo>∣</mo>
    <mtext>Known</mtext>
    <mo>∧</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-∣</ci>
     <mtext>Known</mtext>
     <and></and>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(Searched\mid\text{Known}\wedge\delta\wedge\pi\right)
  </annotation>
 </semantics>
</math>

</p>

<p>made of many "instantiated questions" as the cardinal of 

<math display="inline" id="Bayesian_programming:40">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mi>n</mi>
   <mi>o</mi>
   <mi>w</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>n</ci>
    <ci>o</ci>
    <ci>w</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Known
  </annotation>
 </semantics>
</math>

, each instantiated question being the distribution:</p>

<p>

<math display="block" id="Bayesian_programming:41">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <mtext>Searched</mtext>
    <mo>∣</mo>
    <mtext>Known</mtext>
    <mo>∧</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>Searched</mtext>
     <ci>normal-∣</ci>
     <mtext>Known</mtext>
     <and></and>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(\text{Searched}\mid\text{Known}\wedge\delta\wedge\pi\right)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="inference">Inference</h3>

<p>Given the joint distribution 

<math display="inline" id="Bayesian_programming:42">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>∧</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msub>
     <mi>X</mi>
     <mi>N</mi>
    </msub>
    <mo>∣</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <and></and>
     <ci>normal-⋯</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(X_{1}\wedge X_{2}\wedge\cdots\wedge X_{N}\mid\delta\wedge\pi\right)
  </annotation>
 </semantics>
</math>

, it is always possible to compute any possible question using the following general inference:</p>

<p>

<math display="inline" id="Bayesian_programming:43">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <mtext>Searched</mtext>
    <mo>∣</mo>
    <mtext>Known</mtext>
    <mo>∧</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>Searched</mtext>
     <ci>normal-∣</ci>
     <mtext>Known</mtext>
     <and></and>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P\left(\text{Searched}\mid\text{Known}\wedge\delta\wedge\pi\right)
  </annotation>
 </semantics>
</math>


</p>

<p>where the first equality results from the marginalization rule, the second results from <a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a> and the third corresponds to a second application of marginalization. The denominator appears to be a normalization term and can be replaced by a constant 

<math display="inline" id="Bayesian_programming:44">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

.</p>

<p>Theoretically, this allows to solve any Bayesian inference problem. In practice, however, the cost of computing exhaustively and exactly 

<math display="inline" id="Bayesian_programming:45">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <mtext>Searched</mtext>
    <mo>∣</mo>
    <mtext>Known</mtext>
    <mo>∧</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>Searched</mtext>
     <ci>normal-∣</ci>
     <mtext>Known</mtext>
     <and></and>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(\text{Searched}\mid\text{Known}\wedge\delta\wedge\pi\right)
  </annotation>
 </semantics>
</math>


 is too great in almost all cases.</p>

<p>Replacing the joint distribution by its decomposition we get:</p>

<p>

<math display="inline" id="Bayesian_programming:46">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <mtext>Searched</mtext>
    <mo>∣</mo>
    <mtext>Known</mtext>
    <mo>∧</mo>
    <mi>δ</mi>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>Searched</mtext>
     <ci>normal-∣</ci>
     <mtext>Known</mtext>
     <and></and>
     <csymbol cd="unknown">δ</csymbol>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P\left(\text{Searched}\mid\text{Known}\wedge\delta\wedge\pi\right)
  </annotation>
 </semantics>
</math>


</p>

<p>which is usually a much simpler expression to compute, as the dimensionality of the problem is considerably reduced by the decomposition into a product of lower dimension distributions.</p>
<h2 id="example">Example</h2>
<h3 id="bayesian-spam-detection">Bayesian spam detection</h3>

<p>The purpose of <a href="Bayesian_spam_filtering" title="wikilink">Bayesian spam filtering</a> is to eliminate junk e-mails.</p>

<p>The problem is very easy to formulate. E-mails should be classified into one of two categories: non-spam or spam. The only available information to classify the e-mails is their content: a set of words. Using these words without taking the order into account is commonly called a <a href="Bag_of_words" title="wikilink">bag of words model</a>.</p>

<p>The classifier should furthermore be able to adapt to its user and to learn from experience. Starting from an initial standard setting, the classifier should modify its internal parameters when the user disagrees with its own decision. It will hence adapt to the user’s criteria to differentiate between non-spam and spam. It will improve its results as it encounters increasingly classified e-mails.</p>
<h4 id="variables">Variables</h4>

<p>The variables necessary to write this program are as follows:</p>
<ol>
<li>

<math display="inline" id="Bayesian_programming:47">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>p</mi>
   <mi>a</mi>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>p</ci>
    <ci>a</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Spam
  </annotation>
 </semantics>
</math>

: a binary variable, false if the e-mail is not spam and true otherwise.</li>
<li>

<math display="inline" id="Bayesian_programming:48">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>W</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>W</mi>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{0},W_{1},\ldots,W_{N-1}
  </annotation>
 </semantics>
</math>



<math display="block" id="Bayesian_programming:49">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 binary variables. 

<math display="inline" id="Bayesian_programming:50">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{n}
  </annotation>
 </semantics>
</math>

 is true if the 

<math display="inline" id="Bayesian_programming:51">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{th}
  </annotation>
 </semantics>
</math>

 word of the dictionary is present in the text.</li>
</ol>

<p>These 

<math display="inline" id="Bayesian_programming:52">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N+1
  </annotation>
 </semantics>
</math>

 binary variables sum up all the information about an e-mail.</p>
<h4 id="decomposition-1">Decomposition</h4>

<p>Starting from the joint distribution and applying recursively <a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a> we obtain:</p>

<p>

<math display="inline" id="Bayesian_programming:53">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mtext>Spam</mtext>
     <mo>∧</mo>
     <msub>
      <mi>W</mi>
      <mn>0</mn>
     </msub>
     <mo>∧</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>∧</mo>
     <msub>
      <mi>W</mi>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <and></and>
     <mtext>Spam</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(\text{Spam}\wedge W_{0}\wedge\cdots\wedge W_{N-1})
  </annotation>
 </semantics>
</math>


</p>

<p>This is an exact mathematical expression.</p>

<p>It can be drastically simplified by assuming that the probability of appearance of a word knowing the nature of the text (spam or not) is independent of the appearance of the other words. This is the <a href="naive_Bayes" title="wikilink">naive Bayes</a> assumption and this makes this spam filter a <a href="naive_Bayes" title="wikilink">naive Bayes</a> model.</p>

<p>For instance, the programmer can assume that:</p>

<p>

<math display="block" id="Bayesian_programming:54">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>W</mi>
     <mn>1</mn>
    </msub>
    <mo>∣</mo>
    <mtext>Spam</mtext>
    <mo>∧</mo>
    <msub>
     <mi>W</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>W</mi>
     <mn>1</mn>
    </msub>
    <mo>∣</mo>
    <mtext>Spam</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-∣</ci>
     <mtext>Spam</mtext>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-∣</ci>
     <mtext>Spam</mtext>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(W_{1}\mid\text{Spam}\land W_{0})=P(W_{1}\mid\text{Spam})
  </annotation>
 </semantics>
</math>

</p>

<p>to finally obtain:</p>

<p>

<math display="block" id="Bayesian_programming:55">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>Spam</mtext>
    <mo>∧</mo>
    <msub>
     <mi>W</mi>
     <mn>0</mn>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">…</mi>
    <mo>∧</mo>
    <msub>
     <mi>W</mi>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>Spam</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </munderover>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>W</mi>
      <mi>n</mi>
     </msub>
     <mo>∣</mo>
     <mtext>Spam</mtext>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>Spam</mtext>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <cn type="integer">0</cn>
     </apply>
     <and></and>
     <ci>normal-…</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>Spam</mtext>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-∣</ci>
      <mtext>Spam</mtext>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\text{Spam}\land W_{0}\land\ldots\land W_{N-1})=P(\text{Spam})\prod_{n=0}^{N%
-1}[P(W_{n}\mid\text{Spam})]
  </annotation>
 </semantics>
</math>

</p>

<p>This kind of assumption is known as the <a href="Naive_Bayes_classifier" title="wikilink">naive Bayes' assumption</a>. It is "naive" in the sense that the independence between words is clearly not completely true. For instance, it completely neglects that the appearance of pairs of words may be more significant than isolated appearances. However, the programmer may assume this hypothesis and may develop the model and the associated inferences to test how reliable and efficient it is.</p>
<h4 id="parametric-forms">Parametric forms</h4>

<p>To be able to compute the joint distribution, the programmer must now specify the 

<math display="inline" id="Bayesian_programming:56">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N+1
  </annotation>
 </semantics>
</math>

 distributions appearing in the decomposition:</p>
<ol>
<li>

<math display="inline" id="Bayesian_programming:57">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>Spam</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <mtext>Spam</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\text{Spam})
  </annotation>
 </semantics>
</math>

 is a prior defined, for instance, by 

<math display="inline" id="Bayesian_programming:58">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mtext>Spam</mtext>
     <mo>=</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>0.75</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <mtext>Spam</mtext>
      <eq></eq>
      <cn type="integer">1</cn>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="float">0.75</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P([\text{Spam}=1])=0.75
  </annotation>
 </semantics>
</math>

</li>
<li>Each of the 

<math display="inline" id="Bayesian_programming:59">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 forms 

<math display="inline" id="Bayesian_programming:60">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>W</mi>
     <mi>n</mi>
    </msub>
    <mo>∣</mo>
    <mtext>Spam</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-∣</ci>
     <mtext>Spam</mtext>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(W_{n}\mid\text{Spam})
  </annotation>
 </semantics>
</math>

 may be specified using <a href="Laplace_rule_of_succession" title="wikilink">Laplace rule of succession</a> (this is a pseudocounts-based <a href="N-gram#Smoothing_techniques" title="wikilink">smoothing technique</a> to counter the <a href="PPM_compression_algorithm" title="wikilink">zero-frequency problem</a> of words never-seen-before):
<ol>
<li>

<math display="inline" id="Bayesian_programming:61">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>W</mi>
     <mi>n</mi>
    </msub>
    <mo>∣</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mtext>Spam</mtext>
     <mo>=</mo>
     <mtext>false</mtext>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <msubsup>
      <mi>a</mi>
      <mi>f</mi>
      <mi>n</mi>
     </msubsup>
    </mrow>
    <mrow>
     <mn>2</mn>
     <mo>+</mo>
     <msub>
      <mi>a</mi>
      <mi>f</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-∣</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <mtext>Spam</mtext>
      <eq></eq>
      <mtext>false</mtext>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <ci>f</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(W_{n}\mid[\text{Spam}=\text{false}])=\frac{1+a^{n}_{f}}{2+a_{f}}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Bayesian_programming:62">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>W</mi>
     <mi>n</mi>
    </msub>
    <mo>∣</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mtext>Spam</mtext>
     <mo>=</mo>
     <mtext>true</mtext>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <msubsup>
      <mi>a</mi>
      <mi>t</mi>
      <mi>n</mi>
     </msubsup>
    </mrow>
    <mrow>
     <mn>2</mn>
     <mo>+</mo>
     <msub>
      <mi>a</mi>
      <mi>t</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-∣</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <mtext>Spam</mtext>
      <eq></eq>
      <mtext>true</mtext>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(W_{n}\mid[\text{Spam}=\text{true}])=\frac{1+a^{n}_{t}}{2+a_{t}}
  </annotation>
 </semantics>
</math>

</li>
</ol></li>
</ol>

<p>where 

<math display="inline" id="Bayesian_programming:63">
 <semantics>
  <msubsup>
   <mi>a</mi>
   <mi>f</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{n}_{f}
  </annotation>
 </semantics>
</math>

 stands for the number of appearances of the 

<math display="inline" id="Bayesian_programming:64">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{th}
  </annotation>
 </semantics>
</math>

 word in non-spam e-mails and 

<math display="inline" id="Bayesian_programming:65">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{f}
  </annotation>
 </semantics>
</math>

 stands for the total number of non-spam e-mails. Similarly, 

<math display="inline" id="Bayesian_programming:66">
 <semantics>
  <msubsup>
   <mi>a</mi>
   <mi>t</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>t</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}^{n}
  </annotation>
 </semantics>
</math>

 stands for the number of appearances of the 

<math display="inline" id="Bayesian_programming:67">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{th}
  </annotation>
 </semantics>
</math>

 word in spam e-mails and 

<math display="inline" id="Bayesian_programming:68">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}
  </annotation>
 </semantics>
</math>

 stands for the total number of spam e-mails.</p>
<h4 id="identification">Identification</h4>

<p>The 

<math display="inline" id="Bayesian_programming:69">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 forms 

<math display="inline" id="Bayesian_programming:70">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>W</mi>
     <mi>n</mi>
    </msub>
    <mo>∣</mo>
    <mtext>Spam</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-∣</ci>
     <mtext>Spam</mtext>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(W_{n}\mid\text{Spam})
  </annotation>
 </semantics>
</math>

 are not yet completely specified because the 

<math display="inline" id="Bayesian_programming:71">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>N</mi>
   </mrow>
   <mo>+</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>N</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2N+2
  </annotation>
 </semantics>
</math>

 parameters 

<math display="inline" id="Bayesian_programming:72">
 <semantics>
  <msubsup>
   <mi>a</mi>
   <mi>f</mi>
   <mrow>
    <mi>n</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <eq></eq>
     <ci>n</ci>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{f}^{n=0,\ldots,N-1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Bayesian_programming:73">
 <semantics>
  <msubsup>
   <mi>a</mi>
   <mi>t</mi>
   <mrow>
    <mi>n</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <eq></eq>
     <ci>n</ci>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}^{n=0,\ldots,N-1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Bayesian_programming:74">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{f}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bayesian_programming:75">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{t}
  </annotation>
 </semantics>
</math>

 have no values yet.</p>

<p>The identification of these parameters could be done either by batch processing a series of classified e-mails or by an incremental updating of the parameters using the user's classifications of the e-mails as they arrive.</p>

<p>Both methods could be combined: the system could start with initial standard values of these parameters issued from a generic database, then some incremental learning customizes the classifier to each individual user.</p>
<h4 id="question-1">Question</h4>

<p>The question asked to the program is: "what is the probability for a given text to be spam knowing which words appear and don't appear in this text?" It can be formalized by:</p>

<p>

<math display="block" id="Bayesian_programming:76">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>Spam</mtext>
    <mo>∣</mo>
    <msub>
     <mi>w</mi>
     <mn>0</mn>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>Spam</mtext>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">0</cn>
     </apply>
     <and></and>
     <ci>normal-⋯</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\text{Spam}\mid w_{0}\wedge\cdots\wedge w_{N-1})
  </annotation>
 </semantics>
</math>

</p>

<p>which can be computed as follows:</p>

<p>

<math display="inline" id="Bayesian_programming:77">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>Spam</mtext>
    <mo>∣</mo>
    <msub>
     <mi>w</mi>
     <mn>0</mn>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>Spam</mtext>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">0</cn>
     </apply>
     <and></and>
     <ci>normal-⋯</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(\text{Spam}\mid w_{0}\wedge\cdots\wedge w_{N-1})
  </annotation>
 </semantics>
</math>


</p>

<p>The denominator appears to be a <a href="Normalizing_constant" title="wikilink">normalization constant</a>. It is not necessary to compute it to decide if we are dealing with spam. For instance, an easy trick is to compute the ratio:</p>

<p>

<math display="inline" id="Bayesian_programming:78">
 <semantics>
  <mstyle displaystyle="true">
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mtext>Spam</mtext>
       <mo>=</mo>
       <mtext>true</mtext>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo>∣</mo>
      <msub>
       <mi>w</mi>
       <mn>0</mn>
      </msub>
      <mo>∧</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>∧</mo>
      <msub>
       <mi>w</mi>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mtext>Spam</mtext>
       <mo>=</mo>
       <mtext>false</mtext>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo>∣</mo>
      <msub>
       <mi>w</mi>
       <mn>0</mn>
      </msub>
      <mo>∧</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>∧</mo>
      <msub>
       <mi>w</mi>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mstyle>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <mtext>Spam</mtext>
       <eq></eq>
       <mtext>true</mtext>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-∣</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">0</cn>
      </apply>
      <and></and>
      <ci>normal-⋯</ci>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <mtext>Spam</mtext>
       <eq></eq>
       <mtext>false</mtext>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-∣</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">0</cn>
      </apply>
      <and></and>
      <ci>normal-⋯</ci>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\frac{P([\text{Spam}=\text{true}]\mid w_{0}\wedge\cdots\wedge w_{%
N-1})}{P([\text{Spam}=\text{false}]\mid w_{0}\wedge\cdots\wedge w_{N-1})}
  </annotation>
 </semantics>
</math>


</p>

<p>This computation is faster and easier because it requires only 

<math display="inline" id="Bayesian_programming:79">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2N
  </annotation>
 </semantics>
</math>

 products.</p>
<h4 id="bayesian-program">Bayesian program</h4>

<p>The Bayesian spam filter program is completely defined by:</p>

<p>

<math display="block" id="Bayesian_programming:80">
 <semantics>
  <mrow>
   <mi>Pr</mi>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>D</mi>
        <mi>s</mi>
        <mrow>
         <mo>{</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mi>S</mi>
             <mi>p</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>π</mi>
              <mo stretchy="false">)</mo>
             </mrow>
             <mrow>
              <mo>{</mo>
              <mtable displaystyle="true">
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mrow>
                   <mi>V</mi>
                   <mi>a</mi>
                  </mrow>
                  <mo>:</mo>
                  <mrow>
                   <mtext>Spam</mtext>
                   <mo>,</mo>
                   <msub>
                    <mi>W</mi>
                    <mn>0</mn>
                   </msub>
                   <mo>,</mo>
                   <mrow>
                    <msub>
                     <mi>W</mi>
                     <mn>1</mn>
                    </msub>
                    <mi mathvariant="normal">…</mi>
                    <msub>
                     <mi>W</mi>
                     <mrow>
                      <mi>N</mi>
                      <mo>-</mo>
                      <mn>1</mn>
                     </mrow>
                    </msub>
                   </mrow>
                  </mrow>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mrow>
                   <mi>D</mi>
                   <mi>c</mi>
                  </mrow>
                  <mo>:</mo>
                  <mrow>
                   <mo>{</mo>
                   <mtable displaystyle="true">
                    <mtr>
                     <mtd columnalign="left">
                      <mrow>
                       <mi>P</mi>
                       <mrow>
                        <mo stretchy="false">(</mo>
                        <mrow>
                         <mtext>Spam</mtext>
                         <mo>∧</mo>
                         <msub>
                          <mi>W</mi>
                          <mn>0</mn>
                         </msub>
                         <mo>∧</mo>
                         <mi mathvariant="normal">…</mi>
                         <mo>∧</mo>
                         <msub>
                          <mi>W</mi>
                          <mi>n</mi>
                         </msub>
                         <mo>∧</mo>
                         <mi mathvariant="normal">…</mi>
                         <mo>∧</mo>
                         <msub>
                          <mi>W</mi>
                          <mrow>
                           <mi>N</mi>
                           <mo>-</mo>
                           <mn>1</mn>
                          </mrow>
                         </msub>
                        </mrow>
                        <mo stretchy="false">)</mo>
                       </mrow>
                      </mrow>
                     </mtd>
                     <mtd></mtd>
                    </mtr>
                    <mtr>
                     <mtd columnalign="left">
                      <mrow>
                       <mo>=</mo>
                       <mi>P</mi>
                       <mrow>
                        <mo stretchy="false">(</mo>
                        <mtext>Spam</mtext>
                        <mo stretchy="false">)</mo>
                       </mrow>
                       <mstyle displaystyle="false">
                        <msubsup>
                         <mo largeop="true" symmetric="true">∏</mo>
                         <mrow>
                          <mi>n</mi>
                          <mo>=</mo>
                          <mn>0</mn>
                         </mrow>
                         <mrow>
                          <mi>N</mi>
                          <mo>-</mo>
                          <mn>1</mn>
                         </mrow>
                        </msubsup>
                       </mstyle>
                       <mi>P</mi>
                       <mrow>
                        <mo stretchy="false">(</mo>
                        <msub>
                         <mi>W</mi>
                         <mi>n</mi>
                        </msub>
                        <mo>∣</mo>
                        <mtext>Spam</mtext>
                        <mo stretchy="false">)</mo>
                       </mrow>
                      </mrow>
                     </mtd>
                     <mtd></mtd>
                    </mtr>
                   </mtable>
                  </mrow>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mrow>
                   <mi>F</mi>
                   <mi>o</mi>
                  </mrow>
                  <mo>:</mo>
                  <mrow>
                   <mo>{</mo>
                   <mtable displaystyle="true">
                    <mtr>
                     <mtd columnalign="left">
                      <mrow>
                       <mrow>
                        <mi>P</mi>
                        <mrow>
                         <mo stretchy="false">(</mo>
                         <mtext>Spam</mtext>
                         <mo stretchy="false">)</mo>
                        </mrow>
                       </mrow>
                       <mo>:</mo>
                       <mrow>
                        <mo>{</mo>
                        <mtable displaystyle="true">
                         <mtr>
                          <mtd columnalign="left">
                           <mrow>
                            <mi>P</mi>
                            <mrow>
                             <mo stretchy="false">(</mo>
                             <mrow>
                              <mo stretchy="false">[</mo>
                              <mtext>Spam</mtext>
                              <mo>=</mo>
                              <mtext>false</mtext>
                              <mo stretchy="false">]</mo>
                             </mrow>
                             <mo stretchy="false">)</mo>
                            </mrow>
                            <mo>=</mo>
                            <mn>0.25</mn>
                           </mrow>
                          </mtd>
                          <mtd></mtd>
                         </mtr>
                         <mtr>
                          <mtd columnalign="left">
                           <mrow>
                            <mi>P</mi>
                            <mrow>
                             <mo stretchy="false">(</mo>
                             <mrow>
                              <mo stretchy="false">[</mo>
                              <mtext>Spam</mtext>
                              <mo>=</mo>
                              <mtext>true</mtext>
                              <mo stretchy="false">]</mo>
                             </mrow>
                             <mo stretchy="false">)</mo>
                            </mrow>
                            <mo>=</mo>
                            <mn>0.75</mn>
                           </mrow>
                          </mtd>
                          <mtd></mtd>
                         </mtr>
                        </mtable>
                       </mrow>
                      </mrow>
                     </mtd>
                     <mtd></mtd>
                    </mtr>
                    <mtr>
                     <mtd columnalign="left">
                      <mrow>
                       <mi>P</mi>
                       <mrow>
                        <mo stretchy="false">(</mo>
                        <msub>
                         <mi>W</mi>
                         <mi>n</mi>
                        </msub>
                        <mo>∣</mo>
                        <mtext>Spam</mtext>
                        <mo stretchy="false">)</mo>
                       </mrow>
                       <mo>:</mo>
                       <mrow>
                        <mo>{</mo>
                        <mtable displaystyle="true">
                         <mtr>
                          <mtd columnalign="left">
                           <mrow>
                            <mi>P</mi>
                            <mrow>
                             <mo stretchy="false">(</mo>
                             <msub>
                              <mi>W</mi>
                              <mi>n</mi>
                             </msub>
                             <mo>∣</mo>
                             <mrow>
                              <mo stretchy="false">[</mo>
                              <mtext>Spam</mtext>
                              <mo>=</mo>
                              <mtext>false</mtext>
                              <mo stretchy="false">]</mo>
                             </mrow>
                             <mo stretchy="false">)</mo>
                            </mrow>
                           </mrow>
                          </mtd>
                          <mtd></mtd>
                         </mtr>
                         <mtr>
                          <mtd columnalign="left">
                           <mrow>
                            <mi></mi>
                            <mo>=</mo>
                            <mstyle displaystyle="false">
                             <mfrac>
                              <mrow>
                               <mn>1</mn>
                               <mo>+</mo>
                               <msubsup>
                                <mi>a</mi>
                                <mi>f</mi>
                                <mi>n</mi>
                               </msubsup>
                              </mrow>
                              <mrow>
                               <mn>2</mn>
                               <mo>+</mo>
                               <msub>
                                <mi>a</mi>
                                <mi>f</mi>
                               </msub>
                              </mrow>
                             </mfrac>
                            </mstyle>
                           </mrow>
                          </mtd>
                          <mtd></mtd>
                         </mtr>
                         <mtr>
                          <mtd columnalign="left">
                           <mrow>
                            <mi>P</mi>
                            <mrow>
                             <mo stretchy="false">(</mo>
                             <msub>
                              <mi>W</mi>
                              <mi>n</mi>
                             </msub>
                             <mo>∣</mo>
                             <mrow>
                              <mo stretchy="false">[</mo>
                              <mtext>Spam</mtext>
                              <mo>=</mo>
                              <mtext>true</mtext>
                              <mo stretchy="false">]</mo>
                             </mrow>
                             <mo stretchy="false">)</mo>
                            </mrow>
                           </mrow>
                          </mtd>
                          <mtd></mtd>
                         </mtr>
                         <mtr>
                          <mtd columnalign="left">
                           <mrow>
                            <mi></mi>
                            <mo>=</mo>
                            <mstyle displaystyle="false">
                             <mfrac>
                              <mrow>
                               <mn>1</mn>
                               <mo>+</mo>
                               <msubsup>
                                <mi>a</mi>
                                <mi>t</mi>
                                <mi>n</mi>
                               </msubsup>
                              </mrow>
                              <mrow>
                               <mn>2</mn>
                               <mo>+</mo>
                               <msub>
                                <mi>a</mi>
                                <mi>t</mi>
                               </msub>
                              </mrow>
                             </mfrac>
                            </mstyle>
                           </mrow>
                          </mtd>
                          <mtd></mtd>
                         </mtr>
                        </mtable>
                       </mrow>
                      </mrow>
                     </mtd>
                     <mtd></mtd>
                    </mtr>
                   </mtable>
                  </mrow>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
              </mtable>
             </mrow>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mtext>Identification (based on</mtext>
             <mi>δ</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
         </mtable>
        </mrow>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>Q</mi>
        <mi>u</mi>
        <mo>:</mo>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mtext>Spam</mtext>
         <mo>∣</mo>
         <msub>
          <mi>w</mi>
          <mn>0</mn>
         </msub>
         <mo>∧</mo>
         <mi mathvariant="normal">…</mi>
         <mo>∧</mo>
         <msub>
          <mi>w</mi>
          <mi>n</mi>
         </msub>
         <mo>∧</mo>
         <mi mathvariant="normal">…</mi>
         <mo>∧</mo>
         <msub>
          <mi>w</mi>
          <mrow>
           <mi>N</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Pr</ci>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>s</ci>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>p</ci>
        <ci>π</ci>
        <apply>
         <csymbol cd="latexml">cases</csymbol>
         <apply>
          <ci>normal-:</ci>
          <apply>
           <times></times>
           <ci>V</ci>
           <ci>a</ci>
          </apply>
          <list>
           <mtext>Spam</mtext>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>W</ci>
            <cn type="integer">0</cn>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>W</ci>
             <cn type="integer">1</cn>
            </apply>
            <ci>normal-…</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>W</ci>
             <apply>
              <minus></minus>
              <ci>N</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
           </apply>
          </list>
         </apply>
         <mtext>otherwise</mtext>
         <apply>
          <ci>normal-:</ci>
          <apply>
           <times></times>
           <ci>D</ci>
           <ci>c</ci>
          </apply>
          <apply>
           <csymbol cd="latexml">cases</csymbol>
           <apply>
            <times></times>
            <ci>P</ci>
            <apply>
             <and></and>
             <mtext>Spam</mtext>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>W</ci>
              <cn type="integer">0</cn>
             </apply>
             <ci>normal-…</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>W</ci>
              <ci>n</ci>
             </apply>
             <ci>normal-…</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>W</ci>
              <apply>
               <minus></minus>
               <ci>N</ci>
               <cn type="integer">1</cn>
              </apply>
             </apply>
            </apply>
           </apply>
           <mtext>otherwise</mtext>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <eq></eq>
            <csymbol cd="unknown">P</csymbol>
            <cerror>
             <csymbol cd="ambiguous">fragments</csymbol>
             <ci>normal-(</ci>
             <mtext>Spam</mtext>
             <ci>normal-)</ci>
            </cerror>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <csymbol cd="latexml">product</csymbol>
              <apply>
               <eq></eq>
               <ci>n</ci>
               <cn type="integer">0</cn>
              </apply>
             </apply>
             <apply>
              <minus></minus>
              <ci>N</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <csymbol cd="unknown">P</csymbol>
            <cerror>
             <csymbol cd="ambiguous">fragments</csymbol>
             <ci>normal-(</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>W</ci>
              <ci>n</ci>
             </apply>
             <ci>normal-∣</ci>
             <mtext>Spam</mtext>
             <ci>normal-)</ci>
            </cerror>
           </cerror>
           <mtext>otherwise</mtext>
          </apply>
         </apply>
         <mtext>otherwise</mtext>
         <apply>
          <ci>normal-:</ci>
          <apply>
           <times></times>
           <ci>F</ci>
           <ci>o</ci>
          </apply>
          <apply>
           <csymbol cd="latexml">cases</csymbol>
           <apply>
            <ci>normal-:</ci>
            <apply>
             <times></times>
             <ci>P</ci>
             <mtext>Spam</mtext>
            </apply>
            <apply>
             <csymbol cd="latexml">cases</csymbol>
             <cerror>
              <csymbol cd="ambiguous">fragments</csymbol>
              <csymbol cd="unknown">P</csymbol>
              <cerror>
               <csymbol cd="ambiguous">fragments</csymbol>
               <ci>normal-(</ci>
               <cerror>
                <csymbol cd="ambiguous">fragments</csymbol>
                <ci>normal-[</ci>
                <mtext>Spam</mtext>
                <eq></eq>
                <mtext>false</mtext>
                <ci>normal-]</ci>
               </cerror>
               <ci>normal-)</ci>
              </cerror>
              <eq></eq>
              <cn type="float">0.25</cn>
             </cerror>
             <mtext>otherwise</mtext>
             <cerror>
              <csymbol cd="ambiguous">fragments</csymbol>
              <csymbol cd="unknown">P</csymbol>
              <cerror>
               <csymbol cd="ambiguous">fragments</csymbol>
               <ci>normal-(</ci>
               <cerror>
                <csymbol cd="ambiguous">fragments</csymbol>
                <ci>normal-[</ci>
                <mtext>Spam</mtext>
                <eq></eq>
                <mtext>true</mtext>
                <ci>normal-]</ci>
               </cerror>
               <ci>normal-)</ci>
              </cerror>
              <eq></eq>
              <cn type="float">0.75</cn>
             </cerror>
             <mtext>otherwise</mtext>
            </apply>
           </apply>
           <mtext>otherwise</mtext>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <csymbol cd="unknown">P</csymbol>
            <cerror>
             <csymbol cd="ambiguous">fragments</csymbol>
             <ci>normal-(</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>W</ci>
              <ci>n</ci>
             </apply>
             <ci>normal-∣</ci>
             <mtext>Spam</mtext>
             <ci>normal-)</ci>
            </cerror>
            <ci>normal-:</ci>
            <apply>
             <csymbol cd="latexml">cases</csymbol>
             <cerror>
              <csymbol cd="ambiguous">fragments</csymbol>
              <csymbol cd="unknown">P</csymbol>
              <cerror>
               <csymbol cd="ambiguous">fragments</csymbol>
               <ci>normal-(</ci>
               <apply>
                <csymbol cd="ambiguous">subscript</csymbol>
                <ci>W</ci>
                <ci>n</ci>
               </apply>
               <ci>normal-∣</ci>
               <cerror>
                <csymbol cd="ambiguous">fragments</csymbol>
                <ci>normal-[</ci>
                <mtext>Spam</mtext>
                <eq></eq>
                <mtext>false</mtext>
                <ci>normal-]</ci>
               </cerror>
               <ci>normal-)</ci>
              </cerror>
             </cerror>
             <mtext>otherwise</mtext>
             <apply>
              <eq></eq>
              <csymbol cd="latexml">absent</csymbol>
              <apply>
               <divide></divide>
               <apply>
                <plus></plus>
                <cn type="integer">1</cn>
                <apply>
                 <csymbol cd="ambiguous">subscript</csymbol>
                 <apply>
                  <csymbol cd="ambiguous">superscript</csymbol>
                  <ci>a</ci>
                  <ci>n</ci>
                 </apply>
                 <ci>f</ci>
                </apply>
               </apply>
               <apply>
                <plus></plus>
                <cn type="integer">2</cn>
                <apply>
                 <csymbol cd="ambiguous">subscript</csymbol>
                 <ci>a</ci>
                 <ci>f</ci>
                </apply>
               </apply>
              </apply>
             </apply>
             <mtext>otherwise</mtext>
             <cerror>
              <csymbol cd="ambiguous">fragments</csymbol>
              <csymbol cd="unknown">P</csymbol>
              <cerror>
               <csymbol cd="ambiguous">fragments</csymbol>
               <ci>normal-(</ci>
               <apply>
                <csymbol cd="ambiguous">subscript</csymbol>
                <ci>W</ci>
                <ci>n</ci>
               </apply>
               <ci>normal-∣</ci>
               <cerror>
                <csymbol cd="ambiguous">fragments</csymbol>
                <ci>normal-[</ci>
                <mtext>Spam</mtext>
                <eq></eq>
                <mtext>true</mtext>
                <ci>normal-]</ci>
               </cerror>
               <ci>normal-)</ci>
              </cerror>
             </cerror>
             <mtext>otherwise</mtext>
             <apply>
              <eq></eq>
              <csymbol cd="latexml">absent</csymbol>
              <apply>
               <divide></divide>
               <apply>
                <plus></plus>
                <cn type="integer">1</cn>
                <apply>
                 <csymbol cd="ambiguous">subscript</csymbol>
                 <apply>
                  <csymbol cd="ambiguous">superscript</csymbol>
                  <ci>a</ci>
                  <ci>n</ci>
                 </apply>
                 <ci>t</ci>
                </apply>
               </apply>
               <apply>
                <plus></plus>
                <cn type="integer">2</cn>
                <apply>
                 <csymbol cd="ambiguous">subscript</csymbol>
                 <ci>a</ci>
                 <ci>t</ci>
                </apply>
               </apply>
              </apply>
             </apply>
             <mtext>otherwise</mtext>
            </apply>
           </cerror>
           <mtext>otherwise</mtext>
          </apply>
         </apply>
         <mtext>otherwise</mtext>
        </apply>
       </apply>
       <mtext>otherwise</mtext>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <mtext>Identification (based on</mtext>
        <csymbol cd="unknown">δ</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <mtext>otherwise</mtext>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Q</csymbol>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <mtext>Spam</mtext>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">0</cn>
       </apply>
       <and></and>
       <ci>normal-…</ci>
       <and></and>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>n</ci>
       </apply>
       <and></and>
       <ci>normal-…</ci>
       <and></and>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\begin{cases}Ds\begin{cases}Sp(\pi)\begin{cases}Va:\text{Spam},W_{0},W_{1}%
\ldots W_{N-1}\\
Dc:\begin{cases}P(\text{Spam}\land W_{0}\land\ldots\land W_{n}\land\ldots\land
W%
_{N-1})\\
=P(\text{Spam})\prod_{n=0}^{N-1}P(W_{n}\mid\text{Spam})\end{cases}\\
Fo:\begin{cases}P(\text{Spam}):\begin{cases}P([\text{Spam}=\text{false}])=0.25%
\\
P([\text{Spam}=\text{true}])=0.75\end{cases}\\
P(W_{n}\mid\text{Spam}):\begin{cases}P(W_{n}\mid[\text{Spam}=\text{false}])\\
=\frac{1+a^{n}_{f}}{2+a_{f}}\\
P(W_{n}\mid[\text{Spam}=\text{true}])\\
=\frac{1+a^{n}_{t}}{2+a_{t}}\end{cases}\\
\end{cases}\\
\end{cases}\\
\text{Identification (based on }\delta)\end{cases}\\
Qu:P(\text{Spam}\mid w_{0}\land\ldots\land w_{n}\land\ldots\land w_{N-1})\end{cases}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="bayesian-filter-kalman-filter-and-hidden-markov-model">Bayesian filter, Kalman filter and hidden Markov model</h3>

<p>Bayesian filters (often called <a href="Recursive_Bayesian_estimation" title="wikilink">Recursive Bayesian estimation</a>) are generic probabilistic models for time evolving processes. Numerous models are particular instances of this generic approach, for instance: the <a href="Kalman_filter" title="wikilink">Kalman filter</a> or the <a href="Hidden_Markov_model" title="wikilink">Hidden Markov model</a>.</p>
<h4 id="variables-1">Variables</h4>
<ul>
<li>Variables 

<math display="inline" id="Bayesian_programming:81">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mn>0</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>S</mi>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>T</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{0},\ldots,S^{T}
  </annotation>
 </semantics>
</math>

 are a time series of state variables considered to be on a time horizon ranging from 

<math display="inline" id="Bayesian_programming:82">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 to 

<math display="inline" id="Bayesian_programming:83">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</li>
<li>Variables 

<math display="inline" id="Bayesian_programming:84">
 <semantics>
  <mrow>
   <msup>
    <mi>O</mi>
    <mn>0</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>O</mi>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>O</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>O</ci>
     <ci>T</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O^{0},\ldots,O^{T}
  </annotation>
 </semantics>
</math>

 are a time series of observation variables on the same horizon.</li>
</ul>
<h4 id="decomposition-2">Decomposition</h4>

<p>The decomposition is based:</p>
<ul>
<li>on 

<math display="inline" id="Bayesian_programming:85">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>S</mi>
     <mi>t</mi>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S^{t}\mid S^{t-1})
  </annotation>
 </semantics>
</math>

, called the system model, transition model or dynamic model, which formalizes the transition from the state at time 

<math display="inline" id="Bayesian_programming:86">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t-1
  </annotation>
 </semantics>
</math>

 to the state at time 

<math display="inline" id="Bayesian_programming:87">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

;</li>
<li>on 

<math display="inline" id="Bayesian_programming:88">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>O</mi>
     <mi>t</mi>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>S</mi>
     <mi>t</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(O^{t}\mid S^{t})
  </annotation>
 </semantics>
</math>

, called the observation model, which expresses what can be observed at time 

<math display="inline" id="Bayesian_programming:89">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 when the system is in state 

<math display="inline" id="Bayesian_programming:90">
 <semantics>
  <msup>
   <mi>S</mi>
   <mi>t</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{t}
  </annotation>
 </semantics>
</math>

;</li>
<li>on an initial state at time 

<math display="inline" id="Bayesian_programming:91">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>



<math display="block" id="Bayesian_programming:92">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>S</mi>
      <mn>0</mn>
     </msup>
     <mo>∧</mo>
     <msup>
      <mi>O</mi>
      <mn>0</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S^{0}\wedge O^{0})
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h4 id="parametrical-forms">Parametrical forms</h4>

<p>The parametrical forms are not constrained and different choices lead to different well-known models: see Kalman filters and Hidden Markov models just below.</p>
<h4 id="question-2">Question</h4>

<p>The question usually asked of these models is 

<math display="inline" id="Bayesian_programming:93">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mi>k</mi>
     </mrow>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>O</mi>
     <mn>0</mn>
    </msup>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msup>
     <mi>O</mi>
     <mi>t</mi>
    </msup>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <cn type="integer">0</cn>
     </apply>
     <and></and>
     <ci>normal-⋯</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(S^{t+k}\mid O^{0}\wedge\cdots\wedge O^{t}\right)
  </annotation>
 </semantics>
</math>

: what is the probability distribution for the state at time 

<math display="inline" id="Bayesian_programming:94">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>+</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>t</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t+k
  </annotation>
 </semantics>
</math>

 knowing the observations from instant 

<math display="inline" id="Bayesian_programming:95">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 to 

<math display="inline" id="Bayesian_programming:96">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

?</p>

<p>The most common case is Bayesian filtering where 

<math display="inline" id="Bayesian_programming:97">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=0
  </annotation>
 </semantics>
</math>

, which means that one searches for the present state, knowing the past observations.</p>

<p>However it is also possible to do a prediction 

<math display="inline" id="Bayesian_programming:98">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>k</mi>
    <mo>></mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (k>0)
  </annotation>
 </semantics>
</math>

, where one tries to extrapolate a future state from past observations, or to do smoothing 

<math display="inline" id="Bayesian_programming:99">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>k</mi>
    <mo><</mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (k<0)
  </annotation>
 </semantics>
</math>

, where one tries to recover a past state from observations made either before or after that instant.</p>

<p>Some more complicated questions may also be asked as shown below in the HMM section.</p>

<p>Bayesian filters 

<math display="inline" id="Bayesian_programming:100">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (k=0)
  </annotation>
 </semantics>
</math>

 have a very interesting recursive property, which contributes greatly to their attractiveness. 

<math display="inline" id="Bayesian_programming:101">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>S</mi>
     <mi>t</mi>
    </msup>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>O</mi>
     <mn>0</mn>
    </msup>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msup>
     <mi>O</mi>
     <mi>t</mi>
    </msup>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <cn type="integer">0</cn>
     </apply>
     <and></and>
     <ci>normal-⋯</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(S^{t}|O^{0}\wedge\cdots\wedge O^{t}\right)
  </annotation>
 </semantics>
</math>

 may be computed simply from 

<math display="inline" id="Bayesian_programming:102">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>t</mi>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>O</mi>
     <mn>0</mn>
    </msup>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msup>
     <mi>O</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <cn type="integer">0</cn>
     </apply>
     <and></and>
     <ci>normal-⋯</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(S^{t1}\mid O^{0}\wedge\cdots\wedge O^{t-1}\right)
  </annotation>
 </semantics>
</math>

 with the following formula:</p>

<p>

<math display="block" id="Bayesian_programming:103">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo>(</mo>
       <msup>
        <mi>S</mi>
        <mi>t</mi>
       </msup>
       <mo stretchy="false">|</mo>
       <msup>
        <mi>O</mi>
        <mn>0</mn>
       </msup>
       <mo>∧</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>∧</mo>
       <msup>
        <mi>O</mi>
        <mi>t</mi>
       </msup>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo>(</mo>
       <msup>
        <mi>O</mi>
        <mi>t</mi>
       </msup>
       <mo stretchy="false">|</mo>
       <msup>
        <mi>S</mi>
        <mi>t</mi>
       </msup>
       <mo>)</mo>
      </mrow>
      <mo>×</mo>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <msup>
        <mi>S</mi>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </munder>
      <mrow>
       <mo>[</mo>
       <mi>P</mi>
       <mrow>
        <mo>(</mo>
        <msup>
         <mi>S</mi>
         <mi>t</mi>
        </msup>
        <mo stretchy="false">|</mo>
        <msup>
         <mi>S</mi>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mo>)</mo>
       </mrow>
       <mo>×</mo>
       <mi>P</mi>
       <mrow>
        <mo>(</mo>
        <msup>
         <mi>S</mi>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mo stretchy="false">|</mo>
        <msup>
         <mi>O</mi>
         <mn>0</mn>
        </msup>
        <mo>∧</mo>
        <mi mathvariant="normal">⋯</mi>
        <mo>∧</mo>
        <msup>
         <mi>O</mi>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <mo>)</mo>
       </mrow>
       <mo>]</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>S</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>O</ci>
        <cn type="integer">0</cn>
       </apply>
       <and></and>
       <ci>normal-⋯</ci>
       <and></and>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>O</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>O</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>S</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>S</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">P</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <ci>t</ci>
        </apply>
        <ci>normal-|</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <times></times>
       <csymbol cd="unknown">P</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-|</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>O</ci>
         <cn type="integer">0</cn>
        </apply>
        <and></and>
        <ci>normal-⋯</ci>
        <and></and>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>O</ci>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-]</ci>
      </cerror>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{ll}&P\left(S^{t}|O^{0}\wedge\cdots\wedge O^{t}\right)\\
=&P\left(O^{t}|S^{t}\right)\times\sum_{S^{t-1}}\left[P\left(S^{t}|S^{t-1}%
\right)\times P\left(S^{t-1}|O^{0}\wedge\cdots\wedge O^{t-1}\right)\right]\end%
{array}
  </annotation>
 </semantics>
</math>

</p>

<p>Another interesting point of view for this equation is to consider that there are two phases: a prediction phase and an estimation phase:</p>
<ul>
<li>During the prediction phase, the state is predicted using the dynamic model and the estimation of the state at the previous moment:</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{array}{ll}</p>

<p><code>&amp; P\left(S^{t}|O^{0}\wedge\cdots\wedge O^{t-1}\right)\\</code></p>

<p>= &amp; \sum_{S^{t-1}}\left[P\left(S^{t}|S^{t-1}\right)\times P\left(S^{t-1}|O^{0}\wedge\cdots\wedge O^{t-1}\right)\right]\end{array} </p>
<ul>
<li>During the estimation phase, the prediction is either confirmed or invalidated using the last observation:</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{align}</p>

<p><code>&amp; P\left(S^{t}\mid O^{0}\wedge\cdots\wedge O^{t}\right)\\</code></p>

<p>={} &amp; P\left(O^{t}\mid S^{t}\right)\times P\left(S^{t}|O^{0}\wedge\cdots\wedge O^{t-1}\right) \end{align} </p>
<h4 id="bayesian-program-1">Bayesian program</h4>

<p>

<math display="block" id="Bayesian_programming:104">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>D</mi>
        <mi>s</mi>
        <mrow>
         <mo>{</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mi>S</mi>
             <mi>p</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>π</mi>
              <mo stretchy="false">)</mo>
             </mrow>
             <mrow>
              <mo>{</mo>
              <mtable displaystyle="true">
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mrow>
                   <mi>V</mi>
                   <mi>a</mi>
                  </mrow>
                  <mo>:</mo>
                  <mi></mi>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <msup>
                   <mi>S</mi>
                   <mn>0</mn>
                  </msup>
                  <mo>,</mo>
                  <mi mathvariant="normal">⋯</mi>
                  <mo>,</mo>
                  <msup>
                   <mi>S</mi>
                   <mi>T</mi>
                  </msup>
                  <mo>,</mo>
                  <msup>
                   <mi>O</mi>
                   <mn>0</mn>
                  </msup>
                  <mo>,</mo>
                  <mi mathvariant="normal">⋯</mi>
                  <mo>,</mo>
                  <msup>
                   <mi>O</mi>
                   <mi>T</mi>
                  </msup>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mrow>
                   <mi>D</mi>
                   <mi>c</mi>
                  </mrow>
                  <mo>:</mo>
                  <mi></mi>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mo>{</mo>
                  <mtable displaystyle="true">
                   <mtr>
                    <mtd columnalign="left">
                     <mi></mi>
                    </mtd>
                    <mtd columnalign="left">
                     <mrow>
                      <mi>P</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>S</mi>
                        <mn>0</mn>
                       </msup>
                       <mo>∧</mo>
                       <mi mathvariant="normal">⋯</mi>
                       <mo>∧</mo>
                       <msup>
                        <mi>S</mi>
                        <mi>T</mi>
                       </msup>
                       <mo>∧</mo>
                       <msup>
                        <mi>O</mi>
                        <mn>0</mn>
                       </msup>
                       <mo>∧</mo>
                       <mi mathvariant="normal">⋯</mi>
                       <mo>∧</mo>
                       <msup>
                        <mi>O</mi>
                        <mi>T</mi>
                       </msup>
                       <mo stretchy="false">|</mo>
                       <mi>π</mi>
                       <mo>)</mo>
                      </mrow>
                     </mrow>
                    </mtd>
                   </mtr>
                   <mtr>
                    <mtd columnalign="left">
                     <mo>=</mo>
                    </mtd>
                    <mtd columnalign="left">
                     <mrow>
                      <mi>P</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>S</mi>
                        <mn>0</mn>
                       </msup>
                       <mo>∧</mo>
                       <msup>
                        <mi>O</mi>
                        <mn>0</mn>
                       </msup>
                       <mo>)</mo>
                      </mrow>
                      <mo>×</mo>
                      <mstyle displaystyle="false">
                       <msubsup>
                        <mo largeop="true" symmetric="true">∏</mo>
                        <mrow>
                         <mi>t</mi>
                         <mo>=</mo>
                         <mn>1</mn>
                        </mrow>
                        <mi>T</mi>
                       </msubsup>
                      </mstyle>
                      <mrow>
                       <mo>[</mo>
                       <mi>P</mi>
                       <mrow>
                        <mo>(</mo>
                        <msup>
                         <mi>S</mi>
                         <mi>t</mi>
                        </msup>
                        <mo stretchy="false">|</mo>
                        <msup>
                         <mi>S</mi>
                         <mrow>
                          <mi>t</mi>
                          <mo>-</mo>
                          <mn>1</mn>
                         </mrow>
                        </msup>
                        <mo>)</mo>
                       </mrow>
                       <mo>×</mo>
                       <mi>P</mi>
                       <mrow>
                        <mo>(</mo>
                        <msup>
                         <mi>O</mi>
                         <mi>t</mi>
                        </msup>
                        <mo stretchy="false">|</mo>
                        <msup>
                         <mi>S</mi>
                         <mi>t</mi>
                        </msup>
                        <mo>)</mo>
                       </mrow>
                       <mo>]</mo>
                      </mrow>
                     </mrow>
                    </mtd>
                   </mtr>
                  </mtable>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mrow>
                   <mi>F</mi>
                   <mi>o</mi>
                  </mrow>
                  <mo>:</mo>
                  <mi></mi>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mo>{</mo>
                  <mtable displaystyle="true">
                   <mtr>
                    <mtd columnalign="left">
                     <mrow>
                      <mi>P</mi>
                      <mrow>
                       <mo>(</mo>
                       <mrow>
                        <msup>
                         <mi>S</mi>
                         <mn>0</mn>
                        </msup>
                        <mo>∧</mo>
                        <msup>
                         <mi>O</mi>
                         <mn>0</mn>
                        </msup>
                       </mrow>
                       <mo>)</mo>
                      </mrow>
                     </mrow>
                    </mtd>
                    <mtd></mtd>
                   </mtr>
                   <mtr>
                    <mtd columnalign="left">
                     <mrow>
                      <mi>P</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>S</mi>
                        <mi>t</mi>
                       </msup>
                       <mo stretchy="false">|</mo>
                       <msup>
                        <mi>S</mi>
                        <mrow>
                         <mi>t</mi>
                         <mo>-</mo>
                         <mn>1</mn>
                        </mrow>
                       </msup>
                       <mo>)</mo>
                      </mrow>
                     </mrow>
                    </mtd>
                    <mtd></mtd>
                   </mtr>
                   <mtr>
                    <mtd columnalign="left">
                     <mrow>
                      <mi>P</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>O</mi>
                        <mi>t</mi>
                       </msup>
                       <mo stretchy="false">|</mo>
                       <msup>
                        <mi>S</mi>
                        <mi>t</mi>
                       </msup>
                       <mo>)</mo>
                      </mrow>
                     </mrow>
                    </mtd>
                    <mtd></mtd>
                   </mtr>
                  </mtable>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
              </mtable>
             </mrow>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mi>I</mi>
             <mi>d</mi>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
         </mtable>
        </mrow>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>Q</mi>
         <mi>u</mi>
        </mrow>
        <mo>:</mo>
        <mi></mi>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo>{</mo>
        <mtable displaystyle="true">
         <mtr>
          <mtd columnalign="left">
           <mtable displaystyle="true">
            <mtr>
             <mtd columnalign="left">
              <mrow>
               <mi>P</mi>
               <mrow>
                <mo>(</mo>
                <msup>
                 <mi>S</mi>
                 <mrow>
                  <mi>t</mi>
                  <mo>+</mo>
                  <mi>k</mi>
                 </mrow>
                </msup>
                <mo stretchy="false">|</mo>
                <msup>
                 <mi>O</mi>
                 <mn>0</mn>
                </msup>
                <mo>∧</mo>
                <mi mathvariant="normal">⋯</mi>
                <mo>∧</mo>
                <msup>
                 <mi>O</mi>
                 <mi>t</mi>
                </msup>
                <mo>)</mo>
               </mrow>
              </mrow>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="left">
              <mrow>
               <mrow>
                <mo>(</mo>
                <mi>k</mi>
                <mo>=</mo>
                <mn>0</mn>
                <mo>)</mo>
               </mrow>
               <mo>≡</mo>
               <mtext>Filtering</mtext>
              </mrow>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="left">
              <mrow>
               <mrow>
                <mo>(</mo>
                <mi>k</mi>
                <mo>></mo>
                <mn>0</mn>
                <mo>)</mo>
               </mrow>
               <mo>≡</mo>
               <mtext>Prediction</mtext>
              </mrow>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="left">
              <mrow>
               <mrow>
                <mo>(</mo>
                <mi>k</mi>
                <mo><</mo>
                <mn>0</mn>
                <mo>)</mo>
               </mrow>
               <mo>≡</mo>
               <mtext>Smoothing</mtext>
              </mrow>
             </mtd>
            </mtr>
           </mtable>
          </mtd>
          <mtd></mtd>
         </mtr>
        </mtable>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>r</ci>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>s</ci>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>p</ci>
        <ci>π</ci>
        <apply>
         <csymbol cd="latexml">cases</csymbol>
         <apply>
          <ci>normal-:</ci>
          <apply>
           <times></times>
           <ci>V</ci>
           <ci>a</ci>
          </apply>
          <csymbol cd="latexml">absent</csymbol>
         </apply>
         <mtext>otherwise</mtext>
         <list>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>S</ci>
           <cn type="integer">0</cn>
          </apply>
          <ci>normal-⋯</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>S</ci>
           <ci>T</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>O</ci>
           <cn type="integer">0</cn>
          </apply>
          <ci>normal-⋯</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>O</ci>
           <ci>T</ci>
          </apply>
         </list>
         <mtext>otherwise</mtext>
         <apply>
          <ci>normal-:</ci>
          <apply>
           <times></times>
           <ci>D</ci>
           <ci>c</ci>
          </apply>
          <csymbol cd="latexml">absent</csymbol>
         </apply>
         <mtext>otherwise</mtext>
         <apply>
          <csymbol cd="latexml">cases</csymbol>
          <csymbol cd="latexml">absent</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <csymbol cd="unknown">P</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <cn type="integer">0</cn>
            </apply>
            <and></and>
            <ci>normal-⋯</ci>
            <and></and>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <ci>T</ci>
            </apply>
            <and></and>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>O</ci>
             <cn type="integer">0</cn>
            </apply>
            <and></and>
            <ci>normal-⋯</ci>
            <and></and>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>O</ci>
             <ci>T</ci>
            </apply>
            <ci>normal-|</ci>
            <csymbol cd="unknown">π</csymbol>
            <ci>normal-)</ci>
           </cerror>
          </cerror>
          <eq></eq>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <csymbol cd="unknown">P</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <cn type="integer">0</cn>
            </apply>
            <and></and>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>O</ci>
             <cn type="integer">0</cn>
            </apply>
            <ci>normal-)</ci>
           </cerror>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <csymbol cd="latexml">product</csymbol>
             <apply>
              <eq></eq>
              <ci>t</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <ci>T</ci>
           </apply>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-[</ci>
            <csymbol cd="unknown">P</csymbol>
            <cerror>
             <csymbol cd="ambiguous">fragments</csymbol>
             <ci>normal-(</ci>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <ci>S</ci>
              <ci>t</ci>
             </apply>
             <ci>normal-|</ci>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <ci>S</ci>
              <apply>
               <minus></minus>
               <ci>t</ci>
               <cn type="integer">1</cn>
              </apply>
             </apply>
             <ci>normal-)</ci>
            </cerror>
            <times></times>
            <csymbol cd="unknown">P</csymbol>
            <cerror>
             <csymbol cd="ambiguous">fragments</csymbol>
             <ci>normal-(</ci>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <ci>O</ci>
              <ci>t</ci>
             </apply>
             <ci>normal-|</ci>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <ci>S</ci>
              <ci>t</ci>
             </apply>
             <ci>normal-)</ci>
            </cerror>
            <ci>normal-]</ci>
           </cerror>
          </cerror>
         </apply>
         <mtext>otherwise</mtext>
         <apply>
          <ci>normal-:</ci>
          <apply>
           <times></times>
           <ci>F</ci>
           <ci>o</ci>
          </apply>
          <csymbol cd="latexml">absent</csymbol>
         </apply>
         <mtext>otherwise</mtext>
         <apply>
          <csymbol cd="latexml">cases</csymbol>
          <apply>
           <times></times>
           <ci>P</ci>
           <apply>
            <and></and>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <cn type="integer">0</cn>
            </apply>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>O</ci>
             <cn type="integer">0</cn>
            </apply>
           </apply>
          </apply>
          <mtext>otherwise</mtext>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <csymbol cd="unknown">P</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <ci>t</ci>
            </apply>
            <ci>normal-|</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <apply>
              <minus></minus>
              <ci>t</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <ci>normal-)</ci>
           </cerror>
          </cerror>
          <mtext>otherwise</mtext>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <csymbol cd="unknown">P</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>O</ci>
             <ci>t</ci>
            </apply>
            <ci>normal-|</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <ci>t</ci>
            </apply>
            <ci>normal-)</ci>
           </cerror>
          </cerror>
          <mtext>otherwise</mtext>
         </apply>
         <mtext>otherwise</mtext>
        </apply>
       </apply>
       <mtext>otherwise</mtext>
       <apply>
        <times></times>
        <ci>I</ci>
        <ci>d</ci>
       </apply>
       <mtext>otherwise</mtext>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <times></times>
       <ci>Q</ci>
       <ci>u</ci>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <mtext>otherwise</mtext>
     <apply>
      <csymbol cd="latexml">cases</csymbol>
      <matrix>
       <matrixrow>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <csymbol cd="unknown">P</csymbol>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>S</ci>
           <apply>
            <plus></plus>
            <ci>t</ci>
            <ci>k</ci>
           </apply>
          </apply>
          <ci>normal-|</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>O</ci>
           <cn type="integer">0</cn>
          </apply>
          <and></and>
          <ci>normal-⋯</ci>
          <and></and>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>O</ci>
           <ci>t</ci>
          </apply>
          <ci>normal-)</ci>
         </cerror>
        </cerror>
       </matrixrow>
       <matrixrow>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">k</csymbol>
          <eq></eq>
          <cn type="integer">0</cn>
          <ci>normal-)</ci>
         </cerror>
         <equivalent></equivalent>
         <mtext>Filtering</mtext>
        </cerror>
       </matrixrow>
       <matrixrow>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">k</csymbol>
          <gt></gt>
          <cn type="integer">0</cn>
          <ci>normal-)</ci>
         </cerror>
         <equivalent></equivalent>
         <mtext>Prediction</mtext>
        </cerror>
       </matrixrow>
       <matrixrow>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <csymbol cd="unknown">k</csymbol>
          <lt></lt>
          <cn type="integer">0</cn>
          <ci>normal-)</ci>
         </cerror>
         <equivalent></equivalent>
         <mtext>Smoothing</mtext>
        </cerror>
       </matrixrow>
      </matrix>
      <mtext>otherwise</mtext>
     </apply>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr\begin{cases}Ds\begin{cases}Sp(\pi)\begin{cases}Va:\\
S^{0},\cdots,S^{T},O^{0},\cdots,O^{T}\\
Dc:\\
\begin{cases}&P\left(S^{0}\wedge\cdots\wedge S^{T}\wedge O^{0}\wedge\cdots%
\wedge O^{T}|\pi\right)\\
=&P\left(S^{0}\wedge O^{0}\right)\times\prod_{t=1}^{T}\left[P\left(S^{t}|S^{t-%
1}\right)\times P\left(O^{t}|S^{t}\right)\right]\end{cases}\\
Fo:\\
\begin{cases}P\left(S^{0}\wedge O^{0}\right)\\
P\left(S^{t}|S^{t-1}\right)\\
P\left(O^{t}|S^{t}\right)\end{cases}\end{cases}\\
Id\end{cases}\\
Qu:\\
\begin{cases}\begin{array}[]{l}P\left(S^{t+k}|O^{0}\wedge\cdots\wedge O^{t}%
\right)\\
\left(k=0\right)\equiv\text{Filtering}\\
\left(k>0\right)\equiv\text{Prediction}\\
\left(k<0\right)\equiv\text{Smoothing}\end{array}\end{cases}\end{cases}
  </annotation>
 </semantics>
</math>

</p>
<h4 id="kalman-filter">Kalman filter</h4>

<p>The very well-known <a href="Kalman_filter" title="wikilink">Kalman filters</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> are a special case of Bayesian filters.</p>

<p>They are defined by the following Bayesian program:</p>

<p>

<math display="block" id="Bayesian_programming:105">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>D</mi>
        <mi>s</mi>
        <mrow>
         <mo>{</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mi>S</mi>
             <mi>p</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>π</mi>
              <mo stretchy="false">)</mo>
             </mrow>
             <mrow>
              <mo>{</mo>
              <mtable displaystyle="true">
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mrow>
                   <mi>V</mi>
                   <mi>a</mi>
                  </mrow>
                  <mo>:</mo>
                  <mi></mi>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <msup>
                   <mi>S</mi>
                   <mn>0</mn>
                  </msup>
                  <mo>,</mo>
                  <mi mathvariant="normal">⋯</mi>
                  <mo>,</mo>
                  <msup>
                   <mi>S</mi>
                   <mi>T</mi>
                  </msup>
                  <mo>,</mo>
                  <msup>
                   <mi>O</mi>
                   <mn>0</mn>
                  </msup>
                  <mo>,</mo>
                  <mi mathvariant="normal">⋯</mi>
                  <mo>,</mo>
                  <msup>
                   <mi>O</mi>
                   <mi>T</mi>
                  </msup>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mrow>
                   <mi>D</mi>
                   <mi>c</mi>
                  </mrow>
                  <mo>:</mo>
                  <mi></mi>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mo>{</mo>
                  <mtable displaystyle="true">
                   <mtr>
                    <mtd columnalign="left">
                     <mi></mi>
                    </mtd>
                    <mtd columnalign="left">
                     <mrow>
                      <mi>P</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>S</mi>
                        <mn>0</mn>
                       </msup>
                       <mo>∧</mo>
                       <mi mathvariant="normal">⋯</mi>
                       <mo>∧</mo>
                       <msup>
                        <mi>O</mi>
                        <mi>T</mi>
                       </msup>
                       <mo stretchy="false">|</mo>
                       <mi>π</mi>
                       <mo>)</mo>
                      </mrow>
                     </mrow>
                    </mtd>
                   </mtr>
                   <mtr>
                    <mtd columnalign="left">
                     <mo>=</mo>
                    </mtd>
                    <mtd columnalign="left">
                     <mrow>
                      <mo>[</mo>
                      <mtable displaystyle="true">
                       <mtr>
                        <mtd columnalign="center">
                         <mrow>
                          <mi>P</mi>
                          <mrow>
                           <mo>(</mo>
                           <msup>
                            <mi>S</mi>
                            <mn>0</mn>
                           </msup>
                           <mo>∧</mo>
                           <msup>
                            <mi>O</mi>
                            <mn>0</mn>
                           </msup>
                           <mo stretchy="false">|</mo>
                           <mi>π</mi>
                           <mo>)</mo>
                          </mrow>
                         </mrow>
                        </mtd>
                       </mtr>
                       <mtr>
                        <mtd columnalign="center">
                         <mrow>
                          <mstyle displaystyle="false">
                           <msubsup>
                            <mo largeop="true" symmetric="true">∏</mo>
                            <mrow>
                             <mi>t</mi>
                             <mo>=</mo>
                             <mn>1</mn>
                            </mrow>
                            <mi>T</mi>
                           </msubsup>
                          </mstyle>
                          <mrow>
                           <mo>[</mo>
                           <mi>P</mi>
                           <mrow>
                            <mo>(</mo>
                            <msup>
                             <mi>S</mi>
                             <mi>t</mi>
                            </msup>
                            <mo stretchy="false">|</mo>
                            <msup>
                             <mi>S</mi>
                             <mrow>
                              <mi>t</mi>
                              <mo>-</mo>
                              <mn>1</mn>
                             </mrow>
                            </msup>
                            <mo>∧</mo>
                            <mi>π</mi>
                            <mo>)</mo>
                           </mrow>
                           <mo>×</mo>
                           <mi>P</mi>
                           <mrow>
                            <mo>(</mo>
                            <msup>
                             <mi>O</mi>
                             <mi>t</mi>
                            </msup>
                            <mo stretchy="false">|</mo>
                            <msup>
                             <mi>S</mi>
                             <mi>t</mi>
                            </msup>
                            <mo>∧</mo>
                            <mi>π</mi>
                            <mo>)</mo>
                           </mrow>
                           <mo>]</mo>
                          </mrow>
                         </mrow>
                        </mtd>
                       </mtr>
                      </mtable>
                      <mo>]</mo>
                     </mrow>
                    </mtd>
                   </mtr>
                  </mtable>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mrow>
                   <mi>F</mi>
                   <mi>o</mi>
                  </mrow>
                  <mo>:</mo>
                  <mi></mi>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mo>{</mo>
                  <mtable displaystyle="true">
                   <mtr>
                    <mtd columnalign="left">
                     <mrow>
                      <mi>P</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>S</mi>
                        <mi>t</mi>
                       </msup>
                       <mo>∣</mo>
                       <msup>
                        <mi>S</mi>
                        <mrow>
                         <mi>t</mi>
                         <mo>-</mo>
                         <mn>1</mn>
                        </mrow>
                       </msup>
                       <mo>∧</mo>
                       <mi>π</mi>
                       <mo>)</mo>
                      </mrow>
                      <mo>≡</mo>
                      <mi>G</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>S</mi>
                        <mi>t</mi>
                       </msup>
                       <mo>,</mo>
                       <mi>A</mi>
                       <mo>∙</mo>
                       <msup>
                        <mi>S</mi>
                        <mrow>
                         <mi>t</mi>
                         <mo>-</mo>
                         <mn>1</mn>
                        </mrow>
                       </msup>
                       <mo>,</mo>
                       <mi>Q</mi>
                       <mo>)</mo>
                      </mrow>
                     </mrow>
                    </mtd>
                    <mtd></mtd>
                   </mtr>
                   <mtr>
                    <mtd columnalign="left">
                     <mrow>
                      <mi>P</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>O</mi>
                        <mi>t</mi>
                       </msup>
                       <mo>∣</mo>
                       <msup>
                        <mi>S</mi>
                        <mi>t</mi>
                       </msup>
                       <mo>∧</mo>
                       <mi>π</mi>
                       <mo>)</mo>
                      </mrow>
                      <mo>≡</mo>
                      <mi>G</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>O</mi>
                        <mi>t</mi>
                       </msup>
                       <mo>,</mo>
                       <mi>H</mi>
                       <mo>∙</mo>
                       <msup>
                        <mi>S</mi>
                        <mi>t</mi>
                       </msup>
                       <mo>,</mo>
                       <mi>R</mi>
                       <mo>)</mo>
                      </mrow>
                     </mrow>
                    </mtd>
                    <mtd></mtd>
                   </mtr>
                  </mtable>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
              </mtable>
             </mrow>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mi>I</mi>
             <mi>d</mi>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
         </mtable>
        </mrow>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>Q</mi>
         <mi>u</mi>
        </mrow>
        <mo>:</mo>
        <mi></mi>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>P</mi>
        <mrow>
         <mo>(</mo>
         <msup>
          <mi>S</mi>
          <mi>T</mi>
         </msup>
         <mo>∣</mo>
         <msup>
          <mi>O</mi>
          <mn>0</mn>
         </msup>
         <mo>∧</mo>
         <mi mathvariant="normal">⋯</mi>
         <mo>∧</mo>
         <msup>
          <mi>O</mi>
          <mi>T</mi>
         </msup>
         <mo>∧</mo>
         <mi>π</mi>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>r</ci>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>s</ci>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>p</ci>
        <ci>π</ci>
        <apply>
         <csymbol cd="latexml">cases</csymbol>
         <apply>
          <ci>normal-:</ci>
          <apply>
           <times></times>
           <ci>V</ci>
           <ci>a</ci>
          </apply>
          <csymbol cd="latexml">absent</csymbol>
         </apply>
         <mtext>otherwise</mtext>
         <list>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>S</ci>
           <cn type="integer">0</cn>
          </apply>
          <ci>normal-⋯</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>S</ci>
           <ci>T</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>O</ci>
           <cn type="integer">0</cn>
          </apply>
          <ci>normal-⋯</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>O</ci>
           <ci>T</ci>
          </apply>
         </list>
         <mtext>otherwise</mtext>
         <apply>
          <ci>normal-:</ci>
          <apply>
           <times></times>
           <ci>D</ci>
           <ci>c</ci>
          </apply>
          <csymbol cd="latexml">absent</csymbol>
         </apply>
         <mtext>otherwise</mtext>
         <apply>
          <csymbol cd="latexml">cases</csymbol>
          <csymbol cd="latexml">absent</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <csymbol cd="unknown">P</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <cn type="integer">0</cn>
            </apply>
            <and></and>
            <ci>normal-⋯</ci>
            <and></and>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>O</ci>
             <ci>T</ci>
            </apply>
            <ci>normal-|</ci>
            <csymbol cd="unknown">π</csymbol>
            <ci>normal-)</ci>
           </cerror>
          </cerror>
          <eq></eq>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <matrix>
            <matrixrow>
             <cerror>
              <csymbol cd="ambiguous">fragments</csymbol>
              <csymbol cd="unknown">P</csymbol>
              <cerror>
               <csymbol cd="ambiguous">fragments</csymbol>
               <ci>normal-(</ci>
               <apply>
                <csymbol cd="ambiguous">superscript</csymbol>
                <ci>S</ci>
                <cn type="integer">0</cn>
               </apply>
               <and></and>
               <apply>
                <csymbol cd="ambiguous">superscript</csymbol>
                <ci>O</ci>
                <cn type="integer">0</cn>
               </apply>
               <ci>normal-|</ci>
               <csymbol cd="unknown">π</csymbol>
               <ci>normal-)</ci>
              </cerror>
             </cerror>
            </matrixrow>
            <matrixrow>
             <cerror>
              <csymbol cd="ambiguous">fragments</csymbol>
              <apply>
               <csymbol cd="ambiguous">superscript</csymbol>
               <apply>
                <csymbol cd="ambiguous">subscript</csymbol>
                <csymbol cd="latexml">product</csymbol>
                <apply>
                 <eq></eq>
                 <ci>t</ci>
                 <cn type="integer">1</cn>
                </apply>
               </apply>
               <ci>T</ci>
              </apply>
              <cerror>
               <csymbol cd="ambiguous">fragments</csymbol>
               <ci>normal-[</ci>
               <csymbol cd="unknown">P</csymbol>
               <cerror>
                <csymbol cd="ambiguous">fragments</csymbol>
                <ci>normal-(</ci>
                <apply>
                 <csymbol cd="ambiguous">superscript</csymbol>
                 <ci>S</ci>
                 <ci>t</ci>
                </apply>
                <ci>normal-|</ci>
                <apply>
                 <csymbol cd="ambiguous">superscript</csymbol>
                 <ci>S</ci>
                 <apply>
                  <minus></minus>
                  <ci>t</ci>
                  <cn type="integer">1</cn>
                 </apply>
                </apply>
                <and></and>
                <csymbol cd="unknown">π</csymbol>
                <ci>normal-)</ci>
               </cerror>
               <times></times>
               <csymbol cd="unknown">P</csymbol>
               <cerror>
                <csymbol cd="ambiguous">fragments</csymbol>
                <ci>normal-(</ci>
                <apply>
                 <csymbol cd="ambiguous">superscript</csymbol>
                 <ci>O</ci>
                 <ci>t</ci>
                </apply>
                <ci>normal-|</ci>
                <apply>
                 <csymbol cd="ambiguous">superscript</csymbol>
                 <ci>S</ci>
                 <ci>t</ci>
                </apply>
                <and></and>
                <csymbol cd="unknown">π</csymbol>
                <ci>normal-)</ci>
               </cerror>
               <ci>normal-]</ci>
              </cerror>
             </cerror>
            </matrixrow>
           </matrix>
          </apply>
         </apply>
         <mtext>otherwise</mtext>
         <apply>
          <ci>normal-:</ci>
          <apply>
           <times></times>
           <ci>F</ci>
           <ci>o</ci>
          </apply>
          <csymbol cd="latexml">absent</csymbol>
         </apply>
         <mtext>otherwise</mtext>
         <apply>
          <csymbol cd="latexml">cases</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <csymbol cd="unknown">P</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <ci>t</ci>
            </apply>
            <ci>normal-∣</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <apply>
              <minus></minus>
              <ci>t</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <and></and>
            <csymbol cd="unknown">π</csymbol>
            <ci>normal-)</ci>
           </cerror>
           <equivalent></equivalent>
           <csymbol cd="unknown">G</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <ci>t</ci>
            </apply>
            <ci>normal-,</ci>
            <csymbol cd="unknown">A</csymbol>
            <ci>normal-∙</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <apply>
              <minus></minus>
              <ci>t</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <ci>normal-,</ci>
            <csymbol cd="unknown">Q</csymbol>
            <ci>normal-)</ci>
           </cerror>
          </cerror>
          <mtext>otherwise</mtext>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <csymbol cd="unknown">P</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>O</ci>
             <ci>t</ci>
            </apply>
            <ci>normal-∣</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <ci>t</ci>
            </apply>
            <and></and>
            <csymbol cd="unknown">π</csymbol>
            <ci>normal-)</ci>
           </cerror>
           <equivalent></equivalent>
           <csymbol cd="unknown">G</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>O</ci>
             <ci>t</ci>
            </apply>
            <ci>normal-,</ci>
            <csymbol cd="unknown">H</csymbol>
            <ci>normal-∙</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <ci>t</ci>
            </apply>
            <ci>normal-,</ci>
            <csymbol cd="unknown">R</csymbol>
            <ci>normal-)</ci>
           </cerror>
          </cerror>
          <mtext>otherwise</mtext>
         </apply>
         <mtext>otherwise</mtext>
        </apply>
       </apply>
       <mtext>otherwise</mtext>
       <apply>
        <times></times>
        <ci>I</ci>
        <ci>d</ci>
       </apply>
       <mtext>otherwise</mtext>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <times></times>
       <ci>Q</ci>
       <ci>u</ci>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <mtext>otherwise</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>S</ci>
        <ci>T</ci>
       </apply>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>O</ci>
        <cn type="integer">0</cn>
       </apply>
       <and></and>
       <ci>normal-⋯</ci>
       <and></and>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>O</ci>
        <ci>T</ci>
       </apply>
       <and></and>
       <csymbol cd="unknown">π</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr\begin{cases}Ds\begin{cases}Sp(\pi)\begin{cases}Va:\\
S^{0},\cdots,S^{T},O^{0},\cdots,O^{T}\\
Dc:\\
\begin{cases}&P\left(S^{0}\wedge\cdots\wedge O^{T}|\pi\right)\\
=&\left[\begin{array}[]{c}P\left(S^{0}\wedge O^{0}|\pi\right)\\
\prod_{t=1}^{T}\left[P\left(S^{t}|S^{t-1}\wedge\pi\right)\times P\left(O^{t}|S%
^{t}\wedge\pi\right)\right]\end{array}\right]\end{cases}\\
Fo:\\
\begin{cases}P\left(S^{t}\mid S^{t-1}\wedge\pi\right)\equiv G\left(S^{t},A%
\bullet S^{t-1},Q\right)\\
P\left(O^{t}\mid S^{t}\wedge\pi\right)\equiv G\left(O^{t},H\bullet S^{t},R%
\right)\end{cases}\end{cases}\\
Id\end{cases}\\
Qu:\\
P\left(S^{T}\mid O^{0}\wedge\cdots\wedge O^{T}\wedge\pi\right)\end{cases}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>Variables are continuous.</li>
<li>The transition model 

<math display="inline" id="Bayesian_programming:106">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>S</mi>
     <mi>t</mi>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>∧</mo>
    <mi>π</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S^{t}\mid S^{t-1}\wedge\pi)
  </annotation>
 </semantics>
</math>

 and the observation model 

<math display="inline" id="Bayesian_programming:107">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>O</mi>
     <mi>t</mi>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>S</mi>
     <mi>t</mi>
    </msup>
    <mo>∧</mo>
    <mi>π</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(O^{t}\mid S^{t}\wedge\pi)
  </annotation>
 </semantics>
</math>

 are both specified using Gaussian laws with means that are linear functions of the conditioning variables.</li>
</ul>

<p>With these hypotheses and by using the recursive formula, it is possible to solve the inference problem analytically to answer the usual 

<math display="inline" id="Bayesian_programming:108">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>S</mi>
     <mi>T</mi>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>O</mi>
     <mn>0</mn>
    </msup>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msup>
     <mi>O</mi>
     <mi>T</mi>
    </msup>
    <mo>∧</mo>
    <mi>π</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>T</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <cn type="integer">0</cn>
     </apply>
     <and></and>
     <ci>normal-⋯</ci>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <ci>T</ci>
     </apply>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S^{T}\mid O^{0}\wedge\cdots\wedge O^{T}\wedge\pi)
  </annotation>
 </semantics>
</math>

 question. This leads to an extremely efficient algorithm, which explains the popularity of Kalman filters and the number of their everyday applications.</p>

<p>When there are no obvious linear transition and observation models, it is still often possible, using a first-order Taylor's expansion, to treat these models as locally linear. This generalization is commonly called the <a href="extended_Kalman_filter" title="wikilink">extended Kalman filter</a>.</p>
<h4 id="hidden-markov-model">Hidden Markov model</h4>

<p><a href="Hidden_Markov_model" title="wikilink">Hidden Markov models</a> (HMMs) are another very popular specialization of Bayesian filters.</p>

<p>They are defined by the following Bayesian program:</p>

<p>

<math display="block" id="Bayesian_programming:109">
 <semantics>
  <mrow>
   <mi>Pr</mi>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>D</mi>
        <mi>s</mi>
        <mrow>
         <mo>{</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mi>S</mi>
             <mi>p</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>π</mi>
              <mo stretchy="false">)</mo>
             </mrow>
             <mrow>
              <mo>{</mo>
              <mtable displaystyle="true">
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mrow>
                   <mi>V</mi>
                   <mi>a</mi>
                  </mrow>
                  <mo>:</mo>
                  <mi></mi>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <msup>
                   <mi>S</mi>
                   <mn>0</mn>
                  </msup>
                  <mo>,</mo>
                  <mi mathvariant="normal">…</mi>
                  <mo>,</mo>
                  <msup>
                   <mi>S</mi>
                   <mi>T</mi>
                  </msup>
                  <mo>,</mo>
                  <msup>
                   <mi>O</mi>
                   <mn>0</mn>
                  </msup>
                  <mo>,</mo>
                  <mi mathvariant="normal">…</mi>
                  <mo>,</mo>
                  <msup>
                   <mi>O</mi>
                   <mi>T</mi>
                  </msup>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mrow>
                   <mi>D</mi>
                   <mi>c</mi>
                  </mrow>
                  <mo>:</mo>
                  <mi></mi>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mo>{</mo>
                  <mtable displaystyle="true">
                   <mtr>
                    <mtd columnalign="left">
                     <mi></mi>
                    </mtd>
                    <mtd columnalign="left">
                     <mrow>
                      <mi>P</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>S</mi>
                        <mn>0</mn>
                       </msup>
                       <mo>∧</mo>
                       <mi mathvariant="normal">⋯</mi>
                       <mo>∧</mo>
                       <msup>
                        <mi>O</mi>
                        <mi>T</mi>
                       </msup>
                       <mo>∣</mo>
                       <mi>π</mi>
                       <mo>)</mo>
                      </mrow>
                     </mrow>
                    </mtd>
                   </mtr>
                   <mtr>
                    <mtd columnalign="left">
                     <mo>=</mo>
                    </mtd>
                    <mtd columnalign="left">
                     <mrow>
                      <mo>[</mo>
                      <mtable displaystyle="true">
                       <mtr>
                        <mtd columnalign="center">
                         <mrow>
                          <mi>P</mi>
                          <mrow>
                           <mo>(</mo>
                           <msup>
                            <mi>S</mi>
                            <mn>0</mn>
                           </msup>
                           <mo>∧</mo>
                           <msup>
                            <mi>O</mi>
                            <mn>0</mn>
                           </msup>
                           <mo>∣</mo>
                           <mi>π</mi>
                           <mo>)</mo>
                          </mrow>
                         </mrow>
                        </mtd>
                       </mtr>
                       <mtr>
                        <mtd columnalign="center">
                         <mrow>
                          <mstyle displaystyle="false">
                           <msubsup>
                            <mo largeop="true" symmetric="true">∏</mo>
                            <mrow>
                             <mi>t</mi>
                             <mo>=</mo>
                             <mn>1</mn>
                            </mrow>
                            <mi>T</mi>
                           </msubsup>
                          </mstyle>
                          <mrow>
                           <mo>[</mo>
                           <mi>P</mi>
                           <mrow>
                            <mo>(</mo>
                            <msup>
                             <mi>S</mi>
                             <mi>t</mi>
                            </msup>
                            <mo>∣</mo>
                            <msup>
                             <mi>S</mi>
                             <mrow>
                              <mi>t</mi>
                              <mo>-</mo>
                              <mn>1</mn>
                             </mrow>
                            </msup>
                            <mo>∧</mo>
                            <mi>π</mi>
                            <mo>)</mo>
                           </mrow>
                           <mo>×</mo>
                           <mi>P</mi>
                           <mrow>
                            <mo>(</mo>
                            <msup>
                             <mi>O</mi>
                             <mi>t</mi>
                            </msup>
                            <mo>∣</mo>
                            <msup>
                             <mi>S</mi>
                             <mi>t</mi>
                            </msup>
                            <mo>∧</mo>
                            <mi>π</mi>
                            <mo>)</mo>
                           </mrow>
                           <mo>]</mo>
                          </mrow>
                         </mrow>
                        </mtd>
                       </mtr>
                      </mtable>
                      <mo>]</mo>
                     </mrow>
                    </mtd>
                   </mtr>
                  </mtable>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mrow>
                   <mi>F</mi>
                   <mi>o</mi>
                  </mrow>
                  <mo>:</mo>
                  <mi></mi>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
               <mtr>
                <mtd columnalign="left">
                 <mrow>
                  <mo>{</mo>
                  <mtable displaystyle="true">
                   <mtr>
                    <mtd columnalign="left">
                     <mrow>
                      <mi>P</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>S</mi>
                        <mn>0</mn>
                       </msup>
                       <mo>∧</mo>
                       <msup>
                        <mi>O</mi>
                        <mn>0</mn>
                       </msup>
                       <mo>∣</mo>
                       <mi>π</mi>
                       <mo>)</mo>
                      </mrow>
                      <mo>≡</mo>
                      <mtext>Matrix</mtext>
                     </mrow>
                    </mtd>
                    <mtd></mtd>
                   </mtr>
                   <mtr>
                    <mtd columnalign="left">
                     <mrow>
                      <mi>P</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>S</mi>
                        <mi>t</mi>
                       </msup>
                       <mo>∣</mo>
                       <msup>
                        <mi>S</mi>
                        <mrow>
                         <mi>t</mi>
                         <mo>-</mo>
                         <mn>1</mn>
                        </mrow>
                       </msup>
                       <mo>∧</mo>
                       <mi>π</mi>
                       <mo>)</mo>
                      </mrow>
                      <mo>≡</mo>
                      <mtext>Matrix</mtext>
                     </mrow>
                    </mtd>
                    <mtd></mtd>
                   </mtr>
                   <mtr>
                    <mtd columnalign="left">
                     <mrow>
                      <mi>P</mi>
                      <mrow>
                       <mo>(</mo>
                       <msup>
                        <mi>O</mi>
                        <mi>t</mi>
                       </msup>
                       <mo>∣</mo>
                       <msup>
                        <mi>S</mi>
                        <mi>t</mi>
                       </msup>
                       <mo>∧</mo>
                       <mi>π</mi>
                       <mo>)</mo>
                      </mrow>
                      <mo>≡</mo>
                      <mtext>Matrix</mtext>
                     </mrow>
                    </mtd>
                    <mtd></mtd>
                   </mtr>
                  </mtable>
                 </mrow>
                </mtd>
                <mtd></mtd>
               </mtr>
              </mtable>
             </mrow>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mi>I</mi>
             <mi>d</mi>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
         </mtable>
        </mrow>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>Q</mi>
         <mi>u</mi>
        </mrow>
        <mo>:</mo>
        <mi></mi>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>max</mi>
         <mrow>
          <msup>
           <mi>S</mi>
           <mn>1</mn>
          </msup>
          <mo>∧</mo>
          <mi mathvariant="normal">⋯</mi>
          <mo>∧</mo>
          <msup>
           <mi>S</mi>
           <mrow>
            <mi>T</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msup>
         </mrow>
        </msub>
        <mrow>
         <mo>[</mo>
         <mi>P</mi>
         <mrow>
          <mo>(</mo>
          <msup>
           <mi>S</mi>
           <mn>1</mn>
          </msup>
          <mo>∧</mo>
          <mi mathvariant="normal">⋯</mi>
          <mo>∧</mo>
          <msup>
           <mi>S</mi>
           <mrow>
            <mi>T</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msup>
          <mo>∣</mo>
          <msup>
           <mi>S</mi>
           <mi>T</mi>
          </msup>
          <mo>∧</mo>
          <msup>
           <mi>O</mi>
           <mn>0</mn>
          </msup>
          <mo>∧</mo>
          <mi mathvariant="normal">⋯</mi>
          <mo>∧</mo>
          <msup>
           <mi>O</mi>
           <mi>T</mi>
          </msup>
          <mo>∧</mo>
          <mi>π</mi>
          <mo>)</mo>
         </mrow>
         <mo>]</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Pr</ci>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>s</ci>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>p</ci>
        <ci>π</ci>
        <apply>
         <csymbol cd="latexml">cases</csymbol>
         <apply>
          <ci>normal-:</ci>
          <apply>
           <times></times>
           <ci>V</ci>
           <ci>a</ci>
          </apply>
          <csymbol cd="latexml">absent</csymbol>
         </apply>
         <mtext>otherwise</mtext>
         <list>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>S</ci>
           <cn type="integer">0</cn>
          </apply>
          <ci>normal-…</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>S</ci>
           <ci>T</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>O</ci>
           <cn type="integer">0</cn>
          </apply>
          <ci>normal-…</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>O</ci>
           <ci>T</ci>
          </apply>
         </list>
         <mtext>otherwise</mtext>
         <apply>
          <ci>normal-:</ci>
          <apply>
           <times></times>
           <ci>D</ci>
           <ci>c</ci>
          </apply>
          <csymbol cd="latexml">absent</csymbol>
         </apply>
         <mtext>otherwise</mtext>
         <apply>
          <csymbol cd="latexml">cases</csymbol>
          <csymbol cd="latexml">absent</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <csymbol cd="unknown">P</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <cn type="integer">0</cn>
            </apply>
            <and></and>
            <ci>normal-⋯</ci>
            <and></and>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>O</ci>
             <ci>T</ci>
            </apply>
            <ci>normal-∣</ci>
            <csymbol cd="unknown">π</csymbol>
            <ci>normal-)</ci>
           </cerror>
          </cerror>
          <eq></eq>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <matrix>
            <matrixrow>
             <cerror>
              <csymbol cd="ambiguous">fragments</csymbol>
              <csymbol cd="unknown">P</csymbol>
              <cerror>
               <csymbol cd="ambiguous">fragments</csymbol>
               <ci>normal-(</ci>
               <apply>
                <csymbol cd="ambiguous">superscript</csymbol>
                <ci>S</ci>
                <cn type="integer">0</cn>
               </apply>
               <and></and>
               <apply>
                <csymbol cd="ambiguous">superscript</csymbol>
                <ci>O</ci>
                <cn type="integer">0</cn>
               </apply>
               <ci>normal-∣</ci>
               <csymbol cd="unknown">π</csymbol>
               <ci>normal-)</ci>
              </cerror>
             </cerror>
            </matrixrow>
            <matrixrow>
             <cerror>
              <csymbol cd="ambiguous">fragments</csymbol>
              <apply>
               <csymbol cd="ambiguous">superscript</csymbol>
               <apply>
                <csymbol cd="ambiguous">subscript</csymbol>
                <csymbol cd="latexml">product</csymbol>
                <apply>
                 <eq></eq>
                 <ci>t</ci>
                 <cn type="integer">1</cn>
                </apply>
               </apply>
               <ci>T</ci>
              </apply>
              <cerror>
               <csymbol cd="ambiguous">fragments</csymbol>
               <ci>normal-[</ci>
               <csymbol cd="unknown">P</csymbol>
               <cerror>
                <csymbol cd="ambiguous">fragments</csymbol>
                <ci>normal-(</ci>
                <apply>
                 <csymbol cd="ambiguous">superscript</csymbol>
                 <ci>S</ci>
                 <ci>t</ci>
                </apply>
                <ci>normal-∣</ci>
                <apply>
                 <csymbol cd="ambiguous">superscript</csymbol>
                 <ci>S</ci>
                 <apply>
                  <minus></minus>
                  <ci>t</ci>
                  <cn type="integer">1</cn>
                 </apply>
                </apply>
                <and></and>
                <csymbol cd="unknown">π</csymbol>
                <ci>normal-)</ci>
               </cerror>
               <times></times>
               <csymbol cd="unknown">P</csymbol>
               <cerror>
                <csymbol cd="ambiguous">fragments</csymbol>
                <ci>normal-(</ci>
                <apply>
                 <csymbol cd="ambiguous">superscript</csymbol>
                 <ci>O</ci>
                 <ci>t</ci>
                </apply>
                <ci>normal-∣</ci>
                <apply>
                 <csymbol cd="ambiguous">superscript</csymbol>
                 <ci>S</ci>
                 <ci>t</ci>
                </apply>
                <and></and>
                <csymbol cd="unknown">π</csymbol>
                <ci>normal-)</ci>
               </cerror>
               <ci>normal-]</ci>
              </cerror>
             </cerror>
            </matrixrow>
           </matrix>
          </apply>
         </apply>
         <mtext>otherwise</mtext>
         <apply>
          <ci>normal-:</ci>
          <apply>
           <times></times>
           <ci>F</ci>
           <ci>o</ci>
          </apply>
          <csymbol cd="latexml">absent</csymbol>
         </apply>
         <mtext>otherwise</mtext>
         <apply>
          <csymbol cd="latexml">cases</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <csymbol cd="unknown">P</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <cn type="integer">0</cn>
            </apply>
            <and></and>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>O</ci>
             <cn type="integer">0</cn>
            </apply>
            <ci>normal-∣</ci>
            <csymbol cd="unknown">π</csymbol>
            <ci>normal-)</ci>
           </cerror>
           <equivalent></equivalent>
           <mtext>Matrix</mtext>
          </cerror>
          <mtext>otherwise</mtext>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <csymbol cd="unknown">P</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <ci>t</ci>
            </apply>
            <ci>normal-∣</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <apply>
              <minus></minus>
              <ci>t</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <and></and>
            <csymbol cd="unknown">π</csymbol>
            <ci>normal-)</ci>
           </cerror>
           <equivalent></equivalent>
           <mtext>Matrix</mtext>
          </cerror>
          <mtext>otherwise</mtext>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <csymbol cd="unknown">P</csymbol>
           <cerror>
            <csymbol cd="ambiguous">fragments</csymbol>
            <ci>normal-(</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>O</ci>
             <ci>t</ci>
            </apply>
            <ci>normal-∣</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>S</ci>
             <ci>t</ci>
            </apply>
            <and></and>
            <csymbol cd="unknown">π</csymbol>
            <ci>normal-)</ci>
           </cerror>
           <equivalent></equivalent>
           <mtext>Matrix</mtext>
          </cerror>
          <mtext>otherwise</mtext>
         </apply>
         <mtext>otherwise</mtext>
        </apply>
       </apply>
       <mtext>otherwise</mtext>
       <apply>
        <times></times>
        <ci>I</ci>
        <ci>d</ci>
       </apply>
       <mtext>otherwise</mtext>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <times></times>
       <ci>Q</ci>
       <ci>u</ci>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <mtext>otherwise</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <and></and>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-⋯</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <apply>
          <minus></minus>
          <ci>T</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">P</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <cn type="integer">1</cn>
        </apply>
        <and></and>
        <ci>normal-⋯</ci>
        <and></and>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <apply>
          <minus></minus>
          <ci>T</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-∣</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <ci>T</ci>
        </apply>
        <and></and>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>O</ci>
         <cn type="integer">0</cn>
        </apply>
        <and></and>
        <ci>normal-⋯</ci>
        <and></and>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>O</ci>
         <ci>T</ci>
        </apply>
        <and></and>
        <csymbol cd="unknown">π</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-]</ci>
      </cerror>
     </cerror>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\begin{cases}Ds\begin{cases}Sp(\pi)\begin{cases}Va:\\
S^{0},\ldots,S^{T},O^{0},\ldots,O^{T}\\
Dc:\\
\begin{cases}&P\left(S^{0}\wedge\cdots\wedge O^{T}\mid\pi\right)\\
=&\left[\begin{array}[]{c}P\left(S^{0}\wedge O^{0}\mid\pi\right)\\
\prod_{t=1}^{T}\left[P\left(S^{t}\mid S^{t-1}\wedge\pi\right)\times P\left(O^{%
t}\mid S^{t}\wedge\pi\right)\right]\end{array}\right]\end{cases}\\
Fo:\\
\begin{cases}P\left(S^{0}\wedge O^{0}\mid\pi\right)\equiv\text{Matrix}\\
P\left(S^{t}\mid S^{t-1}\wedge\pi\right)\equiv\text{Matrix}\\
P\left(O^{t}\mid S^{t}\wedge\pi\right)\equiv\text{Matrix}\end{cases}\end{cases%
}\\
Id\end{cases}\\
Qu:\\
\max_{S^{1}\wedge\cdots\wedge S^{T-1}}\left[P\left(S^{1}\wedge\cdots\wedge S^{%
T-1}\mid S^{T}\wedge O^{0}\wedge\cdots\wedge O^{T}\wedge\pi\right)\right]\end{cases}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>Variables are treated as being discrete.</li>
<li>The transition model 

<math display="inline" id="Bayesian_programming:110">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>S</mi>
     <mi>t</mi>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>S</mi>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(S^{t}\mid S^{t-1}\wedge\pi\right)
  </annotation>
 </semantics>
</math>

 and the observation model 

<math display="inline" id="Bayesian_programming:111">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>O</mi>
     <mi>t</mi>
    </msup>
    <mo>∣</mo>
    <msup>
     <mi>S</mi>
     <mi>t</mi>
    </msup>
    <mo>∧</mo>
    <mi>π</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>O</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>t</ci>
     </apply>
     <and></and>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(O^{t}\mid S^{t}\wedge\pi\right)
  </annotation>
 </semantics>
</math>

 are</li>
</ul>

<p>both specified using probability matrices.</p>
<ul>
<li>The question most frequently asked of HMMs is:</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\max_{S^{1}\wedge\cdots\wedge S^{T-1}}\left[P\left(S^{1}\wedge\cdots\wedge S^{T-1}\mid S^{T}\wedge O^{0}\wedge\cdots\wedge O^{T}\wedge\pi\right)\right] </p>

<p>What is the most probable series of states that leads to the present state, knowing the past observations?</p>

<p>This particular question may be answered with a specific and very efficient algorithm called the <a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a>.</p>

<p>A specific learning algorithm called the <a href="Baum–Welch_algorithm" title="wikilink">Baum–Welch algorithm</a> has also been developed for HMMs.</p>
<h2 id="applications">Applications</h2>
<h3 id="academic-applications">Academic applications</h3>

<p>For the last 15 years, Bayesian programming approach has been used in various universities to develop both robotics applications and life sciences models.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h4 id="robotics">Robotics</h4>

<p>In robotics, Bayesian programming has been applied to <a href="autonomous_robotics" title="wikilink">autonomous robotics</a>,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> robotic <a href="Computer-aided_design" title="wikilink">CAD</a> systems,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> <a href="Advanced_driver_assistance_systems" title="wikilink">Advanced driver assistance systems</a>,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> robotic arm control, <a href="mobile_robot" title="wikilink">mobile robotics</a>,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Human-robots interactions,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Human-vehicle interactions (Bayesian autonomous driver models) <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> <a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> <a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> video game avatar programming and training <a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> and real-time strategy games (AI).<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h4 id="life-sciences">Life sciences</h4>

<p>In life sciences, Bayesian Programming has been used in vision to reconstruct shape from motion,<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> to model visuo-vestibular interaction<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> and to study saccadic eye movements;<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> in speech perception and control to study early acquisition of speech<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> and the emergence of articulatory-acoustic systems;<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> and to model handwriting perception and control.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h2 id="bayesian-programming-versus-possibility-theories">Bayesian programming versus possibility theories</h2>

<p>The comparison between probabilistic approaches (not only Bayesian programming) and possibility theories has been debated for a long time and is, unfortunately, a very controversial matter.</p>

<p>Possibility theories like, for instance, <a href="fuzzy_set" title="wikilink">fuzzy sets</a>,<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> <a href="Fuzzy_logic" title="wikilink">Fuzzy logic</a><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> and <a href="Possibility_theory" title="wikilink">Possibility theory</a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> propose different alternatives to probability to model uncertainty. They argue that probability is insufficient or inconvenient to model certain aspects of incomplete and uncertain knowledge.</p>

<p>The defense of probability is mainly based on <a href="Cox's_theorem" title="wikilink">Cox's theorem</a> which, starting from four postulates concerning rational reasoning in the presence of uncertainty, demonstrates that the only mathematical framework that satisfies these postulates is probability theory. The argument then goes like this: if you use a different approach than probability, then you necessarily infringe on one of these postulates. Let us see which one and discuss its utility.</p>
<h2 id="bayesian-programming-versus-probabilistic-programming">Bayesian programming versus probabilistic programming</h2>

<p>The purpose of <a href="Probabilistic_relational_programming_language" title="wikilink">probabilistic programming</a> is to unify the scope of classical programming languages with probabilistic modeling (especially <a href="Bayesian_network" title="wikilink">Bayesian networks</a>) in order to be able to deal with uncertainty but still profit from the power of expression of programming languages to describe complex models.</p>

<p>The extended classical programming languages can be logical languages as proposed in Probabilistic Horn Abduction,<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> Independent Choice Logic,<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> PRISM,<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> and ProbLog which propose an extension of Prolog.</p>

<p>It can also be extensions of functional programming languages (essentially <a href="Lisp_(programming_language)" title="wikilink">Lisp</a> and <a href="Scheme_(programming_language)" title="wikilink">Scheme</a>) such as IBAL or CHURCH. The inspiring programming languages can even be object oriented like in BLOG and FACTORIE or more standard ones like in CES and <a href="https://github.com/p2t2/figaro">FIGARO</a>.</p>

<p>The purpose of Bayesian programming is different. Jaynes' precept of "probability as logic" defends that probability is an extension of and an alternative to logic above which a complete theory of rationality, computation and programming can be rebuilt. Bayesian programming does not search to extend classical languages but rather to replace them by a new programming approach based on probability and taking fully into account <a href="Completeness_(logic)" title="wikilink">incompleteness</a> and <a href="Uncertainty_quantification" title="wikilink">uncertainty</a>.</p>

<p>The precise comparison between the semantic and power of expression of Bayesian and probabilistic programming is still an open question.</p>
<h2 id="see-also">See also</h2>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.probayes.com/Bayesian-Programming-Book">A companion site to the <em>Bayesian programming</em> book where to download ProBT an inference engine dedicated to Bayesian programming.</a></li>
<li>The <a href="http://Bayesian-programming.org">Bayesian-programming.org site</a> for the promotion of Bayesian programming with detailed information and numerous publications.</li>
</ul>

<p>"</p>

<p><a href="Category:Bayesian_statistics" title="wikilink">Category:Bayesian statistics</a> <a href="Category:Probability_theory" title="wikilink">Category:Probability theory</a> <a href="Category:Artificial_intelligence" title="wikilink">Category:Artificial intelligence</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
</ol>
</section>
</body>
</html>
