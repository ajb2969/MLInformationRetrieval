   SWIFFT      SWIFFT   In cryptography , SWIFFT is a collection of provably secure  hash functions . It is based on the concept of the Fast Fourier Transform (FFT). SWIFFT is not the first hash function based on FFT, but it sets itself apart by providing a mathematical proof of its security. It also uses the LLL basis reduction algorithm . It can be shown that finding collisions in SWIFFT is as least as difficult as finding short vectors in cyclic/ ideal lattices in the worst case . By giving a security reduction to the worst-case scenario of a difficult mathematical problem, SWIFFT gives a much stronger security guarantee than most other cryptographic hash functions .  Unlike many other provably secure hash functions, the algorithm is quite fast, yielding a throughput of 40MB/s on a 3.2 GHz Intel Pentium 4. Although SWIFFT satisfies many desirable cryptographic and statistical properties, it was not designed to be an "all-purpose" cryptographic hash function. For example, it is not a pseudorandom function , and would not be a suitable instantiation of a random oracle . The algorithm is less efficient than most traditional hash functions that do not give a proof of their collision-resistance. Therefore, its practical use would lie mostly in applications where the proof of collision-resistance is particularly valuable, such as digital signatures that must remain trustworthy for a long time.  A modification of SWIFFT called SWIFFTX was proposed as a candidate for SHA-3 function to the NIST hash function competition 1 and was rejected in the first round. 2  The Algorithm  The algorithm is as follows: 3   Let the polynomial variable be called   α   α   \alpha     Input : message   M   M   M   of length    m  n      m  n    mn     Convert   M   M   M   to a collection of   m   m   m   polynomials    p  i     subscript  p  i    p_{i}   in a certain polynomial ring    R   R   R   with binary coefficients.  Compute the Fourier coefficients of each    p  i     subscript  p  i    p_{i}   using SWIFFT.  Define the Fourier coefficients of    a  i     subscript  a  i    a_{i}   , so that they are fixed and depend on a family of SWIFFT.  Point-wise multiply the Fourier coefficients    p  i     subscript  p  i    p_{i}   with the Fourier coefficients of    a  i     subscript  a  i    a_{i}   for each   i   i   i   .  Use inverse FFT to obtain   m   m   m   polynomials    f  i     subscript  f  i    f_{i}   of degree .  Compute    f  =    ∑   i  =  1   m    (   f  i   )        f    superscript   subscript     i  1    m    subscript  f  i      f=\sum_{i=1}^{m}(f_{i})   modulo   p   p   p   and     α  n   +  1       superscript  α  n   1    \alpha^{n}+1   .  Convert   f   f   f   to    n   log   (  p  )        n    p     n\log(p)   bits and output it.    The FFT operation in step 4 is easy to invert, and is performed to achieve diffusion , that is, to mix the input bits.  The linear combination in step 6 achieves confusion , since it compresses the input.  This is just a high level description of what the algorithm does, some more advanced optimizations are used to finally yield a high performing algorithm.   Example  We choose concrete values for the parameters n , m , and p as follows: n = 64, m = 16, p = 257. For these parameters, any fixed compression function in the family takes a binary input of length mn = 1024 bits (128 bytes), to an output in the range    ℤ  p  n     subscript   superscript  ℤ  n   p    \mathbb{Z}^{n}_{p}   , which has size     p  n   =   257  64        superscript  p  n    superscript  257  64     p^{n}=257^{64}   . An output in    ℤ  p  n     subscript   superscript  ℤ  n   p    \mathbb{Z}^{n}_{p}   can easily be represented using 528 bits (66 bytes).  Algebraic description  The SWIFFT functions can be described as a simple algebraic expression over some polynomial ring    R   R   R   . A family of these functions depends on three main parameters: let   n   n   n   be a power of 2, let    m  >  0      m  0    m>0   be a small integer, and let    p  >  0      p  0    p>0   be a modulus (not necessarily prime , but is convenient to choose it prime). Define   R   R   R   to be the ring    R  =     ℤ  p    [  α  ]    /   (    α  n   +  1   )        R       subscript  ℤ  p    delimited-[]  α       superscript  α  n   1      R=\mathbb{Z}_{p}[\alpha]/(\alpha^{n}+1)   , i.e., the ring of polynomials in   α   α   \alpha   having integer coefficients, modulo   p   p   p   and     α  n   +  1       superscript  α  n   1    \alpha^{n}+1   . An element of   R   R   R   can be written as a polynomial of degree having coefficients in    Z  p     subscript  Z  p    Z_{p}   . A certain function in the SWIFFT family is specified by   m   m   m   fixed elements      a  1   ,  …  ,   a  m    ∈  R        subscript  a  1   normal-…   subscript  a  m    R    a_{1},\ldots,a_{m}\in R   of the ring   R   R   R   , that are called multipliers. The function corresponds to the following equation over the ring R :       ∑   i  =  1   m    (    a  i   ⋅   x  i    )       superscript   subscript     i  1    m    normal-⋅   subscript  a  i    subscript  x  i      \sum_{i=1}^{m}(a_{i}\cdot x_{i})     The      x  1   ,  …  ,   x  m    ∈  R        subscript  x  1   normal-…   subscript  x  m    R    x_{1},\ldots,x_{m}\in R   are polynomials with binary coefficients, and corresponding to the binary input of length    m  n      m  n    mn   .  Computing the polynomial product  To compute the above expression, the main problem is to compute the polynomial products     a  i   ⋅   x  i      normal-⋅   subscript  a  i    subscript  x  i     a_{i}\cdot x_{i}   . A fast way to compute these products is given by the convolution theorem . This says that under certain restrictions the following holds:       ℱ   {   f  *  g   }    =     ℱ   {  f  }    ⋅  ℱ    {  g  }          ℱ     f  g        normal-⋅    ℱ   f    ℱ    g      \mathcal{F}\{f*g\}=\mathcal{F}\{f\}\cdot\mathcal{F}\{g\}   Here   ℱ   ℱ   \mathcal{F}   denotes the Fourier transform and   ⋅   normal-⋅   \cdot   denotes the pointwise product. In the general case of the convolution theorem   *     *   does not denote multiplication but convolution . It can however be shown that polynomial multiplication is a convolution.  Fast Fourier Transform  For finding the Fourier transform we will use FFT ( Fast Fourier Transform ) which finds the transform in    O   (   n   log   (  n  )     )       O    n    n      O(n\log(n))   time. The multiplication algorithm now goes as follows: We use FFT to compute (all at once) the Fourier coefficients of each polynomial. Then we pointwise multiply the respective Fourier coefficients of the two polynomials, and finally we us an inverse FFT to return a polynomial of degree .  Number-theoretic transform  Instead of the normal Fourier transform SWIFFT uses the Number-theoretic transform . Number-theoretic transform uses roots of unity in    ℤ  p     subscript  ℤ  p    \mathbb{Z}_{p}   instead of complex roots of unity. To make this work, we need to ensure that    ℤ  p     subscript  ℤ  p    \mathbb{Z}_{p}   is a finite field , and that primitive 2 n th roots of unity exist in this field. This can be done by taking   p   p   p   prime such that    2  n      2  n    2n   divides    p  -  1      p  1    p-1   .  Parameter Choice  The parameters m , p , n are subject to the following restrictions:   n must be a power of 2  p must be prime  p -1 must be a multiple of 2 n      log   (  p  )       p    \log(p)   must be greater than m (otherwise the output will not be smaller than the input)   A possible choice is n =64, m =16, p =257. We get a throughput of about 40MB/s, security of about    2  106     superscript  2  106    2^{106}   operations for finding collisions, and a digest size of 512 bits.  Statistical Properties   (Universal hashing). The SWIFFT family of functions is universal . It means that for any fixed distinct    x  ,  x  *     fragments  x  normal-,  x     x,x*   , the probability (over the random choice of   f   f   f   from the family) that    f   (  x  )   =  f   (  x  *  )      fragments  f   fragments  normal-(  x  normal-)    f   fragments  normal-(  x   normal-)     f(x)=f(x*)   is the inverse of the size of the range.  (Regularity). SWIFFT family of compression functions is regular. A function   f   f   f   is said to be regular if, for an input   x   x   x   chosen uniformly at random from the domain, the output    f   (  x  )       f  x    f(x)   is distributed uniformly over the range.    (Randomness extractor). SWIFFT is a randomness extractor . For hash tables and related applications, it is usually desirable for the outputs of the hash function to be distributed uniformly (or as close to uniformly as possible), even when the inputs are not uniform. Hash functions that give such guarantees are known as randomness extractors , because they distill the non-uniform randomness of the input down to an (almost) uniformly distributed output. Formally, randomness extraction is actually a property of a family of functions, from which one function is chosen at random (and obliviously to the input).   Cryptographic Properties and Security   SWIFFT is not pseudorandom , due to linearity. For any function   f   f   f   from our family and any two inputs    x  1     subscript  x  1    x_{1}   ,    x  2     subscript  x  2    x_{2}   such that     x  1   +   x  2        subscript  x  1    subscript  x  2     x_{1}+x_{2}   is also a valid input, we have that      f   (   x  1   )    +   f   (   x  2   )     =   f   (    x  1   +   x  2    )            f   subscript  x  1      f   subscript  x  2       f     subscript  x  1    subscript  x  2       f(x_{1})+f(x_{2})=f(x_{1}+x_{2})   . This relation is very unlikely to hold for a random function, so an adversary can easily distinguish our functions from a random function.  It is not claimed by the authors that SWIFFT functions behave like a random oracle . A function is said to behave like a random oracle if it acts like a truly random function. This differs from pseudorandomness in that the function is fixed and public.  SWIFFT family is provably collision resistant (in an asymptotic sense), under a relatively mild assumption about the worst-case difficulty of finding short vectors in cyclic/ideal lattices. This implies that the family is also second preimage resistant.   Theoretical Security  SWIFFT is an example of a provably secure cryptographic hash function . As with most security proofs, the security proof of SWIFFT relies on a reduction to a certain difficult to solve mathematical problem. Note that this means that the security of SWIFFT relies strongly on the difficulty of this mathematical problem.  The reduction in the case of SWIFFT is to the problem of finding short vectors in cyclic/ ideal lattices . It can be proven that the following holds: Suppose we have an algorithm that for a random version of SWIFFT given by   f   f   f   can find collisions in   f   f   f   within some feasible time   T   T   T   , and with probability   p   p   p   . It is allowed that the algorithm only works in a small but noticeable fraction of the family SWIFFT. Then we can find also an algorithm    f  2     subscript  f  2    f_{2}   which can always find a short vector in any ideal lattice over the ring      ℤ  p    [  α  ]    /   (    α  n   +  1   )          subscript  ℤ  p    delimited-[]  α       superscript  α  n   1     \mathbb{Z}_{p}[\alpha]/(\alpha^{n}+1)   in some feasible time    T  2     subscript  T  2    T_{2}   , depending on   T   T   T   and   p   p   p   . This means that finding collisions in SWIFFT is at least as difficult as the worst-case scenario of finding short vectors in a lattice over      ℤ  p    [  α  ]    /   (    α  n   +  1   )          subscript  ℤ  p    delimited-[]  α       superscript  α  n   1     \mathbb{Z}_{p}[\alpha]/(\alpha^{n}+1)   . At the moment the fastest algorithms for finding short vectors are all exponential in   n   n   n   . Note that this ensures that there is no significant set of "weak instances" where the security of SWIFFT is weak. This guarantee is not given by most other provably secure hash functions.  Practical Security  Known working attacks are: Generalized Birthday Attack, which takes 2 106 operations and inversion attacks which takes 2 448 operations for a standard parameter choice. This is usually considered to be enough to render an attack by an adversary infeasible.  Notes    References   Vadim Lyubashevsky, Daniele Micciancio, Chris Peikert, Alon Rosen (2008). "SWIFFT: A Modest Proposal for FFT Hashing" .  An ECRYPT hash SWIFFT website. http://ehash.iaik.tugraz.at/wiki/SWIFFT   "  Category:Cryptographic hash functions     ↩  ↩  "SWIFFT: A Modest Proposal for FFT Hashing" ↩     