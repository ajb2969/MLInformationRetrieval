<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="593">Robinson–Foulds metric</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Robinson–Foulds metric</h1>
<hr/>

<p>The <strong>Robinson–Foulds metric</strong> is a way to measure the distance between unrooted <a href="phylogenetic_trees" title="wikilink">phylogenetic trees</a>. It is defined as (A + B) where A is the number of partitions of data implied by the first tree but not the second tree and B is the number of partitions of data implied by the second tree but not the first tree. It is also known as the symmetric difference metric.</p>
<h2 id="explanation">Explanation</h2>

<p>Given two unrooted trees of nodes and a set of labels (i.e., <a class="uri" href="taxa" title="wikilink">taxa</a>) for each node (which could be empty, but only nodes with degree greater than or equal to three can be labeled by an empty set) the Robinson–Foulds metric finds the number of 

<math display="inline" id="Robinson–Foulds_metric:0">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Robinson–Foulds_metric:1">
 <semantics>
  <msup>
   <mi>α</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>α</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{-1}
  </annotation>
 </semantics>
</math>

 operations to convert one into the other. The number of operations defines their distance. The authors define two trees to be the same if they are isomorphic and the isomorphism preserves the labeling. The construction of the proof is based on a function called 

<math display="inline" id="Robinson–Foulds_metric:2">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, which contracts an edge (combining the nodes, creating a union of their sets). Conversely, 

<math display="inline" id="Robinson–Foulds_metric:3">
 <semantics>
  <msup>
   <mi>α</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>α</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{-1}
  </annotation>
 </semantics>
</math>


 expands an edge (decontraction), where the set can be split in any fashion.</p>

<p>The 

<math display="inline" id="Robinson–Foulds_metric:4">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 function removes all edges from 

<math display="inline" id="Robinson–Foulds_metric:5">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}
  </annotation>
 </semantics>
</math>

 that are not in 

<math display="inline" id="Robinson–Foulds_metric:6">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{2}
  </annotation>
 </semantics>
</math>

, creating 

<math display="inline" id="Robinson–Foulds_metric:7">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>1</mn>
   </msub>
   <mo>∧</mo>
   <msub>
    <mi>T</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}\wedge T_{2}
  </annotation>
 </semantics>
</math>

, and then 

<math display="inline" id="Robinson–Foulds_metric:8">
 <semantics>
  <msup>
   <mi>α</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>α</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{-1}
  </annotation>
 </semantics>
</math>


 is used to create edges in 

<math display="inline" id="Robinson–Foulds_metric:9">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>1</mn>
   </msub>
   <mo>∧</mo>
   <msub>
    <mi>T</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}\wedge T_{2}
  </annotation>
 </semantics>
</math>

 to build 

<math display="inline" id="Robinson–Foulds_metric:10">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{2}
  </annotation>
 </semantics>
</math>

. The number of operations in each of these procedures is equivalent to the number of edges in 

<math display="inline" id="Robinson–Foulds_metric:11">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}
  </annotation>
 </semantics>
</math>

 that are not in 

<math display="inline" id="Robinson–Foulds_metric:12">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{2}
  </annotation>
 </semantics>
</math>

 plus the number of edges in 

<math display="inline" id="Robinson–Foulds_metric:13">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{2}
  </annotation>
 </semantics>
</math>


 that are not in 

<math display="inline" id="Robinson–Foulds_metric:14">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}
  </annotation>
 </semantics>
</math>

. The sum of the operations is equivalent to a transformation from 

<math display="inline" id="Robinson–Foulds_metric:15">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Robinson–Foulds_metric:16">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{2}
  </annotation>
 </semantics>
</math>

, or vice versa.</p>
<h2 id="properties">Properties</h2>

<p>In their 1981 paper Robinson and Foulds proved that the distance is in fact a <a href="metric_(mathematics)" title="wikilink">metric</a>.</p>
<h3 id="algorithms-for-computing-the-metric">Algorithms for computing the metric</h3>

<p>In 1985 Day gave an algorithm based on perfect hashing that computes this distance that has only a linear complexity in the number of nodes in the trees. A randomized algorithm that uses hash tables that are not necessarily perfect has been shown to approximate the Robinson-Foulds distance with a bounded error in sublinear time.</p>
<h3 id="specific-applications">Specific applications</h3>

<p>In <a class="uri" href="phylogenetics" title="wikilink">phylogenetics</a>, the metric is often used to compute a distance between two trees. The treedist program in the <a class="uri" href="PHYLIP" title="wikilink">PHYLIP</a> suite offers this function, as does the RAxML_standard package and the DendroPy Python library (under the name "symmetric difference metric"). For comparing groups of trees, the fastest implementations include HashRF and MrsRF.</p>

<p>The Robinson–Foulds metric has also been <a href="Quantitative_comparative_linguistics#Metrics" title="wikilink">used in quantitative comparative linguistics</a> to compute distances between trees that represent how languages are related to each other.</p>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>M. Bourque, Arbres de Steiner et reseaux dont certains sommets sont a localisation variable. PhD thesis, University de Montreal, Montreal, Quebec, 1978 <a class="uri" href="http://www.worldcat.org/title/arbres-de-steiner-et-reseaux-dont-certains-sommets-sont-a-localisation-variable/oclc/053538946">http://www.worldcat.org/title/arbres-de-steiner-et-reseaux-dont-certains-sommets-sont-a-localisation-variable/oclc/053538946</a></li>
<li></li>
<li>William H. E. Day, "Optimal algorithms for comparing trees with labeled leaves", <em>Journal of Classification</em>, Number 1, December 1985. <a class="uri" href="http://www.springerlink.com/content/q5906x80g44p44k8/">http://www.springerlink.com/content/q5906x80g44p44k8/</a></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_phylogenetics" title="wikilink">Category:Computational phylogenetics</a> <a href="Category:Bioinformatics_algorithms" title="wikilink">Category:Bioinformatics algorithms</a></p>
</body>
</html>
