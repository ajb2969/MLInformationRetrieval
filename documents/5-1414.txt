   Finite model theory      Finite model theory   Finite Model Theory (FMT) is a subarea of model theory (MT). MT is the branch of mathematical logic which deals with the relation between a formal language (syntax) and its interpretations (semantics). FMT is a restriction of MT to interpretations of finite structures , which have a finite universe.   Since many central theorems of MT do not hold when restricted to finite structures, FMT is quite different from MT in its methods of proof. Central results of classical model theory that fail for finite structures include the compactness theorem , Gödel's completeness theorem , and the method of ultraproducts for first-order logic (FO).  As MT is closely related to mathematical algebra, FMT became an "unusually effective" 1 instrument in computer science. In other words: "In the history of mathematical logic most interest has concentrated on infinite structures....Yet, the objects computers have and hold are always finite. To study computation we need a theory of finite structures." 2 Thus the main application areas of FMT are: descriptive complexity theory , database theory and formal language theory .  FMT is mainly about discrimination of structures. The usual motivating question is whether a given class of structures can be described (up to isomorphism) in a given language. For instance, can all cyclic graphs be discriminated (from the non-cyclic ones) by a sentence of first-order logic? This can also be phrased as: is the property "cyclic" FO expressible?   Basic Challenges  A single structure can always be axiomatized in first-order logic, where axiomatized in a language L means described uniquely up to isomorphism by a single L-sentence. Some finite sets of structures can also be axiomatized in FO. However, FO is not sufficient to axiomatize any set containing infinite structures.  Characterisation of a Single Structure  Is a language L expressive enough to axiomatize a single finite structure S?  Problem  A structure like (1) in the figure can be described by FO sentences like   Every node has an edge to another node      ∀  x     ∃  y    G   (  x  ,  y  )      .      subscript  for-all  x     subscript   y     G   x  y       \forall_{x}\exists_{y}G(x,y).     No node has an edge to itself     ∀   x  ,  y     (  G   (  x  ,  y  )   ⇒  x  ≠  y  )   .     fragments   subscript  for-all   x  y     fragments  normal-(  G   fragments  normal-(  x  normal-,  y  normal-)   normal-⇒  x   y  normal-)   normal-.    \forall_{x,y}(G(x,y)\Rightarrow x\neq y).     There is at least one node that is connected to all others     ∃  x    ∀  y    (  x  ≠  y  ⇒  G   (  x  ,  y  )   )   .     fragments   subscript   x    subscript  for-all  y    fragments  normal-(  x   y  normal-⇒  G   fragments  normal-(  x  normal-,  y  normal-)   normal-)   normal-.    \exists_{x}\forall_{y}(x\neq y\Rightarrow G(x,y)).      However, these properties do not axiomatize the structure, since for structure (1') the above properties hold as well, yet structures (1) and (1') are not isomorphic.  Informally the question is whether by adding enough properties, these properties together describe exactly (1) and are valid (all together) for no other structure (up to isomorphism).  Approach  For a single finite structure it is always possible to precisely describe the structure by a single FO sentence. The principle is illustrated here for a structure with one binary relation   R   R   R   and without constants:   say that there are at least   n   n   n   elements     φ  1   =    ⋀   i  ≠  j     ¬   (    x  i   =   x  j    )          subscript  φ  1     subscript     i  j         subscript  x  i    subscript  x  j        \varphi_{1}=\bigwedge_{i\neq j}\neg(x_{i}=x_{j})     say that there are at most   n   n   n   elements     φ  2   =   ∀  y    ⋁  i    (   x  i   =  y  )      fragments   subscript  φ  2     subscript  for-all  y    subscript   i    fragments  normal-(   subscript  x  i    y  normal-)     \varphi_{2}=\forall_{y}\bigvee_{i}(x_{i}=y)     state every element of the relation   R   R   R        φ  3   =    ⋀    (   a  i   ,   a  j   )   ∈  R     R   (   x  i   ,   x  j   )          subscript  φ  3     subscript       subscript  a  i    subscript  a  j    R      R    subscript  x  i    subscript  x  j        \varphi_{3}=\bigwedge_{(a_{i},a_{j})\in R}R(x_{i},x_{j})     state every non-element of the relation   R   R   R        φ  4   =    ⋀    (   a  i   ,   a  j   )   ∉  R     ¬  R   (   x  i   ,   x  j   )          subscript  φ  4     subscript       subscript  a  i    subscript  a  j    R       R    subscript  x  i    subscript  x  j        \varphi_{4}=\bigwedge_{(a_{i},a_{j})\notin R}\neg R(x_{i},x_{j})      all for the same tuple     x  1   .  .   x  n      fragments   subscript  x  1   normal-.  normal-.   subscript  x  n     x_{1}..x_{n}   , yielding the FO sentence     ∃   x  1     …    ∃   x  n     (    φ  1   ∧   φ  2   ∧   φ  3   ∧   φ  4    )         subscript    subscript  x  1      normal-…    subscript    subscript  x  n       subscript  φ  1    subscript  φ  2    subscript  φ  3    subscript  φ  4        \exists_{x_{1}}\dots\exists_{x_{n}}(\varphi_{1}\land\varphi_{2}\land\varphi_{3%
 }\land\varphi_{4})   .  Extension to a fixed Number of Structures  The method of describing a single structure by means of a first-order sentence can easily be extended for any fixed number of structures. A unique description can be obtained by the disjunction of the descriptions for each structure. For instance, for 2 structures this would be         ∃   x  1     …    ∃   x  n     (    φ  1   ∧   φ  2   ∧   φ  3   ∧   φ  4    )      ∨    ∃   x  1     …    ∃   x  n     (    ϱ  1   ∧   ϱ  2   ∧   ϱ  3   ∧   ϱ  4    )       .        subscript    subscript  x  1      normal-…    subscript    subscript  x  n       subscript  φ  1    subscript  φ  2    subscript  φ  3    subscript  φ  4         subscript    subscript  x  1      normal-…    subscript    subscript  x  n       subscript  ϱ  1    subscript  ϱ  2    subscript  ϱ  3    subscript  ϱ  4         \exists_{x_{1}}...\exists_{x_{n}}(\varphi_{1}\land\varphi_{2}\land\varphi_{3}%
 \land\varphi_{4})\lor\exists_{x_{1}}...\exists_{x_{n}}(\varrho_{1}\land\varrho%
 _{2}\land\varrho_{3}\land\varrho_{4}).     Extension to an infinite Structure  By definition, a set containing an infinite structure falls outside the area that FMT deals with. Note that infinite structures can never be discriminated in FO because of the compactness theorem of classical MT: for every infinite model a non-isomorphic one can be found, but which has exactly the same FO properties.  The most famous example is probably Skolem's theorem , that there is a countable non-standard model of arithmetic.  Characterisation of a Class of Structures  Is a language L expressive enough to describe exactly those finite structures that have certain property P in common (up to isomorphism)?  Problem  The descriptions given so far all specify the number of elements of the universe. Unfortunately most interesting sets of structures are not restricted to a certain size, like all graphs that are trees, are connected or are acyclic. Thus to discriminate a finite number of structures is of special importance.  Approach  Instead of a general statement, the following is a sketch of a methodology to differentiate between structures that can and cannot be discriminated.  1. The core idea is that whenever one wants to see if a Property P can be expressed in FO, one chooses structures A and B, where A does have P and B doesn't. If for A and B the same FO sentences hold, then P cannot be expressed in FO (else it can). In short:       A  ∈  P   ,   B  ∉  P      formulae-sequence    A  P     B  P     A\in P,B\not\in P   and    A  ≡  B      A  B    A\equiv B     where    A  ≡  B      A  B    A\equiv B   is shorthand for     A  ⊧  α   ⇔   B  ⊧  α      normal-⇔   models  A  α    models  B  α     A\models\alpha\Leftrightarrow B\models\alpha   for all FO-sentences α, and P represents the class of structures with property P.  2. The methodology considers countably many subsets of the language, the union of which forms the language itself. For instance, for FO consider classes FO[m] for each m. For each m the above core idea then has to be shown. That is:       A  ∈  P   ,   B  ∉  P      formulae-sequence    A  P     B  P     A\in P,B\not\in P   and    A   ≡  m   B      subscript   m   A  B    A\equiv_{m}B     with a pair    A  ,  B     A  B    A,B   for each   m   m   m   and α (in ≡) from FO[m]. It may be appropriate to choose the classes FO[m] to form a partition of the language.  3. One common way to define FO[m] is by means of the quantifier rank qr(α) of a FO formula α, which expresses the depth of quantifier nesting. For example for a formula in prenex normal form , qr is simply the total number of its quantifiers. Then FO[m] can be defined as all FO formulas α with qr(α) ≤ m (or, if a partition is desired, as those FO formulas with quantifier rank equal to m).  4. Thus it all comes down to showing     A  ⊧  α   ⇔   B  ⊧  α      normal-⇔   models  A  α    models  B  α     A\models\alpha\Leftrightarrow B\models\alpha   on the subsets FO[m]. The main approach here is to use the algebraic characterization provided by Ehrenfeucht–Fraïssé games . Informally, these take a single partial isomorphism on A and B and extend it m times, in order to either prove or disprove    A   ≡  m   B      subscript   m   A  B    A\equiv_{m}B   , dependent on who wins the game.  Example  We want to show that the property that the size of an orderered structure A =(A, ≤) is even, can not be expressed in FO.  1. The idea is to pick A ∈ EVEN and B ∉ EVEN, where EVEN is the class of all structures of even size.  2. We start with 2 ordered structures A 2 and B 2 with universes A 2 = {1, 2, 3, 4} and B 2 = {1, 2, 3, 4, 5}. Obviously A 2 ∈ EVEN and B 2 ∉ EVEN.  3. For m = 2, we can now show* that in a 2-move Ehrenfeucht–Fraïssé game on A 2 and B 2 the duplicator always wins, and thus A 2 and B 2 cannot be discriminated in FO[2], i.e. A 2    ⊧   models   \models   α ⇔ B 2    ⊧   models   \models   α for every α ∈ FO[2].  4. Next we have to scale the structures up by increasing m. For example, for m = 3 we must find an A 3 and B 3 such that the duplicator always wins the 3-move game. This can be achieved by A 3 = {1, ..., 8} and B 3 = {1, ..., 9}. More generally, we can choose A m = {1, ..., 2 m } and B m = {1, ..., 2 m +1}; for any m the duplicator always wins the m-move game for this pair of structures*.  5. Thus EVEN on finite ordered structures cannot be expressed in FO.  (*) Note that the proof of the result of the Ehrenfeucht–Fraïssé game has been omitted, since it is not the main focus here.  Applications  Database Theory  A substantial fragment of SQL (namely that which is effectively relational algebra ) is based on first-order logic (more precisely can be translated in domain relational calculus by means of Codd's theorem ), as the following example illustrates: Think of a database table "GIRLS" with the columns "FIRST_NAME" and "LAST_NAME". This corresponds to a binary relation, say G(f, l) on FIRST_NAME X LAST_NAME. The FO query {l : G('Judy', l)} , which returns all the last names where the first name is 'Judy', would look in SQL like this:  select LAST_NAME  from GIRLS  where FIRST_NAME = 'Judy'  Notice, we assume here, that all last names appear only once (or we should use SELECT DISTINCT since we assume that relations and answers are sets, not bags).  Next we want to make a more complex statement. Therefore in addition to the "GIRLS" table we have a table "BOYS" also with the columns "FIRST_NAME" and "LAST_NAME". Now we want to query the last names of all the girls that have the same last name as at least one of the boys. The FO query is {(f,l) : ∃h ( G(f, l) ∧ B(h, l) )} , and the corresponding SQL statement is:  select FIRST_NAME, LAST_NAME  from GIRLS  where LAST_NAME IN ( select LAST_NAME from BOYS );  Notice that in order to express the "∧" we introduced the new language element "IN" with a subsequent select statement. This makes the language more expressive for the price of higher difficulty to learn and implement. This is a common trade-off in formal language design. The way shown above ("IN") is by far not the only one to extend the language. An alternative way is e.g. to introduce a "JOIN" operator, that is:  select distinct g.FIRST_NAME, g.LAST_NAME  from GIRLS g, BOYS b  where g.LAST_NAME=b.LAST_NAME;  First-order logic is too restrictive for some database applications, for instance because of its inability to express transitive closure . This has led to more powerful constructs being added to database query languages, such as recursive WITH in SQL:1999 . More expressive logics, like fixpoint logics , have therefore been studied in finite model theory because of their relevance to database theory and applications.  Querying & Search  Narrative data contains no defined relations. Thus the logical structure of text search queries can be expressed in Propositional Logic, like in:  ("Java" AND NOT "island") OR ("C#" AND NOT "music")  Note that the challenges in full text search are different from database querying, like ranking of results.  History   Trakhtenbrot 1950 : failure of completeness theorem in FO,  Scholz 1952: characterisation of spectra in FO,  Fagin 1974 : the set of all properties expressible in existential second-order logic is precisely the complexity class NP,  Chandra, Harel 1979/ 80: fixed-point FO extension for db query languages capable of expressing transitive closure -> queries as central objects of FMT.  Immerman , Vardi 1982: fixed point logic over ordered structures captures PTIME -> descriptive complexity (... Immerman–Szelepcsényi theorem )  Ebbinghaus , Flum 1995: First comprehensive book "Finite Model Theory"  Abiteboul , Hull, Vianu 1995: Book "Foundations of Databases"  Immerman 1999: Book "Descriptive Complexity"  Kuper, Libkin, Paredaens 2000: Book "Constraint Databases"  Darmstadt 2005/ Aachen2006: first international workshops on "Algorithmic Model Theory"   Citations    References              Further reading     External links    Also suitable as a general introduction and overview.  Leonid Libkin. Introductory chapter of "Elements of Finite Model Theory" . Motivates three main application areas: databases, complexity and formal languages.  Jouko Väänänen. A Short Course on Finite Model Theory . Department of Mathematics, University of Helsinki. Based on lectures from 1993-1994.  Anuj Dawar. Infinite and Finite Model Theory , slides, University of Cambridge, 2002.   Includes a list of open FMT problems.   "         ↩  ↩     