   Trakhtenbrot's theorem      Trakhtenbrot's theorem   In Logic , finite model theory , and Computability Theory , Trakhtenbrot's theorem (due to Boris Trakhtenbrot ) states that the problem of validity in First-order logic (FO) on the class of all finite models is undecidable . In fact, the class of valid sentences over finite models is not recursively enumerable (though it is co-recursively enumerable ).  It is considered a very important result, since it implies that the completeness theorem (that is fundamental to FO) does not hold in the finite case. Also it seems counter intuitive that being valid over all structures is 'easier' than over just the finite ones.  The Theorem was first published in 1950: "The Impossibility of an Algorithm for the Decidability Problem on Finite Classes". 1  Mathematical Formulation  We follow the formulations as in 2  Theorem   Finite Satisfiability is not decidable in First-order logic (FO).   Remarks   That is, the set { φ | φ is a sentence of FO satisfiable in the finite } is not decidable.   Corollary  Let σ be a relational vocabulary with one at least binary relation symbol.   The set of σ-sentences valid in all finite structures is not recursively enumerable .   Remarks   That is, the set { φ | φ is a sentence of FO[σ] valid in all finite structures } is not recursively enumerable .  This implies that Gödel's completeness theorem fails in the finite. (since completeness implies recursive enumerability)  It follows that there is no recursive function f such that: if Φ has a finite model, then it has a model of size at most f(Φ). In other words, there is no effective analogue to the Löwenheim-Skolem theorem in the finite.   Alternative Proof  In this section we exhibit an alternative proof from Libkin. 3 Note in the above statement that the corollary also entails the theorem, and this is the direction we prove here.  Theorem   For every relational vocabulary τ with at least one binary relation symbol, it is undecidable whether a sentence φ of vocabulary τ is finitely satisfiable.   Proof  According to the previous lemma, we can in fact use finitely many binary relation symbols. The idea of the proof is similar to the proof of Fagin's theorem, and we encode Turing machines in first order logic. What we want to prove is that for every Turing machine M we construct a sentence φ M of vocabulary τ such that φ M is finitely satisfiable if and only if M halts on the empty input, which is equivalent to the halting problem and therefore undecidable.  Let M= ⟨Q, Σ, δ, q 0 , Q a , Q r ⟩ be a deterministic Turing machine with a single infinite tape.   Q is the set of states,  Σ is the input alphabet,  Δ is the tape alphabet,  δ is the transition function,  q 0 is the initial state,  Q a and Q r are the sets of accepting and rejecting states.   Since we are dealing with the problem of halting on an empty input we may assume w.l.o.g. that Δ={0,1} and that 0 represents a blank, while 1 represents some tape symbol. We define τ so that we can represent computations:   τ := {min, T 0 (⋅,⋅), T 1 (⋅,⋅), (H q (⋅,⋅)) (q ∈ Q) }   Where:   min is a constant symbol for the minimal element with respect to < (our finite domain will be associated with an initial segment of the natural numbers).  T 0 and T 1 are tape predicates. T i (s,t) indicates that position s at time t contains i, where i ∈ {0,1}.  H q 's are head predicates. H q (s,t) indicates that at time t the machine is in state q, and its head is in position s.   The sentence φ M states that (i) min, T i 's and H q 's are interpreted as above and (ii) that the machine eventually halts. The halting condition is equivalent to saying that H q∗ (s, t) holds for some s, t and q∗ ∈ Q a ∪ Q r and after that state, the configuration of the machine does not change. Configurantions of a halting machine (the nonhalting is not finite) can be represented as a τ (finite) sentence (more precisely, a finite τ-structure which satisfies the sentence). The sentence φ M is: φ ≡ α ∧ β ∧ γ ∧ η ∧ ζ ∧ θ.  We break it down by components:   α states that min is its minimal element    γ defines the initial configuration of M: it is in state q 0 , the head is in the first position and the tape contains only zeros: γ ≡ H q 0 ( min , min ) ∧ ∀s T 0 (s, min )    η states that in every configuration of M, each tape cell contains exactly one element of Δ: ∀s∀t(T 0 (s, t) → ¬ T 1 (s, t))    β imposes a basic consistency condition on the predicates H q 's: at any time the machine is in exactly one state:        ∀   t    ∃  !    s   (    ⋁   q  ∈  Q      H  q    (  s  ,  t  )     )       ∧   ¬   ∃   s   ∃   t   (     ⋁     q  ,   q  ′    ∈  Q   ,   q  ≠  q       H  q    (  s  ,  t  )     ∧    H   q  ′     (  s  ,  t  )     )             for-all    t         s    subscript     q  Q       subscript  H  q    s  t                s      t      subscript    formulae-sequence     q   superscript  q  normal-′    Q     q  q        subscript  H  q    s  t        subscript  H   superscript  q  normal-′     s  t            \forall t\exists!s(\bigvee_{q\in Q}H_{q}(s,t))\land\neg\exists s\exists t(%
 \bigvee_{q,q^{\prime}\in Q,q\neq q}H_{q}(s,t)\land H_{q^{\prime}}(s,t))      ζ states that at some point M is in a halting state:       ∃   s   ∃   t    ⋁   q  ∈    Q  a   ∪   Q  r        H  q    (  s  ,  t  )              s      t    subscript     q     subscript  Q  a    subscript  Q  r         subscript  H  q    s  t          \exists s\exists t\bigvee_{q\in Q_{a}\cup Q_{r}}H_{q}(s,t)      θ consists of a conjunction of sentences stating that T i 's and H q 's are well behaved with respect to the transitions of M. As an example, let δ(q,0)=(q',1, left) meanining that if M is in state q reading 0, then it writes 1, moves the head one position to the left and goes into the state q'. We represent this condition by the disjunction of θ 0 and θ 1 :        θ  0   ≡  ∀  s  ∀  t   (  s  ≠    m  i  n   ¯   ∧   T  0    (  s  ,  t  )   ∧   H  q    (  s  ,  t  )   )   →   θ  2      fragments   subscript  θ  0    for-all  s  for-all  t   fragments  normal-(  s    normal-¯    m  i  n      subscript  T  0    fragments  normal-(  s  normal-,  t  normal-)     subscript  H  q    fragments  normal-(  s  normal-,  t  normal-)   normal-)   normal-→   subscript  θ  2     \theta_{0}\equiv\forall s\forall t(s\neq\underline{min}\land T_{0}(s,t)\land H%
 _{q}(s,t))\to\theta_{2}     Where θ 2 is:       T  1    (  s  ,  t  +  1  )   ∧   H   q  ′     (  s  -  1  ,  t  +  1  )   ∧  ∀   s  ′    (  s  ≠   s  ′   →   (   ⋀   i  =   0  ,  1      T  i    (   s  ′   ,  t  +  1  )   ↔   T  i    (   s  ′   ,  t  )   )   )      fragments   subscript  T  1    fragments  normal-(  s  normal-,  t   1  normal-)     subscript  H   superscript  q  normal-′     fragments  normal-(  s   1  normal-,  t   1  normal-)    for-all   superscript  s  normal-′    fragments  normal-(  s    superscript  s  normal-′   normal-→   fragments  normal-(   subscript     i   0  1      subscript  T  i    fragments  normal-(   superscript  s  normal-′   normal-,  t   1  normal-)   normal-↔   subscript  T  i    fragments  normal-(   superscript  s  normal-′   normal-,  t  normal-)   normal-)   normal-)     T_{1}(s,t+1)\land H_{q^{\prime}}(s-1,t+1)\land\forall s^{\prime}(s\neq s^{%
 \prime}\to(\bigwedge_{i=0,1}T_{i}(s^{\prime},t+1)\leftrightarrow T_{i}(s^{%
 \prime},t)))     And:       θ  1   ≡  ∀  s  ∀  t   (  s  =    m  i  n   ¯   ∧   T  0    (  s  ,  t  )   ∧   H  q    (  s  ,  t  )   )   →   θ  3      fragments   subscript  θ  1    for-all  s  for-all  t   fragments  normal-(  s    normal-¯    m  i  n      subscript  T  0    fragments  normal-(  s  normal-,  t  normal-)     subscript  H  q    fragments  normal-(  s  normal-,  t  normal-)   normal-)   normal-→   subscript  θ  3     \theta_{1}\equiv\forall s\forall t(s=\underline{min}\land T_{0}(s,t)\land H_{q%
 }(s,t))\to\theta_{3}     Where θ 3 is:       T  1    (  s  ,  t  +  1  )   ∧   H   q  ′     (  s  ,  t  +  1  )   ∧  ∀   s  ′    (  s  ≠   s  ′   →   (   ⋀   i  =   0  ,  1      T  i    (   s  ′   ,  t  +  1  )   ↔   T  i    (   s  ′   ,  t  )   )   )      fragments   subscript  T  1    fragments  normal-(  s  normal-,  t   1  normal-)     subscript  H   superscript  q  normal-′     fragments  normal-(  s  normal-,  t   1  normal-)    for-all   superscript  s  normal-′    fragments  normal-(  s    superscript  s  normal-′   normal-→   fragments  normal-(   subscript     i   0  1      subscript  T  i    fragments  normal-(   superscript  s  normal-′   normal-,  t   1  normal-)   normal-↔   subscript  T  i    fragments  normal-(   superscript  s  normal-′   normal-,  t  normal-)   normal-)   normal-)     T_{1}(s,t+1)\land H_{q^{\prime}}(s,t+1)\land\forall s^{\prime}(s\neq s^{\prime%
 }\to(\bigwedge_{i=0,1}T_{i}(s^{\prime},t+1)\leftrightarrow T_{i}(s^{\prime},t)))     s-1 and t+1 are first order definable abbreviations for the predecessor and successor according to the ordering <. sentence="" the="">0 assures that the tape content in position s changes from 0 to 1, the state changes from q to q', the rest of the tape remains the same and that the head moves to s-1 (i. e. one position to the left), assuming s is not the first position in the tape. If it is, then all is handled by θ 1 : everything is the same, except the head does not move to the left but stays put. .  If φ M has a finite model, then such a model that represents a computation of M (that starts with the empty tape (i.e. tape containing all zeros) and ends in a halting state). If M halts on the empty input, then the set of all configurations of the halting computations of M (coded with i's and H q 's) is a model of φ M , which is finite, since the set of all configurations of halting computations is finite. It follows that M halts on the empty input iff φ M has a finite model. Since halting on the empty input is undecidable, so is the question of whether φ M has a finite model   𝒜   𝒜   \mathcal{A}   (equivalently, whether φ M is finitely satisfiable) is also undecidable (recursively enumerable, but not recursive). This concludes the proof.  Corollary   The set of finitely satisfiable sentences is recursively enumerable.   Proof  Enumerate all pairs    (  𝒜  ,  ϕ  )     𝒜  ϕ    (\mathcal{A},\phi)   where   𝒜   𝒜   \mathcal{A}   is finite and    𝒜  ⊧  ϕ     models  𝒜  ϕ    \mathcal{A}\models\phi   .  Corollary   For any vocabulary containing at least one binary relation symbol, the set of all finitely valid sentences is not recursively enumerable.   Proof  From the previous lemma, the set of finitely satisfiable sentences is recursively enumerable. Assume that the set of all finitely valid sentences is recursively enumerable. Since ¬φ is finitely valid iff φ is not finitely satisfiable, we conclude that the set of sentences which are not finitely satisfiable is recursively enumerable. If both a set A and its complement are recursively enumerable, then A is recursive. It follows that the set of finitely satisfiable sentences is recursive, which contradicts Trakhtenbrot's theorem.  References     Boolos, Burgess, Jeffrey. Computability and Logic , Cambridge University Press, 2002.  Simpson, S. "Theorems of Church and Trakhtenbrot". 2001. 1   "  Category:Finite model theory  Category:Computability theory     ↩  ↩  ↩     