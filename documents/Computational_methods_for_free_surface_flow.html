<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1365">Computational methods for free surface flow</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Computational methods for free surface flow</h1>
<hr/>

<p>In physics, a free surface flow is the surface of a fluid flowing that is subjected to both zero perpendicular normal stress and parallel shear stress. This can be the boundary between two homogeneous fluids, like water in an open container and the air in the Earth's atmosphere that form a boundary at the open face of the container. Computation of free surfaces is complex because of the continuous change in the location of the boundary layer. Conventional methods of computation are insufficient for such analysis. Therefore, special methods are developed for the computation of free surface flows.</p>
<h2 id="introduction">Introduction</h2>

<p>Computation in flows with free and moving boundaries like the <a href="open-channel_flow" title="wikilink">open-channel flow</a> is a difficult task. The position of the boundary is known only at the initial time and its location at later times can be determined as using various methods like the Interface Tracking Method and the Interface Capturing Method.</p>
<h2 id="boundary-conditions">Boundary conditions</h2>

<p>Neglecting the phase change at the free surface, the following boundary conditions apply.</p>
<h3 id="kinematic-condition">Kinematic condition</h3>

<p>The free surface should be a sharp boundary separating the two fluids. There should be no flow through this boundary, i.e. ,<br/>


<math display="block" id="Computational_methods_for_free_surface_flow:0">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>-</mo>
    <mi>v</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-[</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <minus></minus>
     <csymbol cd="unknown">v</csymbol>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [(v-v
  </annotation>
 </semantics>
</math>

<sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:1">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

</sub>)

<math display="inline" id="Computational_methods_for_free_surface_flow:2">
 <semantics>
  <mrow>
   <mo>.</mo>
   <mi>n</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .n]
  </annotation>
 </semantics>
</math>

<sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:3">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   fs
  </annotation>
 </semantics>
</math>

</sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:4">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =0,
  </annotation>
 </semantics>
</math>

 or</p>
<dl>
<dd>ṁ<sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:5">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   fs
  </annotation>
 </semantics>
</math>

</sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:6">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =0
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>where <strong>‘fs’</strong> stands for free surface. This implies that the normal component of the velocity of the fluid at the surface is equal to the normal component of the velocity of the free surface.</p>
<h3 id="dynamic-condition">Dynamic condition</h3>

<p>The forces acting on the fluid at free surface should be in equilibrium, i.e. the momentum is conserved at the free surface. The normal forces on either side of the free surface are equal and opposite in direction and the forces in tangential direction should be equal in magnitude and direction.</p>
<dl>
<dd><big><big>

<math display="inline" id="Computational_methods_for_free_surface_flow:7">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mo>.</mo>
    <mi>T</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <ci>n</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n.T)
  </annotation>
 </semantics>
</math>

<sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:8">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

</sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:9">
 <semantics>
  <mrow>
   <mo>.</mo>
   <mi>n</mi>
   <mo>+</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">n</csymbol>
    <plus></plus>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .n+
  </annotation>
 </semantics>
</math>

σ

<math display="inline" id="Computational_methods_for_free_surface_flow:10">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mo>-</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>.</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">K</csymbol>
    <eq></eq>
    <minus></minus>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=-(n.T)
  </annotation>
 </semantics>
</math>

<sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:11">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

</sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:12">
 <semantics>
  <mrow>
   <mo>.</mo>
   <mi>n</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .n,
  </annotation>
 </semantics>
</math>


</big></big></dd>
<dd>

<math display="inline" id="Computational_methods_for_free_surface_flow:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mo>.</mo>
    <mi>T</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <ci>n</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n.T)
  </annotation>
 </semantics>
</math>

<sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:14">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

</sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:15">
 <semantics>
  <mrow>
   <mo>.</mo>
   <mi>t</mi>
   <mo>-</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">t</csymbol>
    <minus></minus>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .t-
  </annotation>
 </semantics>
</math>



<math display="inline" id="Computational_methods_for_free_surface_flow:16">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">∂</mi>
    <mi>σ</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">∂</mi>
    <mi>t</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>normal-∂</ci>
     <ci>σ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-∂</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{∂σ}{∂t}
  </annotation>
 </semantics>
</math>



<math display="inline" id="Computational_methods_for_free_surface_flow:17">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>.</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(n.T)
  </annotation>
 </semantics>
</math>

<sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:18">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

</sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:19">
 <semantics>
  <mrow>
   <mo>.</mo>
   <mi>t</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">t</csymbol>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .t,
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Computational_methods_for_free_surface_flow:20">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mo>.</mo>
    <mi>T</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <ci>n</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n.T)
  </annotation>
 </semantics>
</math>

<sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:21">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

</sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:22">
 <semantics>
  <mrow>
   <mo>.</mo>
   <mi>s</mi>
   <mo>-</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">s</csymbol>
    <minus></minus>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .s-
  </annotation>
 </semantics>
</math>



<math display="inline" id="Computational_methods_for_free_surface_flow:23">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">∂</mi>
    <mi>σ</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">∂</mi>
    <mi>s</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>normal-∂</ci>
     <ci>σ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-∂</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{∂σ}{∂s}
  </annotation>
 </semantics>
</math>



<math display="inline" id="Computational_methods_for_free_surface_flow:24">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>.</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(n.T)
  </annotation>
 </semantics>
</math>

<sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:25">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

</sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:26">
 <semantics>
  <mrow>
   <mo>.</mo>
   <mi>s</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   .s,
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Here <strong>σ</strong> is the surface tension, <strong>n</strong>, <strong>t</strong> and <strong>s</strong> are unit vectors in a local orthogonal coordinate system (<strong>n</strong>,<strong>t</strong>,<strong>s</strong>) at the free surface (<strong>n</strong> is outward normal to the free surface while the other two lie in the tangential plane and are mutually orthogonal). The indices <strong>'l</strong>' and <strong>'g</strong>' denote liquid and gas, respectively and <strong>K</strong> is the curvature of the free surface.</p>
<dl>
<dd><big> 

<math display="inline" id="Computational_methods_for_free_surface_flow:27">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=
  </annotation>
 </semantics>
</math>

<mtpl></mtpl>

<math display="inline" id="Computational_methods_for_free_surface_flow:28">
 <semantics>
  <mo>+</mo>
  <annotation-xml encoding="MathML-Content">
   <plus></plus>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +
  </annotation>
 </semantics>
</math>

<mtpl></mtpl> </big>
</dd>
</dl>

<p>with <strong>R<sub>t</sub></strong> and <strong>R<sub>s</sub></strong> being radii of curvature along coordinates <strong>t</strong> and <strong>s</strong>.</p>

<p>The <a href="surface_tension" title="wikilink">surface tension</a> <strong>σ</strong> is force per unit length of a surface element and acts tangential to the free surface.</p>

<p>

<math display="block" id="Computational_methods_for_free_surface_flow:29">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

<sub>σ</sub> = σ 

<math display="inline" id="Computational_methods_for_free_surface_flow:30">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>l</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dl
  </annotation>
 </semantics>
</math>

 For an infinitesimally small surface element <strong>dS</strong>, the tangential components of the surface tension forces cancel out when <strong>σ = constant</strong>, and the normal component can be expressed as a local force that results in a pressure jump across the surface.</p>
<h2 id="methods-of-computation">Methods of computation</h2>
<h3 id="interface-tracking-method">Interface tracking method</h3>

<p>This is a methods which treat the free surface as a sharp interface whose motion is followed. In this method, boundary-fitted grids are used and advanced each time the free surface is moved.<br/>
Interface tracking method is useful in situations like calculation of flow around submerged bodies. This is done by linearizing about unperturbed free surface, so a height function is introduced for the free surface elevation relative to its unperturbed state.</p>

<p>

<math display="block" id="Computational_methods_for_free_surface_flow:31">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <times></times>
     <ci>H</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=H(x,y,t)
  </annotation>
 </semantics>
</math>

 This gives the kinematic boundary condition a new form:<br/>
: <big><big>

<math display="inline" id="Computational_methods_for_free_surface_flow:32">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">∂</mi>
    <mi>H</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">∂</mi>
    <mi>t</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>normal-∂</ci>
     <ci>H</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-∂</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{∂H}{∂t}
  </annotation>
 </semantics>
</math>

 = u<sub>z</sub> - u<sub>x</sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:33">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">∂</mi>
    <mi>H</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">∂</mi>
    <mi>x</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>normal-∂</ci>
     <ci>H</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-∂</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{∂H}{∂x}
  </annotation>
 </semantics>
</math>

 - u<sub>y</sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:34">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">∂</mi>
    <mi>H</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">∂</mi>
    <mi>y</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>normal-∂</ci>
     <ci>H</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-∂</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{∂H}{∂y}
  </annotation>
 </semantics>
</math>

</big></big> This equation can be integrated and the fluid velocity at free surface can be obtained either by extrapolation from the interior or by using dynamic boundary condition. For the calculation of flow, FV method is widely used. The steps for a fully conservative FV method of this type are:</p>
<ul>
<li>momentum equation is solved to obtain velocity 

<math display="inline" id="Computational_methods_for_free_surface_flow:35">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

<sub>

<math display="inline" id="Computational_methods_for_free_surface_flow:36">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

</sub><sup>

<math display="inline" id="Computational_methods_for_free_surface_flow:37">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

</sup> at the current free surface using specified pressure.</li>
<li>Local mass conservation is enforced in each CV by solving a pressure-correction equation. Mass is conserved both globally and locally, but velocity-correction is produced at free surface giving a non-zero mass flux.</li>
<li>Position of free surface is corrected to compensate for the non-zero mass flux with the volume flux due to the movement of the each free-surface cell face by enforcing the kinematic boundary conditions.</li>
<li>Iterate until no further correction is needed, satisfying the continuity and momentum equations.</li>
<li>Advance to the next time step.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
</ul>

<p>The main problem with the algorithm in this procedure is that there is only one equation for one cell but large number of grid nodes moving. To avoid instability and wave reflection, the method is modified as follows:<br/>
From the previous steps, we can calculate the volume of fluid to be flowed in or out of the CV to have mass conservation. To obtain the coordinates of CV vertices at free surface, we have more unknowns and less equations due to single volumetric flow rate for each cell.</p>

<p>Hence the CVs are defined by the cell face centers rather than vertices and vertices are obtained by interpolation. This gives a tridiagonal system for 2D and can be solved using <a href="Tridiagonal_matrix_algorithm" title="wikilink">TDMA method</a>. For 3D, the system is block tridiagonal and is best solved by one of the iterative solvers.</p>
<h3 id="interface-capturing-method">Interface capturing method</h3>

<p>In computation of two-fluid flows, in some cases the interface might be too complex to track while keeping the frequency of re-meshing at an acceptable level. Not being able to reduce the frequency of re-meshing in 3D might introduce overwhelming mesh generation and projection costs, making the computations with the interface-tracking technique no longer feasible. In such cases, interface-capturing techniques, which do not normally require costly mesh update steps, could be used with the understanding that the interface will not be represented as accurately as we would have with an interface-tracking technique.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Methods which do not define the interface as sharp boundary. A fixed grid extends beyond the free surface over which the computation is performed. To determine the shape of the free surface, the fraction of each cell near the interface is computed that is partially filled.</p>
<h4 id="marker-and-cell-or-mac-scheme">Marker-and-cell or MAC Scheme</h4>

<p><a href="Marker-and-cell_method" title="wikilink">MAC</a> scheme was proposed by Harlow and Welch in 1965. In this method, a massless particle is introduced at the initial time at the free surface. The motion of this massless particle is followed with the passage of time.</p>

<p><strong>Benefit:</strong> This scheme can treat complex phenomena like wave breaking.</p>

<p><strong>Drawback:</strong> In three dimensional flow solving the equations governing fluid flow and also following the motion of a large number of markers both simultaneously demands high computational power.</p>
<h4 id="volume-of-fluid-or-vof-scheme">Volume-of-fluid or VOF scheme</h4>

<p><a href="Volume_of_fluid_method" title="wikilink">VOF</a> scheme was proposed by Hirt and Nichols in 1981. In this method, fraction of the cell occupied by the liquid phase can be calculated by solving the transport equation.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The transport equation is:</p>
<dl>
<dd><big><big>

<math display="inline" id="Computational_methods_for_free_surface_flow:38">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">∂</mi>
    <mi>c</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">∂</mi>
    <mi>t</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>normal-∂</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-∂</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{∂c}{∂t}
  </annotation>
 </semantics>
</math>

 + div(cv) = 0</big></big>
</dd>
</dl>

<p>where c is the fraction of control volume filled. c=1 for completely filled and c = 0 for completely empty control volumes.<br/>
So in total, for VOF method, one has to solve three forms of equations, conservation equations for mass, conservation equations for momentum, equation for filled fraction for each control volume.</p>

<p><em><strong>NOTE</strong>: IN INCOMPRESSIBLE FLOWS, ABOVE EQUATION GIVES SAME RESULTS WITH c AND 1 - c MAKING THE ENFORCEMENT OF MASS CONSERVATION A MUST.</em></p>

<p>Since the higher order schemes are preferred over lower order schemes to prevent artificial mixing of the two fluids, it is important to prevent the overshoots and undershoots due to the condition 0 ≤ c ≤ 1. For such problems, modifications were made to MAC and VOF schemes.</p>
<h4 id="modifications-to-mac-and-vof-scheme">Modifications to MAC and VOF scheme</h4>

<p>Marker and micro-cell method in which local grid refinement is done according to the following criteria:</p>

<p>only the cells having 0 </p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Ferziger, Joel H., and Milovan Perić. Computational methods for fluid dynamics. Vol. 3. Berlin: Springer, 2002.<a href="#fnref1">↩</a></li>
<li id="fn2">Tezduyar, T. "Interface-tracking and interface-capturing techniques for computation of moving boundaries and interfaces." Proceedings of the Fifth World Congress on Computational Mechanics, On-line publication: <a class="uri" href="http://wccm">http://wccm</a>. tuwien. ac. at/, Paper-ID. Vol. 81513. 2002.<a href="#fnref2">↩</a></li>
<li id="fn3">Hirt, C.W.; Nichols, B.D. (1981), Volume of fluid (VOF) method for the dynamics of free boundaries, Journal of Computational Physics 39 (1): 201–225,Bibcode:1981JCoPh..39..201H, <a class="uri" href="doi:10.1016/0021-9991(81)90145-5">doi:10.1016/0021-9991(81)90145-5</a><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
