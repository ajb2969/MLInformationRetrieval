<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1793">Leibniz operator</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Leibniz operator</h1>
<hr/>

<p>In <a href="abstract_algebraic_logic" title="wikilink">abstract algebraic logic</a> the <strong>Leibniz operator</strong> is a tool used to classify <a href="deductive_system" title="wikilink">deductive systems</a>, which have a precise technical definition, and capture a large number of logics. The Leibniz operator was introduced by <a href="Willem_Blok" title="wikilink">Willem Blok</a> and <a href="Don_Pigozzi" title="wikilink">Don Pigozzi</a>, two of the founders of the field, as a means to abstract the well-known <a href="Lindenbaum-Tarski_algebra" title="wikilink">Lindenbaum-Tarski process</a>, that leads to the association of <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebras</a> to classical <a href="propositional_calculus" title="wikilink">propositional calculus</a>, and make it applicable to as wide a variety of <a href="sentential_logic" title="wikilink">sentential logics</a> as possible. It is an operator that assigns to a given theory of a given sentential logic, perceived as a free algebra with a consequence operation on its universe, the largest <a href="congruence_relation" title="wikilink">congruence</a> on the algebra that is compatible with the theory.</p>
<h2 id="formulation">Formulation</h2>

<p>In this article, we introduce the Leibniz operator in the special case of classical propositional calculus, then we abstract it to the general notion applied to an arbitrary sentential logic and, finally, we summarize some of the most important consequences of its use in the theory of abstract algebraic logic.</p>

<p>Let</p>

<p>

<math display="block" id="Leibniz_operator:0">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>Fm</mi>
    <mo>,</mo>
    <msub>
     <mo>⊢</mo>
     <mi class="ltx_font_mathcaligraphic">𝒮</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">Fm</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <ci>𝒮</ci>
     </apply>
     <ci>normal-⟩</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}=\langle{\rm Fm},\vdash_{\mathcal{S}}\rangle
  </annotation>
 </semantics>
</math>

 denote the classical propositional calculus. According to the classical Lindenbaum-Tarski process, given a theory 

<math display="inline" id="Leibniz_operator:1">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>


 of 

<math display="inline" id="Leibniz_operator:2">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Leibniz_operator:3">
 <semantics>
  <msub>
   <mo>≡</mo>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <equivalent></equivalent>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \equiv_{T}
  </annotation>
 </semantics>
</math>

 denotes the binary relation on the set of formulas of 

<math display="inline" id="Leibniz_operator:4">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

, defined by</p>

<p>

<math display="block" id="Leibniz_operator:5">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <msub>
    <mo>≡</mo>
    <mi>T</mi>
   </msub>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <equivalent></equivalent>
     <ci>T</ci>
    </apply>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\equiv_{T}\psi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Leibniz_operator:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mo>↔</mo>
    <mrow>
     <mi>ψ</mi>
     <mo>∈</mo>
     <mi>T</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <ci>ϕ</ci>
    <apply>
     <in></in>
     <ci>ψ</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\leftrightarrow\psi\in T,
  </annotation>
 </semantics>
</math>


</p>

<p>where 

<math display="inline" id="Leibniz_operator:7">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>

 denotes the usual classical propositional equivalence connective, then 

<math display="inline" id="Leibniz_operator:8">
 <semantics>
  <msub>
   <mo>≡</mo>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <equivalent></equivalent>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \equiv_{T}
  </annotation>
 </semantics>
</math>

 turns out to be a congruence on the formula algebra. Furthermore, the quotient 

<math display="inline" id="Leibniz_operator:9">
 <semantics>
  <mrow>
   <mi>Fm</mi>
   <mo>/</mo>
   <msub>
    <mo>≡</mo>
    <mi>T</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Fm</csymbol>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <equivalent></equivalent>
     <ci>T</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm Fm}/{\equiv_{T}}
  </annotation>
 </semantics>
</math>

 is a Boolean algebra and every Boolean algebra may be formed in this way.</p>

<p>Thus, the variety of Boolean algebras, which is, in Abstract Algebraic Logic terminology, the equivalent <a href="algebraic_semantics_(mathematical_logic)" title="wikilink">algebraic semantics</a> (algebraic counterpart) of classical propositional calculus, is the class of all algebras formed by taking appropriate quotients of <a href="free_algebra" title="wikilink">free algebras</a> by those special kinds of congruences.</p>

<p>The condition</p>

<p>

<math display="block" id="Leibniz_operator:10">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>↔</mo>
   <mrow>
    <mi>ψ</mi>
    <mo>∈</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <ci>ϕ</ci>
    <apply>
     <in></in>
     <ci>ψ</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\leftrightarrow\psi\in T
  </annotation>
 </semantics>
</math>

</p>

<p>that defines 

<math display="inline" id="Leibniz_operator:11">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <msub>
    <mo>≡</mo>
    <mi>T</mi>
   </msub>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <equivalent></equivalent>
     <ci>T</ci>
    </apply>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\equiv_{T}\psi
  </annotation>
 </semantics>
</math>


 is equivalent to the condition</p>

<p>

<math display="block" id="Leibniz_operator:12">
 <semantics>
  <mrow>
   <mi>T</mi>
   <msub>
    <mo>⊢</mo>
    <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   </msub>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>𝒮</ci>
    </apply>
    <csymbol cd="unknown">ϕ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\vdash_{\mathcal{S}}\phi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Leibniz_operator:13">
 <semantics>
  <mrow>
   <mi>T</mi>
   <msub>
    <mo>⊢</mo>
    <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   </msub>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>𝒮</ci>
    </apply>
    <csymbol cd="unknown">ψ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\vdash_{\mathcal{S}}\psi
  </annotation>
 </semantics>
</math>

.</p>

<p>Passing now to an arbitrary sentential logic</p>

<p>

<math display="block" id="Leibniz_operator:14">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>Fm</mi>
    <mo>,</mo>
    <msub>
     <mo>⊢</mo>
     <mi class="ltx_font_mathcaligraphic">𝒮</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">Fm</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <ci>𝒮</ci>
     </apply>
     <ci>normal-⟩</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}=\langle{\rm Fm},\vdash_{\mathcal{S}}\rangle,
  </annotation>
 </semantics>
</math>

</p>

<p>given a theory 

<math display="inline" id="Leibniz_operator:15">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, the <strong>Leibniz congruence</strong> associated with 

<math display="inline" id="Leibniz_operator:16">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is denoted by 

<math display="inline" id="Leibniz_operator:17">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(T)
  </annotation>
 </semantics>
</math>

 and is defined, for all 

<math display="inline" id="Leibniz_operator:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mo>,</mo>
    <mi>ψ</mi>
   </mrow>
   <mo>∈</mo>
   <mi>Fm</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </list>
    <ci>Fm</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi,\psi\in{\rm Fm}
  </annotation>
 </semantics>
</math>

, by</p>

<p>

<math display="block" id="Leibniz_operator:19">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>normal-Ω</ci>
    <ci>T</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\Omega(T)\psi
  </annotation>
 </semantics>
</math>

</p>

<p>if and only if, for every formula 

<math display="inline" id="Leibniz_operator:20">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>α</ci>
    <interval closure="open">
     <ci>x</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>y</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha(x,\vec{y})
  </annotation>
 </semantics>
</math>

 containing a variable 

<math display="inline" id="Leibniz_operator:21">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and possibly other variables in the list 

<math display="inline" id="Leibniz_operator:22">
 <semantics>
  <mover accent="true">
   <mi>y</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{y}
  </annotation>
 </semantics>
</math>

, and all formulas 

<math display="inline" id="Leibniz_operator:23">
 <semantics>
  <mover accent="true">
   <mi>χ</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>χ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{\chi}
  </annotation>
 </semantics>
</math>

 forming a list of the same length as that of 

<math display="inline" id="Leibniz_operator:24">
 <semantics>
  <mover accent="true">
   <mi>y</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{y}
  </annotation>
 </semantics>
</math>

, we have that</p>

<p>

<math display="block" id="Leibniz_operator:25">
 <semantics>
  <mrow>
   <mi>T</mi>
   <msub>
    <mo>⊢</mo>
    <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   </msub>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>χ</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>𝒮</ci>
    </apply>
    <csymbol cd="unknown">α</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>χ</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\vdash_{\mathcal{S}}\alpha(\phi,\vec{\chi})
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Leibniz_operator:26">
 <semantics>
  <mrow>
   <mi>T</mi>
   <msub>
    <mo>⊢</mo>
    <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   </msub>
   <mi>α</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ψ</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>χ</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci>𝒮</ci>
    </apply>
    <csymbol cd="unknown">α</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>χ</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\vdash_{\mathcal{S}}\alpha(\psi,\vec{\chi})
  </annotation>
 </semantics>
</math>

.</p>

<p>It turns out that this binary relation is a <a href="congruence_relation" title="wikilink">congruence relation</a> on the formula algebra and, in fact, may alternatively be characterized as the largest congruence on the formula algebra that is compatible with the theory 

<math display="inline" id="Leibniz_operator:27">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, in the sense that if 

<math display="inline" id="Leibniz_operator:28">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>normal-Ω</ci>
    <ci>T</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\Omega(T)\psi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Leibniz_operator:29">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>∈</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ϕ</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\in T
  </annotation>
 </semantics>
</math>

, then we must have also 

<math display="inline" id="Leibniz_operator:30">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mo>∈</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ψ</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi\in T
  </annotation>
 </semantics>
</math>

. It is this congruence that plays the same role as the congruence used in the traditional Lindenbaum-Tarski process described above in the context of an arbitrary sentential logic.</p>

<p>It is not, however, the case that for arbitrary sentential logics the quotients of the free algebras by these Leibniz congruences over different theories yield all algebras in the class that forms the natural algebraic counterpart of the sentential logic. This phenomenon occurs only in the case of "nice" logics and one of the main goals of Abstract Algebraic Logic is to make this vague notion of a logic being "nice", in this sense, mathematically precise. The Leibniz operator</p>

<p>

<math display="block" id="Leibniz_operator:31">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

</p>

<p>is the operator that maps a theory 

<math display="inline" id="Leibniz_operator:32">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 of a given logic to the Leibniz congruence</p>

<p>

<math display="block" id="Leibniz_operator:33">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(T),
  </annotation>
 </semantics>
</math>

</p>

<p>that is associated with the theory. Thus, formally,</p>

<p>

<math display="block" id="Leibniz_operator:34">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Th</mi>
     <mi class="ltx_font_mathcaligraphic">𝒮</mi>
    </mrow>
    <mo>→</mo>
    <mi>ConFm</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Ω</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>Th</ci>
      <ci>𝒮</ci>
     </apply>
     <ci>ConFm</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega:{\rm Th}\mathcal{S}\rightarrow{\rm Con}{\rm Fm}
  </annotation>
 </semantics>
</math>

</p>

<p>is a mapping from the collection</p>

<p>

<math display="block" id="Leibniz_operator:35">
 <semantics>
  <mrow>
   <mi>Th</mi>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Th</ci>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm Th}\mathcal{S}
  </annotation>
 </semantics>
</math>

 of the theories of a sentential logic 

<math display="inline" id="Leibniz_operator:36">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 to the collection</p>

<p>

<math display="block" id="Leibniz_operator:37">
 <semantics>
  <mi>ConFm</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ConFm</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm Con}{\rm Fm}
  </annotation>
 </semantics>
</math>

</p>

<p>of all congruences on the formula algebra 

<math display="inline" id="Leibniz_operator:38">
 <semantics>
  <mi>Fm</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Fm</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm Fm}
  </annotation>
 </semantics>
</math>

 of the sentential logic.</p>
<h2 id="hierarchy">Hierarchy</h2>

<p>The Leibniz operator and the study of various of its properties that may or may not be satisfied for particular sentential logics have given rise to what is now known as the <strong>abstract algebraic hierarchy</strong> or <strong>Leibniz hierarchy</strong> of sentential logics. Logics are classified in various steps of this hierarchy depending on how strong a tie exists between the logic and its algebraic counterpart. The properties of the Leibniz operator that help classify the logics are monotonicity, injectivity, continuity and commutativity with inverse substitutions. For instance, <a class="uri" href="protoalgebraic" title="wikilink">protoalgebraic</a> logics, forming the widest class in the hierarchy, i.e., the one that lies in the bottom of the hierarchy and contains all other classes, are characterized by the monotonicity of the Leibniz operator on their theories. Other famous classes are formed by the <a class="uri" href="equivalential" title="wikilink">equivalential</a> logics, the weakly <a class="uri" href="algebraizable" title="wikilink">algebraizable</a> logics, the algebraizable logics etc.</p>

<p>By now, there is a generalization of the Leibniz operator in the context of Categorical Abstract Algebraic Logic, that makes it possible to apply a wide variety of techniques that were previously applicable in the sentential logic framework to logics formalized as <a href="π-institution" title="wikilink">

<math display="inline" id="Leibniz_operator:39">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

-institutions</a>. The 

<math display="inline" id="Leibniz_operator:40">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

-institution framework is significantly wider in scope than the framework of sentential logics because it allows incorporating multiple signatures and quantifiers in the language and it provides a mechanism for handling logics that are not syntactically-based.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>Font, J. M., Jansana, R., Pigozzi, D., (2003), <a href="http://www.imub.ub.es/publications/preprints/pdf/Font-altresPre329.pdf">A survey of abstract algebraic logic</a>, <em>Studia Logica 74</em>: 13-79.</li>
<li></li>
<li>Ramon Jansana, <em><a href="http://plato.stanford.edu/entries/consequence-algebraic/">Propositional Consequence Relations and Algebraic Logic</a></em>, Stanford Encyclopedia of Philosophy, 2006.</li>
</ul>

<p>"</p>

<p><a href="Category:Algebraic_logic" title="wikilink">Category:Algebraic logic</a></p>
</body>
</html>
