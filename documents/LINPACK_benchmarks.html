<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1816">LINPACK benchmarks</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>LINPACK benchmarks</h1>
<hr/>

<p>The <strong>LINPACK <a href="Benchmark_(computing)" title="wikilink">Benchmarks</a></strong> are a measure of a system's <a href="floating_point" title="wikilink">floating point</a> computing power. Introduced by <a href="Jack_Dongarra" title="wikilink">Jack Dongarra</a>, they measure how fast a computer solves a dense <em>n</em> by <em>n</em> <a href="system_of_linear_equations" title="wikilink">system of linear equations</a> <em>Ax</em> = <em>b</em>, which is a common task in <a class="uri" href="engineering" title="wikilink">engineering</a>.</p>

<p>The latest version of these benchmarks is used to build the <a class="uri" href="TOP500" title="wikilink">TOP500</a> list, ranking the world's most powerful supercomputers.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The aim is to approximate how fast a computer will perform when solving real problems. It is a simplification, since no single computational task can reflect the overall performance of a computer system. Nevertheless, the LINPACK benchmark performance can provide a good correction over the peak performance provided by the manufacturer. The peak performance is the maximal theoretical performance a computer can achieve, calculated as the machine's frequency, in cycles per second, times the number of operations per cycle it can perform. The actual performance will always be lower than the peak performance.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The <a href="Computer_performance" title="wikilink">performance of a computer</a> is a complex issue that depends on many interconnected variables. The performance measured by the LINPACK benchmark consists of the number of 64-bit floating-point operations, generally additions and multiplications, a computer can perform per second, also known as <a class="uri" href="FLOPS" title="wikilink">FLOPS</a>. However, a computer's performance when running actual applications is likely to be far behind the maximal performance it achieves running the appropriate LINPACK benchmark.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The name of these benchmarks comes from the <a class="uri" href="LINPACK" title="wikilink">LINPACK</a> package, a collection of algebra <a class="uri" href="Fortran" title="wikilink">Fortran</a> subroutines widely used in the 80s, and initially tightly linked to the LINPACK benchmark. The <a class="uri" href="LINPACK" title="wikilink">LINPACK</a> package has been since then replaced by other libraries.</p>
<h2 id="history">History</h2>

<p>The LINPACK benchmark report appeared first in 1979 as an appendix to the <a class="uri" href="LINPACK" title="wikilink">LINPACK</a> user's manual.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>LINPACK was designed to help users estimate the time required by their systems to solve a problem using the <a class="uri" href="LINPACK" title="wikilink">LINPACK</a> package, by extrapolating the performance results obtained by 23 different computers solving a matrix problem of size 100.</p>

<p>This matrix size was chosen due to memory and CPU limitations at that time:</p>
<ul>
<li>10,000 floating-point entries from -1 to 1 are randomly generated to fill in a general, dense matrix,</li>
<li>then, <a href="LU_decomposition" title="wikilink">LU decomposition</a> with partial pivoting is used for the timing.</li>
</ul>

<p>Over the years, additional versions with different problem sizes, like matrices of order 300 and 1000, and constraints were released, allowing new optimization opportunities as hardware architectures started to implement matrix-vector and matrix-matrix operations.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Parallel processing was also introduced in the LINPACK Parallel benchmark in the late 1980s.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>In 1991 the LINPACK was modified for<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> solving problems of arbitrary size, enabling <a href="supercomputer" title="wikilink">high performance computers</a> (HPC) to get near to their asymptotic performance.</p>

<p>Two years later this benchmark was used for measuring the performance of the first <a class="uri" href="TOP500" title="wikilink">TOP500</a> list.</p>
<h2 id="the-benchmarks">The benchmarks</h2>
<h3 id="linpack-100">LINPACK 100</h3>

<p>LINPACK 100 is very similar to the original benchmark published in 1979 along with the [<a class="uri" href="http://books.google.ch/books?id=AmSm1n3Vw0cC&amp;lpg">http://books.google.ch/books?id=AmSm1n3Vw0cC&amp;lpg;</a>;=PR5&amp;ots;=EDFdqJhr8x&amp;dq;=info%3Ahttp%3A%2F%2Fs3da3171290b34600.scholar.google.com%2F0&amp;lr;&amp;pg;=SL2-PA1#v=onepage&amp;q;&amp;f;=false LINPACK users' manual]. The solution is obtained by <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a> with <a href="pivot_element" title="wikilink">partial pivoting</a>, with 2/3n³ + 2n² floating point operations where <em>n</em> is 100, the order of the dense matrix <em>A</em> that defines the problem. Its small size and the lack of software flexibility doesn't allow most modern computers to reach their performance limits. However, it can still be useful to predict performances in numerically intensive user written code using compiler optimization.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="linpack-1000">LINPACK 1000</h3>

<p>LINPACK 1000 can provide a performance nearer to the machine's limit because, in addition to offering a bigger problem size, a matrix of order 1000, changes in the algorithm are possible. The only constraints are that the relative accuracy can't be reduced and the number of operations will always be considered to be 2/3n³ + 2n², with n = 1000.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="hplinpack">HPLinpack</h3>

<p>The previous benchmarks are not suitable for testing parallel computers,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> and the so-called Linpack's Highly Parallel Computing benchmark, or HPLinpack benchmark, was introduced. In HPLinpack the size n of the problem can be made as large as it is needed to optimize the performance results of the machine. Once again, 2/3n³ + 2n² will be taken as the operation count, with independence of the algorithm used. <a href="Strassen_algorithm" title="wikilink">Strassen algorithm</a> is not allowed because it distorts the real execution rate.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> The accuracy must be such that the following expression is satisfied:</p>

<p>

<math display="inline" id="LINPACK_benchmarks:0">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo fence="true">∥</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mi>x</mi>
      </mrow>
      <mo>-</mo>
      <mi>b</mi>
     </mrow>
     <mo fence="true">∥</mo>
    </mrow>
    <mrow>
     <mrow>
      <mo fence="true">∥</mo>
      <mi>A</mi>
      <mo fence="true">∥</mo>
     </mrow>
     <mrow>
      <mo fence="true">∥</mo>
      <mi>x</mi>
      <mo fence="true">∥</mo>
     </mrow>
     <mi>n</mi>
     <mi>ϵ</mi>
    </mrow>
   </mfrac>
   <mo>≤</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>x</ci>
       </apply>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>A</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>x</ci>
      </apply>
      <ci>n</ci>
      <ci>ϵ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\lVert Ax-b\rVert\over\lVert A\rVert\lVert x\rVert n\epsilon}\leq O(1)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="LINPACK_benchmarks:1">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 is the machine's precision, and <em>n</em> is the size of the problem,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> 

<math display="inline" id="LINPACK_benchmarks:2">
 <semantics>
  <mrow>
   <mo fence="true">∥</mo>
   <mo>⋅</mo>
   <mo fence="true">∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lVert\cdot\rVert
  </annotation>
 </semantics>
</math>

 is the <a href="matrix_norm" title="wikilink">matrix norm</a> and 

<math display="inline" id="LINPACK_benchmarks:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

 corresponds to the <a href="big-O_notation" title="wikilink">big-O notation</a>.</p>

<p>For each computer system, the following quantities are reported:<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<ul>
<li>R<sub>max</sub>: the performance in GFLOPS for the largest problem run on a machine.</li>
<li>N<sub>max</sub>: the size of the largest problem run on a machine.</li>
<li>N<sub>1/2</sub>: the size where half the Rmax execution rate is achieved.</li>
<li>R<sub>peak</sub>: the theoretical peak performance GFLOPS for the machine.</li>
</ul>

<p>These results are used to compile the <a class="uri" href="TOP500" title="wikilink">TOP500</a> list twice a year, with the world's most powerful computers.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="linpack-benchmark-implementations">LINPACK benchmark implementations</h2>

<p>The previous section describes the ground rules for the benchmarks. The actual <a class="uri" href="implementation" title="wikilink">implementation</a> of the program can diverge, with some examples being available in <a class="uri" href="Fortran" title="wikilink">Fortran</a>,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <a href="C_(programming_language)" title="wikilink">C</a> <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> or <a href="Java_(programming_language)" title="wikilink">Java</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h3 id="hpl">HPL</h3>

<p>HPL is a portable implementation of HPLinpack that was written in C, originally as a guideline, but that is now widely used to provide data for the TOP500 list, though other technologies and packages can be used. HPL generates a linear system of equations of order n and solves it using LU decomposition with partial row pivoting. It requires installed implementations of <a href="Message_Passing_Interface" title="wikilink">MPI</a> and either <a class="uri" href="BLAS" title="wikilink">BLAS</a> or <a class="uri" href="VSIPL" title="wikilink">VSIPL</a> to run.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>Coarsely, the algorithm has the following characteristics:<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<ul>
<li>Cyclic data distribution in 2D blocks.</li>
<li><a href="LU_factorization" title="wikilink">LU factorization</a> using the right-looking variant with various depths of <a class="uri" href="look-ahead" title="wikilink">look-ahead</a>.</li>
<li>Recursive panel factorization.</li>
<li>Six different panel <a href="broadcasting_(computing)" title="wikilink">broadcasting</a> variants.</li>
<li>Bandwidth reducing swap-broadcast algorithm.</li>
<li>Backward substitution with look-ahead of depth 1.</li>
</ul>
<h2 id="criticism">Criticism</h2>

<p>The LINPACK benchmark is said to have succeeded because of the scalability<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> of HPLinpack, the fact that it generates a single number, making the results easily comparable and the extensive historical data base it has associated.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> However, soon after its release, the LINPACK benchmark was criticized for providing performance levels "generally unobtainable by all but a very few programmers who tediously optimize their code for that machine and that machine alone",<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> because it only tests the resolution of dense linear systems, which are not representative of all the operations usually performed in scientific computing.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> <a href="Jack_Dongarra" title="wikilink">Jack Dongarra</a>, the main driving force behind the LINPACK benchmarks, said that, while they only emphasize "peak" CPU speed and number of CPUs, not enough stress is given to local bandwidth and the network.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>

<p>Thom Dunning, director of the National Center for Supercomputing Applications, had this to say about the LINPACK benchmark: "The Linpack benchmark is one of those interesting phenomena -- almost anyone who knows about it will deride its utility. They understand its limitations but it has mindshare because it's the one number we've all bought into over the years."<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>According to Dongarra, "the organizers of the Top500 are actively looking to expand the scope of the benchmark reporting" because "it is important to include more performance characteristic and signatures for a given system".<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> One of the possibilities that is being considered to extend the benchmark for the TOP500 is the <a href="HPC_Challenge_Benchmark" title="wikilink">HPC Challenge Benchmark</a> Suite.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> With the advent of <a href="Petascale_computing" title="wikilink">petascale computers</a>, <a href="traversed_edges_per_second" title="wikilink">traversed edges per second</a> have started to emerge as an alternative metric to FLOPS measured by LINPACK. Other alternative is the HPCG benchmark, proposed by Dongarra.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h3 id="the-running-time-issue">The running time issue</h3>

<p>According to <a href="Jack_Dongarra" title="wikilink">Jack Dongarra</a>, the running time required to obtain good performance results with HPLinpack are expected to increase. In a conference held in 2010, he said he expects running times of 2.5 days in "a few years".<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Traversed_edges_per_second" title="wikilink">Traversed edges per second</a></li>
<li><a class="uri" href="LAPACK" title="wikilink">LAPACK</a></li>
<li><a class="uri" href="LINPACK" title="wikilink">LINPACK</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.top500.org/project/linpack/">TOP500 LINPACK</a></li>
<li><a href="http://www.netlib.org/benchmark/linpackjava/">a web-based LINPACK benchmark</a></li>
<li><a href="https://software.intel.com/en-us/articles/intel-math-kernel-library-linpack-download">Intel® Optimized LINPACK Benchmark</a></li>
</ul>

<p>"</p>

<p><a href="Category:Computer_benchmarks" title="wikilink">Category:Computer benchmarks</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
</ol>
</section>
</body>
</html>
