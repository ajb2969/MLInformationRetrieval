<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1673">Mathematical optimization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Mathematical optimization</h1>
<hr/>

<p> In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <a href="computer_science" title="wikilink">computer science</a> and <a href="operations_research" title="wikilink">operations research</a>, <strong>mathematical optimization</strong> (alternatively, <strong>optimization</strong> or <strong>mathematical programming</strong>) is the selection of a best element (with regard to some criteria) from some set of available alternatives.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>In the simplest case, an <a href="optimization_problem" title="wikilink">optimization problem</a> consists of <a href="maxima_and_minima" title="wikilink">maximizing or minimizing</a> a <a href="Function_of_a_real_variable" title="wikilink">real function</a> by systematically choosing <a href="Argument_of_a_function" title="wikilink">input</a> values from within an allowed set and computing the <a href="Value_(mathematics)" title="wikilink">value</a> of the function. The generalization of optimization theory and techniques to other formulations comprises a large area of <a href="applied_mathematics" title="wikilink">applied mathematics</a>. More generally, optimization includes finding "best available" values of some objective function given a defined <a href="domain_of_a_function" title="wikilink">domain</a> (or a set of constraints), including a variety of different types of objective functions and different types of domains.</p>
<h2 id="optimization-problems">Optimization problems</h2>

<p>An optimization problem can be represented in the following way:</p>
<dl>
<dd><em>Given:</em> a <a href="function_(mathematics)" title="wikilink">function</a> <em>f</em> : <em>A</em> 

<math display="inline" id="Mathematical_optimization:0">
 <semantics>
  <mo>‚Üí</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-‚Üí</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 <strong>R</strong> from some <a href="Set_(mathematics)" title="wikilink">set</a> <em>A</em> to the <a href="real_number" title="wikilink">real numbers</a>
</dd>
<dd><em>Sought:</em> an element <em>x</em><sub>0</sub> in <em>A</em> such that <em>f</em>(<em>x</em><sub>0</sub>) ‚â§ <em>f</em>(<em>x</em>) for all <em>x</em> in <em>A</em> ("minimization") or such that <em>f</em>(<em>x</em><sub>0</sub>) ‚â• <em>f</em>(<em>x</em>) for all <em>x</em> in <em>A</em> ("maximization").
</dd>
</dl>

<p>Such a formulation is called an <strong><a href="optimization_problem" title="wikilink">optimization problem</a></strong> or a <strong>mathematical programming problem</strong> (a term not directly related to <a href="computer_programming" title="wikilink">computer programming</a>, but still in use for example in <a href="linear_programming" title="wikilink">linear programming</a> ‚Äì see <a href="#History" title="wikilink">History</a> below). Many real-world and theoretical problems may be modeled in this general framework. Problems formulated using this technique in the fields of <a class="uri" href="physics" title="wikilink">physics</a> and <a href="computer_vision" title="wikilink">computer vision</a> may refer to the technique as <strong>energy minimization</strong>, speaking of the value of the function <em>f</em> as representing the energy of the <a class="uri" href="system" title="wikilink">system</a> being <a href="Mathematical_model" title="wikilink">modeled</a>.</p>

<p>Typically, <em>A</em> is some <a class="uri" href="subset" title="wikilink">subset</a> of the <a href="Euclidean_space" title="wikilink">Euclidean space</a> <strong>R</strong><sup><em>n</em></sup>, often specified by a set of <em><a href="constraint_(mathematics)" title="wikilink">constraints</a></em>, equalities or inequalities that the members of <em>A</em> have to satisfy. The <a href="domain_(mathematics)" title="wikilink">domain</a> <em>A</em> of <em>f</em> is called the <em>search space</em> or the <em>choice set</em>, while the elements of <em>A</em> are called <em><a href="candidate_solution" title="wikilink">candidate solutions</a></em> or <em>feasible solutions</em>.</p>

<p>The function <em>f</em> is called, variously, an <strong>objective function</strong>, a <strong><a href="loss_function" title="wikilink">loss function</a></strong> or <strong>cost function</strong> (minimization),<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> a <strong>utility function</strong> or <strong>fitness function</strong> (maximization), or, in certain fields, an <strong>energy function</strong> or <strong>energy <a href="functional_(mathematics)" title="wikilink">functional</a></strong>. A feasible solution that minimizes (or maximizes, if that is the goal) the objective function is called an <em>optimal solution</em>.</p>

<p>In mathematics, by convention optimization problems are usually stated in terms of minimization. Generally, unless both the objective function and the <a href="feasible_region" title="wikilink">feasible region</a> are <a href="Convex_function" title="wikilink">convex</a> in a minimization problem, there may be several local minima, where a <em>local minimum</em> x<sup>*</sup> is defined as a point for which there exists some Œ¥ &gt; 0 so that for all x such that</p>

<p>

<math display="block" id="Mathematical_optimization:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>‚à•</mo>
     <mrow>
      <mi>ùê±</mi>
      <mo>-</mo>
      <msup>
       <mi>ùê±</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mo>‚à•</mo>
    </mrow>
    <mo>‚â§</mo>
    <mi>Œ¥</mi>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>ùê±</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ùê±</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
    <ci>Œ¥</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathbf{x}-\mathbf{x}^{*}\|\leq\delta;\,
  </annotation>
 </semantics>
</math>

</p>

<p>the expression</p>

<p>

<math display="block" id="Mathematical_optimization:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>ùê±</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùê±</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùê±</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>ùê±</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\mathbf{x}^{*})\leq f(\mathbf{x})
  </annotation>
 </semantics>
</math>

 holds; that is to say, on some region around x<sup>*</sup> all of the function values are greater than or equal to the value at that point. Local maxima are defined similarly.</p>

<p>A large number of algorithms proposed for solving non-convex problems ‚Äì including the majority of commercially available solvers ‚Äì are not capable of making a distinction between local optimal solutions and rigorous optimal solutions, and will treat the former as actual solutions to the original problem. The branch of <a href="applied_mathematics" title="wikilink">applied mathematics</a> and <a href="numerical_analysis" title="wikilink">numerical analysis</a> that is concerned with the development of deterministic algorithms that are capable of guaranteeing convergence in finite time to the actual optimal solution of a non-convex problem is called <a href="global_optimization" title="wikilink">global optimization</a>.</p>
<h2 id="notation">Notation</h2>

<p>Optimization problems are often expressed with special notation. Here are some examples.</p>
<h3 id="minimum-and-maximum-value-of-a-function">Minimum and maximum value of a function</h3>

<p>Consider the following notation:</p>

<p>

<math display="block" id="Mathematical_optimization:3">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <munder>
     <mi>min</mi>
     <mrow>
      <mi>x</mi>
      <mo>‚àà</mo>
      <mi>‚Ñù</mi>
     </mrow>
    </munder>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <min></min>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>‚Ñù</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{x\in\mathbb{R}}\;(x^{2}+1)
  </annotation>
 </semantics>
</math>

</p>

<p>This denotes the minimum <a href="Value_(mathematics)" title="wikilink">value</a> of the objective function 

<math display="inline" id="Mathematical_optimization:4">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}+1
  </annotation>
 </semantics>
</math>

, when choosing <em>x</em> from the set of <a href="real_number" title="wikilink">real numbers</a> 

<math display="inline" id="Mathematical_optimization:5">
 <semantics>
  <mi>‚Ñù</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñù</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}
  </annotation>
 </semantics>
</math>

. The minimum value in this case is 

<math display="inline" id="Mathematical_optimization:6">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

, occurring at 

<math display="inline" id="Mathematical_optimization:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=0
  </annotation>
 </semantics>
</math>

.</p>

<p>Similarly, the notation</p>

<p>

<math display="block" id="Mathematical_optimization:8">
 <semantics>
  <mrow>
   <munder>
    <mi>max</mi>
    <mrow>
     <mi>x</mi>
     <mo>‚àà</mo>
     <mi>‚Ñù</mi>
    </mrow>
   </munder>
   <mrow>
    <mn>2</mn>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>‚Ñù</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="float">2</cn>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{x\in\mathbb{R}}\;2x
  </annotation>
 </semantics>
</math>

</p>

<p>asks for the maximum value of the objective function 2<em>x</em>, where <em>x</em> may be any real number. In this case, there is no such maximum as the objective function is unbounded, so the answer is "<a class="uri" href="infinity" title="wikilink">infinity</a>" or "undefined".</p>
<h3 id="optimal-input-arguments">Optimal input arguments</h3>

<p>Consider the following notation:</p>

<p>

<math display="block" id="Mathematical_optimization:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+2.8pt">
      <munder accentunder="true">
       <mrow>
        <mpadded width="+1.7pt">
         <mi>arg</mi>
        </mpadded>
        <mi>min</mi>
       </mrow>
       <mrow>
        <mi>x</mi>
        <mo>‚àà</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo>-</mo>
          <mi mathvariant="normal">‚àû</mi>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </munder>
     </mpadded>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <apply>
       <in></in>
       <ci>x</ci>
       <interval closure="open-closed">
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>arg</ci>
       <ci>min</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underset{x\in(-\infty,-1]}{\operatorname{arg\,min}}\;x^{2}+1,
  </annotation>
 </semantics>
</math>

 or equivalently</p>

<p>

<math display="block" id="Mathematical_optimization:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mpadded width="+2.8pt">
        <munder accentunder="true">
         <mrow>
          <mpadded width="+1.7pt">
           <mi>arg</mi>
          </mpadded>
          <mi>min</mi>
         </mrow>
         <mo>ùë•</mo>
        </munder>
       </mpadded>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo rspace="5.3pt">,</mo>
     <mrow>
      <mpadded width="+2.8pt">
       <mtext>subject to:</mtext>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>‚àà</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">‚àû</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>arg</ci>
         <ci>min</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <mtext>subject to:</mtext>
      <ci>x</ci>
     </apply>
    </list>
    <interval closure="open-closed">
     <apply>
      <minus></minus>
      <infinity></infinity>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underset{x}{\operatorname{arg\,min}}\;x^{2}+1,\;\text{subject to:}\;x\in(-%
\infty,-1].
  </annotation>
 </semantics>
</math>

</p>

<p>This represents the value (or values) of the <a href="Argument_of_a_function" title="wikilink">argument</a> <em>x</em> in the <a href="interval_(mathematics)" title="wikilink">interval</a> 

<math display="inline" id="Mathematical_optimization:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>-</mo>
    <mi mathvariant="normal">‚àû</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open-closed">
    <apply>
     <minus></minus>
     <infinity></infinity>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (-\infty,-1]
  </annotation>
 </semantics>
</math>

 that minimizes (or minimize) the objective function <em>x</em><sup>2</sup>¬†+¬†1 (the actual minimum value of that function is not what the problem asks for). In this case, the answer is <em>x</em> = -1, since <em>x</em> = 0 is infeasible, i.e. does not belong to the <a href="feasible_set" title="wikilink">feasible set</a>.</p>

<p>Similarly,</p>

<p>

<math display="block" id="Mathematical_optimization:12">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+2.8pt">
     <munder accentunder="true">
      <mrow>
       <mpadded width="+1.7pt">
        <mi>arg</mi>
       </mpadded>
       <mi>max</mi>
      </mrow>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mo>‚àà</mo>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mo>-</mo>
          <mn>5</mn>
         </mrow>
         <mo>,</mo>
         <mn>5</mn>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo rspace="5.3pt">,</mo>
       <mrow>
        <mi>y</mi>
        <mo>‚àà</mo>
        <mi>‚Ñù</mi>
       </mrow>
      </mrow>
     </munder>
    </mpadded>
    <mi>x</mi>
    <mrow>
     <mi>cos</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <interval closure="closed">
        <apply>
         <minus></minus>
         <cn type="integer">5</cn>
        </apply>
        <cn type="integer">5</cn>
       </interval>
      </apply>
      <apply>
       <in></in>
       <ci>y</ci>
       <ci>‚Ñù</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>arg</ci>
      <ci>max</ci>
     </apply>
    </apply>
    <ci>x</ci>
    <apply>
     <cos></cos>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underset{x\in[-5,5],\;y\in\mathbb{R}}{\operatorname{arg\,max}}\;x\cos(y),
  </annotation>
 </semantics>
</math>

 or equivalently</p>

<p>

<math display="block" id="Mathematical_optimization:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mpadded width="+2.8pt">
        <munder accentunder="true">
         <mrow>
          <mpadded width="+1.7pt">
           <mi>arg</mi>
          </mpadded>
          <mi>max</mi>
         </mrow>
         <mrow>
          <mi>x</mi>
          <mo rspace="5.3pt">,</mo>
          <mi>y</mi>
         </mrow>
        </munder>
       </mpadded>
       <mi>x</mi>
       <mrow>
        <mi>cos</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo rspace="5.3pt">,</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mtext>subject to:</mtext>
       </mpadded>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo>‚àà</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mo>-</mo>
       <mn>5</mn>
      </mrow>
      <mo>,</mo>
      <mn>5</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo rspace="5.3pt">,</mo>
    <mrow>
     <mi>y</mi>
     <mo>‚àà</mo>
     <mi>‚Ñù</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <apply>
       <times></times>
       <apply>
        <list>
         <ci>x</ci>
         <ci>y</ci>
        </list>
        <apply>
         <times></times>
         <ci>arg</ci>
         <ci>max</ci>
        </apply>
       </apply>
       <ci>x</ci>
       <apply>
        <cos></cos>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <mtext>subject to:</mtext>
       <ci>x</ci>
      </apply>
     </list>
     <interval closure="closed">
      <apply>
       <minus></minus>
       <cn type="integer">5</cn>
      </apply>
      <cn type="integer">5</cn>
     </interval>
    </apply>
    <apply>
     <in></in>
     <ci>y</ci>
     <ci>‚Ñù</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underset{x,\;y}{\operatorname{arg\,max}}\;x\cos(y),\;\text{subject to:}\;x\in%
[-5,5],\;y\in\mathbb{R},
  </annotation>
 </semantics>
</math>

</p>

<p>represents the 

<math display="inline" id="Mathematical_optimization:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 pair (or pairs) that maximizes (or maximize) the value of the objective function 

<math display="inline" id="Mathematical_optimization:15">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mi>cos</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <cos></cos>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\cos(y)
  </annotation>
 </semantics>
</math>

, with the added constraint that <em>x</em> lie in the interval 

<math display="inline" id="Mathematical_optimization:16">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mo>-</mo>
    <mn>5</mn>
   </mrow>
   <mo>,</mo>
   <mn>5</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <apply>
     <minus></minus>
     <cn type="integer">5</cn>
    </apply>
    <cn type="integer">5</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [-5,5]
  </annotation>
 </semantics>
</math>

 (again, the actual maximum value of the expression does not matter). In this case, the solutions are the pairs of the form (5, 2k<a href="Pi" title="wikilink">œÄ</a>) and (‚àí5,(2k+1)œÄ), where <em>k</em> ranges over all <a href="integer" title="wikilink">integers</a>.</p>

<p><strong>arg min</strong> and <strong>arg max</strong> are sometimes also written <strong>argmin</strong> and <strong>argmax</strong>, and stand for <strong>argument of the minimum</strong> and <strong>argument of the maximum</strong>.</p>
<h2 id="history">History</h2>

<p><a href="Pierre_de_Fermat" title="wikilink">Fermat</a> and <a href="Joseph_Louis_Lagrange" title="wikilink">Lagrange</a> found calculus-based formulas for identifying optima, while <a href="Isaac_Newton" title="wikilink">Newton</a> and <a href="Carl_Friedrich_Gauss" title="wikilink">Gauss</a> proposed iterative methods for moving towards an optimum.</p>

<p>The term "<a href="linear_programming" title="wikilink">linear programming</a>" for certain optimization cases was due to <a href="George_Dantzig" title="wikilink">George¬†B. Dantzig</a>, although much of the theory had been introduced by <a href="Leonid_Kantorovich" title="wikilink">Leonid Kantorovich</a> in 1939. (<em>Programming</em> in this context does not refer to <a href="computer_programming" title="wikilink">computer programming</a>, but from the use of <em>program</em> by the United States military to refer to proposed training and <a class="uri" href="logistics" title="wikilink">logistics</a> schedules, which were the problems Dantzig studied at that time.) Dantzig published the <a href="Simplex_algorithm" title="wikilink">Simplex algorithm</a> in 1947, and <a href="John_von_Neumann" title="wikilink">John von Neumann</a> developed the theory of <a href="Linear_programming#Duality" title="wikilink">duality</a> in the same year.</p>

<p>Other major researchers in mathematical optimization include the following:  </p>
<ul>
<li><a href="Richard_Bellman" title="wikilink">Richard Bellman</a></li>
<li><a href="Roger_Fletcher_(mathematician)" title="wikilink">Roger Fletcher</a></li>
<li><a href="Ronald_A._Howard" title="wikilink">Ronald A. Howard</a></li>
<li><a href="Narendra_Karmarkar" title="wikilink">Narendra Karmarkar</a></li>
<li><a href="William_Karush" title="wikilink">William Karush</a></li>
<li><a href="Leonid_Khachiyan" title="wikilink">Leonid Khachiyan</a></li>
<li><a href="Bernard_Koopman" title="wikilink">Bernard Koopman</a></li>
<li><a href="Harold_Kuhn" title="wikilink">Harold Kuhn</a></li>
<li><a href="L√°szl√≥_Lov√°sz" title="wikilink">L√°szl√≥ Lov√°sz</a></li>
</ul>
<ul>
<li><a href="Arkadi_Nemirovski" title="wikilink">Arkadi Nemirovski</a></li>
<li><a href="Yurii_Nesterov" title="wikilink">Yurii Nesterov</a></li>
<li><a href="Boris_Polyak" title="wikilink">Boris Polyak</a></li>
<li><a href="Lev_Pontryagin" title="wikilink">Lev Pontryagin</a></li>
<li><a href="James_Renegar" title="wikilink">James Renegar</a></li>
<li><a href="R._Tyrrell_Rockafellar" title="wikilink">R. Tyrrell Rockafellar</a></li>
<li><a href="Cornelis_Roos" title="wikilink">Cornelis Roos</a></li>
<li><a href="Naum_Z._Shor" title="wikilink">Naum Z. Shor</a></li>
<li><a href="Michael_J._Todd_(mathematician)" title="wikilink">Michael J. Todd</a></li>
<li><a href="Albert_W._Tucker" title="wikilink">Albert Tucker</a></li>
</ul>
<h2 id="major-subfields">Major subfields</h2>
<ul>
<li><a href="Convex_programming" title="wikilink">Convex programming</a> studies the case when the objective function is <a href="convex_function" title="wikilink">convex</a> (minimization) or <a href="Concave_function" title="wikilink">concave</a> (maximization) and the constraint set is <a href="convex_set" title="wikilink">convex</a>. This can be viewed as a particular case of nonlinear programming or as generalization of linear or convex quadratic programming.
<ul>
<li><a href="Linear_programming" title="wikilink">Linear programming</a> (LP), a type of convex programming, studies the case in which the objective function <em>f</em> is linear and the set of constraints is specified using only linear equalities and inequalities. Such a set is called a <a class="uri" href="polyhedron" title="wikilink">polyhedron</a> or a <a class="uri" href="polytope" title="wikilink">polytope</a> if it is <a href="Bounded_set" title="wikilink">bounded</a>.</li>
<li><a href="Second_order_cone_programming" title="wikilink">Second order cone programming</a> (SOCP) is a convex program, and includes certain types of quadratic programs.</li>
<li><a href="Semidefinite_programming" title="wikilink">Semidefinite programming</a> (SDP) is a subfield of convex optimization where the underlying variables are <a class="uri" href="semidefinite" title="wikilink">semidefinite</a> <a href="matrix_(mathematics)" title="wikilink">matrices</a>. It is generalization of linear and convex quadratic programming.</li>
<li><a href="Conic_programming" title="wikilink">Conic programming</a> is a general form of convex programming. LP, SOCP and SDP can all be viewed as conic programs with the appropriate type of cone.</li>
<li><a href="Geometric_programming" title="wikilink">Geometric programming</a> is a technique whereby objective and inequality constraints expressed as <a class="uri" href="posynomials" title="wikilink">posynomials</a> and equality constraints as <a class="uri" href="monomials" title="wikilink">monomials</a> can be transformed into a convex program.</li>
</ul></li>
<li><a href="Integer_programming" title="wikilink">Integer programming</a> studies linear programs in which some or all variables are constrained to take on <a class="uri" href="integer" title="wikilink">integer</a> values. This is not convex, and in general much more difficult than regular linear programming.</li>
<li><a href="Quadratic_programming" title="wikilink">Quadratic programming</a> allows the objective function to have quadratic terms, while the feasible set must be specified with linear equalities and inequalities. For specific forms of the quadratic term, this is a type of convex programming.</li>
<li><a href="Fractional_programming" title="wikilink">Fractional programming</a> studies optimization of ratios of two nonlinear functions. The special class of concave fractional programs can be transformed to a convex optimization problem.</li>
<li><a href="Nonlinear_programming" title="wikilink">Nonlinear programming</a> studies the general case in which the objective function or the constraints or both contain nonlinear parts. This may or may not be a convex program. In general, whether the program is convex affects the difficulty of solving it.</li>
<li><a href="Stochastic_programming" title="wikilink">Stochastic programming</a> studies the case in which some of the constraints or parameters depend on <a href="random_variable" title="wikilink">random variables</a>.</li>
<li><a href="Robust_optimization" title="wikilink">Robust programming</a> is, like stochastic programming, an attempt to capture uncertainty in the data underlying the optimization problem. Robust optimization targets to find solutions that are valid under all possible realizations of the uncertainties.</li>
<li><a href="Combinatorial_optimization" title="wikilink">Combinatorial optimization</a> is concerned with problems where the set of feasible solutions is discrete or can be reduced to a <a href="discrete_mathematics" title="wikilink">discrete</a> one.</li>
<li><a href="Stochastic_optimization" title="wikilink">Stochastic optimization</a> for use with random (noisy) function measurements or random inputs in the search process.</li>
<li><a href="Infinite-dimensional_optimization" title="wikilink">Infinite-dimensional optimization</a> studies the case when the set of feasible solutions is a subset of an infinite-<a href="dimension" title="wikilink">dimensional</a> space, such as a space of functions.</li>
<li><a href="Heuristic_(computer_science)" title="wikilink">Heuristics</a> and <a href="metaheuristic" title="wikilink">metaheuristics</a> make few or no assumptions about the problem being optimized. Usually, heuristics do not guarantee that any optimal solution need be found. On the other hand, heuristics are used to find approximate solutions for many complicated optimization problems.</li>
<li><a href="Constraint_satisfaction" title="wikilink">Constraint satisfaction</a> studies the case in which the objective function <em>f</em> is constant (this is used in <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>, particularly in <a href="automated_reasoning" title="wikilink">automated reasoning</a>).
<ul>
<li><a href="Constraint_programming" title="wikilink">Constraint programming</a>.</li>
</ul></li>
<li>Disjunctive programming is used where at least one constraint must be satisfied but not all. It is of particular use in scheduling.</li>
</ul>

<p>In a number of subfields, the techniques are designed primarily for optimization in dynamic contexts (that is, decision making over time):</p>
<ul>
<li><a href="Calculus_of_variations" title="wikilink">Calculus of variations</a> seeks to optimize an objective defined over many points in time, by considering how the objective function changes if there is a small change in the choice path.</li>
<li><a href="Optimal_control" title="wikilink">Optimal control</a> theory is a generalization of the calculus of variations.</li>
<li><a href="Dynamic_programming" title="wikilink">Dynamic programming</a> studies the case in which the optimization strategy is based on splitting the problem into smaller subproblems. The equation that describes the relationship between these subproblems is called the <a href="Bellman_equation" title="wikilink">Bellman equation</a>.</li>
<li><a href="Mathematical_programming_with_equilibrium_constraints" title="wikilink">Mathematical programming with equilibrium constraints</a> is where the constraints include <a href="variational_inequalities" title="wikilink">variational inequalities</a> or <a href="complementarity_theory" title="wikilink">complementarities</a>.</li>
</ul>
<h3 id="multi-objective-optimization">Multi-objective optimization</h3>

<p>Adding more than one objective to an optimization problem adds complexity. For example, to optimize a structural design, one would want a design that is both light and rigid. Because these two objectives conflict, a trade-off exists. There will be one lightest design, one stiffest design, and an infinite number of designs that are some compromise of weight and stiffness. The set of trade-off designs that cannot be improved upon according to one criterion without hurting another criterion is known as the <a href="Pareto_set" title="wikilink">Pareto set</a>. The curve created plotting weight against stiffness of the best designs is known as the <a href="Pareto_frontier" title="wikilink">Pareto frontier</a>.</p>

<p>A design is judged to be "Pareto optimal" (equivalently, "Pareto efficient" or in the Pareto set) if it is not dominated by any other design: If it is worse than another design in some respects and no better in any respect, then it is dominated and is not Pareto optimal.</p>

<p>The choice among "Pareto optimal" solutions to determine the "favorite solution" is delegated to the decision maker. In other words, defining the problem as multiobjective optimization signals that some information is missing: desirable objectives are given but not their detailed combination. In some cases, the missing information can be derived by interactive sessions with the decision maker.</p>

<p>Multi-objective optimization problems have been generalized further to <a href="vector_optimization" title="wikilink">vector optimization</a> problems where the (partial) ordering is no longer given by the Pareto ordering.</p>
<h3 id="multi-modal-optimization">Multi-modal optimization</h3>

<p>Optimization problems are often multi-modal; that is, they possess multiple good solutions. They could all be globally good (same cost function value) or there could be a mix of globally good and locally good solutions. Obtaining all (or at least some of) the multiple solutions is the goal of a multi-modal optimizer.</p>

<p>Classical optimization techniques due to their iterative approach do not perform satisfactorily when they are used to obtain multiple solutions, since it is not guaranteed that different solutions will be obtained even with different starting points in multiple runs of the algorithm. <a href="Evolutionary_algorithm" title="wikilink">Evolutionary algorithms</a> are however a very popular approach to obtain multiple solutions in a multi-modal optimization task.</p>
<h2 id="classification-of-critical-points-and-extrema">Classification of critical points and extrema</h2>
<h3 id="feasibility-problem">Feasibility problem</h3>

<p>The <strong><a href="satisfiability_problem" title="wikilink">satisfiability problem</a></strong>, also called the <strong>feasibility problem</strong>, is just the problem of finding any <a href="feasible_solution" title="wikilink">feasible solution</a> at all without regard to objective value. This can be regarded as the special case of mathematical optimization where the objective value is the same for every solution, and thus any solution is optimal.</p>

<p>Many optimization algorithms need to start from a feasible point. One way to obtain such a point is to <a href="Relaxation_(approximation)" title="wikilink">relax</a> the feasibility conditions using a <a href="slack_variable" title="wikilink">slack variable</a>; with enough slack, any starting point is feasible. Then, minimize that slack variable until slack is null or negative.</p>
<h3 id="existence">Existence</h3>

<p>The <a href="extreme_value_theorem" title="wikilink">extreme value theorem</a> of <a href="Karl_Weierstrass" title="wikilink">Karl Weierstrass</a> states that a continuous real-valued function on a compact set attains its maximum and minimum value. More generally, a lower semi-continuous function on a compact set attains its minimum; an upper semi-continuous function on a compact set attains its maximum.</p>
<h3 id="necessary-conditions-for-optimality">Necessary conditions for optimality</h3>

<p><a href="Fermat's_theorem_(stationary_points)" title="wikilink">One of Fermat's theorems</a> states that optima of unconstrained problems are found at <a href="stationary_point" title="wikilink">stationary points</a>, where the first derivative or the gradient of the objective function is zero (see <a href="first_derivative_test" title="wikilink">first derivative test</a>). More generally, they may be found at <a href="Critical_point_(mathematics)" title="wikilink">critical points</a>, where the first derivative or gradient of the objective function is zero or is undefined, or on the boundary of the choice set. An equation (or set of equations) stating that the first derivative(s) equal(s) zero at an interior optimum is called a 'first-order condition' or a set of first-order conditions.</p>

<p>Optima of equality-constrained problems can be found by the <a href="Lagrange_multiplier" title="wikilink">Lagrange multiplier</a> method. The optima of problems with equality and/or inequality constraints can be found using the '<a href="Karush‚ÄìKuhn‚ÄìTucker_conditions" title="wikilink">Karush‚ÄìKuhn‚ÄìTucker conditions</a>'.</p>
<h3 id="sufficient-conditions-for-optimality">Sufficient conditions for optimality</h3>

<p>While the first derivative test identifies points that might be extrema, this test does not distinguish a point that is a minimum from one that is a maximum or one that is neither. When the objective function is twice differentiable, these cases can be distinguished by checking the second derivative or the matrix of second derivatives (called the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a>) in unconstrained problems, or the matrix of second derivatives of the objective function and the constraints called the <a href="Hessian_matrix#Bordered_Hessian" title="wikilink">bordered Hessian</a> in constrained problems. The conditions that distinguish maxima, or minima, from other stationary points are called 'second-order conditions' (see '<a href="Second_derivative_test" title="wikilink">Second derivative test</a>'). If a candidate solution satisfies the first-order conditions, then satisfaction of the second-order conditions as well is sufficient to establish at least local optimality.</p>
<h3 id="sensitivity-and-continuity-of-optima">Sensitivity and continuity of optima</h3>

<p>The <a href="envelope_theorem" title="wikilink">envelope theorem</a> describes how the value of an optimal solution changes when an underlying <a class="uri" href="parameter" title="wikilink">parameter</a> changes. The process of computing this change is called <a href="comparative_statics" title="wikilink">comparative statics</a>.</p>

<p>The <a href="maximum_theorem" title="wikilink">maximum theorem</a> of <a href="Claude_Berge" title="wikilink">Claude Berge</a> (1963) describes the continuity of an optimal solution as a function of underlying parameters.</p>
<h3 id="calculus-of-optimization">Calculus of optimization</h3>

<p>For unconstrained problems with twice-differentiable functions, some <a href="critical_point_(mathematics)" title="wikilink">critical points</a> can be found by finding the points where the <a class="uri" href="gradient" title="wikilink">gradient</a> of the objective function is zero (that is, the stationary points). More generally, a zero <a class="uri" href="subgradient" title="wikilink">subgradient</a> certifies that a local minimum has been found for <a href="convex_optimization" title="wikilink">minimization problems with convex</a> <a href="convex_function" title="wikilink">functions</a> and other <a href="Rademacher's_theorem" title="wikilink">locally</a> <a href="Lipschitz_function" title="wikilink">Lipschitz functions</a>.</p>

<p>Further, critical points can be classified using the <a href="positive_definite_matrix" title="wikilink">definiteness</a> of the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a>: If the Hessian is <em>positive</em> definite at a critical point, then the point is a local minimum; if the Hessian matrix is negative definite, then the point is a local maximum; finally, if indefinite, then the point is some kind of <a href="saddle_point" title="wikilink">saddle point</a>.</p>

<p>Constrained problems can often be transformed into unconstrained problems with the help of <a href="Lagrange_multiplier" title="wikilink">Lagrange multipliers</a>. <a href="Lagrangian_relaxation" title="wikilink">Lagrangian relaxation</a> can also provide approximate solutions to difficult constrained problems.</p>

<p>When the objective function is <a href="Convex_function" title="wikilink">convex</a>, then any local minimum will also be a global minimum. There exist efficient numerical techniques for minimizing convex functions, such as <a href="interior-point_method" title="wikilink">interior-point methods</a>.</p>
<h2 id="computational-optimization-techniques">Computational optimization techniques</h2>

<p>To solve problems, researchers may use <a href="algorithm" title="wikilink">algorithms</a> that terminate in a finite number of steps, or <a href="iterative_method" title="wikilink">iterative methods</a> that converge to a solution (on some specified class of problems), or <a href="heuristic_algorithm" title="wikilink">heuristics</a> that may provide approximate solutions to some problems (although their iterates need not converge).</p>
<h3 id="optimization-algorithms">Optimization algorithms</h3>
<ul>
<li><a href="Simplex_algorithm" title="wikilink">Simplex algorithm</a> of <a href="George_Dantzig" title="wikilink">George Dantzig</a>, designed for <a href="linear_programming" title="wikilink">linear programming</a>.</li>
<li>Extensions of the simplex algorithm, designed for <a href="quadratic_programming" title="wikilink">quadratic programming</a> and for <a href="linear-fractional_programming" title="wikilink">linear-fractional programming</a>.</li>
<li>Variants of the simplex algorithm that are especially suited for <a href="flow_network" title="wikilink">network optimization</a>.</li>
<li><a href="Combinatorial_optimization" title="wikilink">Combinatorial algorithms</a></li>
</ul>
<h3 id="iterative-methods">Iterative methods</h3>

<p>The <a href="iterative_methods" title="wikilink">iterative methods</a> used to solve problems of <a href="nonlinear_programming" title="wikilink">nonlinear programming</a> differ according to whether they <a href="subroutine" title="wikilink">evaluate</a> <a href="Hessian_matrix" title="wikilink">Hessians</a>, gradients, or only function values. While evaluating Hessians (H) and gradients (G) improves the rate of convergence, for functions for which these quantities exist and vary sufficiently smoothly, such evaluations increase the <a href="Computational_complexity_theory" title="wikilink">computational complexity</a> (or computational cost) of each iteration. In some cases, the computational complexity may be excessively high.</p>

<p>One major criterion for optimizers is just the number of required function evaluations as this often is already a large computational effort, usually much more effort than within the optimizer itself, which mainly has to operate over the N variables. The derivatives provide detailed information for such optimizers, but are even harder to calculate, e.g. approximating the gradient takes at least N+1 function evaluations. For approximations of the 2nd derivatives (collected in the Hessian matrix) the number of function evaluations is in the order of N¬≤. Newton's method requires the 2nd order derivates, so for each iteration the number of function calls is in the order of N¬≤, but for a simpler pure gradient optimizer it is only N. However, gradient optimizers need usually more iterations than Newton's algorithm. Which one is best with respect to the number of function calls depends on the problem itself.</p>
<ul>
<li>Methods that evaluate Hessians (or approximate Hessians, using <a href="finite_difference" title="wikilink">finite differences</a>):
<ul>
<li><a href="Newton's_method_in_optimization" title="wikilink">Newton's method</a>
<ul>
<li><a href="Sequential_quadratic_programming" title="wikilink">Sequential quadratic programming</a>: A Newton-based method for small-medium scale <em>constrained</em> problems. Some versions can handle large-dimensional problems.</li>
</ul></li>
</ul></li>
</ul>
<ul>
<li>Methods that evaluate gradients or approximate gradients using finite differences (or even subgradients):
<ul>
<li><a href="Quasi-Newton_method" title="wikilink">Quasi-Newton methods</a>: Iterative methods for medium-large problems (e.g. N&lt;1000).</li>
<li><a href="Conjugate_gradient_method" title="wikilink">Conjugate gradient methods</a>: <a href="Iterative_method" title="wikilink">Iterative methods</a> for large problems. (In theory, these methods terminate in a finite number of steps with quadratic objective functions, but this finite termination is not observed in practice on finite‚Äìprecision computers.)</li>
<li><a href="Interior_point_methods" title="wikilink">Interior point methods</a>: This is a large class of methods for constrained optimization. Some interior-point methods use only (sub)gradient information, and others of which require the evaluation of Hessians.</li>
<li><a href="Gradient_descent" title="wikilink">Gradient descent</a> (alternatively, "steepest descent" or "steepest ascent"): A (slow) method of historical and theoretical interest, which has had renewed interest for finding approximate solutions of enormous problems.</li>
<li><a href="Subgradient_method" title="wikilink">Subgradient methods</a> - An iterative method for large <a href="Rademacher's_theorem" title="wikilink">locally</a> <a href="Lipschitz_continuity" title="wikilink">Lipschitz functions</a> using <a href="subgradient" title="wikilink">generalized gradients</a>. Following Boris T. Polyak, subgradient‚Äìprojection methods are similar to conjugate‚Äìgradient methods.</li>
<li>Bundle method of descent: An iterative method for small‚Äìmedium-sized problems with locally Lipschitz functions, particularly for <a href="convex_optimization" title="wikilink">convex minimization</a> problems. (Similar to conjugate gradient methods)</li>
<li><a href="Ellipsoid_method" title="wikilink">Ellipsoid method</a>: An iterative method for small problems with <a href="quasiconvex_function" title="wikilink">quasiconvex</a> objective functions and of great theoretical interest, particularly in establishing the polynomial time complexity of some combinatorial optimization problems. It has similarities with Quasi-Newton methods.</li>
<li><a href="Frank‚ÄìWolfe_algorithm" title="wikilink">Reduced gradient method (Frank‚ÄìWolfe)</a> for approximate minimization of specially structured problems with <a href="linear_constraints" title="wikilink">linear constraints</a>, especially with traffic networks. For general unconstrained problems, this method reduces to the gradient method, which is regarded as obsolete (for almost all problems).</li>
<li><a href="Simultaneous_perturbation_stochastic_approximation" title="wikilink">Simultaneous perturbation stochastic approximation</a> (SPSA) method for stochastic optimization; uses random (efficient) gradient approximation.</li>
</ul></li>
</ul>
<ul>
<li>Methods that evaluate only function values: If a problem is continuously differentiable, then gradients can be approximated using finite differences, in which case a gradient-based method can be used.
<ul>
<li><a class="uri" href="Interpolation" title="wikilink">Interpolation</a> methods</li>
<li><a href="Pattern_search_(optimization)" title="wikilink">Pattern search</a> methods, which have better convergence properties than the <a href="Nelder‚ÄìMead_method" title="wikilink">Nelder‚ÄìMead heuristic (with simplices)</a>, which is listed below.</li>
</ul></li>
</ul>
<h3 id="global-convergence">Global convergence</h3>

<p>More generally, if the objective function is not a quadratic function, then many optimization methods use other methods to ensure that some subsequence of iterations converges to an optimal solution. The first and still popular method for ensuring convergence relies on <a href="line_search" title="wikilink">line searches</a>, which optimize a function along one dimension. A second and increasingly popular method for ensuring convergence uses <a href="trust_region" title="wikilink">trust regions</a>. Both line searches and trust regions are used in modern methods of <a href="subgradient_method" title="wikilink">non-differentiable optimization</a>. Usually a global optimizer is much slower than advanced local optimizers (such as <a href="BFGS_method" title="wikilink">BFGS</a>), so often an efficient global optimizer can be constructed by starting the local optimizer from different starting points.</p>
<h3 id="heuristics">Heuristics</h3>

<p>Besides (finitely terminating) <a href="algorithm" title="wikilink">algorithms</a> and (convergent) <a href="iterative_method" title="wikilink">iterative methods</a>, there are <a href="heuristic_algorithm" title="wikilink">heuristics</a> that can provide approximate solutions to some optimization problems:</p>
<ul>
<li><a href="Memetic_algorithm" title="wikilink">Memetic algorithm</a></li>
<li><a href="Differential_evolution" title="wikilink">Differential evolution</a></li>
<li><a href="Evolutionary_algorithms" title="wikilink">Evolutionary algorithms</a></li>
<li><a href="Dynamic_relaxation" title="wikilink">Dynamic relaxation</a></li>
<li><a href="Genetic_algorithms" title="wikilink">Genetic algorithms</a></li>
<li><a href="Hill_climbing" title="wikilink">Hill climbing</a> with random restart</li>
<li><a href="Nelder-Mead_method" title="wikilink">Nelder-Mead simplicial heuristic</a>: A popular heuristic for approximate minimization (without calling gradients)</li>
<li><a href="Particle_swarm_optimization" title="wikilink">Particle swarm optimization</a></li>
<li><a href="Artificial_bee_colony_optimization" title="wikilink">Artificial bee colony optimization</a></li>
<li><a href="Simulated_annealing" title="wikilink">Simulated annealing</a></li>
<li><a href="Tabu_search" title="wikilink">Tabu search</a></li>
<li><a href="Reactive_Search_Optimization" title="wikilink">Reactive Search Optimization (RSO)</a><ref></ref></li>
</ul>

<p> implemented in <a class="uri" href="LIONsolver" title="wikilink">LIONsolver</a></p>
<h2 id="applications">Applications</h2>
<h3 id="mechanics-and-engineering">Mechanics and engineering</h3>

<p>Problems in <a href="rigid_body_dynamics" title="wikilink">rigid body dynamics</a> (in particular articulated rigid body dynamics) often require mathematical programming techniques, since you can view rigid body dynamics as attempting to solve an <a href="ordinary_differential_equation" title="wikilink">ordinary differential equation</a> on a constraint manifold; the constraints are various nonlinear geometric constraints such as "these two points must always coincide", "this surface must not penetrate any other", or "this point must always lie somewhere on this curve". Also, the problem of computing contact forces can be done by solving a <a href="linear_complementarity_problem" title="wikilink">linear complementarity problem</a>, which can also be viewed as a QP (quadratic programming) problem.</p>

<p>Many design problems can also be expressed as optimization programs. This application is called design optimization. One subset is the <a href="engineering_optimization" title="wikilink">engineering optimization</a>, and another recent and growing subset of this field is <a href="multidisciplinary_design_optimization" title="wikilink">multidisciplinary design optimization</a>, which, while useful in many problems, has in particular been applied to <a href="aerospace_engineering" title="wikilink">aerospace engineering</a> problems.</p>
<h3 id="economics">Economics</h3>

<p><a class="uri" href="Economics" title="wikilink">Economics</a> is closely enough linked to optimization of <a href="agent_(economics)" title="wikilink">agents</a> that an influential definition relatedly describes economics <em>qua</em> science as the "study of human behavior as a relationship between ends and <a class="uri" href="scarce" title="wikilink">scarce</a> means" with alternative uses.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Modern optimization theory includes traditional optimization theory but also overlaps with <a href="game_theory" title="wikilink">game theory</a> and the study of economic <a href="equilibrium_(economics)" title="wikilink">equilibria</a>. The <em><a href="Journal_of_Economic_Literature" title="wikilink">Journal of Economic Literature</a></em> <a href="JEL_classification_codes" title="wikilink">codes</a> classify mathematical programming, optimization techniques, and related topics under <a href="JEL_classification_codes#Mathematical_and_quantitative_methods_JEL:_C_Subcategories" title="wikilink">JEL:C61-C63</a>.</p>

<p>In microeconomics, the <a href="utility_maximization_problem" title="wikilink">utility maximization problem</a> and its <a href="dual_problem" title="wikilink">dual problem</a>, the <a href="expenditure_minimization_problem" title="wikilink">expenditure minimization problem</a>, are economic optimization problems. Insofar as they behave consistently, <a href="consumer" title="wikilink">consumers</a> are assumed to maximize their <a class="uri" href="utility" title="wikilink">utility</a>, while <a href="firm" title="wikilink">firms</a> are usually assumed to maximize their <a href="Profit_(economics)" title="wikilink">profit</a>. Also, agents are often modeled as being <a href="Risk_aversion" title="wikilink">risk-averse</a>, thereby preferring to avoid risk. <a href="Asset_pricing" title="wikilink">Asset prices</a> are also modeled using optimization theory, though the underlying mathematics relies on optimizing <a href="stochastic_process" title="wikilink">stochastic processes</a> rather than on static optimization. <a class="uri" href="Trade" title="wikilink">Trade</a> theory also uses optimization to explain trade patterns between nations. The optimization of <a href="Portfolio_(finance)" title="wikilink">market portfolios</a> is an example of multi-objective optimization in economics.</p>

<p>Since the 1970s, economists have modeled dynamic decisions over time using <a href="control_theory" title="wikilink">control theory</a>. For example, microeconomists use <a href="dynamic_programming" title="wikilink">dynamic</a> <a href="search_theory" title="wikilink">search models</a> to study <a href="labor_economics" title="wikilink">labor-market behavior</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A crucial distinction is between deterministic and stochastic models.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a href="Macroeconomics" title="wikilink">Macroeconomists</a> build <a href="dynamic_stochastic_general_equilibrium" title="wikilink">dynamic stochastic general equilibrium (DSGE)</a> models that describe the dynamics of the whole economy as the result of the interdependent optimizing decisions of workers, consumers, investors, and governments.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="operations-research">Operations research</h3>

<p>Another field that uses optimization techniques extensively is <a href="operations_research" title="wikilink">operations research</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Operations research also uses stochastic modeling and simulation to support improved decision-making. Increasingly, operations research uses <a href="stochastic_programming" title="wikilink">stochastic programming</a> to model dynamic decisions that adapt to events; such problems can be solved with large-scale optimization and <a href="stochastic_optimization" title="wikilink">stochastic optimization</a> methods.</p>
<h3 id="control-engineering">Control engineering</h3>

<p>Mathematical optimization is used in much modern controller design. High-level controllers such as <a href="Model_predictive_control" title="wikilink">Model predictive control</a> (MPC) or Real-Time Optimization (RTO) employ mathematical optimization. These algorithms run online and repeatedly determine values for decision variables, such as choke openings in a process plant, by iteratively solving a mathematical optimization problem including constraints and a model of the system to be controlled.</p>
<h3 id="petroleum-engineering">Petroleum engineering</h3>

<p>Nonlinear optimization methods are used to construct computational models of oil reservoirs.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="molecular-modeling">Molecular modeling</h3>

<p>Nonlinear optimization methods are widely used in <a href="conformational_analysis" title="wikilink">conformational analysis</a>.</p>
<h2 id="solvers">Solvers</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Brachistochrone" title="wikilink">Brachistochrone</a></li>
<li><a href="Curve_fitting" title="wikilink">Curve fitting</a></li>
<li><a href="Goal_programming" title="wikilink">Goal programming</a></li>
<li><a href="List_of_publications_in_mathematics#Optimization" title="wikilink">Important publications in optimization</a></li>
</ul>
<ul>
<li><a href="Least_squares" title="wikilink">Least squares</a></li>
<li><a href="Mathematical_Optimization_Society" title="wikilink">Mathematical Optimization Society</a> (formerly Mathematical Programming Society)</li>
</ul>
<ul>
<li><a href=":Category:Optimization_algorithms_and_methods" title="wikilink">Mathematical optimization algorithms</a></li>
<li><a href=":Category:Mathematical_optimization_software" title="wikilink">Mathematical optimization software</a></li>
<li><a href="Process_optimization" title="wikilink">Process optimization</a></li>
<li><a href="Variational_calculus" title="wikilink">Variational calculus</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="further-reading">Further reading</h2>
<h3 id="comprehensive">Comprehensive</h3>
<h4 id="undergraduate-level">Undergraduate level</h4>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<h4 id="graduate-level">Graduate level</h4>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>
<ul>
<li><a href="J._E._Dennis,_Jr." title="wikilink">J. E. Dennis, Jr.</a> and <a href="Robert_B._Schnabel" title="wikilink">Robert B. Schnabel</a>, A view of unconstrained optimization (pp.¬†1‚Äì72);</li>
<li><a href="Donald_Goldfarb" title="wikilink">Donald Goldfarb</a> and <a href="Michael_J._Todd_(mathematician)" title="wikilink">Michael J. Todd</a>, Linear programming (pp.¬†73‚Äì170);</li>
<li>Philip E. Gill, Walter Murray, Michael A. Saunders, and <a href="Margaret_H._Wright" title="wikilink">Margaret H. Wright</a>, Constrained nonlinear programming (pp.¬†171‚Äì210);</li>
<li><a href="Ravindra_K._Ahuja" title="wikilink">Ravindra K. Ahuja</a>, <a href="Thomas_L._Magnanti" title="wikilink">Thomas L. Magnanti</a>, and <a href="James_B._Orlin" title="wikilink">James B. Orlin</a>, Network flows (pp.¬†211‚Äì369);</li>
<li><a href="W._R._Pulleyblank" title="wikilink">W. R. Pulleyblank</a>, Polyhedral combinatorics (pp.¬†371‚Äì446);</li>
<li>George L. Nemhauser and Laurence A. Wolsey, Integer programming (pp.¬†447‚Äì527);</li>
<li><a href="Claude_Lemar√©chal" title="wikilink">Claude Lemar√©chal</a>, Nondifferentiable optimization (pp.¬†529‚Äì572);</li>
<li><a href="Roger_J-B_Wets" title="wikilink">Roger J-B Wets</a>, Stochastic programming (pp.¬†573‚Äì629);</li>
<li>A. H. G. Rinnooy Kan and G. T. Timmer, Global optimization (pp.¬†631‚Äì662);</li>
<li>P. L. Yu, Multiple criteria decision making: five basic concepts (pp.¬†663‚Äì699).</li>
</ul></li>
</ul>
<ul>
<li></li>
<li>Spall, J. C. (2003), <em>Introduction to Stochastic Search and Optimization: Estimation, Simulation, and Control</em>, Wiley, Hoboken, NJ.</li>
</ul>
<h3 id="continuous-optimization">Continuous optimization</h3>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3 id="combinatorial-optimization">Combinatorial optimization</h3>
<ul>
<li>R. K. Ahuja, <a href="Thomas_L._Magnanti" title="wikilink">Thomas L. Magnanti</a>, and <a href="James_B._Orlin" title="wikilink">James B. Orlin</a> (1993). <em>Network Flows: Theory, Algorithms, and Applications</em>. Prentice-Hall, Inc. ISBN 0-13-617549-X.</li>
<li><a href="William_J._Cook" title="wikilink">William J. Cook</a>, William H. Cunningham, William R. Pulleyblank, <a href="Alexander_Schrijver" title="wikilink">Alexander Schrijver</a>; <em>Combinatorial Optimization</em>; John Wiley &amp; Sons; 1 edition (November 12, 1997); ISBN 0-471-55894-X.</li>
<li></li>
<li></li>
<li>

<p>.</p></li>
<li><a href="Jon_Lee_(mathematician)" title="wikilink">Jon Lee</a>; <em>[<a class="uri" href="http://books.google.com/books?id=3pL1B7WVYnAC&amp;printsec">http://books.google.com/books?id=3pL1B7WVYnAC&amp;printsec;</a>;=frontcover&amp;source;=gbs_ge_summary_r&amp;cad;=0#v=onepage&amp;q;&amp;f;=false A First Course in Combinatorial Optimization]</em>; Cambridge University Press; 2004; ISBN 0-521-01012-8.</li>
<li>Christos H. Papadimitriou and <a href="Kenneth_Steiglitz" title="wikilink">Kenneth Steiglitz</a> <em>Combinatorial Optimization : Algorithms and Complexity</em>; Dover Pubns; (paperback, Unabridged edition, July 1998) ISBN 0-486-40258-4.</li>
</ul>
<h3 id="relaxation-extension-method">Relaxation (extension method)</h3>

<p>Methods to obtain suitable (in some sense) natural extensions of optimization problems that otherwise lack of existence or stability of solutions to obtain problems with guaranteed existence of solutions and their stability in some sense (typically under various perturbation of data) are in general called relaxation. Solutions of such extended (=relaxed) problems in some sense characterizes (at least certain features) of the original problems, e.g. as far as their optimizing sequences concerns. Relaxed problems may also possesses their own natural linear structure that may yield specific optimality conditions different from optimality conditions for the original problems.</p>
<ul>
<li>H. O. Fattorini: Infinite Dimensional Optimization and Control Theory. Cambridge Univ. Press, 1999.</li>
<li>P. Pedregal: Parametrized Measures and Variational Principles. Birkh√§user, Basel, 1997</li>
<li>T. Roubicek: <a href="http://www.amazon.co.uk/exec/obidos/ASIN/3110145421/qid%3D1000637090/202-7422833-6521417">"Relaxation in Optimization Theory and Variational Calculus"</a>. W. de Gruyter, Berlin, 1997. ISBN 3-11-014542-1.</li>
<li>J. Warga: Optimal control of differential and functional equations. Academic Press, 1972.</li>
</ul>
<h2 id="journals">Journals</h2>
<ul>
<li><a href="http://www.springer.com/mathematics/journal/10589"><em>Computational Optimization and Applications</em></a></li>
<li><a href="https://www.novapublishers.com/catalog/product_info.php?products_id=6353">Journal of Computational <em>Optimization in Economics and Finance</em></a></li>
<li><a href="http://www.journals.elsevier.com/journal-of-economic-dynamics-and-control/"><em>Journal of Economic Dynamics and Control</em></a></li>
<li><a href="http://www.siam.org/journals/siopt.php"><em>SIAM Journal on Optimization</em> (SIOPT)</a> and <a href="http://www.siam.org/journals/siopt/policy.php">Editorial Policy</a></li>
<li><a href="http://www.siam.org/journals/sicon.php"><em>SIAM Journal on Control and Optimization</em> (SICON)</a> and <a href="http://www.siam.org/journals/sicon/policy.php">Editorial Policy</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.coin-or.org/">COIN-OR</a>‚ÄîComputational Infrastructure for Operations Research</li>
<li><a href="http://plato.asu.edu/guide.html">Decision Tree for Optimization Software</a> Links to optimization source codes</li>
<li><a href="http://www.mat.univie.ac.at/%7Eneum/glopt.html">Global optimization</a></li>
<li><a href="http://glossary.computing.society.informs.org/">Mathematical Programming Glossary</a></li>
<li><a href="http://www.mathprog.org/">Mathematical Programming Society</a></li>
<li><a href="http://www-fp.mcs.anl.gov/otc/Guide/index.html">NEOS Guide</a> currently being replaced by the <a href="http://wiki.mcs.anl.gov/neos">NEOS Wiki</a></li>
<li><a href="http://www.optimization-online.org">Optimization Online</a> A repository for optimization e-prints</li>
<li><a href="http://www2.arnes.si/%7Eljc3m2/igor/links.html">Optimization Related Links</a></li>
<li><a href="http://see.stanford.edu/see/courseinfo.aspx?coll=2db7ced4-39d1-4fdb-90e8-364129597c87">Convex Optimization I</a> EE364a: Course from Stanford University</li>
<li><a href="http://www.stanford.edu/~boyd/cvxbook">Convex Optimization ‚Äì Boyd and Vandenberghe</a> Book on Convex Optimization</li>
<li><a href="http://apmonitor.com/me575/index.php/Main/BookChapters">Book and Course</a> on Optimization Methods for Engineering Design</li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_optimization" title="wikilink"> </a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">"<a href="http://glossary.computing.society.informs.org/index.php?page=nature.html">The Nature of Mathematical Programming</a>," <em>Mathematical Programming Glossary</em>, INFORMS Computing Society.<a href="#fnref1">‚Ü©</a></li>
<li id="fn2">W. Erwin Diewert (2008). "cost functions," <em>The New Palgrave Dictionary of Economics</em>, 2nd Edition [<a class="uri" href="http://www.dictionaryofeconomics.com/article?id=pde2008_C000390&amp;edition">http://www.dictionaryofeconomics.com/article?id=pde2008_C000390&amp;edition;</a>;=current&amp;q;= Contents].<a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="Lionel_Robbins" title="wikilink">Lionel Robbins</a> (1935, 2nd ed.) <em><a href="An_Essay_on_the_Nature_and_Significance_of_Economic_Science#Major_propositions" title="wikilink">An Essay on the Nature and Significance of Economic Science</a></em>, Macmillan, p. 16.<a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="Avinash_Dixit" title="wikilink">A. K. Dixit</a> ([1976] 1990). <em>Optimization in Economic Theory</em>, 2nd ed., Oxford. [<a class="uri" href="http://books.google.com/books?id=dHrsHz0VocUC&amp;pg">http://books.google.com/books?id=dHrsHz0VocUC&amp;pg;</a>;=find&amp;pg;=PA194=false#v=onepage&amp;q;&amp;f;=false Description] and contents [<a class="uri" href="http://books.google.com/books?id=dHrsHz0VocUC&amp;pg">http://books.google.com/books?id=dHrsHz0VocUC&amp;pg;</a>;=PR7&amp;lpg;=PR6&amp;dq;=false&amp;lr;=#v=onepage&amp;q;=false&amp;f;=false preview].<a href="#fnref4">‚Ü©</a></li>
<li id="fn5">A.G. Malliaris (2008). "stochastic optimal control," <em>The New Palgrave Dictionary of Economics</em>, 2nd Edition. [<a class="uri" href="http://www.dictionaryofeconomics.com/article?id=pde2008_S000269&amp;edition">http://www.dictionaryofeconomics.com/article?id=pde2008_S000269&amp;edition;</a>;=&amp;field;=keyword&amp;q;=Taylor's%20th&amp;topicid;=&amp;result;_number=1 Abstract].<a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="Julio_Rotemberg" title="wikilink">Julio Rotemberg</a> and <a href="Michael_Woodford_(economist)" title="wikilink">Michael Woodford</a> (1997), "An Optimization-based Econometric Framework for the Evaluation of Monetary Policy.<em>NBER Macroeconomics Annual</em>, 12, pp. <a href="http://people.hbs.edu/jrotemberg/PublishedArticles/OptimizBasedEconometric_97.pdf">297-346.</a><a href="#fnref6">‚Ü©</a></li>
<li id="fn7">From <em><a href="The_New_Palgrave_Dictionary_of_Economics" title="wikilink">The New Palgrave Dictionary of Economics</a></em> (2008), 2nd Edition with Abstract links:<br/>
¬†¬† ‚Ä¢ "[<a class="uri" href="http://www.dictionaryofeconomics.com/article?id=pde2008_N000148&amp;edition">http://www.dictionaryofeconomics.com/article?id=pde2008_N000148&amp;edition;</a>;=current&amp;q;=optimization&amp;topicid;=&amp;result;_number=1 numerical optimization methods in economics]" by Karl Schmedders<br/>
¬†¬† ‚Ä¢ "[<a class="uri" href="http://www.dictionaryofeconomics.com/article?id=pde2008_C000348&amp;edition">http://www.dictionaryofeconomics.com/article?id=pde2008_C000348&amp;edition;</a>;=current&amp;q;=optimization&amp;topicid;=&amp;result;_number=4 convex programming]" by <a href="Lawrence_E._Blume" title="wikilink">Lawrence E. Blume</a><br/>
¬†¬† ‚Ä¢ "[<a class="uri" href="http://www.dictionaryofeconomics.com/article?id=pde2008_A000133&amp;edition">http://www.dictionaryofeconomics.com/article?id=pde2008_A000133&amp;edition;</a>;=current&amp;q;=optimization&amp;topicid;=&amp;result;_number=20 Arrow‚ÄìDebreu model of general equilibrium]" by <a href="John_Geanakoplos" title="wikilink">John Geanakoplos</a>.<a href="#fnref7">‚Ü©</a></li>
<li id="fn8"><a href="#fnref8">‚Ü©</a></li>
<li id="fn9"><a href="#fnref9">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
