<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1500">Hadamard code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hadamard code</h1>
<hr/>

<p> </p>

<p>The <strong>Hadamard code</strong> is an <a href="error-correcting_code" title="wikilink">error-correcting code</a> that is used for <a href="error_detection_and_correction" title="wikilink">error detection and correction</a> when transmitting messages over very noisy or unreliable channels. In 1971, the code was used to transmit photos of Mars back to Earth from the NASA space probe <a href="Mariner_9" title="wikilink">Mariner 9</a> Because of its unique mathematical properties, the Hadamard code is not only used by engineers, but also intensely studied in <a href="coding_theory" title="wikilink">coding theory</a>, <a class="uri" href="mathematics" title="wikilink">mathematics</a>, and <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>. The Hadamard code is named after the French mathematician <a href="Jacques_Hadamard" title="wikilink">Jacques Hadamard</a>. It also known under the names <strong>Walsh code</strong>, <strong>Walsh family</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and <strong>Walsh–Hadamard code</strong><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> in recognition of the American mathematician <a href="Joseph_Leonard_Walsh" title="wikilink">Joseph Leonard Walsh</a>.</p>

<p>The Hadamard code is an example of a <a href="linear_code" title="wikilink">linear code</a> over a <a href="binary_set" title="wikilink">binary alphabet</a> that maps messages of length 

<math display="inline" id="Hadamard_code:0">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 to codewords of length 

<math display="inline" id="Hadamard_code:1">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}
  </annotation>
 </semantics>
</math>

. It is unique in that each non-zero codeword has a <a href="Hamming_weight" title="wikilink">Hamming weight</a> of exactly 

<math display="inline" id="Hadamard_code:2">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>k</mi>
   </msup>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}/2
  </annotation>
 </semantics>
</math>

, which implies that the <a href="Block_code#The_distance_d" title="wikilink">distance</a> of the code is also 

<math display="inline" id="Hadamard_code:3">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>k</mi>
   </msup>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}/2
  </annotation>
 </semantics>
</math>

. In standard <a href="Block_code#Popular_notation" title="wikilink">coding theory notation</a> for <a href="block_code" title="wikilink">block codes</a>, the Hadamard code is a 

<math display="inline" id="Hadamard_code:4">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mn>2</mn>
     <mi>k</mi>
    </msup>
    <mo>,</mo>
    <mi>k</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
     <ci>k</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </list>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [2^{k},k,2^{k}/2]_{2}
  </annotation>
 </semantics>
</math>

-code, that is, it is a <a href="linear_code" title="wikilink">linear code</a> over a <a href="binary_set" title="wikilink">binary alphabet</a>, has <a href="Block_code#The_block_length_n" title="wikilink">block length</a> 

<math display="inline" id="Hadamard_code:5">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}
  </annotation>
 </semantics>
</math>

, <a href="Block_code#The_message_length_k" title="wikilink">message length</a> (or dimension) 

<math display="inline" id="Hadamard_code:6">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, and <a href="Block_code#The_distance_d" title="wikilink">minimum distance</a> 

<math display="inline" id="Hadamard_code:7">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>k</mi>
   </msup>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}/2
  </annotation>
 </semantics>
</math>

. The block length is very large compared to the message length, but on the other hand, errors can be corrected even in extremely noisy conditions. The <strong>punctured Hadamard code</strong> is a slightly improved version of the Hadamard code; it is a 

<math display="inline" id="Hadamard_code:8">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>,</mo>
    <mi>k</mi>
    <mo>,</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </list>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [2^{k-1},k,2^{k-2}]_{2}
  </annotation>
 </semantics>
</math>

-code and thus has a slightly better <a href="Block_code#The_rate_R" title="wikilink">rate</a> while maintaining the relative distance of 

<math display="inline" id="Hadamard_code:9">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2
  </annotation>
 </semantics>
</math>

, and is thus preferred in practical applications. The punctured Hadamard code is the same as the first order <a href="Reed–Muller_code" title="wikilink">Reed–Muller code</a> over the binary alphabet.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Normally, Hadamard codes are based on <a href="Hadamard_matrix#Sylvester's_construction" title="wikilink">Sylvester's construction of Hadamard matrices</a>, but the term “Hadamard code” is also used to refer to codes constructed from arbitrary <a href="Hadamard_matrix" title="wikilink">Hadamard matrices</a>, which are not necessarily of Sylvester type. In general, such a code is not linear. Such codes were first constructed by <a href="R._C._Bose" title="wikilink">R. C. Bose</a> and <a href="Sharadchandra_Shankar_Shrikhande" title="wikilink">S. S. Shrikhande</a> in 1959.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> If <em>n</em> is the size of the Hadamard matrix, the code has parameters 

<math display="inline" id="Hadamard_code:10">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mrow>
     <mn>2</mn>
     <mi>n</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <vector>
     <ci>n</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </vector>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,2n,n/2)_{2}
  </annotation>
 </semantics>
</math>

, meaning it is a not-necessarily-linear binary code with 2<em>n</em> codewords of block length <em>n</em> and minimal distance <em>n</em>/2. The construction and decoding scheme described below apply for general <em>n</em>, but the property of linearity and the identification with Reed–Muller codes require that <em>n</em> be a power of 2 and that the Hadamard matrix be equivalent to the matrix constructed by Sylvester's method.</p>

<p>The Hadamard code is a <a href="locally_decodable" title="wikilink">locally decodable</a> code, which provides a way to recover parts of the original message with high probability, while only looking at a small fraction of the received word. This gives rise to applications in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> and particularly in the design of <a href="probabilistically_checkable_proofs" title="wikilink">probabilistically checkable proofs</a>. Since the relative distance of the Hadamard code is 1/2, normally one can only hope to recover from at most a 1/4 fraction of error. Using <a href="list_decoding" title="wikilink">list decoding</a>, however, it is possible to compute a short list of possible candidate messages as long as fewer than 

<math display="inline" id="Hadamard_code:11">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mo>-</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}-\epsilon
  </annotation>
 </semantics>
</math>

 of the bits in the received word have been corrupted.</p>

<p>In <a href="code_division_multiple_access" title="wikilink">code division multiple access</a> (CDMA) communication, the Hadamard code is referred to as Walsh Code, and is used to define individual <a href="telecommunications" title="wikilink">communication</a> <a href="channel_(communications)" title="wikilink">channels</a>. It is usual in the CDMA literature to refer to codewords as “codes”. Each user will use a different codeword, or “code”, to modulate their signal. Because Walsh codewords are mathematically <a class="uri" href="orthogonal" title="wikilink">orthogonal</a>, a Walsh-encoded signal appears as <a href="random_noise" title="wikilink">random noise</a> to a CDMA capable mobile <a href="terminal_(telecommunication)" title="wikilink">terminal</a>, unless that terminal uses the same codeword as the one used to encode the incoming <a href="signal_(information_theory)" title="wikilink">signal</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="history">History</h2>

<p><em>Hadamard code</em> is the name that is most commonly used for this code in the literature. <a href="Jacques_Hadamard" title="wikilink">Jacques Hadamard</a> did not invent the code himself, but he defined <a href="Hadamard_matrix" title="wikilink">Hadamard matrices</a> around 1893, long before the first <a href="error-correcting_code" title="wikilink">error-correcting code</a>, the <a href="Hamming_code" title="wikilink">Hamming code</a>, was developed in the 1940s. The Hadamard code is based on Hadamard matrices, and while there are many different Hadamard matrices that could be used here, normally only <a href="Hadamard_matrix#Sylvester's_construction" title="wikilink">Sylvester's construction of Hadamard matrices</a> is used to obtain the codewords of the Hadamard code. <a href="James_Joseph_Sylvester" title="wikilink">James Joseph Sylvester</a> developed his construction of Hadamard matrices in 1867, which actually predates Hadamard's work on Hadamard matrices. Hence the name <em>Hadamard code</em> is not undisputed and sometimes the code is called <em>Walsh code</em>, honoring the American mathematician <a href="Joseph_Leonard_Walsh" title="wikilink">Joseph Leonard Walsh</a>.</p>

<p>A Hadamard code was used during the 1971 <a href="Mariner_9" title="wikilink">Mariner 9</a> mission to correct for picture transmission errors. The data words used during this mission were 6 bits long, which represented 64 <a class="uri" href="grayscale" title="wikilink">grayscale</a> values. Because of limitations of the quality of the alignment of the transmitter the maximum useful data length was about 30 bits. Instead of using a <a href="repetition_code" title="wikilink">repetition code</a>, a [32, 6, 16] Hadamard code was used. Errors of up to 7 bits per word could be corrected using this scheme. Compared to a 5-<a href="repetition_code" title="wikilink">repetition code</a>, the error correcting properties of this Hadamard code are much better, yet its rate is comparable. The efficient decoding algorithm was an important factor in the decision to use this code. The circuitry used was called the "Green Machine". It employed the <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a> which can increase the decoding speed by a factor of three. Since the 1990s use of this code by space programs has more or less ceased, and the Deep Space Network does not support this error correction scheme for its dishes that are greater than 26 m.</p>
<h2 id="constructions">Constructions</h2>

<p>While all Hadamard codes are based on Hadamard matrices, the constructions differ in subtle ways for different scientific fields, authors, and uses. Engineers, who use the codes for data transmission, and <a href="coding_theory" title="wikilink">coding theorists</a>, who analyze extremal properties of codes, typically want the <a href="Block_code#The_rate_R" title="wikilink">rate</a> of the code to be as high as possible, even if this means that the construction becomes mathematically slightly less elegant. On the other hand, for many applications of Hadamard codes in <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a> it is not so important to achieve the optimal rate, and hence simpler constructions of Hadamard codes are preferred since they can be analyzed more elegantly.</p>
<h3 id="construction-using-inner-products">Construction using inner products</h3>

<p>When given a binary message 

<math display="inline" id="Hadamard_code:12">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\{0,1\}^{k}
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="Hadamard_code:13">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, the Hadamard code encodes the message into a codeword 

<math display="inline" id="Hadamard_code:14">
 <semantics>
  <mrow>
   <mtext>Had</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Had</mtext>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Had}(x)
  </annotation>
 </semantics>
</math>

 using an encoding function 

<math display="inline" id="Hadamard_code:15">
 <semantics>
  <mrow>
   <mtext>Had</mtext>
   <mo>:</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>k</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>Had</mtext>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Had}:\{0,1\}^{k}\to\{0,1\}^{2^{k}}
  </annotation>
 </semantics>
</math>

. This function makes use of the <a href="inner_product" title="wikilink">inner product</a> 

<math display="inline" id="Hadamard_code:16">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,y\rangle
  </annotation>
 </semantics>
</math>

 of two vectors 

<math display="inline" id="Hadamard_code:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>x</ci>
     <ci>y</ci>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y\in\{0,1\}^{k}
  </annotation>
 </semantics>
</math>

, which is defined as follows:</p>

<p>

<math display="block" id="Hadamard_code:18">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>k</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mpadded width="+5pt">
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
      </mpadded>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mn>2 .</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>x</ci>
     <ci>y</ci>
    </list>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <cn type="float">2 .</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,y\rangle=\sum_{i=1}^{k}x_{i}y_{i}\ \bmod\ 2\,.
  </annotation>
 </semantics>
</math>

 Then the Hadamard encoding of 

<math display="inline" id="Hadamard_code:19">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is defined as the sequence of <em>all</em> inner products with 

<math display="inline" id="Hadamard_code:20">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Hadamard_code:21">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Had</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo maxsize="160%" minsize="160%">(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo maxsize="160%" minsize="160%">)</mo>
    </mrow>
    <mrow>
     <mi>y</mi>
     <mo>∈</mo>
     <msup>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">}</mo>
      </mrow>
      <mi>k</mi>
     </msup>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>Had</mtext>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <ci>x</ci>
      <ci>y</ci>
     </list>
     <apply>
      <in></in>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <set>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </set>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Had}(x)=\Big(\langle x,y\rangle\Big)_{y\in\{0,1\}^{k}}
  </annotation>
 </semantics>
</math>

</p>

<p>As mentioned above, the <em>punctured</em> Hadamard code is used in practice since the Hadamard code itself is somewhat wasteful. This is because, if the first bit of 

<math display="inline" id="Hadamard_code:22">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is zero, 

<math display="inline" id="Hadamard_code:23">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}=0
  </annotation>
 </semantics>
</math>

, then the inner product contains no information whatsoever about 

<math display="inline" id="Hadamard_code:24">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

, and hence, it is impossible to fully decode 

<math display="inline" id="Hadamard_code:25">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 from those positions of the codeword alone. On the other hand, when the codeword is restricted to the positions where 

<math display="inline" id="Hadamard_code:26">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}=1
  </annotation>
 </semantics>
</math>

, it is still possible to fully decode 

<math display="inline" id="Hadamard_code:27">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. Hence it makes sense to restrict the Hadamard code to these positions, which gives rise to the <em>punctured</em> Hadamard encoding of 

<math display="inline" id="Hadamard_code:28">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

; that is, 

<math display="inline" id="Hadamard_code:29">
 <semantics>
  <mrow>
   <mrow>
    <mtext>pHad</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo maxsize="160%" minsize="160%">(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo maxsize="160%" minsize="160%">)</mo>
    </mrow>
    <mrow>
     <mi>y</mi>
     <mo>∈</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>1</mn>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo>×</mo>
      <msup>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>pHad</mtext>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <ci>x</ci>
      <ci>y</ci>
     </list>
     <apply>
      <in></in>
      <ci>y</ci>
      <apply>
       <times></times>
       <set>
        <cn type="integer">1</cn>
       </set>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <set>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </set>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{pHad}(x)=\Big(\langle x,y\rangle\Big)_{y\in\{1\}\times\{0,1\}^{k-1}}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="construction-using-a-generator-matrix">Construction using a generator matrix</h3>

<p>The Hadamard code is a linear code, and all linear codes can be generated by a generator matrix 

<math display="inline" id="Hadamard_code:30">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. This is a matrix such that 

<math display="inline" id="Hadamard_code:31">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Had</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>⋅</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>Had</mtext>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>x</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Had}(x)=x\cdot G
  </annotation>
 </semantics>
</math>

 holds for all 

<math display="inline" id="Hadamard_code:32">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\{0,1\}^{k}
  </annotation>
 </semantics>
</math>

, where the message 

<math display="inline" id="Hadamard_code:33">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is viewed as a row vector and the vector-matrix product is understood in the <a href="vector_space" title="wikilink">vector space</a> over the <a href="finite_field" title="wikilink">finite field</a> 

<math display="inline" id="Hadamard_code:34">
 <semantics>
  <msub>
   <mi>𝔽</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔽</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{2}
  </annotation>
 </semantics>
</math>

. In particular, an equivalent way to write the inner product definition for the Hadamard code arises by using the generator matrix whose columns consist of <em>all</em> strings 

<math display="inline" id="Hadamard_code:35">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="Hadamard_code:36">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, that is,</p>

<p>

<math display="block" id="Hadamard_code:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mo>↑</mo>
        </mtd>
        <mtd columnalign="center">
         <mo>↑</mo>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mo>↑</mo>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>y</mi>
          <mn>1</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>y</mi>
          <mn>2</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">…</mi>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>y</mi>
          <msup>
           <mn>2</mn>
           <mi>k</mi>
          </msup>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mo>↓</mo>
        </mtd>
        <mtd columnalign="center">
         <mo>↓</mo>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mo>↓</mo>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mpadded>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <matrix>
     <matrixrow>
      <ci>normal-↑</ci>
      <ci>normal-↑</ci>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-↑</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>k</ci>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-↓</ci>
      <ci>normal-↓</ci>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-↓</ci>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\begin{pmatrix}\uparrow&\uparrow&&\uparrow\\
y_{1}&y_{2}&\dots&y_{2^{k}}\\
\downarrow&\downarrow&&\downarrow\end{pmatrix}\,.
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Hadamard_code:38">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\in\{0,1\}^{k}
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Hadamard_code:39">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th binary vector in <a href="lexicographical_order" title="wikilink">lexicographical order</a>. For example, the generator matrix for the Hadamard code of dimension 

<math display="inline" id="Hadamard_code:40">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=3
  </annotation>
 </semantics>
</math>

 is:</p>

<p>

<math display="block" id="Hadamard_code:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\begin{bmatrix}0&0&0&0&1&1&1&1\\
0&0&1&1&0&0&1&1\\
0&1&0&1&0&1&0&1\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>The matrix 

<math display="inline" id="Hadamard_code:42">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Hadamard_code:43">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>k</mi>
    <mo>×</mo>
    <msup>
     <mn>2</mn>
     <mi>k</mi>
    </msup>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (k\times 2^{k})
  </annotation>
 </semantics>
</math>

-matrix and gives rise to the <a href="linear_operator" title="wikilink">linear operator</a> 

<math display="inline" id="Hadamard_code:44">
 <semantics>
  <mrow>
   <mtext>Had</mtext>
   <mo>:</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>k</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>Had</mtext>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Had}:\{0,1\}^{k}\to\{0,1\}^{2^{k}}
  </annotation>
 </semantics>
</math>

.</p>

<p>The generator matrix of the <em>punctured</em> Hadamard code is obtained by restricting the matrix 

<math display="inline" id="Hadamard_code:45">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 to the columns whose first entry is one. For example, the generator matrix for the punctured Hadamard code of dimension 

<math display="inline" id="Hadamard_code:46">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=3
  </annotation>
 </semantics>
</math>

 is:</p>

<p>

<math display="block" id="Hadamard_code:47">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>G</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}=\begin{bmatrix}1&1&1&1\\
0&0&1&1\\
0&1&0&1\end{bmatrix}.
  </annotation>
 </semantics>
</math>

 Then 

<math display="inline" id="Hadamard_code:48">
 <semantics>
  <mrow>
   <mtext>pHad</mtext>
   <mo>:</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>k</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>pHad</mtext>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{pHad}:\{0,1\}^{k}\to\{0,1\}^{2^{k-1}}
  </annotation>
 </semantics>
</math>

 is a linear mapping with 

<math display="inline" id="Hadamard_code:49">
 <semantics>
  <mrow>
   <mrow>
    <mtext>pHad</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>⋅</mo>
    <msup>
     <mi>G</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>pHad</mtext>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{pHad}(x)=x\cdot G^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>For general 

<math display="inline" id="Hadamard_code:50">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, the generator matrix of the punctured Hadamard code is a <a href="parity-check_matrix" title="wikilink">parity-check matrix</a> for the <a href="Hamming_code#Hamming_codes_with_additional_parity_(SECDED)" title="wikilink">extended Hamming code</a> of length 

<math display="inline" id="Hadamard_code:51">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k-1}
  </annotation>
 </semantics>
</math>

 and dimension 

<math display="inline" id="Hadamard_code:52">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k-1}-k
  </annotation>
 </semantics>
</math>

, which makes the punctured Hadamard code the <a href="dual_code" title="wikilink">dual code</a> of the extended Hamming code. Hence an alternative way to define the Hadamard code is in terms of its parity-check matrix: the parity-check matrix of the Hadamard code is equal to the generator matrix of the Hamming code.</p>
<h3 id="construction-using-general-hadamard-matrices">Construction using general Hadamard matrices</h3>

<p>Generalized Hadamard codes are obtained from an <em>n</em>-by-<em>n</em> <a href="Hadamard_matrix" title="wikilink">Hadamard matrix</a> <em>H</em>. In particular, the 2<em>n</em> codewords of the code are the rows of <em>H</em> and the rows of −<em>H</em>. To obtain a code over the alphabet {0,1}, the mapping −1 ↦ 1, 1 ↦ 0, or, equivalently, <em>x</em> ↦ (1 − <em>x</em>)/2, is applied to the matrix elements. That the minimum distance of the code is <em>n</em>/2 follows from the defining property of Hadamard matrices, namely that their rows are mutually orthogonal. This implies that two distinct rows of a Hadamard matrix differ in exactly <em>n</em>/2 positions, and, since negation of a row does not affect orthogonality, that any row of <em>H</em> differs from any row of −<em>H</em> in <em>n</em>/2 positions as well, except when the rows correspond, in which case they differ in <em>n</em> positions.</p>

<p>To get the punctured Hadamard code above with 

<math display="inline" id="Hadamard_code:53">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=2^{k-1}
  </annotation>
 </semantics>
</math>

, the chosen Hadamard matrix <em>H</em> has to be of Sylvester type, which gives rise to a message length of 

<math display="inline" id="Hadamard_code:54">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{2}(2n)=k
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="distance">Distance</h2>

<p>The distance of a code is the minimum <a href="Hamming_distance" title="wikilink">Hamming distance</a> between any two distinct codewords, i.e., the minimum number of positions at which two distinct codewords differ. Since the Walsh–Hadamard code is a <a href="linear_code" title="wikilink">linear code</a>, the distance is equal to the minimum <a href="Hamming_weight" title="wikilink">Hamming weight</a> among all of its non-zero codewords. All non-zero codewords of the Walsh–Hadamard code have a <a href="Hamming_weight" title="wikilink">Hamming weight</a> of exactly 

<math display="inline" id="Hadamard_code:55">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k-1}
  </annotation>
 </semantics>
</math>

 by the following argument.</p>

<p>Let 

<math display="inline" id="Hadamard_code:56">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\{0,1\}^{k}
  </annotation>
 </semantics>
</math>

 be a non-zero message. Then the following value is exactly equal to the fraction of positions in the codeword that are equal to one:</p>

<p>

<math display="block" id="Hadamard_code:57">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mi>Pr</mi>
      <mrow>
       <mi>y</mi>
       <mo>∈</mo>
       <msup>
        <mrow>
         <mo stretchy="false">{</mo>
         <mn>0</mn>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">}</mo>
        </mrow>
        <mi>k</mi>
       </msup>
      </mrow>
     </munder>
     <mrow>
      <mo maxsize="120%" minsize="120%">[</mo>
      <mrow>
       <msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mtext>Had</mtext>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>y</mi>
       </msub>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mo maxsize="120%" minsize="120%">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mi>Pr</mi>
      <mrow>
       <mi>y</mi>
       <mo>∈</mo>
       <msup>
        <mrow>
         <mo stretchy="false">{</mo>
         <mn>0</mn>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">}</mo>
        </mrow>
        <mi>k</mi>
       </msup>
      </mrow>
     </munder>
     <mrow>
      <mo maxsize="120%" minsize="120%">[</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mo maxsize="120%" minsize="120%" rspace="4.2pt">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Pr</ci>
      <apply>
       <in></in>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <set>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </set>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <times></times>
        <mtext>Had</mtext>
        <ci>x</ci>
       </apply>
       <ci>y</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Pr</ci>
      <apply>
       <in></in>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <set>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </set>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <list>
       <ci>x</ci>
       <ci>y</ci>
      </list>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr_{y\in\{0,1\}^{k}}\big[(\text{Had}(x))_{y}=1\big]=\Pr_{y\in\{0,1\}^{k}}\big%
[\langle x,y\rangle=1\big]\,.
  </annotation>
 </semantics>
</math>

</p>

<p>The fact that the latter value is exactly 

<math display="inline" id="Hadamard_code:58">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2
  </annotation>
 </semantics>
</math>

 is called the <em>random subsum principle</em>. To see that it is true, assume without loss of generality that 

<math display="inline" id="Hadamard_code:59">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=1
  </annotation>
 </semantics>
</math>

. Then, when conditioned on the values of 

<math display="inline" id="Hadamard_code:60">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{2},\dots,y_{k}
  </annotation>
 </semantics>
</math>

, the event is equivalent to 

<math display="inline" id="Hadamard_code:61">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>⋅</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}\cdot x_{1}=b
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Hadamard_code:62">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>b</ci>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\in\{0,1\}
  </annotation>
 </semantics>
</math>

 depending on 

<math display="inline" id="Hadamard_code:63">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2},\dots,x_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hadamard_code:64">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{2},\dots,y_{k}
  </annotation>
 </semantics>
</math>

. The probability that 

<math display="inline" id="Hadamard_code:65">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}=b
  </annotation>
 </semantics>
</math>

 happens is exactly 

<math display="inline" id="Hadamard_code:66">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2
  </annotation>
 </semantics>
</math>

. Thus, in fact, <em>all</em> non-zero codewords of the Hadamard code have relative Hamming weight 

<math display="inline" id="Hadamard_code:67">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2
  </annotation>
 </semantics>
</math>

, and thus, its relative distance is 

<math display="inline" id="Hadamard_code:68">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2
  </annotation>
 </semantics>
</math>

.</p>

<p>The relative distance of the <em>punctured</em> Hadamard code is 

<math display="inline" id="Hadamard_code:69">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2
  </annotation>
 </semantics>
</math>

 as well, but it no longer has the property that every non-zero codeword has weight exactly 

<math display="inline" id="Hadamard_code:70">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2
  </annotation>
 </semantics>
</math>

 since the all 

<math display="inline" id="Hadamard_code:71">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

s vector 

<math display="inline" id="Hadamard_code:72">
 <semantics>
  <msup>
   <mn>1</mn>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1^{2^{k-1}}
  </annotation>
 </semantics>
</math>

 is a codeword of the punctured Hadamard code. This is because the vector 

<math display="inline" id="Hadamard_code:73">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <msup>
    <mn>10</mn>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">10</cn>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=10^{k-1}
  </annotation>
 </semantics>
</math>

 encodes to 

<math display="inline" id="Hadamard_code:74">
 <semantics>
  <mrow>
   <mrow>
    <mtext>pHad</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>10</mn>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>1</mn>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>pHad</mtext>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">10</cn>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{pHad}(10^{k-1})=1^{2^{k-1}}
  </annotation>
 </semantics>
</math>

. Furthermore, whenever 

<math display="inline" id="Hadamard_code:75">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is non-zero and not the vector 

<math display="inline" id="Hadamard_code:76">
 <semantics>
  <msup>
   <mn>10</mn>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">10</cn>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   10^{k-1}
  </annotation>
 </semantics>
</math>

, the random subsum principle applies again, and the relative weight of 

<math display="inline" id="Hadamard_code:77">
 <semantics>
  <mrow>
   <mtext>Had</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Had</mtext>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Had}(x)
  </annotation>
 </semantics>
</math>

 is exactly 

<math display="inline" id="Hadamard_code:78">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="local-decodability">Local decodability</h2>

<p>A <a href="locally_decodable" title="wikilink">locally decodable</a> code is a code that allows a single bit of the original message to be recovered with high probability by only looking at a small portion of the received word. A code is 

<math display="inline" id="Hadamard_code:79">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-query <a href="locally_decodable" title="wikilink">locally decodable</a> if a message bit, 

<math display="inline" id="Hadamard_code:80">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

, can be recovered by checking 

<math display="inline" id="Hadamard_code:81">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 bits of the received word. More formally, a code, 

<math display="inline" id="Hadamard_code:82">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>k</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>C</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C:\{0,1\}^{k}\rightarrow\{0,1\}^{n}
  </annotation>
 </semantics>
</math>

, is 

<math display="inline" id="Hadamard_code:83">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>q</mi>
      <mo>,</mo>
      <mi>δ</mi>
     </mrow>
     <mo>≥</mo>
     <mn>0</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>ϵ</mi>
     <mo>≥</mo>
     <mn>0</mn>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <list>
      <ci>q</ci>
      <ci>δ</ci>
     </list>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <geq></geq>
     <ci>ϵ</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q,\delta\geq 0,\epsilon\geq 0)
  </annotation>
 </semantics>
</math>

-locally decodable, if there exists a probabilistic decoder, 

<math display="inline" id="Hadamard_code:84">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>k</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>D</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D:\{0,1\}^{n}\rightarrow\{0,1\}^{k}
  </annotation>
 </semantics>
</math>

, such that <em>(Note

<math display="block" id="Hadamard_code:85">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(x,y)
  </annotation>
 </semantics>
</math>

 represents the <a href="Hamming_distance" title="wikilink">Hamming distance</a> between vectors 

<math display="inline" id="Hadamard_code:86">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hadamard_code:87">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

)</em>:</p>

<p>

<math display="inline" id="Hadamard_code:88">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>x</mi>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>k</mi>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>y</mi>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>y</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\in\{0,1\}^{k},\forall y\in\{0,1\}^{n}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Hadamard_code:89">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>δ</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <interval closure="open">
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>x</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(y,C(x))\leq\delta n
  </annotation>
 </semantics>
</math>

 implies that 

<math display="inline" id="Hadamard_code:90">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>D</mi>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≥</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mo>+</mo>
   <mi>ϵ</mi>
   <mo>,</mo>
   <mo>∀</mo>
   <mi>i</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>k</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">D</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <geq></geq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <plus></plus>
    <csymbol cd="unknown">ϵ</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <in></in>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr[D(y)_{i}=x_{i}]\geq\frac{1}{2}+\epsilon,\forall i\in[k]
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Theorem 1:</strong> The Walsh–Hadamard code is 

<math display="inline" id="Hadamard_code:91">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi>δ</mi>
   <mo>,</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>δ</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">2</cn>
    <ci>δ</ci>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>δ</ci>
     </apply>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2,\delta,\frac{1}{2}-2\delta)
  </annotation>
 </semantics>
</math>

-locally decodable for 

<math display="inline" id="Hadamard_code:92">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>δ</mi>
   <mo>≤</mo>
   <mfrac>
    <mn>1</mn>
    <mn>4</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>δ</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\delta\leq\frac{1}{4}
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Lemma 1:</strong> For all codewords, 

<math display="inline" id="Hadamard_code:93">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 in a Walsh–Hadamard code, 

<math display="inline" id="Hadamard_code:94">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Hadamard_code:95">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>c</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}+c_{j}=c_{i+j}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Hadamard_code:96">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i},c_{j}
  </annotation>
 </semantics>
</math>

 represent the bits in 

<math display="inline" id="Hadamard_code:97">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 in positions 

<math display="inline" id="Hadamard_code:98">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hadamard_code:99">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 respectively, and 

<math display="inline" id="Hadamard_code:100">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i+j}
  </annotation>
 </semantics>
</math>

 represents the bit at position 

<math display="inline" id="Hadamard_code:101">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mi>j</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>i</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i+j)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="proof-of-lemma-1">Proof of lemma 1</h3>
<hr/>

<p>Let 

<math display="inline" id="Hadamard_code:102">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mrow>
      <msup>
       <mn>2</mn>
       <mi>n</mi>
      </msup>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>x</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(x)=c=(c_{0},\dots,c_{2^{n}-1})
  </annotation>
 </semantics>
</math>

 be the codeword in 

<math display="inline" id="Hadamard_code:103">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 corresponding to message 

<math display="inline" id="Hadamard_code:104">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

.</p>

<p>Let 

<math display="inline" id="Hadamard_code:105">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mo>↑</mo>
      </mtd>
      <mtd columnalign="center">
       <mo>↑</mo>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mo>↑</mo>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>g</mi>
        <mn>0</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>g</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mi mathvariant="normal">…</mi>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>g</mi>
        <mrow>
         <msup>
          <mn>2</mn>
          <mi>n</mi>
         </msup>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mo>↓</mo>
      </mtd>
      <mtd columnalign="center">
       <mo>↓</mo>
      </mtd>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
      <mtd columnalign="center">
       <mo>↓</mo>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <matrix>
     <matrixrow>
      <ci>normal-↑</ci>
      <ci>normal-↑</ci>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-↑</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-↓</ci>
      <ci>normal-↓</ci>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-↓</ci>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\begin{pmatrix}\uparrow&\uparrow&&\uparrow\\
g_{0}&g_{1}&\dots&g_{2^{n}-1}\\
\downarrow&\downarrow&&\downarrow\end{pmatrix}
  </annotation>
 </semantics>
</math>

 be the generator matrix of 

<math display="inline" id="Hadamard_code:106">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

.</p>

<p>By definition, 

<math display="inline" id="Hadamard_code:107">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>⋅</mo>
    <msub>
     <mi>g</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}=x\cdot g_{i}
  </annotation>
 </semantics>
</math>

. From this, 

<math display="inline" id="Hadamard_code:108">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>c</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>⋅</mo>
     <msub>
      <mi>g</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>x</mi>
     <mo>⋅</mo>
     <msub>
      <mi>g</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mi>i</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>g</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-⋅</ci>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}+c_{j}=x\cdot g_{i}+x\cdot g_{j}=x\cdot(g_{i}+g_{j})
  </annotation>
 </semantics>
</math>

. By the construction of 

<math display="inline" id="Hadamard_code:109">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Hadamard_code:110">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>g</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>g</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}+g_{j}=g_{i+j}
  </annotation>
 </semantics>
</math>

. Therefore, by substitution, 

<math display="inline" id="Hadamard_code:111">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>c</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>⋅</mo>
    <msub>
     <mi>g</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}+c_{j}=x\cdot g_{i+j}=c_{i+j}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="proof-of-theorem-1">Proof of theorem 1</h3>
<hr/>

<p>To prove theorem 1 we will construct a decoding algorithm and prove its correctness.</p>
<h4 id="algorithm">Algorithm</h4>

<p><strong>Input:</strong> Received word 

<math display="inline" id="Hadamard_code:112">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mrow>
      <msup>
       <mn>2</mn>
       <mi>n</mi>
      </msup>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=(y_{0},\dots,y_{2^{n}-1})
  </annotation>
 </semantics>
</math>

</p>

<p>For each 

<math display="inline" id="Hadamard_code:113">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in\{1,\dots,n\}
  </annotation>
 </semantics>
</math>

:</p>
<ol>
<li>Pick 

<math display="inline" id="Hadamard_code:114">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>j</ci>
    <set>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\in\{0,\dots,2^{n}-1\}
  </annotation>
 </semantics>
</math>

 independently at random</li>
<li>Pick 

<math display="inline" id="Hadamard_code:115">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>k</ci>
    <set>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\in\{0,\dots,2^{n}-1\}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Hadamard_code:116">
 <semantics>
  <mrow>
   <mrow>
    <mi>j</mi>
    <mo>+</mo>
    <mi>k</mi>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>e</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>j</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j+k=e_{i}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Hadamard_code:117">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>+</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>j</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j+k
  </annotation>
 </semantics>
</math>

 is the bitwise <em>xor</em> of 

<math display="inline" id="Hadamard_code:118">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hadamard_code:119">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Hadamard_code:120">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>j</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\leftarrow y_{j}+y_{k}
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p><strong>Output:</strong> Message 

<math display="inline" id="Hadamard_code:121">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=(x_{1},\dots,x_{n})
  </annotation>
 </semantics>
</math>

</p>
<h4 id="proof-of-correctness">Proof of correctness</h4>

<p>For any message, 

<math display="inline" id="Hadamard_code:122">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, and received word 

<math display="inline" id="Hadamard_code:123">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Hadamard_code:124">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 differs from 

<math display="inline" id="Hadamard_code:125">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=C(x)
  </annotation>
 </semantics>
</math>

 on at most 

<math display="inline" id="Hadamard_code:126">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 fraction of bits, 

<math display="inline" id="Hadamard_code:127">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 can be decoded with probability at least 

<math display="inline" id="Hadamard_code:128">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mo>+</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>δ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}+(1-2\delta)
  </annotation>
 </semantics>
</math>

.</p>

<p>By lemma 1, 

<math display="inline" id="Hadamard_code:129">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>j</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>c</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mi>k</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>⋅</mo>
    <msub>
     <mi>g</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mi>k</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>⋅</mo>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{j}+c_{k}=c_{j+k}=x\cdot g_{j+k}=x\cdot e_{i}=x_{i}
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Hadamard_code:130">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hadamard_code:131">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 are picked uniformly, the probability that 

<math display="inline" id="Hadamard_code:132">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
   <mo>≠</mo>
   <msub>
    <mi>c</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}\not=c_{j}
  </annotation>
 </semantics>
</math>

 is at most 

<math display="inline" id="Hadamard_code:133">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

. Similarly, the probability that 

<math display="inline" id="Hadamard_code:134">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo>≠</mo>
   <msub>
    <mi>c</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}\not=c_{k}
  </annotation>
 </semantics>
</math>

 is at most 

<math display="inline" id="Hadamard_code:135">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

. By the <a href="union_bound" title="wikilink">union bound</a>, the probability that either 

<math display="inline" id="Hadamard_code:136">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Hadamard_code:137">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

 do not match the corresponding bits in 

<math display="inline" id="Hadamard_code:138">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is at most 

<math display="inline" id="Hadamard_code:139">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\delta
  </annotation>
 </semantics>
</math>

. If both 

<math display="inline" id="Hadamard_code:140">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hadamard_code:141">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

 correspond to 

<math display="inline" id="Hadamard_code:142">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, then lemma 1 will apply, and therefore, the proper value of 

<math display="inline" id="Hadamard_code:143">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 will be computed. Therefore the probability 

<math display="inline" id="Hadamard_code:144">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 is decoded properly is at least 

<math display="inline" id="Hadamard_code:145">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mrow>
    <mn>2</mn>
    <mi>δ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-2\delta
  </annotation>
 </semantics>
</math>

. Therefore, 

<math display="inline" id="Hadamard_code:146">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>δ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϵ</ci>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon=\frac{1}{2}-2\delta
  </annotation>
 </semantics>
</math>

 and for 

<math display="inline" id="Hadamard_code:147">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 to be positive, 

<math display="inline" id="Hadamard_code:148">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>δ</mi>
   <mo>≤</mo>
   <mfrac>
    <mn>1</mn>
    <mn>4</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>δ</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\delta\leq\frac{1}{4}
  </annotation>
 </semantics>
</math>

.</p>

<p>Therefore, the Walsh–Hadamard code is 

<math display="inline" id="Hadamard_code:149">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi>δ</mi>
   <mo>,</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>δ</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <cn type="integer">2</cn>
    <ci>δ</ci>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>δ</ci>
     </apply>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2,\delta,\frac{1}{2}-2\delta)
  </annotation>
 </semantics>
</math>

 locally decodable for 

<math display="inline" id="Hadamard_code:150">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>δ</mi>
   <mo>≤</mo>
   <mfrac>
    <mn>1</mn>
    <mn>4</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>δ</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\delta\leq\frac{1}{4}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="optimality">Optimality</h2>

<p>For <em>k</em> ≤ 7 the linear Hadamard codes have been proven optimal in the sense of minimum distance.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Zadoff–Chu_sequence" title="wikilink">Zadoff–Chu sequence</a> — improve over the Walsh–Hadamard codes</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p><a class="uri" href="de:Walsh-Code" title="wikilink">de:Walsh-Code</a> <a class="uri" href="ja:直交符号" title="wikilink">ja:直交符号</a>"</p>

<p><a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">See, e.g., <a href="#fnref1">↩</a></li>
<li id="fn2">See, e.g., .<a href="#fnref2">↩</a></li>
<li id="fn3">See, e.g., .<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
