<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1650">Concatenated error correction code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Concatenated error correction code</h1>
<hr/>

<p>In <a href="coding_theory" title="wikilink">coding theory</a>, <strong>concatenated codes</strong> form a class of <a href="error-correcting_code" title="wikilink">error-correcting codes</a> that are derived by combining an <strong>inner code</strong> and an <strong>outer code</strong>. They were conceived in 1966 by <a href="Dave_Forney" title="wikilink">Dave Forney</a> as a solution to the problem of finding a code that has both exponentially decreasing error probability with increasing block length and <a class="uri" href="polynomial-time" title="wikilink">polynomial-time</a> decoding <a href="Computational_complexity_theory" title="wikilink">complexity</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Concatenated codes became widely used in space communications in the 1970s.</p>
<h2 id="background">Background</h2>

<p>The field of <a href="channel_coding" title="wikilink">channel coding</a> is concerned with sending a stream of data at the highest possible rate over a given <a href="communications_channel" title="wikilink">communications channel</a>, and then decoding the original data reliably at the receiver, using encoding and decoding algorithms that are feasible to implement in a given technology.</p>

<p><a href="Noisy-channel_coding_theorem" title="wikilink">Shannon's channel coding theorem</a> shows that over many common channels there exist channel coding schemes that are able to transmit data reliably at all rates 

<math display="inline" id="Concatenated_error_correction_code:0">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 less than a certain threshold 

<math display="inline" id="Concatenated_error_correction_code:1">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, called the <a href="channel_capacity" title="wikilink">channel capacity</a> of the given channel. In fact, the probability of decoding error can be made to decrease exponentially as the block length 

<math display="inline" id="Concatenated_error_correction_code:2">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 of the coding scheme goes to infinity. However, the complexity of a naive optimum decoding scheme that simply computes the likelihood of every possible transmitted codeword increases exponentially with 

<math display="inline" id="Concatenated_error_correction_code:3">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, so such an optimum decoder rapidly becomes infeasible.</p>

<p>In his [<a class="uri" href="http://mitpress.mit.edu/catalog/item/default.asp?tid=5813&amp;ttype">http://mitpress.mit.edu/catalog/item/default.asp?tid=5813&amp;ttype;</a>;=2 doctoral thesis], <a href="Dave_Forney" title="wikilink">Dave Forney</a> showed that concatenated codes could be used to achieve exponentially decreasing error probabilities at all data rates less than capacity, with decoding complexity that increases only polynomially with the code block length.</p>
<h2 id="description">Description</h2>

<p><a href="File:Concatenated_codes_diagram.png" title="wikilink">thumb|upright=2|Schematic depiction of a concatenated code built upon an inner code and an outer code.</a> </p>

<p>Let <em>C</em><sub><em>in</em></sub> be a [<em>n</em>, <em>k</em>, <em>d</em>] code, that is, a <a href="block_code" title="wikilink">block code</a> of length <em>n</em>, <a href="dimension_(vector_space)" title="wikilink">dimension</a> <em>k</em>, minimum <a href="Hamming_distance" title="wikilink">Hamming distance</a> <em>d</em>, and <a href="code_rate" title="wikilink">rate</a> <em>r</em> = <em>k</em>/<em>n</em>, over an alphabet <em>A</em>:</p>

<p>

<math display="block" id="Concatenated_error_correction_code:4">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>k</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>A</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{in}:A^{k}\rightarrow A^{n}
  </annotation>
 </semantics>
</math>

 Let <em>C</em><sub><em>out</em></sub> be a [<em>N</em>, <em>K</em>, <em>D</em>] code over an alphabet <em>B</em> with |<em>B</em>| = |<em>A</em>|<sup><em>k</em></sup> symbols:</p>

<p>

<math display="block" id="Concatenated_error_correction_code:5">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>o</mi>
     <mi>u</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>B</mi>
     <mi>K</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>B</mi>
     <mi>N</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{out}:B^{K}\rightarrow B^{N}
  </annotation>
 </semantics>
</math>

 The inner code <em>C</em><sub><em>in</em></sub> takes one of |<em>A</em>|<sup><em>k</em></sup> = |<em>B</em>| possible inputs, encodes into an <em>n</em>-tuple over <em>A</em>, transmits, and decodes into one of |<em>B</em>| possible outputs. We regard this as a (super) channel which can transmit one symbol from the alphabet <em>B</em>. We use this channel <em>N</em> times to transmit each of the <em>N</em> symbols in a codeword of <em>C</em><sub><em>out</em></sub>. The <em>concatenation</em> of <em>C</em><sub><em>out</em></sub> (as outer code) with <em>C</em><sub><em>in</em></sub> (as inner code), denoted <em>C</em><sub><em>out</em></sub>∘<em>C</em><sub><em>in</em></sub>, is thus a code of length <em>Nn</em> over the alphabet <em>A</em>:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>

<math display="block" id="Concatenated_error_correction_code:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>o</mi>
      <mi>u</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>∘</mo>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>i</mi>
      <mi>n</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mrow>
      <mi>k</mi>
      <mi>K</mi>
     </mrow>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>A</mi>
     <mrow>
      <mi>n</mi>
      <mi>N</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>u</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>K</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{out}\circ C_{in}:A^{kK}\rightarrow A^{nN}
  </annotation>
 </semantics>
</math>

 It maps each input message <em>m</em> = (<em>m</em><sub>1</sub>, <em>m</em><sub>2</sub>, ..., <em>m</em><sub>K</sub>) to a codeword (<em>C</em><sub><em>in</em></sub>(<em>m</em>'<sub>1</sub>), <em>C</em><sub><em>in</em></sub>(<em>m</em>'<sub>2</sub>), ..., <em>C</em><sub><em>in</em></sub>(<em>m</em>'<sub>N</sub>)), where (<em>m</em>'<sub>1</sub>, <em>m</em>'<sub>2</sub>, ..., <em>m</em>'<sub>N</sub>) = <em>C</em><sub><em>out</em></sub>(<em>m</em><sub>1</sub>, <em>m</em><sub>2</sub>, ..., <em>m</em><sub>K</sub>).</p>

<p>The <em>key insight</em> in this approach is that if <em>C</em><sub><em>in</em></sub> is decoded using a <a href="maximum_likelihood_decoding" title="wikilink">maximum-likelihood approach</a> (thus showing an exponentially decreasing error probability with increasing length), and <em>C</em><sub><em>out</em></sub> is a code with length <em>N</em> = 2<sup><em>nr</em></sup> that can be decoded in polynomial time of <em>N</em>, then the concatenated code can be decoded in polynomial time of its combined length <em>n</em>2<sup><em>nr</em></sup> = <a href="O_notation" title="wikilink"><em>O</em></a>(<em>N</em>⋅log(<em>N</em>)) and shows an exponentially decreasing error probability, even if <em>C</em><sub><em>in</em></sub> has exponential decoding complexity.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This is discussed in more detail in section <a href="#Decoding_concatenated_codes" title="wikilink">Decoding concatenated codes</a>.</p>

<p>In a generalization of above concatenation, there are <em>N</em> possible inner codes <em>C</em><sub><em>in</em>,<em>i</em></sub> and the <em>i</em>-th symbol in a codeword of <em>C</em><sub><em>out</em></sub> is transmitted across the inner channel using the <em>i</em>-th inner code. The <a href="Justesen_code" title="wikilink">Justesen codes</a> are examples of generalized concatenated codes, where the outer code is a <a href="Reed–Solomon_code" title="wikilink">Reed–Solomon code</a>.</p>
<h2 id="properties">Properties</h2>

<p><strong>1.</strong> The distance of the concatenated code <em>C</em><sub><em>out</em></sub>∘<em>C</em><sub><em>in</em></sub> is at least <em>dD</em>, that is, it is a [<em>nN</em>, <em>kK</em>, <em>D</em>'] code with <em>D</em>' ≥ <em>dD</em>.</p>

<p><em>Proof:</em> Consider two different messages <em>m</em><sup>1</sup> ≠ <em>m</em><sup>2</sup> ∈ <em>B</em><sup><em>K</em></sup>. Let Δ denote the distance between two codewords. Then</p>

<p>

<math display="block" id="Concatenated_error_correction_code:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>C</mi>
        <mrow>
         <mi>o</mi>
         <mi>u</mi>
         <mi>t</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>m</mi>
         <mn>1</mn>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>C</mi>
        <mrow>
         <mi>o</mi>
         <mi>u</mi>
         <mi>t</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>m</mi>
         <mn>2</mn>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mi>D</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>u</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>u</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </interval>
    </apply>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(C_{out}(m^{1}),C_{out}(m^{2}))\geq D.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, there are at least <em>D</em> positions in which the sequence of <em>N</em> symbols of the codewords <em>C</em><sub><em>out</em></sub>(<em>m</em><sup>1</sup>) and <em>C</em><sub><em>out</em></sub>(<em>m</em><sup>2</sup>) differ. For these positions, denoted <em>i</em>, we have</p>

<p>

<math display="block" id="Concatenated_error_correction_code:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>C</mi>
        <mrow>
         <mi>i</mi>
         <mi>n</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>C</mi>
          <mrow>
           <mi>o</mi>
           <mi>u</mi>
           <mi>t</mi>
          </mrow>
         </msub>
         <msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msup>
            <mi>m</mi>
            <mn>1</mn>
           </msup>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>C</mi>
        <mrow>
         <mi>i</mi>
         <mi>n</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>C</mi>
          <mrow>
           <mi>o</mi>
           <mi>u</mi>
           <mi>t</mi>
          </mrow>
         </msub>
         <msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msup>
            <mi>m</mi>
            <mn>2</mn>
           </msup>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mi>d</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <apply>
          <times></times>
          <ci>o</ci>
          <ci>u</ci>
          <ci>t</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <apply>
          <times></times>
          <ci>o</ci>
          <ci>u</ci>
          <ci>t</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>m</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </interval>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(C_{in}(C_{out}(m^{1})_{i}),C_{in}(C_{out}(m^{2})_{i}))\geq d.
  </annotation>
 </semantics>
</math>

</p>

<p>Consequently, there are at least <em>d</em>⋅<em>D</em> positions in the sequence of <em>n</em>⋅<em>N</em> symbols taken from the alphabet <em>A</em> in which the two codewords differ, and hence</p>

<p>

<math display="block" id="Concatenated_error_correction_code:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>C</mi>
        <mrow>
         <mi>i</mi>
         <mi>n</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>C</mi>
          <mrow>
           <mi>o</mi>
           <mi>u</mi>
           <mi>t</mi>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msup>
           <mi>m</mi>
           <mn>1</mn>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>C</mi>
        <mrow>
         <mi>i</mi>
         <mi>n</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>C</mi>
          <mrow>
           <mi>o</mi>
           <mi>u</mi>
           <mi>t</mi>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msup>
           <mi>m</mi>
           <mn>2</mn>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mi>d</mi>
     <mi>D</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <apply>
          <times></times>
          <ci>o</ci>
          <ci>u</ci>
          <ci>t</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <apply>
          <times></times>
          <ci>o</ci>
          <ci>u</ci>
          <ci>t</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>m</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(C_{in}(C_{out}(m^{1})),C_{in}(C_{out}(m^{2})))\geq dD.
  </annotation>
 </semantics>
</math>

</p>

<p><strong>2.</strong> If <em>C</em><sub><em>out</em></sub> and <em>C</em><sub><em>in</em></sub> are <a href="linear_block_code" title="wikilink">linear block codes</a>, then <em>C</em><sub><em>out</em></sub>∘<em>C</em><sub><em>in</em></sub> is also a linear block code.</p>

<p>This property can be easily shown based on the idea of defining a <a href="generator_matrix" title="wikilink">generator matrix</a> for the concatenated code in terms of the generator matrices of <em>C</em><sub><em>out</em></sub> and <em>C</em><sub><em>in</em></sub>.</p>
<h2 id="decoding-concatenated-codes">Decoding concatenated codes</h2>

<p>A natural concept for a decoding algorithm for concatenated codes is to ﬁrst decode the inner code and then the outer code. For the algorithm to be practical it must be <a class="uri" href="polynomial-time" title="wikilink">polynomial-time</a> in the final block length. Consider that there is a polynomial-time unique decoding algorithm for the outer code. Now we have to find a polynomial-time decoding algorithm for the inner code. It is understood that polynomial running time here means that running time is polynomial in the final block length. The main idea is that if the inner block length is selected to be logarithmic in the size of the outer code then the decoding algorithm for the inner code may run in <a href="exponential_time" title="wikilink">exponential time</a> of the inner block length, and we can thus use an exponential-time but optimal <a href="Decoding_methods#Maximum_likelihood_decoding" title="wikilink">maximum likelihood decoder</a> (MLD) for the inner code.</p>

<p>In detail, let the input to the decoder be the vector <em>y</em> = (<em>y</em><sub>1</sub>, ..., <em>y</em><sub><em>N</em></sub>) ∈ (<em>A</em><sup><em>n</em></sup>)<sup><em>N</em></sup>. Then the decoding algorithm is a two-step process:</p>
<ol>
<li>Use the MLD of the inner code <em>C</em><sub>in</sub> to reconstruct a set of inner code words <em>y</em>' = (<em>y</em>'<sub>1</sub>, ..., <em>y</em>'<sub><em>N</em></sub>), with <em>y</em>'<sub><em>i</em></sub> = MLD<sub><em>C</em><sub>in</sub></sub>(<em>y</em><sub>i</sub>), 1 ≤ <em>i</em> ≤ <em>N</em>.</li>
<li>Run the unique decoding algorithm for <em>C</em><sub>out</sub> on <em>y</em>'.</li>
</ol>

<p>Now, the time complexity of the first step is <a href="O_notation" title="wikilink"><em>O</em></a>(<em>N</em>⋅exp(<em>n</em>)), where <em>n</em> = <em>O</em>(log(<em>N</em>)) is the inner block length. In other words, it is <em>N</em><sup><em>O</em>(1)</sup> (i.e., polynomial-time) in terms of the outer block length <em>N</em>. As the outer decoding algorithm in step two is assumed to run in polynomial time the complexity of the overall decoding algorithm is polynomial-time as well.</p>
<h3 id="remarks">Remarks</h3>

<p>The decoding algorithm described above can be used to correct all errors up to less than <em>dD</em>/4 in number. Using <a href="minimum_distance_decoding" title="wikilink">minimum distance decoding</a>, the outer decoder can correct all inputs <em>y</em>' with less than <em>D</em>/2 symbols <em>y</em>'<sub><em>i</em></sub> in error. Similarly, the inner code can reliably correct an input <em>y</em><sub><em>i</em></sub> if less than <em>d</em>/2 inner symbols are erroneous. Thus, for an outer symbol <em>y</em>'<sub><em>i</em></sub> to be incorrect after inner decoding at least <em>d</em>/2 inner symbols must have been in error, and for the outer code to fail this must have happened for at least <em>D</em>/2 outer symbols. Consequently, the total number of inner symbols that must be received incorrectly for the concatenated code to fail must be at least <em>d</em>/2⋅<em>D</em>/2 = <em>dD</em>/4.</p>

<p>The algorithm also works if the inner codes are different, e.g., for <a href="Justesen_code" title="wikilink">Justesen codes</a>. The <a href="generalized_minimum_distance_decoding" title="wikilink">generalized minimum distance algorithm</a>, developed by Forney, can be used to correct up to <em>dD</em>/2 errors.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It uses <a href="erasure_code" title="wikilink">erasure</a> information from the inner code to improve performance of the outer code, and was the first example of an algorithm using <a href="soft-decision_decoding" title="wikilink">soft-decision decoding</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="applications">Applications</h2>

<p>Although a simple concatenation scheme was implemented already for the 1971 <a class="uri" href="Mariner" title="wikilink">Mariner</a> Mars orbiter mission,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> concatenated codes were starting to be regularly used for <a href="Deep_Space_Network" title="wikilink">deep space</a> communication with the <a href="Voyager_program" title="wikilink">Voyager program</a>, which launched two <a href="space_probe" title="wikilink">space probes</a> in 1977.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Since then, concatenated codes became the workhorse for efficient error correction coding, and stayed so at least until the invention of <a href="turbo_codes" title="wikilink">turbo codes</a> and <a href="LDPC_codes" title="wikilink">LDPC codes</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>Typically, the inner code is not a block code but a <a href="soft-decision_decoder" title="wikilink">soft-decision</a> <a href="convolutional_code" title="wikilink">convolutional</a> <a href="Viterbi_decoder" title="wikilink">Viterbi-decoded</a> code with a short constraint length.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> For the outer code, a longer hard-decision block code, frequently a <a href="Reed-Solomon_code" title="wikilink">Reed-Solomon code</a> with eight-bit symbols, is used.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The larger symbol size makes the outer code more robust to <a href="error_burst" title="wikilink">error bursts</a> that can occur due to channel impairments, and also because erroneous output of the convolutional code itself is bursty.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> An <a href="forward_error_correction#Interleaving" title="wikilink">interleaving layer</a> is usually added between the two codes to spread error bursts across a wider range.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>The combination of an inner Viterbi convolutional code with an outer <a href="Reed–Solomon_code" title="wikilink">Reed–Solomon code</a> (known as an RSV code) was first used in <em><a href="Voyager_2" title="wikilink">Voyager 2</a></em>,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> and it became a popular construction both within and outside of the space sector. It is still notably used today for <a href="satellite_communication" title="wikilink">satellite communications</a>, such as the <a class="uri" href="DVB-S" title="wikilink">DVB-S</a> <a href="digital_television" title="wikilink">digital television</a> broadcast standard.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>In a looser sense, any (serial) combination of two or more codes may be referred to as a concatenated code. For example, within the <a class="uri" href="DVB-S2" title="wikilink">DVB-S2</a> standard, a highly efficient <a href="LDPC_code" title="wikilink">LDPC code</a> is combined with an algebraic outer code in order to remove any resilient errors left over from the inner LDPC code due to its inherent <a href="error_floor" title="wikilink">error floor</a>.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>A simple concatenation scheme is also used on the compact disc (CD), where an interleaving layer between two Reed–Solomon codes of different sizes spreads errors across various blocks.</p>
<h2 id="turbo-codes-a-parallel-concatenation-approach">Turbo codes: A parallel concatenation approach</h2>

<p>The description above is given for what is now called a serially concatenated code. <a href="Turbo_code" title="wikilink">Turbo codes</a>, as described first in 1993, implemented a parallel concatenation of two convolutional codes, with an interleaver between the two codes and an iterative decoder that passes information forth and back between the codes.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> This design has a better performance than any previously conceived concatenated codes.</p>

<p>However, a key aspect of turbo codes is their iterated decoding approach. Iterated decoding is now also applied to serial concatenations in order to achieve higher coding gains, such as within serially concatenated convolutional codes (SCCCs). An early form of iterated decoding was implemented with two to five iterations in the "Galileo code" of the <a href="Galileo_(spacecraft)" title="wikilink">Galileo space probe</a>.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Justesen_code" title="wikilink">Justesen code</a></li>
<li><a href="Zyablov_bound" title="wikilink">Zyablov bound</a></li>
<li><a href="Singleton_bound" title="wikilink">Singleton bound</a></li>
<li><a href="Gilbert–Varshamov_bound" title="wikilink">Gilbert–Varshamov bound</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/fall07.html">University at Buffalo Lecture Notes on Coding Theory – Dr. Atri Rudra</a></li>
</ul>

<p>"</p>

<p><a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a> <a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Finite_fields" title="wikilink">Category:Finite fields</a> <a href="Category:Information_theory" title="wikilink">Category:Information theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8">K. Andrews et al., <em>The Development of Turbo and LDPC Codes for Deep-Space Applications</em>, Proceedings of the IEEE, Vol. 95, No. 11, Nov. 2007.<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18">R. Ludwig, J. Taylor, <a href="http://descanso.jpl.nasa.gov/DPSummary/Descanso4--Voyager_new.pdf">Voyager Telecommunications Manual</a>, <a class="uri" href="JPL" title="wikilink">JPL</a> DESCANSO <em>(Design and Performance Summary Series)</em>, March 2002.<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="http://www.etsi.org/deliver/etsi_en/300400_300499/300421/01.01.02_60/en_300421v010102p.pdf">Digital Video Broadcasting (DVB); Framing structure, channel coding and modulation for 11/12 GHz satellite services</a>, <a class="uri" href="ETSI" title="wikilink">ETSI</a> EN 300 421, V1.1.2, August 1997.<a href="#fnref19">↩</a></li>
<li id="fn20"><a href="http://www.etsi.org/deliver/etsi_en/302300_302399/302307/01.02.01_60/en_302307v010201p.pdf">Digital Video Broadcasting (DVB); Second generation framing structure, channel coding and modulation systems for Broadcasting, Interactive Services, News Gathering and other broadband satellite applications (DVB-S2)</a>, <a class="uri" href="ETSI" title="wikilink">ETSI</a> EN 302 307, V1.2.1, April 2009.<a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22"></li>
</ol>
</section>
</body>
</html>
