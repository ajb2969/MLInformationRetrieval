   Fortune's algorithm      Fortune's algorithm    Fortune's algorithm is a sweep line algorithm for generating a Voronoi diagram from a set of points in a plane using O ( n log n ) time and O( n ) space. 1 2 It was originally published by Steven Fortune in 1986 in his paper "A sweepline algorithm for Voronoi diagrams." 3  Algorithm description  The algorithm maintains both a sweep line and a beach line , which both move through the plane as the algorithm progresses. The sweep line is a straight line, which we may by convention assume to be vertical and moving left to right across the plane. At any time during the algorithm, the input points left of the sweep line will have been incorporated into the Voronoi diagram, while the points right of the sweep line will not have been considered yet. The beach line is not a line, but a complicated, piecewise curve to the left of the sweep line, composed of pieces of parabolas ; it divides the portion of the plane within which the Voronoi diagram can be known, regardless of what other points might be right of the sweep line, from the rest of the plane. For each point left of the sweep line, one can define a parabola of points equidistant from that point and from the sweep line; the beach line is the boundary of the union of these parabolas. As the sweep line progresses, the vertices of the beach line, at which two parabolas cross, trace out the edges of the Voronoi diagram. The beach line progresses by keeping each parabola base exactly half way between the points initially swept over with the sweep line, and the new position of the sweep line.  The algorithm maintains as data structures a binary search tree describing the combinatorial structure of the beach line, and a priority queue listing potential future events that could change the beach line structure. These events include the addition of another parabola to the beach line (when the sweep line crosses another input point) and the removal of a curve from the beach line (when the sweep line becomes tangent to a circle through some three input points whose parabolas form consecutive segments of the beach line). Each such event may be prioritized by the x -coordinate of the sweep line at the point the event occurs. The algorithm itself then consists of repeatedly removing the next event from the priority queue, finding the changes the event causes in the beach line, and updating the data structures.  As there are O( n ) events to process (each being associated with some feature of the Voronoi diagram) and O(log n ) time to process an event (each consisting of a constant number of binary search tree and priority queue operations) the total time is O( n log n ).  Pseudocode  Pseudocode description of the algorithm. 4  let      *   (  z  )       absent  z    *(z)    be the transformation     *   (  z  )   =   (   z  x   ,   z  y   +  d   (  z  )   )      fragments    fragments  normal-(  z  normal-)     fragments  normal-(   subscript  z  x   normal-,   subscript  z  y    d   fragments  normal-(  z  normal-)   normal-)     *(z)=(z_{x},z_{y}+d(z))    ,  where     d   (  z  )       d  z    d(z)    is the Euclidean distance between    z   z   z    and the nearest site  let    T   T   T    be the "beach line"  let     R  p     subscript  R  p    R_{p}    be the region covered by site    p   p   p    .  let     C   p  q      subscript  C    p  q     C_{pq}    be the boundary ray between sites    p   p   p    and    q   q   q    .  let      p  1   ,   p  2   ,  …  ,   p  m       subscript  p  1    subscript  p  2   normal-…   subscript  p  m     p_{1},p_{2},...,p_{m}    be the sites with minimal    y   y   y    -coordinate, ordered by    x   x   x    -coordinate     Q  ←    S  -   p  1    ,   p  2   ,  …  ,   p  m       normal-←  Q     S   subscript  p  1     subscript  p  2   normal-…   subscript  p  m      Q\leftarrow S-{p_{1},p_{2},...,p_{m}}     create initial vertical boundary rays      C    p  1   ,   p  2    0   ,   C    p  2   ,   p  3    0   ,   …   C    p   m  -  1    ,   p  m    0        superscript   subscript  C    subscript  p  1    subscript  p  2     0    superscript   subscript  C    subscript  p  2    subscript  p  3     0     normal-…   superscript   subscript  C    subscript  p    m  1     subscript  p  m     0      C_{p_{1},p_{2}}^{0},C_{p_{2},p_{3}}^{0},...C_{p_{m-1},p_{m}}^{0}         T  ←  *   (   R   p  1    )   ,   C    p  1   ,   p  2    0   ,  *   (   R   p  2    )   ,   C    p  2   ,   p  3    0   ,  …  ,  *   (   R   p   m  -  1     )   ,   C    p   m  -  1    ,   p  m    0   ,  *   (   R   p  m    )      fragments  T  normal-←    fragments  normal-(   subscript  R   subscript  p  1    normal-)   normal-,   superscript   subscript  C    subscript  p  1    subscript  p  2     0   normal-,    fragments  normal-(   subscript  R   subscript  p  2    normal-)   normal-,   superscript   subscript  C    subscript  p  2    subscript  p  3     0   normal-,  normal-…  normal-,    fragments  normal-(   subscript  R   subscript  p    m  1     normal-)   normal-,   superscript   subscript  C    subscript  p    m  1     subscript  p  m     0   normal-,    fragments  normal-(   subscript  R   subscript  p  m    normal-)     T\leftarrow*(R_{p_{1}}),C_{p_{1},p_{2}}^{0},*(R_{p_{2}}),C_{p_{2},p_{3}}^{0},.%
 ..,*(R_{p_{m-1}}),C_{p_{m-1},p_{m}}^{0},*(R_{p_{m}})     while  not IsEmpty(    Q   Q   Q    ) do      p   p   p    ← DeleteMin(    Q   Q   Q    )   case     p   p   p    of      p   p   p    is a site in      *   (  V  )       absent  V    *(V)    :  find the occurrence of a region      *   (   R  q   )       absent   subscript  R  q     *(R_{q})    in    T   T   T    containing    p   p   p    ,  bracketed by     C   r  q      subscript  C    r  q     C_{rq}    on the left and     C   q  s      subscript  C    q  s     C_{qs}    on the right  create new boundary rays     C   p  q   -     superscript   subscript  C    p  q       C_{pq}^{-}    and     C   p  q   +     superscript   subscript  C    p  q       C_{pq}^{+}    with bases    p   p   p     replace      *   (   R  q   )       absent   subscript  R  q     *(R_{q})    with     *   (   R  q   )   ,   C   p  q   -   ,  *   (   R  p   )   ,   C   p  q   +   ,  *   (   R  q   )      fragments    fragments  normal-(   subscript  R  q   normal-)   normal-,   superscript   subscript  C    p  q      normal-,    fragments  normal-(   subscript  R  p   normal-)   normal-,   superscript   subscript  C    p  q      normal-,    fragments  normal-(   subscript  R  q   normal-)     *(R_{q}),C_{pq}^{-},*(R_{p}),C_{pq}^{+},*(R_{q})    in    T   T   T     delete from    Q   Q   Q    any intersection between     C   r  q      subscript  C    r  q     C_{rq}    and     C   q  s      subscript  C    q  s     C_{qs}     insert into    Q   Q   Q    any intersection between     C   r  q      subscript  C    r  q     C_{rq}    and     C   p  q   -     superscript   subscript  C    p  q       C_{pq}^{-}     insert into    Q   Q   Q    any intersection between     C   p  q   +     superscript   subscript  C    p  q       C_{pq}^{+}    and     C   q  s      subscript  C    q  s     C_{qs}        p   p   p   is a Voronoi vertex in     *   (  V  )       absent  V    *(V)   :  let    p   p   p    be the intersection of     C   q  r      subscript  C    q  r     C_{qr}    on the left and     C   r  s      subscript  C    r  s     C_{rs}    on the right  let     C   u  q      subscript  C    u  q     C_{uq}    be the left neighbor of     C   q  r      subscript  C    q  r     C_{qr}    and  let     C   s  v      subscript  C    s  v     C_{sv}    be the right neighbor of     C   r  s      subscript  C    r  s     C_{rs}    in    T   T   T     create a new boundary ray     C   q  s   0     superscript   subscript  C    q  s    0    C_{qs}^{0}    if      q  y   =   s  y        subscript  q  y    subscript  s  y     q_{y}=s_{y}    ,  or create     C   q  s   +     superscript   subscript  C    q  s       C_{qs}^{+}    if    p   p   p    is right of the higher of    q   q   q    and    s   s   s    ,  otherwise create     C   q  s   -     superscript   subscript  C    q  s       C_{qs}^{-}     replace      C   q  r    ,  *   (   R  r   )   ,   C   r  s       fragments   subscript  C    q  r    normal-,    fragments  normal-(   subscript  R  r   normal-)   normal-,   subscript  C    r  s      C_{qr},*(R_{r}),C_{rs}    with newly created     C   q  s      subscript  C    q  s     C_{qs}    in    T   T   T     delete from    Q   Q   Q    any intersection between     C   u  q      subscript  C    u  q     C_{uq}    and     C   q  r      subscript  C    q  r     C_{qr}     delete from    Q   Q   Q    any intersection between     C   r  s      subscript  C    r  s     C_{rs}    and     C   s  v      subscript  C    s  v     C_{sv}     insert into    Q   Q   Q    any intersection between     C   u  q      subscript  C    u  q     C_{uq}    and     C   q  s      subscript  C    q  s     C_{qs}     insert into    Q   Q   Q    any intersection between     C   q  s      subscript  C    q  s     C_{qs}    and     C   s  v      subscript  C    s  v     C_{sv}     record    p   p   p    as the summit of     C   q  r      subscript  C    q  r     C_{qr}    and     C   r  s      subscript  C    r  s     C_{rs}    and the base of     C   q  s      subscript  C    q  s     C_{qs}     output the boundary segments     C   q  r      subscript  C    q  r     C_{qr}    and     C   r  s      subscript  C    r  s     C_{rs}      endcase  endwhile  output the remaining boundary rays in    T   T   T     Weighted sites and disks  As Fortune describes in 5 a modified version of the sweepline algorithm can be used to construct an additively weighted Voronoi diagram, in which the distance to each site is offset by the weight of the site; this may equivalently be viewed as a Voronoi diagram of a set of disks, centered at the sites with radius equal to the weight of the site.  Weighted sites may be used to control the areas of the Voronoi cells when using Voronoi diagrams to construct treemaps . In an additively weighted Voronoi diagram, the bisector between sites is in general a hyperbola, in contrast to unweighted Voronoi diagrams and power diagrams of disks for which it is a straight line.  References  External links   Steven Fortune's C implementation  Fortune's Voronoi algorithm implemented in C++  Fortune's algorithm implemented in JavaScript   "  Category:Computational geometry  Category:Articles with example pseudocode     Section 7.2: Computing the Voronoi Diagram: pp.151–160. ↩  . ↩  Steven Fortune. A sweepline algorithm for Voronoi diagrams. Proceedings of the second annual symposium on Computational geometry . Yorktown Heights, New York, United States, pp.313–322. 1986. ISBN 0-89791-194-6. ACM Digital Library SpringerLink ↩  . ↩      