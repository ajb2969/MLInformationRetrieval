<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="201">Elliptic curve point multiplication</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Elliptic curve point multiplication</h1>
<hr/>

<p><strong>Elliptic curve point multiplication</strong> is the operation of successively adding a point along an <a href="elliptic_curve" title="wikilink">elliptic curve</a> to itself repeatedly. It is used in <a href="elliptic_curve_cryptography" title="wikilink">elliptic curve cryptography</a> (ECC) as a means of producing a <a href="trapdoor_function" title="wikilink">trapdoor function</a>. The literature presents this operation as <a href="scalar_multiplication" title="wikilink">scalar multiplication</a>, thus the most common name is "elliptic curve scalar multiplication", as written in <a href="Hessian_form_of_an_elliptic_curve" title="wikilink">Hessian form of an elliptic curve</a>.</p>
<h2 id="basics">Basics</h2>

<p>Given a curve, <em>E</em>, defined along some equation in a finite field (such as <em>E</em>: <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em>), point multiplication is defined as the repeated addition of a point along that curve. Denote as <em>nP</em> = <em>P</em> + <em>P</em> + <em>P</em> + … + <em>P</em> for some scalar (integer) <em>n</em> and a point <em>P</em> = (<em>x</em>, <em>y</em>) that lies on the curve, <em>E</em>. This type of curve is known as a Weierstrass curve.</p>

<p>The security of modern ECC depends on the intractability of determining <em>n</em> from 

<math display="inline" id="Elliptic_curve_point_multiplication:0">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>Q</mi>
   </mpadded>
   <mo rspace="5.8pt">=</mo>
   <mrow>
    <mi>n</mi>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Q~{}=~{}nP
  </annotation>
 </semantics>
</math>

 given known values of <em>Q</em> and <em>P</em>. It is known as the elliptic curve discrete logarithm problem.</p>
<h2 id="point-addition">Point addition</h2>

<p>With 2 distinct points, <em>P</em> and <em>Q</em>, addition is defined as the negation of the point resulting from the intersection of the curve, <em>E</em>, and the straight line defined by the points <em>P</em> and <em>Q</em>, giving the point, <em>R</em>.</p>

<p>

<math display="inline" id="Elliptic_curve_point_multiplication:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>+</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P+Q
  </annotation>
 </semantics>
</math>


.</p>

<p>Assuming, the elliptic curve, <em>E</em>, is given by <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em>, this can be calculated as:</p>

<p>

<math display="inline" id="Elliptic_curve_point_multiplication:2">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x_{r}
  </annotation>
 </semantics>
</math>


</p>
<h3 id="point-doubling">Point doubling</h3>

<p>Where the points, <em>P</em> and <em>Q</em>, are coincident, addition is similar, except that there is no well-defined straight line through <em>P</em> and <em>Q</em>, so the limiting case, the tangent to the curve, <em>E</em>, at <em>P</em> and <em>Q</em> is used instead.</p>

<p>This is calculated as above, except with:</p>

<p>

<math display="block" id="Elliptic_curve_point_multiplication:3">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mn>3</mn>
      <msubsup>
       <mi>x</mi>
       <mi>p</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo>+</mo>
     <mi>a</mi>
    </mrow>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>y</mi>
      <mi>p</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>p</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=\frac{3x_{p}^{2}+a}{2y_{p}}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>a</em> is from the defining equation of the curve, <em>E</em>, above.</p>
<h2 id="point-multiplication">Point multiplication</h2>

<p>The straightforward way of computing a point multiplication is through repeated addition. However, this is a fully exponential approach to computing the multiplication.</p>
<h3 id="double-and-add">Double-and-add</h3>

<p>The simplest method is the <strong>double-and-add</strong> method, similar to multiply-and-square in modular exponentiation. The algorithm works as follows:</p>

<p>To compute <em>dP</em>, start with the binary representation for <em>d</em>

<math display="block" id="Elliptic_curve_point_multiplication:4">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>d</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mn>2</mn>
     </msup>
     <msub>
      <mi>d</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>m</mi>
     </msup>
     <msub>
      <mi>d</mi>
      <mi>m</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=d_{0}+2d_{1}+2^{2}d_{2}+\cdots+2^{m}d_{m}
  </annotation>
 </semantics>
</math>

, where [

<math display="inline" id="Elliptic_curve_point_multiplication:5">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mn>0</mn>
   </msub>
   <mo>.</mo>
   <mo>.</mo>
   <msub>
    <mi>d</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-.</ci>
    <ci>normal-.</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>m</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{0}..d_{m}
  </annotation>
 </semantics>
</math>

] ∈ {0,1}</p>

<p><code>  * </code><em><code>Q</code></em><code> := </code><em><code>0</code></em><br/>
<code>  * for </code><em><code>i</code></em><code> from 0 to m do</code><br/>
<code>     * if </code><em><code>d</code></em><sub><em><code>i</code></em></sub><code> = 1 then </code><em><code>Q</code></em><code> := </code><em><code>Q</code></em><code> + </code><em><code>P</code></em><code> (using point addition)</code><br/>
<code>     * </code><em><code>P</code></em><code> := 2</code><em><code>P</code></em><code> (using point doubling)</code><br/>
<code>  * Return </code><em><code>Q</code></em></p>

<p>An alternative way of writing the above as a recursive function is</p>
<pre><code>f(P, n) is
   if n = 0 then return 0           # computation complete
   if n = 1 then return P
   else if n mod 2 = 1 then
      return P + f(P, n-1)                 # addition when n is odd
   else
      return f(2P, n/2)                    # doubling when n is even</code></pre>

<p>where f is the function for doubling, P is the coordinate to double, n is the number of times to double the coordinate. Example: 100P can be written as 2(2(P+2(2(2(P+2P))))) and thus requires six doublings and two additions. 100P would be equal to f(P,100).</p>

<p>This algorithm requires log<sub>2</sub>(<em>n</em>) iterations of point doubling and addition to compute the full-point multiplication. There are many variations of this algorithm such as using a window, sliding window, NAF, NAF-w, vector chains, and Montgomery ladder.</p>
<h3 id="windowed-method">Windowed method</h3>

<p>In the <strong>windowed</strong> version of this algorithm, one selects a window size <em>w</em> and computes all 

<math display="inline" id="Elliptic_curve_point_multiplication:6">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>w</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{w}
  </annotation>
 </semantics>
</math>

 values of 

<math display="inline" id="Elliptic_curve_point_multiplication:7">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dP
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Elliptic_curve_point_multiplication:8">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>w</mi>
     </msup>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>w</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=0,1,2,\dots,2^{w}-1
  </annotation>
 </semantics>
</math>

. The algorithm now uses the representation 

<math display="inline" id="Elliptic_curve_point_multiplication:9">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>w</mi>
     </msup>
     <msub>
      <mi>d</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mn>2</mn>
       <mi>w</mi>
      </mrow>
     </msup>
     <msub>
      <mi>d</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>m</mi>
       <mi>w</mi>
      </mrow>
     </msup>
     <msub>
      <mi>d</mi>
      <mi>m</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>w</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>w</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>w</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=d_{0}+2^{w}d_{1}+2^{2w}d_{2}+\cdots+2^{mw}d_{m}
  </annotation>
 </semantics>
</math>

 and becomes</p>

<p><code>  * </code><em><code>Q</code></em><code> = 0</code><br/>
<code>  * for </code><em><code>i</code></em><code> from m to 0 do</code><br/>
<code>    * </code><em><code>Q</code></em><code> := 2</code><sup><code>w</code></sup><em><code>Q</code></em><code> (using repeated point doubling)</code><br/>
<code>    * if </code><em><code>d</code></em><sub><code>i</code></sub><code> &gt; 0 then </code><em><code>Q</code></em><code> := </code><em><code>Q</code></em><code> + </code><em><code>d</code></em><sub><code>i</code></sub><code>P (using a single point addition with the pre-computed value of </code><em><code>d</code></em><sub><code>i</code></sub><code>P)</code><br/>
<code>  * Return </code><em><code>Q</code></em></p>

<p>This algorithm has the same complexity as the double-and-add approach with the benefit of using fewer point additions (which in practice are slower than doubling). Typically, the value of <em>w</em> is chosen to be fairly small making the <a class="uri" href="pre-computation" title="wikilink">pre-computation</a> stage a trivial component of the algorithm. For the NIST recommended curves, 

<math display="inline" id="Elliptic_curve_point_multiplication:10">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=4
  </annotation>
 </semantics>
</math>

 is usually the best selection. The entire complexity for a <em>n</em>-bit number is measured as 

<math display="inline" id="Elliptic_curve_point_multiplication:11">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 point doubles and 

<math display="inline" id="Elliptic_curve_point_multiplication:12">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>w</mi>
    </msup>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
   <mo>+</mo>
   <mfrac>
    <mi>n</mi>
    <mi>w</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>w</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{w}-2+{n\over w}
  </annotation>
 </semantics>
</math>

 point additions.</p>
<h3 id="sliding-window-method">Sliding-window method</h3>

<p>In the <strong>sliding-window</strong> version, we look to trade off point additions for point doubles. We compute a similar table as in the windowed version except we only compute the points 

<math display="inline" id="Elliptic_curve_point_multiplication:13">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dP
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Elliptic_curve_point_multiplication:14">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>w</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>,</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>w</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>w</mi>
     </msup>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>w</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=2^{w-1},2^{w-1}+1,\dots,2^{w}-1
  </annotation>
 </semantics>
</math>

. Effectively, we are only computing the values for which the most significant bit of the window is set. The algorithm then uses the original double-and-add representation of 

<math display="inline" id="Elliptic_curve_point_multiplication:15">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>d</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mn>2</mn>
     </msup>
     <msub>
      <mi>d</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>m</mi>
     </msup>
     <msub>
      <mi>d</mi>
      <mi>m</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=d_{0}+2d_{1}+2^{2}d_{2}+\cdots+2^{m}d_{m}
  </annotation>
 </semantics>
</math>

.</p>

<p><code>  * </code><em><code>Q</code></em><code> = 0</code><br/>
<code>  * for </code><em><code>i</code></em><code> from </code><em><code>m</code></em><code> downto 0 do</code><br/>
<code>     * if </code><em><code>d</code></em><sub><code>i</code></sub><code> = 0 then</code><br/>
<code>        * </code><em><code>Q</code></em><code> := 2Q (point double)</code><br/>
<code>     * else </code><br/>
<code>        * Grab up to </code><em><code>w</code></em><code> - 1 additional bits from </code><em><code>d</code></em><code> to store into (including d</code><sub><code>i</code></sub><code>) </code><em><code>t</code></em><code> and decrement </code><em><code>i</code></em><code> suitably</code><br/>
<code>        * If fewer than </code><em><code>w</code></em><code> bits were grabbed </code><br/>
<code>           * Perform double-and-add using </code><em><code>t</code></em><code> </code><br/>
<code>           * Return </code><em><code>Q</code></em><br/>
<code>        * else </code><br/>
<code>           * </code><em><code>Q</code></em><code> := 2</code><sup><code>w</code></sup><code>Q (repeated point double)</code><br/>
<code>           * </code><em><code>Q</code></em><code> := </code><em><code>Q</code></em><code> + </code><em><code>tP</code></em><code> (point addition)</code><br/>
<code>  * Return </code><em><code>Q</code></em></p>

<p>This algorithm has the benefit that the pre-computation stage is roughly half as complex as the normal windowed method while also trading slower point additions for point doublings. In effect, there is little reason to use the windowed method over this approach. The algorithm requires 

<math display="inline" id="Elliptic_curve_point_multiplication:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>+</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w-1+n
  </annotation>
 </semantics>
</math>

 point doubles and at most 

<math display="inline" id="Elliptic_curve_point_multiplication:17">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>w</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>+</mo>
   <mfrac>
    <mi>n</mi>
    <mi>w</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{w-1}-1+{n\over w}
  </annotation>
 </semantics>
</math>

 point additions.</p>
<h3 id="wnaf-method">wNAF method</h3>

<p>In the <a href="Non-adjacent_form" title="wikilink">Non-Adjacent Form</a> we aim to make use of the fact that point subtraction is just as easy as point addition to perform fewer (of either) as compared to a sliding-window method. The NAF of the multiplicand 

<math display="inline" id="Elliptic_curve_point_multiplication:18">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 must be computed first with the following algorithm</p>

<p><code>   * </code><em><code>i</code></em><code> = 0</code><br/>
<code>   * While (</code><em><code>d</code></em><code> &gt; 0) do</code><br/>
<code>       * if (</code><em><code>d</code></em><code> mod 2) == 1 then </code><br/>
<code>           * </code><em><code>d</code></em><sub><code>i</code></sub><code> = </code><em><code>d</code></em><code> mods 2</code><sup><code>w</code></sup><br/>
<code>           * </code><em><code>d</code></em><code> = </code><em><code>d</code></em><code> - </code><em><code>d</code></em><sub><code>i</code></sub><br/>
<code>       * else</code><br/>
<code>           * </code><em><code>d</code></em><sub><code>i</code></sub><code> = 0</code><br/>
<code>       * </code><em><code>d</code></em><code> = </code><em><code>d</code></em><code>/2</code><br/>
<code>       * </code><em><code>i</code></em><code> = </code><em><code>i</code></em><code> + 1</code><br/>
<code>   * return (</code><em><code>d</code></em><sub><code>i-1</code></sub><code>, </code><em><code>d</code></em><sub><code>i-2</code></sub><code>, ..., </code><em><code>d</code></em><sub><code>0</code></sub><code>)</code></p>

<p>Where the <em>mods</em> function is defined as</p>

<p><code>   * if (</code><em><code>d</code></em><code> mod 2</code><sup><code>w</code></sup><code>) &gt;= 2</code><sup><code>w-1</code></sup><br/>
<code>       * return (</code><em><code>d</code></em><code> mod 2</code><sup><code>w</code></sup><code>) - 2</code><sup><code>w</code></sup><br/>
<code>   * else</code><br/>
<code>       * return d mod 2</code><sup><code>w</code></sup></p>

<p>This produces the NAF needed to now perform the multiplication. This algorithm requires the pre-computation of the points 

<math display="inline" id="Elliptic_curve_point_multiplication:19">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>5</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>w</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">3</cn>
     <cn type="integer">5</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </set>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,3,5,\dots,2^{w-1}-1\}P
  </annotation>
 </semantics>
</math>

 and their negatives, where 

<math display="inline" id="Elliptic_curve_point_multiplication:20">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is the point to be multiplied. On typical Weierstrass curves, if 

<math display="inline" id="Elliptic_curve_point_multiplication:21">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <set>
     <ci>x</ci>
     <ci>y</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\{x,y\}
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Elliptic_curve_point_multiplication:22">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <mo>-</mo>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>P</ci>
    </apply>
    <set>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <ci>y</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -P=\{x,-y\}
  </annotation>
 </semantics>
</math>

. So in essence the negatives are cheap to compute. Next, the following algorithm computes the multiplication 

<math display="inline" id="Elliptic_curve_point_multiplication:23">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dP
  </annotation>
 </semantics>
</math>

:</p>

<p><code>   * Q = 0</code><br/>
<code>   * for </code><em><code>j</code></em><code> = </code><em><code>i</code></em><code>-1 downto 0 do</code><br/>
<code>       * Q = 2Q</code><br/>
<code>       * if (</code><em><code>d</code></em><sub><code>j</code></sub><code> != 0)</code><br/>
<code>           * Q = Q + </code><em><code>d</code></em><sub><code>j</code></sub><code>G</code><br/>
<code>   * return Q</code></p>

<p>The wNAF guarantees that on average there will be a density of 

<math display="inline" id="Elliptic_curve_point_multiplication:24">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mrow>
    <mi>w</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <plus></plus>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\over{w+1}
  </annotation>
 </semantics>
</math>

 point additions (slightly better than the unsigned window). It requires 1 point doubling and 

<math display="inline" id="Elliptic_curve_point_multiplication:25">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>w</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>w</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{w-2}-1
  </annotation>
 </semantics>
</math>

 point additions for precomputation. The algorithm then requires 

<math display="inline" id="Elliptic_curve_point_multiplication:26">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 point doublings and 

<math display="inline" id="Elliptic_curve_point_multiplication:27">
 <semantics>
  <mfrac>
   <mi>n</mi>
   <mrow>
    <mi>w</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <apply>
     <plus></plus>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\over{w+1}
  </annotation>
 </semantics>
</math>

 point additions for the rest of the multiplication.</p>

<p>One property of the NAF is that we are guaranteed that every non-zero element 

<math display="inline" id="Elliptic_curve_point_multiplication:28">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{i}
  </annotation>
 </semantics>
</math>

 is followed by at least 

<math display="inline" id="Elliptic_curve_point_multiplication:29">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>w</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w-1
  </annotation>
 </semantics>
</math>

 additional zeroes. This is because the algorithm clears out the lower 

<math display="inline" id="Elliptic_curve_point_multiplication:30">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 bits of 

<math display="inline" id="Elliptic_curve_point_multiplication:31">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 with every subtraction of the output of the <em>mods</em> function. This observation can be used for several purposes. After every non-zero element the additional zeroes can be implied and do not need to be stored. Secondly, the multiple serial divisions by 2 can be replaced by a division by 

<math display="inline" id="Elliptic_curve_point_multiplication:32">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>w</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{w}
  </annotation>
 </semantics>
</math>

 after every non-zero 

<math display="inline" id="Elliptic_curve_point_multiplication:33">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{i}
  </annotation>
 </semantics>
</math>

 element and divide by 2 after every zero.</p>
<h3 id="montgomery-ladder">Montgomery ladder</h3>

<p>The <strong>Montgomery ladder</strong> approach computes the point multiplication in a <strong>fixed</strong> amount of time. This can be beneficial when timing or power consumption measurements are exposed to an attacker performing a <a href="side-channel_attack" title="wikilink">side-channel attack</a>. The algorithm uses the same representation as from double-and-add.</p>

<p><code>  * </code><em><code>R</code></em><sub><code>0</code></sub><code> := 0</code><br/>
<code>  * </code><em><code>R</code></em><sub><code>1</code></sub><code> := P</code><br/>
<code>  * for </code><em><code>i</code></em><code> from </code><em><code>m</code></em><code> downto 0 do</code><br/>
<code>     * if </code><em><code>d</code></em><sub><code>i</code></sub><code> = 0 then</code><br/>
<code>        * </code><em><code>R</code></em><sub><code>1</code></sub><code> := </code><em><code>R</code></em><sub><code>0</code></sub><code> + </code><em><code>R</code></em><sub><code>1</code></sub><br/>
<code>        * </code><em><code>R</code></em><sub><code>0</code></sub><code> := 2</code><em><code>R</code></em><sub><code>0</code></sub><br/>
<code>     * else</code><br/>
<code>        * </code><em><code>R</code></em><sub><code>0</code></sub><code> := </code><em><code>R</code></em><sub><code>0</code></sub><code> + </code><em><code>R</code></em><sub><code>1</code></sub><br/>
<code>        * </code><em><code>R</code></em><sub><code>1</code></sub><code> := 2</code><em><code>R</code></em><sub><code>1</code></sub><br/>
<code>  * Return </code><em><code>R</code></em><sub><code>0</code></sub></p>

<p>This algorithm has in effect the same speed as the double-and-add approach except that it computes the same number of point additions and doubles regardless of the value of the multiplicand <em>d</em>. This means that at this level the algorithm does not leak any information through timing or power. However, it was shown by Yuval Yarom and Naomi Benger that through application of FLUSH+RELOAD side-channel attack the full private key can be revealed in only one multiplication operation.</p>
<h2 id="references">References</h2>
<ul>
<li>Yuval Yarom and Naomi Benger. Recovering OpenSSL ECDSA Nonces Using the FLUSH+RELOAD Cache Side-channel Attack.</li>
</ul>

<p>Cryptology ePrint Archive, Report 2014/140, 2014. <a class="uri" href="http://eprint.iacr.org/2014/140.pdf">http://eprint.iacr.org/2014/140.pdf</a></p>

<p>"</p>

<p><a href="Category:Elliptic_curves" title="wikilink">Category:Elliptic curves</a></p>
</body>
</html>
