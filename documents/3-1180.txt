   Paillier cryptosystem      Paillier cryptosystem   The Paillier cryptosystem , named after and invented by Pascal Paillier in 1999, is a probabilistic asymmetric algorithm for public key cryptography . The problem of computing n -th residue classes is believed to be computationally difficult. The decisional composite residuosity assumption is the intractability hypothesis upon which this cryptosystem is based.  The scheme is an additive homomorphic cryptosystem; this means that, given only the public-key and the encryption of    m  1     subscript  m  1    m_{1}   and    m  2     subscript  m  2    m_{2}   , one can compute the encryption of     m  1   +   m  2        subscript  m  1    subscript  m  2     m_{1}+m_{2}   .  Algorithm  The scheme works as follows:  Key generation   Choose two large prime numbers  p and q randomly and independently of each other such that     gcd   (   p  q   ,    (   p  -  1   )    (   q  -  1   )    )    =  1          p  q       p  1     q  1     1    \gcd(pq,(p-1)(q-1))=1   . This property is assured if both primes are of equal length. 1  Compute    n  =   p  q       n    p  q     n=pq   and    λ  =   lcm   (   p  -  1   ,   q  -  1   )        λ   lcm    p  1     q  1      \lambda=\operatorname{lcm}(p-1,q-1)   .  Select random integer   g   g   g   where    g  ∈   ℤ   n  2   *       g   subscript   superscript  ℤ     superscript  n  2      g\in\mathbb{Z}^{*}_{n^{2}}     Ensure   n   n   n   divides the order of   g   g   g   by checking the existence of the following modular multiplicative inverse     μ  =     (   L   (    g  λ   mod   n  2    )    )    -  1    mod  n       μ   modulo   superscript    L   modulo   superscript  g  λ    superscript  n  2       1    n     \mu=(L(g^{\lambda}\bmod n^{2}))^{-1}\bmod n   ,    where function   L   L   L   is defined as     L   (  u  )    =    u  -  1   n         L  u       u  1   n     L(u)=\frac{u-1}{n}   .  Note that the notation    a  b      a  b    \frac{a}{b}   does not denote the modular multiplication of   a   a   a   times the modular multiplicative inverse of   b   b   b   but rather the quotient of   a   a   a   divided by   b   b   b   , i.e., the largest integer value    v  ≥  0      v  0    v\geq 0   to satisfy the relation    a  ≥   v  b       a    v  b     a\geq vb   .      The public (encryption) key is    (  n  ,  g  )     n  g    (n,g)   .  The private (decryption) key is     (  λ  ,  μ  )   .     λ  μ    (\lambda,\mu).      If using p,q of equivalent length, a simpler variant of the above key generation steps would be to set      g  =   n  +  1    ,   λ  =   φ   (  n  )      ,     formulae-sequence    g    n  1      λ    φ  n      g=n+1,\lambda=\varphi(n),   and    μ  =    φ    (  n  )    -  1     mod  n       μ   modulo    φ   superscript  n    1     n     \mu=\varphi(n)^{-1}\bmod n   , where     φ   (  n  )    =    (   p  -  1   )    (   q  -  1   )          φ  n       p  1     q  1      \varphi(n)=(p-1)(q-1)   . 2  Encryption   Let   m   m   m   be a message to be encrypted where    m  ∈   ℤ  n       m   subscript  ℤ  n     m\in\mathbb{Z}_{n}     Select random   r   r   r   where    r  ∈   ℤ  n  *       r   subscript   superscript  ℤ    n     r\in\mathbb{Z}^{*}_{n}     Compute ciphertext as    c  =     g  m   ⋅   r  n    mod   n  2        c   modulo   normal-⋅   superscript  g  m    superscript  r  n     superscript  n  2      c=g^{m}\cdot r^{n}\bmod n^{2}      Decryption   Let   c   c   c   be the ciphertext to decrypt, where    c  ∈   ℤ   n  2   *       c   subscript   superscript  ℤ     superscript  n  2      c\in\mathbb{Z}^{*}_{n^{2}}     Compute the plaintext message as    m  =     L   (    c  λ   mod   n  2    )    ⋅  μ   mod  n       m   modulo   normal-⋅    L   modulo   superscript  c  λ    superscript  n  2     μ   n     m=L(c^{\lambda}\bmod n^{2})\cdot\mu\bmod n      As the original paper points out, decryption is "essentially one exponentiation modulo    n  2     superscript  n  2    n^{2}   ."  Homomorphic properties  A notable feature of the Paillier cryptosystem is its homomorphic properties. As the encryption function is additively homomorphic, the following identities can be described:   Homomorphic addition of plaintexts    The product of two ciphertexts will decrypt to the sum of their corresponding plaintexts,           D   (      E   (   m  1   ,   r  1   )    ⋅  E    (   m  2   ,   r  2   )    mod   n  2    )    =     m  1   +   m  2    mod  n    .        D   modulo     normal-⋅    E    subscript  m  1    subscript  r  1     E     subscript  m  2    subscript  r  2      superscript  n  2      modulo     subscript  m  1    subscript  m  2    n     D(E(m_{1},r_{1})\cdot E(m_{2},r_{2})\bmod n^{2})=m_{1}+m_{2}\bmod n.\,         The product of a ciphertext with a plaintext raising g will decrypt to the sum of the corresponding plaintexts,           D   (     E   (   m  1   ,   r  1   )    ⋅   g   m  2     mod   n  2    )    =     m  1   +   m  2    mod  n    .        D   modulo   normal-⋅    E    subscript  m  1    subscript  r  1      superscript  g   subscript  m  2      superscript  n  2      modulo     subscript  m  1    subscript  m  2    n     D(E(m_{1},r_{1})\cdot g^{m_{2}}\bmod n^{2})=m_{1}+m_{2}\bmod n.\,         Homomorphic multiplication of plaintexts    An encrypted plaintext raised to the power of another plaintext will decrypt to the product of the two plaintexts,           D   (    E    (   m  1   ,   r  1   )    m  2     mod   n  2    )    =     m  1    m  2    mod  n    ,        D   modulo    E   superscript    subscript  m  1    subscript  r  1     subscript  m  2      superscript  n  2      modulo     subscript  m  1    subscript  m  2    n     D(E(m_{1},r_{1})^{m_{2}}\bmod n^{2})=m_{1}m_{2}\bmod n,\,           D   (    E    (   m  2   ,   r  2   )    m  1     mod   n  2    )    =     m  1    m  2    mod  n    .        D   modulo    E   superscript    subscript  m  2    subscript  r  2     subscript  m  1      superscript  n  2      modulo     subscript  m  1    subscript  m  2    n     D(E(m_{2},r_{2})^{m_{1}}\bmod n^{2})=m_{1}m_{2}\bmod n.\,         More generally, an encrypted plaintext raised to a constant k will decrypt to the product of the plaintext and the constant,           D   (    E    (   m  1   ,   r  1   )   k    mod   n  2    )    =    k   m  1    mod  n    .        D   modulo    E   superscript    subscript  m  1    subscript  r  1    k     superscript  n  2      modulo    k   subscript  m  1    n     D(E(m_{1},r_{1})^{k}\bmod n^{2})=km_{1}\bmod n.\,        However, given the Paillier encryptions of two messages there is no known way to compute an encryption of the product of these messages without knowing the private key.  Background  Paillier cryptosystem exploits the fact that certain discrete logarithms can be computed easily.  For example, by binomial theorem ,          (   1  +  n   )   x   =    ∑   k  =  0   x     (      x      k      )    n  k     =   1  +   n  x   +    (      x      2      )    n  2    +   higher powers of  n           superscript    1  n   x     superscript   subscript     k  0    x      binomial  x  k    superscript  n  k            1    n  x      binomial  x  2    superscript  n  2      higher powers of  n       (1+n)^{x}=\sum_{k=0}^{x}{x\choose k}n^{k}=1+nx+{x\choose 2}n^{2}+\text{higher %
 powers of }n        This indicates that:          (   1  +  n   )   x   ≡    1  +   n  x       (   mod   n  2    )         superscript    1  n   x    annotated    1    n  x     pmod   superscript  n  2       (1+n)^{x}\equiv 1+nx\;\;(\mathop{{\rm mod}}n^{2})        Therefore, if:        y  =     (   1  +  n   )   x   mod   n  2        y   modulo   superscript    1  n   x    superscript  n  2      y=(1+n)^{x}\bmod n^{2}        then        x  ≡     y  -  1   n      (   mod  n   )        x   annotated      y  1   n    pmod  n      x\equiv\frac{y-1}{n}\;\;(\mathop{{\rm mod}}n)   .     Thus:         L   (     (   1  +  n   )   x   mod   n  2    )    ≡   x     (   mod  n   )          L   modulo   superscript    1  n   x    superscript  n  2      annotated  x   pmod  n      L((1+n)^{x}\bmod n^{2})\equiv x\;\;(\mathop{{\rm mod}}n)   ,    where function   L   L   L   is defined as     L   (  u  )    =    u  -  1   n         L  u       u  1   n     L(u)=\frac{u-1}{n}   (quotient of integer division) and    x  ∈   ℤ  n       x   subscript  ℤ  n     x\in\mathbb{Z}_{n}   .   Semantic security  The original cryptosystem as shown above does provide semantic security against chosen-plaintext attacks ( IND-CPA ). The ability to successfully distinguish the challenge ciphertext essentially amounts to the ability to decide composite residuosity. The so-called decisional composite residuosity assumption (DCRA) is believed to be intractable.  Because of the aforementioned homomorphic properties however, the system is malleable , and therefore does not enjoy the highest echelon of semantic security that protects against adaptive chosen-ciphertext attacks ( IND-CCA2 ). Usually in cryptography the notion of malleability is not seen as an "advantage," but under certain applications such as secure electronic voting and threshold cryptosystems, this property may indeed be necessary.  Paillier and Pointcheval however went on to propose an improved cryptosystem that incorporates the combined hashing of message m with random r . Similar in intent to the Cramer–Shoup cryptosystem , the hashing prevents an attacker, given only c, from being able to change m in a meaningful way. Through this adaptation the improved scheme can be shown to be IND-CCA2 secure in the random oracle model .  Applications   Electronic voting   Semantic security is not the only consideration. There are situations under which malleability may be desirable. The above homomorphic properties can be utilized by secure electronic voting systems. Consider a simple binary ("for" or "against") vote. Let m voters cast a vote of either 1 (for) or 0 (against). Each voter encrypts their choice before casting their vote. The election official takes the sum of the m encrypted votes and then decrypts the result and obtains the value n , which is the sum of all the votes. The election official then knows that n people voted for and m-n people voted against . The role of the random r ensures that two equivalent votes will encrypt to the same value only with negligible likelihood, hence ensuring voter privacy.   Electronic cash   Another feature named in paper is the notion of self- blinding . This is the ability to change one ciphertext into another without changing the content of its decryption. This has application to the development of ecash , an effort originally spearheaded by David Chaum . Imagine paying for an item online without the vendor needing to know your credit card number, and hence your identity. The goal in both electronic cash and electronic voting, is to ensure the e-coin (likewise e-vote) is valid, while at the same time not disclosing the identity of the person with whom it is currently associated.  See also   The Okamoto–Uchiyama cryptosystem as a historical antecedent of Paillier.  The Damgård–Jurik cryptosystem is a generalization of Paillier.  The Paillier cryptosystem interactive simulator demonstrates a voting application.  An interactive demo of the Paillier cryptosystem.  A proof-of-concept Javascript implementation of the Paillier cryptosystem with an interactive demo .  A googletechtalk video on voting using cryptographic methods.   References         Notes  External links   The Homomorphic Encryption Project implements the Paillier cryptosystem along with its homomorphic operations.  Encounter: an open-source library providing an implementation of Paillier cryptosystem and a cryptographic counters construction based on the same.  python-paillier a library for Partially Homomorphic Encryption in Python, including full support for floating point numbers.   "  Category:Public-key encryption schemes     Jonathan Katz, Yehuda Lindell, "Introduction to Modern Cryptography: Principles and Protocols," Chapman & Hall/CRC, 2007 ↩      