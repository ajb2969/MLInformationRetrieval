<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="829">Negation as failure</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Negation as failure</h1>
<hr/>

<p><strong>Negation as failure</strong> (<strong>NAF</strong>, for short) is a <a href="non-monotonic_logic" title="wikilink">non-monotonic</a> inference rule in <a href="logic_programming" title="wikilink">logic programming</a>, used to derive 

<math display="inline" id="Negation_as_failure:0">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>not</mi>
   </mpadded>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>not</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}p
  </annotation>
 </semantics>
</math>

 (i.e. that 

<math display="inline" id="Negation_as_failure:1">
 <semantics>
  <mpadded lspace="3.3pt" width="+3.3pt">
   <mi>p</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ~{}p
  </annotation>
 </semantics>
</math>

 is assumed not to hold) from failure to derive 

<math display="inline" id="Negation_as_failure:2">
 <semantics>
  <mpadded lspace="3.3pt" width="+3.3pt">
   <mi>p</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ~{}p
  </annotation>
 </semantics>
</math>

. Note that 

<math display="inline" id="Negation_as_failure:3">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>not</mi>
   </mpadded>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>not</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}p
  </annotation>
 </semantics>
</math>

 can be different from the statement 

<math display="inline" id="Negation_as_failure:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg p
  </annotation>
 </semantics>
</math>

 of the <a href="negation" title="wikilink">logical negation</a> of 

<math display="inline" id="Negation_as_failure:5">
 <semantics>
  <mpadded lspace="3.3pt" width="+3.3pt">
   <mi>p</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ~{}p
  </annotation>
 </semantics>
</math>

, depending on the <a href="Complete_theory" title="wikilink">completeness</a> of the inference algorithm and thus also on the formal logic system.</p>

<p>Negation as failure has been an important feature of logic programming since the earliest days of both <a href="Planner_(programming_language)" title="wikilink">Planner</a> and <a class="uri" href="Prolog" title="wikilink">Prolog</a>. In Prolog, it is usually implemented using Prolog's extralogical constructs.</p>
<h2 id="planner-semantics">Planner semantics</h2>

<p>In Planner, negation as failure could be implemented as follows:</p>
<dl>
<dd><code>''if'' (''not'' (''goal'' p)),  ''then'' (''assert'' ¬p) </code>
</dd>
</dl>

<p>which says that if an exhaustive search to prove <code>p</code> fails, then assert <code>¬p</code>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Note that the above example uses true mathematical negation, which cannot be expressed in Prolog.</p>
<h2 id="prolog-semantics">Prolog semantics</h2>

<p>In pure Prolog, NAF literals of the form 

<math display="inline" id="Negation_as_failure:6">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>o</mi>
   <mpadded width="+3.3pt">
    <mi>t</mi>
   </mpadded>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>o</ci>
    <ci>t</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   not~{}p
  </annotation>
 </semantics>
</math>

 can occur in the body of clauses and can be used to derive other NAF literals. For example, given only the four clauses</p>

<p>

<math display="block" id="Negation_as_failure:7">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>←</mo>
   <mrow>
    <mi>q</mi>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>r</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>q</ci>
     <ci>italic- and</ci>
     <ci>not</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\leftarrow q\and\mathrm{not}~{}r
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:8">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>←</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>q</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\leftarrow s
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:9">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>←</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>q</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\leftarrow t
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:10">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>←</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>t</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\leftarrow
  </annotation>
 </semantics>
</math>

</p>

<p>NAF derives 

<math display="inline" id="Negation_as_failure:11">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>not</mi>
   </mpadded>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>not</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}s
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Negation_as_failure:12">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>not</mi>
   </mpadded>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>not</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}r
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Negation_as_failure:13">
 <semantics>
  <mpadded lspace="3.3pt" width="+3.3pt">
   <mi>p</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ~{}p
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="completion-semantics">Completion semantics</h2>

<p>The semantics of NAF remained an open issue until Keith Clark [1978] showed that it is correct with respect to the completion of the logic program, where, loosely speaking, "only" and 

<math display="inline" id="Negation_as_failure:14">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

 are interpreted as "if and only if", written as "iff" or "

<math display="inline" id="Negation_as_failure:15">
 <semantics>
  <mo>≡</mo>
  <annotation-xml encoding="MathML-Content">
   <equivalent></equivalent>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \equiv
  </annotation>
 </semantics>
</math>

".</p>

<p>For example, the completion of the four clauses above is</p>

<p>

<math display="block" id="Negation_as_failure:16">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≡</mo>
   <mrow>
    <mi>q</mi>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>r</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>q</ci>
     <ci>italic- and</ci>
     <ci>not</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\equiv q\and\mathrm{not}~{}r
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:17">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>≡</mo>
   <mrow>
    <mi>s</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>q</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\equiv st
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:18">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≡</mo>
   <mi>true</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>t</ci>
    <ci>true</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\equiv\mathrm{true}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:19">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>≡</mo>
   <mi>false</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>r</ci>
    <ci>false</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\equiv\mathrm{false}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:20">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>≡</mo>
   <mi>false</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>s</ci>
    <ci>false</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\equiv\mathrm{false}
  </annotation>
 </semantics>
</math>

</p>

<p>The NAF inference rule simulates reasoning explicitly with the completion, where both sides of the equivalence are negated and negation on the right-hand side is distributed down to <a href="atomic_formula" title="wikilink">atomic formulae</a>. For example, to show 

<math display="inline" id="Negation_as_failure:21">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>not</mi>
   </mpadded>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>not</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}p
  </annotation>
 </semantics>
</math>

, NAF simulates reasoning with the equivalences</p>

<p>

<math display="block" id="Negation_as_failure:22">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>p</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>q</mi>
    <mi>r</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>not</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <ci>not</ci>
     <ci>q</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}p\equiv\mathrm{not}~{}qr
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:23">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>q</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>s</mi>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>not</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <times></times>
     <ci>not</ci>
     <ci>s</ci>
     <ci>italic- and</ci>
     <ci>not</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}q\equiv\mathrm{not}~{}s\and\mathrm{not}~{}t
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:24">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>t</mi>
   </mrow>
   <mo>≡</mo>
   <mi>false</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>not</ci>
     <ci>t</ci>
    </apply>
    <ci>false</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}t\equiv\mathrm{false}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:25">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>r</mi>
   </mrow>
   <mo>≡</mo>
   <mi>true</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>not</ci>
     <ci>r</ci>
    </apply>
    <ci>true</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}r\equiv\mathrm{true}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:26">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>s</mi>
   </mrow>
   <mo>≡</mo>
   <mi>true</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>not</ci>
     <ci>s</ci>
    </apply>
    <ci>true</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}s\equiv\mathrm{true}
  </annotation>
 </semantics>
</math>

</p>

<p>In the non-propositional case, the completion needs to be augmented with equality axioms, to formalise the assumption that individuals with distinct names are distinct. NAF simulates this by failure of unification. For example, given only the two clauses</p>

<p>

<math display="block" id="Negation_as_failure:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>a</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(a)\leftarrow
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>b</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(b)\leftarrow
  </annotation>
 </semantics>
</math>

 t</p>

<p>NAF derives 

<math display="inline" id="Negation_as_failure:29">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>not</mi>
   </mpadded>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>not</ci>
    <ci>p</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}p(c)
  </annotation>
 </semantics>
</math>

.</p>

<p>The completion of the program is</p>

<p>

<math display="block" id="Negation_as_failure:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mi>X</mi>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>X</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X)\equiv X=aX=b
  </annotation>
 </semantics>
</math>

</p>

<p>augmented with unique names axioms and domain closure axioms.</p>

<p>The completion semantics is closely related both to <a href="Circumscription_(logic)" title="wikilink">circumscription</a> and to the <a href="closed_world_assumption" title="wikilink">closed world assumption</a>.</p>
<h2 id="autoepistemic-semantics">Autoepistemic semantics</h2>

<p>The completion semantics justifies interpreting the result 

<math display="inline" id="Negation_as_failure:31">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>not</mi>
   </mpadded>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>not</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}p
  </annotation>
 </semantics>
</math>

 of a NAF inference as the classical negation 

<math display="inline" id="Negation_as_failure:32">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg p
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Negation_as_failure:33">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. However, <a href="Michael_Gelfond" title="wikilink">Michael Gelfond</a> [1987] showed that it is also possible to interpret 

<math display="inline" id="Negation_as_failure:34">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>not</mi>
   </mpadded>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>not</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}p
  </annotation>
 </semantics>
</math>

 literally as "

<math display="inline" id="Negation_as_failure:35">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 can not be shown", "

<math display="inline" id="Negation_as_failure:36">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is not known" or "

<math display="inline" id="Negation_as_failure:37">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is not believed", as in <a href="autoepistemic_logic" title="wikilink">autoepistemic logic</a>. The autoepistemic interpretation was developed further by Gelfond and <a href="Vladimir_Lifschitz" title="wikilink">Lifschitz</a> [1988] and is the basis of <a href="answer_set_programming" title="wikilink">answer set programming</a>.</p>

<p>The autoepistemics semantics of a pure Prolog program P with NAF literals is obtained by "expanding" P with a set of ground (variable-free) NAF literals Δ that is <a href="Stable_model_semantics" title="wikilink">stable</a> in the sense that</p>
<dl>
<dd>Δ = {

<math display="inline" id="Negation_as_failure:38">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>not</mi>
   </mpadded>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>not</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}p
  </annotation>
 </semantics>
</math>

 | 

<math display="inline" id="Negation_as_failure:39">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is not implied by P ∪ Δ}
</dd>
</dl>

<p>In other words, a set of assumptions Δ about what can not be shown is <a href="Stable_model_semantics" title="wikilink">stable</a> if and only if Δ is the set of all sentences that truly can not be shown from the program P expanded by Δ. Here, because of the simple syntax of pure Prolog programs, "implied by" can be understood very simply as derivability using modus ponens and universal instantiation alone.</p>

<p>A program can have zero, one or more stable expansions. For example</p>

<p>

<math display="block" id="Negation_as_failure:40">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>←</mo>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>not</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\leftarrow\mathrm{not}~{}p
  </annotation>
 </semantics>
</math>

 has no stable expansions.</p>

<p>

<math display="block" id="Negation_as_failure:41">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>←</mo>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>not</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\leftarrow\mathrm{not}~{}q
  </annotation>
 </semantics>
</math>

 has exactly one stable expansion Δ = {

<math display="inline" id="Negation_as_failure:42">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>not</mi>
   </mpadded>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>not</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}q
  </annotation>
 </semantics>
</math>

}</p>

<p>

<math display="block" id="Negation_as_failure:43">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>←</mo>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>not</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\leftarrow\mathrm{not}~{}q
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Negation_as_failure:44">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>←</mo>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>q</ci>
    <apply>
     <times></times>
     <ci>not</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\leftarrow\mathrm{not}~{}p
  </annotation>
 </semantics>
</math>

 has exactly two stable expansions Δ<sub>1</sub> = {

<math display="inline" id="Negation_as_failure:45">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>not</mi>
   </mpadded>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>not</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}p
  </annotation>
 </semantics>
</math>

} and Δ<sub>2</sub> = {

<math display="inline" id="Negation_as_failure:46">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <mi>not</mi>
   </mpadded>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>not</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{not}~{}q
  </annotation>
 </semantics>
</math>

}.</p>

<p>The autoepistemic interpretation of NAF can be combined with classical negation, as in extended logic programming and <a href="answer_set_programming" title="wikilink">answer set programming</a>. Combining the two negations, it is possible to express, for example</p>

<p>

<math display="block" id="Negation_as_failure:47">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
   </mrow>
   <mo>←</mo>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <ci>not</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg p\leftarrow\mathrm{not}~{}p
  </annotation>
 </semantics>
</math>

 (the closed world assumption) and</p>

<p>

<math display="block" id="Negation_as_failure:48">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>←</mo>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>not</mi>
    </mpadded>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>not</ci>
     <not></not>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\leftarrow\mathrm{not}~{}\neg p
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Negation_as_failure:49">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 holds by default).</p>
<h2 id="footnotes">Footnotes</h2>
<h2 id="references">References</h2>
<ul>
<li>K. Clark [1978, 1987]. <a href="http://www.doc.ic.ac.uk/~klc/neg.html">Negation as failure</a>. <em>Readings in nonmonotonic reasoning</em>, Morgan Kaufmann Publishers, pages 311-325.</li>
</ul>
<ul>
<li>M. Gelfond [1987] <a href="http://www.cs.ttu.edu/~mgelfond/papers/autoepistemic.pdf">On Stratified Autoepistemic Theories</a> Proc. AAAI, pages 207-211.</li>
</ul>
<ul>
<li>M. Gelfond and V. Lifschitz [1988] <a href="http://www.cs.ttu.edu/~mgelfond/papers/stable.pdf">The Stable Model Semantics for Logic Programming</a> Proc. 5th International Conference and Symposium on Logic Programming (R. Kowalski and K. Bowen, eds), MIT Press, pages 1070-1080.</li>
</ul>
<ul>
<li>J.C. Shepherdson [1984] <em>Negation as failure: a comparison of Clark's completed data base and Reiter's closed world assumption</em>, Journal of Logic Programming, vol 1, 1984, pages 51-81.</li>
</ul>
<ul>
<li>J.C. Shepherdson [1985] <em>Negation as failure II</em>, Journal of Logic Programming, vol 3, 1985, pages 185-202.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.w3.org/2004/12/rules-ws/report/">Report</a> from the W3C Workshop on Rule Languages for Interoperability. Includes notes on NAF and SNAF (scoped negation as failure).</li>
</ul>

<p>"</p>

<p><a href="Category:Logic_programming" title="wikilink">Category:Logic programming</a> <a href="Category:Rules_of_inference" title="wikilink">Category:Rules of inference</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
