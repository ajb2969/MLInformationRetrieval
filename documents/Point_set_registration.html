<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="454">Point set registration</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Point set registration</h1>
<hr/>

<p> In <a href="computer_vision" title="wikilink">computer vision</a> and <a href="pattern_recognition" title="wikilink">pattern recognition</a>, <strong>point set registration</strong>, also known as <strong>point matching</strong>, is the process of finding a spatial <a href="mathematical_transformation" title="wikilink">transformation</a> that aligns two <a href="point_cloud" title="wikilink">point sets</a>. The purpose of finding such a transformation includes merging multiple data sets into a globally consistent model, and mapping a new measurement to a known data set to identify features or to <a href="pose_(computer_vision)" title="wikilink">estimate its pose</a>. A point set may be raw data from <a href="3D_scanner" title="wikilink">3D scanning</a> or an array of <a href="rangefinder" title="wikilink">rangefinders</a>. For use in image processing and feature-based <a href="image_registration" title="wikilink">image registration</a>, a point set may be a set of features obtained by <a href="feature_extraction" title="wikilink">feature extraction</a> from an image, for example <a href="corner_detection" title="wikilink">corner detection</a>. Point set registration is used in <a href="optical_character_recognition" title="wikilink">optical character recognition</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and aligning data from <a href="magnetic_resonance_imaging" title="wikilink">magnetic resonance imaging</a> with <a href="computer_aided_tomography" title="wikilink">computer aided tomography</a> scans.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="overview-of-problem">Overview of problem</h2>

<p>  The problem may be summarized as follows:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Let 

<math display="inline" id="Point_set_registration:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
   <mo>,</mo>
   <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>‚Ñ≥</ci>
    <ci>ùíÆ</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\mathcal{M},\mathcal{S}\}
  </annotation>
 </semantics>
</math>

 be two finite size point sets <a href="set_membership" title="wikilink">in</a> a finite-dimensional real vector space 

<math display="inline" id="Point_set_registration:1">
 <semantics>
  <msup>
   <mi>‚Ñù</mi>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>‚Ñù</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{d}
  </annotation>
 </semantics>
</math>

, which contain 

<math display="inline" id="Point_set_registration:2">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:3">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 points respectively. The problem is to find a transformation to be applied to the moving "model" point set 

<math display="inline" id="Point_set_registration:4">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}
  </annotation>
 </semantics>
</math>

 such that the difference between 

<math display="inline" id="Point_set_registration:5">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}
  </annotation>
 </semantics>
</math>

 and the static "scene" set 

<math display="inline" id="Point_set_registration:6">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíÆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 is minimized. In other words, a mapping from 

<math display="inline" id="Point_set_registration:7">
 <semantics>
  <msup>
   <mi>‚Ñù</mi>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>‚Ñù</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{d}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Point_set_registration:8">
 <semantics>
  <msup>
   <mi>‚Ñù</mi>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>‚Ñù</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{d}
  </annotation>
 </semantics>
</math>

 is desired which yields the best alignment between the transformed "model" set and the "scene" set. The mapping may consist of a rigid or non-rigid transformation. The transformation model may be written as 

<math display="inline" id="Point_set_registration:9">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 where the transformed, registered model point set is:</p>

<p>It is useful to define an optimization parameter 

<math display="inline" id="Point_set_registration:10">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

:</p>

<p>such that it is clear that the optimizing algorithm adjusts 

<math display="inline" id="Point_set_registration:11">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

. Depending on the problem and number of dimensions, there may be more such parameters. The output of a point set registration algorithm is therefore the transformation parameter 

<math display="inline" id="Point_set_registration:12">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 of model 

<math display="inline" id="Point_set_registration:13">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 so that 

<math display="inline" id="Point_set_registration:14">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}
  </annotation>
 </semantics>
</math>

 is optimally aligned to 

<math display="inline" id="Point_set_registration:15">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíÆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

.</p>

<p>In convergence, it is desired for the distance between the two point sets to reach a global minimum. This is difficult without exhausting all possible transformations, so a local minimum suffices. The distance function between a transformed model point set 

<math display="inline" id="Point_set_registration:16">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>‚Ñ≥</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(\mathcal{M})
  </annotation>
 </semantics>
</math>

 and the scene point set 

<math display="inline" id="Point_set_registration:17">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíÆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 is given by some function 

<math display="inline" id="Point_set_registration:18">
 <semantics>
  <mo>dist</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>dist</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dist}
  </annotation>
 </semantics>
</math>

. A simple approach is to take the square of the <a href="Euclidean_distance" title="wikilink">Euclidean distance</a> for every pair of points:</p>

<p>(m - s)^2|<mtpl><eqref>3<eqref></eqref></eqref></mtpl>}}</p>

<p>Minimizing such a function in rigid registration is equivalent to solving a <a href="least_squares" title="wikilink">least squares</a> problem. However, this function is sensitive to outlier data and consequently algorithms based on this function tend to be less robust against noisy data. A more robust formulation of the cost function uses some <em>robust function</em> 

<math display="inline" id="Point_set_registration:19">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

:</p>

<p>(T(\mathcal{M}), \mathcal{S}) = \sum_{m \in T(\mathcal{M})} \sum_{s \in \mathcal{S}} g((m - s)^2)|<mtpl><eqref>4<eqref></eqref></eqref></mtpl>}}</p>

<p>Such a formulation is known as an <em><a class="uri" href="M-estimator" title="wikilink">M-estimator</a></em>. The robust function 

<math display="inline" id="Point_set_registration:20">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is chosen such that the local configuration of the point set is insensitive to distant points, hence making it robust against outliers and noise.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="rigid-registration">Rigid registration</h3>

<p>Given two point sets, rigid registration yields a <a href="rigid_transformation" title="wikilink">rigid transformation</a> which maps one point set to the other. A rigid transformation is defined as a transformation that does not change the distance between any two points. Typically such a transformation consists of <a href="translation_(geometry)" title="wikilink">translation</a> and <a class="uri" href="rotation" title="wikilink">rotation</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> In rare cases, the point set may also be mirrored.</p>
<h3 id="non-rigid-registration">Non-rigid registration</h3>

<p>Given two point sets, non-rigid registration yields a non-rigid transformation which maps one point set to the other. Non-rigid transformations include <a href="affine_transformations" title="wikilink">affine transformations</a> such as <a href="scaling_(geometry)" title="wikilink">scaling</a> and <a href="shear_mapping" title="wikilink">shear mapping</a>. However, in the context of point set registration, non-rigid registration typically involves nonlinear transformation. If the <a href="eigenmode" title="wikilink">eigenmodes of variation</a> of the point set are known, the nonlinear transformation may be parametrized by the eigenvalues.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> A nonlinear transformation may also be parametrized as a <a href="thin_plate_spline" title="wikilink">thin plate spline</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="point-set-registration-algorithms">Point set registration algorithms</h2>

<p>Some approaches to point set registration use algorithms that solve the more general <a href="matching_(graph_theory)" title="wikilink">graph matching</a> problem.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> However, the computational complexity of such methods tend to be high and they are limited to rigid registrations. Algorithms specific to the point set registration problem are described in the following sections.</p>
<h3 id="iterative-closest-point">Iterative closest point</h3>

<p>The <a href="iterative_closest_point" title="wikilink">iterative closest point</a> (ICP) algorithm was introduced by Besl and McKay.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The algorithm performs rigid registration in an iterative fashion by assuming that every point in 

<math display="inline" id="Point_set_registration:21">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}
  </annotation>
 </semantics>
</math>

 corresponds with <a href="nearest_neighbor_search" title="wikilink">the closest point to it</a> in 

<math display="inline" id="Point_set_registration:22">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíÆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

, and then finding the <a href="least_squares" title="wikilink">least squares</a> rigid transformation. As such, it works best if the initial pose of 

<math display="inline" id="Point_set_registration:23">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}
  </annotation>
 </semantics>
</math>

 is sufficiently close to 

<math display="inline" id="Point_set_registration:24">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíÆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

. In <a class="uri" href="pseudocode" title="wikilink">pseudocode</a>, the basic algorithm is implemented as follows:</p>

<p><code>¬†¬†¬†</code><strong><code>Algorithm</code> <code>ICP</code></strong>

<math display="inline" id="Point_set_registration:25">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
   <mo>,</mo>
   <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>‚Ñ≥</ci>
    <ci>ùíÆ</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{M},\mathcal{S})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Point_set_registration:26">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:27">
 <semantics>
  <msub>
   <mi>Œ∏</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œ∏</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}
  </annotation>
 </semantics>
</math>

</p>

<p><code>¬†¬†¬†¬†¬†¬†¬†while¬†not¬†registered:</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:28">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†</code>

<math display="inline" id="Point_set_registration:29">
 <semantics>
  <mi mathvariant="normal">‚àÖ</mi>
  <annotation-xml encoding="MathML-Content">
   <emptyset></emptyset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset
  </annotation>
 </semantics>
</math>

<br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†for¬†</code>

<math display="inline" id="Point_set_registration:30">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>i</mi>
   </msub>
   <mo>‚àà</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
     <mo>,</mo>
     <mi>Œ∏</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <ci>‚Ñ≥</ci>
      <ci>Œ∏</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}\in T(\mathcal{M},\theta)
  </annotation>
 </semantics>
</math>

<code>:</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:31">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>s</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>s</ci>
    </apply>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{s}_{j}
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†closest¬†point¬†in¬†</code>

<math display="inline" id="Point_set_registration:32">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíÆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

<code>¬†to¬†</code>

<math display="inline" id="Point_set_registration:33">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Point_set_registration:34">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:35">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 + 

<math display="inline" id="Point_set_registration:36">
 <semantics>
  <mrow>
   <mo stretchy="false">‚ü®</mo>
   <msub>
    <mi>m</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mover accent="true">
     <mi>s</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">‚ü©</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>s</ci>
     </apply>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle m_{i},\hat{s}_{j}\rangle
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:37">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 := <strong><a href="least_squares" title="wikilink">least squares</a></strong>

<math display="inline" id="Point_set_registration:38">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>X</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X)
  </annotation>
 </semantics>
</math>

</p>

<p><code>¬†¬†¬†¬†¬†¬†¬†return¬†</code>

<math display="inline" id="Point_set_registration:39">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

</p>

<p>Here, the function <code>'''least_squares'''</code> performs <a href="least_squares" title="wikilink">least squares</a> regression to minimize the distance in each of the 

<math display="inline" id="Point_set_registration:40">
 <semantics>
  <mrow>
   <mo stretchy="false">‚ü®</mo>
   <msub>
    <mi>m</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mover accent="true">
     <mi>s</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">‚ü©</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>s</ci>
     </apply>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle m_{i},\hat{s}_{j}\rangle
  </annotation>
 </semantics>
</math>

 pairs, i.e. minimizing the distance function in Equation ().</p>

<p>Because the <a href="loss_function" title="wikilink">cost function</a> of registration depends on finding the closest point in 

<math display="inline" id="Point_set_registration:41">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíÆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 to every point in 

<math display="inline" id="Point_set_registration:42">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}
  </annotation>
 </semantics>
</math>

, it can change as the algorithm is running. As such, it is difficult to prove that ICP will in fact converge exactly to the local optimum.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> In fact, empirically, ICP and EM-ICP do not converge to the local minimum of the cost function.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Nonetheless, because ICP is intuitive to understand and straightforward to implement, it remains the most commonly used point set registration algorithm.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Many variants of ICP have been proposed, affecting all phases of the algorithm from the selection and matching of points to the minimization strategy.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> For example, the <a href="expectation_maximization" title="wikilink">expectation maximization</a> algorithm is applied to the ICP algorithm to form the EM-ICP method, and the <a href="Levenberg-Marquardt_algorithm" title="wikilink">Levenberg-Marquardt algorithm</a> is applied to the ICP algorithm to form the LM-ICP method.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h3 id="robust-point-matching">Robust point matching</h3>

<p>Robust point matching (RPM) was introduced by Gold et al.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> The method performs registration using <a href="deterministic_annealing" title="wikilink">deterministic annealing</a> and soft assignment of correspondences between point sets. Whereas in ICP the correspondence generated by the nearest-neighbour heuristic is binary, RPM uses a <em>soft</em> correspondence where the correspondence between any two points can be anywhere from 0 to 1, although it ultimately converges to either 0 or 1. The correspondences found in RPM is always one-to-one, which is not always the case in ICP.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Let 

<math display="inline" id="Point_set_registration:43">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}
  </annotation>
 </semantics>
</math>

 be the 

<math display="inline" id="Point_set_registration:44">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

th point in 

<math display="inline" id="Point_set_registration:45">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:46">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{j}
  </annotation>
 </semantics>
</math>

 be the 

<math display="inline" id="Point_set_registration:47">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

th point in 

<math display="inline" id="Point_set_registration:48">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíÆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

. The <em>match matrix</em> 

<math display="inline" id="Point_set_registration:49">
 <semantics>
  <mi>Œº</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œº</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\mu}
  </annotation>
 </semantics>
</math>

 is defined as such:</p>

<p>The problem is then defined as: Given two point sets 

<math display="inline" id="Point_set_registration:50">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:51">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíÆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 find the <a href="Affine_transformation" title="wikilink">Affine transformation</a> 

<math display="inline" id="Point_set_registration:52">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and the match matrix 

<math display="inline" id="Point_set_registration:53">
 <semantics>
  <mi>Œº</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œº</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\mu}
  </annotation>
 </semantics>
</math>

 that best relates them.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> Knowing the optimal transformation makes it easy to determine the match matrix, and vice versa. However, the RPM algorithm determines both simultaneously. The transformation may be decomposed into a translation vector and a transformation matrix:</p>

<p>

<math display="block" id="Point_set_registration:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>ùêÄ</mi>
     <mi>m</mi>
    </mrow>
    <mo>+</mo>
    <mi>ùê≠</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>ùêÄ</ci>
      <ci>m</ci>
     </apply>
     <ci>ùê≠</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(m)=\mathbf{A}m+\mathbf{t}
  </annotation>
 </semantics>
</math>

</p>

<p>The matrix 

<math display="inline" id="Point_set_registration:55">
 <semantics>
  <mi>ùêÄ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêÄ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 in 2D is composed of four separate parameters 

<math display="inline" id="Point_set_registration:56">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>Œ∏</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>a</ci>
    <ci>Œ∏</ci>
    <ci>b</ci>
    <ci>c</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,\theta,b,c\}
  </annotation>
 </semantics>
</math>

, which are scale, rotation, and the vertical and horizontal shear components respectively. The cost function is then:</p>

<p>subject to 

<math display="inline" id="Point_set_registration:57">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àÄ</mo>
    <mrow>
     <mpadded width="+3.3pt">
      <mi>j</mi>
     </mpadded>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">‚àë</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>M</mi>
      </msubsup>
      <msub>
       <mi>Œº</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>j</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>M</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œº</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall j~{}\sum_{i=1}^{M}\mu_{ij}\leq 1
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Point_set_registration:58">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àÄ</mo>
    <mrow>
     <mpadded width="+3.3pt">
      <mi>i</mi>
     </mpadded>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">‚àë</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </msubsup>
      <msub>
       <mi>Œº</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>i</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œº</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i~{}\sum_{j=1}^{N}\mu_{ij}\leq 1
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Point_set_registration:59">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àÄ</mo>
    <mrow>
     <mi>i</mi>
     <mpadded width="+3.3pt">
      <mi>j</mi>
     </mpadded>
     <msub>
      <mi>Œº</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>‚àà</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œº</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall ij~{}\mu_{ij}\in\{0,1\}
  </annotation>
 </semantics>
</math>

. The 

<math display="inline" id="Point_set_registration:60">
 <semantics>
  <mi>Œ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 term biases the objective towards stronger correlation by decreasing the cost if the match matrix has more ones in it. The function 

<math display="inline" id="Point_set_registration:61">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ùêÄ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>ùêÄ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\mathbf{A})
  </annotation>
 </semantics>
</math>

 serves to regularize the Affine transformation by penalizing large values of the scale and shear components:</p>

<p>

<math display="block" id="Point_set_registration:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ùêÄ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>Œ∏</mi>
       <mo>,</mo>
       <mi>b</mi>
       <mo>,</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Œ≥</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <msup>
       <mi>b</mi>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <msup>
       <mi>c</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <times></times>
      <ci>ùêÄ</ci>
      <vector>
       <ci>a</ci>
       <ci>Œ∏</ci>
       <ci>b</ci>
       <ci>c</ci>
      </vector>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>Œ≥</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(\mathbf{A}(a,\theta,b,c))=\gamma(a^{2}+b^{2}+c^{2})
  </annotation>
 </semantics>
</math>

</p>

<p>for some regularization parameter 

<math display="inline" id="Point_set_registration:63">
 <semantics>
  <mi>Œ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

.</p>

<p>The RPM method optimizes the cost function using the <a class="uri" href="Softassign" title="wikilink">Softassign</a> algorithm. The 1D case will be derived here. Given a set of variables 

<math display="inline" id="Point_set_registration:64">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>Q</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>j</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{Q_{j}\}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Point_set_registration:65">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>j</mi>
   </msub>
   <mo>‚àà</mo>
   <msup>
    <mi>‚Ñù</mi>
    <mn>1</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>‚Ñù</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{j}\in\mathbb{R}^{1}
  </annotation>
 </semantics>
</math>

. A variable 

<math display="inline" id="Point_set_registration:66">
 <semantics>
  <msub>
   <mi>Œº</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œº</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{j}
  </annotation>
 </semantics>
</math>

 is associated with each 

<math display="inline" id="Point_set_registration:67">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{j}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Point_set_registration:68">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>J</mi>
    </msubsup>
    <msub>
     <mi>Œº</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>J</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œº</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j=1}^{J}\mu_{j}=1
  </annotation>
 </semantics>
</math>

. The goal is to find 

<math display="inline" id="Point_set_registration:69">
 <semantics>
  <mi>Œº</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œº</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\mu}
  </annotation>
 </semantics>
</math>

 that maximizes 

<math display="inline" id="Point_set_registration:70">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">‚àë</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>J</mi>
   </msubsup>
   <mrow>
    <msub>
     <mi>Œº</mi>
     <mi>j</mi>
    </msub>
    <msub>
     <mi>Q</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>J</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œº</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j=1}^{J}\mu_{j}Q_{j}
  </annotation>
 </semantics>
</math>

. This can be formulated as a continuous problem by introducing a control parameter 

<math display="inline" id="Point_set_registration:71">
 <semantics>
  <mrow>
   <mi>Œ≤</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>Œ≤</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta>0
  </annotation>
 </semantics>
</math>

. In the <a href="deterministic_annealing" title="wikilink">deterministic annealing</a> method, the control parameter 

<math display="inline" id="Point_set_registration:72">
 <semantics>
  <mi>Œ≤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 is slowly increased as the algorithm runs. Let 

<math display="inline" id="Point_set_registration:73">
 <semantics>
  <mi>Œº</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œº</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\mu}
  </annotation>
 </semantics>
</math>

 be:</p>

<p>= \frac{\exp{(\beta Q_{\hat{j}})}}{\sum_{j=1}^J \exp{(\beta Q_j)}} |<mtpl><eqref>rpm.3<eqref></eqref></eqref></mtpl>}}</p>

<p>this is known as the <a href="softmax_function" title="wikilink">softmax function</a>. As 

<math display="inline" id="Point_set_registration:74">
 <semantics>
  <mi>Œ≤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 increases, it approaches a binary value as desired in Equation (). The problem may now be generalized to the 2D case, where instead of maximizing 

<math display="inline" id="Point_set_registration:75">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">‚àë</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>J</mi>
   </msubsup>
   <mrow>
    <msub>
     <mi>Œº</mi>
     <mi>j</mi>
    </msub>
    <msub>
     <mi>Q</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>J</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œº</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j=1}^{J}\mu_{j}Q_{j}
  </annotation>
 </semantics>
</math>

, the following is maximized:</p>

<p>where</p>

<p>

<math display="block" id="Point_set_registration:76">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mrow>
        <mo fence="true">‚à•</mo>
        <mrow>
         <msub>
          <mi>s</mi>
          <mi>j</mi>
         </msub>
         <mo>-</mo>
         <mi>ùê≠</mi>
         <mo>-</mo>
         <mrow>
          <mi>ùêÄ</mi>
          <msub>
           <mi>m</mi>
           <mi>i</mi>
          </msub>
         </mrow>
        </mrow>
        <mo fence="true">‚à•</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>-</mo>
      <mi>Œ±</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mo>‚àÇ</mo>
      <mo>cost</mo>
     </mrow>
     <mrow>
      <mo>‚àÇ</mo>
      <msub>
       <mi>Œº</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>s</ci>
           <ci>j</ci>
          </apply>
          <ci>ùê≠</ci>
          <apply>
           <times></times>
           <ci>ùêÄ</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>m</ci>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>Œ±</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>cost</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Œº</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{ij}=-(\lVert s_{j}-\mathbf{t}-\mathbf{A}m_{i}\rVert^{2}-\alpha)=-\frac{%
\partial\operatorname{cost}}{\partial\mu_{ij}}
  </annotation>
 </semantics>
</math>

</p>

<p>This is straightforward, except that now the constraints on 

<math display="inline" id="Point_set_registration:77">
 <semantics>
  <mi>Œº</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œº</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 are <a href="doubly_stochastic_matrix" title="wikilink">doubly stochastic matrix</a> constraints

<math display="block" id="Point_set_registration:78">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àÄ</mo>
    <mrow>
     <mpadded width="+3.3pt">
      <mi>j</mi>
     </mpadded>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>M</mi>
      </munderover>
      <msub>
       <mi>Œº</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>j</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>M</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œº</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall j~{}\sum_{i=1}^{M}\mu_{ij}=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:79">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àÄ</mo>
    <mrow>
     <mpadded width="+3.3pt">
      <mi>i</mi>
     </mpadded>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">‚àë</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </msubsup>
      <msub>
       <mi>Œº</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>i</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œº</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i~{}\sum_{j=1}^{N}\mu_{ij}=1
  </annotation>
 </semantics>
</math>

. As such the denominator from Equation () cannot be expressed for the 2D case simply. To satisfy the constraints, it is possible to use a result due to Sinkhorn,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> which states that a doubly stochastic matrix is obtained from any square matrix with all positive entries by the iterative process of alternating row and column normalizations. Thus the algorithm is written as such:<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p><code>¬†¬†¬†</code><strong><code>Algorithm</code> <code>RPM2D</code></strong>

<math display="inline" id="Point_set_registration:80">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
   <mo>,</mo>
   <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>‚Ñ≥</ci>
    <ci>ùíÆ</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{M},\mathcal{S})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Point_set_registration:81">
 <semantics>
  <mi>ùê≠</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùê≠</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}
  </annotation>
 </semantics>
</math>

 := 0</p>

<p><code>¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:82">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>,</mo>
   <mi>Œ∏</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>Œ∏</ci>
    <ci>b</ci>
    <ci>c</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,\theta,b,c
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†0</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:83">
 <semantics>
  <mi>Œ≤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†</code>

<math display="inline" id="Point_set_registration:84">
 <semantics>
  <msub>
   <mi>Œ≤</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œ≤</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Point_set_registration:85">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>Œº</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>Œº</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mu}_{ij}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:86">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mi>œµ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <ci>œµ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p><code>¬†¬†¬†¬†¬†¬†¬†while¬†</code>

<math display="inline" id="Point_set_registration:87">
 <semantics>
  <mrow>
   <mi>Œ≤</mi>
   <mo><</mo>
   <msub>
    <mi>Œ≤</mi>
    <mi>f</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>Œ≤</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œ≤</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta<\beta_{f}
  </annotation>
 </semantics>
</math>

<code>:</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†while¬†</code>

<math display="inline" id="Point_set_registration:88">
 <semantics>
  <mi>Œº</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œº</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

<code>¬†has¬†not¬†converged:</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code><em><code>//</code> <code>update</code> <code>correspondence</code> <code>parameters</code> <code>by</code> <code>softassign</code></em><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:89">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{ij}
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†</code>

<math display="inline" id="Point_set_registration:90">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mfrac>
    <mrow>
     <mo>‚àÇ</mo>
     <mo>cost</mo>
    </mrow>
    <mrow>
     <mo>‚àÇ</mo>
     <msub>
      <mi>Œº</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>cost</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œº</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\frac{\partial\operatorname{cost}}{\partial\mu_{ij}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Point_set_registration:91">
 <semantics>
  <msubsup>
   <mi>Œº</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Œº</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{0}_{ij}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:92">
 <semantics>
  <mrow>
   <mi>exp</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>Œ≤</mi>
     <msub>
      <mi>Q</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exp></exp>
    <apply>
     <times></times>
     <ci>Œ≤</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp(\beta Q_{ij})
  </annotation>
 </semantics>
</math>

</p>

<p><code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code><em><code>//</code> <code>apply</code> <code>Sinkhorn's</code> <code>method</code></em><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†while¬†</code>

<math display="inline" id="Point_set_registration:93">
 <semantics>
  <mover accent="true">
   <mi>Œº</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>Œº</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mu}
  </annotation>
 </semantics>
</math>

<code>¬†has¬†not¬†converged:</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code><em><code>//</code> <code>update</code> 

<math display="inline" id="Point_set_registration:94">
 <semantics>
  <mover accent="true">
   <mi>Œº</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>Œº</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mu}
  </annotation>
 </semantics>
</math>

 <code>by</code> <code>normalizing</code> <code>across</code> <code>all</code> <code>rows:</code></em><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:95">
 <semantics>
  <msubsup>
   <mover accent="true">
    <mi>Œº</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>Œº</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mu}^{1}_{ij}
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†</code>

<math display="inline" id="Point_set_registration:96">
 <semantics>
  <mfrac>
   <msubsup>
    <mover accent="true">
     <mi>Œº</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <mn>0</mn>
   </msubsup>
   <mrow>
    <mstyle displaystyle="false">
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>M</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
    </mstyle>
    <msubsup>
     <mover accent="true">
      <mi>Œº</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mn>0</mn>
    </msubsup>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>Œº</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>M</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>Œº</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\hat{\mu}^{0}_{ij}}{\sum_{i=1}^{M+1}\hat{\mu}^{0}_{ij}}
  </annotation>
 </semantics>
</math>

<br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code><em><code>//</code> <code>update</code> 

<math display="inline" id="Point_set_registration:97">
 <semantics>
  <mover accent="true">
   <mi>Œº</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>Œº</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mu}
  </annotation>
 </semantics>
</math>

 <code>by</code> <code>normalizing</code> <code>across</code> <code>all</code> <code>columns:</code></em><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:98">
 <semantics>
  <msubsup>
   <mover accent="true">
    <mi>Œº</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>Œº</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mu}^{0}_{ij}
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†</code>

<math display="inline" id="Point_set_registration:99">
 <semantics>
  <mfrac>
   <msubsup>
    <mover accent="true">
     <mi>Œº</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <mn>1</mn>
   </msubsup>
   <mrow>
    <mstyle displaystyle="false">
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
    </mstyle>
    <msubsup>
     <mover accent="true">
      <mi>Œº</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mn>1</mn>
    </msubsup>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>Œº</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>Œº</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\hat{\mu}^{1}_{ij}}{\sum_{j=1}^{N+1}\hat{\mu}^{1}_{ij}}
  </annotation>
 </semantics>
</math>

<br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code><em><code>//</code> <code>update</code> <code>pose</code> <code>parameters</code> <code>by</code> <code>coordinate</code> <code>descent</code></em><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†update¬†</code>

<math display="inline" id="Point_set_registration:100">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

<code>¬†using¬†analytical¬†solution</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†update¬†</code>

<math display="inline" id="Point_set_registration:101">
 <semantics>
  <mi>ùê≠</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùê≠</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}
  </annotation>
 </semantics>
</math>

<code>¬†using¬†analytical¬†solution</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†update¬†</code>

<math display="inline" id="Point_set_registration:102">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
    <ci>c</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b,c
  </annotation>
 </semantics>
</math>

<code>¬†using¬†</code><a href="Newton's_method" title="wikilink"><code>Newton's</code> <code>method</code></a><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:103">
 <semantics>
  <mi>Œ≤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†</code>

<math display="inline" id="Point_set_registration:104">
 <semantics>
  <mrow>
   <msub>
    <mi>Œ≤</mi>
    <mi>r</mi>
   </msub>
   <mi>Œ≤</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œ≤</ci>
     <ci>r</ci>
    </apply>
    <ci>Œ≤</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{r}\beta
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Point_set_registration:105">
 <semantics>
  <mi>Œ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:106">
 <semantics>
  <mfrac>
   <mi>Œ≥</mi>
   <msub>
    <mi>Œ≤</mi>
    <mi>r</mi>
   </msub>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>Œ≥</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œ≤</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\gamma}{\beta_{r}}
  </annotation>
 </semantics>
</math>

</p>

<p><code>¬†¬†¬†¬†¬†¬†¬†return¬†</code>

<math display="inline" id="Point_set_registration:107">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo>,</mo>
   <mi>Œ∏</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
    <ci>c</ci>
    <ci>Œ∏</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b,c,\theta
  </annotation>
 </semantics>
</math>

<code>¬†and¬†</code>

<math display="inline" id="Point_set_registration:108">
 <semantics>
  <mi>ùê≠</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùê≠</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}
  </annotation>
 </semantics>
</math>

</p>

<p>where the deterministic annealing control parameter 

<math display="inline" id="Point_set_registration:109">
 <semantics>
  <mi>Œ≤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 is initially set to 

<math display="inline" id="Point_set_registration:110">
 <semantics>
  <msub>
   <mi>Œ≤</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œ≤</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{0}
  </annotation>
 </semantics>
</math>

 and increases by factor 

<math display="inline" id="Point_set_registration:111">
 <semantics>
  <msub>
   <mi>Œ≤</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œ≤</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{r}
  </annotation>
 </semantics>
</math>

 until it reaches the maximum value 

<math display="inline" id="Point_set_registration:112">
 <semantics>
  <msub>
   <mi>Œ≤</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œ≤</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{f}
  </annotation>
 </semantics>
</math>

. The summations in the normalization steps sum to 

<math display="inline" id="Point_set_registration:113">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M+1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:114">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N+1
  </annotation>
 </semantics>
</math>

 instead of just 

<math display="inline" id="Point_set_registration:115">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:116">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 because the constraints on 

<math display="inline" id="Point_set_registration:117">
 <semantics>
  <mi>Œº</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œº</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 are inequalities. As such the 

<math display="inline" id="Point_set_registration:118">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M+1
  </annotation>
 </semantics>
</math>

th and 

<math display="inline" id="Point_set_registration:119">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N+1
  </annotation>
 </semantics>
</math>

th elements are <a href="slack_variable" title="wikilink">slack variables</a>.</p>

<p>The algorithm can also be extended for point sets in 3D or higher dimensions. The constraints on the correspondence matrix 

<math display="inline" id="Point_set_registration:120">
 <semantics>
  <mi>Œº</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œº</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\mu}
  </annotation>
 </semantics>
</math>

 are the same in the 3D case as in the 2D case. Hence the structure of the algorithm remains unchanged, with the main difference being how the rotation and translation matrices are solved.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h4 id="thin-plate-spline-robust-point-matching">Thin plate spline robust point matching</h4>

<p> The thin plate spline robust point matching (TPS-RPM) algorithm by Chui and Rangarajan augments the RPM method to perform non-rigid registration by parametrizing the transformation as a <a href="thin_plate_spline" title="wikilink">thin plate spline</a>.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> However, because the thin plate spline parametrization only exists in three dimensions, the method cannot be extended to problems involving four or more dimensions.</p>
<h3 id="kernel-correlation">Kernel correlation</h3>

<p>The kernel correlation (KC) approach of point set registration was introduced by Tsin and Kanade.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> Compared with ICP, the KC algorithm is more robust against noisy data. Unlike ICP, where, for every model point, only the closest scene point is considered, here every scene point affects every model point.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> As such this is a <em>multiply-linked</em> registration algorithm. For some <a href="kernel_function" title="wikilink">kernel function</a> 

<math display="inline" id="Point_set_registration:121">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

, the kernel correlation 

<math display="inline" id="Point_set_registration:122">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   KC
  </annotation>
 </semantics>
</math>

 of two points 

<math display="inline" id="Point_set_registration:123">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i},x_{j}
  </annotation>
 </semantics>
</math>

 is defined thus:<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> <mtpl></mtpl></p>

<p>The <a href="Kernel_(statistics)#In_non-parametric_statistics" title="wikilink">kernel function</a> 

<math display="inline" id="Point_set_registration:124">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 chosen for point set registration is typically symmetric and non-negative kernel, similar to the ones used in the <a href="Parzen_window" title="wikilink">Parzen window</a> density estimation. The <a href="Gaussian_kernel" title="wikilink">Gaussian kernel</a> typically used for its simplicity, although other ones like the <a href="Epanechnikov_kernel" title="wikilink">Epanechnikov kernel</a> and the tricube kernel may be substituted.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> The kernel correlation of an entire point set 

<math display="inline" id="Point_set_registration:125">
 <semantics>
  <mi>œá</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œá</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{\chi}
  </annotation>
 </semantics>
</math>

 is defined as the sum of the kernel correlations of every point in the set to every other point in the set:<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>

<p>The KC of a point set is proportional, within a constant factor, to the logarithm of the <a href="entropy_(information_theory)" title="wikilink">information entropy</a>. Observe that the KC is a measure of a "compactness" of the point set‚Äîtrivially, if all points in the point set were at the same location, the KC would evaluate to zero. The <a href="loss_function" title="wikilink">cost function</a> of the point set registration algorithm for some transformation parameter 

<math display="inline" id="Point_set_registration:126">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is defined thus:</p>

<p>\sum_{s \in \mathcal{S}} KC(s, T(m, \theta))|<mtpl><eqref>kc.3<eqref></eqref></eqref></mtpl>}}</p>

<p>Some algebraic manipulation yields:</p>

<p>The expression is simplified by observing that 

<math display="inline" id="Point_set_registration:127">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>C</ci>
    <ci>ùíÆ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   KC(\mathcal{S})
  </annotation>
 </semantics>
</math>

 is independent of 

<math display="inline" id="Point_set_registration:128">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

. Furthermore, assuming rigid registration, 

<math display="inline" id="Point_set_registration:129">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
      <mo>,</mo>
      <mi>Œ∏</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <ci>‚Ñ≥</ci>
      <ci>Œ∏</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   KC(T(\mathcal{M},\theta))
  </annotation>
 </semantics>
</math>

 is invariant when 

<math display="inline" id="Point_set_registration:130">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is changed because the Euclidean distance between every pair of points stays the same under <a href="rigid_transformation" title="wikilink">rigid transformation</a>. So the above equation may be rewritten as:</p>

<p>The <a href="Kernel_density_estimation" title="wikilink">kernel density estimates</a> are defined as:</p>

<p>

<math display="block" id="Point_set_registration:131">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>Œ∏</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>m</mi>
       <mo>‚àà</mo>
       <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mrow>
        <mi>T</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>m</mi>
         <mo>,</mo>
         <mi>Œ∏</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>‚Ñ≥</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>Œ∏</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>m</ci>
        <ci>‚Ñ≥</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>K</ci>
       <interval closure="open">
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>T</ci>
         <interval closure="open">
          <ci>m</ci>
          <ci>Œ∏</ci>
         </interval>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\mathcal{M}}(x,\theta)=\frac{1}{N}\sum_{m\in\mathcal{M}}K(x,T(m,\theta))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Point_set_registration:132">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>s</mi>
       <mo>‚àà</mo>
       <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>ùíÆ</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>s</ci>
        <ci>ùíÆ</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>K</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>s</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\mathcal{S}}(x)=\frac{1}{N}\sum_{s\in\mathcal{S}}K(x,s)
  </annotation>
 </semantics>
</math>

</p>

<p>The cost function can then be shown to be the correlation of the two kernel density estimates:</p>

<p>\cdot P_{\mathcal{S}} ~ dx|<mtpl><eqref>kc.6<eqref></eqref></eqref></mtpl>}}</p>

<p>Having established the <a href="loss_function" title="wikilink">cost function</a>, the algorithm simply uses <a href="gradient_descent" title="wikilink">gradient descent</a> to find the optimal transformation. It is computationally expensive to compute the cost function from scratch on every iteration, so a discrete version of the cost function Equation () is used. The kernel density estimates 

<math display="inline" id="Point_set_registration:133">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>P</mi>
    <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>‚Ñ≥</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>ùíÆ</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\mathcal{M}},P_{\mathcal{S}}
  </annotation>
 </semantics>
</math>

 can be evaluated at grid points and stored in a <a href="lookup_table" title="wikilink">lookup table</a>. Unlike the ICP and related methods, it is not necessary to fund the nearest neighbour, which allows the KC algorithm to be comparatively simple in implementation.</p>

<p>Compared to ICP and EM-ICP for noisy 2D and 3D point sets, the KC algorithm is less sensitive to noise and results in correct registration more often.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<h4 id="gaussian-mixture-model">Gaussian mixture model</h4>

<p>The kernel density estimates are sums of Gaussians and may therefore be represented as <a href="Gaussian_mixture_model" title="wikilink">Gaussian mixture models</a> (GMM).<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> Jian and Vemuri use the GMM version of the KC registration algorithm to perform non-rigid registration parametrized by <a href="thin_plate_spline" title="wikilink">thin plate splines</a>.</p>
<h3 id="coherent-point-drift">Coherent point drift</h3>

<p>   Coherent point drift (CPD) was introduced by Myronenko and Song.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> The algorithm takes a probabilistic approach to aligning point sets, similar to the GMM KC method. Unlike earlier approaches to non-rigid registration which assume a <a href="thin_plate_spline" title="wikilink">thin plate spline</a> transformation model, CPD is agnostic with regard to the transformation model used. The point set 

<math display="inline" id="Point_set_registration:134">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}
  </annotation>
 </semantics>
</math>

 represents the <a href="Gaussian_mixture_model" title="wikilink">Gaussian mixture model</a> (GMM) centroids. When the two point sets are optimally aligned, the correspondence is the maximum of the GMM <a href="posterior_probability" title="wikilink">posterior probability</a> for a given data point. To preserve the topological structure of the point sets, the GMM centroids are forced to move coherently as a group. The <a href="expectation_maximization" title="wikilink">expectation maximization</a> algorithm is used to optimize the cost function.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>

<p>Let there be 

<math display="inline" id="Point_set_registration:135">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 points in 

<math display="inline" id="Point_set_registration:136">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:137">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 points in 

<math display="inline" id="Point_set_registration:138">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíÆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

. The GMM <a href="probability_density_function" title="wikilink">probability density function</a> for a point 

<math display="inline" id="Point_set_registration:139">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is:</p>

<p>where, in 

<math display="inline" id="Point_set_registration:140">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 dimensions, 

<math display="inline" id="Point_set_registration:141">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">|</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(s|i)
  </annotation>
 </semantics>
</math>

 is the <a href="Gaussian_distribution" title="wikilink">Gaussian distribution</a> centered on point 

<math display="inline" id="Point_set_registration:142">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>i</mi>
   </msub>
   <mo>‚àà</mo>
   <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>i</ci>
    </apply>
    <ci>‚Ñ≥</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}\in\mathcal{M}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Point_set_registration:143">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">|</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>œÄ</mi>
       <msup>
        <mi>œÉ</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>D</mi>
      <mo>/</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mfrac>
   <mi>exp</mi>
   <mrow>
    <mo>(</mo>
    <mo>-</mo>
    <mfrac>
     <msup>
      <mrow>
       <mo fence="true">‚à•</mo>
       <mrow>
        <mi>s</mi>
        <mo>-</mo>
        <msub>
         <mi>m</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo fence="true">‚à•</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>œÉ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>œÄ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>œÉ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">D</csymbol>
       <divide></divide>
       <cn type="integer">2</cn>
       <ci>normal-)</ci>
      </cerror>
     </apply>
    </apply>
    <exp></exp>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <ci>s</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>œÉ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(s|i)=\frac{1}{(2\pi\sigma^{2})^{D/2)}}\exp{\left(-\frac{\lVert s-m_{i}\rVert%
^{2}}{2\sigma^{2}}\right)}
  </annotation>
 </semantics>
</math>

</p>

<p>The membership probabilities 

<math display="inline" id="Point_set_registration:144">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>M</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(i)=\frac{1}{M}
  </annotation>
 </semantics>
</math>

 is equal for all GMM components. The weight of the uniform distribution is denoted as 

<math display="inline" id="Point_set_registration:145">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>‚àà</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>w</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in[0,1]
  </annotation>
 </semantics>
</math>

. The mixture model is then:</p>

<p>The GMM centroids are re-parametrized by a set of parameters 

<math display="inline" id="Point_set_registration:146">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 estimated by maximizing the likelihood. This is equivalent to minimizing the negative <a href="Likelihood_function#Log-likelihood" title="wikilink">log-likelihood function</a>:</p>

<p>where it is assumed that the data is <a href="independent_and_identically_distributed" title="wikilink">independent and identically distributed</a>. The correspondence probability between two points 

<math display="inline" id="Point_set_registration:147">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:148">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{j}
  </annotation>
 </semantics>
</math>

 is defined as the <a href="posterior_probability" title="wikilink">posterior probability</a> of the GMM centroid given the data point:</p>

<p>

<math display="block" id="Point_set_registration:149">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>s</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>s</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">|</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>s</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">i</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-|</ci>
       <csymbol cd="unknown">i</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(i|s_{j})=\frac{P(i)p(s_{j}|i)}{p(s_{j})}
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="expectation_maximization" title="wikilink">expectation maximization</a> (EM) algorithm is used to find 

<math display="inline" id="Point_set_registration:150">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:151">
 <semantics>
  <msup>
   <mi>œÉ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>œÉ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>

. The EM algorithm consists of two steps. First, in the E-step or <em>estimation</em> step, it guesses the values of parameters ("old" parameter values) and then uses <a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a> to compute the posterior probability distributions 

<math display="inline" id="Point_set_registration:152">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mtext>old</mtext>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <mtext>old</mtext>
    </apply>
    <interval closure="open">
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>j</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\text{old}}(i,s_{j})
  </annotation>
 </semantics>
</math>

 of mixture components. Second, in the M-step or <em>maximization</em> step, the "new" parameter values are then found by minimizing the expectation of the complete negative log-likelihood function, i.e. the cost function:</p>

<p>(i|s_j) \log(P^{\text{new}}(i) p^{\text{new}}(s_j|i)) |<mtpl><eqref>cpd.4<eqref></eqref></eqref></mtpl>}}</p>

<p>Ignoring constants independent of 

<math display="inline" id="Point_set_registration:153">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:154">
 <semantics>
  <mi>œÉ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œÉ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, Equation () can be expressed thus:</p>

<p>(i|s_j) \lVert s_j - T(m_i,\theta) \rVert^2</p>

<p><code>¬†¬†¬†+¬†\frac{N_\mathbf{P}D}{2}\log{\sigma^2}</code></p>

<p>|<mtpl><eqref>cpd.5<eqref></eqref></eqref></mtpl>}}</p>

<p>where</p>

<p>

<math display="block" id="Point_set_registration:155">
 <semantics>
  <mrow>
   <msub>
    <mi>N</mi>
    <mi>ùêè</mi>
   </msub>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi>M</mi>
   </munderover>
   <msup>
    <mi>P</mi>
    <mtext>old</mtext>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>s</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>‚â§</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <ci>ùêè</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <mtext>old</mtext>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">N</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{\mathbf{P}}=\sum_{j=0}^{N}\sum_{i=0}^{M}P^{\text{old}}(i|s_{j})\leq N
  </annotation>
 </semantics>
</math>

</p>

<p>with 

<math display="inline" id="Point_set_registration:156">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <msub>
    <mi>N</mi>
    <mi>ùêè</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <ci>ùêè</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=N_{\mathbf{P}}
  </annotation>
 </semantics>
</math>

 only if 

<math display="inline" id="Point_set_registration:157">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=0
  </annotation>
 </semantics>
</math>

. The posterior probabilities of GMM components computed using previous parameter values 

<math display="inline" id="Point_set_registration:158">
 <semantics>
  <msup>
   <mi>P</mi>
   <mtext>old</mtext>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <mtext>old</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\text{old}}
  </annotation>
 </semantics>
</math>

 is:</p>

<p>(i|s_j) =</p>

<p><code>¬†¬†¬†\frac</code><br/>
<code>¬†¬†¬†{\exp</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†\left(</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†-\frac{1}{2\sigma^{\text{old}2}}¬†\lVert¬†s_j¬†-¬†T(m_i,¬†\theta^{\text{old}})\rVert^2¬†</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†\right)¬†}</code><br/>
<code>¬†¬†¬†{\sum_{k=1}^{M}¬†\exp</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†\left(</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†-\frac{1}{2\sigma^{\text{old}2}}¬†\lVert¬†s_j¬†-¬†T(m_k,¬†\theta^{\text{old}})\rVert^2¬†</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†\right)¬†+¬†(2\pi¬†\sigma^2)^\frac{D}{2}¬†\frac{w}{1-w}¬†\frac{M}{N}}</code></p>

<p>|<mtpl><eqref>cpd.6<eqref></eqref></eqref></mtpl>}}</p>

<p>Minimizing the cost function in Equation () necessarily decreases the negative log-likelihood function 

<math display="inline" id="Point_set_registration:159">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 in Equation () unless it is already at a local minimum.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> Thus, the algorithm can be expressed using the following pseudocode, where the point sets 

<math display="inline" id="Point_set_registration:160">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:161">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíÆ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 are represented as 

<math display="inline" id="Point_set_registration:162">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>√ó</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\times D
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:163">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>√ó</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times D
  </annotation>
 </semantics>
</math>

 matrices 

<math display="inline" id="Point_set_registration:164">
 <semantics>
  <mi>ùêå</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêå</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Point_set_registration:165">
 <semantics>
  <mi>ùêí</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêí</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}
  </annotation>
 </semantics>
</math>

 respectively:<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>

<p><code>¬†¬†¬†</code><strong><code>Algorithm</code> <code>CPD</code></strong>

<math display="inline" id="Point_set_registration:166">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi class="ltx_font_mathcaligraphic">‚Ñ≥</mi>
   <mo>,</mo>
   <mi class="ltx_font_mathcaligraphic">ùíÆ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>‚Ñ≥</ci>
    <ci>ùíÆ</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{M},\mathcal{S})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Point_set_registration:167">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:168">
 <semantics>
  <msub>
   <mi>Œ∏</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œ∏</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}
  </annotation>
 </semantics>
</math>

</p>

<p><code>¬†¬†¬†¬†¬†¬†¬†initialize¬†</code>

<math display="inline" id="Point_set_registration:169">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>‚â§</mo>
   <mi>w</mi>
   <mo>‚â§</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>w</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq w\leq 1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Point_set_registration:170">
 <semantics>
  <msup>
   <mi>œÉ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>œÉ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:171">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>D</mi>
     <mi>N</mi>
     <mi>M</mi>
    </mrow>
   </mfrac>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </msubsup>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>M</mi>
     </msubsup>
     <msup>
      <mrow>
       <mo fence="true">‚à•</mo>
       <mrow>
        <msub>
         <mi>s</mi>
         <mi>j</mi>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>m</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo fence="true">‚à•</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>N</ci>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{DNM}\sum_{j=1}^{N}\sum_{i=1}^{M}\lVert s_{j}-m_{i}\rVert^{2}
  </annotation>
 </semantics>
</math>

</p>

<p><code>¬†¬†¬†¬†¬†¬†¬†while¬†not¬†registered:</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code><em><code>//</code> <code>E-step,</code> <code>compute</code> 

<math display="inline" id="Point_set_registration:172">
 <semantics>
  <mi>ùêè</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêè</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{P}
  </annotation>
 </semantics>
</math>

</em><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†for¬†</code>

<math display="inline" id="Point_set_registration:173">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>‚àà</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>M</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <interval closure="closed">
     <cn type="integer">1</cn>
     <ci>M</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in[1,M]
  </annotation>
 </semantics>
</math>

<code>¬†and¬†</code>

<math display="inline" id="Point_set_registration:174">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>‚àà</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>j</ci>
    <interval closure="closed">
     <cn type="integer">1</cn>
     <ci>N</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\in[1,N]
  </annotation>
 </semantics>
</math>

<code>:</code><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:175">
 <semantics>
  <msub>
   <mi>p</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{ij}
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†</code>

<math display="inline" id="Point_set_registration:176">
 <semantics>
  <mfrac>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mn>2</mn>
         <msup>
          <mi>œÉ</mi>
          <mn>2</mn>
         </msup>
        </mrow>
       </mfrac>
       <msup>
        <mrow>
         <mo fence="true">‚à•</mo>
         <mrow>
          <msub>
           <mi>s</mi>
           <mi>j</mi>
          </msub>
          <mo>-</mo>
          <mrow>
           <mi>T</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>m</mi>
             <mi>i</mi>
            </msub>
            <mo>,</mo>
            <mi>Œ∏</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo fence="true">‚à•</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mstyle displaystyle="false">
      <msubsup>
       <mo largeop="true" symmetric="true">‚àë</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>M</mi>
      </msubsup>
     </mstyle>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mfrac>
          <mn>1</mn>
          <mrow>
           <mn>2</mn>
           <msup>
            <mi>œÉ</mi>
            <mn>2</mn>
           </msup>
          </mrow>
         </mfrac>
         <msup>
          <mrow>
           <mo fence="true">‚à•</mo>
           <mrow>
            <msub>
             <mi>s</mi>
             <mi>j</mi>
            </msub>
            <mo>-</mo>
            <mrow>
             <mi>T</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <msub>
               <mi>m</mi>
               <mi>k</mi>
              </msub>
              <mo>,</mo>
              <mi>Œ∏</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
           <mo fence="true">‚à•</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>œÄ</mi>
        <msup>
         <mi>œÉ</mi>
         <mn>2</mn>
        </msup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mi>D</mi>
       <mn>2</mn>
      </mfrac>
     </msup>
     <mfrac>
      <mi>w</mi>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>w</mi>
      </mrow>
     </mfrac>
     <mfrac>
      <mi>M</mi>
      <mi>N</mi>
     </mfrac>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>œÉ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>s</ci>
           <ci>j</ci>
          </apply>
          <apply>
           <times></times>
           <ci>T</ci>
           <interval closure="open">
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>m</ci>
             <ci>i</ci>
            </apply>
            <ci>Œ∏</ci>
           </interval>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <exp></exp>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>œÉ</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="latexml">norm</csymbol>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>s</ci>
             <ci>j</ci>
            </apply>
            <apply>
             <times></times>
             <ci>T</ci>
             <interval closure="open">
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>m</ci>
               <ci>k</ci>
              </apply>
              <ci>Œ∏</ci>
             </interval>
            </apply>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>œÄ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>œÉ</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <ci>D</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>w</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>w</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>M</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\exp\left(-\frac{1}{2\sigma^{2}}\lVert s_{j}-T(m_{i},\theta)\rVert^{2}%
\right)}{\sum_{k=1}^{M}\exp\left(-\frac{1}{2\sigma^{2}}\lVert s_{j}-T(m_{k},%
\theta)\rVert^{2}\right)+(2\pi\sigma^{2})^{\frac{D}{2}}\frac{w}{1-w}\frac{M}{N}}
  </annotation>
 </semantics>
</math>

<br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code><em><code>//</code> <code>M-step,</code> <code>solve</code> <code>for</code> <code>optimal</code> <code>transformation</code></em><br/>
<code>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:177">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>Œ∏</mi>
   <mo>,</mo>
   <msup>
    <mi>œÉ</mi>
    <mn>2</mn>
   </msup>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>Œ∏</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>œÉ</ci>
     <cn type="integer">2</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\theta,\sigma^{2}\}
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†</code><strong><code>solve</code></strong>

<math display="inline" id="Point_set_registration:178">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>ùêí</mi>
   <mo>,</mo>
   <mi>ùêå</mi>
   <mo>,</mo>
   <mi>ùêè</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>ùêí</ci>
    <ci>ùêå</ci>
    <ci>ùêè</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{S},\mathbf{M},\mathbf{P})
  </annotation>
 </semantics>
</math>

<br/>
<code>¬†¬†¬†¬†¬†¬†¬†return¬†</code>

<math display="inline" id="Point_set_registration:179">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

</p>

<p>where the vector 

<math display="inline" id="Point_set_registration:180">
 <semantics>
  <mn>ùüè</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{1}
  </annotation>
 </semantics>
</math>

 is a column vector of ones. The <code>'''solve'''</code> function differs by the type of registration performed. For example, in rigid registration, the output is a scale 

<math display="inline" id="Point_set_registration:181">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, a rotation matrix 

<math display="inline" id="Point_set_registration:182">
 <semantics>
  <mi>ùêë</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêë</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

, and a translation vector 

<math display="inline" id="Point_set_registration:183">
 <semantics>
  <mi>ùê≠</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùê≠</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}
  </annotation>
 </semantics>
</math>

. The parameter 

<math display="inline" id="Point_set_registration:184">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 can be written as a tuple of these:</p>

<p>

<math display="block" id="Point_set_registration:185">
 <semantics>
  <mrow>
   <mi>Œ∏</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>ùêë</mi>
    <mo>,</mo>
    <mi>ùê≠</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ∏</ci>
    <set>
     <ci>a</ci>
     <ci>ùêë</ci>
     <ci>ùê≠</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta=\{a,\mathbf{R},\mathbf{t}\}
  </annotation>
 </semantics>
</math>

</p>

<p>which is initialized to one, the <a href="identity_matrix" title="wikilink">identity matrix</a>, and a column vector of zeroes:</p>

<p>

<math display="block" id="Point_set_registration:186">
 <semantics>
  <mrow>
   <msub>
    <mi>Œ∏</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>ùêà</mi>
    <mo>,</mo>
    <mn>ùüé</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œ∏</ci>
     <cn type="integer">0</cn>
    </apply>
    <set>
     <cn type="integer">1</cn>
     <ci>ùêà</ci>
     <cn type="integer">0</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}=\{1,\mathbf{I},\mathbf{0}\}
  </annotation>
 </semantics>
</math>

</p>

<p>The aligned point set is:</p>

<p>

<math display="block" id="Point_set_registration:187">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùêå</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <msup>
      <mi>ùêåùêë</mi>
      <mi>T</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>ùüè</mn>
     <msup>
      <mi>ùê≠</mi>
      <mi>T</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>ùêå</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ùêåùêë</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ùê≠</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(\mathbf{M})=a\mathbf{M}\mathbf{R}^{T}+\mathbf{1}\mathbf{t}^{T}
  </annotation>
 </semantics>
</math>

</p>

<p>The <code>'''solve_rigid'''</code> function for rigid registration can then be written as follows, with derivation of the algebra explained in Myronenko's 2010 paper.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>

<p><code>¬†¬†¬†</code><strong><code>solve_rigid</code></strong>

<math display="inline" id="Point_set_registration:188">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>ùêí</mi>
   <mo>,</mo>
   <mi>ùêå</mi>
   <mo>,</mo>
   <mi>ùêè</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>ùêí</ci>
    <ci>ùêå</ci>
    <ci>ùêè</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{S},\mathbf{M},\mathbf{P})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Point_set_registration:189">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>ùêè</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>ùêè</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{\mathbf{P}}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:190">
 <semantics>
  <mrow>
   <msup>
    <mn>ùüè</mn>
    <mi>T</mi>
   </msup>
   <mi>ùêèùüè</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">1</cn>
     <ci>T</ci>
    </apply>
    <ci>ùêèùüè</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{1}^{T}\mathbf{P}\mathbf{1}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:191">
 <semantics>
  <msub>
   <mi>Œº</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œº</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{s}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:192">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <msub>
     <mi>N</mi>
     <mi>ùêè</mi>
    </msub>
   </mfrac>
   <msup>
    <mi>ùêí</mi>
    <mi>T</mi>
   </msup>
   <msup>
    <mi>ùêè</mi>
    <mi>T</mi>
   </msup>
   <mn>ùüè</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>ùêè</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ùêí</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ùêè</ci>
     <ci>T</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{N_{\mathbf{P}}}\mathbf{S}^{T}\mathbf{P}^{T}\mathbf{1}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:193">
 <semantics>
  <msub>
   <mi>Œº</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œº</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{m}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:194">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <msub>
     <mi>N</mi>
     <mi>ùêè</mi>
    </msub>
   </mfrac>
   <msup>
    <mi>ùêå</mi>
    <mi>T</mi>
   </msup>
   <mi>ùêèùüè</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>ùêè</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ùêå</ci>
     <ci>T</ci>
    </apply>
    <ci>ùêèùüè</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{N_{\mathbf{P}}}\mathbf{M}^{T}\mathbf{P}\mathbf{1}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:195">
 <semantics>
  <mover accent="true">
   <mi>ùêí</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>ùêí</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{S}}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:196">
 <semantics>
  <mrow>
   <mi>ùêí</mi>
   <mo>-</mo>
   <mrow>
    <mn>ùüè</mn>
    <msubsup>
     <mi>Œº</mi>
     <mi>s</mi>
     <mi>T</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>ùêí</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œº</ci>
       <ci>s</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}-\mathbf{1}\mu_{s}^{T}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:197">
 <semantics>
  <mover accent="true">
   <mi>ùêå</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>ùêå</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{M}}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:198">
 <semantics>
  <mrow>
   <mi>ùêå</mi>
   <mo>-</mo>
   <mrow>
    <mn>ùüè</mn>
    <msubsup>
     <mi>Œº</mi>
     <mi>m</mi>
     <mi>T</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>ùêå</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œº</ci>
       <ci>m</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}-\mathbf{1}\mu_{m}^{T}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:199">
 <semantics>
  <mi>ùêÄ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêÄ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:200">
 <semantics>
  <mrow>
   <mover accent="true">
    <msup>
     <mi>ùêí</mi>
     <mi>T</mi>
    </msup>
    <mo stretchy="false">^</mo>
   </mover>
   <msup>
    <mi>ùêè</mi>
    <mi>T</mi>
   </msup>
   <mover accent="true">
    <mi>ùêå</mi>
    <mo stretchy="false">^</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùêí</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ùêè</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <ci>normal-^</ci>
     <ci>ùêå</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{S}^{T}}\mathbf{P}^{T}\hat{\mathbf{M}}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:201">
 <semantics>
  <mrow>
   <mi>ùêî</mi>
   <mo>,</mo>
   <mi>ùêï</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>ùêî</ci>
    <ci>ùêï</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U},\mathbf{V}
  </annotation>
 </semantics>
</math>

 := <strong>svd</strong>

<math display="inline" id="Point_set_registration:202">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>ùêÄ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêÄ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{A})
  </annotation>
 </semantics>
</math>

 <em>// the <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> of 

<math display="inline" id="Point_set_registration:203">
 <semantics>
  <mrow>
   <mi>ùêÄ</mi>
   <mo>=</mo>
   <mrow>
    <mi>ùêî</mi>
    <mi mathvariant="normal">Œ£</mi>
    <msup>
     <mi>ùêï</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ùêÄ</ci>
    <apply>
     <times></times>
     <ci>ùêî</ci>
     <ci>normal-Œ£</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùêï</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}=\mathbf{U}\Sigma\mathbf{V}^{T}
  </annotation>
 </semantics>
</math>

</em></p>

<p><code>¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:204">
 <semantics>
  <mi>ùêÇ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêÇ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†</code>

<math display="inline" id="Point_set_registration:205">
 <semantics>
  <mrow>
   <mo>diag</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mrow>
     <mo>det</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>ùêîùêï</mi>
       <mi>T</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>diag</ci>
    <cn type="integer">1</cn>
    <ci>normal-‚Ä¶</ci>
    <cn type="integer">1</cn>
    <apply>
     <determinant></determinant>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùêîùêï</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{diag}(1,...,1,\det(\mathbf{UV}^{T}))
  </annotation>
 </semantics>
</math>

<code>¬†</code><em><code>//</code> 

<math display="inline" id="Point_set_registration:206">
 <semantics>
  <mrow>
   <mo>diag</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Œæ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>diag</ci>
    <ci>Œæ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{diag}(\xi)
  </annotation>
 </semantics>
</math>

 <code>is</code> <code>the</code> <a href="diagonal_matrix" title="wikilink"><code>diagonal</code> <code>matrix</code></a> <code>formed</code> <code>from</code> <code>vector</code> 

<math display="inline" id="Point_set_registration:207">
 <semantics>
  <mi>Œæ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œæ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

</em><br/>
<code>¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:208">
 <semantics>
  <mi>ùêë</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêë</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†</code>

<math display="inline" id="Point_set_registration:209">
 <semantics>
  <msup>
   <mi>ùêîùêÇùêï</mi>
   <mi>T</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ùêîùêÇùêï</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{UCV}^{T}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Point_set_registration:210">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:211">
 <semantics>
  <mfrac>
   <mrow>
    <mo>tr</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>ùêÄ</mi>
       <mi>T</mi>
      </msup>
      <mi>ùêë</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mo>tr</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mover accent="true">
        <mi>ùêå</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>ùêì</mi>
      </msup>
      <mrow>
       <mrow>
        <mo>diag</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ùêèùüè</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mover accent="true">
        <mi>ùêå</mi>
        <mo stretchy="false">^</mo>
       </mover>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <ci>tr</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ùêÄ</ci>
       <ci>T</ci>
      </apply>
      <ci>ùêë</ci>
     </apply>
    </apply>
    <apply>
     <ci>tr</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>ùêå</ci>
       </apply>
       <ci>ùêì</ci>
      </apply>
      <apply>
       <apply>
        <ci>diag</ci>
        <ci>ùêèùüè</ci>
       </apply>
       <apply>
        <ci>normal-^</ci>
        <ci>ùêå</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\operatorname{tr}(\mathbf{A}^{T}\mathbf{R})}{\operatorname{tr}(\mathbf{%
\hat{\mathbf{M}}^{T}\operatorname{diag}(\mathbf{P}\mathbf{1})\hat{\mathbf{M}}})}
  </annotation>
 </semantics>
</math>

 <em>// 

<math display="inline" id="Point_set_registration:212">
 <semantics>
  <mo>tr</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>tr</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{tr}
  </annotation>
 </semantics>
</math>

 is the <a href="trace_(linear_algebra)" title="wikilink">trace</a> of a matrix</em></p>

<p><code>¬†¬†¬†¬†¬†¬†¬†</code>

<math display="inline" id="Point_set_registration:213">
 <semantics>
  <mi>ùê≠</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùê≠</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}
  </annotation>
 </semantics>
</math>

<code>¬†:=¬†</code>

<math display="inline" id="Point_set_registration:214">
 <semantics>
  <mrow>
   <msub>
    <mi>Œº</mi>
    <mi>s</mi>
   </msub>
   <mo>-</mo>
   <mrow>
    <mi>a</mi>
    <mi>ùêë</mi>
    <msub>
     <mi>Œº</mi>
     <mi>m</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œº</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>ùêë</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œº</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{s}-a\mathbf{R}\mu_{m}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Point_set_registration:215">
 <semantics>
  <msup>
   <mi>œÉ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>œÉ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:216">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msub>
       <mi>N</mi>
       <mi>ùêè</mi>
      </msub>
      <mi>D</mi>
     </mrow>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>tr</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mover accent="true">
          <mi>ùêí</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mi>ùêì</mi>
        </msup>
        <mrow>
         <mrow>
          <mo>diag</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msup>
             <mi>ùêè</mi>
             <mi>ùêì</mi>
            </msup>
            <mn>ùüè</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mover accent="true">
          <mi>ùêí</mi>
          <mo stretchy="false">^</mo>
         </mover>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo>tr</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>ùêÄ</mi>
        <mi>T</mi>
       </msup>
       <mi>ùêë</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <ci>ùêè</ci>
       </apply>
       <ci>D</ci>
      </apply>
     </apply>
     <apply>
      <ci>tr</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>ùêí</ci>
        </apply>
        <ci>ùêì</ci>
       </apply>
       <apply>
        <apply>
         <ci>diag</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ùêè</ci>
           <ci>ùêì</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <ci>normal-^</ci>
         <ci>ùêí</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <ci>tr</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ùêÄ</ci>
        <ci>T</ci>
       </apply>
       <ci>ùêë</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{N_{\mathbf{P}}D}(\operatorname{tr}(\mathbf{\hat{\mathbf{S}}^{T}%
\operatorname{diag}(\mathbf{P}^{T}\mathbf{1})\hat{\mathbf{S}}}))-a%
\operatorname{tr}(\mathbf{A}^{T}\mathbf{R})
  </annotation>
 </semantics>
</math>

</p>

<p><code>¬†¬†¬†¬†¬†¬†¬†return¬†</code>

<math display="inline" id="Point_set_registration:217">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>ùêë</mi>
    <mo>,</mo>
    <mi>ùê≠</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>,</mo>
   <msup>
    <mi>œÉ</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <set>
     <ci>a</ci>
     <ci>ùêë</ci>
     <ci>ùê≠</ci>
    </set>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>œÉ</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,\mathbf{R},\mathbf{t}\},\sigma^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>For affine registration, where the goal is to find an <a href="affine_transformation" title="wikilink">affine transformation</a> instead of a rigid one, the output is an affine transformation matrix 

<math display="inline" id="Point_set_registration:218">
 <semantics>
  <mi>ùêÅ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêÅ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}
  </annotation>
 </semantics>
</math>

 and a translation 

<math display="inline" id="Point_set_registration:219">
 <semantics>
  <mi>ùê≠</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùê≠</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}
  </annotation>
 </semantics>
</math>

 such that the aligned point set is:</p>

<p>

<math display="block" id="Point_set_registration:220">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùêå</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>ùêåùêÅ</mi>
     <mi>T</mi>
    </msup>
    <mo>+</mo>
    <mrow>
     <mn>ùüè</mn>
     <msup>
      <mi>ùê≠</mi>
      <mi>T</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>ùêå</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùêåùêÅ</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ùê≠</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(\mathbf{M})=\mathbf{M}\mathbf{B}^{T}+\mathbf{1}\mathbf{t}^{T}
  </annotation>
 </semantics>
</math>

</p>

<p>The <code>'''solve_affine'''</code> function for rigid registration can then be written as follows, with derivation of the algebra explained in Myronenko's 2010 paper.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>

<p><code>¬†¬†¬†</code><strong><code>solve_affine</code></strong>

<math display="inline" id="Point_set_registration:221">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>ùêí</mi>
   <mo>,</mo>
   <mi>ùêå</mi>
   <mo>,</mo>
   <mi>ùêè</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>ùêí</ci>
    <ci>ùêå</ci>
    <ci>ùêè</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{S},\mathbf{M},\mathbf{P})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Point_set_registration:222">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>ùêè</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>ùêè</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{\mathbf{P}}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:223">
 <semantics>
  <mrow>
   <msup>
    <mn>ùüè</mn>
    <mi>T</mi>
   </msup>
   <mi>ùêèùüè</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">1</cn>
     <ci>T</ci>
    </apply>
    <ci>ùêèùüè</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{1}^{T}\mathbf{P}\mathbf{1}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:224">
 <semantics>
  <msub>
   <mi>Œº</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œº</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{s}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:225">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <msub>
     <mi>N</mi>
     <mi>ùêè</mi>
    </msub>
   </mfrac>
   <msup>
    <mi>ùêí</mi>
    <mi>T</mi>
   </msup>
   <msup>
    <mi>ùêè</mi>
    <mi>T</mi>
   </msup>
   <mn>ùüè</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>ùêè</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ùêí</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ùêè</ci>
     <ci>T</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{N_{\mathbf{P}}}\mathbf{S}^{T}\mathbf{P}^{T}\mathbf{1}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:226">
 <semantics>
  <msub>
   <mi>Œº</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œº</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{m}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:227">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <msub>
     <mi>N</mi>
     <mi>ùêè</mi>
    </msub>
   </mfrac>
   <msup>
    <mi>ùêå</mi>
    <mi>T</mi>
   </msup>
   <mi>ùêèùüè</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>ùêè</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ùêå</ci>
     <ci>T</ci>
    </apply>
    <ci>ùêèùüè</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{N_{\mathbf{P}}}\mathbf{M}^{T}\mathbf{P}\mathbf{1}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:228">
 <semantics>
  <mover accent="true">
   <mi>ùêí</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>ùêí</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{S}}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:229">
 <semantics>
  <mrow>
   <mi>ùêí</mi>
   <mo>-</mo>
   <mrow>
    <mn>ùüè</mn>
    <msubsup>
     <mi>Œº</mi>
     <mi>s</mi>
     <mi>T</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>ùêí</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œº</ci>
       <ci>s</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}-\mathbf{1}\mu_{s}^{T}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:230">
 <semantics>
  <mover accent="true">
   <mi>ùêå</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>ùêå</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{M}}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:231">
 <semantics>
  <mrow>
   <mi>ùêå</mi>
   <mo>-</mo>
   <mrow>
    <mn>ùüè</mn>
    <msubsup>
     <mi>Œº</mi>
     <mi>s</mi>
     <mi>T</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>ùêå</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œº</ci>
       <ci>s</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}-\mathbf{1}\mu_{s}^{T}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:232">
 <semantics>
  <mi>ùêÅ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêÅ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:233">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mover accent="true">
      <msup>
       <mi>ùêí</mi>
       <mi>T</mi>
      </msup>
      <mo stretchy="false">^</mo>
     </mover>
     <msup>
      <mi>ùêè</mi>
      <mi>T</mi>
     </msup>
     <mover accent="true">
      <mi>ùêå</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <msup>
        <mi>ùêå</mi>
        <mi>T</mi>
       </msup>
       <mo stretchy="false">^</mo>
      </mover>
      <mrow>
       <mrow>
        <mo>diag</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ùêèùüè</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mover accent="true">
        <mi>ùêå</mi>
        <mo stretchy="false">^</mo>
       </mover>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ùêí</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùêè</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <ci>normal-^</ci>
      <ci>ùêå</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ùêå</ci>
        <ci>T</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <ci>diag</ci>
        <ci>ùêèùüè</ci>
       </apply>
       <apply>
        <ci>normal-^</ci>
        <ci>ùêå</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\hat{\mathbf{S}^{T}}\mathbf{P}^{T}\hat{\mathbf{M}})(\hat{\mathbf{M}^{T}}%
\operatorname{diag}(\mathbf{P}\mathbf{1})\hat{\mathbf{M}})^{-1}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:234">
 <semantics>
  <mi>ùê≠</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùê≠</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:235">
 <semantics>
  <mrow>
   <msub>
    <mi>Œº</mi>
    <mi>s</mi>
   </msub>
   <mo>-</mo>
   <mrow>
    <mi>ùêÅ</mi>
    <msub>
     <mi>Œº</mi>
     <mi>m</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œº</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ùêÅ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œº</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{s}-\mathbf{B}\mu_{m}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Point_set_registration:236">
 <semantics>
  <msup>
   <mi>œÉ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>œÉ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>

 := 

<math display="inline" id="Point_set_registration:237">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msub>
       <mi>N</mi>
       <mi>ùêè</mi>
      </msub>
      <mi>D</mi>
     </mrow>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>tr</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mover accent="true">
         <mi>ùêí</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mrow>
         <mrow>
          <mo>diag</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msup>
             <mi>ùêè</mi>
             <mi>ùêì</mi>
            </msup>
            <mn>ùüè</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mover accent="true">
          <mi>ùêí</mi>
          <mo stretchy="false">^</mo>
         </mover>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mo>tr</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <msup>
        <mi>ùêí</mi>
        <mi>T</mi>
       </msup>
       <mo stretchy="false">^</mo>
      </mover>
      <msup>
       <mi>ùêè</mi>
       <mi>T</mi>
      </msup>
      <mover accent="true">
       <mi>ùêå</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <msup>
       <mi>ùêÅ</mi>
       <mi>T</mi>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <ci>ùêè</ci>
       </apply>
       <ci>D</ci>
      </apply>
     </apply>
     <apply>
      <ci>tr</ci>
      <apply>
       <times></times>
       <apply>
        <ci>normal-^</ci>
        <ci>ùêí</ci>
       </apply>
       <apply>
        <apply>
         <ci>diag</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ùêè</ci>
           <ci>ùêì</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <ci>normal-^</ci>
         <ci>ùêí</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>tr</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ùêí</ci>
        <ci>T</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ùêè</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <ci>ùêå</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ùêÅ</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{N_{\mathbf{P}}D}(\operatorname{tr}(\mathbf{\hat{\mathbf{S}}%
\operatorname{diag}(\mathbf{P}^{T}\mathbf{1})\hat{\mathbf{S}}}))-\operatorname%
{tr}(\hat{\mathbf{S}^{T}}\mathbf{P}^{T}\hat{\mathbf{M}}\mathbf{B}^{T})
  </annotation>
 </semantics>
</math>

</p>

<p><code>¬†¬†¬†¬†¬†¬†¬†return¬†</code>

<math display="inline" id="Point_set_registration:238">
 <semantics>
  <mrow>
   <mi>ùêÅ</mi>
   <mo>,</mo>
   <mi>ùê≠</mi>
   <mo stretchy="false">}</mo>
   <mo>,</mo>
   <mi>œÉ</mi>
   <msup>
    <mi></mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">B</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">t</csymbol>
    <ci>normal-}</ci>
    <ci>normal-,</ci>
    <csymbol cd="unknown">œÉ</csymbol>
    <apply>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B},\mathbf{t}\},\sigma^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>It is also possible to use CPD with non-rigid registration using a parametrization derived using <a href="calculus_of_variation" title="wikilink">calculus of variation</a>.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>

<p>Sums of Gaussian distributions can be computed in <a href="linear_time" title="wikilink">linear time</a> using the <a href="fast_Gauss_transform" title="wikilink">fast Gauss transform</a> (FGT).<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> Consequently, the <a href="time_complexity" title="wikilink">time complexity</a> of CPD is 

<math display="inline" id="Point_set_registration:239">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>M</mi>
     <mo>+</mo>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <ci>M</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(M+N)
  </annotation>
 </semantics>
</math>

, which is asymptotically much faster than 

<math display="inline" id="Point_set_registration:240">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>M</mi>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(MN)
  </annotation>
 </semantics>
</math>

 methods.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cise.ufl.edu/~anand/students/chui/research.html">Reference implementation of thin plate spline robust point matching</a></li>
<li><a href="http://www.cs.cmu.edu/~ytsin/KCReg/">Reference implementation of kernel correlation point set registration</a></li>
<li><a href="http://sites.google.com/site/myronenko/research/cpd">Reference implementation of coherent point drift</a></li>
<li><a href="https://github.com/ethz-asl/libpointmatcher">Reference implementation of ICP variants</a></li>
<li><a href="http://projects.asl.ethz.ch/datasets/doku.php?id=laserregistration:laserregistration">Evaluation data sets for 3D rigid registration algorithms</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Computer_vision" title="wikilink">Category:Computer vision</a> <a class="uri" href="Category:Robotics" title="wikilink">Category:Robotics</a> <a href="Category:Pattern_matching" title="wikilink">Category:Pattern matching</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">‚Ü©</a></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">‚Ü©</a></li>
<li id="fn18"></li>
<li id="fn19"><a href="#fnref19">‚Ü©</a></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"><a href="#fnref25">‚Ü©</a></li>
<li id="fn26"><a href="#fnref26">‚Ü©</a></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"><a href="#fnref32">‚Ü©</a></li>
<li id="fn33"><a href="#fnref33">‚Ü©</a></li>
<li id="fn34"><a href="#fnref34">‚Ü©</a></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39"></li>
<li id="fn40"></li>
<li id="fn41"></li>
<li id="fn42"></li>
</ol>
</section>
</body>
</html>
