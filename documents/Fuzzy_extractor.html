<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="127">Fuzzy extractor</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Fuzzy extractor</h1>
<hr/>

<p><strong>Fuzzy extractors</strong> convert <a href="Biometrics" title="wikilink">biometric</a> data into <a href="Random_variable" title="wikilink">random</a> strings, which makes it possible to apply <a href="Cryptography" title="wikilink">cryptographic</a> techniques for biometric security. They are used to <a href="Encryption" title="wikilink">encrypt</a> and <a href="Authentication" title="wikilink">authenticate</a> users records, with biometric inputs as a key. Historically, the first biometric system of this kind was designed by Juels and Wattenberg and was called "Fuzzy commitment", where the cryptographic key is decommitted using biometric data. "Fuzzy", in that context, implies that the value close to the original one can extract the committed value. Later, Juels and <a href="Madhu_Sudan" title="wikilink">Sudan</a> came up with <a href="https://wiki.cse.buffalo.edu/cse545/content/fuzzy-vault">Fuzzy vault</a> schemes which are order invariant for the fuzzy commitment scheme but uses a <a href="Reed–Solomon_error_correction" title="wikilink">Reed–Solomon</a> <a class="uri" href="code" title="wikilink">code</a>. Codeword is evaluated by <a class="uri" href="polynomial" title="wikilink">polynomial</a> and the secret message is inserted as the coefficients of the polynomial. The polynomial is evaluated for different values of a set of features of the biometric data. So Fuzzy commitment and Fuzzy Vault were per-cursor to Fuzzy extractors. Fuzzy extractor is a biometric tool to authenticate a user using its own biometric template as a key. They extract uniform and random string 

<math display="inline" id="Fuzzy_extractor:0">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 from its input 

<math display="inline" id="Fuzzy_extractor:1">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 that has tolerance for noise. If the input changes to 

<math display="inline" id="Fuzzy_extractor:2">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 but is still close to 

<math display="inline" id="Fuzzy_extractor:3">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, the string 

<math display="inline" id="Fuzzy_extractor:4">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 can still be re-constructed. When 

<math display="inline" id="Fuzzy_extractor:5">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is used first time to re-construct, it outputs a helper string 

<math display="inline" id="Fuzzy_extractor:6">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 which can be made public without compromising the security of 

<math display="inline" id="Fuzzy_extractor:7">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 (used for encryption and authentication key) and 

<math display="inline" id="Fuzzy_extractor:8">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 (helper string) is stored to recover 

<math display="inline" id="Fuzzy_extractor:9">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

. They remain secure even when the adversary modifies 

<math display="inline" id="Fuzzy_extractor:10">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 (key agreement between a user and a server based only on a biometric input). This article is based on the papers "Fuzzy Extractors: A Brief Survey of Results from 2004 to 2006" and "Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data" by Yevgeniy Dodis, Rafail Ostrovsky, Leonid Reyzin and Adam Smith</p>
<h2 id="motivation">Motivation</h2>

<p>As fuzzy extractors deal with how to generate strong keys from Biometrics and other Noisy Data, it applies <a class="uri" href="cryptography" title="wikilink">cryptography</a> paradigms to biometric data and that means (1) Make little assumptions about the biometric data (these data comes from variety of sources and don't want adversary to exploit that so it is best to assume the input is unpredictable) (2) Apply cryptographic application techniques to the input. (for that fuzzy extractor converts biometric data into secret, uniformly random and reliably reproducible random string). According to "Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data" paper by Yevgeniy Dodis, Rafail Ostrovsky, Leonid Reyzin and Adam Smith – these techniques also have other broader applications (when noisy inputs are used) such as human <a class="uri" href="memory" title="wikilink">memory</a>, images used as passwords, keys from quantum channel. Based on the <a href="Differential_privacy" title="wikilink">Differential Privacy</a> paper by Cynthia Dwork (ICALP 2006) – fuzzy extractors have application in the <a href="proof_of_impossibility" title="wikilink">proof of impossibility</a> of strong notions of privacy for statistical databases.</p>
<h2 id="basic-definitions">Basic definitions</h2>
<h3 id="predictability">Predictability</h3>

<p>Predictability indicates probability that adversary can guess a secret key. Mathematically speaking, the predictability of a random variable 

<math display="inline" id="Fuzzy_extractor:11">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Fuzzy_extractor:12">
 <semantics>
  <mrow>
   <msub>
    <mi>max</mi>
    <mi mathvariant="normal">a</mi>
   </msub>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>A</mi>
    <mo>=</mo>
    <mi>a</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <ci>normal-a</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">A</csymbol>
     <eq></eq>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{\mathrm{a}}P[A=a]
  </annotation>
 </semantics>
</math>

. For example, if pair of random variable 

<math display="inline" id="Fuzzy_extractor:13">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:14">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, if the adversary knows 

<math display="inline" id="Fuzzy_extractor:15">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Fuzzy_extractor:16">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, then predictability of 

<math display="inline" id="Fuzzy_extractor:17">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 will be 

<math display="inline" id="Fuzzy_extractor:18">
 <semantics>
  <mrow>
   <msub>
    <mi>max</mi>
    <mi mathvariant="normal">a</mi>
   </msub>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>A</mi>
    <mo>=</mo>
    <mi>a</mi>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo>=</mo>
    <mi>b</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <ci>normal-a</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">A</csymbol>
     <eq></eq>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">B</csymbol>
     <eq></eq>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{\mathrm{a}}P[A=a|B=b]
  </annotation>
 </semantics>
</math>

. So, Adversary can predict 

<math display="inline" id="Fuzzy_extractor:19">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Fuzzy_extractor:20">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mrow>
     <mi>b</mi>
     <mo>←</mo>
     <mi>B</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>max</mi>
     <mi mathvariant="normal">a</mi>
    </msub>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>A</mi>
     <mo>=</mo>
     <mi>a</mi>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo>=</mo>
     <mi>b</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <apply>
      <ci>normal-←</ci>
      <ci>b</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>normal-a</ci>
     </apply>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">A</csymbol>
      <eq></eq>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">B</csymbol>
      <eq></eq>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{b\leftarrow B}[\max_{\mathrm{a}}P[A=a|B=b]]
  </annotation>
 </semantics>
</math>

. Taking average over 

<math display="inline" id="Fuzzy_extractor:21">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 as it is not under adversary control, but since knowing 

<math display="inline" id="Fuzzy_extractor:22">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 makes 

<math display="inline" id="Fuzzy_extractor:23">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 prediction adversarial, taking the worst case over 

<math display="inline" id="Fuzzy_extractor:24">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="min-entropy">Min-entropy</h3>

<p><a class="uri" href="Min-entropy" title="wikilink">Min-entropy</a> indicates worst-case entropy. Mathematically speaking, it is defined as 

<math display="inline" id="Fuzzy_extractor:25">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi mathvariant="normal">∞</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>-</mo>
   <mi>log</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>max</mi>
     <mi mathvariant="normal">a</mi>
    </msub>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>A</mi>
     <mo>=</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <infinity></infinity>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <minus></minus>
    <log></log>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>normal-a</ci>
     </apply>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">A</csymbol>
      <eq></eq>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\infty}(A)=-\log(\max_{\mathrm{a}}P[A=a])
  </annotation>
 </semantics>
</math>

 . Random variables with min-entropy at least 

<math display="inline" id="Fuzzy_extractor:26">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is called 

<math display="inline" id="Fuzzy_extractor:27">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-source.</p>
<h3 id="statistical-distance">Statistical distance</h3>

<p><a href="Statistical_distance" title="wikilink">Statistical distance</a> is measure of distinguishability. Mathematically speaking, it is between two probability distributions 

<math display="inline" id="Fuzzy_extractor:28">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:29">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is, 

<math display="inline" id="Fuzzy_extractor:30">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>D</ci>
    <interval closure="closed">
     <ci>A</ci>
     <ci>B</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SD[A,B]
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="Fuzzy_extractor:31">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mi mathvariant="normal">v</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>A</mi>
    <mo>=</mo>
    <mi>v</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>-</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>B</mi>
    <mo>=</mo>
    <mi>v</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>normal-v</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">A</csymbol>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">B</csymbol>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-|</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}\sum_{\mathrm{v}}|P[A=v]-P[B=v]|
  </annotation>
 </semantics>
</math>

. In any system if 

<math display="inline" id="Fuzzy_extractor:32">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is replaced by 

<math display="inline" id="Fuzzy_extractor:33">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, it will behave as original system with probability at least 

<math display="inline" id="Fuzzy_extractor:34">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mrow>
    <mi>S</mi>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>B</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>D</ci>
     <interval closure="closed">
      <ci>A</ci>
      <ci>B</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-SD[A,B]
  </annotation>
 </semantics>
</math>

 .</p>
<h3 id="definition-1-strong-extractor">Definition 1 (strong extractor)</h3>

<p>Set 

<math display="inline" id="Fuzzy_extractor:35">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is <a href="Randomness_extractor" title="wikilink">strong randomness extractor</a>. Randomized function Ext

<math display="block" id="Fuzzy_extractor:36">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>→</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>l</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\rightarrow\{0,1\}^{l}
  </annotation>
 </semantics>
</math>

 with randomness of length 

<math display="inline" id="Fuzzy_extractor:37">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 is an 

<math display="inline" id="Fuzzy_extractor:38">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mi>l</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>m</ci>
    <ci>l</ci>
    <ci>ϵ</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m,l,\epsilon)
  </annotation>
 </semantics>
</math>

 -strong extractor if for all 

<math display="inline" id="Fuzzy_extractor:39">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-sources (Random variables with min-entropy at least 

<math display="inline" id="Fuzzy_extractor:40">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is called 

<math display="inline" id="Fuzzy_extractor:41">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-source) 

<math display="inline" id="Fuzzy_extractor:42">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Fuzzy_extractor:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>E</mi>
       <mi>x</mi>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>W</mi>
        <mo>;</mo>
        <mi>I</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>I</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <msub>
     <mo>≈</mo>
     <mi>ϵ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>U</mi>
      <mi>l</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>U</mi>
      <mi>r</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <approx></approx>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>M</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>x</ci>
       <ci>t</ci>
       <list>
        <ci>W</ci>
        <ci>I</ci>
       </list>
      </apply>
      <ci>I</ci>
     </interval>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>r</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(Ext(W;I),I)\approx_{\epsilon}(U_{l},U_{r}),
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Fuzzy_extractor:44">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>=</mo>
   <msub>
    <mi>U</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I=U_{r}
  </annotation>
 </semantics>
</math>

 is independent of 

<math display="inline" id="Fuzzy_extractor:45">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

. Output of the extractor is a key generated from 

<math display="inline" id="Fuzzy_extractor:46">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>←</mo>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>w</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\leftarrow W
  </annotation>
 </semantics>
</math>

 with the seed 

<math display="inline" id="Fuzzy_extractor:47">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>←</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>i</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\leftarrow I
  </annotation>
 </semantics>
</math>

. It behaves independent of other parts of the system with the probability of 

<math display="inline" id="Fuzzy_extractor:48">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\epsilon
  </annotation>
 </semantics>
</math>

. Strong extractors can extract at most 

<math display="inline" id="Fuzzy_extractor:49">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>l</mi>
      <mi>o</mi>
      <mi>g</mi>
      <mfrac>
       <mn>1</mn>
       <mi>ϵ</mi>
      </mfrac>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>l</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>l</ci>
       <ci>o</ci>
       <ci>g</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>ϵ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l=m-2log\frac{1}{\epsilon}+O(1)
  </annotation>
 </semantics>
</math>

 bits from arbitrary 

<math display="inline" id="Fuzzy_extractor:50">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-source.</p>
<h3 id="secure-sketch">Secure sketch</h3>

<p>Secure sketch makes it possible to reconstruct noisy input, so if the input is 

<math display="inline" id="Fuzzy_extractor:51">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

and sketch is 

<math display="inline" id="Fuzzy_extractor:52">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, given 

<math display="inline" id="Fuzzy_extractor:53">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and value 

<math display="inline" id="Fuzzy_extractor:54">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 close to 

<math display="inline" id="Fuzzy_extractor:55">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, it is possible to recover 

<math display="inline" id="Fuzzy_extractor:56">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. But sketch 

<math display="inline" id="Fuzzy_extractor:57">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 doesn't give much information about 

<math display="inline" id="Fuzzy_extractor:58">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, so it is secure. If 

<math display="inline" id="Fuzzy_extractor:59">
 <semantics>
  <mi>𝕄</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝕄</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{M}
  </annotation>
 </semantics>
</math>

 is a metric space with distance function dis. Secure sketch recovers string 

<math display="inline" id="Fuzzy_extractor:60">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∈</mo>
   <mi>𝕄</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>w</ci>
    <ci>𝕄</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in\mathbb{M}
  </annotation>
 </semantics>
</math>

 from any close string 

<math display="inline" id="Fuzzy_extractor:61">
 <semantics>
  <mrow>
   <msup>
    <mi>w</mi>
    <mo>′</mo>
   </msup>
   <mo>∈</mo>
   <mi>𝕄</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>𝕄</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}\in\mathbb{M}
  </annotation>
 </semantics>
</math>

without disclosing 

<math display="inline" id="Fuzzy_extractor:62">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="definition-2-secure-sketch">Definition 2 (secure sketch)</h3>

<p>An 

<math display="inline" id="Fuzzy_extractor:63">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mover accent="true">
    <mi>m</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>m</ci>
    <apply>
     <ci>normal-~</ci>
     <ci>m</ci>
    </apply>
    <ci>t</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m,\tilde{m},t)
  </annotation>
 </semantics>
</math>

 secure sketch is a pair of efficient randomized procedures (SS – Sketch, Rec – Recover) such that – (1) The sketching procedure SS on input 

<math display="inline" id="Fuzzy_extractor:64">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∈</mo>
   <mi>𝕄</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>w</ci>
    <ci>𝕄</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in\mathbb{M}
  </annotation>
 </semantics>
</math>

 returns a string 

<math display="inline" id="Fuzzy_extractor:65">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in{\{0,1\}^{*}}
  </annotation>
 </semantics>
</math>

. The recovery procedure Rec takes an element 

<math display="inline" id="Fuzzy_extractor:66">
 <semantics>
  <mrow>
   <msup>
    <mi>w</mi>
    <mo>′</mo>
   </msup>
   <mo>∈</mo>
   <mi>𝕄</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>𝕄</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}\in\mathbb{M}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:67">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in{\{0,1\}^{*}}
  </annotation>
 </semantics>
</math>

. (2) Correctness: If 

<math display="inline" id="Fuzzy_extractor:68">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>i</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo>,</mo>
     <msup>
      <mi>w</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>i</ci>
     <ci>s</ci>
     <interval closure="open">
      <ci>w</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dis(w,w^{\prime})\leq t
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Fuzzy_extractor:69">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mi>e</mi>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>w</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mrow>
      <mi>S</mi>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>e</ci>
     <ci>c</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>S</ci>
       <ci>w</ci>
      </apply>
     </interval>
    </apply>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rec(w^{\prime},SS(w))=w
  </annotation>
 </semantics>
</math>

. (3) Security: For any 

<math display="inline" id="Fuzzy_extractor:70">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-source over 

<math display="inline" id="Fuzzy_extractor:71">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, the min-entropy of 

<math display="inline" id="Fuzzy_extractor:72">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 given 

<math display="inline" id="Fuzzy_extractor:73">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is high: for any 

<math display="inline" id="Fuzzy_extractor:74">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>E</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>W</ci>
    <ci>E</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (W,E)
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Fuzzy_extractor:75">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>H</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi mathvariant="normal">∞</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">|</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>H</ci>
     </apply>
     <infinity></infinity>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">W</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{H}_{\mathrm{\infty}}(W|E)\geq m
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Fuzzy_extractor:76">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>H</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi mathvariant="normal">∞</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>W</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mover accent="true">
    <mi>m</mi>
    <mo stretchy="false">~</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>H</ci>
     </apply>
     <infinity></infinity>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">W</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">S</csymbol>
     <csymbol cd="unknown">S</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">W</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <apply>
     <ci>normal-~</ci>
     <ci>m</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{H}_{\mathrm{\infty}}(W|SS(W),E)\geq\tilde{m}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="fuzzy-extractor">Fuzzy extractor</h3>

<p>Fuzzy extractors do not recover the original input but generate string 

<math display="inline" id="Fuzzy_extractor:77">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 (which is close to uniform) from 

<math display="inline" id="Fuzzy_extractor:78">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and its subsequent reproduction (using helper string 

<math display="inline" id="Fuzzy_extractor:79">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

) given any 

<math display="inline" id="Fuzzy_extractor:80">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 close to 

<math display="inline" id="Fuzzy_extractor:81">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. Strong extractors are a special case of fuzzy extractors when 

<math display="inline" id="Fuzzy_extractor:82">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 = 0 and 

<math display="inline" id="Fuzzy_extractor:83">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=I
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="definition-3-fuzzy-extractor">Definition 3 (fuzzy extractor)</h3>

<p>An 

<math display="inline" id="Fuzzy_extractor:84">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mi>l</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>m</ci>
    <ci>l</ci>
    <ci>t</ci>
    <ci>ϵ</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m,l,t,\epsilon)
  </annotation>
 </semantics>
</math>

 fuzzy extractor is a pair of efficient randomized procedures (Gen – Generate and Rep – Reproduce) such that: (1) Gen, given 

<math display="inline" id="Fuzzy_extractor:85">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∈</mo>
   <mi>𝕄</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>w</ci>
    <ci>𝕄</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in\mathbb{M}
  </annotation>
 </semantics>
</math>

, outputs an extracted string 

<math display="inline" id="Fuzzy_extractor:86">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>l</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>R</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\in{\mathbb{\{}0,1\}^{l}}
  </annotation>
 </semantics>
</math>

 and a helper string 

<math display="inline" id="Fuzzy_extractor:87">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\in{\mathbb{\{}0,1\}^{*}}
  </annotation>
 </semantics>
</math>

. (2) Correctness: If 

<math display="inline" id="Fuzzy_extractor:88">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>i</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo>,</mo>
     <msup>
      <mi>w</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>i</ci>
     <ci>s</ci>
     <interval closure="open">
      <ci>w</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dis(w,w^{\prime})\leq t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:89">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>←</mo>
   <mrow>
    <mi>G</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <interval closure="open">
     <ci>R</ci>
     <ci>P</ci>
    </interval>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>e</ci>
     <ci>n</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R,P)\leftarrow Gen(w)
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Fuzzy_extractor:90">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mi>e</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>w</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>e</ci>
     <ci>p</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>P</ci>
     </interval>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rep(w^{\prime},P)=R
  </annotation>
 </semantics>
</math>

. (3) Security: For all m-sources 

<math display="inline" id="Fuzzy_extractor:91">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 over 

<math display="inline" id="Fuzzy_extractor:92">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, the string 

<math display="inline" id="Fuzzy_extractor:93">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is nearly uniform even given 

<math display="inline" id="Fuzzy_extractor:94">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, So 

<math display="inline" id="Fuzzy_extractor:95">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>H</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi mathvariant="normal">∞</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">|</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>H</ci>
     </apply>
     <infinity></infinity>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">W</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <csymbol cd="unknown">m</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{H}_{\mathrm{\infty}}(W|E)\geq m
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Fuzzy_extractor:96">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>U</mi>
     <mi mathvariant="normal">l</mi>
    </msub>
    <mo>,</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <vector>
     <ci>R</ci>
     <ci>P</ci>
     <ci>E</ci>
    </vector>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>normal-l</ci>
     </apply>
     <ci>P</ci>
     <ci>E</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R,P,E)\approx(U_{\mathrm{l}},P,E)
  </annotation>
 </semantics>
</math>

.</p>

<p>So Fuzzy extractors output almost uniform random bits which is prerequisite for using cryptographic applications (in terms of secret keys). Since output bits are slightly non-uniform, it can decrease security, but not more than the distance 

<math display="inline" id="Fuzzy_extractor:97">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 from the uniform and as long as that distance is sufficiently small – security still remains robust.</p>
<h3 id="secure-sketches-and-fuzzy-extractors">Secure sketches and fuzzy extractors</h3>

<p>Secure sketches can be used to construct fuzzy extractors. Like applying SS to 

<math display="inline" id="Fuzzy_extractor:98">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 to obtain 

<math display="inline" id="Fuzzy_extractor:99">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and strong extractor Ext with randomness 

<math display="inline" id="Fuzzy_extractor:100">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Fuzzy_extractor:101">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 to get 

<math display="inline" id="Fuzzy_extractor:102">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Fuzzy_extractor:103">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>x</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>s</ci>
    <ci>x</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,x)
  </annotation>
 </semantics>
</math>

 can be stored as helper string 

<math display="inline" id="Fuzzy_extractor:104">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Fuzzy_extractor:105">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 can be reproduced by 

<math display="inline" id="Fuzzy_extractor:106">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:107">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <interval closure="open">
     <ci>s</ci>
     <ci>x</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(s,x)
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Fuzzy_extractor:108">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mi>e</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>e</ci>
    <ci>c</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rec(w^{\prime},s)
  </annotation>
 </semantics>
</math>

 can recover 

<math display="inline" id="Fuzzy_extractor:109">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:110">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mi>x</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>x</ci>
    <ci>t</ci>
    <interval closure="open">
     <ci>w</ci>
     <ci>x</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ext(w,x)
  </annotation>
 </semantics>
</math>

 can reproduce 

<math display="inline" id="Fuzzy_extractor:111">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

. Following Lemma formalize this.</p>
<h3 id="lemma-1-fuzzy-extractors-from-sketches">Lemma 1 (fuzzy extractors from sketches)</h3>

<p>Assume (SS,Rec) is an 

<math display="inline" id="Fuzzy_extractor:112">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>M</mi>
   <mo>,</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mover accent="true">
    <mi>m</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>M</ci>
    <ci>m</ci>
    <apply>
     <ci>normal-~</ci>
     <ci>m</ci>
    </apply>
    <ci>t</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M,m,\tilde{m},t)
  </annotation>
 </semantics>
</math>

 secure sketch and let Ext be an average-case 

<math display="inline" id="Fuzzy_extractor:113">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mover accent="true">
    <mi>m</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>,</mo>
   <mi>l</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>n</ci>
    <apply>
     <ci>normal-~</ci>
     <ci>m</ci>
    </apply>
    <ci>l</ci>
    <ci>ϵ</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,\tilde{m},l,\epsilon)
  </annotation>
 </semantics>
</math>

 strong extractor. Then the following (Gen, Rep) is an 

<math display="inline" id="Fuzzy_extractor:114">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>M</mi>
   <mo>,</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mi>l</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>M</ci>
    <ci>m</ci>
    <ci>l</ci>
    <ci>t</ci>
    <ci>ϵ</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M,m,l,t,\epsilon)
  </annotation>
 </semantics>
</math>

 fuzzy extractor: (1) Gen 

<math display="inline" id="Fuzzy_extractor:115">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo>,</mo>
     <mi>r</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>s</mi>
       <mi>e</mi>
       <mi>t</mi>
       <mi>P</mi>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>S</mi>
        <mi>S</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>w</mi>
         <mo>;</mo>
         <mi>r</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>R</mi>
      <mo>=</mo>
      <mrow>
       <mi>E</mi>
       <mi>x</mi>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>w</mi>
        <mo>;</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <vector>
     <ci>w</ci>
     <ci>r</ci>
     <ci>x</ci>
    </vector>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>e</ci>
       <ci>t</ci>
       <ci>P</ci>
      </apply>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>S</ci>
        <list>
         <ci>w</ci>
         <ci>r</ci>
        </list>
       </apply>
       <ci>x</ci>
      </interval>
     </apply>
     <apply>
      <eq></eq>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>E</ci>
       <ci>x</ci>
       <ci>t</ci>
       <list>
        <ci>w</ci>
        <ci>x</ci>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (w,r,x):setP=(SS(w;r),x),R=Ext(w;x),
  </annotation>
 </semantics>
</math>

 and output 

<math display="inline" id="Fuzzy_extractor:116">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mi>P</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>R</ci>
    <ci>P</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R,P)
  </annotation>
 </semantics>
</math>

. (2) Rep 

<math display="inline" id="Fuzzy_extractor:117">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>w</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <ci>normal-′</ci>
    </apply>
    <interval closure="open">
     <ci>s</ci>
     <ci>x</ci>
    </interval>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (w^{\prime},(s,x))
  </annotation>
 </semantics>
</math>

: recover 

<math display="inline" id="Fuzzy_extractor:118">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mi>e</mi>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>w</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>e</ci>
     <ci>c</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>s</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=Rec(w^{\prime},s)
  </annotation>
 </semantics>
</math>

 and output 

<math display="inline" id="Fuzzy_extractor:119">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mi>x</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo>;</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>x</ci>
     <ci>t</ci>
     <list>
      <ci>w</ci>
      <ci>x</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=Ext(w;x)
  </annotation>
 </semantics>
</math>

.</p>

<p>Proof: From the definition of secure sketch (Definition 2), 

<math display="inline" id="Fuzzy_extractor:120">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi mathvariant="normal">∞</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>W</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mover accent="true">
    <mi>m</mi>
    <mo stretchy="false">~</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <infinity></infinity>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">W</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">S</csymbol>
     <csymbol cd="unknown">S</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">W</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <apply>
     <ci>normal-~</ci>
     <ci>m</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\infty}(W|SS(W))\geq\tilde{m}
  </annotation>
 </semantics>
</math>

. And since Ext is an average-case 

<math display="inline" id="Fuzzy_extractor:121">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mi>l</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>n</ci>
    <ci>m</ci>
    <ci>l</ci>
    <ci>ϵ</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,m,l,\epsilon)
  </annotation>
 </semantics>
</math>

-strong extractor. 

<math display="inline" id="Fuzzy_extractor:122">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>E</mi>
        <mi>x</mi>
        <mi>t</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>W</mi>
         <mo>;</mo>
         <mi>X</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>S</mi>
        <mi>S</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>W</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>U</mi>
        <mi>l</mi>
       </msub>
       <mo>,</mo>
       <mrow>
        <mi>S</mi>
        <mi>S</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>W</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>S</mi>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>R</mi>
       <mo>,</mo>
       <mi>P</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>U</mi>
        <mi>l</mi>
       </msub>
       <mo>,</mo>
       <mi>P</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mi>ϵ</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>D</ci>
      <interval closure="open">
       <vector>
        <apply>
         <times></times>
         <ci>E</ci>
         <ci>x</ci>
         <ci>t</ci>
         <list>
          <ci>W</ci>
          <ci>X</ci>
         </list>
        </apply>
        <apply>
         <times></times>
         <ci>S</ci>
         <ci>S</ci>
         <ci>W</ci>
        </apply>
        <ci>X</ci>
       </vector>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <ci>l</ci>
        </apply>
        <apply>
         <times></times>
         <ci>S</ci>
         <ci>S</ci>
         <ci>W</ci>
        </apply>
        <ci>X</ci>
       </vector>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>D</ci>
      <interval closure="open">
       <interval closure="open">
        <ci>R</ci>
        <ci>P</ci>
       </interval>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <ci>l</ci>
        </apply>
        <ci>P</ci>
       </interval>
      </interval>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SD((Ext(W;X),SS(W),X),(U_{l},SS(W),X))=SD((R,P),(U_{l},P))\leq\epsilon.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="corollary-1">Corollary 1</h3>

<p>If (SS,Rec) is an 

<math display="inline" id="Fuzzy_extractor:123">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>M</mi>
   <mo>,</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mover accent="true">
    <mi>m</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>M</ci>
    <ci>m</ci>
    <apply>
     <ci>normal-~</ci>
     <ci>m</ci>
    </apply>
    <ci>t</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M,m,\tilde{m},t)
  </annotation>
 </semantics>
</math>

 – secure sketch and Ext is an 

<math display="inline" id="Fuzzy_extractor:124">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mrow>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>-</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mfrac>
       <mn>1</mn>
       <mi>δ</mi>
      </mfrac>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi>l</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>n</ci>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-~</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <ci>l</ci>
      <ci>o</ci>
      <ci>g</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>δ</ci>
      </apply>
     </apply>
    </apply>
    <ci>l</ci>
    <ci>ϵ</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,\tilde{m}-log(\frac{1}{\delta}),l,\epsilon)
  </annotation>
 </semantics>
</math>

 – strong extractor, then the above construction (Gen,Rep) is a 

<math display="inline" id="Fuzzy_extractor:125">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>M</mi>
   <mo>,</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mi>l</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo>,</mo>
   <mrow>
    <mi>ϵ</mi>
    <mo>+</mo>
    <mi>δ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>M</ci>
    <ci>m</ci>
    <ci>l</ci>
    <ci>t</ci>
    <apply>
     <plus></plus>
     <ci>ϵ</ci>
     <ci>δ</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M,m,l,t,\epsilon+\delta)
  </annotation>
 </semantics>
</math>

 fuzzy extractor.</p>

<p>Reference paper "Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data" by Yevgeniy Dodis, Rafail Ostrovsky, Leonid Reyzin and Adam Smith (2008) includes many generic combinatorial bounds on secure sketches and fuzzy extractors</p>
<h2 id="basic-constructions">Basic constructions</h2>

<p>Due to their error tolerant properties, a secure sketches can be treated, analyzed, and constructed like a 

<math display="inline" id="Fuzzy_extractor:126">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo>,</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <vector>
     <ci>n</ci>
     <ci>k</ci>
     <ci>d</ci>
    </vector>
    <ci>ℱ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,k,d)_{\mathcal{F}}
  </annotation>
 </semantics>
</math>

 general <a href="Forward_error_correction" title="wikilink">error correcting code</a> or 

<math display="inline" id="Fuzzy_extractor:127">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo>,</mo>
    <mi>d</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <list>
     <ci>n</ci>
     <ci>k</ci>
     <ci>d</ci>
    </list>
    <ci>ℱ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n,k,d]_{\mathcal{F}}
  </annotation>
 </semantics>
</math>

 for <a href="Linear_code" title="wikilink">linear</a> codes, where 

<math display="inline" id="Fuzzy_extractor:128">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the length of codewords, 

<math display="inline" id="Fuzzy_extractor:129">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is the length of the message to be codded, 

<math display="inline" id="Fuzzy_extractor:130">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 is the distance between codewords, and 

<math display="inline" id="Fuzzy_extractor:131">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 is the alphabet. If 

<math display="inline" id="Fuzzy_extractor:132">
 <semantics>
  <msup>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℱ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}^{n}
  </annotation>
 </semantics>
</math>

 is the universe of possible words then it may be possible to find an error correcting code 

<math display="inline" id="Fuzzy_extractor:133">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>∈</mo>
   <msup>
    <mi class="ltx_font_mathcaligraphic">ℱ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>C</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℱ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\in\mathcal{F}^{n}
  </annotation>
 </semantics>
</math>

 that has a unique codeword 

<math display="inline" id="Fuzzy_extractor:134">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in C
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Fuzzy_extractor:135">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∈</mo>
   <msup>
    <mi class="ltx_font_mathcaligraphic">ℱ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>w</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℱ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in\mathcal{F}^{n}
  </annotation>
 </semantics>
</math>

 and have a <a href="Hamming_distance" title="wikilink">Hamming distance</a> of 

<math display="inline" id="Fuzzy_extractor:136">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>i</mi>
    <msub>
     <mi>s</mi>
     <mrow>
      <mi>H</mi>
      <mi>a</mi>
      <mi>m</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo>,</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <apply>
       <times></times>
       <ci>H</ci>
       <ci>a</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>c</ci>
      <ci>w</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dis_{Ham}(c,w)\leq(d-1)/2
  </annotation>
 </semantics>
</math>

. The first step for constructing a secure sketch is determining the type of errors that will likely occur and then choosing a distance to measure.</p>
<figure><b>(Figure)</b>
<figcaption>Red is the code-offset construction, blue is the syndrome construction, green represents edit distance and other complex constructions.</figcaption>
</figure>
<h3 id="hamming-distance-constructions">Hamming distance constructions</h3>

<p>When there is no chance of data being deleted and only being corrupted than the best measurement to use for error correction is Hamming distance. There are two common constructions for correcting Hamming errors depending on whether the code is linear or not. Both constructions start with an error correcting code that has a distance of 

<math display="inline" id="Fuzzy_extractor:137">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>t</mi>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>t</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2t+1
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Fuzzy_extractor:138">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {t}
  </annotation>
 </semantics>
</math>

 is the number of tolerated errors.</p>
<h4 id="code-offset-construction">Code-offset construction</h4>

<p>When using a 

<math display="inline" id="Fuzzy_extractor:139">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>t</mi>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <vector>
     <ci>n</ci>
     <ci>k</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>t</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </vector>
    <ci>ℱ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,k,2t+1)_{\mathcal{F}}
  </annotation>
 </semantics>
</math>

 general code, assign a uniformly random codeword 

<math display="inline" id="Fuzzy_extractor:140">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in C
  </annotation>
 </semantics>
</math>

 to each 

<math display="inline" id="Fuzzy_extractor:141">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, then let 

<math display="inline" id="Fuzzy_extractor:142">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>w</mi>
    <mo>-</mo>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>S</ci>
      <ci>w</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>w</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SS(w)=s=w-c
  </annotation>
 </semantics>
</math>

 which is the shift needed to change 

<math display="inline" id="Fuzzy_extractor:143">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Fuzzy_extractor:144">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. To fix errors in 

<math display="inline" id="Fuzzy_extractor:145">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 subtract 

<math display="inline" id="Fuzzy_extractor:146">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Fuzzy_extractor:147">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 then correct the errors in the resulting incorrect codeword to get 

<math display="inline" id="Fuzzy_extractor:148">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 and finally add 

<math display="inline" id="Fuzzy_extractor:149">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Fuzzy_extractor:150">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 to get 

<math display="inline" id="Fuzzy_extractor:151">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. This means 

<math display="inline" id="Fuzzy_extractor:152">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mi>e</mi>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>w</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mo>+</mo>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>w</mi>
        <mo>′</mo>
       </msup>
       <mo>-</mo>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>e</ci>
      <ci>c</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>w</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>s</ci>
      </interval>
     </apply>
     <apply>
      <plus></plus>
      <ci>s</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>e</ci>
       <ci>c</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>w</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rec(w^{\prime},s)=s+dec(w^{\prime}-s)=w
  </annotation>
 </semantics>
</math>

. This construction can achieve the best possible tradeoff between error tolerance and entropy loss when 

<math display="inline" id="Fuzzy_extractor:153">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
   <mo>≥</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>ℱ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}\geq n
  </annotation>
 </semantics>
</math>

 and a <a href="Reed–Solomon_error_correction" title="wikilink">Reed–Solomon code</a> is used resulting in an entropy loss of 

<math display="inline" id="Fuzzy_extractor:154">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>t</mi>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi class="ltx_font_mathcaligraphic">ℱ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>t</ci>
    <apply>
     <log></log>
     <ci>ℱ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2t\log(\mathcal{F})
  </annotation>
 </semantics>
</math>

, and the only way to improve upon this is to find a code better than Reed–Solomon.</p>
<h4 id="syndrome-construction">Syndrome construction</h4>

<p>When using a 

<math display="inline" id="Fuzzy_extractor:155">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>t</mi>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <list>
     <ci>n</ci>
     <ci>k</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>t</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </list>
    <ci>ℱ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n,k,2t+1]_{\mathcal{F}}
  </annotation>
 </semantics>
</math>

 linear code let the 

<math display="inline" id="Fuzzy_extractor:156">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>S</ci>
     <ci>w</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SS(w)=s
  </annotation>
 </semantics>
</math>

 be the <a href="Syndrome_decoding#Syndrome_decoding" title="wikilink">syndrome</a> of 

<math display="inline" id="Fuzzy_extractor:157">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. To correct 

<math display="inline" id="Fuzzy_extractor:158">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 find a vector 

<math display="inline" id="Fuzzy_extractor:159">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Fuzzy_extractor:160">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>y</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mi>y</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>w</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mi>s</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>y</ci>
     <ci>n</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>y</ci>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   syn(e)=syn(w^{\prime})-s
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Fuzzy_extractor:161">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
    <mo>-</mo>
    <mi>e</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=w^{\prime}-e
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="set-difference-constructions">Set difference constructions</h3>

<p>When working with a very large alphabet or very long strings resulting in a very large universe 

<math display="inline" id="Fuzzy_extractor:162">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

, it may be more efficient to treat 

<math display="inline" id="Fuzzy_extractor:163">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:164">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 as sets and look at <a href="Set_difference#Relative_complement" title="wikilink">set differences</a> to correct errors. To work with a large set 

<math display="inline" id="Fuzzy_extractor:165">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 it is useful to look at its characteristic vector 

<math display="inline" id="Fuzzy_extractor:166">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>w</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{w}
  </annotation>
 </semantics>
</math>

, which is a binary vector of length 

<math display="inline" id="Fuzzy_extractor:167">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 that has a value of 1 when an element 

<math display="inline" id="Fuzzy_extractor:168">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>𝒰</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in\mathcal{U}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:169">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in w
  </annotation>
 </semantics>
</math>

, or 0 when 

<math display="inline" id="Fuzzy_extractor:170">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∉</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>a</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\notin w
  </annotation>
 </semantics>
</math>

. The best way to decrease the size of a secure sketch when 

<math display="inline" id="Fuzzy_extractor:171">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is large is make 

<math display="inline" id="Fuzzy_extractor:172">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 large since the size is determined by 

<math display="inline" id="Fuzzy_extractor:173">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k
  </annotation>
 </semantics>
</math>

. A good code to base this construction on is a 

<math display="inline" id="Fuzzy_extractor:174">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mrow>
      <mi>t</mi>
      <mi>α</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>t</mi>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <list>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>α</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>t</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </list>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n,n-t\alpha,2t+1]_{2}
  </annotation>
 </semantics>
</math>

 <a href="BCH_codes" title="wikilink">BCH code</a> where 

<math display="inline" id="Fuzzy_extractor:175">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>α</mi>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>α</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=2^{\alpha}-1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:176">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≪</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-less-than</csymbol>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\ll n
  </annotation>
 </semantics>
</math>

 so 

<math display="inline" id="Fuzzy_extractor:177">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≤</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mrow>
      <mo>(</mo>
      <mstyle scriptlevel="+1">
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mi>n</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mi>t</mi>
         </mtd>
        </mtr>
       </mtable>
      </mstyle>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>k</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>l</ci>
      <ci>o</ci>
      <ci>g</ci>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <ci>n</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\leq n-log{n\choose{t}}
  </annotation>
 </semantics>
</math>

, it is also useful that BCH codes can be decode in sub-linear time.</p>
<h4 id="pin-sketch-construction">Pin sketch construction</h4>

<p>Let 

<math display="inline" id="Fuzzy_extractor:178">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mi>y</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>w</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>S</ci>
      <ci>w</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>y</ci>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SS(w)=s=syn(x_{w})
  </annotation>
 </semantics>
</math>

. To correct 

<math display="inline" id="Fuzzy_extractor:179">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 first find 

<math display="inline" id="Fuzzy_extractor:180">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>w</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mi>y</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>x</mi>
      <mi>w</mi>
      <mo>′</mo>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>y</ci>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>w</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SS(w^{\prime})=s^{\prime}=syn(x_{w}^{\prime})
  </annotation>
 </semantics>
</math>

, then find a set v where 

<math display="inline" id="Fuzzy_extractor:181">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>y</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>v</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo>-</mo>
    <mi>s</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>y</ci>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   syn(x_{v})=s^{\prime}-s
  </annotation>
 </semantics>
</math>

, finally compute the <a href="symmetric_difference" title="wikilink">symmetric difference</a> to get 

<math display="inline" id="Fuzzy_extractor:182">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mi>e</mi>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>w</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
    <mi mathvariant="normal">△</mi>
    <mi>v</mi>
   </mrow>
   <mo>=</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>e</ci>
      <ci>c</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>w</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>s</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-△</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rec(w^{\prime},s)=w^{\prime}\triangle v=w
  </annotation>
 </semantics>
</math>

. While this is not the only construction to use set difference it is the easiest one to use.</p>
<h3 id="edit-distance-constructions">Edit distance constructions</h3>

<p>When data can be corrupted or deleted the best measurement to use is <a href="Levenshtein_distance" title="wikilink">edit distance</a>. To make a construction based on edit distance it is easiest to start with a construction for set difference or hamming distance as an intermediate correction step and then build the edit distance construction around that.</p>
<h3 id="other-distance-measure-constructions">Other distance measure constructions</h3>

<p>There are many other types of errors and distances that can be measured which can be used to model other situations. Most of these other possible constructions are like edit distance constructions where they build upon simpler constructions.</p>
<h2 id="improving-error-tolerance-via-relaxed-notions-of-correctness">Improving error-tolerance via relaxed notions of correctness</h2>

<p>It is possible to show that the error-tolerance of a secure sketch can be improved by applying a <a href="probabilistic_method" title="wikilink">probabilistic method</a> to error correction and only needing errors to be correctable with a high probability. This will show that it is possible to exceed the <a href="Plotkin_bound" title="wikilink">Plotkin bound</a> which is limited to correcting 

<math display="inline" id="Fuzzy_extractor:183">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/4
  </annotation>
 </semantics>
</math>

 errors, and approach <a href="Noisy_channel_coding_theorem" title="wikilink">Shannon’s bound</a> allowing for nearly 

<math display="inline" id="Fuzzy_extractor:184">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/2
  </annotation>
 </semantics>
</math>

 corrections. To achieve this better error correction a less restrictive error distribution model must be used.</p>
<h3 id="random-errors">Random errors</h3>

<p>For this most restrictive model use a <a href="Binary_symmetric_channel" title="wikilink">BSC</a>

<math display="inline" id="Fuzzy_extractor:185">
 <semantics>
  <msub>
   <mi></mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}_{p}
  </annotation>
 </semantics>
</math>

 to create a 

<math display="inline" id="Fuzzy_extractor:186">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 that a probability 

<math display="inline" id="Fuzzy_extractor:187">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 at each position in 

<math display="inline" id="Fuzzy_extractor:188">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 that the bit received is wrong. This model can show that entropy loss is limited to 

<math display="inline" id="Fuzzy_extractor:189">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>H</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   nH(p)-o(n)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Fuzzy_extractor:190">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is the <a href="binary_entropy_function" title="wikilink">binary entropy function</a>, and if min-entropy 

<math display="inline" id="Fuzzy_extractor:191">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>H</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mfrac>
          <mn>1</mn>
          <mn>2</mn>
         </mfrac>
         <mo>-</mo>
         <mi>γ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>ε</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>m</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <times></times>
       <ci>H</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <ci>γ</ci>
       </apply>
      </apply>
     </apply>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\geq n(H(\frac{1}{2}-\gamma))+\varepsilon
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Fuzzy_extractor:192">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mo>-</mo>
     <mi>γ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <ci>γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(\frac{1}{2}-\gamma)
  </annotation>
 </semantics>
</math>

 errors can be tolerated, for some constant 

<math display="inline" id="Fuzzy_extractor:193">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>γ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma>0
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="input-dependent-errors">Input-dependent errors</h3>

<p>For this model errors do not have a known distribution and can be from an adversary, the only constraints are 

<math display="inline" id="Fuzzy_extractor:194">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>i</mi>
    <msub>
     <mi>s</mi>
     <mtext>err</mtext>
    </msub>
   </mrow>
   <mo>≤</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <mtext>err</mtext>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dis_{\text{err}}\leq t
  </annotation>
 </semantics>
</math>

 and that a corrupted word depends only on the input 

<math display="inline" id="Fuzzy_extractor:195">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and not on the secure sketch. It can be shown for this error model that there will never be more than 

<math display="inline" id="Fuzzy_extractor:196">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 errors since this model can account for all complex noise processes, meaning that Shannon’s bound can be reached, to do this a random permutation is prepended to the secure sketch that will reduce entropy loss.</p>
<h3 id="computationally-bounded-errors">Computationally bounded errors</h3>

<p>This differs from the input dependent model by having errors that depend on both the input 

<math display="inline" id="Fuzzy_extractor:197">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and the secure sketch, and an adversary is limited to polynomial time algorithms for introducing errors. Since algorithms that can run in better than polynomial time are not currently feasible in the real world, then a positive result using this error model would guarantee that any errors can be fixed. This is the least restrictive model the only known way to approach Shannon’s bound is to use <a href="List_decoding" title="wikilink">list-decodable codes</a> although this may not always be useful in practice since returning a list instead of a single codeword may not always be acceptable.</p>
<h2 id="privacy-guarantees">Privacy guarantees</h2>

<p>In general a secure system attempts to leak as little information as possible to an <a href="Adversary_(cryptography)" title="wikilink">adversary</a>. In the case of biometrics if information about the biometric reading is leaked the adversary may be able to learn personal information about a user. For example an adversary notices that there is a certain pattern in the helper strings that implies the ethnicity of the user. We can consider this additional information a function 

<math display="inline" id="Fuzzy_extractor:198">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(W)
  </annotation>
 </semantics>
</math>

. If an adversary were to learn a helper string, it must be ensured that, from this data he can not infer any data about the person from which the biometric reading was taken.</p>
<h3 id="correlation-between-helper-string-and-biometric-input">Correlation between helper string and biometric input</h3>

<p>Ideally the helper string 

<math display="inline" id="Fuzzy_extractor:199">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 would reveal no information about the biometric input 

<math display="inline" id="Fuzzy_extractor:200">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. This is only possible when every subsequent biometric reading 

<math display="inline" id="Fuzzy_extractor:201">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 is identical to the original 

<math display="inline" id="Fuzzy_extractor:202">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. In this case there is actually no need for the helper string, so it is easy to generate a string that is in no way correlated to 

<math display="inline" id="Fuzzy_extractor:203">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

.</p>

<p>Since it is desirable to accept biometric input 

<math display="inline" id="Fuzzy_extractor:204">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 similar to 

<math display="inline" id="Fuzzy_extractor:205">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 the helper string 

<math display="inline" id="Fuzzy_extractor:206">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 must be somehow correlated. The more different 

<math display="inline" id="Fuzzy_extractor:207">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:208">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 are allowed to be, the more correlation there will be between 

<math display="inline" id="Fuzzy_extractor:209">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:210">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, the more correlated they are the more information 

<math display="inline" id="Fuzzy_extractor:211">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 reveals about 

<math display="inline" id="Fuzzy_extractor:212">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. We can consider this information to be a function 

<math display="inline" id="Fuzzy_extractor:213">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(W)
  </annotation>
 </semantics>
</math>

. The best possible solution is to make sure the adversary can't learn anything useful from the helper string.</p>
<h3 id="genw-as-a-probabilistic-map">Gen(<em>W</em>) as a probabilistic map</h3>

<p>A probabilistic map 

<math display="inline" id="Fuzzy_extractor:214">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y()
  </annotation>
 </semantics>
</math>

 hides the results of functions with a small amount of leakage 

<math display="inline" id="Fuzzy_extractor:215">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

. The leakage is the difference in probability two adversaries have of guessing some function when one knows the probabilistic map and one does not. Formally:</p>

<p>

<math display="block" id="Fuzzy_extractor:216">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>W</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>W</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>-</mo>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>W</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mo>≤</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Y</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">W</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">W</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">W</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-|</ci>
    <leq></leq>
    <csymbol cd="unknown">ϵ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |Pr[A_{1}(Y(W))=f(W)]-Pr[A_{2}()=f(W)]|\leq\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p>If the function 

<math display="inline" id="Fuzzy_extractor:217">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Gen(W)
  </annotation>
 </semantics>
</math>

 is a probabilistic map, then even if an adversary knows both the helper string 

<math display="inline" id="Fuzzy_extractor:218">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and the secret string 

<math display="inline" id="Fuzzy_extractor:219">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 they are only negligibly more likely figure something out about the subject as if they knew nothing. The string 

<math display="inline" id="Fuzzy_extractor:220">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is supposed to kept secret, so even if it is leaked (which should be very unlikely) the adversary can still figure out nothing useful about the subject, as long as 

<math display="inline" id="Fuzzy_extractor:221">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 is small. We can consider 

<math display="inline" id="Fuzzy_extractor:222">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(W)
  </annotation>
 </semantics>
</math>

 to be any correlation between the biometric input and some physical characteristic of the person. Setting 

<math display="inline" id="Fuzzy_extractor:223">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mo>=</mo>
    <mrow>
     <mi>G</mi>
     <mi>e</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>W</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>R</mi>
   </mrow>
   <mo>,</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <ci>Y</ci>
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>e</ci>
       <ci>n</ci>
       <ci>W</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>R</ci>
     </apply>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=Gen(W)=R,P
  </annotation>
 </semantics>
</math>

 in the above equation changes it to:</p>

<p>

<math display="block" id="Fuzzy_extractor:224">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>Pr</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>A</mi>
          <mn>1</mn>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>R</mi>
          <mo>,</mo>
          <mi>P</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>W</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>Pr</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>A</mi>
          <mn>2</mn>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>W</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <ci>Pr</ci>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">1</cn>
         </apply>
         <interval closure="open">
          <ci>R</ci>
          <ci>P</ci>
         </interval>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>W</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>Pr</ci>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <cn type="integer">2</cn>
         </apply>
         <list></list>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>W</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\Pr[A_{1}(R,P)=f(W)]-\Pr[A_{2}()=f(W)]|\leq\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p>This means that if one adversary 

<math display="inline" id="Fuzzy_extractor:225">
 <semantics>
  <msub>
   <mi>A</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1}
  </annotation>
 </semantics>
</math>

 has 

<math display="inline" id="Fuzzy_extractor:226">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mi>P</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>R</ci>
    <ci>P</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R,P)
  </annotation>
 </semantics>
</math>

 and a second adversary 

<math display="inline" id="Fuzzy_extractor:227">
 <semantics>
  <msub>
   <mi>A</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{2}
  </annotation>
 </semantics>
</math>

 knows nothing, their best guesses at 

<math display="inline" id="Fuzzy_extractor:228">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(W)
  </annotation>
 </semantics>
</math>

 are only 

<math display="inline" id="Fuzzy_extractor:229">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 apart.</p>
<h3 id="uniform-fuzzy-extractors">Uniform fuzzy extractors</h3>

<p>Uniform fuzzy extractors are a special case of fuzzy extractors, where the output 

<math display="inline" id="Fuzzy_extractor:230">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mi>P</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>R</ci>
    <ci>P</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R,P)
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Fuzzy_extractor:231">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Gen(W)
  </annotation>
 </semantics>
</math>

 are negligibly different from strings picked from the uniform distribution, i.e. 

<math display="inline" id="Fuzzy_extractor:232">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mo>≈</mo>
    <mi>ϵ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>U</mi>
     <mi mathvariant="normal">ℓ</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>P</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <approx></approx>
     <ci>ϵ</ci>
    </apply>
    <interval closure="open">
     <ci>R</ci>
     <ci>P</ci>
    </interval>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <ci>normal-ℓ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <apply>
       <abs></abs>
       <ci>P</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R,P)\approx_{\epsilon}(U_{\ell},U_{|P|})
  </annotation>
 </semantics>
</math>

</p>
<h3 id="uniform-secure-sketches">Uniform secure sketches</h3>

<p>Since secure sketches imply fuzzy extractors, constructing a uniform secure sketch allows for the easy construction of a uniform fuzzy extractor. In a uniform secure sketch the sketch procedure 

<math display="inline" id="Fuzzy_extractor:233">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>S</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SS(w)
  </annotation>
 </semantics>
</math>

 is a <a href="randomness_extractor" title="wikilink">randomness extractor</a> 

<math display="inline" id="Fuzzy_extractor:234">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mi>x</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo>;</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>x</ci>
    <ci>t</ci>
    <list>
     <ci>w</ci>
     <ci>i</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ext(w;i)
  </annotation>
 </semantics>
</math>

. Where 

<math display="inline" id="Fuzzy_extractor:235">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 is the biometric input and 

<math display="inline" id="Fuzzy_extractor:236">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is the <a href="random_seed" title="wikilink">random seed</a>. Since randomness extractors output a string that appears to be from a uniform distribution they hide all the information about their input.</p>
<h3 id="applications">Applications</h3>

<p>Extractor sketches can be used to construct 

<math display="inline" id="Fuzzy_extractor:237">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>m</ci>
    <ci>t</ci>
    <ci>ϵ</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m,t,\epsilon)
  </annotation>
 </semantics>
</math>

-fuzzy perfectly one-way hash functions. When used as a hash function the input 

<math display="inline" id="Fuzzy_extractor:238">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 is the object you want to hash. The 

<math display="inline" id="Fuzzy_extractor:239">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>,</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>P</ci>
    <ci>R</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P,R
  </annotation>
 </semantics>
</math>

 that 

<math display="inline" id="Fuzzy_extractor:240">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Gen(w)
  </annotation>
 </semantics>
</math>

 outputs is the hash value. If one wanted to verify that a 

<math display="inline" id="Fuzzy_extractor:241">
 <semantics>
  <msup>
   <mi>w</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>w</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}
  </annotation>
 </semantics>
</math>

 within 

<math display="inline" id="Fuzzy_extractor:242">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 from the original 

<math display="inline" id="Fuzzy_extractor:243">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, they would verify that 

<math display="inline" id="Fuzzy_extractor:244">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mi>e</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>w</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>e</ci>
     <ci>p</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>P</ci>
     </interval>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rep(w^{\prime},P)=R
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Fuzzy_extractor:245">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>m</ci>
    <ci>t</ci>
    <ci>ϵ</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m,t,\epsilon)
  </annotation>
 </semantics>
</math>

-fuzzy perfectly one-way hash functions are special <a href="Hash_function_(cryptography)" title="wikilink">hash functions</a> where they accept any input with at most 

<math display="inline" id="Fuzzy_extractor:246">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 errors, compared to traditional hash functions which only accept when the input matches the original exactly. Traditional cryptographic hash functions attempt to guarantee that is it is computationally infeasible to find two different inputs that hash to the same value. Fuzzy perfectly one-way hash functions make an analogous claim. They make it computationally infeasible two find two inputs, that are more than 

<math display="inline" id="Fuzzy_extractor:247">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 <a href="Hamming_distance" title="wikilink">Hamming distance</a> apart and hash to the same value.</p>
<h2 id="protection-against-active-attacks">Protection against active attacks</h2>

<p>An active attack could be one where the adversary can modify the helper string 

<math display="inline" id="Fuzzy_extractor:248">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. If the adversary is able to change 

<math display="inline" id="Fuzzy_extractor:249">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 to another string that is also acceptable to the reproduce function

<math display="inline" id="Fuzzy_extractor:250">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mi>e</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>e</ci>
    <ci>p</ci>
    <interval closure="open">
     <ci>W</ci>
     <ci>P</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rep(W,P)
  </annotation>
 </semantics>
</math>

, it cause 

<math display="inline" id="Fuzzy_extractor:251">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mi>e</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>e</ci>
    <ci>p</ci>
    <interval closure="open">
     <ci>W</ci>
     <ci>P</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rep(W,P)
  </annotation>
 </semantics>
</math>

 to output an incorrect secret string 

<math display="inline" id="Fuzzy_extractor:252">
 <semantics>
  <mover accent="true">
   <mi>R</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{R}
  </annotation>
 </semantics>
</math>

. Robust fuzzy extractors solve this problem by allowing the reproduce function to fail, if a modified helper string is provided as input.</p>
<h3 id="robust-fuzzy-extractors">Robust fuzzy extractors</h3>

<p>One method of constructing robust fuzzy extractors is to use <a href="Hash_function_(cryptography)" title="wikilink">hash functions</a>. This construction requires two hash functions 

<math display="inline" id="Fuzzy_extractor:253">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:254">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{2}
  </annotation>
 </semantics>
</math>

. The 

<math display="inline" id="Fuzzy_extractor:255">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Gen(W)
  </annotation>
 </semantics>
</math>

 functions produces the helper string 

<math display="inline" id="Fuzzy_extractor:256">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 by appending the output of a secure sketch 

<math display="inline" id="Fuzzy_extractor:257">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>S</mi>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>S</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=SS(w)
  </annotation>
 </semantics>
</math>

 to the hash of both the reading 

<math display="inline" id="Fuzzy_extractor:258">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and secure sketch 

<math display="inline" id="Fuzzy_extractor:259">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. It generates the secret string 

<math display="inline" id="Fuzzy_extractor:260">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 by applying the second hash function to 

<math display="inline" id="Fuzzy_extractor:261">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:262">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. Formally: 

<math display="inline" id="Fuzzy_extractor:263">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>s</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>S</mi>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>r</mi>
      <mi>e</mi>
      <mi>t</mi>
      <mi>u</mi>
      <mi>r</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mo>=</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>H</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>w</mi>
        <mo>,</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>R</mi>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>H</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>e</ci>
      <ci>n</ci>
      <ci>w</ci>
     </apply>
     <apply>
      <eq></eq>
      <ci>s</ci>
      <list>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>S</ci>
        <ci>w</ci>
       </apply>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>e</ci>
        <ci>t</ci>
        <ci>u</ci>
        <ci>r</ci>
        <ci>n</ci>
       </apply>
      </list>
     </apply>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <ci>P</ci>
       <interval closure="open">
        <ci>s</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <cn type="integer">1</cn>
         </apply>
         <interval closure="open">
          <ci>w</ci>
          <ci>s</ci>
         </interval>
        </apply>
       </interval>
      </apply>
      <apply>
       <eq></eq>
       <ci>R</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <cn type="integer">2</cn>
        </apply>
        <interval closure="open">
         <ci>w</ci>
         <ci>s</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Gen(w):s=SS(w),return:P=(s,H_{1}(w,s)),R=H_{2}(w,s)
  </annotation>
 </semantics>
</math>

  The reproduce function 

<math display="inline" id="Fuzzy_extractor:264">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mi>e</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>e</ci>
    <ci>p</ci>
    <interval closure="open">
     <ci>W</ci>
     <ci>P</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rep(W,P)
  </annotation>
 </semantics>
</math>

 also makes use of the hash functions 

<math display="inline" id="Fuzzy_extractor:265">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:266">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{2}
  </annotation>
 </semantics>
</math>

. In addition to verifying the biometric input is similar enough to the one recovered using the 

<math display="inline" id="Fuzzy_extractor:267">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mi>e</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>e</ci>
    <ci>c</ci>
    <interval closure="open">
     <ci>W</ci>
     <ci>S</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rec(W,S)
  </annotation>
 </semantics>
</math>

 function, it also verifies that hash in the second part of 

<math display="inline" id="Fuzzy_extractor:268">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 was actually derived from 

<math display="inline" id="Fuzzy_extractor:269">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:270">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. If both of those conditions are met it returns 

<math display="inline" id="Fuzzy_extractor:271">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 which is itself the second hash function applied to 

<math display="inline" id="Fuzzy_extractor:272">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:273">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. Formally:</p>

<p>

<math display="inline" id="Fuzzy_extractor:274">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mi>e</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>w</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mover accent="true">
      <mi>P</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>e</ci>
     <ci>p</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>P</ci>
      </apply>
     </interval>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rep(w^{\prime},\tilde{P}):
  </annotation>
 </semantics>
</math>

 Get 

<math display="inline" id="Fuzzy_extractor:275">
 <semantics>
  <mover accent="true">
   <mi>s</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{s}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:276">
 <semantics>
  <mover accent="true">
   <mi>h</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{h}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Fuzzy_extractor:277">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>P</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo>;</mo>
     <mover accent="true">
      <mi>w</mi>
      <mo stretchy="false">~</mo>
     </mover>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>R</mi>
     <mi>e</mi>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>w</mi>
       <mo>′</mo>
      </msup>
      <mo>,</mo>
      <mover accent="true">
       <mi>s</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <ci>normal-~</ci>
      <ci>P</ci>
     </apply>
     <apply>
      <ci>normal-~</ci>
      <ci>w</ci>
     </apply>
    </list>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>e</ci>
     <ci>c</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>s</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P};\tilde{w}=Rec(w^{\prime},\tilde{s}).
  </annotation>
 </semantics>
</math>

 If 

<math display="inline" id="Fuzzy_extractor:278">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>w</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo>,</mo>
     <msup>
      <mi>w</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <interval closure="open">
      <apply>
       <ci>normal-~</ci>
       <ci>w</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>w</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(\tilde{w},w^{\prime})\leq t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Fuzzy_extractor:279">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>h</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>w</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo>,</mo>
     <mover accent="true">
      <mi>s</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>h</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">1</cn>
     </apply>
     <interval closure="open">
      <apply>
       <ci>normal-~</ci>
       <ci>w</ci>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>s</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{h}=H_{1}(\tilde{w},\tilde{s})
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Fuzzy_extractor:280">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>t</mi>
    <mi>u</mi>
    <mi>r</mi>
    <mi>n</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>w</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo>,</mo>
     <mover accent="true">
      <mi>s</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>e</ci>
     <ci>t</ci>
     <ci>u</ci>
     <ci>r</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">2</cn>
     </apply>
     <interval closure="open">
      <apply>
       <ci>normal-~</ci>
       <ci>w</ci>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>s</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   return:H_{2}(\tilde{w},\tilde{s})
  </annotation>
 </semantics>
</math>

 else 

<math display="inline" id="Fuzzy_extractor:281">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>t</mi>
    <mi>u</mi>
    <mi>r</mi>
    <mi>n</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>f</mi>
    <mi>a</mi>
    <mi>i</mi>
    <mi>l</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>e</ci>
     <ci>t</ci>
     <ci>u</ci>
     <ci>r</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>a</ci>
     <ci>i</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   return:fail
  </annotation>
 </semantics>
</math>

 </p>

<p>If 

<math display="inline" id="Fuzzy_extractor:282">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 has been tampered with it will be obvious because, 

<math display="inline" id="Fuzzy_extractor:283">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mi>e</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>e</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Rep
  </annotation>
 </semantics>
</math>

 will output fail with very high probability. To cause the algorithm accept a different 

<math display="inline" id="Fuzzy_extractor:284">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 an adversary would have to find a 

<math display="inline" id="Fuzzy_extractor:285">
 <semantics>
  <mover accent="true">
   <mi>w</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{w}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Fuzzy_extractor:286">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>w</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo>,</mo>
     <mover accent="true">
      <mi>s</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">1</cn>
     </apply>
     <interval closure="open">
      <ci>w</ci>
      <ci>s</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">1</cn>
     </apply>
     <interval closure="open">
      <apply>
       <ci>normal-~</ci>
       <ci>w</ci>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>s</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(w,s)=H_{1}(\tilde{w},\tilde{s})
  </annotation>
 </semantics>
</math>

. Since hash function are believed to be <a href="one_way_function" title="wikilink">one way functions</a>, it is computationally infeasible to find such a 

<math display="inline" id="Fuzzy_extractor:287">
 <semantics>
  <mover accent="true">
   <mi>w</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{w}
  </annotation>
 </semantics>
</math>

. Seeing 

<math display="inline" id="Fuzzy_extractor:288">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 would provide the adversary with no useful information. Since, again, hash function are one way functions, it is computationally infeasible for the adversary to reverse the hash function and figure out 

<math display="inline" id="Fuzzy_extractor:289">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. Part of 

<math display="inline" id="Fuzzy_extractor:290">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is the secure sketch, but by definition the sketch reveals negligible information about its input. Similarly seeing 

<math display="inline" id="Fuzzy_extractor:291">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

(even though it should never see it) would provide the adversary with no useful information as the adversary wouldn't be able to reverse the hash function and see the biometric input.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.cs.bu.edu/~reyzin/fuzzysurvey.html">Fuzzy Extractors: A Brief Survey of Results from 2004 to 2006</a></li>
<li><a href="http://www.cs.ucla.edu/~rafail/PUBLIC/89.pdf">Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data</a></li>
<li><a href="http://digital.csic.es/bitstream/10261/15966/1/SAM3262.pdf">Biometric Fuzzy Extractor Scheme for Iris Templates</a></li>
<li><a href="http://people.csail.mit.edu/madhu/papers/2002/ari-journ.pdf">A Fuzzy Vault Scheme</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Biometrics" title="wikilink">Category:Biometrics</a> <a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Cryptographic_algorithms" title="wikilink">Category:Cryptographic algorithms</a></p>
</body>
</html>
