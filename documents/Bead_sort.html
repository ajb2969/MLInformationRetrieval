<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="373">Bead sort</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bead sort</h1>
<hr/>

<p><strong>Bead sort</strong> is a <a href="natural_algorithm" title="wikilink">natural</a> <a href="sorting_algorithm" title="wikilink">sorting algorithm</a>, developed by <a href="Joshua_J._Arulanandham" title="wikilink">Joshua J. Arulanandham</a>, <a href="Cristian_S._Calude" title="wikilink">Cristian S. Calude</a> and <a href="Michael_J._Dinneen" title="wikilink">Michael J. Dinneen</a> in 2002, and published in The Bulletin of the <a href="European_Association_for_Theoretical_Computer_Science" title="wikilink">European Association for Theoretical Computer Science</a>. Both <a href="Digital_data" title="wikilink">digital</a> and <a href="analog_computer" title="wikilink">analog</a> hardware <a href="implementation" title="wikilink">implementations</a> of bead sort can achieve a sorting time of <em><a href="Big_O_Notation" title="wikilink">O</a></em>(<em>n</em>); however, the implementation of this algorithm tends to be significantly slower in <a class="uri" href="software" title="wikilink">software</a> and can only be used to sort lists of <a href="positive_integer" title="wikilink">positive integers</a>. Also, it would seem that even in the best case, the algorithm requires <em><a href="Big_O_Notation" title="wikilink">O</a></em>(<em>n<sup>2</sup></em>) space.</p>
<h2 id="algorithm-overview">Algorithm overview</h2>

<p>  The bead sort operation can be compared to the manner in which beads slide on parallel poles, such as on an <a class="uri" href="abacus" title="wikilink">abacus</a>. However, each pole may have a distinct number of beads. Initially, it may be helpful to imagine the beads suspended on vertical poles. In Step 1, such an arrangement is displayed using <em>n=5</em> rows of beads on <em>m=4</em> vertical poles. The numbers to the right of each row indicate the number that the row in question represents; rows 1 and 2 are representing the positive integer 3 (because they each contain three beads) while the top row represents the positive integer 2 (as it only contains two beads).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>If we then allow the beads to fall, the rows now represent the same integers in sorted order. Row 1 contains the largest number in the set, while row <em>n</em> contains the smallest. If the above-mentioned convention of rows containing a series of beads on poles 1..<em>k</em> and leaving poles <em>k</em>+1..<em>m</em> empty has been followed, it will continue to be the case here.</p>

<p>The action of allowing the beads to "fall" in our physical example has allowed the larger values from the higher rows to propagate to the lower rows. If the value represented by row <em>a</em> is smaller than the value contained in row <em>a+1</em>, some of the beads from row <em>a+1</em> will fall into row <em>a</em>; this is certain to happen, as row <em>a</em> does not contain beads in those positions to stop the beads from row <em>a+1</em> from falling.</p>

<p>The mechanism underlying bead sort is similar to that behind <a href="counting_sort" title="wikilink">counting sort</a>; the number of beads on each pole corresponds to the number of elements with value equal or greater than the index of that pole.</p>
<h2 id="complexity">Complexity</h2>

<p>Bead sort can be implemented with four general levels of complexity, among others:</p>
<ul>
<li><em><a href="Big_O_Notation" title="wikilink">O</a></em>(1): The beads are all moved simultaneously in the same time unit, as would be the case with the simple physical example above. This is an abstract complexity, and cannot be implemented in practice.</li>
<li><em><a href="Big_O_Notation" title="wikilink">O</a></em>(

<math display="inline" id="Bead_sort:0">
 <semantics>
  <msqrt>
   <mi>n</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n}
  </annotation>
 </semantics>
</math>

): In a realistic physical model that uses gravity, the time it takes to let the beads fall is proportional to the square root of the maximum height, which is proportional to n.</li>
<li><em><a href="Big_O_Notation" title="wikilink">O</a></em>(n): The beads are moved one row at a time. This is the case used in the analog and <a href="digital_hardware" title="wikilink">digital hardware</a> solutions.</li>
<li><em><a href="Big_O_Notation" title="wikilink">O</a></em>(S), where S is the sum of the integers in the input set: Each bead is moved individually. This is the case when bead sort is implemented without a mechanism to assist in finding empty spaces below the beads, such as in software implementations.</li>
</ul>

<p>Like the <a href="Pigeonhole_sort" title="wikilink">Pigeonhole sort</a>, bead sort is unusual in that it can perform faster than <em><a href="Big_O_Notation" title="wikilink">O</a></em>(<em>n</em><a href="logarithm" title="wikilink">log</a><em>n</em>), the fastest performance possible for a <a href="comparison_sort" title="wikilink">comparison sort</a>. This is possible because the key for a bead sort is always a positive integer and bead sort exploits its structure.</p>
<h2 id="references-and-notes">References and notes</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://mgs.spatial-computing.org/ImageGallery/EXEMPLES/BeadSort/index.html">Bead Sort in MGS</a>, a visualization of a bead sort implemented in the <a href="http://mgs.spatial-computing.org">MGS</a> programming language</li>
<li><a href="http://mathworld.wolfram.com/Bead-Sort.html">Bead Sort on MathWorld</a></li>
</ul>

<p>"</p>

<p><a href="Category:Sorting_algorithms" title="wikilink">Category:Sorting algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">By convention, a row representing the positive integer <em>k</em> should have beads on poles 1..<em>k</em> and poles <em>k</em>+1..<em>m</em> should be empty. This is not a strict requirement, but will most likely simplify implementation.<a href="#fnref1">â†©</a></li>
</ol>
</section>
</body>
</html>
