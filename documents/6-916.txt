   C++ Technical Report 1      C++ Technical Report 1  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     C++ Technical Report 1 ( TR1 ) is the common name for ISO/IEC TR 19768, C++ Library Extensions , which was a document proposing additions to the C++ standard library for the C++03 language standard. The additions include regular expressions , smart pointers , hash tables , and random number generators . TR1 was not a standard itself, but rather a draft document. However, most of its proposals became part of the later official standard, C++11 . Before C++11 was standardized, vendors used this document as a guide to create extensions. The report's goal was "to build more widespread existing practice for an expanded C++ standard library."  The report was first circulated in draft form in 2005 as Draft Technical Report on C++ Library Extensions , then published in 2007 as an ISO/IEC standard as [ http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2; ;=60&ics3;=&csnumber;=43289 ISO/IEC TR 19768:2007].  Overview  Compilers did not need to include the TR1 components in order to conform to the C++ standard, because TR1 proposals were not part of the standard itself, only a set of possible additions that were still to be ratified. However, most of TR1 was available from Boost , and several compiler/library distributors implemented all or some of the components. TR1 is not the complete list of additions to the library to appear in the next standard, C++11 . For example, C++11 includes a thread support library that is not available in TR1.  The new components were defined in the std::tr1  namespace to distinguish them from the then-current standard library.  There is also a second technical report, C++ Technical Report 2 , planned to be published after C++11. 1  Components  TR1 includes the following components:  General utilities  Reference wrapper – enables passing references , rather than copies, into algorithms or function objects. The feature was based on Boost.Ref. 2 A wrapper reference is obtained from an instance of the template class reference_wrapper . Wrapper references are similar to normal references (‘&’) of the C++ language. To obtain a wrapper reference from any object the template class ref is used (for a constant reference cref is used).  Wrapper references are useful above all for template functions, when argument deduction would not deduce a reference (e.g. when forwarding arguments):  #include  #include  void f( int &r; )  { ++r; } template < class Funct, class Arg > void g( Funct f, Arg t )
 {
   f(t);
 } int main()
 { int i = 0 ;
 
   g( f, i ); // 'g< void(int &r;), int >' is instantiated std::cout << i << " \n " ; // Output: 0 g( f, std::tr1::ref(i) ); // 'g< void(int &r;), reference_wrapper >' is instanced std::cout << i << " \n " ; // Output: 1 } <span class="dt" int > Smart pointers – adds several classes that simplify object lifetime management in complex cases. Three main classes are added:   shared_ptr – a reference-counted smart pointer  weak_ptr – a variant of shared_ptr that doesn't increase the reference count   The proposal is based on Boost Smart Pointer library. 3  Function objects  These four modules are added to the header file:  Polymorphic function wrapper ( function ) – can store any callable function (function pointers, member function pointers, and function objects) that uses a specified function call signature. The type does not depend on the kind of the callable used. Based on Boost.Function 4  Function object binders ( bind ) – can bind any parameter parameters to function objects. Function composition is also allowed. This is a generalized version of the standard std::bind1st and std::bind2nd bind functions. The feature is based on Boost Bind library. 5  Function return types ( result_of ) – determines the type of a call expression.  mem_fn – enhancement to the standard std::mem_fun and std::mem_fun_ref . Allows pointers to member functions to be treated as function objects. Based on Boost Mem Fn library. 6  Metaprogramming and type traits  There is now header file that contains many useful trait meta-templates, such as is_pod , has_virtual_destructor , remove_extent , etc. It facilitates metaprogramming by enabling queries on and transformation between different types . The proposal is based on Boost Type Traits library. 7  Numerical facilities  Random number generation   new header file – variate_generator , [[Mersenne Twister|mersenne_twister]] , [[Poisson Distribution|poisson_distribution]] , etc.  utilities for generating random numbers using any of several Pseudorandom number generators , engines, and probability distributions   Mathematical special functions  Some features of TR1, such as the mathematical special functions and certain C99 additions, are not included in the Visual C++ implementation of TR1. The Mathematical special functions library was not standardized in C++11.   additions to the / header files – [[Beta function|beta]] , [[Legendre polynomials|legendre]] , etc.   These functions will likely be of principal interest to programmers in the engineering and scientific disciplines.  The following table shows all 23 special functions described in TR1.      Function name   Function prototype   Mathematical expression       Associated Laguerre polynomials   double assoc_laguerre ( unsigned n, unsigned m, double x ) ;          L  n    m    (  x  )    =     (   -  1   )   m     d  m    d   x  m      L   n  +  m     (  x  )     ,    for  x   ≥  0      formulae-sequence       superscript   subscript  L  n   m   x      superscript    1   m      superscript  d  m     d   superscript  x  m      subscript  L    n  m    x        for  x   0     {L_{n}}^{m}(x)=(-1)^{m}\frac{d^{m}}{dx^{m}}L_{n+m}(x),\text{ for }x\geq 0        Associated Legendre polynomials   double assoc_legendre ( unsigned l, unsigned m, double x ) ;          P  l    m    (  x  )    =     (   1  -   x  2    )    m  /  2      d  m    d   x  m      P  l    (  x  )     ,    for  x   ≥  0      formulae-sequence       superscript   subscript  P  l   m   x      superscript    1   superscript  x  2      m  2       superscript  d  m     d   superscript  x  m      subscript  P  l   x        for  x   0     {P_{l}}^{m}(x)=(1-x^{2})^{m/2}\frac{d^{m}}{dx^{m}}P_{l}(x),\text{ for }x\geq 0        Beta function   double beta ( double x, double y ) ;         \Beta    (  x  ,  y  )    =    Γ   (  x  )   Γ   (  y  )     Γ   (   x  +  y   )           \Beta   x  y        normal-Γ  x  normal-Γ  y     normal-Γ    x  y       \Beta(x,y)=\frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}        Complete elliptic integral of the first kind   double comp_ellint_1 ( double k ) ;        K   (  k  )    =   F   (  k  ,   π  2   )    =    ∫  0   π  2      d  θ     1  -    k  2     sin  2   θ                K  k     F   k    π  2            superscript   subscript   0     π  2        d  θ       1     superscript  k  2     superscript   2   θ           K(k)=F\left(k,\textstyle\frac{\pi}{2}\right)=\int_{0}^{\frac{\pi}{2}}\frac{d%
 \theta}{\sqrt{1-k^{2}\sin^{2}\theta}}        Complete elliptic integral of the second kind   double comp_ellint_2 ( double k ) ;        E   (  k  ,   π  2   )    =    ∫  0   π  2        1  -    k  2     sin  2   θ       d  θ          E   k    π  2       superscript   subscript   0     π  2          1     superscript  k  2     superscript   2   θ      d  θ      E\left(k,\textstyle\frac{\pi}{2}\right)=\int_{0}^{\frac{\pi}{2}}\sqrt{1-k^{2}%
 \sin^{2}\theta}\;d\theta        Complete elliptic integral of the third kind   double comp_ellint_3 ( double k, double nu ) ;        Π   (  ν  ,  k  ,   π  2   )    =    ∫  0   π  2      d  θ     (   1  -   ν    sin  2   θ     )     1  -    k  2     sin  2   θ               normal-Π   ν  k    π  2       superscript   subscript   0     π  2        d  θ       1    ν    superscript   2   θ         1     superscript  k  2     superscript   2   θ           \Pi\left(\nu,k,\textstyle\frac{\pi}{2}\right)=\int_{0}^{\frac{\pi}{2}}\frac{d%
 \theta}{(1-\nu\sin^{2}\theta)\sqrt{1-k^{2}\sin^{2}\theta}}        Confluent hypergeometric functions   double conf_hyperg ( double a, double c, double x ) ;        F   (  a  ,  c  ,  x  )    =     Γ   (  c  )     Γ   (  a  )       ∑   n  =  0   ∞     Γ   (   a  +  n   )    x  n     Γ   (   c  +  n   )    n  !             F   a  c  x          normal-Γ  c     normal-Γ  a      superscript   subscript     n  0          normal-Γ    a  n    superscript  x  n      normal-Γ    c  n     n         F(a,c,x)=\frac{\Gamma(c)}{\Gamma(a)}\sum_{n=0}^{\infty}\frac{\Gamma(a+n)x^{n}}%
 {\Gamma(c+n)n!}        Regular modified cylindrical Bessel functions   double cyl_bessel_i ( double nu, double x ) ;          I  ν    (  x  )    =    i   -  ν     J  ν    (   i  x   )    =    ∑   k  =  0   ∞      (   x  /  2   )    ν  +   2  k       k  !   Γ   (   ν  +  k  +  1   )       ,    for  x   ≥  0      formulae-sequence         subscript  I  ν   x      superscript  i    ν     subscript  J  ν     i  x           superscript   subscript     k  0         superscript    x  2     ν    2  k         k   normal-Γ    ν  k  1            for  x   0     I_{\nu}(x)=i^{-\nu}J_{\nu}(ix)=\sum_{k=0}^{\infty}\frac{(x/2)^{\nu+2k}}{k!\;%
 \Gamma(\nu+k+1)},\text{ for }x\geq 0        Cylindrical Bessel functions of the first kind   double cyl_bessel_j ( double nu, double x ) ;          J  ν    (  x  )    =    ∑   k  =  0   ∞        (   -  1   )   k      (   x  /  2   )    ν  +   2  k        k  !   Γ   (   ν  +  k  +  1   )       ,    for  x   ≥  0      formulae-sequence       subscript  J  ν   x     superscript   subscript     k  0           superscript    1   k    superscript    x  2     ν    2  k          k   normal-Γ    ν  k  1           for  x   0     J_{\nu}(x)=\sum_{k=0}^{\infty}\frac{(-1)^{k}\;(x/2)^{\nu+2k}}{k!\;\Gamma(\nu+k%
 +1)},\text{ for }x\geq 0        Irregular modified cylindrical Bessel functions   double cyl_bessel_k ( double nu, double x ) ;           K  ν    (  x  )        =    π  2    i   ν  +  1     (     J  ν    (   i  x   )    +   i   N  ν    (   i  x   )     )            =   {           I   -  ν     (  x  )    -    I  ν    (  x  )      sin   ν  π      ,       for  x   ≥   0  and  ν   ∉  ℤ           π  2      lim   μ  →  ν         I   -  μ     (  x  )    -    I  μ    (  x  )      sin   μ  π        ,       for  x   <   0  and  ν   ∈  ℤ                 subscript  K  ν   x     absent      π  2    superscript  i    ν  1         subscript  J  ν     i  x      i   subscript  N  ν     i  x          missing-subexpression     absent   cases         subscript  I    ν    x      subscript  I  ν   x        ν  π           for  x     0  and  ν        ℤ        π  2     subscript    normal-→  μ  ν           subscript  I    μ    x      subscript  I  μ   x        μ  π             for  x     0  and  ν        ℤ         \begin{aligned}\displaystyle K_{\nu}(x)&\displaystyle=\textstyle\frac{\pi}{2}i%
 ^{\nu+1}\big(J_{\nu}(ix)+iN_{\nu}(ix)\big)\\
 &\displaystyle=\begin{cases}\displaystyle\frac{I_{-\nu}(x)-I_{\nu}(x)}{\sin\nu%
 \pi},&\text{for }x\geq 0\text{ and }\nu\notin\mathbb{Z}\\
 \displaystyle\frac{\pi}{2}\lim_{\mu\to\nu}\frac{I_{-\mu}(x)-I_{\mu}(x)}{\sin%
 \mu\pi},&\text{for }x<0\text{ and }\nu\in\mathbb{Z}\\
 \end{cases}\end{aligned}        Cylindrical Neumann functions   Cylindrical Bessel functions of the second kind   double cyl_neumann ( double nu, double x ) ;     Incomplete elliptic integral of the first kind   double ellint_1 ( double k, double phi ) ;         F   (  k  ,  ϕ  )    =    ∫  0  ϕ     d  θ     1  -    k  2     sin  2   θ         ,    for   |  k  |    ≤  1      formulae-sequence      F   k  ϕ      superscript   subscript   0   ϕ       d  θ       1     superscript  k  2     superscript   2   θ             for    k    1     F(k,\phi)=\int_{0}^{\phi}\frac{d\theta}{\sqrt{1-k^{2}\sin^{2}\theta}},\text{ %
 for }\left|k\right|\leq 1        Incomplete elliptic integral of the second kind   double ellint_2 ( double k, double phi ) ;         E   (  k  ,  ϕ  )    =     ∫  0  ϕ       1  -    k  2     sin  2   θ      d  θ     ,    for   |  k  |    ≤  1      formulae-sequence      E   k  ϕ      superscript   subscript   0   ϕ         1     superscript  k  2     superscript   2   θ      d  θ         for    k    1     \displaystyle E(k,\phi)=\int_{0}^{\phi}\sqrt{1-k^{2}\sin^{2}\theta}d\theta,%
 \text{ for }\left|k\right|\leq 1        Incomplete elliptic integral of the third kind   double ellint_3 ( double k, double nu, double phi ) ;         Π   (  k  ,  ν  ,  ϕ  )    =    ∫  0  ϕ     d  θ     (   1  -   ν    sin  2   θ     )     1  -    k  2     sin  2   θ          ,    for   |  k  |    ≤  1      formulae-sequence      normal-Π   k  ν  ϕ      superscript   subscript   0   ϕ       d  θ       1    ν    superscript   2   θ         1     superscript  k  2     superscript   2   θ              for    k    1     \Pi(k,\nu,\phi)=\int_{0}^{\phi}\frac{d\theta}{\left(1-\nu\sin^{2}\theta\right)%
 \sqrt{1-k^{2}\sin^{2}\theta}},\text{ for }\left|k\right|\leq 1        Exponential integral   double expint ( double x ) ;        E  i   (  x  )    =   -    ∫   -  x   ∞       e   -  t    t    d  t           E  i  x       superscript   subscript     x           superscript  e    t    t   d  t       \mbox{E}i(x)=-\int_{-x}^{\infty}\frac{e^{-t}}{t}\,dt        Hermite polynomials   double hermite ( unsigned n, double x ) ;         H  n    (  x  )    =     (   -  1   )   n    e   x  2      d  n    d   x  n      e   -   x  2             subscript  H  n   x      superscript    1   n    superscript  e   superscript  x  2       superscript  d  n     d   superscript  x  n      superscript  e     superscript  x  2        H_{n}(x)=(-1)^{n}e^{x^{2}}\frac{d^{n}}{dx^{n}}e^{-x^{2}}\,\!        Hypergeometric series   double hyperg ( double a, double b, double c, double x ) ;        F   (  a  ,  b  ,  c  ,  x  )    =     Γ   (  c  )     Γ   (  a  )   Γ   (  b  )       ∑   n  =  0   ∞      Γ   (   a  +  n   )   Γ   (   b  +  n   )     Γ   (   c  +  n   )       x  n    n  !             F   a  b  c  x          normal-Γ  c     normal-Γ  a  normal-Γ  b      superscript   subscript     n  0            normal-Γ    a  n   normal-Γ    b  n      normal-Γ    c  n        superscript  x  n     n         F(a,b,c,x)=\frac{\Gamma(c)}{\Gamma(a)\Gamma(b)}\sum_{n=0}^{\infty}\frac{\Gamma%
 (a+n)\Gamma(b+n)}{\Gamma(c+n)}\frac{x^{n}}{n!}        Laguerre polynomials   double laguerre ( unsigned n, double x ) ;          L  n    (  x  )    =     e  x    n  !      d  n    d   x  n      (    x  n    e   -  x     )     ,    for  x   ≥  0      formulae-sequence       subscript  L  n   x        superscript  e  x     n       superscript  d  n     d   superscript  x  n        superscript  x  n    superscript  e    x           for  x   0     L_{n}(x)=\frac{e^{x}}{n!}\frac{d^{n}}{dx^{n}}\left(x^{n}e^{-x}\right),\text{ %
 for }x\geq 0        Legendre polynomials   double legendre ( unsigned l, double x ) ;          P  l    (  x  )    =    1    2  l    l  !       d  l    d   x  l       (    x  2   -  1   )   l     ,    for   |  x  |    ≤  1      formulae-sequence       subscript  P  l   x       1     superscript  2  l     l        superscript  d  l     d   superscript  x  l      superscript     superscript  x  2   1   l         for    x    1     P_{l}(x)={1\over 2^{l}l!}{d^{l}\over dx^{l}}(x^{2}-1)^{l},\text{ for }\left|x%
 \right|\leq 1        Riemann zeta function   double riemann_zeta ( double x ) ;         \Zeta    (  x  )    =   {         ∑   k  =  1   ∞     k   -  x     ,       for  x   >  1          2  x    π   x  -  1     sin   (     x  π   2    )    Γ   (   1  -  x   )   ζ   (   1  -  x   )    ,       for  x   <  1             \Zeta  x    cases    superscript   subscript     k  1       superscript  k    x         for  x   1      superscript  2  x    superscript  π    x  1          x  π   2    normal-Γ    1  x   ζ    1  x        for  x   1      \Zeta(x)=\begin{cases}\displaystyle\sum_{k=1}^{\infty}k^{-x},&\text{for }x>1\\
 \displaystyle 2^{x}\pi^{x-1}\sin\left(\frac{x\pi}{2}\right)\Gamma(1-x)\zeta(1-%
 x),&\text{for }x<1\\
 \end{cases}        Spherical Bessel functions of the first kind   double sph_bessel ( unsigned n, double x ) ;          j  n    (  x  )    =     π   2  x      J   n  +   1  /  2      (  x  )     ,    for  x   ≥  0      formulae-sequence       subscript  j  n   x         π    2  x      subscript  J    n    1  2     x        for  x   0     j_{n}(x)=\sqrt{\frac{\pi}{2x}}J_{n+1/2}(x),\text{ for }x\geq 0        Spherical associated Legendre functions   double sph_legendre ( unsigned l, unsigned m, double theta ) ;          Y  l  m    (  θ  ,  0  )   where   Y  l  m    (  θ  ,  ϕ  )    =     (   -  1   )   m     [     (    2  l   +  1   )    4  π       (   l  -  m   )   !     (   l  +  m   )   !     ]    1  2     P  l  m    (   cos  θ   )    e   i  m  ϕ      ,    for   |  m  |    ≤  l      formulae-sequence       superscript   subscript  Y  l   m    θ  0   where   superscript   subscript  Y  l   m    θ  ϕ       superscript    1   m    superscript   delimited-[]          2  l   1     4  π          l  m        l  m         1  2     superscript   subscript  P  l   m     θ    superscript  e    normal-i  m  ϕ          for    m    l     Y_{l}^{m}(\theta,0)\text{ where }Y_{l}^{m}(\theta,\phi)=(-1)^{m}\left[\frac{(2%
 l+1)}{4\pi}\frac{(l-m)!}{(l+m)!}\right]^{1\over 2}P_{l}^{m}(\cos\theta)e^{%
 \mathrm{i}m\phi},\text{ for }|m|\leq l        Spherical Neumann functions   Spherical Bessel functions of the second kind   double sph_neumann ( unsigned n, double x ) ;     Each function has two additional variants. Appending the suffix ‘ f ’ or ‘ l ’ to a function name gives a function that operates on float or long double values respectively. For example:  float sph_neumannf( unsigned n, float x ) ; long  double sph_neumannl( unsigned n, long  double x ) ;  Containers  Tuple types   new header file – tuple  based on Boost Tuple library 8  vaguely an extension of the standard std::pair  fixed size collection of elements, which may be of different types   Fixed size array   new header file – array  taken from Boost Array library 9  as opposed to dynamic array types such as the standard std::vector   Hash tables   new , header files  they implement the unordered_set , unordered_multiset , unordered_map , and unordered_multimap classes, analogous to set , multiset , map , and multimap , respectively  unfortunately, unordered_set and unordered_multiset cannot be used with the set_union , set_intersection , set_difference , set_symmetric_difference , and includes standard library functions, which work for set and multiset   new implementation, not derived from an existing library, not fully API compatible with existing libraries  like all hash tables , often provide constant time lookup of elements but the worst case can be linear in the size of the container   Regular expressions   new header file – regex , regex_match , regex_search , regex_replace , etc.  based on Boost RegEx library 10  pattern matching library   C compatibility  C++ is designed to be compatible with the C programming language , but is not a strict superset of C due to diverging standards. TR1 attempts to reconcile some of these differences through additions to various headers in the C++ library, such as , , , etc. These changes help to bring C++ more in line with the C99 version of the C standard (not all parts of C99 are included in TR1).  Technical Report 2  In 2005, a request for proposals for a TR2 was made with a special interest in Unicode, XML/HTML, Networking and usability for novice programmers. 3 .  Some of the proposals included:   Threads 4  The Asio C++ library (networking 5 6 ).  Signals/Slots 7 8  Filesystem Library 9 – Based on the Boost Filesystem Library, for query/manipulation of paths, files and directories.  Boost Any Library 10  Lexical Conversion Library 11  New String Algorithms 12  Toward a More Complete Taxonomy of Algebraic Properties for Numeric Libraries in TR2 13  Adding heterogeneous comparison lookup to associative containers for TR2 14   After the call was issued for proposals for TR2, ISO procedures were changed, so there will not be a TR2. Instead, enhancements to C++ will be published in a number of Technical Specifications. Some of the proposals listed above are already included in the C++ standard or in draft versions of the Technical Specifications.  See also   C++11 , standard for the C++ programming language; the library improvements were based on TR1  C11 (C standard revision) , the most recent standard for the C programming language  Boost library , a large collection of portable C++ libraries, several of which were included in TR1  Standard Template Library , part of the current C++ Standard Library   Notes  References       External links   Scott Meyers' Effective C++: TR1 Information – contains links to the TR1 proposal documents which provide background and rationale for the TR1 libraries.   "  Category:C++ Standard Library     1 ↩  Chapter 22. Boost.Ref – Boost 1.48.0 ↩  Smart Pointers – Boost 1.48.0 ↩  Chapter 9. Boost.Function – Boost 1.48.0 ↩  Boost: bind.hpp documentation – Boost 1.48.0 ↩  Boost: mem_fn.hpp documentation – Boost 1.48.0 ↩  2 ↩  The Boost Tuple Library – Boost 1.48.0 ↩  Chapter 3. Boost.Array – Boost 1.48.0 ↩  Boost.Regex – Boost 1.36.0 ↩   