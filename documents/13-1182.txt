   Group testing      Group testing   In combinatorial mathematics , group testing refers to any procedure which breaks up the task of locating elements of a set which have certain properties into tests on subsets ("groups") rather than on individual elements. A familiar example of this type of technique is the false coin problem of recreational mathematics . In this problem there are n coins and one of them is false, weighing less than a real coin. The objective is to find the false coin, using a balance scale , in the fewest number of weighings. By repeatedly dividing the coins in half and comparing the two halves, the false coin can be found quickly as it is always in the lighter half. 1  Schemes for carrying out such group testing can be simple or complex and the tests involved at each stage may be different. Schemes in which the tests for the next stage depend on the results of the previous stages are called adaptive procedures , while schemes designed so that all the tests are known beforehand are called non-adaptive procedures . The structure of the scheme of the tests involved in a non-adaptive procedure is known as a pooling design .  Background  Robert Dorfman's paper in 1943 introduced the field of (Combinatorial) Group Testing. The motivation arose during the Second World War when the United States Public Health Service and the Selective service embarked upon a large scale project. The objective was to weed out all syphilitic men called up for induction. However, syphilis testing back then was expensive and testing every soldier individually would have been very cost heavy and inefficient. A basic breakdown of a test is:   Draw sample from a given individual  Perform required tests  Determine presence or absence of syphilis   Say we have   n   n   n   soldiers, then this method of testing leads to   n   n   n   tests. If we have 70-75% of the people infected then the method of individual testing would be reasonable. Our goal however, is to achieve effective testing in the more likely scenario where it does not make sense to test 100,000 people to get (say) 10 positives.  The feasibility of a more effective testing scheme hinges on the following property. We can combine blood samples and test a combined sample together to check if at least one soldier has syphilis.  Modern interest in these testing schemes has been rekindled by the Human Genome Project. 2  Formalization of the problem  We now formalize the group testing problem abstractly.       I  n  p  u  t   :      normal-:    I  n  p  u  t   absent    Input:   The total number of soldiers   n   n   n   , an upper bound on the number of infected soldiers   d   d   d   . The (unknown) information about which soldier is infected described as a vector     𝐱  =   (   x  1   ,   x  2   ,  …  ,   x  n   )       𝐱    subscript  x  1    subscript  x  2   normal-…   subscript  x  n      \mathbf{x}=(x_{1},x_{2},...,x_{n})   where     x  i   =  1       subscript  x  i   1    x_{i}=1   if the item   i   i   i   is infected else     x  i   =  0       subscript  x  i   0    x_{i}=0   .  The Hamming Weight of   𝐱   𝐱   \mathbf{x}   is defined as the number of     1  ′   s       superscript  1  normal-′   s    1^{\prime}s   in   x   x   x   . Hence,     |  x  |   ≤  d        x   d    |x|\leq d   where    |  x  |      x    |x|   is the Hamming weight . The vector   𝐱   𝐱   \mathbf{x}   is an implicit input since we do not know the positions of     1  ′   s       superscript  1  normal-′   s    1^{\prime}s   in the input. The only way to find out is to run the tests.  Formal notion of a Test  A query/test    S   S   S   is a subset of    [  n  ]     delimited-[]  n    [n]   . The answer to the query    S  ⊆   [  n  ]       S   delimited-[]  n     S\subseteq[n]   is defined as follows:       A   (  S  )    =   {       1  ,   if     ∑   k  ∈  S      x  k      ≥  1         0  ,  otherwise.              A  S    cases     1    if    subscript     k  S     subscript  x  k      1   otherwise   0  otherwise.   otherwise     A(S)=\begin{cases}1,\mbox{ if }\displaystyle\sum_{k\in S}x_{k}\geq 1\\
 0,\mbox{ otherwise.}\end{cases}     Note that the addition operation used by the summation is the logical-    O  R      O  R    OR   , i.e.       A   (  S  )    =     ⋁   i  ∈  S      x  i          A  S     subscript     i  S     subscript  x  i      A(S)=\displaystyle\bigvee_{i\in S}x_{i}   .  Goal  Compute   𝐱   𝐱   \mathbf{x}   and minimize the number of tests required to determine   𝐱   𝐱   \mathbf{x}     The question boils down to one of Combinatorial Searching . Combinatorial searching in general can be explained as follows: Say you have a set of   n   n   n   variables and each of these can take on   m   m   m   possible values. So, finding possible solutions that match a certain constraint is a problem of combinatorial searching. The major problem with such questions is that the solution can grow exponentially in the size of the input. Here, we have no direct questions or answers. Any piece of information can only be obtained using an indirect query.  Definition       t   (  d  ,  n  )    :      normal-:    t   d  n    absent    t(d,n):   Given a set of   n   n   n   items with   d   d   d   defects, the minimum number of tests that one would have to make to detect all the defective items is defined as    t   (  d  ,  n  )       t   d  n     t(d,n)   .  Consider the case when only one person in the group will test positive. Then if we tested in the naive way, in the best case we would at least have to test the first person to find out if he/she is infected. However, in the worst case one might have to end up testing the entire group and only the last person we test will turn out to really be the one who was infected. Hence,    1  ≤   t   (  d  ,  n  )    ≤  n        1    t   d  n         n     1\leq t(d,n)\leq n     Testing Methods  There are two basic principles via which the testing may be carried out:   Adaptive Group Testing is where we test a given subset of items and, we get the answer from the test. We then base the next test on the outcome of the current test.  Non-adaptive Group Testing on the other hand is when all the tests to be performed are decided a priori . 3   Definition        t  a    (  d  ,  n  )    :      normal-:     superscript  t  a    d  n    absent    t^{a}(d,n):   Given a set of   n   n   n   items with   d   d   d   defects,      t  a    (  d  ,  n  )    :      normal-:     superscript  t  a    d  n    absent    t^{a}(d,n):   is defined as the number of adaptive tests that one would have to make to detect all the defective items.  One should note that in the case of group testing for the Syphilis problem, non-adaptive group testing is crucial. This is because the soldiers might be spread out geographically and adaptive group testing will need a lot of co-ordination.  Mathematical representation of the set of non-adaptive tests  For,    S  ⊆   [  n  ]       S   delimited-[]  n     S\subseteq[n]   , define     χ  i   ∈    {  0  ,  1  }   n        subscript  χ  i    superscript   0  1   n     \chi_{i}\in\{0,1\}^{n}   such that     i  ∈  S   ⇔     χ  s    (  i  )    =  1      normal-⇔    i  S        subscript  χ  s   i   1     i\in S\Leftrightarrow\chi_{s}(i)=1   .   M   M   M   is a    t  ×  n      t  n    t\times n   matrix of    χ  i     subscript  χ  i    \chi_{i}   .   𝐱   𝐱   \mathbf{x}   is the input vector transposed and   𝐫   𝐫   \mathbf{r}   is the resultant. The construction is based on the grounds that for non-adaptive testing with   t   t   t   tests is represented by a    t  -     limit-from  t     t-   subset     S  i   ⊆   [  n  ]    (  1  ≤  i  ≤  t  )      fragments   subscript  S  i     fragments  normal-[  n  normal-]    fragments  normal-(  1   i   t  normal-)     S_{i}\subseteq[n](1\leq i\leq t)   .    χ  i     subscript  χ  i    \chi_{i}   for a given   i   i   i   is the    i   t  h      superscript  i    t  h     i^{th}   test.   M   M   M   test matrix where    m   i  ,  j      subscript  m   i  j     m_{i,j}   is one if for the    i   t  h      superscript  i    t  h     i^{th}   test,    j  ∈  S      j  S    j\in S   . Note that here multiplication is logical AND (   ⋀     \bigwedge   ) and addition is logical OR (   ⋁     \bigvee   ). Then,     M  ×  𝐱   =  𝐫        M  𝐱   𝐫    M\times\mathbf{x}=\mathbf{r}   where   𝐫   𝐫   \mathbf{r}   is the resultant of the matrix multiplication. To think of this in terms of testing, it is helpful to visualize matrix multiplication. Here,   𝐫   𝐫   \mathbf{r}   will have a 1 in position   i   i   i   if and only if there was a   1   1   1   in that position in both   M   M   M   and   𝐱   𝐱   \mathbf{x}   i.e. if that person was tested with that particular group and if he tested out to be positive.    M  =   (       m   1  ,  1    ⋯   m   1  ,  n          ⋮  ⋱  ⋮         m   t  ,  1    ⋯   m   t  ,  n        )       M       subscript  m   1  1    normal-⋯   subscript  m   1  n         normal-⋮  normal-⋱  normal-⋮        subscript  m   t  1    normal-⋯   subscript  m   t  n         M=\begin{pmatrix}m_{1,1}\cdots m_{1,n}\\
 \vdots\ddots\vdots\\
 m_{t,1}\cdots m_{t,n}\end{pmatrix}       𝐱  =    (      x  1       ⋮       x  n      )   𝐫   =   (      r  1       ⋮       r  t      )         𝐱       subscript  x  1     normal-⋮     subscript  x  n     𝐫           subscript  r  1     normal-⋮     subscript  r  t        \mathbf{x}=\begin{pmatrix}x_{1}\\
 \vdots\\
 x_{n}\end{pmatrix}\mathbf{r}=\begin{pmatrix}r_{1}\\
 \vdots\\
 r_{t}\end{pmatrix}     Bounds for testing on     t  a    (  d  ,  n  )        superscript  t  a    d  n     t^{a}(d,n)   and    t   (  d  ,  n  )       t   d  n     t(d,n)         1  ≤    t  a    (  d  ,  n  )    ≤   t   (  d  ,  n  )    ≤  n        1     superscript  t  a    d  n           t   d  n         n     1\leq t^{a}(d,n)\leq t(d,n)\leq n     The reason for      t  a    (  d  ,  n  )    ≤   t   (  d  ,  n  )           superscript  t  a    d  n      t   d  n      t^{a}(d,n)\leq t(d,n)   is due to the fact that any non-adaptive test can be performed by an adaptive test by running all of the tests in the first step of the adaptive test. Adaptive tests can be more efficient than non-adaptive tests since the test can be changed after certain things are discovered.  Lower bound on     t  a    (  d  ,  n  )        superscript  t  a    d  n     t^{a}(d,n)     Fix a valid group testing scheme with   t   t   t   tests. Now, for two distinct vectors   𝐱   𝐱   \mathbf{x}   and   𝐲   𝐲   \mathbf{y}   where      |  𝐱  |   ,   |  𝐲  |    ≤  d         𝐱     𝐲    d    |\mathbf{x}|,|\mathbf{y}|\leq d   , the resulting vectors will not be the same i.e.     𝐫   (  𝐱  )    ≠   𝐫   (  𝐲  )          𝐫  𝐱     𝐫  𝐲     \mathbf{r(x)}\neq\mathbf{r(y)}   . Here    𝐫   (  𝐱  )       𝐫  𝐱    \mathbf{r(x)}   is the resultant vector when   𝐱   𝐱   \mathbf{x}   . This is because, two valid inputs will never give us the same result. If this ever happened, then we would always have an error in finding both   𝐱   𝐱   \mathbf{x}   and   𝐲   𝐲   \mathbf{y}   . This gives us that the total number of distinct results is the volume of a Hamming Ball of radius   d   d   d   , centered about   n   n   n   i.e.    V  o   l  2    (  d  ,  n  )       V  o   subscript  l  2    d  n     Vol_{2}(d,n)   . However, for   t   t   t   bits, the total number of possible distinct vectors is    2  t     superscript  2  t    2^{t}   . Hence,     2  t   ≥   V  o   l  2    (  d  ,  n  )         superscript  2  t     V  o   subscript  l  2    d  n      2^{t}\geq Vol_{2}(d,n)   . Taking the   log     \log   on both sides gives us    t  ≥   log   {   V  o   l  2    (  d  ,  n  )    }        t      V  o   subscript  l  2    d  n       t\geq\log\{Vol_{2}(d,n)\}   .  Now,     V  o   l  2    (  d  ,  n  )    ≥   (      n      d      )   ≥    (   n  d   )   d           V  o   subscript  l  2    d  n     binomial  n  d         superscript    n  d   d      Vol_{2}(d,n)\geq{n\choose d}\geq(\frac{n}{d})^{d}   . Therefore, we will end up having to perform a minimum of    d   log   n  d        d      n  d      d\log{\frac{n}{d}}   tests.  Thus we have proved,      t  a    (  d  ,  n  )    ≥   d   log   n  d            superscript  t  a    d  n      d      n  d       t^{a}(d,n)\geq d\log\frac{n}{d}     Upper bound on     t  a    (  d  ,  n  )        superscript  t  a    d  n     t^{a}(d,n)           t  a    (  d  ,  n  )    ≤   O   (   d   log  n    )           superscript  t  a    d  n      O    d    n       t^{a}(d,n)\leq O(d\log{n})   .  Since we know that the upper bound on the number of positives is   d   d   d   , we run a binary search at most   d   d   d   times or until there are no more values to be found. To simplify the problem we try to give a testing sccheme that uses    O   (   log  n   )       O    n     O(\log{n})   adaptive tests to figure out a   i   i   i   such that     x  i   =  1       subscript  x  i   1    x_{i}=1   . The related problem is solved by splitting    [  n  ]     delimited-[]  n    [n]   in two halves and querying to find a   1   1   1   in one of those and then proceeding recursively to find the exact position in the half where the query returned a   1   1   1   . This will take    2   ⌈   log  n   ⌉       2      n      2\lceil\log{n}\rceil   time or if the first query is performed on the whole set, it will take     ⌈   log  n   ⌉   +  1          n    1    \lceil\log{n}\rceil+1   . Once a   1   1   1   is found, the search is then repeated after removing the    i   t  h      superscript  i    t  h     i^{th}   co-ordinate. This can be done at most   d   d   d   times. This justifies the running time of    O   (   d   log  n    )       O    d    n      O(d\log{n})   . For a full proof and an algorithm for the problem refer to: CSE545 at the University at Buffalo  Upper bound on    t   (  1  ,  n  )       t   1  n     t(1,n)          t   (  1  ,  n  )    ≤   ⌈   log  n   ⌉         t   1  n        n      t(1,n)\leq\lceil\log{n}\rceil   This upper bound is for the special case where    d  =  1      d  1    d=1   i.e. there is a maximum of 1 positive. In this case, the matrix multiplication gets simplified and the resultant   𝐫   𝐫   \mathbf{r}   represents the binary representation of   i   i   i   for test   i   i   i   . This gives a lower bound of    ⌈   log  n   ⌉        n     \lceil\log{n}\rceil   . Note that decoding becomes trivial because the binary representation of   i   i   i   gives us the location directly. The group test matrix here is just the parity check matrix    H  m     subscript  H  m    H_{m}   for the    [    2  m   -  1   ,    2  m   -  m  -  1   ,  3  ]        superscript  2  m   1      superscript  2  m   m  1   3    [2^{m}-1,2^{m}-m-1,3]    Hamming code .  Thus as the upper and lower bounds are the same, we have a tight bound for    t   (  d  ,  n  )       t   d  n     t(d,n)   when    d  =  1      d  1    d=1   . Such tight bounds are not known for general   d   d   d   .  Upper Bounds for Non-Adaptive Group Testing  For non-adaptive group testing upper bounds we shift focus toward disjunct matrices . Disjunct matrices have been used for many of the bounds because of their nice properties. Through use of different constructions of disjunct matrices it has been shown that     Ω   (     d  2    log  d     log  n    )    ≤   t   (  d  ,  n  )          normal-Ω       superscript  d  2     d      n       t   d  n      \Omega(\frac{d^{2}}{\log{d}}\log{n})\leq t(d,n)   . Also for upper bounds we currently have that (i)     t   (  d  ,  n  )    ≤   𝒪   (    d  2    log  n    )          t   d  n      𝒪     superscript  d  2     n       t(d,n)\leq\mathcal{O}(d^{2}\log{n})   (explicit construction) and (ii)     t   (  d  ,  n  )    ≤   𝒪   (    d  2     log  2   n    )          t   d  n      𝒪     superscript  d  2     superscript   2   n       t(d,n)\leq\mathcal{O}(d^{2}\log^{2}{n})   (strongly explicit construction). It is good to note that the current known lower bound for    t   (  d  ,  n  )       t   d  n     t(d,n)   is already a    d   log  d       d    d     \frac{d}{\log{d}}   factor larger than the upper bound for     t  a    (  d  ,  n  )        superscript  t  a    d  n     t^{a}(d,n)   . Another thing to note is that give the smallest upper bound and biggest lower bound they are only off by a factor of    1   log  d       1    d     \frac{1}{\log{d}}   which is fairly small.  See also   Disjunct Matrix  Robert Dorfman  Concatenated error correction codes  Hamming weight  Hamming code   Notes  References   Atri Rudra's course on Error Correcting Codes: Combinatorics, Algorithms, and Applications (Spring 2007), Lectures 7 .  Atri Rudra's course on Error Correcting Codes: Combinatorics, Algorithms, and Applications (Spring 2010), Lectures 10 , 11 , 28 , 29   Dorfman, R. The Detection of Defective Members of Large Populations. The Annals of Mathematical Statistics, 14(4), 436-440. Retrieved from 1  Du, D., & Hwang, F. (2006). Pooling Designs and Nonadaptive Group Testing. Boston: Twayne Publishers.  Ely Porat, Amir Rothschild: Explicit Non-adaptive Combinatorial Group Testing Schemes. ICALP (1) 2008: 748-759   "  Category:Combinatorics  Category:Design of experiments     A bit more precisely – if there are an odd number of coins to be weighed, pick one to put aside and divide the rest into two equal piles. If the two piles have equal weight, the bad coin is the one put aside, otherwise the one put aside was good and no longer has to be tested. ↩  ↩  ↩     