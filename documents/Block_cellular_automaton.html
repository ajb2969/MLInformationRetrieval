<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="642">Block cellular automaton</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Block cellular automaton</h1>
<hr/>

<p> A <strong>block cellular automaton</strong> or <strong>partitioning cellular automaton</strong> is a special kind of <a href="cellular_automaton" title="wikilink">cellular automaton</a> in which the lattice of cells is divided into non-overlapping blocks (with different partitions at different time steps) and the transition rule is applied to a whole block at a time rather than a single cell. Block cellular automata are useful for simulations of physical quantities, because it is straightforward to choose transition rules that obey physical constraints such as <a href="reversible_cellular_automaton" title="wikilink">reversibility</a> and <a href="Conservation_law_(physics)" title="wikilink">conservation laws</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="definition">Definition</h2>

<p>A block cellular automaton consists of the following components:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ul>
<li>A regular <a href="Lattice_(group)" title="wikilink">lattice</a> of cells</li>
<li>A finite set of the states that each cell may be in</li>
<li>A partition of the cells into a uniform <a class="uri" href="tessellation" title="wikilink">tessellation</a> in which each tile of the partition has the same size and shape</li>
<li>A rule for shifting the partition after each time step</li>
<li>A transition rule, a function that takes as input an assignment of states for the cells in a single tile and produces as output another assignment of states for the same cells.</li>
</ul>

<p>In each time step, the transition rule is applied simultaneously and synchronously to all of the tiles in the partition. Then, the partition is shifted and the same operation is repeated in the next time step, and so forth. In this way, as with any cellular automaton, the pattern of cell states changes over time to perform some nontrivial computation or simulation.</p>
<h2 id="neighborhoods">Neighborhoods</h2>

<p>The simplest partitioning scheme is probably the <strong>Margolus neighborhood</strong>, named after <a href="Norman_Margolus" title="wikilink">Norman Margolus</a>, who first studied block cellular automata using this neighborhood structure. In the Margolus neighborhood, the lattice is divided into 

<math display="inline" id="Block_cellular_automaton:0">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

-cell blocks (or 

<math display="inline" id="Block_cellular_automaton:1">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi mathvariant="normal">×</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>normal-×</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2×2
  </annotation>
 </semantics>
</math>

 squares in two dimensions, or 

<math display="inline" id="Block_cellular_automaton:2">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi mathvariant="normal">×</mi>
   <mn>2</mn>
   <mi mathvariant="normal">×</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>normal-×</ci>
    <cn type="integer">2</cn>
    <ci>normal-×</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2×2×2
  </annotation>
 </semantics>
</math>

 cubes in three dimensions, etc.) which are shifted by one cell (along each dimension) on alternate timesteps.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>A closely related technique due to K. Morita and M. Harao<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> consists in partitioning each cell into a finite number of parts, each part being devoted to some neighbor. The evolution proceeds by exchanging the corresponding parts between neighbors and then applying on each cell a purely local transformation 

<math display="inline" id="Block_cellular_automaton:3">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 depending only on the state of the cell (and not on the states of its neighbors). With such a construction scheme, the cellular automaton is guaranteed to be reversible if the local transformation 

<math display="inline" id="Block_cellular_automaton:4">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is itself a <a class="uri" href="bijection" title="wikilink">bijection</a>. This technique may be viewed as a block cellular automaton on a finer lattice of cells, formed by the parts of each larger cell; the blocks of this finer lattice alternate between the sets of parts within a single large cell and the sets of parts in neighboring cells that share parts with each other.</p>
<h2 id="reversibility-and-conservation">Reversibility and conservation</h2>

<p>As long as the rule for evolving each block is <a href="reversible_cellular_automaton" title="wikilink">reversible</a>, the entire automaton will also be. More strongly, in this case, the time-reversed behavior of the automaton can also be described as a block cellular automaton, with the same block structure and with a transition rule that inverts the original automaton's rule within each block. The converse is also true: if the blocks are not individually reversible, the global evolution cannot be reversible: if two different configurations <em>x</em> and <em>y</em> of a block lead to the same result state <em>z</em>, then a global configuration with <em>x</em> in one block would be indistinguishable after one step from the configuration in which the <em>x</em> is replaced by <em>y</em>. That is, a cellular automaton is reversible globally if and only if it is reversible at the block level.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>The ease of designing reversible block cellular automata, and of testing block cellular automata for reversibility, is in strong contrast to cellular automata with other non-block neighborhood structures, for which it is <a href="undecidable_problem" title="wikilink">undecidable</a> whether the automaton is reversible and for which the reverse dynamics may require much larger neighborhoods than the forward dynamics.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Any reversible cellular automaton may be simulated by a reversible block cellular automaton with a larger number of states; however, because of the undecidability of reversibility for non-block cellular automata, there is no computable bound on the radius of the regions in the non-block automaton that correspond to blocks in the simulation, and the translation from a non-block rule to a block rule is also not computable.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>Block cellular automata are also a convenient formalism in which to design rules that, in addition to reversibility, implement <a href="conservation_laws" title="wikilink">conservation laws</a> such as the conservation of particle number, conservation of momentum, etc.. For instance, if the rule within each block preserves the number of live cells in the block, then the global evolution of the automaton will also preserve the same number. This property is useful in the applications of cellular automata to physical simulation.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="simulation-by-conventional-cellular-automata">Simulation by conventional cellular automata</h2>

<p>As Toffoli and Margolus write,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> the block cellular automaton model does not introduce any additional power compared to a conventional cellular automaton that uses the same neighborhood structure at each time step: any block cellular automaton may be simulated on a conventional cellular automaton by using more states and a larger neighborhood. Specifically, let the two automata use the same lattice of cells, but let each state of the conventional automaton specify the state of the block automaton, the phase of its partition shifting pattern, and the position of the cell within its block. For instance, with the Margolus neighborhood, this would increase the number of states by a factor of eight: there are four possible positions that a cell may take in its 

<math display="inline" id="Block_cellular_automaton:5">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi mathvariant="normal">×</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>normal-×</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2×2
  </annotation>
 </semantics>
</math>

 block, and two phases to the partition. Additionally, let the neighborhood of the conventional automaton be the union of the blocks containing the given cell in the block cellular automaton. Then with this neighborhood and state structure, each update to the block automaton may be simulated by a single update to the conventional cellular automaton.</p>
<h2 id="applications">Applications</h2>

<p>Block cellular automata are commonly used to implement <a href="lattice_gas" title="wikilink">lattice gases</a> and other quasi-physical simulations, due to the ease of simulating physical constraints such as conservation laws in these systems.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> For instance, the Margolus model may be used to simulate the HPP lattice gas model, in which particles move in two perpendicular directions and scatter at right angles when they collide with each other. In the block cellular simulation of this model, the update rule moves each cell to the cell diagonally opposite in its block, except in the case that a cell contains two diagonally opposite particles, in which case they are replaced by the complementary pair of diagonally opposite particles. In this way, particles move diagonally and scatter according to the HPP model.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> An alternative rule that simulates the HPP lattice gas model with horizontal and vertical motion of particles, rather than with diagonal motion, involves rotating the contents of each block clockwise or counterclockwise in alternating phases, except again in the case that a cell contains two diagonally opposite particles, in which case it remains unchanged.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> In either of these models, momentum (the sum of the <a href="velocity" title="wikilink">velocity vectors</a> of the moving particles) is conserved, as well as their number, an essential property for simulating physical gases. However, the HPP models are somewhat unrealistic as a model of gas dynamics, because they have additional non-physical conservation rules: the total momentum within each line of motion, as well as the total momentum of the overall system, is conserved. More complex models based on the hexagonal grid avoid this problem.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>These automata may also be used to model the motion of grains of <a class="uri" href="sand" title="wikilink">sand</a> in sand piles and <a href="hourglass" title="wikilink">hourglasses</a>. In this application, one may use a Margolus neighborhood with an update rule that preserves the number of grains within each 

<math display="inline" id="Block_cellular_automaton:6">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi mathvariant="normal">×</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>normal-×</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2×2
  </annotation>
 </semantics>
</math>

 block but that moves each grain as far down within its block as possible. If a block includes two grains that are stacked vertically on top of each other, the transition function of the automaton replaces it by a block in which the grains are side-by-side, in effect allowing tall sand piles to topple and spread. This model is not reversible, but it still obeys a conservation law on the number of particles.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> A modified rule, using the same neighborhood but moving the particles sideways to the extent possible as well as down, allows the simulated sandpiles to spread even when they are not very steep.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> More sophisticated cellular automaton sand pile models are also possible, incorporating phenomena such as wind transport and friction.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>Margolus' original application for the block cellular automaton model was to the <a href="Billiard-ball_computer" title="wikilink">billiard ball model</a> of reversible computation, in which <a href="Boolean_logic" title="wikilink">Boolean logic</a> signals are simulated by moving particles and logic gates are simulated by <a href="elastic_collision" title="wikilink">elastic collisions</a> of those particles. It is possible, for instance, to perform billiard-ball computations in the two-dimensional Margolus model, with two states per cell, and with the number of live cells conserved by the evolution of the model. In the "BBM" rule that simulates the billiard-ball model in this way, signals consist of single live cells, moving diagonally. To accomplish this motion, the block transition function replaces a block containing a single live cell with another block in which the cell has been moved to the opposite corner of the block. Similarly, elastic collisions may be performed by a block transition function that replaces two diagonally opposite live cells by the other two cells of the block. In all other configurations of a block, the block transition function makes no change to its state. In this model, 

<math display="inline" id="Block_cellular_automaton:7">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi mathvariant="normal">×</mi>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>normal-×</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2×4
  </annotation>
 </semantics>
</math>

 rectangles of live cells (carefully aligned with respect to the partition) remain stable, and may be used as mirrors to guide the paths of the moving particles. For instance, the illustration of the Margolus neighborhood shows four particles and a mirror; if the next step uses the blue partition, then two particles are moving towards the mirror while the other two are about to collide, whereas if the next step uses the red partition, then two particles are moving away from the mirror and the other two have just collided and will move apart from each other.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h2 id="additional-rules">Additional rules</h2>

<p> Toffoli and Margolus<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> suggest two more reversible rules for the Margolus neighborhood with two-state cells that, while not motivated by physical considerations, lead to interesting dynamics.</p>
<h3 id="critters">Critters</h3>

<p>In the "Critters" rule, the transition function reverses the state of every cell in a block, except for a block with exactly two live cells which remains unchanged. Additionally, blocks with three live cells undergo a 180-degree rotation as well as the state reversal.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> This is a reversible rule, and it obeys conservation laws on the number of particles (counting a particle as a live cell in even phases and as a dead cell in odd phases) and on the parity of the number of particles along diagonal lines.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> Because it is reversible, initial states in which all cells take randomly chosen states remain unstructured throughout their evolution. However, when started with a smaller field of random cells centered within a larger region of dead cells, this rule leads to complex dynamics similar to those in <a href="Conway's_Game_of_Life" title="wikilink">Conway's Game of Life</a> in which many small patterns similar to life's <a href="Glider_(Conway's_Life)" title="wikilink">glider</a> escape from the central random area and interact with each other.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> Unlike the gliders in Life, reversibility and the conservation of particles together imply that when gliders crash together in Critters, at least one must escape, and often these crashes allow both incoming gliders to reconstitute themselves on different outgoing tracks. By means of such collisions, this rule can also simulate the billiard ball model of computing, although in a more complex way than the BBM rule.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> The Critters rule can also support more complex <a href="Spaceship_(cellular_automaton)" title="wikilink">spaceships</a> of varying speeds as well as <a href="Oscillator_(cellular_automaton)" title="wikilink">oscillators</a> with infinitely many different periods.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<h3 id="tron">Tron</h3>

<p> In the "Tron" rule, the transition function leaves each block unchanged except when all four of its cells have the same state, in which case their states are all reversed. Running this rule from initial conditions in the form of a rectangle of live cells, or from similar simple straight-edged shapes, leads to complex rectilinear patterns. Toffoli and Margolus also suggest that this rule can be used to implement a local synchronization rule that allows any Margolus-neighborhood block cellular automaton to be simulated using an <a href="asynchronous_cellular_automaton" title="wikilink">asynchronous cellular automaton</a>. In this simulation, each cell of an asynchronous automaton stores both a state for the simulated automaton and a second bit representing the <a href="parity_(mathematics)" title="wikilink">parity</a> of a timestamp for that cell; therefore, the resulting asynchronous automaton has twice as many states as the automaton it simulates. The timestamps are constrained to differ by at most one between adjacent cells, and any block of four cells whose timestamps all have the correct parity may be updated according to the block rule being simulated. When an update of this type is performed, the timestamp parities should also be updated according to the Tron rule, which necessarily preserves the constraint on adjacent timestamps. By performing local updates in this way, the evolution of each cell in the asynchronous automaton is identical to its evolution in the synchronous block automaton being simulated.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a><a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>The first three steps of the toothpick sequence and its emulation by a block cellular automaton with the Margolus neighborhood</figcaption>
</figure>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Toothpick_sequence" title="wikilink">Toothpick sequence</a>, a fractal pattern that can be emulated by cellular automata with the Margolus neighborhood</li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cise.ufl.edu/~skoehler/critters/index.html">Critters simulation</a>, Seth Koehler, Univ. of Florida</li>
</ul>

<p>"</p>

<p><a href="Category:Cellular_automata" title="wikilink">Category:Cellular automata</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6">. Reprinted in <a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">; <a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18">"5.5.4 Lattice Gases", in , pp. 165–169.<a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
</ol>
</section>
</body>
</html>
