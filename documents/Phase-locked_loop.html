<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1334">Phase-locked loop</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Phase-locked loop</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>A <strong>phase-locked loop</strong> or <strong>phase lock loop (PLL)</strong> is a <a href="control_system" title="wikilink">control system</a> that generates an output <a href="Signal_(electrical_engineering)" title="wikilink">signal</a> whose <a href="phase_(waves)" title="wikilink">phase</a> is related to the phase of an input signal. While there are several differing types, it is easy to initially visualize as an <a href="electronic_circuit" title="wikilink">electronic circuit</a> consisting of a variable frequency <a href="Electronic_oscillator" title="wikilink">oscillator</a> and a <a href="phase_detector" title="wikilink">phase detector</a>. The oscillator generates a periodic signal. The phase detector compares the phase of that signal with the phase of the input periodic signal and adjusts the oscillator to keep the phases matched. Bringing the output signal back toward the input signal for comparison is called a <a href="feedback_loop" title="wikilink">feedback loop</a> since the output is 'fed back' toward the input forming a loop.</p>

<p>Keeping the input and output phase in lock step also implies keeping the input and output frequencies the same. Consequently, in addition to synchronizing signals, a phase-locked loop can track an input frequency, or it can generate a frequency that is a multiple of the input frequency. These properties are used for computer clock synchronization, <a class="uri" href="demodulation" title="wikilink">demodulation</a>, and <a href="frequency_synthesis" title="wikilink">frequency synthesis</a>.</p>

<p>Phase-locked loops are widely employed in <a class="uri" href="radio" title="wikilink">radio</a>, <a class="uri" href="telecommunications" title="wikilink">telecommunications</a>, <a href="computer" title="wikilink">computers</a> and other electronic applications. They can be used to <a href="demodulation" title="wikilink">demodulate</a> a signal, recover a signal from a noisy communication channel, generate a stable frequency at multiples of an input frequency (<a href="frequency_synthesis" title="wikilink">frequency synthesis</a>), or distribute precisely timed clock pulses in digital logic circuits such as <a href="microprocessor" title="wikilink">microprocessors</a>. Since a single <a href="integrated_circuit" title="wikilink">integrated circuit</a> can provide a complete phase-locked-loop building block, the technique is widely used in modern electronic devices, with output frequencies from a fraction of a hertz up to many gigahertz.</p>
<h2 id="practical-analogies">Practical analogies</h2>
<h3 id="automobile-race-analogy">Automobile race analogy</h3>

<p>For a practical idea of what is going on, consider an auto race. There are many cars, and the driver of each of them wants to go around the track as fast as possible. Each lap corresponds to a complete cycle, and each car will complete dozens of laps per hour. The number of laps per hour (a speed) corresponds to an angular velocity (i.e. a frequency), but the number of laps (a distance) corresponds to a phase (and the conversion factor is the distance around the track loop).</p>

<p>During most of the race, each car is on its own and the driver of the car is trying to beat the driver of every other car on the course, and the phase of each car varies freely.</p>

<p>However, if there is an accident, a <a href="Safety_car" title="wikilink">pace car</a> comes out to set a safe speed. None of the race cars are permitted to pass the pace car (or the race cars in front of them), but each of the race cars wants to stay as close to the pace car as it can. While it is on the track, the pace car is a reference, and the race cars become phase-locked loops. Each driver will measure the phase difference (a distance in laps) between him and the pace car. If the driver is far away, he will increase his engine speed to close the gap. If he's too close to the pace car, he will slow down. The result is all the race cars lock on to the phase of the pace car. The cars travel around the track in a tight group that is a small fraction of a lap.</p>
<h3 id="clock-analogy">Clock analogy</h3>

<p>Phase can be proportional to time,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> so a phase difference can be a time difference. Clocks are, with varying degrees of accuracy, phase-locked (time-locked) to a master clock.</p>

<p>Left on its own, each clock will mark time at slightly different rates. A wall clock, for example, might be fast by a few seconds per hour compared to the reference clock at <a href="National_Institute_of_Standards_and_Technology" title="wikilink">NIST</a>. Over time, that time difference would become substantial.</p>

<p>To keep the wall clock in sync with the reference clock, each week the owner compares the time on his wall clock to a more accurate clock (a phase comparison), and he resets his clock. Left alone, the wall clock will continue to diverge from the reference clock at the same few seconds per hour rate.</p>

<p>Some clocks have a timing adjustment (a fast-slow control). When the owner compared his wall clock's time to the reference time, he noticed that his clock was too fast. Consequently, he could turn the timing adjust a small amount to make the clock run a little slower(frequency). If things work out right, his clock will be more accurate. Over a series of weekly adjustments, the wall clock's notion of a second would agree with the reference time (locked both in frequency and phase within the wall clock's stability).</p>

<p>An early <a class="uri" href="electromechanical" title="wikilink">electromechanical</a> version of a phase-locked loop was used in 1921 in the <a href="Shortt-Synchronome_clock" title="wikilink">Shortt-Synchronome clock</a>.</p>
<h2 id="history">History</h2>

<p>Spontaneous synchronization of weakly coupled pendulum clocks was noted by the Dutch physicist <a href="Christiaan_Huygens" title="wikilink">Christiaan Huygens</a> as early as 1673.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Around the turn of the 19th century, <a href="John_William_Strutt,_3rd_Baron_Rayleigh" title="wikilink">Lord Rayleigh</a> observed synchronization of weakly coupled organ pipes and tuning forks.<ref>See:</ref></p>
<ul>
<li>Lord Rayleigh, <em>The Theory of Sound</em> (London, England: Macmillan, 1896), vol. 2. The synchronization of organ pipes in opposed phase is mentioned in §322c, [<a class="uri" href="http://books.google.com/books?id=Zm9LAAAAMAAJ&amp;pg">http://books.google.com/books?id=Zm9LAAAAMAAJ&amp;pg;</a>;=PA221#v=onepage&amp;q;&amp;f;=false pages 221-222.]</li>
<li>Lord Rayleigh (1907) "Acoustical notes — VII," <em>Philosophical Magazine</em>, 6th series, <strong>13</strong> : 316-333. See "Tuning-forks with slight mutual influence," [<a class="uri" href="http://books.google.com/books?id=vVjKOdktZhsC&amp;pg">http://books.google.com/books?id=vVjKOdktZhsC&amp;pg;</a>;=PA322#v=onepage&amp;q;&amp;f;=false pages 322-323.] In 1919, <a href="William_Eccles" title="wikilink">W. H. Eccles</a> and J. H. Vincent found that two electronic oscillators that had been tuned to oscillate at slightly different frequencies but that were coupled to a resonant circuit would soon oscillate at the same frequency.<ref>See:</ref></li>
<li>Vincent (1919) "On some experiments in which two neighbouring maintained oscillatory circuits affect a resonating circuit," <em>Proceedings of the Physical Society of London</em>, <strong>32</strong>, pt. 2, 84-91.</li>
<li>W. H. Eccles and J. H. Vincent, <em>British Patent Specifications</em>, <strong>163</strong> : 462 (17 Feb. 1920). Automatic synchronization of electronic oscillators was described in 1923 by <a href="Edward_Victor_Appleton" title="wikilink">Edward Victor Appleton</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
</ul>

<p>Earliest research towards what was later named the phase-locked loop goes back to 1932, when British researchers developed an alternative to <a href="Edwin_Armstrong" title="wikilink">Edwin Armstrong</a>'s <a href="superheterodyne_receiver" title="wikilink">superheterodyne receiver</a>, the <a href="Homodyne_detection" title="wikilink">Homodyne</a> or <a href="direct-conversion_receiver" title="wikilink">direct-conversion receiver</a>. In the homodyne or synchrodyne system, a <a href="local_oscillator" title="wikilink">local oscillator</a> was tuned to the desired input frequency and multiplied with the input signal. The resulting output signal included the original modulation information. The intent was to develop an alternative receiver circuit that required fewer tuned circuits than the superheterodyne receiver. Since the local oscillator would rapidly drift in frequency, an automatic correction signal was applied to the oscillator, maintaining it in the same phase and frequency of the desired signal. The technique was described in 1932, in a paper by Henri de Bellescize, in the French journal <em>L'Onde Électrique</em>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>In analog television receivers since at least the late 1930s, phase-locked-loop horizontal and vertical sweep circuits are locked to synchronization pulses in the broadcast signal.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>When <a class="uri" href="Signetics" title="wikilink">Signetics</a> introduced a line of monolithic <a href="integrated_circuits" title="wikilink">integrated circuits</a> like the NE565 that were complete phase-locked loop systems on a chip in 1969,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> applications for the technique multiplied. A few years later RCA introduced the "<a href="List_of_4000_series_integrated_circuits" title="wikilink">CD4046</a>" <a class="uri" href="CMOS" title="wikilink">CMOS</a> Micropower Phase-Locked Loop, which became a popular integrated circuit.</p>
<h2 id="structure-and-function">Structure and function</h2>

<p>Phase-locked loop mechanisms may be implemented as either analog or digital circuits. Both implementations use the same basic structure.</p>

<p>Both analog and digital PLL circuits include four basic elements:</p>
<ul>
<li><a href="Phase_detector" title="wikilink">Phase detector</a>,</li>
<li><a href="Low-pass_filter" title="wikilink">Low-pass filter</a>,</li>
<li><a href="Variable-frequency_oscillator" title="wikilink">Variable-frequency oscillator</a>, and</li>
<li><a class="uri" href="feedback" title="wikilink">feedback</a> path (which may include a <a href="frequency_divider" title="wikilink">frequency divider</a>).</li>
</ul>
<h3 id="variations">Variations</h3>

<p>There are several variations of PLLs. Some terms that are used are analog phase-locked loop (APLL) also referred to as a linear phase-locked loop (LPLL), digital phase-locked loop (DPLL), all digital phase-locked loop (ADPLL), and software phase-locked loop (SPLL).<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<dl>
<dt>Analog or linear PLL (APLL): Phase detector is an analog multiplier. Loop filter is active or passive. Uses a <a href="Voltage-controlled_oscillator" title="wikilink">Voltage-controlled oscillator</a> (VCO).<br/>
Digital PLL (DPLL): An analog PLL with a digital phase detector (such as XOR, edge-trigger JK, phase frequency detector). May have digital divider in the loop.<br/>
All digital PLL (ADPLL): Phase detector, filter and oscillator are digital. Uses a <a href="numerically_controlled_oscillator" title="wikilink">numerically controlled oscillator</a> (NCO).<br/>
Software PLL (SPLL): Functional blocks are implemented by software rather than specialized hardware.<br/>
Neuronal PLL (NPLL): Phase detector, filter and oscillator are neurons or small neuronal pools. Uses a <a href="rate_controlled_oscillator" title="wikilink">rate controlled oscillator</a> (RCO). Used for tracking and decoding low frequency modulations (&lt; 1 kHz), such as those occurring during mammalian-like active sensing.</dt>
</dl>
<h3 id="performance-parameters">Performance parameters</h3>
<ul>
<li>Type and order</li>
<li>Lock range: The frequency range the PLL is able to stay locked. Mainly defined by the VCO range.</li>
<li>Capture range: The frequency range the PLL is able to lock-in, starting from unlocked condition. This range is usually smaller than the lock range and will depend, for example, on phase detector.</li>
<li>Loop bandwidth: Defining the speed of the control loop.</li>
<li>Transient response: Like overshoot and settling time to a certain accuracy (like 50ppm).</li>
<li>Steady-state errors: Like remaining phase or timing error.</li>
<li>Output spectrum purity: Like sidebands generated from a certain VCO tuning voltage ripple.</li>
<li>Phase-noise: Defined by noise energy in a certain frequency band (like 10 kHz offset from carrier). Highly dependent on VCO phase-noise, PLL bandwidth, etc.</li>
<li>General parameters: Such as power consumption, supply voltage range, output amplitude, etc.</li>
</ul>
<h2 id="applications">Applications</h2>

<p>Phase-locked loops are widely used for <a class="uri" href="synchronization" title="wikilink">synchronization</a> purposes; in space <a href="telecommunication" title="wikilink">communications</a> for <a href="coherent_demodulation" title="wikilink">coherent demodulation</a> and <a href="Noise_gate#Audio_noise_reduction" title="wikilink">threshold extension</a>, <a href="bit_synchronization" title="wikilink">bit synchronization</a>, and symbol synchronization. Phase-locked loops can also be used to <a class="uri" href="demodulate" title="wikilink">demodulate</a> <a href="frequency_modulation" title="wikilink">frequency-modulated</a> signals. In radio transmitters, a PLL is used to synthesize new frequencies which are a multiple of a reference frequency, with the same stability as the reference frequency.</p>

<p>Other applications include:</p>
<ul>
<li><a class="uri" href="Demodulation" title="wikilink">Demodulation</a> of both <a href="Frequency_modulation" title="wikilink">FM</a> and <a href="Amplitude_modulation" title="wikilink">AM</a> signals</li>
<li>Recovery of small signals that otherwise would be lost in noise (<a href="lock-in_amplifier" title="wikilink">lock-in amplifier</a> to track the reference frequency)</li>
<li>Recovery of clock timing information from a data stream such as from a <a href="disk_drive" title="wikilink">disk drive</a></li>
<li><a href="CPU_multiplier" title="wikilink">Clock multipliers</a> in <a class="uri" href="microprocessors" title="wikilink">microprocessors</a> that allow internal processor elements to run faster than external connections, while maintaining precise timing relationships</li>
<li><a class="uri" href="DTMF" title="wikilink">DTMF</a> decoders, <a href="modem" title="wikilink">modems</a>, and other tone decoders, for <a href="remote_control" title="wikilink">remote control</a> and <a class="uri" href="telecommunications" title="wikilink">telecommunications</a></li>
<li><a href="Digital_signal_processing" title="wikilink">DSP</a> of <a class="uri" href="video" title="wikilink">video</a> signals; Phase-locked loops are also used to synchronize phase and frequency to the input <a href="analog_video" title="wikilink">analog video</a> signal so it can be <a href="sample_(signal)" title="wikilink">sampled</a> and digitally processed</li>
<li><a href="Atomic_force_microscopy" title="wikilink">Atomic force microscopy</a> in tapping mode, to detect changes of the cantilever resonance frequency due to tip–surface interactions</li>
<li><a href="DC_motor" title="wikilink">DC motor</a> <a href="motor_controller" title="wikilink">drive</a></li>
</ul>
<h3 id="clock-recovery">Clock recovery</h3>

<p>Some data streams, especially high-speed serial data streams (such as the raw stream of data from the magnetic head of a disk drive), are sent without an accompanying clock. The receiver generates a clock from an approximate frequency reference, and then phase-aligns to the transitions in the data stream with a PLL. This process is referred to as <a href="clock_recovery" title="wikilink">clock recovery</a>. In order for this scheme to work, the data stream must have a transition frequently enough to correct any drift in the PLL's oscillator. Typically, some sort of <a href="line_code" title="wikilink">line code</a>, such as <a href="8b/10b_encoding" title="wikilink">8b/10b encoding</a>, is used to put a hard upper bound on the maximum time between transitions.</p>
<h3 id="deskewing">Deskewing</h3>

<p>If a clock is sent in parallel with data, that clock can be used to sample the data. Because the clock must be received and amplified before it can drive the flip-flops which sample the data, there will be a finite, and process-, temperature-, and voltage-dependent delay between the detected clock edge and the received data window. This delay limits the frequency at which data can be sent. One way of eliminating this delay is to include a deskew PLL on the receive side, so that the clock at each data flip-flop is phase-matched to the received clock. In that type of application, a special form of a PLL called a <a href="delay-locked_loop" title="wikilink">delay-locked loop</a> (DLL) is frequently used.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="clock-generation">Clock generation</h3>

<p>Many electronic systems include processors of various sorts that operate at hundreds of megahertz. Typically, the clocks supplied to these processors come from clock generator PLLs, which multiply a lower-frequency reference clock (usually 50 or 100 MHz) up to the operating frequency of the processor. The multiplication factor can be quite large in cases where the operating frequency is multiple gigahertz and the reference crystal is just tens or hundreds of megahertz.</p>
<h3 id="spread-spectrum">Spread spectrum</h3>

<p>All electronic systems emit some unwanted radio frequency energy. Various regulatory agencies (such as the <a href="Federal_Communications_Commission" title="wikilink">FCC</a> in the United States) put limits on the emitted energy and any interference caused by it. The emitted noise generally appears at sharp spectral peaks (usually at the operating frequency of the device, and a few harmonics). A system designer can use a spread-spectrum PLL to reduce interference with high-Q receivers by spreading the energy over a larger portion of the spectrum. For example, by changing the operating frequency up and down by a small amount (about 1%), a device running at hundreds of megahertz can spread its interference evenly over a few megahertz of spectrum, which drastically reduces the amount of noise seen on broadcast <a href="FM_broadcasting" title="wikilink">FM radio</a> channels, which have a bandwidth of several tens of kilohertz.</p>
<h3 id="clock-distribution">Clock distribution</h3>
<figure><b>(Figure)</b>
<figcaption>PLL usage.svg</figcaption>
</figure>

<p>Typically, the reference clock enters the chip and drives a phase locked loop (<strong>PLL</strong>), which then drives the system's clock distribution. The clock distribution is usually balanced so that the clock arrives at every endpoint simultaneously. One of those endpoints is the PLL's feedback input. The function of the PLL is to compare the distributed clock to the incoming reference clock, and vary the phase and frequency of its output until the reference and feedback clocks are phase and frequency matched.</p>

<p>PLLs are ubiquitous—they tune clocks in systems several feet across, as well as clocks in small portions of individual chips. Sometimes the reference clock may not actually be a pure clock at all, but rather a data stream with enough transitions that the PLL is able to recover a regular clock from that stream. Sometimes the reference clock is the same frequency as the clock driven through the clock distribution, other times the distributed clock may be some rational multiple of the reference.</p>
<h3 id="jitter-and-noise-reduction">Jitter and noise reduction</h3>

<p>One desirable property of all PLLs is that the reference and feedback clock edges be brought into very close alignment. The average difference in time between the phases of the two signals when the PLL has achieved lock is called the <strong>static phase offset</strong> (also called the <strong>steady-state phase error</strong>). The variance between these phases is called <strong>tracking <a class="uri" href="jitter" title="wikilink">jitter</a></strong>. Ideally, the static phase offset should be zero, and the tracking jitter should be as low as possible.</p>

<p><a href="Phase_noise" title="wikilink">Phase noise</a> is another type of jitter observed in PLLs, and is caused by the oscillator itself and by elements used in the oscillator's frequency control circuit. Some technologies are known to perform better than others in this regard. The best digital PLLs are constructed with emitter-coupled logic (<a href="Emitter_coupled_logic" title="wikilink">ECL</a>) elements, at the expense of high power consumption. To keep phase noise low in PLL circuits, it is best to avoid saturating logic families such as transistor-transistor logic (<a href="transistor-transistor_logic" title="wikilink">TTL</a>) or <a class="uri" href="CMOS" title="wikilink">CMOS</a>.</p>

<p>Another desirable property of all PLLs is that the phase and frequency of the generated clock be unaffected by rapid changes in the voltages of the power and ground supply lines, as well as the voltage of the substrate on which the PLL circuits are fabricated. This is called substrate and <a href="Power_supply_rejection_ratio" title="wikilink">supply noise rejection</a>. The higher the noise rejection, the better.</p>

<p>To further improve the phase noise of the output, an <a href="injection_locked_oscillator" title="wikilink">injection locked oscillator</a> can be employed following the VCO in the PLL.</p>
<h3 id="frequency-synthesis">Frequency synthesis</h3>

<p>In digital wireless communication systems (GSM, CDMA etc.), PLLs are used to provide the local oscillator up-conversion during transmission and <a href="Digital_down_converter" title="wikilink">down-conversion</a> during reception. In most cellular handsets this function has been largely integrated into a single integrated circuit to reduce the cost and size of the handset. However, due to the high performance required of base station terminals, the transmission and reception circuits are built with discrete components to achieve the levels of performance required. GSM local oscillator modules are typically built with a <a href="frequency_synthesizer" title="wikilink">frequency synthesizer</a> integrated circuit and discrete resonator VCOs.</p>
<h2 id="block-diagram">Block diagram</h2>
<figure><b>(Figure)</b>
<figcaption><a href="Block_diagram" title="wikilink">Block diagram</a> of a phase-locked loop</figcaption>
</figure>

<p>A phase detector compares two input signals and produces an error signal which is proportional to their phase difference. The error signal is then low-pass filtered and used to drive a VCO which creates an output phase. The output is fed through an optional divider back to the input of the system, producing a <a href="negative_feedback_loop" title="wikilink">negative feedback loop</a>. If the output phase drifts, the error signal will increase, driving the VCO phase in the opposite direction so as to reduce the error. Thus the output phase is locked to the phase at the other input. This input is called the reference.</p>

<p>Analog phase locked loops are generally built with an analog phase detector, low pass filter and VCO placed in a <a href="negative_feedback" title="wikilink">negative feedback</a> configuration. A digital phase locked loop uses a digital phase detector; it may also have a divider in the feedback path or in the reference path, or both, in order to make the PLL's output signal frequency a <a href="Rational_number" title="wikilink">rational</a> multiple of the reference frequency. A non-integer multiple of the reference frequency can also be created by replacing the simple divide-by-<em>N</em> counter in the feedback path with a programmable <a href="pulse_swallowing_counter" title="wikilink">pulse swallowing counter</a>. This technique is usually referred to as a <a href="fractional-N_synthesizer" title="wikilink">fractional-N synthesizer</a> or fractional-N PLL.</p>

<p>The oscillator generates a periodic output signal. Assume that initially the oscillator is at nearly the same frequency as the reference signal. If the phase from the oscillator falls behind that of the reference, the phase detector changes the control voltage of the oscillator so that it speeds up. Likewise, if the phase creeps ahead of the reference, the phase detector changes the control voltage to slow down the oscillator. Since initially the oscillator may be far from the reference frequency, practical phase detectors may also respond to frequency differences, so as to increase the lock-in range of allowable inputs.</p>

<p>Depending on the application, either the output of the controlled oscillator, or the control signal to the oscillator, provides the useful output of the PLL system.</p>
<h2 id="elements">Elements</h2>
<h3 id="phase-detector">Phase detector</h3>

<p>A phase detector (PD) generates a voltage, which represents the phase difference between two signals. In a PLL, the two inputs of the phase detector are the reference input and the feedback from the VCO. The PD output voltage is used to control the VCO such that the phase difference between the two inputs is held constant, making it a negative feedback system. There are several types of phase detectors in the two main categories of analog and digital.</p>

<p>Different types of phase detectors have different performance characteristics.</p>

<p>For instance, the <a href="frequency_mixer" title="wikilink">frequency mixer</a> produces harmonics that adds complexity in applications where spectral purity of the VCO signal is important. The resulting unwanted (spurious) sidebands, also called "<a href="reference_spurs" title="wikilink">reference spurs</a>" can dominate the filter requirements and reduce the capture range well below and/or increase the lock time beyond the requirements. In these applications the more complex digital phase detectors are used which do not have as severe a reference spur component on their output. Also, when in lock, the steady-state phase difference at the inputs using this type of phase detector is near 90 degrees. The actual difference is determined by the DC loop gain.</p>

<p>A <strong>bang-bang</strong> charge pump phase detector must always have a <strong>dead band</strong> where the phases of inputs are close enough that the detector detects no phase error. For this reason, bang-bang phase detectors are associated with significant minimum peak-to-peak <a class="uri" href="jitter" title="wikilink">jitter</a>, because of drift within the dead band. However these types, having outputs consisting of very narrow pulses at lock, are very useful for applications requiring very low VCO spurious outputs. The narrow pulses contain very little energy and are easy to filter out of the VCO control voltage. This results in low VCO control line ripple and therefore low FM sidebands on the VCO.</p>

<p>In PLL applications it is frequently required to know when the loop is out of lock. The more complex digital phase-frequency detectors usually have an output that allows a reliable indication of an out of lock condition.</p>
<h3 id="filter">Filter</h3>

<p>The block commonly called the PLL loop filter (usually a low pass filter) generally has two distinct functions.</p>

<p>The primary function is to determine loop dynamics, also called <a href="Nyquist_stability_criterion" title="wikilink">stability</a>. This is how the loop responds to disturbances, such as changes in the reference frequency, changes of the feedback divider, or at startup. Common considerations are the range over which the loop can achieve lock (pull-in range, lock range or capture range), how fast the loop achieves lock (lock time, lock-up time or <a href="settling_time" title="wikilink">settling time</a>) and <a class="uri" href="damping" title="wikilink">damping</a> behavior. Depending on the application, this may require one or more of the following: a simple proportion (gain or attenuation), an <a class="uri" href="integral" title="wikilink">integral</a> (low pass filter) and/or <a class="uri" href="derivative" title="wikilink">derivative</a> (<a href="high_pass_filter" title="wikilink">high pass filter</a>). Loop parameters commonly examined for this are the loop's <a href="gain_margin" title="wikilink">gain margin</a> and <a href="phase_margin" title="wikilink">phase margin</a>. Common concepts in <a href="control_theory" title="wikilink">control theory</a> including the <a href="PID_controller" title="wikilink">PID controller</a> are used to design this function.</p>

<p>The second common consideration is limiting the amount of reference frequency energy (ripple) appearing at the phase detector output that is then applied to the VCO control input. This frequency modulates the VCO and produces FM sidebands commonly called "reference spurs". The low pass characteristic of this block can be used to attenuate this energy, but at times a band reject "notch" may also be useful.</p>

<p>The design of this block can be dominated by either of these considerations, or can be a complex process juggling the interactions of the two. Typical trade-offs are: increasing the bandwidth usually degrades the stability or too much damping for better stability will reduce the speed and increase settling time. Often also the phase-noise is affected.</p>
<h3 id="oscillator">Oscillator</h3>

<p>All phase-locked loops employ an oscillator element with variable frequency capability. This can be an analog VCO either driven by analog circuitry in the case of an APLL or driven digitally through the use of a <a href="digital-to-analog_converter" title="wikilink">digital-to-analog converter</a> as is the case for some DPLL designs. Pure digital oscillators such as a numerically controlled oscillator are used in ADPLLs.</p>
<h3 id="feedback-path-and-optional-divider">Feedback path and optional divider</h3>
<figure><b>(Figure)</b>
<figcaption>An Example Digital Divider (by 4) for use in the Feedback Path of a Multiplying PLL</figcaption>
</figure>

<p>PLLs may include a divider between the oscillator and the feedback input to the phase detector to produce a <a href="frequency_synthesizer" title="wikilink">frequency synthesizer</a>. A programmable divider is particularly useful in radio transmitter applications, since a large number of transmit frequencies can be produced from a single stable, accurate, but expensive, quartz crystal–controlled reference oscillator.</p>

<p>Some PLLs also include a divider between the reference clock and the reference input to the phase detector. If the divider in the feedback path divides by 

<math display="inline" id="Phase-locked_loop:0">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 and the reference input divider divides by 

<math display="inline" id="Phase-locked_loop:1">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, it allows the PLL to multiply the reference frequency by 

<math display="inline" id="Phase-locked_loop:2">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>/</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>N</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N/M
  </annotation>
 </semantics>
</math>

. It might seem simpler to just feed the PLL a lower frequency, but in some cases the reference frequency may be constrained by other issues, and then the reference divider is useful.</p>

<p>Frequency multiplication can also be attained by locking the VCO output to the <em>N</em>th harmonic of the reference signal. Instead of a simple phase detector, the design uses a harmonic mixer (sampling mixer). The harmonic mixer turns the reference signal into an impulse train that is rich in harmonics.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> The VCO output is coarse tuned to be close to one of those harmonics. Consequently, the desired harmonic mixer output (representing the difference between the <em>N</em> harmonic and the VCO output) falls within the loop filter passband.</p>

<p>It should also be noted that the feedback is not limited to a frequency divider. This element can be other elements such as a frequency multiplier, or a mixer. The multiplier will make the VCO output a sub-multiple (rather than a multiple) of the reference frequency. A mixer can translate the VCO frequency by a fixed offset. It may also be a combination of these. An example being a divider following a mixer; this allows the divider to operate at a much lower frequency than the VCO without a loss in loop gain.</p>
<h2 id="modeling">Modeling</h2>
<h3 id="time-domain-model">Time domain model</h3>

<p>The equations governing a phase-locked loop with an analog multiplier as the phase detector and linear filter may be derived as follows. Let the input to the phase detector be 

<math display="inline" id="Phase-locked_loop:3">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>θ</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}(\theta_{1}(t))
  </annotation>
 </semantics>
</math>

 and the output of the VCO is 

<math display="inline" id="Phase-locked_loop:4">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>θ</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}(\theta_{2}(t))
  </annotation>
 </semantics>
</math>

 with phases 

<math display="inline" id="Phase-locked_loop:5">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{1}(t)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Phase-locked_loop:6">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{2}(t)
  </annotation>
 </semantics>
</math>

. Functions 

<math display="inline" id="Phase-locked_loop:7">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}(\theta)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Phase-locked_loop:8">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}(\theta)
  </annotation>
 </semantics>
</math>

 describe <a class="uri" href="waveforms" title="wikilink">waveforms</a> of signals. Then the output of the phase detector 

<math display="inline" id="Phase-locked_loop:9">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(t)
  </annotation>
 </semantics>
</math>

 is given by</p>

<p>

<math display="block" id="Phase-locked_loop:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>θ</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>f</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>θ</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(t)=f_{1}(\theta_{1}(t))f_{2}(\theta_{2}(t))
  </annotation>
 </semantics>
</math>

</p>

<p>the VCO frequency is usually taken as a function of the VCO input 

<math display="inline" id="Phase-locked_loop:11">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(t)
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Phase-locked_loop:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>θ</mi>
      <mo>˙</mo>
     </mover>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ω</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ω</mi>
     <mrow>
      <mi>f</mi>
      <mi>r</mi>
      <mi>e</mi>
      <mi>e</mi>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>g</mi>
      <mi>v</mi>
     </msub>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-˙</ci>
        <ci>θ</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>r</ci>
        <ci>e</ci>
        <ci>e</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>v</ci>
       </apply>
       <ci>g</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\theta}_{2}(t)=\omega_{2}(t)=\omega_{free}+g_{v}g(t)\,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Phase-locked_loop:13">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{v}
  </annotation>
 </semantics>
</math>

 is the <em>sensitivity</em> of the VCO and is expressed in Hz / V; 

<math display="inline" id="Phase-locked_loop:14">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mrow>
    <mi>f</mi>
    <mi>r</mi>
    <mi>e</mi>
    <mi>e</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>r</ci>
     <ci>e</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{free}
  </annotation>
 </semantics>
</math>

 is a free-running frequency of VCO.</p>

<p>The loop filter can be described by system of linear differential equations</p>

<p>

<math display="block" id="Phase-locked_loop:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="right">
        <mover accent="true">
         <mi>x</mi>
         <mo>˙</mo>
        </mover>
       </mtd>
       <mtd columnalign="center">
        <mo>=</mo>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mrow>
           <mi>A</mi>
           <mi>x</mi>
          </mrow>
          <mo>;</mo>
          <mrow>
           <mo>+</mo>
           <mrow>
            <mi>b</mi>
            <mi>ϕ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>t</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
         </mrow>
         <mo>,</mo>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="right">
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mo>=</mo>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mi>c</mi>
         <msup>
          <mo>;</mo>
          <mo>*</mo>
         </msup>
         <mi>x</mi>
         <mo>,</mo>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <matrix>
      <matrixrow>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <eq></eq>
       <list>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>b</ci>
          <ci>ϕ</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </list>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>t</ci>
       </apply>
       <eq></eq>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">c</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-;</ci>
         <times></times>
        </apply>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-,</ci>
       </cerror>
      </matrixrow>
     </matrix>
     <apply>
      <times></times>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rcl}\dot{x}&=&Ax;+b\phi(t),\\
g(t)&=&c;^{*}x,\end{array}\quad x(0)=x_{0},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Phase-locked_loop:16">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(t)
  </annotation>
 </semantics>
</math>

 is an input of the filter, 

<math display="inline" id="Phase-locked_loop:17">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(t)
  </annotation>
 </semantics>
</math>

 is an output of the filter, 

<math display="inline" id="Phase-locked_loop:18">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Phase-locked_loop:19">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-by-

<math display="inline" id="Phase-locked_loop:20">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 matrix, 

<math display="inline" id="Phase-locked_loop:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <msup>
      <mi>ℂ</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>b</mi>
      <mo>∈</mo>
      <msup>
       <mi>ℝ</mi>
       <mi>n</mi>
      </msup>
     </mrow>
     <mo rspace="12.5pt">,</mo>
     <mrow>
      <mi>c</mi>
      <mo>∈</mo>
      <msup>
       <mi>ℂ</mi>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>b</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℂ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathbb{C}^{n},\quad b\in\mathbb{R}^{n},\quad c\in\mathbb{C}^{n},\quad
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Phase-locked_loop:22">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>ℂ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℂ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}\in\mathbb{C}^{n}
  </annotation>
 </semantics>
</math>

 represents an initial state of the filter. The star symbol is a <a href="conjugate_transpose" title="wikilink">conjugate transpose</a>.</p>

<p>Hence the following system describes PLL</p>

<p>

<math display="block" id="Phase-locked_loop:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="right">
         <mover accent="true">
          <mi>x</mi>
          <mo>˙</mo>
         </mover>
        </mtd>
        <mtd columnalign="center">
         <mo>=</mo>
        </mtd>
        <mtd columnalign="left">
         <mrow>
          <mrow>
           <mrow>
            <mi>A</mi>
            <mi>x</mi>
           </mrow>
           <mo>;</mo>
           <mrow>
            <mo>+</mo>
            <mrow>
             <mi>b</mi>
             <msub>
              <mi>f</mi>
              <mn>1</mn>
             </msub>
             <mrow>
              <mo stretchy="false">(</mo>
              <mrow>
               <msub>
                <mi>θ</mi>
                <mn>1</mn>
               </msub>
               <mrow>
                <mo stretchy="false">(</mo>
                <mi>t</mi>
                <mo stretchy="false">)</mo>
               </mrow>
              </mrow>
              <mo stretchy="false">)</mo>
             </mrow>
             <msub>
              <mi>f</mi>
              <mn>2</mn>
             </msub>
             <mrow>
              <mo stretchy="false">(</mo>
              <mrow>
               <msub>
                <mi>θ</mi>
                <mn>2</mn>
               </msub>
               <mrow>
                <mo stretchy="false">(</mo>
                <mi>t</mi>
                <mo stretchy="false">)</mo>
               </mrow>
              </mrow>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
          </mrow>
          <mo>,</mo>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="right">
         <msub>
          <mover accent="true">
           <mi>θ</mi>
           <mo>˙</mo>
          </mover>
          <mn>2</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mo>=</mo>
        </mtd>
        <mtd columnalign="left">
         <mrow>
          <msub>
           <mi>ω</mi>
           <mrow>
            <mi>f</mi>
            <mi>r</mi>
            <mi>e</mi>
            <mi>e</mi>
           </mrow>
          </msub>
          <mo>+</mo>
          <mrow>
           <msub>
            <mi>g</mi>
            <mi>v</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msup>
              <mi>c</mi>
              <mo>*</mo>
             </msup>
             <mi>x</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>θ</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>θ</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <matrix>
       <matrixrow>
        <apply>
         <ci>normal-˙</ci>
         <ci>x</ci>
        </apply>
        <eq></eq>
        <list>
         <apply>
          <times></times>
          <ci>A</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <ci>b</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>θ</ci>
             <cn type="integer">1</cn>
            </apply>
            <ci>t</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <cn type="integer">2</cn>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>θ</ci>
             <cn type="integer">2</cn>
            </apply>
            <ci>t</ci>
           </apply>
          </apply>
         </apply>
        </list>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-˙</ci>
          <ci>θ</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <eq></eq>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <apply>
           <times></times>
           <ci>f</ci>
           <ci>r</ci>
           <ci>e</ci>
           <ci>e</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>g</ci>
           <ci>v</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>c</ci>
            <times></times>
           </apply>
           <ci>x</ci>
          </apply>
         </apply>
        </apply>
       </matrixrow>
      </matrix>
      <apply>
       <times></times>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rcl}\dot{x}&=&Ax;+bf_{1}(\theta_{1}(t))f_{2}(\theta_{2}(t)),\\
\dot{\theta}_{2}&=&\omega_{free}+g_{v}(c^{*}x)\\
\end{array}\quad x(0)=x_{0},\quad\theta_{2}(0)=\theta_{0}.
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Phase-locked_loop:24">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}
  </annotation>
 </semantics>
</math>

 is an initial phase shift.</p>
<h3 id="phase-domain-model">Phase domain model</h3>

<p>Consider the input of PLL 

<math display="inline" id="Phase-locked_loop:25">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>θ</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}(\theta_{1}(t))
  </annotation>
 </semantics>
</math>

 and VCO output 

<math display="inline" id="Phase-locked_loop:26">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>θ</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}(\theta_{2}(t))
  </annotation>
 </semantics>
</math>

 are high frequency signals. Then for any piecewise differentiable 

<math display="inline" id="Phase-locked_loop:27">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\pi
  </annotation>
 </semantics>
</math>

-periodic functions 

<math display="inline" id="Phase-locked_loop:28">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}(\theta)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Phase-locked_loop:29">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}(\theta)
  </annotation>
 </semantics>
</math>

 there is a function 

<math display="inline" id="Phase-locked_loop:30">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(\theta)
  </annotation>
 </semantics>
</math>

 such that the output 

<math display="inline" id="Phase-locked_loop:31">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(t)
  </annotation>
 </semantics>
</math>

 of Filter</p>

<p>

<math display="block" id="Phase-locked_loop:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="right">
        <mover accent="true">
         <mi>x</mi>
         <mo>˙</mo>
        </mover>
       </mtd>
       <mtd columnalign="center">
        <mo>=</mo>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mrow>
           <mi>A</mi>
           <mi>x</mi>
          </mrow>
          <mo>;</mo>
          <mrow>
           <mo>+</mo>
           <mrow>
            <mi>b</mi>
            <mi>φ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mrow>
               <msub>
                <mi>θ</mi>
                <mn>1</mn>
               </msub>
               <mrow>
                <mo stretchy="false">(</mo>
                <mi>t</mi>
                <mo stretchy="false">)</mo>
               </mrow>
              </mrow>
              <mo>-</mo>
              <mrow>
               <msub>
                <mi>θ</mi>
                <mn>2</mn>
               </msub>
               <mrow>
                <mo stretchy="false">(</mo>
                <mi>t</mi>
                <mo stretchy="false">)</mo>
               </mrow>
              </mrow>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
         </mrow>
         <mo>,</mo>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="right">
        <mrow>
         <mi>G</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mo>=</mo>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mi>c</mi>
         <msup>
          <mo>;</mo>
          <mo>*</mo>
         </msup>
         <mi>x</mi>
         <mo>,</mo>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <matrix>
      <matrixrow>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <eq></eq>
       <list>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>b</ci>
          <ci>φ</ci>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>θ</ci>
             <cn type="integer">1</cn>
            </apply>
            <ci>t</ci>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>θ</ci>
             <cn type="integer">2</cn>
            </apply>
            <ci>t</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </list>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>G</ci>
        <ci>t</ci>
       </apply>
       <eq></eq>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">c</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-;</ci>
         <times></times>
        </apply>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-,</ci>
       </cerror>
      </matrixrow>
     </matrix>
     <apply>
      <times></times>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rcl}\dot{x}&=&Ax;+b\varphi(\theta_{1}(t)-\theta_{2}(t)),\\
G(t)&=&c;^{*}x,\end{array}\quad x(0)=x_{0},
  </annotation>
 </semantics>
</math>

 in phase domain is asymptotically equal ( the difference 

<math display="inline" id="Phase-locked_loop:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(t)-g(t)
  </annotation>
 </semantics>
</math>

 is small with respect to the frequencies) to the output of the Filter in time domain model. <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Here function 

<math display="inline" id="Phase-locked_loop:34">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(\theta)
  </annotation>
 </semantics>
</math>

 is a <a href="phase_detector_characteristic" title="wikilink">phase detector characteristic</a>.</p>

<p>Denote by 

<math display="inline" id="Phase-locked_loop:35">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mi mathvariant="normal">Δ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>normal-Δ</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{\Delta}(t)
  </annotation>
 </semantics>
</math>

 the phase difference</p>

<p>

<math display="block" id="Phase-locked_loop:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>θ</mi>
     <mi mathvariant="normal">Δ</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>θ</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>θ</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>normal-Δ</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{\Delta}=\theta_{1}(t)-\theta_{2}(t).
  </annotation>
 </semantics>
</math>

 Then the following <a href="dynamical_system" title="wikilink">dynamical system</a> describes PLL behavior</p>

<p>

<math display="block" id="Phase-locked_loop:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="right">
         <mover accent="true">
          <mi>x</mi>
          <mo>˙</mo>
         </mover>
        </mtd>
        <mtd columnalign="center">
         <mo>=</mo>
        </mtd>
        <mtd columnalign="left">
         <mrow>
          <mrow>
           <mrow>
            <mi>A</mi>
            <mi>x</mi>
           </mrow>
           <mo>;</mo>
           <mrow>
            <mo>+</mo>
            <mrow>
             <mi>b</mi>
             <mi>φ</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <msub>
               <mi>θ</mi>
               <mi mathvariant="normal">Δ</mi>
              </msub>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
          </mrow>
          <mo>,</mo>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="right">
         <msub>
          <mover accent="true">
           <mi>θ</mi>
           <mo>˙</mo>
          </mover>
          <mi mathvariant="normal">Δ</mi>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mo>=</mo>
        </mtd>
        <mtd columnalign="left">
         <mrow>
          <mrow>
           <msub>
            <mi>ω</mi>
            <mi mathvariant="normal">Δ</mi>
           </msub>
           <mo>-</mo>
           <mrow>
            <msub>
             <mi>g</mi>
             <mi>v</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <msup>
               <mi>c</mi>
               <mo>*</mo>
              </msup>
              <mi>x</mi>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo>.</mo>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>θ</mi>
       <mi mathvariant="normal">Δ</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>θ</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>θ</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <matrix>
       <matrixrow>
        <apply>
         <ci>normal-˙</ci>
         <ci>x</ci>
        </apply>
        <eq></eq>
        <list>
         <apply>
          <times></times>
          <ci>A</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <ci>b</ci>
           <ci>φ</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>θ</ci>
            <ci>normal-Δ</ci>
           </apply>
          </apply>
         </apply>
        </list>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-˙</ci>
          <ci>θ</ci>
         </apply>
         <ci>normal-Δ</ci>
        </apply>
        <eq></eq>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <ci>normal-Δ</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>g</ci>
           <ci>v</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>c</ci>
            <times></times>
           </apply>
           <ci>x</ci>
          </apply>
         </apply>
        </apply>
       </matrixrow>
      </matrix>
      <apply>
       <times></times>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>normal-Δ</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rcl}\dot{x}&=&Ax;+b\varphi(\theta_{\Delta}),\\
\dot{\theta}_{\Delta}&=&\omega_{\Delta}-g_{v}(c^{*}x).\\
\end{array}\quad x(0)=x_{0},\quad\theta_{\Delta}(0)=\theta_{1}(0)-\theta_{2}(0).
  </annotation>
 </semantics>
</math>

</p>

<p>Here 

<math display="inline" id="Phase-locked_loop:38">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mi mathvariant="normal">Δ</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ω</mi>
     <mn>1</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>ω</mi>
     <mrow>
      <mi>f</mi>
      <mi>r</mi>
      <mi>e</mi>
      <mi>e</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>normal-Δ</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>r</ci>
       <ci>e</ci>
       <ci>e</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{\Delta}=\omega_{1}-\omega_{free}
  </annotation>
 </semantics>
</math>

; 

<math display="inline" id="Phase-locked_loop:39">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{1}
  </annotation>
 </semantics>
</math>

 is a frequency of reference oscillator (we assume that 

<math display="inline" id="Phase-locked_loop:40">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mrow>
    <mi>f</mi>
    <mi>r</mi>
    <mi>e</mi>
    <mi>e</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>r</ci>
     <ci>e</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{free}
  </annotation>
 </semantics>
</math>

 is constant).</p>
<h4 id="example">Example</h4>

<p>Consider sinusoidal signals</p>

<p>

<math display="block" id="Phase-locked_loop:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>θ</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>θ</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>θ</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>A</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>θ</mi>
         <mn>2</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <sin></sin>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}(\theta_{1}(t))=A_{1}\sin(\theta_{1}(t)),\quad f_{2}(\theta_{2}(t))=A_{2}%
\cos(\theta_{2}(t))
  </annotation>
 </semantics>
</math>

</p>

<p>and simple one-pole <a href="RC_circuit" title="wikilink">RC circuit</a> as a filter. The time-domain model takes the form</p>

<p>

<math display="inline" id="Phase-locked_loop:42">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\dot{x}
  </annotation>
 </semantics>
</math>


</p>

<p>PD characteristics for this signals is equal<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> to</p>

<p>

<math display="block" id="Phase-locked_loop:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>θ</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>θ</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>A</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mi>sin</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>θ</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>θ</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <sin></sin>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(\theta_{1}-\theta_{2})=\frac{A_{1}A_{2}}{2}\sin(\theta_{1}-\theta_{2})
  </annotation>
 </semantics>
</math>

</p>

<p>Hence the phase domain model takes form</p>

<p>

<math display="inline" id="Phase-locked_loop:44">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\dot{x}
  </annotation>
 </semantics>
</math>


</p>

<p>This system of equations is equivalent to the equation of mathematical pendulum</p>

<p>

<math display="inline" id="Phase-locked_loop:45">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x
  </annotation>
 </semantics>
</math>


</p>
<h3 id="linearized-phase-domain-model">Linearized phase domain model</h3>

<p>Phase locked loops can also be analyzed as control systems by applying the <a href="Laplace_transform" title="wikilink">Laplace transform</a>. The loop response can be written as:</p>

<p>

<math display="block" id="Phase-locked_loop:46">
 <semantics>
  <mrow>
   <mfrac>
    <msub>
     <mi>θ</mi>
     <mi>o</mi>
    </msub>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>p</mi>
     </msub>
     <msub>
      <mi>K</mi>
      <mi>v</mi>
     </msub>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>s</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>K</mi>
       <mi>p</mi>
      </msub>
      <msub>
       <mi>K</mi>
       <mi>v</mi>
      </msub>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>o</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>v</ci>
      </apply>
      <ci>F</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>s</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>v</ci>
       </apply>
       <ci>F</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\theta_{o}}{\theta_{i}}=\frac{K_{p}K_{v}F(s)}{s+K_{p}K_{v}F(s)}
  </annotation>
 </semantics>
</math>

</p>

<p>Where</p>
<ul>
<li>

<math display="inline" id="Phase-locked_loop:47">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{o}
  </annotation>
 </semantics>
</math>

 is the output phase in <a href="radian" title="wikilink">radians</a></li>
<li>

<math display="inline" id="Phase-locked_loop:48">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

 is the input phase in radians</li>
<li>

<math display="inline" id="Phase-locked_loop:49">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{p}
  </annotation>
 </semantics>
</math>

 is the phase detector gain in <a href="volt" title="wikilink">volts</a> per radian</li>
<li>

<math display="inline" id="Phase-locked_loop:50">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{v}
  </annotation>
 </semantics>
</math>

 is the VCO gain in radians per volt-<a class="uri" href="second" title="wikilink">second</a></li>
<li>

<math display="inline" id="Phase-locked_loop:51">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(s)
  </annotation>
 </semantics>
</math>

 is the loop filter transfer function (dimensionless)</li>
</ul>

<p>The loop characteristics can be controlled by inserting different types of loop filters. The simplest filter is a one-pole <a href="RC_circuit" title="wikilink">RC circuit</a>. The loop transfer function in this case is:</p>

<p>

<math display="block" id="Phase-locked_loop:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>s</mi>
      <mi>R</mi>
      <mi>C</mi>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>R</ci>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(s)=\frac{1}{1+sRC}
  </annotation>
 </semantics>
</math>

</p>

<p>The loop response becomes:</p>

<p>

<math display="block" id="Phase-locked_loop:53">
 <semantics>
  <mrow>
   <mfrac>
    <msub>
     <mi>θ</mi>
     <mi>o</mi>
    </msub>
    <msub>
     <mi>θ</mi>
     <mi>i</mi>
    </msub>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mfrac>
     <mrow>
      <msub>
       <mi>K</mi>
       <mi>p</mi>
      </msub>
      <msub>
       <mi>K</mi>
       <mi>v</mi>
      </msub>
     </mrow>
     <mrow>
      <mi>R</mi>
      <mi>C</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msup>
      <mi>s</mi>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mfrac>
      <mi>s</mi>
      <mrow>
       <mi>R</mi>
       <mi>C</mi>
      </mrow>
     </mfrac>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>K</mi>
        <mi>p</mi>
       </msub>
       <msub>
        <mi>K</mi>
        <mi>v</mi>
       </msub>
      </mrow>
      <mrow>
       <mi>R</mi>
       <mi>C</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>o</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>v</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>C</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <divide></divide>
       <ci>s</ci>
       <apply>
        <times></times>
        <ci>R</ci>
        <ci>C</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>p</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>v</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>R</ci>
        <ci>C</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\theta_{o}}{\theta_{i}}=\frac{\frac{K_{p}K_{v}}{RC}}{s^{2}+\frac{s}{RC}+%
\frac{K_{p}K_{v}}{RC}}
  </annotation>
 </semantics>
</math>

</p>

<p>This is the form of a classic <a href="harmonic_oscillator" title="wikilink">harmonic oscillator</a>. The denominator can be related to that of a second order system:</p>

<p>

<math display="block" id="Phase-locked_loop:54">
 <semantics>
  <mrow>
   <msup>
    <mi>s</mi>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <mrow>
    <mn>2</mn>
    <mi>s</mi>
    <mi>ζ</mi>
    <msub>
     <mi>ω</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>+</mo>
   <msubsup>
    <mi>ω</mi>
    <mi>n</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>s</ci>
     <ci>ζ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{2}+2s\zeta\omega_{n}+\omega_{n}^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>Where</p>
<ul>
<li>

<math display="inline" id="Phase-locked_loop:55">
 <semantics>
  <mi>ζ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ζ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta
  </annotation>
 </semantics>
</math>

 is the damping factor</li>
<li>

<math display="inline" id="Phase-locked_loop:56">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{n}
  </annotation>
 </semantics>
</math>

 is the natural frequency of the loop</li>
</ul>

<p>For the one-pole RC filter,</p>

<p>

<math display="block" id="Phase-locked_loop:57">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <msqrt>
    <mfrac>
     <mrow>
      <msub>
       <mi>K</mi>
       <mi>p</mi>
      </msub>
      <msub>
       <mi>K</mi>
       <mi>v</mi>
      </msub>
     </mrow>
     <mrow>
      <mi>R</mi>
      <mi>C</mi>
     </mrow>
    </mfrac>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <root></root>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>v</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{n}=\sqrt{\frac{K_{p}K_{v}}{RC}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Phase-locked_loop:58">
 <semantics>
  <mrow>
   <mi>ζ</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>2</mn>
     <msqrt>
      <mrow>
       <msub>
        <mi>K</mi>
        <mi>p</mi>
       </msub>
       <msub>
        <mi>K</mi>
        <mi>v</mi>
       </msub>
       <mi>R</mi>
       <mi>C</mi>
      </mrow>
     </msqrt>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ζ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>p</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>v</ci>
        </apply>
        <ci>R</ci>
        <ci>C</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta=\frac{1}{2\sqrt{K_{p}K_{v}RC}}
  </annotation>
 </semantics>
</math>

</p>

<p>The loop natural frequency is a measure of the response time of the loop, and the damping factor is a measure of the overshoot and ringing. Ideally, the natural frequency should be high and the damping factor should be near 0.707 (critical damping). With a single pole filter, it is not possible to control the loop frequency and damping factor independently. For the case of critical damping,</p>

<p>

<math display="block" id="Phase-locked_loop:59">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mi>C</mi>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>K</mi>
      <mi>p</mi>
     </msub>
     <msub>
      <mi>K</mi>
      <mi>v</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   RC=\frac{1}{2K_{p}K_{v}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Phase-locked_loop:60">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mi>c</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>K</mi>
     <mi>p</mi>
    </msub>
    <msub>
     <mi>K</mi>
     <mi>v</mi>
    </msub>
    <msqrt>
     <mn>2</mn>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{c}=K_{p}K_{v}\sqrt{2}
  </annotation>
 </semantics>
</math>

</p>

<p>A slightly more effective filter, the lag-lead filter includes one pole and one zero. This can be realized with two resistors and one capacitor. The transfer function for this filter is</p>

<p>

<math display="block" id="Phase-locked_loop:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>s</mi>
      <mi>C</mi>
      <msub>
       <mi>R</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mi>s</mi>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>R</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>R</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>C</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>C</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(s)=\frac{1+sCR_{2}}{1+sC(R_{1}+R_{2})}
  </annotation>
 </semantics>
</math>

</p>

<p>This filter has two time constants</p>

<p>

<math display="block" id="Phase-locked_loop:62">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>R</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{1}=C(R_{1}+R_{2})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Phase-locked_loop:63">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>C</mi>
    <msub>
     <mi>R</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{2}=CR_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>Substituting above yields the following natural frequency and damping factor</p>

<p>

<math display="block" id="Phase-locked_loop:64">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <msqrt>
    <mfrac>
     <mrow>
      <msub>
       <mi>K</mi>
       <mi>p</mi>
      </msub>
      <msub>
       <mi>K</mi>
       <mi>v</mi>
      </msub>
     </mrow>
     <msub>
      <mi>τ</mi>
      <mn>1</mn>
     </msub>
    </mfrac>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <root></root>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>v</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{n}=\sqrt{\frac{K_{p}K_{v}}{\tau_{1}}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Phase-locked_loop:65">
 <semantics>
  <mrow>
   <mi>ζ</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <msub>
       <mi>ω</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>τ</mi>
       <mn>1</mn>
      </msub>
     </mrow>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>ω</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>τ</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ζ</ci>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta=\frac{1}{2\omega_{n}\tau_{1}}+\frac{\omega_{n}\tau_{2}}{2}
  </annotation>
 </semantics>
</math>

</p>

<p>The loop filter components can be calculated independently for a given natural frequency and damping factor</p>

<p>

<math display="block" id="Phase-locked_loop:66">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>p</mi>
     </msub>
     <msub>
      <mi>K</mi>
      <mi>v</mi>
     </msub>
    </mrow>
    <msubsup>
     <mi>ω</mi>
     <mi>n</mi>
     <mn>2</mn>
    </msubsup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{1}=\frac{K_{p}K_{v}}{\omega_{n}^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Phase-locked_loop:67">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mn>2</mn>
      <mi>ζ</mi>
     </mrow>
     <msub>
      <mi>ω</mi>
      <mi>n</mi>
     </msub>
    </mfrac>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msub>
       <mi>K</mi>
       <mi>p</mi>
      </msub>
      <msub>
       <mi>K</mi>
       <mi>v</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>ζ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>p</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{2}=\frac{2\zeta}{\omega_{n}}-\frac{1}{K_{p}K_{v}}
  </annotation>
 </semantics>
</math>

</p>

<p>Real world loop filter design can be much more complex e.g. using higher order filters to reduce various types or source of phase noise. (See the D Banerjee ref below)</p>
<h3 id="implementing-a-digital-phase-locked-loop-in-software">Implementing a digital phase-locked loop in software</h3>

<p>Digital phase locked loops can be implemented in hardware, using integrated circuits such as a CMOS 4046. However, with microcontrollers becoming faster, it may make sense to implement a phase locked loop in software for applications that do not require locking onto signals in the MHz range or faster, such as precisely controlling motor speeds. Software implementation has several advantages including easy customization of the feedback loop including changing the multiplication or division ratio between the signal being tracked and the output oscillator. Furthermore, a software implementation is useful to understand and experiment with. As an example of a phase-locked loop implemented using a <a href="phase_frequency_detector" title="wikilink">phase frequency detector</a> is presented in MATLAB, as this type of phase detector is robust and easy to implement. This example uses integer arithmetic rather than floating point, as such an example is likely more useful in practice.</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span class="co">% This example is written in MatLab</span>

<span class="co">% Initialize variables</span>
vcofreq = zeros(<span class="fl">1</span>, numiterations);
ervec = zeros(<span class="fl">1</span>, numiterations);
<span class="co">% keep track of last states of reference, signal, and error signal</span>
qsig = <span class="fl">0</span>; qref = <span class="fl">0</span>; lref = <span class="fl">0</span>; lsig = <span class="fl">0</span>; lersig = <span class="fl">0</span>;
phs = <span class="fl">0</span>;
freq = <span class="fl">0</span>;

<span class="co">% Loop filter constants (proportional and derivative)</span>
<span class="co">% Currently powers of two to facilitate multiplication by shifts</span>
prop = <span class="fl">1</span>/<span class="fl">128</span>;
deriv = <span class="fl">64</span>;

for it=<span class="fl">1</span>:numiterations
    <span class="co">% Simulate a local oscillator using a 16-bit counter</span>
    phs = mod(phs + floor(freq/<span class="fl">2</span>^<span class="fl">16</span>), <span class="fl">2</span>^<span class="fl">16</span>);
    ref = phs &lt; <span class="fl">32768</span>;
    <span class="co">% Get the next digital value (0 or 1) of the signal to track</span>
    sig = tracksig(it);
    <span class="co">% Implement the phase-frequency detector</span>
    rst = ~(qsig &amp; qref);  <span class="co">% Reset the "flip-flop" of the phase-frequency</span>
                    <span class="co">% detector when both signal and reference are high</span>
    qsig = (qsig | (sig &amp; ~lsig)) &amp; rst;   <span class="co">% Trigger signal flip-flop and leading edge of signal</span>
    qref = (qref | (ref &amp; ~lref)) &amp; rst;   <span class="co">% Trigger reference flip-flop on leading edge of reference</span>
    lref = ref; lsig = sig; <span class="co">% Store these values for next iteration (for edge detection)</span>
    ersig = qref - qsig;    <span class="co">% Compute the error signal (whether frequency should increase or decrease)</span>
                            <span class="co">% Error signal is given by one or the other flip flop signal</span>
    <span class="co">% Implement a pole-zero filter by proportional and derivative input to frequency</span>
    filtered_ersig = ersig + (ersig - lersig) * deriv; 
    <span class="co">% Keep error signal for proportional output</span>
    lersig = ersig;
    <span class="co">% Integrate VCO frequency using the error signal</span>
    freq = freq - <span class="fl">2</span>^<span class="fl">16</span> * filtered_ersig * prop;
    <span class="co">% Frequency is tracked as a fixed-point binary fraction</span>
    <span class="co">% Store the current VCO frequency</span>
    vcofreq(<span class="fl">1</span>, it) = freq / <span class="fl">2</span>^<span class="fl">16</span>;
    <span class="co">% Store the error signal to show whether signal or reference is higher frequency</span>
    ervec(<span class="fl">1</span>, it) = ersig;
end</code></pre></div>

<p>In this example, an array <code>tracksig</code> is assumed to contain a reference signal to be tracked. The oscillator is implemented by a counter, with the most significant bit of the counter indicating the on/off status of the oscillator. This code simulates the two D-type <a href="Flip-flop_(electronics)" title="wikilink">flip-flops</a> that comprise a phase-frequency comparator. When either the reference or signal has a positive edge, the corresponding flip-flop switches high. Once both reference and signal is high, both flip-flops are reset. Which flip-flop is high determines at that instant whether the reference or signal leads the other. The error signal is the difference between these two flip-flop values. The pole-zero filter is implemented by adding the error signal and its derivative to the filtered error signal. This in turn is integrated to find the oscillator frequency.</p>

<p>In practice, one would likely insert other operations into the feedback of this phase-locked loop. For example, if the phase locked loop were to implement a frequency multiplier, the oscillator signal could be divided in frequency before it is compared to the reference signal.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Direct_digital_synthesizer" title="wikilink">Direct-digital synthesis</a></li>
<li><a href="Costas_loop" title="wikilink">Costas loop</a></li>
<li><a href="Kalman_filter" title="wikilink">Kalman filter</a></li>
<li><a href="Direct_conversion_receiver" title="wikilink">Direct conversion receiver</a></li>
<li><a href="Circle_map" title="wikilink">Circle map</a> - a simple mathematical model of the phase-locked loop showing both mode-locking and chaotic behavior.</li>
<li><a href="Carrier_recovery" title="wikilink">Carrier recovery</a></li>
<li><a href="Delay-locked_loop" title="wikilink">Delay-locked loop</a> (DLL)</li>
<li><a href="PLL_multibit" title="wikilink">PLL multibit</a></li>
<li><a href="Shortt-Synchronome_clock" title="wikilink">Shortt-Synchronome clock</a> - slave pendulum phase-locked to master (ca 1921).</li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>

<p>.</p></li>
<li></li>
<li></li>
<li></li>
<li>

<p>. (provides useful Matlab scripts for simulation)</p></li>
<li>

<p>. (provides useful Matlab scripts for simulation)</p></li>
<li></li>
<li>

<p>. (FM Demodulation)</p></li>
<li></li>
<li>

<p>. An article on designing a standard PLL IC for Bluetooth applications.</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Oscillators" title="wikilink">Category:Oscillators</a> <a href="Category:Communication_circuits" title="wikilink">Category:Communication circuits</a> <a href="Category:Electronic_design" title="wikilink">Category:Electronic design</a> <a href="Category:Radio_electronics" title="wikilink">Category:Radio electronics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">If the frequency is constant and the initial phase is zero, then the phase of a sinusoid is proportional to time.<a href="#fnref1">↩</a></li>
<li id="fn2">Christiaan Huygens, <em>Horologium Oscillatorium</em> … (Paris, France: F. Muguet, 1673), [<a class="uri" href="http://books.google.com/books?id=YgY8AAAAMAAJ&amp;pg">http://books.google.com/books?id=YgY8AAAAMAAJ&amp;pg;</a>;=PA18#v=onepage&amp;q;&amp;f;=false pages 18-19.] From page 18: <em>" … illudque accidit memoratu dignum, … brevi tempore reduceret."</em> ( … and it is worth mentioning, since with two clocks constructed in this form and which we suspend in like manner, truly the cross beam is assigned two fulcrums [i.e., two pendulum clocks were suspended from the same wooden beam]; the motions of the pendulums thus share the opposite swings between the two [clocks], since the two clocks at no time move even a small distance, and the sound of both can be heard clearly together always: for if the innermost part [of one of the clocks] is disturbed with a little help, it will have been restored in a short time by the clocks themselves.) English translation provided by Ian Bruce's translation of <a href="http://www.17centurymaths.com/contents/huygens/horologiumpart1.pdf"><em>Horologium Oscillatorium</em> …</a>, pages 16-17.<a href="#fnref2">↩</a></li>
<li id="fn3">E. V. Appleton (1923) "The automatic synchronization of triode oscillators," <em>Proceedings of the Cambridge Philosophical Society</em>, <strong>21</strong> (Part III): 231-248. Available on-line at: <a href="https://archive.org/stream/proceedingscambr21camb#page/231/mode/2up">Internet Archive</a>.<a href="#fnref3">↩</a></li>
<li id="fn4">Henri de Bellescize, "La réception synchrone," <em>L'Onde Électrique</em> (later: <em>Revue de l'Electricité et de l'Electronique</em>), vol. 11, pages 230-240 (June 1932).<a href="#fnref4">↩</a></li>
<li id="fn5">See also: French patent no. 635,451 (filed: 6 October 1931; issued: 29 September 1932); and U.S. patent [<a class="uri" href="http://patimg1.uspto.gov/.piw?Docid=01990428&amp;homeurl">http://patimg1.uspto.gov/.piw?Docid=01990428&amp;homeurl;</a>;=http%3A%2F%2Fpatft.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526p%3D1%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-bool.html%2526r%3D1%2526f%3DG%2526l%3D50%2526co1%3DAND%2526d%3DPALL%2526s1%3D1,990,428.PN.%2526OS%3DPN%2F1,990,428%2526RS%3DPN%2F1,990,428&amp;PageNum;=&amp;Rtype;=&amp;SectionNum;=&amp;idkey;=NONE&amp;Input;=View+first+page "Synchronizing system,"] no. 1,990,428 (filed: 29 September 1932; issued: 5 February 1935).<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="http://www.uoguelph.ca/~antoon/gadgets/pll/pll.html">Notes for a University of Guelph course describing the PLL and early history, including an IC PLL tutorial</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">A. B. Grebene, H. R. Camenzind, "Phase Locking As A New Approach For Tuned Integrated Circuits", ISSCC Digest of Technical Papers, pp. 100-101, Feb. 1969.<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">Typically, the reference sinewave drives a <a href="step_recovery_diode" title="wikilink">step recovery diode</a> circuit to make this impulse train. The resulting impulse train drives a sample gate.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14">A. J. Viterbi, <em>Principles of Coherent Communication</em>, McGraw-Hill, New York, 1966<a href="#fnref14">↩</a></li>
</ol>
</section>
</body>

