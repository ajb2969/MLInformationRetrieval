   Integrated Encryption Scheme      Integrated Encryption Scheme   Integrated Encryption Scheme ( IES ) is a hybrid encryption scheme which provides semantic security against an adversary who is allowed to use chosen-plaintext and chosen-ciphertext attacks. The security of the scheme is based on the Diffie–Hellman problem . Two incarnations of the IES are standardized: Discrete Logarithm Integrated Encryption Scheme (DLIES) and Elliptic Curve Integrated Encryption Scheme (ECIES), which is also known as the Elliptic Curve Augmented Encryption Scheme or simply the Elliptic Curve Encryption Scheme. These two incarnations are identical up to the change of an underlying group and so to be concrete we concentrate on the latter.  Information required  To send an encrypted message to Bob using ECIES, Alice needs the following information:   cryptographic suite to be used, including a key derivation function (e.g., ANSI-X9.63-KDF with SHA-1 option ), a message authentication code (e.g., HMAC-SHA-1-160 with 160-bit keys or HMAC-SHA-1-80 with 80-bit keys ) and a symmetric encryption scheme (e.g., TDEA in CBC mode or XOR encryption scheme )—noted   E   E   E   ;  elliptic curve domain parameters    (  p  ,  a  ,  b  ,  G  ,  n  ,  h  )     p  a  b  G  n  h    (p,a,b,G,n,h)   for a curve over a prime field or    (  m  ,   f   (  x  )    ,  a  ,  b  ,  G  ,  n  ,  h  )     m    f  x   a  b  G  n  h    (m,f(x),a,b,G,n,h)   for a curve over a binary field;  Bob's public key    K  B     subscript  K  B    K_{B}   (Bob generates it as follows     K  B   =    k  B   G        subscript  K  B      subscript  k  B   G     K_{B}=k_{B}G   , where    k  B     subscript  k  B    k_{B}   is the private key he chooses at random     k  B   ∈   [  1  ,   n  -  1   ]        subscript  k  B    1    n  1      k_{B}\in[1,n-1]   );  optional shared information    S  1     subscript  S  1    S_{1}   and    S  2     subscript  S  2    S_{2}   .   Encryption  To encrypt a message   m   m   m   Alice does the following:   generates a random number    r  ∈   [  1  ,   n  -  1   ]       r   1    n  1      r\in[1,n-1]   and calculates    R  =   r  G       R    r  G     R=rG   ;  derives a shared secret    S  =   P  x       S   subscript  P  x     S=P_{x}   , where    P  =   (   P  x   ,   P  y   )   =   r   K  B          P    subscript  P  x    subscript  P  y           r   subscript  K  B       P=(P_{x},P_{y})=rK_{B}   (and    P  ≠  O      P  O    P\neq O   );  uses KDF to derive a symmetric encryption and a MAC keys     k  E   ∥   k  M   =  KDF   (  S  ∥   S  1   )      fragments   subscript  k  E   parallel-to   subscript  k  M    KDF   fragments  normal-(  S  parallel-to   subscript  S  1   normal-)     k_{E}\|k_{M}=\textrm{KDF}(S\|S_{1})   ;  encrypts the message    c  =   E   (   k  E   ;  m  )        c    E    subscript  k  E   m      c=E(k_{E};m)   ;  computes the tag of encrypted message and    S  2     subscript  S  2    S_{2}       d  =  MAC   (   k  M   ;  c  ∥   S  2   )      fragments  d   MAC   fragments  normal-(   subscript  k  M   normal-;  c  parallel-to   subscript  S  2   normal-)     d=\textrm{MAC}(k_{M};c\|S_{2})   ;  outputs    R   ∥  c  ∥   d      R   norm  c   d    R\|c\|d   .   Decryption  To decrypt the ciphertext    R   ∥  c  ∥   d      R   norm  c   d    R\|c\|d   Bob does the following:   derives the shared secret    S  =   P  x       S   subscript  P  x     S=P_{x}   , where    P  =   (   P  x   ,   P  y   )   =    k  B   R         P    subscript  P  x    subscript  P  y            subscript  k  B   R      P=(P_{x},P_{y})=k_{B}R   (it is the same as the one Alice derived because    P  =    k  B   R   =    k  B   r  G   =   r   k  B   G   =   r   K  B          P     subscript  k  B   R           subscript  k  B   r  G          r   subscript  k  B   G          r   subscript  K  B       P=k_{B}R=k_{B}rG=rk_{B}G=rK_{B}   ), or outputs failed if    P  =  O      P  O    P=O   ;  derives keys the same way as Alice did     k  E   ∥   k  M   =  KDF   (  S  ∥   S  1   )      fragments   subscript  k  E   parallel-to   subscript  k  M    KDF   fragments  normal-(  S  parallel-to   subscript  S  1   normal-)     k_{E}\|k_{M}=\textrm{KDF}(S\|S_{1})   ;  uses MAC to check the tag and outputs failed if    d  ≠  MAC   (   k  M   ;  c  ∥   S  2   )      fragments  d   MAC   fragments  normal-(   subscript  k  M   normal-;  c  parallel-to   subscript  S  2   normal-)     d\neq\textrm{MAC}(k_{M};c\|S_{2})   ;  uses symmetric encryption scheme to decrypt the message    m  =    E   -  1     (   k  E   ;  c  )        m     superscript  E    1      subscript  k  E   c      m=E^{-1}(k_{E};c)   .   References   Victor Shoup, A proposal for an ISO standard for public key encryption , Version 2.1, December 20, 2001.  Certicom Research, Standards for efficient cryptography, SEC 1: Elliptic Curve Cryptography , Version 2.0, May 21, 2009.  Gayoso Martínez, Hernández Encinas, Sánchez Ávila: A Survey of the Elliptic Curve Integrated Encryption Scheme , Journal of Computer Science and Engineering, 2, 2 (2010), 7-13.   "  Category:Cryptographic protocols   