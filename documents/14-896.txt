   ACE Encrypt      ACE Encrypt   ACE ( Advanced Cryptographic Engine ) — the collection of units, implementing both a public key encryption scheme and a digital signature scheme. Corresponding names for these schemes — «ACE Encrypt» and «ACE Sign». Schemes are based on Cramer-Shoup public key encryption scheme and Cramer-Shoup signature scheme. Introduced variants of these schemes are intended to achieve a good balance between performance and security of the whole encryption system.  Authors  All the algorithms, implemented in ACE are based on algorithms developed by Victor Shoup and Ronald Cramer. The full algorithms specification is written by Victor Shoup. Implementation of algorithms is done by Thomas Schweinberger and Mehdi Nassehi, its supporting and maintaining is done by Victor Shoup. Thomas Schweinberger participated in construction of ACE specification document and also wrote a user manual.  Ronald Cramer currently stays in the university of Aarhus, Denmark . He worked on the project of ACE Encrypt while his staying in ETH in Zürich , Switzerland .  Mehdi Nassehi and Thomas Schweinberger worked on ACE project in the IBM research lab in Zürich , Switzerland . Victor Shoup works in the IBM research lab in Zürich , Switzerland .  Security  The encryption scheme in ACE can be proven secure under reasonable and natural intractability assumptions. These four assumptions are:   The Decisional Diffie-Hellman (DDH) assumption  Strong RSA assumption  SHA-1 second preimage collision resistance  MARS sum/counter mode pseudo-randomness   Basic Terminology and Notation  Here we introduce some notations, being used in this article.  Basic mathematical notation      Z    Z   Z\,   — The set of integers.      F  2    [  T  ]        subscript  F  2    delimited-[]  T     F_{2}[T]\,   — The set of univariate polynomials with coefficients in the finite field     F  2      subscript  F  2    F_{2}\,   of cardinality 2.     A  r  e  m   n       A  r  e  m  n    Aremn\,   — integer    r  ∈   {  0  ,  …  ,   n  -  1   }       r   0  normal-…    n  1      r\in\left\{0,...,n-1\right\}   such that    A  ≡   r   (   m  o  d  n   )        A    r    m  o  d  n      A\equiv r(modn)   for integer    n  >   0       n  0    n>0\,   and    A  ∈   Z       A  Z    A\in Z\,   .     A  r  e  m   f       A  r  e  m  f    Aremf\,   — polynomial    r  ∈    F  2    [  T  ]        r     subscript  F  2    delimited-[]  T      r\in F_{2}[T]   with      A  ,  f   ∈    F  2    [  T  ]     ,   f  ≠   0       formulae-sequence     A  f      subscript  F  2    delimited-[]  T       f  0     A,f\in F_{2}[T],f\neq 0\,   with     A  ∗      superscript  A  normal-∗    A^{\ast}\,   .  Basic string notation       A  n      superscript  A  n    A^{n}\,   — The set of all strings.     x  ∈    A  ∗   L   (  x  )        x     superscript  A  normal-∗   L  x     x\in A^{\ast}L(x)   — The set of all strings with length n. For    x    x   x\,   — length of string     λ  A      subscript  λ  A    \lambda_{A}\,   . The string of length zero is denoted     x  ,  y   ∈   A  ∗        x  y    superscript  A  normal-∗     x,y\in A^{\ast}   . For    x  |  |   y      fragments  x  normal-|  normal-|  y    x||y\,       x    x   x\,   — the result of    y    y   y\,   and    b   =  def    {  0  ,  1  }       superscript   def   b   0  1     b\stackrel{\mathrm{def}}{=}\left\{0,1\right\}   concatenation.  Bits, Bytes, Words      b  ,   b   n  1    ,    (   b   n  1    )    n  2    ,  …     b   superscript  b   subscript  n  1     superscript   superscript  b   subscript  n  1     subscript  n  2    normal-…    b,b^{n_{1}},(b^{n_{1}})^{n_{2}},...   — The set of bits. Let us take all sets of form     0  b    =  def   0  ∈  b        superscript   def    subscript  0  b   0       b     0_{b}\stackrel{\mathrm{def}}{=}0\in b   . For such a set A we define the "zero element":        0   A  n     =  def    (   0  A   ,  …  ,   0  A   )   ∈   A  n         superscript   def    subscript  0   superscript  A  n      subscript  0  A   normal-…   subscript  0  A          superscript  A  n      0_{A^{n}}\stackrel{\mathrm{def}}{=}(0_{A},...,0_{A})\in A^{n}   ;     n  >   0       n  0    n>0\,   for    B   =  def    b  8       superscript   def   B   superscript  b  8     B\stackrel{\mathrm{def}}{=}b^{8}   .   We define    W   =  def    b  32       superscript   def   W   superscript  b  32     W\stackrel{\mathrm{def}}{=}b^{32}   as a set of bytes, and    x  ∈    A  ∗        x   superscript  A  normal-∗     x\in A^{\ast}\,   as a set of words.  For    A  ∈   {  b  ,  B  ,  W  }       A   b  B  W     A\in\left\{b,B,W\right\}\,   with    l  >   0       l  0    l>0\,   and     I   s  r  c    d  s  t    :    s  r  c   →   d  s  t       normal-:   superscript   subscript  I    s  r  c      d  s  t     normal-→    s  r  c     d  s  t      I_{src}^{dst}:src\rightarrow dst   we define a padding operator:       Z  ,    F  2    [  T  ]    ,   b  ∗   ,   B  ∗   ,   W  ∗      Z     subscript  F  2    delimited-[]  T     superscript  b  normal-∗    superscript  B  normal-∗    superscript  W  normal-∗     Z,F_{2}[T],b^{\ast},B^{\ast},W^{\ast}      Conversion operator  Conversion operator    (  P  ,  q  ,   g  1   ,   g  2   ,  c  ,  d  ,   h  1   ,   h  2   ,   k  1   ,   k  2   )     P  q   subscript  g  1    subscript  g  2   c  d   subscript  h  1    subscript  h  2    subscript  k  1    subscript  k  2     (P,q,g_{1},g_{2},c,d,h_{1},h_{2},k_{1},k_{2})\,   makes a conversion between elements    (  w  ,  x  ,  y  ,   z  1   ,   z  2   )     w  x  y   subscript  z  1    subscript  z  2     (w,x,y,z_{1},z_{2})\,   .  Encryption Scheme  Encryption Key Pair  The encryption scheme employs two key types: ACE public key    m    m   m\,   . ACE private key    1024  ≤  m  ≤  16384        1024  m       16384     1024\leq m\leq 16384   . For a given size parameter m    q    q   q\,   , such that    P    P   P\,   , key components are defined as:     P  ≡   1   (   m  o  d  q   )        P    1    m  o  d  q      P\equiv 1(modq)   — a 256-bit prime number.      g  1   ,   g  2   ,  c  ,  d  ,   h  1   ,    h  2        subscript  g  1    subscript  g  2   c  d   subscript  h  1    subscript  h  2     g_{1},g_{2},c,d,h_{1},h_{2}\,   — a m-bit prime number, such that    {  1  ,  …  ,   P  -  1   }     1  normal-…    P  1     \left\{1,...,P-1\right\}   .     P    P   P\,   — elements    q    q   q\,   (whose multiplicative order modulo    w  ,  x  ,  y  ,   z  1   ,    z  2       w  x  y   subscript  z  1    subscript  z  2     w,x,y,z_{1},z_{2}\,   divides    {  0  ,  …  ,   q  -  1   }     0  normal-…    q  1     \left\{0,...,q-1\right\}   ).      k  1   ,    k  2        subscript  k  1    subscript  k  2     k_{1},k_{2}\,   — elements    B  ∗     superscript  B  normal-∗    B^{\ast}   .      L   (   k  1   )    =    20   l  ′    +  64         L   subscript  k  1        20   superscript  l  normal-′    64     L(k_{1})=20l^{\prime}+64   — elements     L   (   k  2   )    =    32   ⌈   l  /  16   ⌉    +  40         L   subscript  k  2        32      l  16     40     L(k_{2})=32\left\lceil l/16\right\rceil+40   with    l  =   ⌈   m  /  8   ⌉       l      m  8      l=\left\lceil m/8\right\rceil   and     l  ′   =    L  b    (   ⌈    (    2   ⌈   l  /  4   ⌉    +  4   )   /  16   ⌉   )         superscript  l  normal-′      subscript  L  b           2      l  4     4   16       l^{\prime}=L_{b}(\left\lceil(2\left\lceil l/4\right\rceil+4)/16\right\rceil)   , where    m    m   m\,   and    1024  ≤  m  ≤  16384        1024  m       16384     1024\leq m\leq 16384   .  Key Generation  Algorithm. Key Generation for ACE encryption scheme. Input: a size parameter m    q    q   q\,   , such that     2  255   <  q  <    2  256           superscript  2  255   q        superscript  2  256      2^{255}   . Output: a public/private key pair.   Generate a random prime    P    P   P\,   , such that     2   m  -  1    <  P  <    2  m           superscript  2    m  1    P        superscript  2  m      2^{m-1}   .  Generate a random prime    P  ≡   1   (   m  o  d  q   )        P    1    m  o  d  q      P\equiv 1(modq)   ,     g  1   ∈   {  2  ,  …  ,   P  -  1   }        subscript  g  1    2  normal-…    P  1      g_{1}\in\left\{2,...,P-1\right\}   , such that     g  1  q   ≡   1   (   m  o  d  P   )         superscript   subscript  g  1   q     1    m  o  d  P      g_{1}^{q}\equiv 1(modP)   .  Generate a random integer    w  ∈   {  1  ,  …  ,   q  -  1   }       w   1  normal-…    q  1      w\in\left\{1,...,q-1\right\}   , such that     x  ,  y  ,   z  1   ,   z  2    ∈   {  0  ,  …  ,   q  -  1   }        x  y   subscript  z  1    subscript  z  2     0  normal-…    q  1      x,y,z_{1},z_{2}\in\left\{0,...,q-1\right\}   .  Generate random integers    {  1  ,  …  ,   P  -  1   }     1  normal-…    P  1     \left\{1,...,P-1\right\}   and     g  2   ←    g  1  w   r  e  m  P      normal-←   subscript  g  2      superscript   subscript  g  1   w   r  e  m  P     g_{2}\leftarrow g_{1}^{w}remP     Compute the following integers in    c  ←    g  1  x   r  e  m  P      normal-←  c     superscript   subscript  g  1   x   r  e  m  P     c\leftarrow g_{1}^{x}remP   :      d  ←    g  1  y   r  e  m  P      normal-←  d     superscript   subscript  g  1   y   r  e  m  P     d\leftarrow g_{1}^{y}remP   ,      h  1   ←    g  1   z  1    r  e  m  P      normal-←   subscript  h  1      superscript   subscript  g  1    subscript  z  1    r  e  m  P     h_{1}\leftarrow g_{1}^{z_{1}}remP   ,      h  2   ←    g  1   z  2    r  e  m  P      normal-←   subscript  h  2      superscript   subscript  g  1    subscript  z  2    r  e  m  P     h_{2}\leftarrow g_{1}^{z_{2}}remP   ,      k  1   ∈   B    20   l  ′    +  64         subscript  k  1    superscript  B      20   superscript  l  normal-′    64      k_{1}\in B^{20l^{\prime}+64}   ,      k  2   ∈   B    2   ⌈   l  /  16   ⌉    +  40         subscript  k  2    superscript  B      2      l  16     40      k_{2}\in B^{2\left\lceil l/16\right\rceil+40}   .   Generate random byte strings    l  =    L  B    (  P  )        l     subscript  L  B   P     l=L_{B}(P)\,   and     l  ′   =    L  B    (   ⌈    (    2   ⌈   l  /  4   ⌉    +  4   )   /  16   ⌉   )         superscript  l  normal-′      subscript  L  B           2      l  4     4   16       l^{\prime}=L_{B}(\left\lceil(2\left\lceil l/4\right\rceil+4)/16\right\rceil)   , where    (   (  P  ,  q  ,   g  1   ,   g  2   ,  c  ,  d  ,   h  1   ,   h  2   ,   k  1   ,   k  2   )   ,   (  w  ,  x  ,  y  ,   z  1   ,   z  2   )   )      P  q   subscript  g  1    subscript  g  2   c  d   subscript  h  1    subscript  h  2    subscript  k  1    subscript  k  2     w  x  y   subscript  z  1    subscript  z  2      ((P,q,g_{1},g_{2},c,d,h_{1},h_{2},k_{1},k_{2}),(w,x,y,z_{1},z_{2}))\,   and    (  s  ,   u  1   ,   u  2   ,  v  ,  e  )     s   subscript  u  1    subscript  u  2   v  e    (s,u_{1},u_{2},v,e)\,   .  Return the public key/private key pair       u  1   ,   u  2   ,   v       subscript  u  1    subscript  u  2   v    u_{1},u_{2},v\,       Ciphertext Representation  A ciphertext of the ACE encryption scheme has the form        {  1  ,  …  ,   P  -  1   }     1  normal-…    P  1     \left\{1,...,P-1\right\}   ,   where the components are defined as:     P    P   P\,   — integers from    q    q   q\,   (whose multiplicative order modulo    s    s   s\,   divides     W  4      superscript  W  4    W^{4}\,   ).     e    e   e\,   — element     B  ∗      superscript  B  normal-∗    B^{\ast}\,   .     s  ,   u  1   ,   u  2   ,   v      s   subscript  u  1    subscript  u  2   v    s,u_{1},u_{2},v\,   — element    e    e   e\,   .     l    l   l\,   we call the preamble , and    e    e   e\,   — the cryptogram . If a cleartext is a string consisting of    l  +   16   ⌈   l  /  1024   ⌉        l    16      l  1024       l+16\left\lceil l/1024\right\rceil   байт, then the length of    C  E  n  c  o  d   e       C  E  n  c  o  d  e    CEncode\,   is equal to    C  D  e  c  o  d   e       C  D  e  c  o  d  e    CDecode\,   . We need to introduce the function    l  >   0       l  0    l>0\,   , which maps a ciphertext to its byte-string representation, and the corresponding inverse function    s  ∈   W  4       s   superscript  W  4     s\in W^{4}   . For the integer     0  ≤    u  1   ,   u  2     ,   v  <   256  l       formulae-sequence    0    subscript  u  1    subscript  u  2       v   superscript  256  l      0\leq u_{1},u_{2},v<256^{l}   , word string    e  ∈   B  ∗       e   superscript  B  normal-∗     e\in B^{\ast}   , integers     C  E  n  c  o  d  e   (  l  ,  s  ,   u  1   ,   u  2   ,  v  ,  e  )     =  def     I   W  ∗    B  ∗     (  s  )    ||   p  a   d  l    (    I  Z   B  ∗     (   u  1   )    )    ||   p  a   d  l    (    I  Z   B  ∗     (   u  2   )    )    ||   p  a   d  l    (    I  Z   B  ∗     (  v  )    )    ||   e   ∈   B  ∗         superscript   def     C  E  n  c  o  d  e   l  s   subscript  u  1    subscript  u  2   v  e       superscript   subscript  I   superscript  W  normal-∗     superscript  B  normal-∗    s   norm    p  a   subscript  d  l      superscript   subscript  I  Z    superscript  B  normal-∗     subscript  u  1      p  a   subscript  d  l      superscript   subscript  I  Z    superscript  B  normal-∗     subscript  u  2     norm    p  a   subscript  d  l      superscript   subscript  I  Z    superscript  B  normal-∗    v     e         superscript  B  normal-∗      CEncode(l,s,u_{1},u_{2},v,e)\stackrel{\mathrm{def}}{=}I_{W^{\ast}}^{B^{\ast}}(%
 s)||pad_{l}(I_{Z}^{B^{\ast}}(u_{1}))||pad_{l}(I_{Z}^{B^{\ast}}(u_{2}))||pad_{l%
 }(I_{Z}^{B^{\ast}}(v))||e\in B^{\ast}   , and byte string    l  >   0       l  0    l>0\,   ,       ψ  ∈   B  ∗       ψ   superscript  B  normal-∗     \psi\in B^{\ast}   .   For integer     L   (  ψ  )    ≥    3  l   +  16         L  ψ       3  l   16     L(\psi)\geq 3l+16   , byte string     C  D  e  c  o  d  e   (  l  ,  ψ  )     =  def    (    I   B  ∗    W  ∗     (    [  ψ  ]   0  16   )    ,    I   B  ∗   Z    (    [  ψ  ]   16   16  +  l    )    ,    I   B  ∗   Z    (    [  ψ  ]    16  +  l    16  +   2  l     )    ,    I   B  ∗   Z    (    [  ψ  ]    16  +   2  l     16  +   3  l     )    ,    [  ψ  ]    16  +   3  l     L   (  ψ  )     )   ∈    W  4   ×  Z  ×  Z  ×  Z  ×   B  ∗          superscript   def     C  D  e  c  o  d  e   l  ψ        superscript   subscript  I   superscript  B  normal-∗     superscript  W  normal-∗     superscript   subscript   delimited-[]  ψ   0   16       superscript   subscript  I   superscript  B  normal-∗    Z    superscript   subscript   delimited-[]  ψ   16     16  l        superscript   subscript  I   superscript  B  normal-∗    Z    superscript   subscript   delimited-[]  ψ     16  l      16    2  l         superscript   subscript  I   superscript  B  normal-∗    Z    superscript   subscript   delimited-[]  ψ     16    2  l       16    3  l       superscript   subscript   delimited-[]  ψ     16    3  l       L  ψ             superscript  W  4   Z  Z  Z   superscript  B  normal-∗       CDecode(l,\psi)\stackrel{\mathrm{def}}{=}(I_{B^{\ast}}^{W^{\ast}}(\Bigl[\psi%
 \Bigr]_{0}^{16}),I_{B^{\ast}}^{Z}(\Bigl[\psi\Bigr]_{16}^{16+l}),I_{B^{\ast}}^{%
 Z}(\Bigl[\psi\Bigr]_{16+l}^{16+2l}),I_{B^{\ast}}^{Z}(\Bigl[\psi\Bigr]_{16+2l}^%
 {16+3l}),\Bigl[\psi\Bigr]_{16+3l}^{L(\psi)})\in W^{4}\times Z\times Z\times Z%
 \times B^{\ast}   , such that    (  P  ,  q  ,   g  1   ,   g  2   ,  c  ,  d  ,   h  1   ,   h  2   ,   k  1   ,   k  2   )     P  q   subscript  g  1    subscript  g  2   c  d   subscript  h  1    subscript  h  2    subscript  k  1    subscript  k  2     (P,q,g_{1},g_{2},c,d,h_{1},h_{2},k_{1},k_{2})\,   ,       M  ∈    B  ∗        M   superscript  B  normal-∗     M\in B^{\ast}\,   .   Encryption Process  Algorithm. ACE asymmetric encryption operation. input: public key   ψ   ψ   \psi   and byte string    M    M   M\,   . Output: byte string — ciphertext    r  ∈   {  0  ,  …  ,   q  -  1   }       r   0  normal-…    q  1      r\in\left\{0,...,q-1\right\}   of    s  ∈    W  4        s   superscript  W  4     s\in W^{4}\,   .   Generate     u  1   ←    g  1  r   r  e  m  P      normal-←   subscript  u  1      superscript   subscript  g  1   r   r  e  m  P     u_{1}\leftarrow g_{1}^{r}remP   at random.  Generate the ciphertext preamble:  Generate     u  2   ←    g  2  r   r  e  m  P      normal-←   subscript  u  2      superscript   subscript  g  2   r   r  e  m  P     u_{2}\leftarrow g_{2}^{r}remP   at random.  Compute     α   ←   U  O  W  H  a  s   h  ′    (   k  1   ,    L  B    (  P  )    ,  s  ,   u  1   ,   u  2   )    ∈   Z        normal-←  α    U  O  W  H  a  s   superscript  h  normal-′     subscript  k  1      subscript  L  B   P   s   subscript  u  1    subscript  u  2          Z     \alpha\ \leftarrow UOWHash^{\prime}(k_{1},L_{B}(P),s,u_{1},u_{2})\in Z\,   ,    0  <   α   <    2  160          0  α        superscript  2  160      0<\alpha\ <2^{160}\,   .  Compute    v  ←    c  r    d    α   r    r  e  m   P       normal-←  v     superscript  c  r    superscript  d    α  r    r  e  m  P     v\leftarrow c^{r}d^{\alpha\ r}remP\,   ; note that      h  1   ~   ←    h  1  r   r  e  m  P      normal-←   normal-~   subscript  h  1       superscript   subscript  h  1   r   r  e  m  P     \tilde{h_{1}}\leftarrow h_{1}^{r}remP   .  Compute      h  2   ~   ←    h  2  r   r  e  m  P      normal-←   normal-~   subscript  h  2       superscript   subscript  h  2   r   r  e  m  P     \tilde{h_{2}}\leftarrow h_{2}^{r}remP   .   Compute the key for the symmetric encryption operation:      k  ←   E  S  H  a  s  h   (  k  ,    L  B    (  P  )    ,  s  ,   u  1   ,   u  2   ,    h  1   ~   ,    h  2   ~   )    ∈    W  8         normal-←  k    E  S  H  a  s  h   k     subscript  L  B   P   s   subscript  u  1    subscript  u  2    normal-~   subscript  h  1     normal-~   subscript  h  2            superscript  W  8      k\leftarrow ESHash(k,L_{B}(P),s,u_{1},u_{2},\tilde{h_{1}},\tilde{h_{2}})\in W^%
 {8}\,   ,    e  ←   S  E  n  c   (  k  ,  s  ,  1024  ,  M  )       normal-←  e    S  E  n  c   k  s  1024  M      e\leftarrow SEnc(k,s,1024,M)   .  Compute     ψ   ←   C  E  n  c  o  d  e   (    L  B    (  P  )    ,  s  ,   u  1   ,   u  2   ,  v  ,  e  )       normal-←  ψ    C  E  n  c  o  d  e      subscript  L  B   P   s   subscript  u  1    subscript  u  2   v  e      \psi\ \leftarrow CEncode(L_{B}(P),s,u_{1},u_{2},v,e)   .   Compute cryptogram   ψ   ψ   \psi   .  Encode the ciphertext:      M  ∈    B  ∗        M   superscript  B  normal-∗     M\in B^{\ast}\,   .   Return     M  1   ,  …  ,    M  t        subscript  M  1   normal-…   subscript  M  t     M_{1},...,M_{t}\,   .   Before starting off the symmetric encryption process, the input message     E  i      subscript  E  i    E_{i}\,   is divided into blocks    e  =    E  1    ||   C  1   ||   …   ||   E  t   ||     C  t         e     subscript  E  1    norm   subscript  C  1    normal-…   norm   subscript  E  t     subscript  C  t      e=E_{1}||C_{1}||...||E_{t}||C_{t}\,   , where each of the block, possibly except the last one, is of 1024 bytes. Each block is encrypted by the stream cipher. For each encrypted block     L   (  e  )    =    L   (  M  )    +   16   ⌈    L   (  M  )    /  m   ⌉           L  e       L  M     16        L  M   m        L(e)=L(M)+16\left\lceil L(M)/m\right\rceil   16-byte message authentication code is computed. We get the cryptogram        L   (  M  )    =   0         L  M   0    L(M)=0\,   .     L   (  e  )    =   0         L  e   0    L(e)=0\,   .   Note that if     (  k  ,  s  ,  M  ,  m  )   ∈    W  8   ×   W  4   ×  Z  ×    B  ∗          k  s  M  m      superscript  W  8    superscript  W  4   Z   superscript  B  normal-∗      (k,s,M,m)\in W^{8}\times W^{4}\times Z\times B^{\ast}\,   , then    m  >   0       m  0    m>0\,   . Algorithm. ACE asymmetric encryption process. Input    e  ∈   B  l       e   superscript  B  l     e\in B^{l}       l  =    L   (  M  )    +   16   ⌈    L   (  N  )    /  m   ⌉         l      L  M     16        L  N   m        l=L(M)+16\left\lceil L(N)/m\right\rceil    Output    M  =    λ  B        M   subscript  λ  B     M=\lambda_{B}\,   ,     λ  B      subscript  λ  B    \lambda_{B}\,   .   If     g  e  n  S  t  a  t  e   ←   I  n  i  t  G  e  n   (  k  ,  s  )    ∈   G  e  n  S  t  a  t  e        normal-←    g  e  n  S  t  a  t  e     I  n  i  t  G  e  n   k  s           G  e  n  S  t  a  t  e      genState\leftarrow InitGen(k,s)\in GenState   , then return     k   A  X  U    A  X  U  H  a  s   h        subscript  k    A  X  U    A  X  U  H  a  s  h    k_{AXU}AXUHash\,   .  Initialize a pseudo-random generator state:        (   k   A  X  U    ,   g  e  n  S  t  a  t  e   )   ←   G  e  n  W  o  r  d  s   (   (    5   L  b    (   ⌈   m  /  64   ⌉   )    +  24   )   ,   g  e  n  S  t  a  t  e   )     .     normal-←    subscript  k    A  X  U      g  e  n  S  t  a  t  e      G  e  n  W  o  r  d  s       5   subscript  L  b       m  64     24     g  e  n  S  t  a  t  e       (k_{AXU},genState)\leftarrow GenWords((5L_{b}(\left\lceil m/64\right\rceil)+24%
 ),genState).      Generate the key     e  ←   λ  B    ,   i  ←  0      formulae-sequence   normal-←  e   subscript  λ  B     normal-←  i  0     e\leftarrow\lambda_{B},i\leftarrow 0   :       (   m  a  s   k  m    ,   g  e  n  S  t  a  t  e   )   ←   G  e  n  W  o  r  d  s   (  4  ,   g  e  n  S  t  a  t  e   )       normal-←     m  a  s   subscript  k  m      g  e  n  S  t  a  t  e      G  e  n  W  o  r  d  s   4    g  e  n  S  t  a  t  e       (mask_{m},genState)\leftarrow GenWords(4,genState)   .        (   m  a  s   k  e    ,   g  e  n  S  t  a  t  e   )   ←   G  e  n  W  o  r  d  s   (  r  ,   g  e  n  S  t  a  t  e   )       normal-←     m  a  s   subscript  k  e      g  e  n  S  t  a  t  e      G  e  n  W  o  r  d  s   r    g  e  n  S  t  a  t  e       (mask_{e},genState)\leftarrow GenWords(r,genState)   .  While     e  n  c   ←     [  M  ]   i   i  +  r    ⊕   m  a  s   k  e        normal-←    e  n  c    direct-sum   superscript   subscript   delimited-[]  M   i     i  r      m  a  s   subscript  k  e       enc\leftarrow\Bigl[M\Bigr]_{i}^{i+r}\oplus mask_{e}   .  Generate mask values for the encryption and MAC:       i  +  r   =   L   (  M  )          i  r     L  M     i+r=L(M)\,   .       l  a  s  t  B  l  o  c  k   ←  1     normal-←    l  a  s  t  B  l  o  c  k   1    lastBlock\leftarrow 1   .   Encrypt the plaintext     l  a  s  t  B  l  o  c  k   ←  0     normal-←    l  a  s  t  B  l  o  c  k   0    lastBlock\leftarrow 0   .  Generate the message authentication code:  If     m  a  c   ←   A  X  U  H  a  s  h   (   k   A  X  U    ,   l  a  s  t  B  l  o  c  k   ,   e  n  c   )    ∈   W  4        normal-←    m  a  c     A  X  U  H  a  s  h    subscript  k    A  X  U      l  a  s  t  B  l  o  c  k     e  n  c           superscript  W  4      mac\leftarrow AXUHash(k_{AXU},lastBlock,enc)\in W^{4}   , then    e  ←   e   ||   e  n  c   ||    I   W  ∗    B  ∗     (    m  a  c   ⊕   m  a  s   k  m     )       normal-←  e    e   norm    e  n  c     superscript   subscript  I   superscript  W  normal-∗     superscript  B  normal-∗     direct-sum    m  a  c     m  a  s   subscript  k  m        e\leftarrow e||enc||I_{W^{\ast}}^{B^{\ast}}(mac\oplus mask_{m})   ; else    i  ←   i  +  r      normal-←  i    i  r     i\leftarrow i+r   .      e    e   e\,   .   Update the ciphertext    (  P  ,  q  ,   g  1   ,   g  2   ,  c  ,  d  ,   h  1   ,   h  2   ,   k  1   ,   k  2   )     P  q   subscript  g  1    subscript  g  2   c  d   subscript  h  1    subscript  h  2    subscript  k  1    subscript  k  2     (P,q,g_{1},g_{2},c,d,h_{1},h_{2},k_{1},k_{2})\,   .      (  w  ,  x  ,  y  ,   z  1   ,   z  2   )     w  x  y   subscript  z  1    subscript  z  2     (w,x,y,z_{1},z_{2})\,   .   Return    ψ  ∈   B  ∗       ψ   superscript  B  normal-∗     \psi\in B^{\ast}   .   Decryption process  Algorithm. ACE decryption process. Input: public key    M  ∈    B  ∗   ∪   R  e  j  e  c  t        M     superscript  B  normal-∗     R  e  j  e  c  t      M\in B^{\ast}\cup{Reject}   and corresponding private key     L   (  ψ  )    <    3   L  B    (  P  )    +   16          L  ψ       3   subscript  L  B   P   16     L(\psi)<3L_{B}(P)+16\,   , byt e string    R  e  j  e  c   t       R  e  j  e  c  t    Reject\,   . Output: Decrypted message     (  s  ,   u  1   ,   u  2   ,  v  ,  e  )   ←   C  D  e  c  o  d  e   (    L  B    (  P  )    ,  ψ  )    ∈    W  4   ×  Z  ×  Z  ×  Z  ×   B  ∗         normal-←   s   subscript  u  1    subscript  u  2   v  e     C  D  e  c  o  d  e      subscript  L  B   P   ψ            superscript  W  4   Z  Z  Z   superscript  B  normal-∗       (s,u_{1},u_{2},v,e)\leftarrow CDecode(L_{B}(P),\psi)\in W^{4}\times Z\times Z%
 \times Z\times B^{\ast}   .   Decrypt the ciphertext:  If     0  ≤    u  1   ,   u  2     ,   v  <   256  l       formulae-sequence    0    subscript  u  1    subscript  u  2       v   superscript  256  l      0\leq u_{1},u_{2},v<256^{l}   , then return    l  =    L  B    (  P  )        l     subscript  L  B   P     l=L_{B}(P)\,   .  Compute:       u  1   ≥  P       subscript  u  1   P    u_{1}\geq P   ;   note that     u  2   ≥  P       subscript  u  2   P    u_{2}\geq P   , where    v  ≥  P      v  P    v\geq P   .   Verify the ciphertext preamble:  If    R  e  j  e  c   t       R  e  j  e  c  t    Reject\,   or     u  1  q   ≠   1  r  e  m  P        superscript   subscript  u  1   q     1  r  e  m  P     u_{1}^{q}\neq 1remP   or    R  e  j  e  c   t       R  e  j  e  c  t    Reject\,   , then return     r  e  j  e  c  t   ←   0      normal-←    r  e  j  e  c  t   0    reject\leftarrow 0\,   .  If     u  2   ≠    u  1  w   r  e  m  P        subscript  u  2      superscript   subscript  u  1   w   r  e  m  P     u_{2}\neq u_{1}^{w}remP   , then return     r  e  j  e  c  t   ←   1      normal-←    r  e  j  e  c  t   1    reject\leftarrow 1\,   .      α  ←   U  O  W  H  a  s   h  ′    (   k  1   ,    L  B    (  P  )    ,  s  ,   u  1   ,   u  2   )    ∈  Z       normal-←  α    U  O  W  H  a  s   superscript  h  normal-′     subscript  k  1      subscript  L  B   P   s   subscript  u  1    subscript  u  2          Z     \alpha\leftarrow UOWHash^{\prime}(k_{1},L_{B}(P),s,u_{1},u_{2})\in Z   .  If    0  ≤  α  ≤   2  160         0  α        superscript  2  160      0\leq\alpha\leq 2^{160}   , then    v  ≠    u  1   x  +   α  y     r  e  m  P       v     superscript   subscript  u  1     x    α  y     r  e  m  P     v\neq u_{1}^{x+{\alpha}y}remP   .  Compute     r  e  j  e  c  t   ←   1      normal-←    r  e  j  e  c  t   1    reject\leftarrow 1\,   ; note that     r  e  j  e  c  t   =   1         r  e  j  e  c  t   1    reject=1\,   .  If    R  e  j  e  c   t       R  e  j  e  c  t    Reject\,   , then      h  1   ~   ←    u  1   z  1    r  e  m  P      normal-←   normal-~   subscript  h  1       superscript   subscript  u  1    subscript  z  1    r  e  m  P     \tilde{h_{1}}\leftarrow u_{1}^{z_{1}}remP   .  If      h  2   ~   ←    u  1   z  2    r  e  m  P      normal-←   normal-~   subscript  h  2       superscript   subscript  u  1    subscript  z  2    r  e  m  P     \tilde{h_{2}}\leftarrow u_{1}^{z_{2}}remP   , then return    k  ←   E  S  H  a  s  h   (   k  2   ,    L  B    (  P  )    ,  s  ,   u  1   ,    h  1   ~   ,    h  2   ~   )    ∈   W  8        normal-←  k    E  S  H  a  s  h    subscript  k  2      subscript  L  B   P   s   subscript  u  1    normal-~   subscript  h  1     normal-~   subscript  h  2            superscript  W  8      k\leftarrow ESHash(k_{2},L_{B}(P),s,u_{1},\tilde{h_{1}},\tilde{h_{2}})\in W^{8}   .   Compute the key for the symmetric decryption operation:      M  ←   S  D  e  c   (  k  ,  s  ,  1024  ,  e  )       normal-←  M    S  D  e  c   k  s  1024  e      M\leftarrow SDec(k,s,1024,e)   ,    S  D  e   c       S  D  e  c    SDec\,   .  Compute    R  e  j  e  c   t       R  e  j  e  c  t    Reject\,   .   Compute    M    M   M\,   ;note that    S  D  e   c       S  D  e  c    SDec\,   can return     (  k  ,  s  ,  m  ,  e  )   ∈    W  8   ×   W  4   ×  Z  ×    B  ∗          k  s  m  e      superscript  W  8    superscript  W  4   Z   superscript  B  normal-∗      (k,s,m,e)\in W^{8}\times W^{4}\times Z\times B^{\ast}\,   .  Return    m  >   0       m  0    m>0\,   .   Algorithm. Decryption operation    M  ∈    B  ∗   ∪   R  e  j  e  c  t        M     superscript  B  normal-∗     R  e  j  e  c  t      M\in B^{\ast}\cup{Reject}   . Input    e  =    λ  B        e   subscript  λ  B     e=\lambda_{B}\,        λ  B      subscript  λ  B    \lambda_{B}\,    Output: Decrypted message     g  e  n  S  t  a  t  e   ←   I  n  i  t  G  e  n   (  k  ,  s  )    ∈   G  e  n  S  t  a  t  e        normal-←    g  e  n  S  t  a  t  e     I  n  i  t  G  e  n   k  s           G  e  n  S  t  a  t  e      genState\leftarrow InitGen(k,s)\in GenState   .   If     k   A  X  U    A  X  U  H  a  s   h        subscript  k    A  X  U    A  X  U  H  a  s  h    k_{AXU}AXUHash\,   , then return      (   k   A  X  U    ,   g  e  n  S  t  a  t   e  ′    )   ←   G  e  n  W  o  r  d  s   (   (    5   L  b    (   ⌈   m  /  64   ⌉   )    +  24   )   ,   g  e  n  S  t  a  t  e   )     .     normal-←    subscript  k    A  X  U      g  e  n  S  t  a  t   superscript  e  normal-′       G  e  n  W  o  r  d  s       5   subscript  L  b       m  64     24     g  e  n  S  t  a  t  e       (k_{AXU},genState^{\prime})\leftarrow GenWords((5L_{b}(\left\lceil m/64\right%
 \rceil)+24),genState).   .  Initialize a pseudo-random generator state:       M  ←   λ  B    ,   i  ←  0      formulae-sequence   normal-←  M   subscript  λ  B     normal-←  i  0     M\leftarrow\lambda_{B},i\leftarrow 0      Generate the key    r  ≤  0      r  0    r\leq 0   :      R  e  j  e  c   t       R  e  j  e  c  t    Reject\,   .        (   m  a  s   k  m    ,   g  e  n  S  t  a  t  e   )   ←   G  e  n  W  o  r  d  s   (  4  ,   g  e  n  S  t  a  t  e   )       normal-←     m  a  s   subscript  k  m      g  e  n  S  t  a  t  e      G  e  n  W  o  r  d  s   4    g  e  n  S  t  a  t  e       (mask_{m},genState)\leftarrow GenWords(4,genState)   .  While     (   m  a  s   k  e    ,   g  e  n  S  t  a  t  e   )   ←   G  e  n  W  o  r  d  s   (  r  ,   g  e  n  S  t  a  t  e   )       normal-←     m  a  s   subscript  k  e      g  e  n  S  t  a  t  e      G  e  n  W  o  r  d  s   r    g  e  n  S  t  a  t  e       (mask_{e},genState)\leftarrow GenWords(r,genState)   .  If     i  +  r  +  16   =   L   (  M  )          i  r  16     L  M     i+r+16=L(M)\,   , then return     l  a  s  t  b  l  o  c  k   ←  1     normal-←    l  a  s  t  b  l  o  c  k   1    lastblock\leftarrow 1   .  Generate mask values for the encryption and MAC:       l  a  s  t  b  l  o  c  k   ←  0     normal-←    l  a  s  t  b  l  o  c  k   0    lastblock\leftarrow 0   .       m  a  c   ←   A  X  U  H  a  s  h   (   k   A  X  U    ,   l  a  s  t  B  l  o  c  k   ,    [  e  ]   i   i  +  r    )    ∈   W  4        normal-←    m  a  c     A  X  U  H  a  s  h    subscript  k    A  X  U      l  a  s  t  B  l  o  c  k    superscript   subscript   delimited-[]  e   i     i  r            superscript  W  4      mac\leftarrow AXUHash(k_{AXU},lastBlock,\Bigl[e\Bigr]_{i}^{i+r})\in W^{4}   .   Verify the message authentication code:  If      [  e  ]    r   i  +  r    i  +  r  +  16     ≠    I   W  ∗    B  ∗     (    m  a  c   ⊕   m  a  s   k  m     )           delimited-[]  e    superscript   subscript  r    i  r      i  r  16        superscript   subscript  I   superscript  W  normal-∗     superscript  B  normal-∗     direct-sum    m  a  c     m  a  s   subscript  k  m        \Bigl[e\Big]r_{i+r}^{i+r+16}\neq I_{W^{\ast}}^{B^{\ast}}(mac\oplus mask_{m})   , then    R  e  j  e  c   t       R  e  j  e  c  t    Reject\,   ; else    M  ←  M  |  |   (    [  e  ]   i   i  +  r    )   ⊕  m  a  s   k  e   )     fragments  M  normal-←  M  normal-|  normal-|   fragments  normal-(   superscript   subscript   fragments  normal-[  e  normal-]   i     i  r    normal-)   direct-sum  m  a  s   subscript  k  e   normal-)    M\leftarrow M||(\Bigl[e\Bigr]_{i}^{i+r})\oplus mask_{e})   .      i  ←   i  +  r  +  16      normal-←  i    i  r  16     i\leftarrow i+r+16   .  If    M    M   M\,   , then return    (  N  ,  h  ,  x  ,   e  ′   ,   k  ′   ,  s  )     N  h  x   superscript  e  normal-′    superscript  k  normal-′   s    (N,h,x,e^{\prime},k^{\prime},s)\,   .   Update the plaintext    (  p  ,  q  ,  a  )     p  q  a    (p,q,a)\,   .      m    m   m\,   .   Return    1024  ≤  m  ≤  16384        1024  m       16384     1024\leq m\leq 16384   .   Signature Scheme  The signature scheme employs two key types: ACE Signature public key    p    p   p\,   . ACE Signature private key    ⌊   m  /  2   ⌋        m  2     \left\lfloor m/2\right\rfloor   . For the given size parameter     (   p  -  1   )   /   2         p  1   2    (p-1)/2\,   , such that    q    q   q\,   , key components are defined the following way:     ⌊   m  /  2   ⌋        m  2     \left\lfloor m/2\right\rfloor   —     (   q  -  1   )   /   2         q  1   2    (q-1)/2\,   -bit prime number with    N    N   N\,   — is also a prime number.     N  =   p   q        N    p  q     N=pq\,   —    m    m   m\,   -bit prime number with    m  -   1       m  1    m-1\,   — is also a prime number.     h  ,   x      h  x    h,x\,   —    {  1  ,  …  ,   N  -  1   }     1  normal-…    N  1     \left\{1,...,N-1\right\}   and has either    N    N   N\,   or     e  ′      superscript  e  normal-′    e^{\prime}\,   бит.     a    a   a\,   — elements    {  0  ,  …  ,      (   p  -  1   )    (   q  -  1   )    /  4   -  1   }     0  normal-…          p  1     q  1    4   1     \left\{0,...,(p-1)(q-1)/4-1\right\}   (quadratic residues modulo     k  ′      superscript  k  normal-′    k^{\prime}\,   ).      B  184      superscript  B  184    B^{184}\,   — 161-bit prime number.     s    s   s\,   — element     B  32      superscript  B  32    B^{32}\,        m    m   m\,   — elements    1024  ≤  m  ≤  16384        1024  m       16384     1024\leq m\leq 16384   .     p  ,   q      p  q    p,q\,   — elements     (   p  -  1   )   /   2         p  1   2    (p-1)/2\,   .  Key Generation  Algorithm. Key generation for the ACE public-key signature scheme. Input: size parameter     (   q  -  1   )   /   2         q  1   2    (q-1)/2\,   , such that     2    m  1   -  1    <  p  <   2   m  1           superscript  2     subscript  m  1   1    p        superscript  2   subscript  m  1       2^{m_{1}-1}   . Output: public/private key pair.   Generate random prime numbers    p  ≠  q      p  q    p\neq q   , such that     m  1   =   ⌊   m  /  2   ⌋        subscript  m  1       m  2      m_{1}=\left\lfloor m/2\right\rfloor   and     m  1   =   ⌈   m  /  2   ⌉        subscript  m  1       m  2      m_{1}=\left\lceil m/2\right\rceil   — is also a prime number, and      N  ←   p  q      normal-←  N    p  q     N\leftarrow pq   ,     e  ′      superscript  e  normal-′    e^{\prime}\,      и     2  160   ≤   e  ′   ≤   2  161          superscript  2  160    superscript  e  normal-′         superscript  2  161      2^{160}\leq e^{\prime}\leq 2^{161}   , where         h  ′   ∈   {  1  ,  …  ,   N  -  1   }        superscript  h  normal-′    1  normal-…    N  1      h^{\prime}\in\left\{1,...,N-1\right\}   and     g  c  d   (   h  ′   ,  N  )    =  1        g  c  d    superscript  h  normal-′   N    1    gcd(h^{\prime},N)=1   .   Set     g  c  d   (    h  ′   ±  1   ,  N  )    =  1        g  c  d    plus-or-minus   superscript  h  normal-′   1   N    1    gcd(h^{\prime}\pm 1,N)=1   .  Generate random prime number    h  ←     (   h  ′   )    -  2    r  e  m  N      normal-←  h     superscript   superscript  h  normal-′     2    r  e  m  N     h\leftarrow(h^{\prime})^{-2}remN   , где    a  ∈   {  0  ,  …  ,      (   p  -  1   )    (   q  -  1   )    /  4   -  1   }       a   0  normal-…          p  1     q  1    4   1      a\in\left\{0,...,(p-1)(q-1)/4-1\right\}   .  Generate random    x  ←    h  a   r  e  m  N      normal-←  x     superscript  h  a   r  e  m  N     x\leftarrow h^{a}remN   , taking into account     k  ′   ∈    B  184         superscript  k  normal-′    superscript  B  184     k^{\prime}\in B^{184}\,   and    s  ∈    B  32        s   superscript  B  32     s\in B^{32}\,   , and compute    (   (  N  ,  h  ,  x  ,   e  ′   ,   k  ′   ,  s  )   ,   (  p  ,  q  ,  a  )   )      N  h  x   superscript  e  normal-′    superscript  k  normal-′   s    p  q  a     ((N,h,x,e^{\prime},k^{\prime},s),(p,q,a))\,   .  Generate random    (  d  ,  w  ,  y  ,   y  ′   ,   k  ~   )     d  w  y   superscript  y  normal-′    normal-~  k     (d,w,y,y^{\prime},\tilde{k})   and compute    d    d   d\,   .  Generate random byte strings     B  64      superscript  B  64    B^{64}\,   , and    w    w   w\,   .  Return public key/private key pair       2  160   ≤  w  ≤   2  161          superscript  2  160   w        superscript  2  161      2^{160}\leq w\leq 2^{161}   .    Signature Representation  The signature in the ACE signature scheme has the form    y  ,    y  ′       y   superscript  y  normal-′     y,y^{\prime}\,   , where the components are defined the following way:     {  1  ,  …  ,   N  -  1   }     1  normal-…    N  1     \left\{1,...,N-1\right\}   — element     k  ~      normal-~  k    \tilde{k}\,   .      B  ∗      superscript  B  normal-∗    B^{\ast}\,   — integer, such that     L   (   k  ~   )    =   64  +   20   L  B    (   ⌈    (    L   (  M  )    +  8   )   /  64   ⌉   )           L   normal-~  k      64    20   subscript  L  B           L  M   8   64        L(\tilde{k})=64+20L_{B}(\left\lceil(L(M)+8)/64\right\rceil)   .     M    M   M\,   — elements    S  E  n  c  o  d   e       S  E  n  c  o  d  e    SEncode\,   .     S  D  e  c  o  d   e       S  D  e  c  o  d  e    SDecode\,   — element    l  >   0       l  0    l>0\,   ;note that    d  ∈   B  64       d   superscript  B  64     d\in B^{64}   , where    0  ≤  w  ≤   256  21         0  w        superscript  256  21      0\leq w\leq 256^{21}   — message being signed. We need to introduce the     0  ≤  y   ,    y  ′   <   256  l       formulae-sequence    0  y      superscript  y  normal-′    superscript  256  l      0\leq y,y^{\prime}<256^{l}   function, which maps a signature into its byte string representation, and the corresponding inverse function     k  ~   ∈   B  ∗        normal-~  k    superscript  B  normal-∗     \tilde{k}\in B^{\ast}   . For integer     S  E  n  c  o  d  e   (  l  ,  d  ,  w  ,  y  ,   y  ′   ,   k  ~   )     =  def    d   ||   p  a   d  21    (    I  Z   B  ∗     (  w  )    )    ||   p  a   d  l    (    I  Z   B  ∗     (  y  )    )    ||   p  a   d  l    (    I  Z   B  ∗     (   y  ′   )    )    ||    k  ~    ∈   B  ∗         superscript   def     S  E  n  c  o  d  e   l  d  w  y   superscript  y  normal-′    normal-~  k       d   norm    p  a   subscript  d  21      superscript   subscript  I  Z    superscript  B  normal-∗    w     p  a   subscript  d  l      superscript   subscript  I  Z    superscript  B  normal-∗    y    norm    p  a   subscript  d  l      superscript   subscript  I  Z    superscript  B  normal-∗     superscript  y  normal-′       normal-~  k          superscript  B  normal-∗      SEncode(l,d,w,y,y^{\prime},\tilde{k})\stackrel{\mathrm{def}}{=}d||pad_{21}(I_{%
 Z}^{B^{\ast}}(w))||pad_{l}(I_{Z}^{B^{\ast}}(y))||pad_{l}(I_{Z}^{B^{\ast}}(y^{%
 \prime}))||\tilde{k}\in B^{\ast}   , byte string    l  >   0       l  0    l>0\,   , integers    σ  ∈   B  ∗       σ   superscript  B  normal-∗     \sigma\in B^{\ast}   and     L   (  σ  )    ≥    2  l   +  53         L  σ       2  l   53     L(\sigma)\geq 2l+53   , and byte string     C  S  e  c  o  d  e   (  l  ,  σ  )     =  def    (    [  σ  ]   0  64   ,    I   B  ∗   Z    (    [  σ  ]   64  85   )    ,    I   B  ∗   Z    (    [  σ  ]   85   85  +  l    )    ,    I   B  ∗   Z    (    [  σ  ]    85  +  l    85  +   2  l     )    ,    [  σ  ]    85  +   2  l     L   (  σ  )     )   ∈    B  64   ×  Z  ×  Z  ×  Z  ×   B  ∗          superscript   def     C  S  e  c  o  d  e   l  σ      superscript   subscript   delimited-[]  σ   0   64      superscript   subscript  I   superscript  B  normal-∗    Z    superscript   subscript   delimited-[]  σ   64   85       superscript   subscript  I   superscript  B  normal-∗    Z    superscript   subscript   delimited-[]  σ   85     85  l        superscript   subscript  I   superscript  B  normal-∗    Z    superscript   subscript   delimited-[]  σ     85  l      85    2  l       superscript   subscript   delimited-[]  σ     85    2  l       L  σ             superscript  B  64   Z  Z  Z   superscript  B  normal-∗       CSecode(l,\sigma)\stackrel{\mathrm{def}}{=}(\Bigl[\sigma\Bigr]_{0}^{64},I_{B^{%
 \ast}}^{Z}(\Bigl[\sigma\Bigr]_{64}^{85}),I_{B^{\ast}}^{Z}(\Bigl[\sigma\Bigr]_{%
 85}^{85+l}),I_{B^{\ast}}^{Z}(\Bigl[\sigma\Bigr]_{85+l}^{85+2l}),\Bigl[\sigma%
 \Bigr]_{85+2l}^{L(\sigma)})\in B^{64}\times Z\times Z\times Z\times B^{\ast}   ,       (  N  ,  h  ,  x  ,   e  ′   ,   k  ′   ,  s  )     N  h  x   superscript  e  normal-′    superscript  k  normal-′   s    (N,h,x,e^{\prime},k^{\prime},s)\,   .   For integer    (  p  ,  q  ,  a  )     p  q  a    (p,q,a)\,   , byte string    M  ∈    B  ∗        M   superscript  B  normal-∗     M\in B^{\ast}\,   , where    0  ≤   L   (  M  )    ≤   2  64         0    L  M         superscript  2  64      0\leq L(M)\leq 2^{64}   ,       σ  ∈    B  ∗        σ   superscript  B  normal-∗     \sigma\in B^{\ast}\,   .   Signature Generation Process  Algorithm. ACE Signature Generation Process. Input: public key     k  ~   ∈   B    20  m   +  64         normal-~  k    superscript  B      20  m   64      \tilde{k}\in B^{20m+64}   and corresponding private key    m  =    L  b    (   ⌈    (    L   (  M  )    +  8   )   /  64   ⌉   )        m     subscript  L  b           L  M   8   64       m=L_{b}(\left\lceil(L(M)+8)/64\right\rceil)   and byte string     m  h   ←    I   W  ∗   Z    (   U  O  W  H  a  s   h  ′′    (   k  ~   ,  M  )    )       normal-←   subscript  m  h      superscript   subscript  I   superscript  W  normal-∗    Z     U  O  W  H  a  s   superscript  h  ′′     normal-~  k   M       m_{h}\leftarrow I_{W^{\ast}}^{Z}(UOWHash^{\prime\prime}(\tilde{k},M))   ,     y  ~   ∈   {  1  ,  …  ,   N  -  1   }        normal-~  y    1  normal-…    N  1      \tilde{y}\in\left\{1,...,N-1\right\}   . Output: byte string — digital signature     y  ′   ←     y  ~   2   r  e  m  N      normal-←   superscript  y  normal-′      superscript   normal-~  y   2   r  e  m  N     y^{\prime}\leftarrow\tilde{y}^{2}remN   .   Perform the following steps to hash the input data:  Generate a hash key     x  ′   ←     (   y  ′   )    r  ′     h   m  h    r  e  m  N      normal-←   superscript  x  normal-′      superscript   superscript  y  normal-′    superscript  r  normal-′     superscript  h   subscript  m  h    r  e  m  N     x^{\prime}\leftarrow(y^{\prime})^{r^{\prime}}h^{m_{h}}remN   at random, such that    e    e   e\,   .  Compute     2  160   ≤  e  ≤   2  161          superscript  2  160   e        superscript  2  161      2^{160}\leq e\leq 2^{161}   .   Select    (  w  ,  d  )     w  d    (w,d)\,   at random, and compute     (  e  ,  w  ,  d  )   ←   G  e  n  C  e  r  t  P  r  i  m  e   (  s  )       normal-←   e  w  d     G  e  n  C  e  r  t  P  r  i  m  e  s     (e,w,d)\leftarrow GenCertPrime(s)\,   .  Compute    e  ≠    e  ′        e   superscript  e  normal-′     e\neq e^{\prime}\,   .  Generate a random prime    r  ←   U  O  W  H  a  s   h  ′′′    (   k  ′   ,    L  B    (  N  )    ,   x  ′   ,   k  ~   )    ∈  Z       normal-←  r    U  O  W  H  a  s   superscript  h  ′′′     superscript  k  normal-′      subscript  L  B   N    superscript  x  normal-′    normal-~  k          Z     r\leftarrow UOWHash^{\prime\prime\prime}(k^{\prime},L_{B}(N),x^{\prime},\tilde%
 {k})\in Z   ,    0  ≤  r  <   2  160         0  r        superscript  2  160      0\leq r<2^{160}   , and its certificate of correctness    y  ←    h  b   r  e  m  N      normal-←  y     superscript  h  b   r  e  m  N     y\leftarrow h^{b}remN       b  ←    e   -  1     (   a  -  r   )   r  e  m   (    p  ′    q  ′    )       normal-←  b     superscript  e    1      a  r   r  e  m     superscript  p  normal-′    superscript  q  normal-′       b\leftarrow e^{-1}(a-r)rem(p^{\prime}q^{\prime})   . Repeat this step until     p  ′   =    (   p  -  1   )   /  2        superscript  p  normal-′       p  1   2     p^{\prime}=(p-1)/2   .  Set     q  ′   =    (   q  -  1   )   /  2        superscript  q  normal-′       q  1   2     q^{\prime}=(q-1)/2   ; note that    σ  ←   S  E  n  c  o  d  e   (    L  B    (  N  )    ,  d  ,  w  ,  y  ,   y  ′   ,   k  ~   )       normal-←  σ    S  E  n  c  o  d  e      subscript  L  B   N   d  w  y   superscript  y  normal-′    normal-~  k       \sigma\leftarrow SEncode(L_{B}(N),d,w,y,y^{\prime},\tilde{k})   .  Compute    σ    σ   \sigma\,   , where  $b \leftarrow e^{-1}(a-r)rem(p^{\prime}q^{\prime})$ ,   and where $p^{\prime}=(p-1)/2$ and $q^{\prime}=(q-1)/2$ .  Encode the signature:  $\sigma \leftarrow SEncode(L_B(N),d,w,y,y^{\prime},\tilde{k})$ .   Return $\sigma\,$   Notes  In the definition of ACE Encryption process and ACE Signature process some auxiliary function(e.g. UOWHash,ESHash and some other) are being used, definition of which goes beyond this article. You cand find more details about it in в. 1  Implementation, Utilization and Performance  ACE Encryption scheme is recommended by NESSIE (New European Schemes for Signatures, Integrity and Encryption) as asymmetric encryption scheme. Press-release is dated by February 2003.  Both schemes were implemented in ANSI C, with the use of GNU GMP library. Tests were done on two platforms: Power PC 604 model 43P under AIX system and 266 MHz Pentium under Windows NT system. Result tables:  Table 1. Time costs on basic operations.       Power PC   Pentium      Operand size(byte)   Operand size(byte)      512   1024     Multiplication   3.5 * 10^(-5) sec   1.0 * 10^(-4) sec     Squaring   3.3 * 10^(-5) sec   1.0 * 10^(-4) sec     Exponentiation   1.9 * 10^(-2) sec   1.2 * 10^(-1) sec     Table 2. Performance of encryption scheme and signature scheme.       Power PC   Pentium      Fixed costs (ms)   MBit/sec     Encrypt   160   18     Decrypt   68   18     Sign   48   64     Sign set-up   29      Verify   52   65     Literature    External links   http://www.alphaworks.ibm.com/tech/ace  http://www.zurich.ibm.com/security/ace/  NESSIE Portfolio of recommended cryptographic primitives   "  Category:Cryptographic software     ACE: The Advanced Cryptographic Engine, T. Schweinberger and V. Shoup, manuscript 2000 ↩     