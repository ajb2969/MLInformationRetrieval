   Golden section search      Golden section search  table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */     (Figure)  Diagram of a golden section search   The golden section search is a technique for finding the extremum (minimum or maximum) of a strictly unimodal function by successively narrowing the range of values inside which the extremum is known to exist. The technique derives its name from the fact that the algorithm maintains the function values for triples of points whose distances form a golden ratio . The algorithm is the limit of Fibonacci search (also described below) for a large number of function evaluations. Fibonacci search and Golden section search were discovered by Kiefer (1953). (see also Avriel and Wilde (1966)).  Basic idea  The diagram above illustrates a single step in the technique for finding a minimum. The functional values of    f   (  x  )       f  x    f(x)   are on the vertical axis, and the horizontal axis is the x parameter. The value of    f   (  x  )       f  x    f(x)   has already been evaluated at the three points    x  1     subscript  x  1    x_{1}   ,    x  2     subscript  x  2    x_{2}   , and    x  3     subscript  x  3    x_{3}   . Since    f  2     subscript  f  2    f_{2}   is smaller than either    f  1     subscript  f  1    f_{1}   or    f  3     subscript  f  3    f_{3}   , it is clear that a minimum lies inside the interval from    x  1     subscript  x  1    x_{1}   to    x  3     subscript  x  3    x_{3}   (since f is unimodal ).  The next step in the minimization process is to "probe" the function by evaluating it at a new value of x , namely    x  4     subscript  x  4    x_{4}   . It is most efficient to choose    x  4     subscript  x  4    x_{4}   somewhere inside the largest interval, i.e. between    x  2     subscript  x  2    x_{2}   and    x  3     subscript  x  3    x_{3}   . From the diagram, it is clear that if the function yields    f   4  a      subscript  f    4  a     f_{4a}   then a minimum lies between    x  1     subscript  x  1    x_{1}   and    x  4     subscript  x  4    x_{4}   and the new triplet of points will be    x  1     subscript  x  1    x_{1}   ,    x  2     subscript  x  2    x_{2}   , and    x  4     subscript  x  4    x_{4}   . However if the function yields the value    f   4  b      subscript  f    4  b     f_{4b}   then a minimum lies between    x  2     subscript  x  2    x_{2}   and    x  3     subscript  x  3    x_{3}   , and the new triplet of points will be    x  2     subscript  x  2    x_{2}   ,    x  4     subscript  x  4    x_{4}   , and    x  3     subscript  x  3    x_{3}   . Thus, in either case, we can construct a new narrower search interval that is guaranteed to contain the function's minimum.  Probe point selection  From the diagram above, it is seen that the new search interval will be either between    x  1     subscript  x  1    x_{1}   and    x  4     subscript  x  4    x_{4}   with a length of a + c , or between    x  2     subscript  x  2    x_{2}   and    x  3     subscript  x  3    x_{3}   with a length of b . The golden section search requires that these intervals be equal. If they are not, a run of "bad luck" could lead to the wider interval being used many times, thus slowing down the rate of convergence. To ensure that b = a + c , the algorithm should choose     x  4   =    x  1   +   (    x  3   -   x  2    )         subscript  x  4      subscript  x  1      subscript  x  3    subscript  x  2       x_{4}=x_{1}+(x_{3}-x_{2})   .  However there still remains the question of where    x  2     subscript  x  2    x_{2}   should be placed in relation to    x  1     subscript  x  1    x_{1}   and    x  3     subscript  x  3    x_{3}   . The golden section search chooses the spacing between these points in such a way that these points have the same proportion of spacing as the subsequent triple     x  1   ,   x  2   ,   x  4       subscript  x  1    subscript  x  2    subscript  x  4     x_{1},x_{2},x_{4}   or     x  2   ,   x  4   ,   x  3       subscript  x  2    subscript  x  4    subscript  x  3     x_{2},x_{4},x_{3}   . By maintaining the same proportion of spacing throughout the algorithm, we avoid a situation in which    x  2     subscript  x  2    x_{2}   is very close to    x  1     subscript  x  1    x_{1}   or    x  3     subscript  x  3    x_{3}   , and guarantee that the interval width shrinks by the same constant proportion in each step.  Mathematically, to ensure that the spacing after evaluating    f   (   x  4   )       f   subscript  x  4     f(x_{4})   is proportional to the spacing prior to that evaluation, if    f   (   x  4   )       f   subscript  x  4     f(x_{4})   is    f   4  a      subscript  f    4  a     f_{4a}   and our new triplet of points is    x  1     subscript  x  1    x_{1}   ,    x  2     subscript  x  2    x_{2}   , and    x  4     subscript  x  4    x_{4}   then we want:        c  a   =   a  b    .        c  a     a  b     \frac{c}{a}=\frac{a}{b}.     However, if    f   (   x  4   )       f   subscript  x  4     f(x_{4})   is    f   4  b      subscript  f    4  b     f_{4b}   and our new triplet of points is    x  2     subscript  x  2    x_{2}   ,    x  4     subscript  x  4    x_{4}   , and    x  3     subscript  x  3    x_{3}   then we want:        c   (   b  -  c   )    =   a  b    .        c    b  c      a  b     \frac{c}{(b-c)}=\frac{a}{b}.     Eliminating c from these two simultaneous equations yields:        (   b  a   )   2   =    b  a   +  1        superscript    b  a   2       b  a   1     \left(\frac{b}{a}\right)^{2}=\frac{b}{a}+1     or       b  a   =  φ        b  a   φ    \frac{b}{a}=\varphi     where φ  is the golden ratio :      φ  =    1  +   5    2   =   1.618033988  …         φ      1    5    2          1.618033988  normal-…      \varphi=\frac{1+\sqrt{5}}{2}=1.618033988\ldots     The appearance of the golden ratio in the proportional spacing of the evaluation points is how this search algorithm gets its name.  Termination condition  In addition to a routine for reducing the size of the bracketing of the solution, a complete algorithm must have a termination condition. The one provided in the book Numerical Recipes in C is based on testing the gaps among    x  1     subscript  x  1    x_{1}   ,    x  2     subscript  x  2    x_{2}   ,    x  3     subscript  x  3    x_{3}   and    x  4     subscript  x  4    x_{4}   , terminating when within the relative accuracy bounds:       |    x  3   -   x  1    |   <   τ   (    |   x  2   |   +   |   x  4   |    )             subscript  x  3    subscript  x  1       τ       subscript  x  2       subscript  x  4        |x_{3}-x_{1}|<\tau(|x_{2}|+|x_{4}|)\,     where   τ   τ   \tau   is a tolerance parameter of the algorithm and    |  x  |      x    |x|   is the absolute value of   x   x   x   . The check is based on the bracket size relative to its central value, because that relative error in   x   x   x   is approximately proportional to the squared absolute error in    f   (  x  )       f  x    f(x)   in typical cases. For that same reason, the Numerical Recipes text recommends that    τ  =   ϵ       τ    ϵ     \tau=\sqrt{\epsilon}   where   ϵ   ϵ   \epsilon   is the required absolute precision of    f   (  x  )       f  x    f(x)   .  Algorithm  Iterative algorithm   Let [a, b] be interval of current bracket. f(a), f(b) would already have been computed earlier.    φ  =    (    -  1   +   5    )   /  2       φ        1     5    2     \varphi=(-1+\sqrt{5})/2   .  Let c = b + φ (a - b), d = a + φ (b - a). If f(c), f(d) not available, compute them.  If f(c) < f(d) (this is to find min, to find max, just reverse it) then move the data: (b, f(b)) ← (d, f(d)), (d, f(d)) ← (c, f(c)) and update c = b + φ (a - b) and f(c);  otherwise, move the data: (a, f(a)) ← (c, f(c)), (c, f(c)) ← (d, f(d)) and update d = a + φ (b - a) and f(d).  At the end of the iteration, [a, c, d, b] bracket the minimum point.   # python program for golden section search gr = (math.sqrt( 5 ) - 1 ) / 2  def gss(f,a,b,tol = 1e-5 ): '''golden section search  to find the minimum of f on [a,b]  f: a strictly unimodal function on [a,b]  example:  >>> f=lambda x:(x-2)**2  >>> x=gss(f,1,5)  >>> x  2.000009644875678  ''' c = b - gr * (b - a)
     d = a + gr * (b - a) while  abs (c - d) > tol:       
         fc = f(c) ; fd = f(d) if fc < fd: #fc="fd;fd=f(d)" #fd="fc;fc=f(c)" (b+a)="" 2="" <="" a="c" b="d" c="d" d="a+gr*(b-a)" else:="" return="" source="">  === Recursive algorithm ===  < source lang = "java" > double phi = ( 1  + Math.sqrt( 5 )) /  2 ; double resphi =  2  - phi ;  // a and c are the current bounds ; the minimum is between them. // b is a center point // f(x) is some mathematical function elsewhere defined // a corresponds to x1 ; b corresponds to x2 ; c corresponds to x3 // x corresponds to x4 // tau is a tolerance parameter ; see above
 
 public double goldenSectionSearch(double a, double b, double c, double tau) {
     double x ;  if (c - b > b - a)
       x = b + resphi * (c - b) ;  else x = b - resphi * (b - a) ;  if (Math. abs (c - a) < tau * (Math. abs (b) + Math. abs (x))) return (c + a) /  2 ;  assert (f(x) != f(b)) ;  if (f(x) < f(b)) { if (c - b > b - a) return goldenSectionSearch(b, x, c, tau) ;  else  return goldenSectionSearch(a, x, b, tau) ; } else { if (c - b > b - a) return goldenSectionSearch(a, b, x, tau) ;  else  return goldenSectionSearch(x, b, c, tau) ; }
   }  To realise the advantage of golden section search, the function    f   (  x  )       f  x    f(x)   would be implemented with caching, so that in all invocations of goldenSectionSearch(..) above, except the first,    f   (   x  2   )       f   subscript  x  2     f(x_{2})   would have already been evaluated previously — the result of the calculation will be re-used, bypassing the (perhaps expensive) explicit evaluation of the function. Together with a slightly smaller number of recursions, this 50% saving in the number of calls to    f   (  x  )       f  x    f(x)   is the main algorithmic advantage over Ternary search .  Fibonacci search  A very similar algorithm can also be used to find the extremum (minimum or maximum) of a sequence of values that has a single local minimum or local maximum. In order to approximate the probe positions of golden section search while probing only integer sequence indices, the variant of the algorithm for this case typically maintains a bracketing of the solution in which the length of the bracketed interval is a Fibonacci number . For this reason, the sequence variant of golden section search is often called Fibonacci search .  Fibonacci search was first devised by Kiefer (1953) as a minimax search for the maximum (minimum) of a unimodal function in an interval.   ;;   See also   Fibonacci search technique  Brent's method  Binary search   References         "  Category:Golden ratio  Category:Fibonacci numbers  Category:Optimization algorithms and methods  Category:Articles with example Java code  