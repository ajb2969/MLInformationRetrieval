<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1772">Metropolis–Hastings algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Metropolis–Hastings algorithm</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The proposal <a href="probability_distribution" title="wikilink">distribution</a> <em>Q</em> proposes the next point that the <a href="random_walk" title="wikilink">random walk</a> might move to.</figcaption>
</figure>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a> and in <a href="statistical_physics" title="wikilink">statistical physics</a>, the <strong>Metropolis–Hastings algorithm</strong> is a <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a> (MCMC) method for obtaining a sequence of <a href="pseudo-random_number_sampling" title="wikilink">random samples</a> from a <a href="probability_distribution" title="wikilink">probability distribution</a> for which direct sampling is difficult. This sequence can be used to approximate the distribution (i.e., to generate a <a class="uri" href="histogram" title="wikilink">histogram</a>), or to <a href="Monte_Carlo_integration" title="wikilink">compute an integral</a> (such as an <a href="expected_value" title="wikilink">expected value</a>). Metropolis–Hastings and other MCMC algorithms are generally used for sampling from multi-dimensional distributions, especially when the number of dimensions is high. For single-dimensional distributions, other methods are usually available (e.g. <a href="adaptive_rejection_sampling" title="wikilink">adaptive rejection sampling</a>) that can directly return independent samples from the distribution, and are free from the problem of auto-correlated samples that is inherent in MCMC methods.</p>
<h2 id="history">History</h2>

<p>The algorithm was named after <a href="Nicholas_Metropolis" title="wikilink">Nicholas Metropolis</a>, who was an author along with <a href="Arianna_W._Rosenbluth" title="wikilink">Arianna W. Rosenbluth</a>, <a href="Marshall_N._Rosenbluth" title="wikilink">Marshall N. Rosenbluth</a>, <a href="Augusta_H._Teller" title="wikilink">Augusta H. Teller</a>, and <a href="Edward_Teller" title="wikilink">Edward Teller</a> of the 1953 paper <em><a href="Equation_of_State_Calculations_by_Fast_Computing_Machines" title="wikilink">Equation of State Calculations by Fast Computing Machines</a></em> which first proposed the algorithm for the specific case of the <a href="canonical_ensemble" title="wikilink">canonical ensemble</a>;<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and <a href="W._K._Hastings" title="wikilink">W. K. Hastings</a> who extended it to the more general case in 1970.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> There is controversy over the credit for discovery of the algorithm. Edward Teller states in his memoirs that the five authors of the 1953 paper worked together for "days (and nights)".<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> M. Rosenbluth, in an oral history recorded shortly before his death<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> credits E. Teller with posing the original problem, himself with solving it, and A.W. Rosenbluth (his wife) with programming the computer. According to M. Rosenbluth, neither Metropolis nor A.H. Teller participated in any way. Rosenbluth's account of events is supported by other contemporary recollections.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> According to <a href="Roy_Glauber" title="wikilink">Roy Glauber</a> and <a href="Emilio_Segrè" title="wikilink">Emilio Segrè</a>, the original algorithm was invented by <a href="Enrico_Fermi" title="wikilink">Enrico Fermi</a> and reinvented by <a href="Stan_Ulam" title="wikilink">Stan Ulam</a>.</p>
<h2 id="intuition">Intuition</h2>

<p>The Metropolis–Hastings algorithm can draw samples from any <a href="probability_distribution" title="wikilink">probability distribution</a> <em>P(x)</em>, provided you can compute the value of a function <em>f(x)</em> which is <em>proportional</em> to the density of <em>P</em>. The lax requirement that <em>f(x)</em> should be merely proportional to the density, rather than exactly equal to it, makes the Metropolis–Hastings algorithm particularly useful, because calculating the necessary normalization factor is often extremely difficult <a href="Bayesian_statistics" title="wikilink">in practice</a>.</p>

<p>The Metropolis–Hastings algorithm works by generating a sequence of sample values in such a way that, as more and more sample values are produced, the distribution of values more closely approximates the desired distribution, <em>P(x)</em>. These sample values are produced iteratively, with the distribution of the next sample being dependent only on the current sample value (thus making the sequence of samples into a <a href="Markov_chain" title="wikilink">Markov chain</a>). Specifically, at each iteration, the algorithm picks a candidate for the next sample value based on the current sample value. Then, with some probability, the candidate is either accepted (in which case the candidate value is used in the next iteration) or rejected (in which case the candidate value is discarded, and current value is reused in the next iteration)−the probability of acceptance is determined by comparing the values of the function <em>f(x)</em> of the current and candidate sample values with respect to the desired distribution <em>P(x)</em>.</p>

<p>For the purpose of illustration, the Metropolis algorithm, a special case of the Metropolis–Hastings algorithm where the proposal function is symmetric, is described below.</p>

<p><strong>Metropolis algorithm (symmetric proposal distribution)</strong></p>

<p>Let <em>f(x)</em> be a function that is proportional to the desired probability distribution <em>P(x) (a.k.a. a target distribution)</em>.</p>
<ol>
<li>Initialization: Choose an arbitrary point <em>x<sub>0</sub></em> to be the first sample, and choose an arbitrary probability density 

<math display="inline" id="Metropolis–Hastings_algorithm:0">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x|y)
  </annotation>
 </semantics>
</math>

 which suggests a candidate for the next sample value <em>x</em>, given the previous sample value <em>y</em>. For the Metropolis algorithm, <em>Q</em> must be symmetric; in other words, it must satisfy 

<math display="inline" id="Metropolis–Hastings_algorithm:1">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x|y)=Q(y|x)
  </annotation>
 </semantics>
</math>

. A usual choice is to let 

<math display="inline" id="Metropolis–Hastings_algorithm:2">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x|y)
  </annotation>
 </semantics>
</math>

 be a <a href="Gaussian_distribution" title="wikilink">Gaussian distribution</a> centered at <em>y</em>, so that points closer to <em>y</em> are more likely to be visited next—making the sequence of samples into a <a href="random_walk" title="wikilink">random walk</a>. The function <em>Q</em> is referred to as the <em>proposal density</em> or <em>jumping distribution</em>.</li>
<li>For each iteration <em>t</em>:
<ul>
<li>Generate a candidate <em>x</em>' for the next sample by picking from the distribution 

<math display="inline" id="Metropolis–Hastings_algorithm:3">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x^{\prime}|x_{t})
  </annotation>
 </semantics>
</math>

.</li>
<li>Calculate the <em>acceptance ratio</em> α = <em>f(x')/f(x<sub>t</sub>)</em>, which will be used to decide whether to accept or reject the candidate. Because <em>f</em> is proportional to the density of <em>P</em>, we have that '' α = f(x')/f(x<sub>t</sub>)'' = <em>P(x')/P(x<sub>t</sub>)</em>.</li>
<li>If α ≥ 1, then the candidate is more likely than <em>x<sub>t</sub></em>; automatically accept the candidate by setting <em>x<sub>t+1</sub> = x</em>'. Otherwise, accept the candidate with probability α; if the candidate is rejected, set <em>x<sub>t+1</sub> = x<sub>t</sub></em>, instead.</li>
</ul></li>
</ol>

<p>This algorithm proceeds by randomly attempting to move about the sample space, sometimes accepting the moves and sometimes remaining in place. Note that the acceptance ratio 

<math display="inline" id="Metropolis–Hastings_algorithm:4">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 indicates how probable the new proposed sample is with respect to the current sample, according to the distribution 

<math display="inline" id="Metropolis–Hastings_algorithm:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(x)
  </annotation>
 </semantics>
</math>

. If we attempt to move to a point that is more probable than the existing point (i.e. a point in a higher-density region of 

<math display="inline" id="Metropolis–Hastings_algorithm:6">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(x)
  </annotation>
 </semantics>
</math>

), we will always accept the move. However, if we attempt to move to a less probable point, we will sometimes reject the move, and the more the relative drop in probability, the more likely we are to reject the new point. Thus, we will tend to stay in (and return large numbers of samples from) high-density regions of 

<math display="inline" id="Metropolis–Hastings_algorithm:7">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(x)
  </annotation>
 </semantics>
</math>

, while only occasionally visiting low-density regions. Intuitively, this is why this algorithm works, and returns samples that follow the desired distribution 

<math display="inline" id="Metropolis–Hastings_algorithm:8">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>Compared with an algorithm like <a href="adaptive_rejection_sampling" title="wikilink">adaptive rejection sampling</a> that directly generates independent samples from a distribution, Metropolis–Hastings and other MCMC algorithms have a number of disadvantages:</p>
<ul>
<li>The samples are correlated. Even though over the long term they do correctly follow 

<math display="inline" id="Metropolis–Hastings_algorithm:9">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(x)
  </annotation>
 </semantics>
</math>

, a set of nearby samples will be correlated with each other and not correctly reflect the distribution. This means that if we want a set of independent samples, we have to throw away the majority of samples and only take every <em>n</em>th sample, for some value of <em>n</em> (typically determined by examining the auto-correlation between adjacent samples). Auto-correlation can be reduced by increasing the <em>jumping width</em> (the average size of a jump, which is related to the variance of the jumping distribution), but this will also increase the likelihood of rejection of the proposed jump. Too large or too small a jumping size will lead to a <em>slow-mixing</em> Markov chain, i.e. a highly correlated set of samples, so that a very large number of samples will be needed to get a reasonable estimate of any desired property of the distribution.</li>
<li>Although the Markov chain eventually converges to the desired distribution, the initial samples may follow a very different distribution, especially if the starting point is in a region of low density. As a result, a <em>burn-in</em> period is typically necessary, where an initial number of samples (e.g. the first 1,000 or so) are thrown away.</li>
</ul>

<p>On the other hand, most simple <a href="rejection_sampling" title="wikilink">rejection sampling</a> methods suffer from the "curse of dimensionality", where the probability of rejection increases exponentially as a function of the number of dimensions. Metropolis–Hastings, along with other MCMC methods, do not have this problem to such a degree, and thus are often the only solutions available when the number of dimensions of the distribution to be sampled is high. As a result, MCMC methods are often the methods of choice for producing samples from <a href="hierarchical_Bayesian_model" title="wikilink">hierarchical Bayesian models</a> and other high-dimensional statistical models used nowadays in many disciplines.</p>

<p>In <a href="multivariate_distribution" title="wikilink">multivariate</a> distributions, the classic Metropolis–Hastings algorithm as described above involves choosing a new multi-dimensional sample point. When the number of dimensions is high, finding the right jumping distribution to use can be difficult, as the different individual dimensions behave in very different ways, and the jumping width (see above) must be "just right" for all dimensions at once to avoid excessively slow mixing. An alternative approach that often works better in such situations, known as <a href="Gibbs_sampling" title="wikilink">Gibbs sampling</a>, involves choosing a new sample for each dimension separately from the others, rather than choosing a sample for all dimensions at once. This is especially applicable when the multivariate distribution is composed out of a set of individual <a href="random_variable" title="wikilink">random variables</a> in which each variable is conditioned on only a small number of other variables, as is the case in most typical <a href="hierarchical_Bayesian_model" title="wikilink">hierarchical models</a>. The individual variables are then sampled one at a time, with each variable conditioned on the most recent values of all the others. Various algorithms can be used to choose these individual samples, depending on the exact form of the multivariate distribution: some possibilities are <a href="adaptive_rejection_sampling" title="wikilink">adaptive rejection sampling</a>, a one-dimensional Metropolis–Hastings step, or <a href="slice_sampling" title="wikilink">slice sampling</a>.</p>
<h2 id="formal-derivation-of-the-metropolis-hastings-algorithm">Formal derivation of the Metropolis-Hastings algorithm</h2>

<p>The purpose of the Metropolis–Hastings algorithm is to generate a collection of states according to a desired distribution P(x). To accomplish this, the algorithm uses a <a href="Markov_process" title="wikilink">Markov process</a> which asymptotically reaches a unique <a href="Markov_chain#Steady-state_analysis_and_limiting_distributions" title="wikilink">stationary distribution</a> π(x) such that π(x)=P(x) .<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>A Markov process is uniquely defined by its transition probabilities, the probability 

<math display="inline" id="Metropolis–Hastings_algorithm:10">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x\rightarrow x^{\prime})
  </annotation>
 </semantics>
</math>

 of transitioning between any two states x to x'. It has a unique stationary distribution π(x) when the following two conditions are met:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<ol>
<li><strong>existence of stationary distribution</strong>: there must exist a stationary distribution π(x). A sufficient but not necessary condition is <a href="Markov_chain#Reversible_Markov_chain" title="wikilink">detailed balance</a> which requires that each transition x→x' is reversible: for every pair of states x, x', the probability of being in state x and transit to the state x' must be equal to the probability of being in state x' and transit to the state x, 

<math display="inline" id="Metropolis–Hastings_algorithm:11">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo>→</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">π</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">π</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-→</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(x)P(x\rightarrow x^{\prime})=\pi(x^{\prime})P(x^{\prime}\rightarrow x)
  </annotation>
 </semantics>
</math>

.</li>
<li><strong>uniqueness of stationary distribution</strong>: the stationary distribution π(x) must be unique. This is guaranteed by <a href="Markov_Chain#Ergodicity" title="wikilink">ergodicity</a> of the Markov process, which requires that every state must (1) be aperiodic—the system does not return to the same state at fixed intervals; and (2) be positive recurrent—the expected number of steps for returning to the same state is finite.</li>
</ol>

<p>Metropolis–Hastings algorithm resides in designing a Markov process (by constructing transition probabilities) which fulfils the two above conditions, such that its stationary distribution π(x) is chosen to be <em>P(x)</em>. The derivation of the algorithm starts with the condition of detailed balance:</p>

<p>

<math display="inline" id="Metropolis–Hastings_algorithm:12">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo>→</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-→</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)P(x\rightarrow x^{\prime})=P(x^{\prime})P(x^{\prime}\rightarrow x)
  </annotation>
 </semantics>
</math>

</p>

<p>which is re-written as</p>

<p>

<math display="inline" id="Metropolis–Hastings_algorithm:13">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>→</mo>
      <msup>
       <mi>x</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>′</mo>
      </msup>
      <mo>→</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-→</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-→</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{P(x\rightarrow x^{\prime})}{P(x^{\prime}\rightarrow x)}=\frac{P(x^{%
\prime})}{P(x)}
  </annotation>
 </semantics>
</math>

.</p>

<p>The approach is to separate the transition in two sub-steps; the proposal and the acceptance-rejection. The <strong>proposal distribution</strong> 

<math display="inline" id="Metropolis–Hastings_algorithm:14">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle g(x\rightarrow x^{\prime})
  </annotation>
 </semantics>
</math>

 is the conditional probability of proposing a state x' given x, and the <strong>acceptance distribution</strong> 

<math display="inline" id="Metropolis–Hastings_algorithm:15">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A(x\rightarrow x^{\prime})
  </annotation>
 </semantics>
</math>

 the conditional probability to accept the proposed state x'. The transition probability can be written as the product of them:</p>

<p>

<math display="inline" id="Metropolis–Hastings_algorithm:16">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">g</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x\rightarrow x^{\prime})=g(x\rightarrow x^{\prime})A(x\rightarrow x^{\prime})
  </annotation>
 </semantics>
</math>

 .</p>

<p>Inserting this relation the previous equation, we have</p>

<p>

<math display="inline" id="Metropolis–Hastings_algorithm:17">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>→</mo>
      <msup>
       <mi>x</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>′</mo>
      </msup>
      <mo>→</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mfrac>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mo>′</mo>
       </msup>
       <mo>→</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>→</mo>
       <msup>
        <mi>x</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">A</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-→</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">A</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-→</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">g</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>normal-→</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">g</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{A(x\rightarrow x^{\prime})}{A(x^{\prime}\rightarrow x)}=\frac{P(x^{%
\prime})}{P(x)}\frac{g(x^{\prime}\rightarrow x)}{g(x\rightarrow x^{\prime})}
  </annotation>
 </semantics>
</math>

 .</p>

<p>The next step in the derivation is to choose an acceptance that fulfils the condition above. One common choice is the Metropolis choice:</p>

<p>

<math display="inline" id="Metropolis–Hastings_algorithm:18">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>min</mi>
   <mrow>
    <mo>(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mfrac>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mfrac>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mo>′</mo>
       </msup>
       <mo>→</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>→</mo>
       <msup>
        <mi>x</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <min></min>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">g</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>normal-→</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">g</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-→</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(x\rightarrow x^{\prime})=\min\left(1,\frac{P(x^{\prime})}{P(x)}\frac{g(x^{%
\prime}\rightarrow x)}{g(x\rightarrow x^{\prime})}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>i.e., we always accept when the acceptance is bigger than 1, and we reject accordingly when the acceptance is smaller than 1. This is the required quantity for the algorithm.</p>

<p>The Metropolis–Hastings algorithm thus consists in the following:</p>
<ol>
<li>Initialisation: pick an initial state x at random;</li>
<li>randomly pick a state x' according to 

<math display="inline" id="Metropolis–Hastings_algorithm:19">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle g(x\rightarrow x^{\prime})
  </annotation>
 </semantics>
</math>

;</li>
<li>accept the state according to 

<math display="inline" id="Metropolis–Hastings_algorithm:20">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A(x\rightarrow x^{\prime})
  </annotation>
 </semantics>
</math>

. If not accepted, transition doesn't take place, and so there is no need to update anything. Else, the system transits to x';</li>
<li>go to 2 until T states were generated;</li>
<li>save the state x, go to 2.</li>
</ol>

<p>The saved states are in principle drawn from the distribution 

<math display="inline" id="Metropolis–Hastings_algorithm:21">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)
  </annotation>
 </semantics>
</math>

, as step 4 ensures they are de-correlated. The value of T must be chosen according to different factors such as the proposal distribution and, formally, it has to be of the order of the <a class="uri" href="autocorrelation" title="wikilink">autocorrelation</a> time of the Markov process.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>It is important to notice that it is not clear, in a general problem, which distribution 

<math display="inline" id="Metropolis–Hastings_algorithm:22">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle g(x\rightarrow x^{\prime})
  </annotation>
 </semantics>
</math>

 one should use; it is a free parameter of the method which has to be adjusted to the particular problem in hand.</p>
<h2 id="step-by-step-instructions">Step-by-step instructions</h2>

<p>Suppose the most recent value sampled is 

<math display="inline" id="Metropolis–Hastings_algorithm:23">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>x</mi>
    <mi>t</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}\,
  </annotation>
 </semantics>
</math>

. To follow the Metropolis–Hastings algorithm, we next draw a new proposal state 

<math display="inline" id="Metropolis–Hastings_algorithm:24">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}\,
  </annotation>
 </semantics>
</math>

 with probability density 

<math display="inline" id="Metropolis–Hastings_algorithm:25">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo>∣</mo>
    <msub>
     <mi>x</mi>
     <mi>t</mi>
    </msub>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x^{\prime}\mid x_{t})\,
  </annotation>
 </semantics>
</math>

, and calculate a value</p>

<p>

<math display="block" id="Metropolis–Hastings_algorithm:26">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mpadded width="+1.7pt">
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=a_{1}a_{2}\,
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Metropolis–Hastings_algorithm:27">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}=\frac{P(x^{\prime})}{P(x_{t})}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>is the probability (e.g., Bayesian posterior) ratio between the proposed sample 

<math display="inline" id="Metropolis–Hastings_algorithm:28">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}\,
  </annotation>
 </semantics>
</math>

 and the previous sample 

<math display="inline" id="Metropolis–Hastings_algorithm:29">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>x</mi>
    <mi>t</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}\,
  </annotation>
 </semantics>
</math>

, and</p>

<p>

<math display="block" id="Metropolis–Hastings_algorithm:30">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
      <mo>∣</mo>
      <msup>
       <mi>x</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>′</mo>
      </msup>
      <mo>∣</mo>
      <msub>
       <mi>x</mi>
       <mi>t</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-∣</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{2}=\frac{Q(x_{t}\mid x^{\prime})}{Q(x^{\prime}\mid x_{t})}
  </annotation>
 </semantics>
</math>

</p>

<p>is the ratio of the proposal density in two directions (from 

<math display="inline" id="Metropolis–Hastings_algorithm:31">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>x</mi>
    <mi>t</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{t}\,
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Metropolis–Hastings_algorithm:32">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}\,
  </annotation>
 </semantics>
</math>

 and <em>vice versa</em>). This is equal to 1 if the proposal density is symmetric. Then the new state 

<math display="inline" id="Metropolis–Hastings_algorithm:33">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>t</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x_{t+1}
  </annotation>
 </semantics>
</math>

 is chosen according to the following rules.</p>

<p>

<math display="block" id="Metropolis–Hastings_algorithm:34">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <mrow>
        <mtext>If</mtext>
        <mi>a</mi>
       </mrow>
       <mo>≥</mo>
       <mn>1</mn>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <msub>
        <mi>x</mi>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>=</mo>
       <msup>
        <mi>x</mi>
        <mo>′</mo>
       </msup>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <geq></geq>
       <apply>
        <times></times>
        <mtext>If</mtext>
        <ci>a</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <csymbol cd="latexml">absent</csymbol>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}\mbox{If }a\geq 1:&\\
&x_{t+1}=x^{\prime},\end{matrix}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Metropolis–Hastings_algorithm:35">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <mtext>else</mtext>
    </mtd>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>=</mo>
      <mrow>
       <mo>{</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="left">
          <msup>
           <mi>x</mi>
           <mo>′</mo>
          </msup>
         </mtd>
         <mtd columnalign="right">
          <mrow>
           <mtext>with probability</mtext>
           <mi>a</mi>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="left">
          <msub>
           <mi>x</mi>
           <mi>t</mi>
          </msub>
         </mtd>
         <mtd columnalign="right">
          <mrow>
           <mrow>
            <mrow>
             <mtext>with probability</mtext>
             <mn>1</mn>
            </mrow>
            <mo>-</mo>
            <mi>a</mi>
           </mrow>
           <mo>.</mo>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
       <mi></mi>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <mtext>else</mtext>
     <csymbol cd="latexml">absent</csymbol>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <matrix>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>normal-′</ci>
         </apply>
         <apply>
          <times></times>
          <mtext>with probability</mtext>
          <ci>a</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <mtext>with probability</mtext>
           <cn type="integer">1</cn>
          </apply>
          <ci>a</ci>
         </apply>
        </matrixrow>
       </matrix>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}\mbox{else}&\\
&x_{t+1}=\left\{\begin{array}[]{lr}x^{\prime}&\mbox{ with probability }a\\
x_{t}&\mbox{ with probability }1-a.\end{array}\right.\end{matrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The Markov chain is started from an arbitrary initial value 

<math display="inline" id="Metropolis–Hastings_algorithm:36">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x_{0}
  </annotation>
 </semantics>
</math>

 and the algorithm is run for many iterations until this initial state is "forgotten". These samples, which are discarded, are known as <em>burn-in</em>. The remaining set of accepted values of 

<math display="inline" id="Metropolis–Hastings_algorithm:37">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 represent a <a href="Sample_(statistics)" title="wikilink">sample</a> from the distribution 

<math display="inline" id="Metropolis–Hastings_algorithm:38">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>The algorithm works best if the proposal density matches the shape of the target distribution 

<math display="inline" id="Metropolis–Hastings_algorithm:39">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(x)
  </annotation>
 </semantics>
</math>

 from which direct sampling is difficult, that is 

<math display="inline" id="Metropolis–Hastings_algorithm:40">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo>∣</mo>
    <msub>
     <mi>x</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≈</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <approx></approx>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x^{\prime}\mid x_{t})\approx P(x^{\prime})\,\!
  </annotation>
 </semantics>
</math>

. If a Gaussian proposal density 

<math display="inline" id="Metropolis–Hastings_algorithm:41">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle Q
  </annotation>
 </semantics>
</math>

 is used the variance parameter 

<math display="inline" id="Metropolis–Hastings_algorithm:42">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\sigma^{2}
  </annotation>
 </semantics>
</math>

 has to be tuned during the burn-in period. This is usually done by calculating the <em>acceptance rate</em>, which is the fraction of proposed samples that is accepted in a window of the last 

<math display="inline" id="Metropolis–Hastings_algorithm:43">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle N
  </annotation>
 </semantics>
</math>

 samples. The desired acceptance rate depends on the target distribution, however it has been shown theoretically that the ideal acceptance rate for a one-dimensional Gaussian distribution is approx 50%, decreasing to approx 23% for an 

<math display="inline" id="Metropolis–Hastings_algorithm:44">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle N
  </annotation>
 </semantics>
</math>

-dimensional Gaussian target distribution.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>If 

<math display="inline" id="Metropolis–Hastings_algorithm:45">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\sigma^{2}
  </annotation>
 </semantics>
</math>

 is too small the chain will <em>mix slowly</em> (i.e., the acceptance rate will be high but successive samples will move around the space slowly and the chain will converge only slowly to 

<math display="inline" id="Metropolis–Hastings_algorithm:46">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(x)
  </annotation>
 </semantics>
</math>

). On the other hand, if 

<math display="inline" id="Metropolis–Hastings_algorithm:47">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\sigma^{2}
  </annotation>
 </semantics>
</math>

 is too large the acceptance rate will be very low because the proposals are likely to land in regions of much lower probability density, so 

<math display="inline" id="Metropolis–Hastings_algorithm:48">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle a_{1}
  </annotation>
 </semantics>
</math>

 will be very small and again the chain will converge very slowly.</p>
<figure><b>(Figure)</b>
<figcaption>The result of three <a href="Markov_chain" title="wikilink">Markov chains</a> running on the 3D <a href="Rosenbrock_function" title="wikilink">Rosenbrock function</a> using the Metropolis-Hastings algorithm. The algorithm samples from regions where the <a href="posterior_probability" title="wikilink">posterior probability</a> is high and the chains begin to mix in these regions. The approximate position of the maximum has been illuminated. Note that the red points are the ones that remain after the burn-in process. The earlier ones have been discarded.</figcaption>
</figure>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Simulated_annealing" title="wikilink">Simulated annealing</a></li>
<li><a href="Detailed_balance" title="wikilink">Detailed balance</a></li>
<li><a href="Multiple-try_Metropolis" title="wikilink">Multiple-try Metropolis</a></li>
<li><a href="Metropolis_light_transport" title="wikilink">Metropolis light transport</a></li>
<li><a href="Gibbs_sampling" title="wikilink">Gibbs sampling</a></li>
<li><a href="Parallel_tempering" title="wikilink">Parallel tempering</a></li>
<li><a href="Particle_filter" title="wikilink">Sequential Monte Carlo</a></li>
<li><a href="Genetic_algorithm" title="wikilink">Genetic algorithms</a></li>
<li><a href="Mean_field_particle_methods" title="wikilink">Mean field particle methods</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="Bernd_A._Berg" title="wikilink">Bernd A. Berg</a>. <em>Markov Chain Monte Carlo Simulations and Their Statistical Analysis</em>. Singapore, <a href="World_Scientific" title="wikilink">World Scientific</a>, 2004.</li>
<li>Siddhartha Chib and Edward Greenberg: "Understanding the Metropolis–Hastings Algorithm". <em><a href="American_Statistician" title="wikilink">American Statistician</a></em>, 49(4), 327–335, 1995</li>
<li><a href="http://www.tandfonline.com/doi/abs/10.1080/03610918.2013.777455#.VOk8J1PF9_c">David D. L. Minh and Do Le Minh. "Understanding the Hastings Algorithm." Communications in Statistics - Simulation and Computation, 44:2 332-349, 2015</a></li>
<li>Bolstad, William M. (2010) <em>Understanding Computational Bayesian Statistics</em>, <a href="John_Wiley_&amp;_Sons" title="wikilink">John Wiley &amp; Sons</a> ISBN 0-470-04609-0</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://xbeta.org/wiki/show/Metropolis-Hastings+algorithm">Metropolis-Hastings algorithm on xβ</a></li>
<li><a href="http://www.quantiphile.com/2010/11/01/metropolis-hastings/">Matlab implementation of Random-Walk Metropolis</a></li>
<li><a href="http://blog.abhranil.net/2014/02/08/r-code-for-multivariate-random-walk-metropolis-hastings-sampling/">R implementation of Random-Walk Metropolis</a></li>
</ul>

<p>"</p>

<p><a href="Category:Monte_Carlo_methods" title="wikilink">Category:Monte Carlo methods</a> <a href="Category:Markov_chain_Monte_Carlo" title="wikilink">Category:Markov chain Monte Carlo</a> <a href="Category:Statistical_algorithms" title="wikilink">Category:Statistical algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
</ol>
</section>
</body>
</html>
