<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="532">Christofides algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Christofides algorithm</h1>
<hr/>

<p>The goal of the <strong>Christofides <a href="approximation_algorithm" title="wikilink">approximation algorithm</a></strong> (named after Nicos Christofides) is to find a solution to the instances of the <a href="traveling_salesman_problem" title="wikilink">traveling salesman problem</a> where the edge weights satisfy the <a href="triangle_inequality" title="wikilink">triangle inequality</a>. Let 

<math display="inline" id="Christofides_algorithm:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>w</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,w)
  </annotation>
 </semantics>
</math>

 be an instance of TSP, i.e. 

<math display="inline" id="Christofides_algorithm:1">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is a complete graph on the set 

<math display="inline" id="Christofides_algorithm:2">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 of vertices with weight function 

<math display="inline" id="Christofides_algorithm:3">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 assigning a nonnegative real weight to every edge of 

<math display="inline" id="Christofides_algorithm:4">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="algorithm">Algorithm</h2>

<p>In <a class="uri" href="pseudo-code" title="wikilink">pseudo-code</a>:</p>
<ol>
<li>Create a <a href="minimum_spanning_tree" title="wikilink">minimum spanning tree</a> 

<math display="inline" id="Christofides_algorithm:5">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Christofides_algorithm:6">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</li>
<li>Let 

<math display="inline" id="Christofides_algorithm:7">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

 be the set of vertices with odd <a href="degree_(graph_theory)" title="wikilink">degree</a> in 

<math display="inline" id="Christofides_algorithm:8">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and find a <a href="perfect_matching" title="wikilink">perfect matching</a> 

<math display="inline" id="Christofides_algorithm:9">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 with minimum weight in the <a href="complete_graph" title="wikilink">complete graph</a> over the vertices from 

<math display="inline" id="Christofides_algorithm:10">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

.</li>
<li>Combine the edges of 

<math display="inline" id="Christofides_algorithm:11">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Christofides_algorithm:12">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 to form a <a class="uri" href="multigraph" title="wikilink">multigraph</a> 

<math display="inline" id="Christofides_algorithm:13">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

.</li>
<li>Form an <a href="Eulerian_circuit" title="wikilink">Eulerian circuit</a> in 

<math display="inline" id="Christofides_algorithm:14">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 (H is Eulerian because it is <a href="Eulerian_path#Properties" title="wikilink">connected, with only even-degree vertices</a>).</li>
<li>Make the circuit found in previous step <a href="Hamiltonian_circuit" title="wikilink">Hamiltonian</a> by skipping visited nodes (<em>shortcutting</em>).</li>
</ol>
<h2 id="approximation-ratio">Approximation ratio</h2>

<p>The cost of the solution produced by the algorithm is within 3/2 of the optimum.</p>

<p>The proof is as follows:</p>

<p>Let <mtpl></mtpl> denote the edge set of the optimal solution of TSP for <mtpl></mtpl>. Because <mtpl></mtpl> is connected, it contains some spanning tree <mtpl></mtpl> and thus <mtpl></mtpl>. Further let 

<math display="inline" id="Christofides_algorithm:15">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 denote the edge set of the optimal solution of TSP for the complete graph over vertices from 

<math display="inline" id="Christofides_algorithm:16">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

. Because the edge weights are triangular (so visiting more nodes cannot reduce total cost), we know that <mtpl></mtpl>. We show that there is a perfect matching of vertices from 

<math display="inline" id="Christofides_algorithm:17">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

 with weight under <mtpl></mtpl> and therefore we have the same upper bound for 

<math display="inline" id="Christofides_algorithm:18">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 (because 

<math display="inline" id="Christofides_algorithm:19">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is a perfect matching of minimum cost). Because 

<math display="inline" id="Christofides_algorithm:20">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>

 must contain an even number of vertices, a perfect matching exists. Let <mtpl></mtpl> be the (only) Eulerian path in 

<math display="inline" id="Christofides_algorithm:21">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>O</mi>
   <mo>,</mo>
   <mi>B</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>O</ci>
    <ci>B</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (O,B)
  </annotation>
 </semantics>
</math>

. Clearly both <mtpl></mtpl> and <mtpl></mtpl> are perfect matchings and the weight of at least one of them is less than or equal to <mtpl></mtpl>. Thus <mtpl></mtpl> and from the triangle inequality it follows that the algorithm is 3/2-approximative.</p>
<h2 id="example">Example</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Metrischer Graph mit 5 Knoten.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>Given: metric graph 

<math display="inline" id="Christofides_algorithm:22">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\left(V,E\right)
  </annotation>
 </semantics>
</math>

 with edge weights</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Christofides MST.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>Calculate <a href="minimum_spanning_tree" title="wikilink">minimum spanning tree</a> 

<math display="inline" id="Christofides_algorithm:23">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>V'.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>Calculate the set of vertices 

<math display="inline" id="Christofides_algorithm:24">
 <semantics>
  <msup>
   <mi>V</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>V</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\prime}
  </annotation>
 </semantics>
</math>

 with odd degree in 

<math display="inline" id="Christofides_algorithm:25">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>G V'.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>Reduce 

<math display="inline" id="Christofides_algorithm:26">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 to the vertices of 

<math display="inline" id="Christofides_algorithm:27">
 <semantics>
  <msup>
   <mi>V</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>V</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\prime}
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Christofides_algorithm:28">
 <semantics>
  <msub>
   <mrow>
    <mi>G</mi>
    <mo fence="true">|</mo>
   </mrow>
   <msup>
    <mi>V</mi>
    <mo>′</mo>
   </msup>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">evaluated-at</csymbol>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G|_{V^{\prime}}
  </annotation>
 </semantics>
</math>

).</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Christofides Matching.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>Calculate matching 

<math display="inline" id="Christofides_algorithm:29">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 with minimum weight in 

<math display="inline" id="Christofides_algorithm:30">
 <semantics>
  <msub>
   <mrow>
    <mi>G</mi>
    <mo fence="true">|</mo>
   </mrow>
   <msup>
    <mi>V</mi>
    <mo>′</mo>
   </msup>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">evaluated-at</csymbol>
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G|_{V^{\prime}}
  </annotation>
 </semantics>
</math>

.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>TuM.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>Unite matching and spanning tree (

<math display="inline" id="Christofides_algorithm:31">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>∪</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>T</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\cup M
  </annotation>
 </semantics>
</math>

).</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Eulertour.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>Calculate Euler tour on 

<math display="inline" id="Christofides_algorithm:32">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>∪</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>T</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\cup M
  </annotation>
 </semantics>
</math>

 (A-B-C-A-D-E-A).</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Eulertour bereinigt.svg</figcaption>
</figure></td>
<td style="text-align: left;">
<p>Remove reoccuring vertices and replace by direct connections (A-B-C-D-E-A). In metric graphs, this step can not lengthen the tour. This tour is the algorithm's output.</p></td>
</tr>
</tbody>
</table>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.nist.gov/dads/HTML/christofides.html">NIST Christofides Algorithm Definition</a></li>
<li>Nicos Christofides, Worst-case analysis of a new heuristic for the travelling salesman problem, Report 388, Graduate School of Industrial Administration, CMU, 1976.</li>
</ul>

<p>"</p>

<p><a href="Category:Travelling_salesman_problem" title="wikilink">Category:Travelling salesman problem</a> <a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a> <a href="Category:Spanning_tree" title="wikilink">Category:Spanning tree</a> <a href="Category:Approximation_algorithms" title="wikilink">Category:Approximation algorithms</a></p>
</body>
</html>
