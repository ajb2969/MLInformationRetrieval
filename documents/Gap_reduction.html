<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1476">Gap reduction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Gap reduction</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, a <strong>gap reduction</strong> is a <a href="reduction_(complexity)" title="wikilink">reduction</a> to a particular type of decision problem, known as a <em>c-gap problem</em>. Such reductions provide information about the hardness of <a href="approximation_algorithm" title="wikilink">approximating</a> solutions to <a href="optimization_problem" title="wikilink">optimization problems</a>. In short, a gap problem refers to one wherein the objective is to distinguish between cases where the best solution is above one threshold from cases where the best solution is below another threshold, such that the two thresholds have a gap in between. Gap reductions can be used to demonstrate inapproximability results, as if a problem may be approximated to a better factor than the size of gap, then the approximation algorithm can be used to solve the corresponding gap problem.</p>
<h2 id="c-gap-problem">c-gap problem</h2>

<p>We define a <strong>c-gap problem</strong> as follows:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> given an optimization (maximization or minimization) problem P, the equivalent c-gap problem distinguishes between two cases, for an input k and an instance x of problem P:</p>

<p>

<math display="block" id="Gap_reduction:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mi>P</mi>
    <msub>
     <mi>T</mi>
     <mi>P</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>P</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   OPT_{P}(x)\leq k
  </annotation>
 </semantics>
</math>

. Here, the best solution to instance x of problem P has a cost, or score, below k.</p>

<p>

<math display="block" id="Gap_reduction:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mi>P</mi>
    <msub>
     <mi>T</mi>
     <mi>P</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>c</mi>
    <mo>⋅</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>P</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>c</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   OPT_{P}(x)>c\cdot k
  </annotation>
 </semantics>
</math>

. Here, the best solution to instance x of problem P has a cost above c⋅k. The gap between the two thresholds is thus c.</p>

<p>Note that whenever OPT falls between the thresholds, there is no requirement on what the output should be. A valid algorithm for the c-gap problem may answer anything if OPT is in the middle of the gap. The value c does not need to be constant; it can depend on the size of the instance of P. Note that <a href="Approximation_algorithm" title="wikilink">c-approximating</a> the solution to an instance of P is at least as hard as solving the c-gap version of P.</p>

<p>One can define an <strong>(a,b)-gap problem</strong> similarly. The difference is that the thresholds do not depend on the input; instead, the lower threshold is a and the upper threshold is b.</p>
<h2 id="gap-producing-reduction">Gap-producing reduction</h2>

<p>A gap-producing reduction is a <a href="reduction_(complexity)" title="wikilink">reduction</a> from an optimization problem to a c-gap problem, so that solving the c-gap problem quickly would enable solving the optimization problem quickly. The term gap-producing arises from the nature of the reduction: the optimal solution in the optimization problem maps to the opposite side of the gap from every other solution via reduction. Thus, a gap is produced between the optimal solution and every other solution.</p>

<p>A simple example of a gap-producing reduction is the nonmetric <a href="Traveling_Salesman_problem" title="wikilink">Traveling Salesman problem</a> (i.e. where the graph's edge costs need not satisfy the conditions of a <a href="metric_(mathematics)" title="wikilink">metric</a>). We can reduce from the <a href="Hamiltonian_path" title="wikilink">Hamiltonian path</a> problem on a given graph G = (V, E) to this problem as follows: we construct a complete graph G' = (V, E'), for the traveling salesman problem. For each edge e ∈ G', we let the cost of traversing it be 1 if e is in the original graph G and ∞ otherwise. A Hamiltonian path in the original graph G exists if and only if there exists a traveling salesman solution with weight (|V|-1). However, if no such Hamiltonian path exists, then the best traveling salesman tour must have weight at least |V|. Thus, Hamiltonian Path reduces to |V|/(|V|-1)-gap nonmetric traveling salesman.</p>
<h2 id="gap-preserving-reduction">Gap-preserving reduction</h2>

<p>A gap-preserving reduction is a <a href="reduction_(complexity)" title="wikilink">reduction</a> from a c-gap problem to a c'-gap problem. More specifically, we are given an instance x of a problem A with |x| = n and want to reduce it to an instance x' of a problem B with |x'| = n'. A gap-preserving reduction from A to B is a set of functions (k(n), k'(n'), c(n), c'(n')) such that</p>

<p>For minimization problems:</p>
<dl>
<dd>OPT<sub>A</sub>(x) ≤ k ⇒ OPT<sub>B</sub>(x') ≤ k', and
</dd>
<dd>OPT<sub>A</sub>(x) ≥ c⋅k ⇒ OPT<sub>B</sub>(x') ≥ c'⋅k'
</dd>
</dl>

<p>For maximization problems:</p>
<dl>
<dd>OPT<sub>A</sub>(x) ≥ k ⇒ OPT<sub>B</sub>(x') ≥ k', and
</dd>
<dd>OPT<sub>A</sub>(x) ≤ k/c ⇒ OPT<sub>B</sub>(x') ≤ k'/c'
</dd>
</dl>

<p>If c' &gt; c, then this is a <em>gap-amplifying reduction</em>.</p>
<h2 id="examples">Examples</h2>
<h3 id="max-e3sat">Max E3SAT</h3>

<p>This problem is a form of the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a> (SAT), where each clause contains three distinct literals and we want to maximize the number of clauses satisfied.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Håstad showed that the (1/2+ε, 1-ε)-gap version of a similar problem, MAX E3-X(N)OR-SAT, is NP-hard.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The MAX E3-X(N)OR-SAT problem is a form of SAT where each clause is the XOR of three distinct literals, exactly one of which is negated. We can reduce from MAX E3-X(N)OR-SAT to MAX E3SAT as follows:</p>
<dl>
<dd>A clause x<sub>i</sub> ⊕ x<sub>j</sub> ⊕ x<sub>k</sub> = 0 is converted to (x<sub>i</sub> ∨ x<sub>j</sub> ∨ x<sub>k</sub>) ∧ (¬x<sub>i</sub> ∨ ¬x<sub>j</sub> ∨ x<sub>k</sub>) ∧ (¬x<sub>i</sub> ∨ x<sub>j</sub> ∨ ¬x<sub>k</sub>) ∧ (x<sub>i</sub> ∨ ¬x<sub>j</sub> ∨ ¬x<sub>k</sub>)
</dd>
<dd>A clause x<sub>i</sub> ⊕ x<sub>j</sub> ⊕ x<sub>k</sub> = 0 is converted to (¬x<sub>i</sub> ∨ ¬x<sub>j</sub> ∨ ¬x<sub>k</sub>) ∧ (¬x<sub>i</sub> ∨ x<sub>j</sub> ∨ x<sub>k</sub>) ∧ (x<sub>i</sub> ∨ ¬x<sub>j</sub> ∨ x<sub>k</sub>) ∧ (x<sub>i</sub> ∨ x<sub>j</sub> ∨ ¬x<sub>k</sub>)
</dd>
</dl>

<p>If a clause is not satisfied in the original instance of MAX E3-X(N)OR-SAT, then at most three of the four corresponding clauses in our MAX E3SAT instance can be satisfied. Using a gap argument, it follows that a YES instance of the problem has at least a (1-ε) fraction of the clauses satisfied, while a NO instance of the problem has at most a (1/2+ε)(1) + (1/2-ε)(3/4) = (7/8 + ε/4)-fraction of the clauses satisfied. Thus, it follows that (7/8 + ε, 1 - ε)-gap MAX E3SAT is NP-hard. Note that this bound is tight, as a random assignment of variables gives an expected 7/8 fraction of satisfied clauses.</p>
<h3 id="label-cover">Label Cover</h3>

<p>The <strong>label cover</strong> problem is defined as follows: given a bipartite graph G = (A∪B, E), with</p>
<dl>
<dd>A = A<sub>1</sub> ∪ A<sub>2</sub> ∪ ... ∪ A<sub>k</sub>, |A| = n, and |A<sub>i</sub>| = n/k
</dd>
<dd>B = B<sub>1</sub> ∪ B<sub>2</sub> ∪ ... ∪ B<sub>k</sub>, |B| = n, and |B<sub>i</sub>| = n/k
</dd>
</dl>

<p>We define a "superedge" between A<sub>i</sub> and B<sub>j</sub> if at least one edge exists from A<sub>i</sub> to B<sub>j</sub> in G, and define the superedge to be covered if at least one edge from A<sub>i</sub> to B<sub>j</sub> is covered.</p>

<p>In the <em>max-rep</em> version of the problem, we are allowed to choose one vertex from each A<sub>i</sub> and each B<sub>i</sub>, and we aim to maximize the number of covered superedges. In the <em>min-rep</em> version, we are required to cover every superedge in the graph, and want to minimize the number of vertices we choose. Manurangsi and Moshkovitz show that the (O(n<sup>1/4</sup>), 1)-gap version of both problems is solvable in polynomial time.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Approximation-preserving_reduction" title="wikilink">Approximation-preserving reduction</a></li>
<li><a href="Optimization_problem" title="wikilink">Optimization problem</a></li>
<li><a href="Approximation_algorithm" title="wikilink">Approximation algorithm</a></li>
<li><a href="PTAS_reduction" title="wikilink">PTAS reduction</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Approximation_algorithms" title="wikilink">Category:Approximation algorithms</a> <a href="Category:Computational_problems" title="wikilink">Category:Computational problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
