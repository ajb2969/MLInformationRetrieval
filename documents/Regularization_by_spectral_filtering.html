<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="710">Regularization by spectral filtering</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Regularization by spectral filtering</h1>
<hr/>

<p><strong>Spectral regularization</strong> is any of a class of <a href="Regularization_(mathematics)" title="wikilink">regularization</a> techniques used in <a href="machine_learning" title="wikilink">machine learning</a> to control the impact of noise and prevent <a class="uri" href="overfitting" title="wikilink">overfitting</a>. Spectral regularization can be used in a broad range of applications, from deblurring images to classifying emails into a spam folder and a non-spam folder. For instance, in the email classification example, spectral regularization can be used to reduce the impact of noise and prevent overfitting when a machine learning system is being trained on a labeled set of emails to learn how to tell a spam and a non-spam email apart.</p>

<p>Spectral regularization algorithms rely on methods that were originally defined and studied in the theory of <a href="Ill-posed_problem" title="wikilink">ill-posed</a> <a href="inverse_problem" title="wikilink">inverse problems</a> (for instance, see<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>) focusing on the inversion of a linear operator (or a matrix) that possibly has a bad <a href="condition_number" title="wikilink">condition number</a> or an unbounded inverse. In this context, regularization amounts to substituting the original operator by a bounded operator called the "regularization operator" that has a condition number controlled by a regularization parameter,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> a classical example being <a href="Tikhonov_regularization" title="wikilink">Tikhonov regularization</a>. To ensure stability, this regularization parameter is tuned based on the level of noise.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The main idea behind spectral regularization is that each regularization operator can be described using spectral calculus as an appropriate filter on the eigenvalues of the operator that defines the problem, and the role of the filter is to "suppress the oscillatory behavior corresponding to small eigenvalues".<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Therefore, each algorithm in the class of spectral regularization algorithms is defined by a suitable filter function (which needs to be derived for that particular algorithm). Three of the most commonly used regularization algorithms for which spectral filtering is well-studied are Tikhonov regularization, <a href="Landweber_iteration" title="wikilink">Landweber iteration</a>, and <a href="Singular_value_decomposition#Reduced_SVDs" title="wikilink">truncated singular value decomposition</a> (TSVD). As for choosing the regularization parameter, examples of candidate methods to compute this parameter include the discrepancy principle, generalized <a href="Cross-validation_(statistics)" title="wikilink">cross validation</a>, and the L-curve criterion.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>It is of note that the notion of spectral filtering studied in the context of machine learning is closely connected to the literature on <a href="function_approximation" title="wikilink">function approximation</a> (in signal processing).</p>
<h2 id="notation">Notation</h2>

<p>The training set is defined as 

<math display="inline" id="Regularization_by_spectral_filtering:0">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <set>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
     <ci>normal-…</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </interval>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{(x_{1},y_{1}),\dots,(x_{n},y_{n})\}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Regularization_by_spectral_filtering:1">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Regularization_by_spectral_filtering:2">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times d
  </annotation>
 </semantics>
</math>

 input matrix and 

<math display="inline" id="Regularization_by_spectral_filtering:3">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=(y_{1},\dots,y_{n})
  </annotation>
 </semantics>
</math>

 is the output vector. Where applicable, the kernel function is denoted by 

<math display="inline" id="Regularization_by_spectral_filtering:4">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, and the 

<math display="inline" id="Regularization_by_spectral_filtering:5">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 kernel matrix is denoted by 

<math display="inline" id="Regularization_by_spectral_filtering:6">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 which has entries 

<math display="inline" id="Regularization_by_spectral_filtering:7">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{ij}=k(x_{i},x_{j})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Regularization_by_spectral_filtering:8">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 denotes the <a href="RKHS" title="wikilink">Reproducing Kernel Hilbert Space</a> (RKHS) with kernel 

<math display="inline" id="Regularization_by_spectral_filtering:9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. The regularization parameter is denoted by 

<math display="inline" id="Regularization_by_spectral_filtering:10">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

.</p>

<p>''(Note: For 

<math display="inline" id="Regularization_by_spectral_filtering:11">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in G
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Regularization_by_spectral_filtering:12">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>f</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in F
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Regularization_by_spectral_filtering:13">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Regularization_by_spectral_filtering:14">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 being Hilbert spaces, given a linear, continuous operator 

<math display="inline" id="Regularization_by_spectral_filtering:15">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

, assume that 

<math display="inline" id="Regularization_by_spectral_filtering:16">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>g</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g=Lf
  </annotation>
 </semantics>
</math>

 holds. In this setting, the direct problem would be to solve for 

<math display="inline" id="Regularization_by_spectral_filtering:17">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 given 

<math display="inline" id="Regularization_by_spectral_filtering:18">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and the inverse problem would be to solve for 

<math display="inline" id="Regularization_by_spectral_filtering:19">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 given 

<math display="inline" id="Regularization_by_spectral_filtering:20">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

. If the solution exists, is unique and stable, the inverse problem (i.e. the problem of solving for 

<math display="inline" id="Regularization_by_spectral_filtering:21">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

) is well-posed; otherwise, it is ill-posed.) ''</p>
<h2 id="relation-to-the-theory-of-ill-posed-inverse-problems">Relation to the theory of ill-posed inverse problems</h2>

<p>The connection between the regularized least squares (RLS) estimation problem (Tikhonov regularization setting) and the theory of ill-posed inverse problems is an example of how spectral regularization algorithms are related to the theory of ill-posed inverse problems.</p>

<p>The RLS estimator solves</p>

<p>

<math display="block" id="Regularization_by_spectral_filtering:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mi>min</mi>
      <mrow>
       <mi>f</mi>
       <mo>∈</mo>
       <mi class="ltx_font_mathcaligraphic">ℋ</mi>
      </mrow>
     </munder>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
    </mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <mo>-</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>λ</mi>
    <msubsup>
     <mrow>
      <mo>∥</mo>
      <mi>f</mi>
      <mo>∥</mo>
     </mrow>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <min></min>
       <apply>
        <in></in>
        <ci>f</ci>
        <ci>ℋ</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>f</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>ℋ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{f\in\mathcal{H}}\frac{1}{n}\sum_{i=1}^{n}(y_{i}-f(x_{i}))^{2}+\lambda\|f%
\|^{2}_{\mathcal{H}}
  </annotation>
 </semantics>
</math>

</p>

<p>and the RKHS allows for expressing this RLS estimator as 

<math display="inline" id="Regularization_by_spectral_filtering:23">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>f</mi>
     <mi>S</mi>
     <mi>λ</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
      <ci>λ</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{S}^{\lambda}(X)=\sum_{i=1}^{n}c_{i}k(x,x_{i})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Regularization_by_spectral_filtering:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>K</mi>
      <mo>+</mo>
      <mrow>
       <mi>n</mi>
       <mi>λ</mi>
       <mi>I</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </mrow>
   <mo>=</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>K</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>λ</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (K+n\lambda I)c=Y
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Regularization_by_spectral_filtering:25">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=(c_{1},\dots,c_{n})
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The penalization term is used for controlling smoothness and preventing overfitting. Since the solution of empirical risk minimization 

<math display="inline" id="Regularization_by_spectral_filtering:26">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>min</mi>
     <mrow>
      <mi>f</mi>
      <mo>∈</mo>
      <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     </mrow>
    </msub>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
   </mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>f</ci>
       <ci>ℋ</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{f\in\mathcal{H}}\frac{1}{n}\sum_{i=1}^{n}(y_{i}-f(x_{i}))^{2}
  </annotation>
 </semantics>
</math>

 can be written as 

<math display="inline" id="Regularization_by_spectral_filtering:27">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>f</mi>
     <mi>S</mi>
     <mi>λ</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
      <ci>λ</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{S}^{\lambda}(X)=\sum_{i=1}^{n}c_{i}k(x,x_{i})
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Regularization_by_spectral_filtering:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mi>c</mi>
   </mrow>
   <mo>=</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>c</ci>
    </apply>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Kc=Y
  </annotation>
 </semantics>
</math>

, adding the penalty function amounts to the following change in the system that needs to be solved:<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>

<math display="block" id="Regularization_by_spectral_filtering:29">
 <semantics>
  <mrow>
   <mrow>
    <mo maxsize="210%" minsize="210%">{</mo>
    <munder>
     <mi>min</mi>
     <mrow>
      <mi>f</mi>
      <mo>∈</mo>
      <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     </mrow>
    </munder>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>→</mo>
    <munder>
     <mi>min</mi>
     <mrow>
      <mi>f</mi>
      <mo>∈</mo>
      <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     </mrow>
    </munder>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mi>λ</mi>
    <mo>∥</mo>
    <mi>f</mi>
    <msubsup>
     <mo>∥</mo>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mn>2</mn>
    </msubsup>
    <mo maxsize="210%" minsize="210%">}</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo maxsize="210%" minsize="210%">{</mo>
    <mi>K</mi>
    <mi>c</mi>
    <mo>=</mo>
    <mi>Y</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo>+</mo>
     <mi>n</mi>
     <mi>λ</mi>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
    <mo>=</mo>
    <mi>Y</mi>
    <mo maxsize="210%" minsize="210%">}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>f</ci>
       <ci>ℋ</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <minus></minus>
       <csymbol cd="unknown">f</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>f</ci>
       <ci>ℋ</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <minus></minus>
       <csymbol cd="unknown">f</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <cn type="integer">2</cn>
     </apply>
     <plus></plus>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="latexml">parallel-to</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <csymbol cd="latexml">parallel-to</csymbol>
       <cn type="integer">2</cn>
      </apply>
      <ci>ℋ</ci>
     </apply>
     <ci>normal-}</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">K</csymbol>
     <csymbol cd="unknown">c</csymbol>
     <eq></eq>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">K</csymbol>
      <plus></plus>
      <csymbol cd="unknown">n</csymbol>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">I</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">c</csymbol>
     <eq></eq>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigg\{\min_{f\in\mathcal{H}}\frac{1}{n}\sum_{i=1}^{n}(y_{i}-f(x_{i}))^{2}%
\rightarrow\min_{f\in\mathcal{H}}\frac{1}{n}\sum_{i=1}^{n}(y_{i}-f(x_{i}))^{2}%
+\lambda\|f\|^{2}_{\mathcal{H}}\bigg\}\equiv\bigg\{Kc=Y\rightarrow(K+n\lambda I%
)c=Y\bigg\}.
  </annotation>
 </semantics>
</math>

</p>

<p>In this learning setting, the kernel matrix can be decomposed as 

<math display="inline" id="Regularization_by_spectral_filtering:30">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <mi mathvariant="normal">Σ</mi>
    <msup>
     <mi>Q</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>normal-Σ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=Q\Sigma Q^{T}
  </annotation>
 </semantics>
</math>

, with</p>

<p>

<math display="block" id="Regularization_by_spectral_filtering:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mo>=</mo>
    <mrow>
     <mo>diag</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>σ</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>σ</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">,</mo>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mn>1</mn>
    </msub>
    <mo>≥</mo>
    <msub>
     <mi>σ</mi>
     <mn>2</mn>
    </msub>
    <mo>≥</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>≥</mo>
    <msub>
     <mi>σ</mi>
     <mi>n</mi>
    </msub>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>σ</ci>
     <apply>
      <ci>diag</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <geq></geq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <share href="#.cmml">
      </share>
      <ci>normal-⋯</ci>
     </apply>
     <apply>
      <geq></geq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma=\operatorname{diag}(\sigma_{1},\dots,\sigma_{n}),~{}\sigma_{1}\geq%
\sigma_{2}\geq\cdots\geq\sigma_{n}\geq 0
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="inline" id="Regularization_by_spectral_filtering:32">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>q</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{1},\dots,q_{n}
  </annotation>
 </semantics>
</math>

 are the corresponding eigenvectors. Therefore, in the initial learning setting, the following holds:</p>

<p>

<math display="block" id="Regularization_by_spectral_filtering:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>K</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>Y</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <msup>
      <mi mathvariant="normal">Σ</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mi>Q</mi>
      <mi>T</mi>
     </msup>
     <mi>Y</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <msub>
        <mi>σ</mi>
        <mi>i</mi>
       </msub>
      </mfrac>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>q</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mi>Y</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msub>
       <mi>q</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>c</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>K</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Σ</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Q</ci>
       <ci>T</ci>
      </apply>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <ci>i</ci>
        </apply>
        <ci>Y</ci>
       </list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=K^{-1}Y=Q\Sigma^{-1}Q^{T}Y=\sum_{i=1}^{n}\frac{1}{\sigma_{i}}\langle q_{i},Y%
\rangle q_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, for small eigenvalues, even small perturbations in the data can lead to considerable changes in the solution. Hence, the problem is ill-conditioned, and solving this RLS problem amounts to stabilizing a possibly ill-conditioned matrix inversion problem, which is studied in the theory of ill-posed inverse problems; in both problems, a main concern is to deal with the issue of numerical stability.</p>
<h2 id="implementation-of-algorithms-for-spectral-regularization">Implementation of algorithms for spectral regularization</h2>

<p>Each algorithm in the class of spectral regularization algorithms is defined by a suitable filter function, denoted here by 

<math display="inline" id="Regularization_by_spectral_filtering:34">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>λ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>λ</ci>
    </apply>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\lambda}(\cdot)
  </annotation>
 </semantics>
</math>

. If the Kernel matrix is denoted by 

<math display="inline" id="Regularization_by_spectral_filtering:35">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Regularization_by_spectral_filtering:36">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 should control the magnitude of the smaller eigenvalues of 

<math display="inline" id="Regularization_by_spectral_filtering:37">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>λ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>λ</ci>
    </apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\lambda}(K)
  </annotation>
 </semantics>
</math>

. In a filtering setup, the goal is to find estimators 

<math display="inline" id="Regularization_by_spectral_filtering:38">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>f</mi>
     <mi>S</mi>
     <mi>λ</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
      <ci>λ</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{S}^{\lambda}(X):=\sum_{i=1}^{n}c_{i}k(x,x_{i})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Regularization_by_spectral_filtering:39">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>G</mi>
     <mi>λ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>λ</ci>
     </apply>
     <ci>K</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=G_{\lambda}(K)Y
  </annotation>
 </semantics>
</math>

. To do so, a scalar filter function 

<math display="inline" id="Regularization_by_spectral_filtering:40">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>λ</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>λ</ci>
    </apply>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\lambda}(\sigma)
  </annotation>
 </semantics>
</math>

 is defined using the eigen-decomposition of the kernel matrix:</p>

<p>

<math display="block" id="Regularization_by_spectral_filtering:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>G</mi>
      <mi>λ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>K</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Q</mi>
     <msub>
      <mi>G</mi>
      <mi>λ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>Q</mi>
      <mi>T</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>λ</ci>
     </apply>
     <ci>K</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>λ</ci>
     </apply>
     <ci>normal-Σ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\lambda}(K)=QG_{\lambda}(\Sigma)Q^{T},
  </annotation>
 </semantics>
</math>

</p>

<p>which yields</p>

<p>

<math display="block" id="Regularization_by_spectral_filtering:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>G</mi>
      <mi>λ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>K</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mpadded width="+3.3pt">
      <mi>Y</mi>
     </mpadded>
    </mrow>
    <mo rspace="5.8pt">=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>G</mi>
       <mi>λ</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>σ</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>q</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mi>Y</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msub>
       <mi>q</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>λ</ci>
     </apply>
     <ci>K</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <ci>λ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>i</ci>
      </apply>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <ci>i</ci>
       </apply>
       <ci>Y</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\lambda}(K)Y~{}=~{}\sum_{i=1}^{n}G_{\lambda}(\sigma_{i})\langle q_{i},Y%
\rangle q_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>Typically, an appropriate filter function should have the following properties:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>1. As 

<math display="inline" id="Regularization_by_spectral_filtering:43">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 goes to zero, 

<math display="inline" id="Regularization_by_spectral_filtering:44">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>G</mi>
     <mi>λ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo rspace="5.8pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">→</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>σ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>λ</ci>
     </apply>
     <ci>σ</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\lambda}(\sigma)~{}\rightarrow~{}1/\sigma
  </annotation>
 </semantics>
</math>

.</p>

<p>2. The magnitude of the (smaller) eigenvalues of 

<math display="inline" id="Regularization_by_spectral_filtering:45">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>λ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\lambda}
  </annotation>
 </semantics>
</math>

 is controlled by 

<math display="inline" id="Regularization_by_spectral_filtering:46">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

.</p>

<p>While the above items give a rough characterization of the general properties of filter functions for all spectral regularization algorithms, the derivation of the filter function (and hence its exact form) varies depending on the specific regularization method that spectral filtering is applied to.</p>
<h3 id="filter-function-for-tikhonov-regularization">Filter function for Tikhonov regularization</h3>

<p>In the Tikhonov regularization setting, the filter function for RLS is described below. As shown in,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> in this setting, 

<math display="inline" id="Regularization_by_spectral_filtering:47">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>K</mi>
       <mo>+</mo>
       <mrow>
        <mi>n</mi>
        <mi>λ</mi>
        <mi>I</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>K</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>λ</ci>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=(K+n\lambda I)^{-1}Y
  </annotation>
 </semantics>
</math>

. Thus,</p>

<p>

<math display="inline" id="Regularization_by_spectral_filtering:48">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>≫</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-greater-than</csymbol>
    <ci>σ</ci>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\gg\lambda n
  </annotation>
 </semantics>
</math>

</p>

<p>The undesired components are filtered out using regularization:</p>
<ul>
<li>If 

<math display="inline" id="Regularization_by_spectral_filtering:49">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <msub>
      <mi>σ</mi>
      <mi>i</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>n</mi>
      <mi>λ</mi>
     </mrow>
    </mrow>
   </mfrac>
   <mo>∼</mo>
   <mfrac>
    <mn>1</mn>
    <msub>
     <mi>σ</mi>
     <mi>i</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\sigma_{i}+n\lambda}\sim\frac{1}{\sigma_{i}}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Regularization_by_spectral_filtering:50">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>≪</mo>
   <mrow>
    <mi>λ</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-less-than</csymbol>
    <ci>σ</ci>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\ll\lambda n
  </annotation>
 </semantics>
</math>

.</li>
<li>If 

<math display="inline" id="Regularization_by_spectral_filtering:51">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <msub>
      <mi>σ</mi>
      <mi>i</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>n</mi>
      <mi>λ</mi>
     </mrow>
    </mrow>
   </mfrac>
   <mo>∼</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>λ</mi>
     <mi>n</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\sigma_{i}+n\lambda}\sim\frac{1}{\lambda n}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Regularization_by_spectral_filtering:52">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>G</mi>
      <mi>λ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi>σ</mi>
      <mo>+</mo>
      <mrow>
       <mi>n</mi>
       <mi>λ</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>λ</ci>
     </apply>
     <ci>σ</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <ci>σ</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\lambda}(\sigma)=\frac{1}{\sigma+n\lambda}.
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The filter function for Tikhonov regularization is therefore defined as:<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> 

<math display="block" id="Regularization_by_spectral_filtering:53">
 <semantics>
  <mrow>
   <msup>
    <mi>c</mi>
    <mn>0</mn>
   </msup>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c^{0}=0\,
  </annotation>
 </semantics>
</math>

</p>
<h3 id="filter-function-for-landweber-iteration">Filter function for Landweber iteration</h3>

<p>The idea behind the Landweber iteration is <a href="gradient_descent" title="wikilink">gradient descent</a>:<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>

<math display="block" id="Regularization_by_spectral_filtering:54">
 <semantics>
  <mrow>
   <mrow>
    <mtext>for</mtext>
    <mi>i</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>t</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>for</mtext>
     <ci>i</ci>
    </apply>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{for }i=1,\dots,t-1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Regularization_by_spectral_filtering:55">
 <semantics>
  <mrow>
   <msup>
    <mpadded lspace="16.5pt" width="+16.5pt">
     <mi>c</mi>
    </mpadded>
    <mi>i</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>c</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>+</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Y</mi>
       <mo>-</mo>
       <mrow>
        <mi>K</mi>
        <msup>
         <mi>c</mi>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <minus></minus>
       <ci>Y</ci>
       <apply>
        <times></times>
        <ci>K</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>c</ci>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ~{}~{}~{}~{}~{}c^{i}=c^{i-1}+\eta(Y-Kc^{i-1})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Regularization_by_spectral_filtering:56">
 <semantics>
  <mi>end</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>end</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{end}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Regularization_by_spectral_filtering:57">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

</p>

<p>In this setting, if 

<math display="inline" id="Regularization_by_spectral_filtering:58">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is larger than 

<math display="inline" id="Regularization_by_spectral_filtering:59">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>η</ci>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta=2/n
  </annotation>
 </semantics>
</math>

's largest eigenvalue, the above iteration converges by choosing 

<math display="inline" id="Regularization_by_spectral_filtering:60">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mi>n</mi>
   </mfrac>
   <msubsup>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <mi>Y</mi>
      <mo>-</mo>
      <mrow>
       <mi>K</mi>
       <mi>c</mi>
      </mrow>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mn>2</mn>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>Y</ci>
        <apply>
         <times></times>
         <ci>K</ci>
         <ci>c</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{n}||Y-Kc||_{2}^{2}
  </annotation>
 </semantics>
</math>

 as the step-size:.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The above iteration is equivalent to minimizing 

<math display="inline" id="Regularization_by_spectral_filtering:61">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 (i.e. the empirical risk) via gradient descent; using induction, it can be proved that at the 

<math display="block" id="Regularization_by_spectral_filtering:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mo>=</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>I</mi>
          <mo>-</mo>
          <mrow>
           <mi>η</mi>
           <mi>K</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>i</mi>
       </msup>
       <mi>Y</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>η</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>I</ci>
         <apply>
          <times></times>
          <ci>η</ci>
          <ci>K</ci>
         </apply>
        </apply>
        <ci>i</ci>
       </apply>
       <ci>Y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=\eta\sum_{i=0}^{t-1}(I-\eta K)^{i}Y.
  </annotation>
 </semantics>
</math>

-th iteration, the solution is given by <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>

<math display="inline" id="Regularization_by_spectral_filtering:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>G</mi>
      <mi>λ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>I</mi>
         <mo>-</mo>
         <mrow>
          <mi>η</mi>
          <mi>σ</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>i</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>λ</ci>
     </apply>
     <ci>σ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>η</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>I</ci>
        <apply>
         <times></times>
         <ci>η</ci>
         <ci>σ</ci>
        </apply>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\lambda}(\sigma)=\eta\sum_{i=0}^{t-1}(I-\eta\sigma)^{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, the appropriate filter function is defined by:</p>

<p>

<math display="inline" id="Regularization_by_spectral_filtering:64">
 <semantics>
  <msup>
   <mi>K</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>K</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K^{-1}
  </annotation>
 </semantics>
</math>

</p>

<p>It can be shown that this filter function corresponds to a truncated power expansion of 

<math display="inline" id="Regularization_by_spectral_filtering:65">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>≥</mo>
      <mn>0</mn>
     </mrow>
    </msub>
    <msup>
     <mi>x</mi>
     <mi>i</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <geq></geq>
       <ci>i</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i\geq 0}x^{i}=1/(1-x)
  </annotation>
 </semantics>
</math>

;<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> to see this, note that the relation 

<math display="inline" id="Regularization_by_spectral_filtering:66">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, would still hold if 

<math display="inline" id="Regularization_by_spectral_filtering:67">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is replaced by a matrix; thus, if 

<math display="inline" id="Regularization_by_spectral_filtering:68">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>-</mo>
   <mrow>
    <mi>η</mi>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>I</ci>
    <apply>
     <times></times>
     <ci>η</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I-\eta K
  </annotation>
 </semantics>
</math>

 (the kernel matrix), or rather 

<math display="block" id="Regularization_by_spectral_filtering:69">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>K</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </munderover>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>I</mi>
         <mo>-</mo>
         <mrow>
          <mi>η</mi>
          <mi>K</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>i</mi>
      </msup>
     </mrow>
    </mrow>
    <mo>∼</mo>
    <mrow>
     <mi>η</mi>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>I</mi>
         <mo>-</mo>
         <mrow>
          <mi>η</mi>
          <mi>K</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>i</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>K</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>I</ci>
         <apply>
          <times></times>
          <ci>η</ci>
          <ci>K</ci>
         </apply>
        </apply>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>I</ci>
         <apply>
          <times></times>
          <ci>η</ci>
          <ci>K</ci>
         </apply>
        </apply>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K^{-1}=\eta\sum_{i=0}^{\infty}(I-\eta K)^{i}\sim\eta\sum_{i=0}^{t-1}(I-\eta K)%
^{i}.
  </annotation>
 </semantics>
</math>

, is considered, the following holds:</p>

<p>

<math display="inline" id="Regularization_by_spectral_filtering:70">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∼</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>λ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>t</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\sim 1/\lambda
  </annotation>
 </semantics>
</math>

</p>

<p>In this setting, the number of iterations gives the regularization parameter; roughly speaking, 

<math display="inline" id="Regularization_by_spectral_filtering:71">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> If 

<math display="inline" id="Regularization_by_spectral_filtering:72">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is large, overfitting may be a concern. If 

<math display="inline" id="Regularization_by_spectral_filtering:73">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <mi mathvariant="normal">Σ</mi>
    <msup>
     <mi>Q</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>normal-Σ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=Q\Sigma Q^{T}
  </annotation>
 </semantics>
</math>

 is small, oversmoothing may be a concern. Thus, choosing an appropriate time for early stopping of the iterations provides a regularization effect.</p>
<h3 id="filter-function-for-tsvd">Filter function for TSVD</h3>

<p>In the TSVD setting, given the eigen-decomposition 

<math display="inline" id="Regularization_by_spectral_filtering:74">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>λ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda n
  </annotation>
 </semantics>
</math>

 and using a prescribed threshold 

<math display="block" id="Regularization_by_spectral_filtering:75">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>G</mi>
      <mi>λ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>{</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mi>σ</mi>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mi></mi>
         <mo>,</mo>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>σ</mi>
         </mrow>
         <mo>≥</mo>
         <mrow>
          <mi>λ</mi>
          <mi>n</mi>
         </mrow>
        </mrow>
       </mtd>
       <mtd></mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mi></mi>
         <mo>,</mo>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mtext>otherwise</mtext>
       </mtd>
       <mtd></mtd>
      </mtr>
     </mtable>
     <mi></mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>λ</ci>
     </apply>
     <ci>σ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <matrix>
      <matrixrow>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>σ</ci>
       </apply>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <geq></geq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>σ</ci>
        </apply>
        <apply>
         <times></times>
         <ci>λ</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <csymbol cd="latexml">absent</csymbol>
       <mtext>otherwise</mtext>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{\lambda}(\sigma)=\left\{\begin{array}[c]{lcll}1/\sigma&,&\text{if }\sigma%
\geq\lambda n\\
0&,&\text{otherwise}\\
\end{array}\right..
  </annotation>
 </semantics>
</math>

, a regularized inverse can be formed for the kernel matrix by discarding all the eigenvalues that are smaller than this threshold.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Thus, the filter function for TSVD can be defined as</p>

<p><span class="LaTeX">$$G_\lambda(\sigma) =\left\{\begin{array}[c]{lcll}1/\sigma &amp; ,&amp; \text{if }\sigma\geq\lambda n\\[0.05in]0&amp;,&amp; \text{otherwise}\\[0.05in]\end{array}\right..$$</span></p>

<p>It can be shown that TSVD is equivalent to the (unsupervised) projection of the data using (kernel) <a href="Principal_component_analysis" title="wikilink">Principal Component Analysis</a> (PCA), and that it is also equivalent to minimizing the empirical risk on the projected data (without regularization).<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Note that the number of components kept for the projection is the only free parameter here.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Mathematical_analysis" title="wikilink">Category:Mathematical analysis</a> <a href="Category:Inverse_problems" title="wikilink">Category:Inverse problems</a> <a href="Category:Computer_engineering" title="wikilink">Category:Computer engineering</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Heinz_Engl" title="wikilink">H. W. Engl</a>, M. Hanke, and A. Neubauer. <em>Regularization of inverse problems</em>. Kluwer, 1996.<a href="#fnref1">↩</a></li>
<li id="fn2">L. Lo Gerfo, L. Rosasco, F. Odone, E. De Vito, and A. Verri. Spectral Algorithms for Supervised Learning, <em>Neural Computation</em>, 20(7), 2008.<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5">P. C. Hansen, J. G. Nagy, and D. P. O'Leary. <em>Deblurring Images: Matrices, Spectra, and Filtering</em>, Fundamentals of Algorithms 3, SIAM, Philadelphia, 2006.<a href="#fnref5">↩</a></li>
<li id="fn6">L. Rosasco. Lecture 6 of the Lecture Notes for 9.520: Statistical Learning Theory and Applications. Massachusetts Institute of Technology, Fall 2013. Available at <a class="uri" href="http://www.mit.edu/~9.520/fall13/slides/class06/class06_RLSSVM.pdf">http://www.mit.edu/~9.520/fall13/slides/class06/class06_RLSSVM.pdf</a><a href="#fnref6">↩</a></li>
<li id="fn7">L. Rosasco. Lecture 7 of the Lecture Notes for 9.520: Statistical Learning Theory and Applications. Massachusetts Institute of Technology, Fall 2013. Available at <a class="uri" href="http://www.mit.edu/~9.520/fall13/slides/class07/class07_spectral.pdf">http://www.mit.edu/~9.520/fall13/slides/class07/class07_spectral.pdf</a><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
</ol>
</section>
</body>
</html>
