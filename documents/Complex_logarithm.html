<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1830">Complex logarithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Complex logarithm</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>A single branch of the complex logarithm. The hue of the color is used to show the <strong><em><a href="Arg_(mathematics)" title="wikilink">arg</a></em></strong> (polar coordinate angle) of the complex logarithm. The saturation and value (intensity and brightness) of the color is used to show the <strong><em><a href="Modulus_(algebraic_number_theory)" title="wikilink">modulus</a></em></strong> of the complex logarithm. <a href=":File:Complex_log.jpg" title="wikilink">The image file's page</a> shows the encoding of colors as a function of their complex values.</figcaption>
</figure>

<p>In <a href="complex_analysis" title="wikilink">complex analysis</a>, a <strong>complex logarithm</strong> function is an "<a href="inverse_function" title="wikilink">inverse</a>" of the <a href="Exponential_function#Complex_plane" title="wikilink">complex exponential function</a>, just as the real <a href="natural_logarithm" title="wikilink">natural logarithm</a> ln <em>x</em> is the inverse of the <a href="exponential_function" title="wikilink">real exponential function</a> <em>e</em><sup><em>x</em></sup>. Thus, a <a class="uri" href="logarithm" title="wikilink">logarithm</a> of a <a href="complex_number" title="wikilink">complex number</a> <em>z</em> is a complex number <em>w</em> such that <em>e</em><sup><em>w</em></sup> = <em>z</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The notation for such a <em>w</em> is <strong>ln <em>z</em></strong> or <strong>log <em>z</em></strong>. Since every nonzero complex number <em>z</em> has infinitely many logarithms,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> care is required to give such notation an unambiguous meaning.</p>

<p>If <em>z</em> = <em>re</em><sup><em>iθ</em></sup> with <em>r</em> &gt; 0 (<a href="polar_form" title="wikilink">polar form</a>), then <em>w</em> = ln <em>r</em> + <em>iθ</em> is one logarithm of <em>z;</em> adding integer multiples of 2<em>πi</em> gives all the others.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="problems-with-inverting-the-complex-exponential-function">Problems with inverting the complex exponential function</h2>
<figure><b>(Figure)</b>
<figcaption>A plot of the multi-valued imaginary part of the complex logarithm function, which shows the branches. As a complex number <em>z</em> goes around the origin, the imaginary part of the logarithm goes up or down. This makes the origin a <em>branch point</em> of the function.</figcaption>
</figure>

<p>For a function to have an <a href="inverse_function" title="wikilink">inverse</a>, it must <a href="injective" title="wikilink">map distinct values to distinct values</a>, i.e., be <a class="uri" href="injective" title="wikilink">injective</a>. But the complex exponential function is not injective, because <mtpl></mtpl> for any <em>w</em>, since adding <em>iθ</em> to <em>w</em> has the effect of rotating <em>e</em><sup><em>w</em></sup> counterclockwise <em>θ</em> <a href="radian" title="wikilink">radians</a>. Even worse, the infinitely many numbers</p>

<p>
<math display="block" id="Complex_logarithm:0">
<semantics>
<mrow>
<mrow>
<mi mathvariant="normal">…</mi>
<mo rspace="5.3pt">,</mo>
<mrow>
<mi>w</mi>
<mo>-</mo>
<mrow>
<mn>4</mn>
<mi>π</mi>
<mi>i</mi>
</mrow>
</mrow>
<mo rspace="5.3pt">,</mo>
<mrow>
<mi>w</mi>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>i</mi>
</mrow>
</mrow>
<mo rspace="5.3pt">,</mo>
<mi>w</mi>
<mo rspace="5.3pt">,</mo>
<mrow>
<mi>w</mi>
<mo>+</mo>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>i</mi>
</mrow>
</mrow>
<mo rspace="5.3pt">,</mo>
<mrow>
<mi>w</mi>
<mo>+</mo>
<mrow>
<mn>4</mn>
<mi>π</mi>
<mi>i</mi>
</mrow>
</mrow>
<mo rspace="5.3pt">,</mo>
<mi mathvariant="normal">…</mi>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>normal-…</ci>
<apply>
<minus></minus>
<ci>w</ci>
<apply>
<times></times>
<cn type="integer">4</cn>
<ci>π</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<minus></minus>
<ci>w</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>i</ci>
</apply>
</apply>
<ci>w</ci>
<apply>
<plus></plus>
<ci>w</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<plus></plus>
<ci>w</ci>
<apply>
<times></times>
<cn type="integer">4</cn>
<ci>π</ci>
<ci>i</ci>
</apply>
</apply>
<ci>normal-…</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ldots,\;w-4\pi i,\;w-2\pi i,\;w,\;w+2\pi i,\;w+4\pi i,\;\ldots,
  </annotation>
</semantics>
</math>

 forming a sequence of equally spaced points along a vertical line, are all mapped to the same number by the exponential function. So the exponential function does not have an inverse function in the standard sense.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>There are two solutions to this problem.</p>

<p>One is to restrict the domain of the exponential function to a region that <em>does not contain any two numbers differing by an integer multiple of 2πi</em>: this leads naturally to the definition of <a href="branch_cut" title="wikilink">branches</a> of , which are certain functions that single out one logarithm of each number in their domains. This is analogous to the definition of <a href="arcsin" title="wikilink"></a> on  as the inverse of the restriction of <a href="sine" title="wikilink"></a> to the interval : there are infinitely many real numbers <em>θ</em> with , but one (somewhat arbitrarily) chooses the one in .</p>

<p>Another way to resolve the indeterminacy is to view the logarithm as a function whose domain is not a region in the <a href="complex_plane" title="wikilink">complex plane</a>, but a <a href="Riemann_surface" title="wikilink">Riemann surface</a> that <em><a href="covering_space" title="wikilink">covers</a></em> the punctured complex plane in an infinite-to-1 way.</p>

<p>Branches have the advantage that they can be evaluated at complex numbers. On the other hand, the function on the Riemann surface is elegant in that it packages together <em>all</em> branches of  and does not require an arbitrary choice as part of its definition.</p>
<h2 id="definition-of-principal-value">Definition of principal value</h2>

<p>For each nonzero complex number <em>z</em> = <em>x</em> + <em>yi</em>, the <strong>principal value</strong> Log <em>z</em> is the logarithm whose <a href="imaginary_part" title="wikilink">imaginary part</a> lies in the interval (−<em>π</em>,<em>π</em>]. The expression Log 0 is left undefined since there is no complex number <em>w</em> satisfying <em>e</em><sup><em>w</em></sup> = 0.</p>

<p>The principal value can be described also in a few other ways.</p>

<p>To give a formula for Log <em>z</em>, begin by expressing <em>z</em> in <a href="polar_form" title="wikilink">polar form</a>, <em>z</em> = <em>re</em><sup><em>iθ</em></sup>. Given <em>z</em>, the polar form is not quite unique, because of the possibility of adding an integer multiple of 2<em>π</em> to <em>θ</em>, but it can be <em>made</em> unique by requiring <em>θ</em> to lie in the interval (−<em>π</em>,<em>π</em>]; this <em>θ</em> is called the principal value of the argument, and is sometimes written <a href="Arg_(mathematics)" title="wikilink">Arg <em>z</em></a> or (especially in computer languages) <a href="atan2" title="wikilink">atan2(<em>y</em>,<em>x</em>)</a>. Then the principal value of the logarithm<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> can be defined by</p>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Complex_logarithm:1">
<semantics>
<mrow>
<mrow>
<mrow>
<mo>Log</mo>
<mi>z</mi>
</mrow>
<mo>:=</mo>
<mrow>
<mrow>
<mtext>ln</mtext>
<mi>r</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>i</mi>
<mi>θ</mi>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">|</mo>
<mi>z</mi>
<mo stretchy="false">|</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mi>i</mi>
<mrow>
<mo>Arg</mo>
<mi>z</mi>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo>ln</mo>
<msqrt>
<mrow>
<msup>
<mi>x</mi>
<mn>2</mn>
</msup>
<mo>+</mo>
<msup>
<mi>y</mi>
<mn>2</mn>
</msup>
</mrow>
</msqrt>
</mrow>
<mo>+</mo>
<mrow>
<mi>i</mi>
<mrow>
<mo>atan2</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo>,</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<csymbol cd="latexml">assign</csymbol>
<apply>
<ci>Log</ci>
<ci>z</ci>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<mtext>ln</mtext>
<ci>r</ci>
</apply>
<apply>
<times></times>
<ci>i</ci>
<ci>θ</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<plus></plus>
<apply>
<ln></ln>
<apply>
<abs></abs>
<ci>z</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>i</ci>
<apply>
<ci>Arg</ci>
<ci>z</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<plus></plus>
<apply>
<ci>ln</ci>
<apply>
<root></root>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>i</ci>
<apply>
<ci>atan2</ci>
<ci>y</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Log}z:=\text{ln }r+i\theta=\ln|z|+i\operatorname{Arg}z=%
\operatorname{ln}\sqrt{x^{2}+y^{2}}+i\operatorname{atan2}(y,x).
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>

<p>For example, Log(-3<em>i</em>) = ln 3 − <em>πi</em>/2.</p>

<p>Another way to describe Log <em>z</em> is as the inverse of a restriction of the complex exponential function, as in the previous section. The horizontal strip <em>S</em> consisting of complex numbers <em>w</em> = <em>x</em>+<em>yi</em> such that −<em>π</em> \mathbb{C}^\times = \mathbb{C} - \{0\}, and the inverse of this restriction is 

<math display="inline" id="Complex_logarithm:2">
<semantics>
<mrow>
<mo>Log</mo>
<mo>:</mo>
<mrow>
<msup>
<mi>ℂ</mi>
<mo>×</mo>
</msup>
<mo>→</mo>
<mi>S</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>Log</ci>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℂ</ci>
<times></times>
</apply>
<ci>S</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Log}\colon\mathbb{C}^{\times}\to S
  </annotation>
</semantics>
</math>

. The conformal mapping section below explains the geometric properties of this map in more detail.</p>

<p>When the notation log <em>z</em> appears without any particular logarithm having been specified, it is generally best to assume that the principal value is intended. In particular, this gives a value consistent with the real value of ln <em>z</em> when <em>z</em> is a positive real number. The capitalization in the notation Log is used by some authors<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> to distinguish the principal value from other logarithms of <em>z</em>.</p>

<p>Not all identities satisfied by ln extend to complex numbers. It is true that <em>e</em><sup>Log <em>z</em></sup> = <em>z</em> for all <em>z</em> ≠ 0 (this is what it means for Log <em>z</em> to be a logarithm of <em>z</em>), but the identity Log <em>e</em><sup><em>z</em></sup> = <em>z</em> fails for <em>z</em> outside the strip <em>S</em>. For this reason, one cannot always apply Log to both sides of an identity <em>e</em><sup><em>z</em></sup> = <em>e</em><sup><em>w</em></sup> to deduce <em>z</em> = <em>w</em>. Also, the identity Log(<em>z</em><sub>1</sub><em>z</em><sub>2</sub>) = Log <em>z</em><sub>1</sub> + Log <em>z</em><sub>2</sub> can fail: the two sides can differ by an integer multiple of 2<em>πi</em> : for instance,</p>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Complex_logarithm:3">
<semantics>
<mrow>
<mrow>
<mrow>
<mo>Log</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>i</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>Log</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>i</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>-</mo>
<mfrac>
<mrow>
<mi>π</mi>
<mi>i</mi>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mfrac>
<mrow>
<mi>π</mi>
<mi>i</mi>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<ci>Log</ci>
<apply>
<times></times>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<ci>i</ci>
</apply>
</apply>
<apply>
<ci>Log</ci>
<apply>
<minus></minus>
<ci>i</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<minus></minus>
<apply>
<ln></ln>
<cn type="integer">1</cn>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>π</ci>
<ci>i</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<minus></minus>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>π</ci>
<ci>i</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Log}((-1)i)=\operatorname{Log}(-i)=\ln(1)-\frac{\pi i}{2}=-\frac%
{\pi i}{2},
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>

<p>but</p>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Complex_logarithm:4">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mo>Log</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mo>Log</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo>(</mo>
<mrow>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mi>π</mi>
<mi>i</mi>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mo>+</mo>
<mrow>
<mo>(</mo>
<mrow>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mfrac>
<mrow>
<mi>π</mi>
<mi>i</mi>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mfrac>
<mrow>
<mn>3</mn>
<mi>π</mi>
<mi>i</mi>
</mrow>
<mn>2</mn>
</mfrac>
<mo>≠</mo>
<mrow>
<mo>-</mo>
<mfrac>
<mrow>
<mi>π</mi>
<mi>i</mi>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<ci>Log</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<ci>Log</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<plus></plus>
<apply>
<ln></ln>
<cn type="integer">1</cn>
</apply>
<apply>
<times></times>
<ci>π</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<ln></ln>
<cn type="integer">1</cn>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>π</ci>
<ci>i</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<divide></divide>
<apply>
<times></times>
<cn type="integer">3</cn>
<ci>π</ci>
<ci>i</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<neq></neq>
<share href="#.cmml">
</share>
<apply>
<minus></minus>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>π</ci>
<ci>i</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Log}(-1)+\operatorname{Log}(i)=\left(\ln(1)+\pi i\right)+\left(%
\ln(1)+\frac{\pi i}{2}\right)=\frac{3\pi i}{2}\neq-\frac{\pi i}{2}.
  </annotation>
</semantics>
</math>
<br/>
</dd>
</dl>
</dd>
</dl>

<p>The function Log <em>z</em> is <a class="uri" href="discontinuous" title="wikilink">discontinuous</a> at each negative real number, but <a href="continuous_function" title="wikilink">continuous</a> everywhere else in 

<math display="inline" id="Complex_logarithm:5">
<semantics>
<msup>
<mi>ℂ</mi>
<mo>×</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℂ</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}^{\times}
  </annotation>
</semantics>
</math>

. To explain the discontinuity, consider what happens to Arg <em>z</em> as <em>z</em> approaches a negative real number <em>a</em>. If <em>z</em> approaches <em>a</em> from above, then Arg <em>z</em> approaches <em>π</em>, which is also the value of Arg <em>a</em> itself. But if <em>z</em> approaches <em>a</em> from below, then Arg <em>z</em> approaches −<em>π</em>. So Arg <em>z</em> "jumps" by 2<em>π</em> as <em>z</em> crosses the negative real axis, and similarly Log <em>z</em> jumps by 2<em>πi</em>.</p>
<h2 id="branches-of-the-complex-logarithm">Branches of the complex logarithm</h2>

<p>Is there a different way to choose a logarithm of each nonzero complex number so as to make a function <em>L</em>(<em>z</em>) that is continuous on <em>all</em> of 

<math display="inline" id="Complex_logarithm:6">
<semantics>
<msup>
<mi>ℂ</mi>
<mo>×</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℂ</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}^{\times}
  </annotation>
</semantics>
</math>

? Unfortunately, the answer is no. To see why, imagine tracking such a logarithm function along the <a href="unit_circle" title="wikilink">unit circle</a>, by evaluating <em>L</em> at <em>e</em><sup><em>iθ</em></sup> as <em>θ</em> increases from 0 to 2<em>π</em>. For simplicity, suppose that the starting value <em>L</em>(1) is 0. Then for <em>L</em>(<em>z</em>) to be continuous, <em>L</em>(<em>e</em><sup><em>iθ</em></sup>) must agree with <em>iθ</em> as <em>θ</em> increases (the difference is a continuous function of <em>θ</em> taking values in the discrete set 

<math display="inline" id="Complex_logarithm:7">
<semantics>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>i</mi>
<mi>ℤ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>i</ci>
<ci>ℤ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2\pi i\mathbb{Z}
  </annotation>
</semantics>
</math>

). In particular, <em>L</em>(<em>e</em><sup>2<em>πi</em></sup>) = 2<em>πi</em>, but <em>e</em><sup>2<em>πi</em></sup> = 1, so this contradicts <em>L</em>(1) = 0.</p>

<p>To obtain a continuous logarithm defined on complex numbers, it is hence necessary to restrict the domain to a smaller subset <em>U</em> of the complex plane. Because one of the goals is to be able to <a href="derivative" title="wikilink">differentiate</a> the function, it is reasonable to assume that the function is defined on a neighborhood of each point of its domain; in other words, <em>U</em> should be an <a href="open_set" title="wikilink">open set</a>. Also, it is reasonable to assume that <em>U</em> is <a href="Connectedness" title="wikilink">connected</a>, since otherwise the function values on different components of <em>U</em> could be unrelated to each other. All this motivates the following definition:</p>
<dl>
<dd><dl>
<dd>A <strong>branch</strong> of log <em>z</em> is a <a href="continuous_function" title="wikilink">continuous function</a> <em>L</em>(<em>z</em>) defined on a connected <a href="open_set" title="wikilink">open subset</a> <em>U</em> of the complex plane such that <em>L</em>(<em>z</em>) is a logarithm of <em>z</em> for each <em>z</em> in <em>U</em>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a>
</dd>
</dl>
</dd>
</dl>

<p>For example, the principal value defines a branch on the open set where it is continuous, which is the set 

<math display="inline" id="Complex_logarithm:8">
<semantics>
<mrow>
<mi>ℂ</mi>
<mo>-</mo>
<msub>
<mi>ℝ</mi>
<mrow>
<mi></mi>
<mo>≤</mo>
<mn>0</mn>
</mrow>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>ℂ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℝ</ci>
<apply>
<leq></leq>
<csymbol cd="latexml">absent</csymbol>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}-\mathbb{R}_{\leq 0}
  </annotation>
</semantics>
</math>

 obtained by removing 0 and all negative real numbers from the complex plane.</p>

<p>Another example: The <a href="Mercator_series" title="wikilink">Mercator series</a></p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\log(1+u)=\sum_{n=1}^\infty \frac{(-1)^{n+1}}{n} u^n = u - \frac{u^2}{2} + \frac{u^3}{3} - \cdots \,  <a href="Convergent_series" title="wikilink">converges</a> <a href="uniform_convergence" title="wikilink">locally uniformly</a> for |<em>u</em>|  Another way to prove this is to check the <a href="Cauchy-Riemann_equations#Other_representations" title="wikilink">Cauchy-Riemann equations in polar coordinates</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="constructing-branches-via-integration">Constructing branches via integration</h3>

<p>The function ln <em>x</em> for <em>x</em> &gt; 0 can be constructed by the formula</p>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Complex_logarithm:9">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>ln</mi>
<mi>x</mi>
</mrow>
<mo>=</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mn>1</mn>
<mi>x</mi>
</msubsup>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<mn>1</mn>
<mi>u</mi>
</mfrac>
</mpadded>
<mi>d</mi>
<mi>u</mi>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ln></ln>
<ci>x</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">1</cn>
</apply>
<ci>x</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>u</ci>
</apply>
<ci>d</ci>
<ci>u</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ln x=\int_{1}^{x}\frac{1}{u}\,du.
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>

<p>If the range of integration started at a positive number <em>a</em> other than 1, the formula would have to be</p>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Complex_logarithm:10">
<semantics>
<mrow>
<mrow>
<mi>ln</mi>
<mi>x</mi>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mi>ln</mi>
<mi>a</mi>
</mrow>
<mo>+</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mi>a</mi>
<mi>x</mi>
</msubsup>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<mn>1</mn>
<mi>u</mi>
</mfrac>
</mpadded>
<mi>d</mi>
<mi>u</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ln></ln>
<ci>x</ci>
</apply>
<apply>
<plus></plus>
<apply>
<ln></ln>
<ci>a</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<ci>a</ci>
</apply>
<ci>x</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>u</ci>
</apply>
<ci>d</ci>
<ci>u</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ln x=\ln a+\int_{a}^{x}\frac{1}{u}\,du
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>

<p>instead.</p>

<p>In developing the analogue for the <em>complex</em> logarithm, there is an additional complication: the definition of the <a href="complex_integral" title="wikilink">complex integral</a> requires a choice of path. Fortunately, if the integrand is holomorphic, then the value of the integral is unchanged by <a href="homotopy" title="wikilink">deforming the path</a> (while holding the endpoints fixed), and in a <a href="simply_connected" title="wikilink">simply connected</a> region <em>U</em> (a region with "no holes") <em>any</em> path from <em>a</em> to <em>z</em> inside <em>U</em> can be <a href="homotopy" title="wikilink">continuously deformed</a> inside <em>U</em> into any other. All this leads to the following:</p>
<dl>
<dd><dl>
<dd>If <em>U</em> is a <a href="simply_connected" title="wikilink">simply connected</a> open subset of 

<math display="inline" id="Complex_logarithm:11">
<semantics>
<mi>ℂ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℂ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}
  </annotation>
</semantics>
</math>

 not containing 0, then a branch of log <em>z</em> defined on <em>U</em> can be constructed by choosing a starting point <em>a</em> in <em>U</em>, choosing a logarithm <em>b</em> of <em>a</em>, and defining
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Complex_logarithm:12">
<semantics>
<mrow>
<mrow>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>:=</mo>
<mrow>
<mi>b</mi>
<mo>+</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mi>a</mi>
<mi>z</mi>
</msubsup>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<mn>1</mn>
<mi>w</mi>
</mfrac>
</mpadded>
<mi>d</mi>
<mi>w</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">assign</csymbol>
<apply>
<times></times>
<ci>L</ci>
<ci>z</ci>
</apply>
<apply>
<plus></plus>
<ci>b</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<ci>a</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>w</ci>
</apply>
<ci>d</ci>
<ci>w</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L(z):=b+\int_{a}^{z}\frac{1}{w}\,dw
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>for each <em>z</em> in <em>U</em>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a>
</dd>
</dl>
</dd>
</dl>
<h2 id="the-complex-logarithm-as-a-conformal-map">The complex logarithm as a conformal map</h2>
<figure><b>(Figure)</b>
<figcaption>The circles Re(Log <em>z</em>) = constant and the rays Im(Log <em>z</em>) = constant in the complex <em>z</em>-plane.</figcaption>
</figure>

<p>Any holomorphic map 

<math display="inline" id="Complex_logarithm:13">
<semantics>
<mrow>
<mi>f</mi>
<mo>:</mo>
<mrow>
<mi>U</mi>
<mo>→</mo>
<mi>ℂ</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>f</ci>
<apply>
<ci>normal-→</ci>
<ci>U</ci>
<ci>ℂ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f\colon U\to\mathbb{C}
  </annotation>
</semantics>
</math>

 satisfying 

<math display="inline" id="Complex_logarithm:14">
<semantics>
<mrow>
<mrow>
<msup>
<mi>f</mi>
<mo>′</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≠</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<neq></neq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<ci>normal-′</ci>
</apply>
<ci>z</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f^{\prime}(z)\neq 0
  </annotation>
</semantics>
</math>

 for all 

<math display="inline" id="Complex_logarithm:15">
<semantics>
<mrow>
<mi>z</mi>
<mo>∈</mo>
<mi>U</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>z</ci>
<ci>U</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z\in U
  </annotation>
</semantics>
</math>

 is a <a href="conformal_map" title="wikilink">conformal map</a>, which means that if two curves passing through a point <em>a</em> of <em>U</em> form an angle <em>α</em> (in the sense that the <a href="tangent_line" title="wikilink">tangent lines</a> to the curves at <em>a</em> form an angle <em>α</em>), then the images of the two curves form the <em>same</em> angle <em>α</em> at <em>f</em>(<em>a</em>). Since a branch of log <em>z</em> is <a href="Holomorphic_function" title="wikilink">holomorphic</a>, and since its derivative 1/<em>z</em> is never 0, it defines a <a href="conformal_map" title="wikilink">conformal map</a>.</p>

<p>For example, the principal branch <em>w</em> = Log <em>z</em>, viewed as a mapping from 

<math display="inline" id="Complex_logarithm:16">
<semantics>
<mrow>
<mi>ℂ</mi>
<mo>-</mo>
<msub>
<mi>ℝ</mi>
<mrow>
<mi></mi>
<mo>≤</mo>
<mn>0</mn>
</mrow>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>ℂ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℝ</ci>
<apply>
<leq></leq>
<csymbol cd="latexml">absent</csymbol>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}-\mathbb{R}_{\leq 0}
  </annotation>
</semantics>
</math>

 to the horizontal strip defined by |Im <em>z</em>| Strictly speaking, the point on each circle on the negative real axis should be discarded, or the principal value should be used there. in the <em>z</em>-plane centered at 0 are mapped to vertical segments in the <em>w</em>-plane connecting <em>a</em> − <em>πi</em> to <em>a</em> + <em>πi</em>, where <em>a</em> is a real number depending on the radius of the circle.</p>
<ul>
<li>Rays emanating from 0 in the <em>z</em>-plane are mapped to horizontal lines in the <em>w</em>-plane.</li>
</ul>

<p>Each circle and ray in the <em>z</em>-plane as above meet at a right angle. Their images under Log are a vertical segment and a horizontal line (respectively) in the <em>w</em>-plane, and these too meet at a right angle. This is an illustration of the conformal property of Log.</p>
<h2 id="the-associated-riemann-surface">The associated Riemann surface</h2>
<figure><b>(Figure)</b>
<figcaption>A visualization of the Riemann surface of log <em>z</em>. The surface appears to spiral around a vertical line corresponding to the origin of the complex plane. The actual surface extends arbitrarily far both horizontally and vertically, but is cut off in this image.</figcaption>
</figure>
<h3 id="construction">Construction</h3>

<p>The various branches of log <em>z</em> cannot be glued to give a single function 

<math display="inline" id="Complex_logarithm:17">
<semantics>
<mrow>
<mi>log</mi>
<mo>:</mo>
<mrow>
<msup>
<mi>ℂ</mi>
<mo>×</mo>
</msup>
<mo>→</mo>
<mi>ℂ</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<log></log>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℂ</ci>
<times></times>
</apply>
<ci>ℂ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \log\colon\mathbb{C}^{\times}\to\mathbb{C}
  </annotation>
</semantics>
</math>

 because two branches may give different values at a point where both are defined. Compare, for example, the principal branch Log(<em>z</em>) on 

<math display="inline" id="Complex_logarithm:18">
<semantics>
<mrow>
<mi>ℂ</mi>
<mo>-</mo>
<msub>
<mi>ℝ</mi>
<mrow>
<mi></mi>
<mo>≤</mo>
<mn>0</mn>
</mrow>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>ℂ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℝ</ci>
<apply>
<leq></leq>
<csymbol cd="latexml">absent</csymbol>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}-\mathbb{R}_{\leq 0}
  </annotation>
</semantics>
</math>

 with imaginary part <em>θ</em> in (−<em>π</em>,<em>π</em>) and the branch <em>L</em>(<em>z</em>) on 

<math display="inline" id="Complex_logarithm:19">
<semantics>
<mrow>
<mi>ℂ</mi>
<mo>-</mo>
<msub>
<mi>ℝ</mi>
<mrow>
<mi></mi>
<mo>≥</mo>
<mn>0</mn>
</mrow>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>ℂ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ℝ</ci>
<apply>
<geq></geq>
<csymbol cd="latexml">absent</csymbol>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}-\mathbb{R}_{\geq 0}
  </annotation>
</semantics>
</math>

 whose imaginary part <em>θ</em> lies in (0,2<em>π</em>). These agree on the <a href="upper_half_plane" title="wikilink">upper half plane</a>, but not on the lower half plane. So it makes sense to glue the domains of these branches <em>only along the copies of the upper half plane</em>. The resulting glued domain is connected, but it has two copies of the lower half plane. Those two copies can be visualized as two levels of a parking garage, and one can get from the Log level of the lower half plane up to the <em>L</em> level of the lower half plane by going 360° counterclockwise around 0, first crossing the positive real axis (of the Log level) into the shared copy of the upper half plane and then crossing the negative real axis (of the <em>L</em> level) into the <em>L</em> level of the lower half plane.</p>

<p>One can continue by gluing branches with imaginary part <em>θ</em> in (<em>π</em>,3<em>π</em>), in (2<em>π</em>,4<em>π</em>), and so on, and in the other direction, branches with imaginary part <em>θ</em> in (−2<em>π</em>,0), in (−3<em>π</em>,−<em>π</em>), and so on. The final result is a connected surface that can be viewed as a spiralling parking garage with infinitely many levels extending both upward and downward. This is the <a href="Riemann_surface" title="wikilink">Riemann surface</a> <em>R</em> associated to log <em>z</em>.</p>

<p>A point on <em>R</em> can be thought of as a pair (<em>z</em>,<em>θ</em>) where <em>θ</em> is a possible value of the argument of <em>z</em>. In this way, <em>R</em> can be embedded in 

<math display="inline" id="Complex_logarithm:20">
<semantics>
<mrow>
<mrow>
<mi>ℂ</mi>
<mo>×</mo>
<mi>ℝ</mi>
</mrow>
<mo>≈</mo>
<msup>
<mi>ℝ</mi>
<mn>3</mn>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<approx></approx>
<apply>
<times></times>
<ci>ℂ</ci>
<ci>ℝ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℝ</ci>
<cn type="integer">3</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}\times\mathbb{R}\approx\mathbb{R}^{3}
  </annotation>
</semantics>
</math>

.</p>
<h3 id="the-logarithm-function-on-the-riemann-surface">The logarithm function on the Riemann surface</h3>

<p>Because the domains of the branches were glued only along open sets where their values agreed, the branches glue to give a single well-defined function 

<math display="inline" id="Complex_logarithm:21">
<semantics>
<mrow>
<msub>
<mi>log</mi>
<mi>R</mi>
</msub>
<mo>:</mo>
<mrow>
<mi>R</mi>
<mo>→</mo>
<mi>ℂ</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<log></log>
<ci>R</ci>
</apply>
<apply>
<ci>normal-→</ci>
<ci>R</ci>
<ci>ℂ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \log_{R}\colon R\to\mathbb{C}
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> It maps each point (<em>z</em>,<em>θ</em>) on <em>R</em> to ln |<em>z</em>| + <em>iθ</em>. This process of extending the original branch Log by gluing compatible <a href="holomorphic_function" title="wikilink">holomorphic functions</a> is known as <a href="analytic_continuation" title="wikilink">analytic continuation</a>.</p>

<p>There is a "projection map" from <em>R</em> down to 

<math display="inline" id="Complex_logarithm:22">
<semantics>
<msup>
<mi>ℂ</mi>
<mo>×</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℂ</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}^{\times}
  </annotation>
</semantics>
</math>

 that "flattens" the spiral, sending (<em>z</em>,<em>θ</em>) to <em>z</em>. For any 

<math display="inline" id="Complex_logarithm:23">
<semantics>
<mrow>
<mi>z</mi>
<mo>∈</mo>
<msup>
<mi>ℂ</mi>
<mo>×</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>z</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℂ</ci>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z\in\mathbb{C}^{\times}
  </annotation>
</semantics>
</math>

, if one takes all the points (<em>z</em>,<em>θ</em>) of <em>R</em> lying "directly above" <em>z</em> and evaluates log<sub><em>R</em></sub> at all these points, one gets all the logarithms of <em>z</em>.</p>
<h3 id="gluing-all-branches-of-logz">Gluing all branches of log <em>z</em></h3>

<p>Instead of gluing only the branches chosen above, one can start with <em>all</em> branches of log <em>z</em>, and simultaneously glue <em>every</em> pair of branches 

<math display="inline" id="Complex_logarithm:24">
<semantics>
<mrow>
<msub>
<mi>L</mi>
<mn>1</mn>
</msub>
<mo>:</mo>
<mrow>
<msub>
<mi>U</mi>
<mn>1</mn>
</msub>
<mo>→</mo>
<mi>ℂ</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>U</ci>
<cn type="integer">1</cn>
</apply>
<ci>ℂ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L_{1}\colon U_{1}\to\mathbb{C}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Complex_logarithm:25">
<semantics>
<mrow>
<msub>
<mi>L</mi>
<mn>2</mn>
</msub>
<mo>:</mo>
<mrow>
<msub>
<mi>U</mi>
<mn>2</mn>
</msub>
<mo>→</mo>
<mi>ℂ</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>U</ci>
<cn type="integer">2</cn>
</apply>
<ci>ℂ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L_{2}\colon U_{2}\to\mathbb{C}
  </annotation>
</semantics>
</math>

 along the largest open subset of 

<math display="inline" id="Complex_logarithm:26">
<semantics>
<mrow>
<msub>
<mi>U</mi>
<mn>1</mn>
</msub>
<mo>∩</mo>
<msub>
<mi>U</mi>
<mn>2</mn>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<intersect></intersect>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>U</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>U</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   U_{1}\cap U_{2}
  </annotation>
</semantics>
</math>

 on which <em>L</em><sub>1</sub> and <em>L</em><sub>2</sub> agree. This yields the same Riemann surface <em>R</em> and function log<sub><em>R</em></sub> as before. This approach, although slightly harder to visualize, is more natural in that it does not require selecting any particular branches.</p>

<p>If <em>U</em>′ is an open subset of <em>R</em> projecting bijectively to its image <em>U</em> in 

<math display="inline" id="Complex_logarithm:27">
<semantics>
<msup>
<mi>ℂ</mi>
<mo>×</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℂ</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}^{\times}
  </annotation>
</semantics>
</math>

, then the restriction of log<sub><em>R</em></sub> to <em>U</em>′ corresponds to a branch of log <em>z</em> defined on <em>U</em>. Every branch of log <em>z</em> arises in this way.</p>
<h3 id="the-riemann-surface-as-a-universal-cover">The Riemann surface as a universal cover</h3>

<p>The projection map 

<math display="inline" id="Complex_logarithm:28">
<semantics>
<mrow>
<mi>R</mi>
<mo>→</mo>
<msup>
<mi>ℂ</mi>
<mo>×</mo>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>R</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℂ</ci>
<times></times>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R\to\mathbb{C}^{\times}
  </annotation>
</semantics>
</math>

 realizes <em>R</em> as a <a href="covering_space" title="wikilink">covering space</a> of 

<math display="inline" id="Complex_logarithm:29">
<semantics>
<msup>
<mi>ℂ</mi>
<mo>×</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℂ</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}^{\times}
  </annotation>
</semantics>
</math>

. In fact, it is a <a href="Galois_covering" title="wikilink">Galois covering</a> with <a href="deck_transformation" title="wikilink">deck transformation</a> group isomorphic to 

<math display="inline" id="Complex_logarithm:30">
<semantics>
<mi>ℤ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℤ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{Z}
  </annotation>
</semantics>
</math>

, generated by the <a class="uri" href="homeomorphism" title="wikilink">homeomorphism</a> sending (<em>z</em>,<em>θ</em>) to (<em>z</em>,<em>θ</em>+2<em>π</em>).</p>

<p>As a <a href="complex_manifold" title="wikilink">complex manifold</a>, <em>R</em> is <a class="uri" href="biholomorphic" title="wikilink">biholomorphic</a> with 

<math display="inline" id="Complex_logarithm:31">
<semantics>
<mi>ℂ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℂ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}
  </annotation>
</semantics>
</math>

 via log<sub><em>R</em></sub>. (The inverse map sends <em>z</em> to (<em>e</em><sup><em>z</em></sup>,Im <em>z</em>).) This shows that <em>R</em> is <a href="simply_connected" title="wikilink">simply connected</a>, so <em>R</em> is the <a href="universal_cover" title="wikilink">universal cover</a> of 

<math display="inline" id="Complex_logarithm:32">
<semantics>
<msup>
<mi>ℂ</mi>
<mo>×</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ℂ</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}^{\times}
  </annotation>
</semantics>
</math>

.</p>
<h2 id="applications">Applications</h2>
<ul>
<li>The complex logarithm is needed to define <a href="exponentiation#Powers_of_complex_numbers" title="wikilink">exponentation</a> in which the base is a complex number. Namely, if <em>a</em> and <em>b</em> are complex numbers with <em>a</em> ≠ 0, one can use the principal value to define <em>a</em><sup><em>b</em></sup> = <em>e</em><sup><em>b</em> Log <em>a</em></sup>. One can also replace Log <em>a</em> by other logarithms of <em>a</em> to obtain other values of <em>a</em><sup><em>b</em></sup>.</li>
<li>Since the mapping <em>w</em> = Log <em>z</em> transforms circles centered at 0 into vertical straight line segments, it is useful in engineering applications involving an <a href="annulus_(mathematics)" title="wikilink">annulus</a>.</li>
</ul>
<h2 id="generalizations">Generalizations</h2>
<h3 id="logarithms-to-other-bases">Logarithms to other bases</h3>

<p>Just as for real numbers, one can define for complex numbers <em>a</em> and <em>b</em></p>

<p>
<math display="block" id="Complex_logarithm:33">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>log</mi>
<mi>a</mi>
</msub>
<mi>b</mi>
</mrow>
<mo>=</mo>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mi>log</mi>
<mi>b</mi>
</mrow>
<mrow>
<mi>log</mi>
<mi>a</mi>
</mrow>
</mfrac>
</mpadded>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<log></log>
<ci>a</ci>
</apply>
<ci>b</ci>
</apply>
<apply>
<divide></divide>
<apply>
<log></log>
<ci>b</ci>
</apply>
<apply>
<log></log>
<ci>a</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \log_{a}b=\frac{\log b}{\log a}\,,
  </annotation>
</semantics>
</math>

 the only caveat being that its value depends on the choice of a branch of log defined at <em>a</em> and <em>b</em> (with log <em>a</em> ≠ 0). For example, using the principal value gives</p>

<p>
<math display="block" id="Complex_logarithm:34">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>log</mi>
<mi>i</mi>
</msub>
<mi>e</mi>
</mrow>
<mo>=</mo>
<mfrac>
<mrow>
<mi>ln</mi>
<mi>e</mi>
</mrow>
<mrow>
<mi>ln</mi>
<mi>i</mi>
</mrow>
</mfrac>
<mo>=</mo>
<mfrac>
<mn>1</mn>
<mrow>
<mrow>
<mi>π</mi>
<mi>i</mi>
</mrow>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mfrac>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mfrac>
<mrow>
<mn>2</mn>
<mi>i</mi>
</mrow>
<mi>π</mi>
</mfrac>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<log></log>
<ci>i</ci>
</apply>
<ci>e</ci>
</apply>
<apply>
<divide></divide>
<apply>
<ln></ln>
<ci>e</ci>
</apply>
<apply>
<ln></ln>
<ci>i</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>π</ci>
<ci>i</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<minus></minus>
<apply>
<divide></divide>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>i</ci>
</apply>
<ci>π</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \log_{i}e=\frac{\ln e}{\ln i}=\frac{1}{\pi i/2}=-\frac{2i}{\pi}.
  </annotation>
</semantics>
</math>
</p>
<h3 id="logarithms-of-holomorphic-functions">Logarithms of holomorphic functions</h3>

<p>If <em>f</em> is a <a href="holomorphic_function" title="wikilink">holomorphic function</a> on a connected open subset <em>U</em> of 

<math display="inline" id="Complex_logarithm:35">
<semantics>
<mi>ℂ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℂ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}
  </annotation>
</semantics>
</math>

, then a <strong>branch of log <em>f</em></strong> on <em>U</em> is a continuous function <em>g</em> on <em>U</em> such that <em>e</em><sup><em>g</em>(<em>z</em>)</sup> = <em>f</em>(<em>z</em>) for all <em>z</em> in <em>U</em>. Such a function <em>g</em> is necessarily <a href="Holomorphic_function" title="wikilink">holomorphic</a> with <em>g′</em>(<em>z</em>) = <em>f′</em>(<em>z</em>)/<em>f</em>(<em>z</em>) for all <em>z</em> in <em>U</em>.</p>

<p>If <em>U</em> is a <a href="simply_connected" title="wikilink">simply connected</a> open subset of 

<math display="inline" id="Complex_logarithm:36">
<semantics>
<mi>ℂ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ℂ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathbb{C}
  </annotation>
</semantics>
</math>

, and <em>f</em> is a nowhere-vanishing holomorphic function on <em>U</em>, then a branch of log <em>f</em> defined on <em>U</em> can be constructed by choosing a starting point <em>a</em> in <em>U</em>, choosing a logarithm <em>b</em> of <em>f</em>(<em>a</em>), and defining</p>

<p>
<math display="block" id="Complex_logarithm:37">
<semantics>
<mrow>
<mrow>
<mi>g</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>:=</mo>
<mrow>
<mi>b</mi>
<mo>+</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mi>a</mi>
<mi>z</mi>
</msubsup>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<msup>
<mi>f</mi>
<mo>′</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>w</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>w</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mpadded>
<mi>d</mi>
<mi>w</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">assign</csymbol>
<apply>
<times></times>
<ci>g</ci>
<ci>z</ci>
</apply>
<apply>
<plus></plus>
<ci>b</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<ci>a</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<ci>normal-′</ci>
</apply>
<ci>w</ci>
</apply>
<apply>
<times></times>
<ci>f</ci>
<ci>w</ci>
</apply>
</apply>
<ci>d</ci>
<ci>w</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   g(z):=b+\int_{a}^{z}\frac{f^{\prime}(w)}{f(w)}\,dw
  </annotation>
</semantics>
</math>
</p>

<p>for each <em>z</em> in <em>U</em>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Logarithm" title="wikilink">Logarithm</a></li>
<li><a href="Discrete_logarithm" title="wikilink">Discrete logarithm</a></li>
<li><a href="Exponential_function" title="wikilink">Exponential function</a></li>
<li><a href="Arg_(mathematics)" title="wikilink">Arg (mathematics)</a></li>
<li><a href="Inverse_trigonometric_functions" title="wikilink">Inverse trigonometric functions</a></li>
<li><a class="uri" href="Exponentiation" title="wikilink">Exponentiation</a></li>
<li><a href="Branch_cut" title="wikilink">Branch cut</a></li>
<li><a href="Conformal_map" title="wikilink">Conformal map</a></li>
<li><a href="Analytic_continuation" title="wikilink">Analytic continuation</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="John_B._Conway" title="wikilink">John B. Conway</a>, <em>Functions of One Complex Variable</em>, 2nd edition, Springer, 1978.</li>
<li><a href="Serge_Lang" title="wikilink">Serge Lang</a>, <em>Complex Analysis</em>, 3rd edition, Springer-Verlag, 1993.</li>
<li>Gino Moretti, <em>Functions of a Complex Variable</em>, Prentice-Hall, Inc., 1964.</li>
<li>Donald Sarason, <em>[<a class="uri" href="http://books.google.com/books?id=FUWPyHM-XK0C&amp;pg">http://books.google.com/books?id=FUWPyHM-XK0C&amp;pg;</a>;=PA40&amp;dq;=logarithm+intitle:Complex+intitle:function+intitle:theory+inauthor:sarason&amp;lr;=&amp;as;_brr=0&amp;ei;=df4UScGONJ_EtAPZ5-XjCw Complex Function Theory]</em>, 2nd edition, American Mathematical Society, 2007.</li>
<li><a href="E._T._Whittaker" title="wikilink">E. T. Whittaker</a> and <a href="G._N._Watson" title="wikilink">G. N. Watson</a>, <em>A Course in Modern Analysis</em>, fourth edition, Cambridge University Press, 1927.</li>
</ul>

<p>"</p>

<p><a href="Category:Analytic_functions" title="wikilink">Category:Analytic functions</a> <a class="uri" href="Category:Logarithms" title="wikilink">Category:Logarithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Sarason, Section IV.9.<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4">Conway, p. 39.<a href="#fnref4">↩</a></li>
<li id="fn5">Another interpretation of this is that the "inverse" of the complex exponential function is a <a href="multivalued_function" title="wikilink">multivalued function</a> taking each nonzero complex number <em>z</em> to the <em>set</em> of all logarithms of <em>z</em>.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10">Lang, p. 121.<a href="#fnref10">↩</a></li>
<li id="fn11">The notations <em>R</em> and log<sub><em>R</em></sub> are not universally used.<a href="#fnref11">↩</a></li>
<li id="fn12"></li>
</ol>
</section>
</body>
</html>
