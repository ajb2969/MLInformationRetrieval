<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1591">Restricted Boltzmann machine</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Restricted Boltzmann machine</h1>
<hr/>

<p> A <strong>restricted Boltzmann machine</strong> (<strong>RBM</strong>) is a <a href="generative_model" title="wikilink">generative</a> <a href="stochastic_neural_network" title="wikilink">stochastic</a> <a href="artificial_neural_network" title="wikilink">artificial neural network</a> that can learn a probability distribution over its set of inputs. RBMs were initially invented under the name <strong>Harmonium</strong> by <a href="Paul_Smolensky" title="wikilink">Paul Smolensky</a> in 1986,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> but only rose to prominence after <a href="Geoffrey_Hinton" title="wikilink">Geoffrey Hinton</a> and collaborators invented fast learning algorithms for them in the mid-2000s. RBMs have found applications in <a href="dimensionality_reduction" title="wikilink">dimensionality reduction</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a href="statistical_classification" title="wikilink">classification</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a href="collaborative_filtering" title="wikilink">collaborative filtering</a>,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a href="feature_learning" title="wikilink">feature learning</a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and <a href="topic_model" title="wikilink">topic modelling</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> They can be trained in either <a href="supervised_learning" title="wikilink">supervised</a> or <a href="unsupervised_learning" title="wikilink">unsupervised</a> ways, depending on the task.</p>

<p>As their name implies, RBMs are a variant of <a href="Boltzmann_machine" title="wikilink">Boltzmann machines</a>, with the restriction that their neurons must form a <a href="bipartite_graph" title="wikilink">bipartite graph</a>: a pair of nodes from each of the two groups of units, commonly referred to as the "visible" and "hidden" units respectively, may have a symmetric connection between them, and there are no connections between nodes within a group. By contrast, "unrestricted" Boltzmann machines may have connections between hidden units. This restriction allows for more efficient training algorithms than are available for the general class of Boltzmann machines, in particular the <a href="Gradient_descent" title="wikilink">gradient-based</a> <strong>contrastive divergence</strong> algorithm.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Restricted Boltzmann machines can also be used in <a href="deep_learning" title="wikilink">deep learning</a> networks. In particular, <a href="deep_belief_network" title="wikilink">deep belief networks</a> can be formed by "stacking" RBMs and optionally fine-tuning the resulting deep network with <a href="gradient_descent" title="wikilink">gradient descent</a> and <a class="uri" href="backpropagation" title="wikilink">backpropagation</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="structure">Structure</h2>

<p>The standard type of RBM has binary-valued (<a href="Boolean_algebra" title="wikilink">Boolean</a>/<a href="Bernoulli_distribution" title="wikilink">Bernoulli</a>) hidden and visible units, and consists of a <a href="Matrix_(mathematics)" title="wikilink">matrix</a> of weights 

<math display="inline" id="Restricted_Boltzmann_machine:0">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W=(w_{i,j})
  </annotation>
 </semantics>
</math>

 (size <em>m</em>×<em>n</em>) associated with the connection between hidden unit 

<math display="inline" id="Restricted_Boltzmann_machine:1">
 <semantics>
  <msub>
   <mi>h</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{j}
  </annotation>
 </semantics>
</math>

 and visible unit 

<math display="inline" id="Restricted_Boltzmann_machine:2">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

, as well as bias weights (offsets) 

<math display="inline" id="Restricted_Boltzmann_machine:3">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

 for the visible units and 

<math display="inline" id="Restricted_Boltzmann_machine:4">
 <semantics>
  <msub>
   <mi>b</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{j}
  </annotation>
 </semantics>
</math>

 for the hidden units. Given these, the <em>energy</em> of a configuration (pair of boolean vectors) 

<math display="inline" id="Restricted_Boltzmann_machine:5">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>v</mi>
   <mo>,</mo>
   <mi>h</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>v</ci>
    <ci>h</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v,h)
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>

<math display="block" id="Restricted_Boltzmann_machine:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>h</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>i</mi>
      </munder>
      <mrow>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>v</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mrow>
      <msub>
       <mi>b</mi>
       <mi>j</mi>
      </msub>
      <msub>
       <mi>h</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>j</mi>
      </munder>
      <mrow>
       <msub>
        <mi>v</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>w</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
        </mrow>
       </msub>
       <msub>
        <mi>h</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <interval closure="open">
      <ci>v</ci>
      <ci>h</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <list>
          <ci>i</ci>
          <ci>j</ci>
         </list>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(v,h)=-\sum_{i}a_{i}v_{i}-\sum_{j}b_{j}h_{j}-\sum_{i}\sum_{j}v_{i}w_{i,j}h_{j}
  </annotation>
 </semantics>
</math>

</p>

<p>or, in matrix notation,</p>

<p>

<math display="block" id="Restricted_Boltzmann_machine:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>h</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mi mathvariant="normal">T</mi>
      </msup>
      <mi>v</mi>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>b</mi>
      <mi mathvariant="normal">T</mi>
     </msup>
     <mi>h</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>v</mi>
      <mi mathvariant="normal">T</mi>
     </msup>
     <mi>W</mi>
     <mi>h</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <interval closure="open">
      <ci>v</ci>
      <ci>h</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>normal-T</ci>
       </apply>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>normal-T</ci>
      </apply>
      <ci>h</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>v</ci>
       <ci>normal-T</ci>
      </apply>
      <ci>W</ci>
      <ci>h</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(v,h)=-a^{\mathrm{T}}v-b^{\mathrm{T}}h-v^{\mathrm{T}}Wh
  </annotation>
 </semantics>
</math>

</p>

<p>This energy function is analogous to that of a <a href="Hopfield_network" title="wikilink">Hopfield network</a>. As in general Boltzmann machines, probability distributions over hidden and/or visible vectors are defined in terms of the energy function:<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>

<math display="block" id="Restricted_Boltzmann_machine:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>h</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>Z</mi>
    </mfrac>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo>,</mo>
        <mi>h</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <interval closure="open">
      <ci>v</ci>
      <ci>h</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>Z</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>E</ci>
        <interval closure="open">
         <ci>v</ci>
         <ci>h</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(v,h)=\frac{1}{Z}e^{-E(v,h)}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Restricted_Boltzmann_machine:9">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 is a <a href="Partition_function_(mathematics)" title="wikilink">partition function</a> defined as the sum of 

<math display="inline" id="Restricted_Boltzmann_machine:10">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>h</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>E</ci>
      <interval closure="open">
       <ci>v</ci>
       <ci>h</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{-E(v,h)}
  </annotation>
 </semantics>
</math>

 over all possible configurations (in other words, just a <a href="normalizing_constant" title="wikilink">normalizing constant</a> to ensure the probability distribution sums to 1). Similarly, the (<a href="Marginal_distribution" title="wikilink">marginal</a>) probability of a visible (input) vector of booleans is the sum over all possible hidden layer configurations:<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>

<math display="block" id="Restricted_Boltzmann_machine:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>Z</mi>
    </mfrac>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>h</mi>
     </munder>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>E</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>v</mi>
         <mo>,</mo>
         <mi>h</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>Z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>h</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>E</ci>
         <interval closure="open">
          <ci>v</ci>
          <ci>h</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(v)=\frac{1}{Z}\sum_{h}e^{-E(v,h)}
  </annotation>
 </semantics>
</math>

</p>

<p>Since the RBM has the shape of a bipartite graph, with no intra-layer connections, the hidden unit activations are mutually <a href="Conditional_independence" title="wikilink">independent</a> given the visible unit activations and conversely, the visible unit activations are mutually independent given the hidden unit activations.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> That is, for 

<math display="inline" id="Restricted_Boltzmann_machine:12">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 visible units and 

<math display="inline" id="Restricted_Boltzmann_machine:13">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 hidden units, the <a href="conditional_probability" title="wikilink">conditional probability</a> of a configuration of the visible units 

<math display="inline" id="Restricted_Boltzmann_machine:14">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, given a configuration of the hidden units 

<math display="inline" id="Restricted_Boltzmann_machine:15">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, is</p>

<p>

<math display="block" id="Restricted_Boltzmann_machine:16">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">|</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>m</mi>
   </munderover>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>m</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(v|h)=\prod_{i=1}^{m}P(v_{i}|h)
  </annotation>
 </semantics>
</math>

.</p>

<p>Conversely, the conditional probability of 

<math display="inline" id="Restricted_Boltzmann_machine:17">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 given 

<math display="inline" id="Restricted_Boltzmann_machine:18">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Restricted_Boltzmann_machine:19">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>h</mi>
    <mo stretchy="false">|</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </munderover>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>h</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(h|v)=\prod_{j=1}^{n}P(h_{j}|v)
  </annotation>
 </semantics>
</math>

.</p>

<p>The individual activation probabilities are given by</p>

<p>

<math display="block" id="Restricted_Boltzmann_machine:20">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>h</mi>
     <mi>j</mi>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">|</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>σ</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>b</mi>
     <mi>j</mi>
    </msub>
    <mo>+</mo>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </munderover>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo rspace="4.2pt">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>j</ci>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">σ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>j</ci>
     </apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(h_{j}=1|v)=\sigma\left(b_{j}+\sum_{i=1}^{m}w_{i,j}v_{i}\right)\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Restricted_Boltzmann_machine:21">
 <semantics>
  <mrow>
   <mpadded lspace="1.7pt" width="+1.7pt">
    <mi>P</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">|</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>σ</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <msub>
     <mi>h</mi>
     <mi>j</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">σ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,P(v_{i}=1|h)=\sigma\left(a_{i}+\sum_{j=1}^{n}w_{i,j}h_{j}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Restricted_Boltzmann_machine:22">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 denotes the <a href="Logistic_function" title="wikilink">logistic sigmoid</a>.</p>

<p>The visible units of RBM can be multinomial, although the hidden units are Bernoulli. In this case, the logistic function for visible units is replaced by the <a href="Softmax_function" title="wikilink">Softmax function</a></p>

<p>

<math display="block" id="Restricted_Boltzmann_machine:23">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>v</mi>
     <mi>i</mi>
     <mi>k</mi>
    </msubsup>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">|</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msubsup>
        <mi>a</mi>
        <mi>i</mi>
        <mi>k</mi>
       </msubsup>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi mathvariant="normal">Σ</mi>
         <mi>j</mi>
        </msub>
        <msubsup>
         <mi>W</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
         <mi>k</mi>
        </msubsup>
        <msub>
         <mi>h</mi>
         <mi>j</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mi mathvariant="normal">Σ</mi>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msubsup>
         <mi>a</mi>
         <mi>i</mi>
         <mi>k</mi>
        </msubsup>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi mathvariant="normal">Σ</mi>
          <mi>j</mi>
         </msub>
         <msubsup>
          <mi>W</mi>
          <mrow>
           <mi>i</mi>
           <mi>j</mi>
          </mrow>
          <mi>k</mi>
         </msubsup>
         <msub>
          <mi>h</mi>
          <mi>j</mi>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <exp></exp>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Σ</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>W</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Σ</ci>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <exp></exp>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>i</ci>
         </apply>
         <ci>k</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-Σ</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>W</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>h</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(v_{i}^{k}=1|h)=\frac{\exp(a_{i}^{k}+\Sigma_{j}W_{ij}^{k}h_{j})}{\Sigma_{k=1}%
^{K}\exp(a_{i}^{k}+\Sigma_{j}W_{ij}^{k}h_{j})}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>K</em> is the number of discrete values that the visible values have. They are applied in Topic Modeling,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> and <a href="Recommender_system" title="wikilink">RecSys</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="relation-to-other-models">Relation to other models</h3>

<p>Restricted Boltzmann machines are a special case of Boltzmann machines and <a href="Markov_random_field" title="wikilink">Markov random fields</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Their <a href="graphical_model" title="wikilink">graphical model</a> corresponds to that of <a href="factor_analysis" title="wikilink">factor analysis</a>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="training-algorithm">Training algorithm</h2>

<p>Restricted Boltzmann machines are trained to maximize the product of probabilities assigned to some training set 

<math display="inline" id="Restricted_Boltzmann_machine:24">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 (a matrix, each row of which is treated as a visible vector 

<math display="inline" id="Restricted_Boltzmann_machine:25">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

),</p>

<p>

<math display="block" id="Restricted_Boltzmann_machine:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>arg</mi>
    <munder>
     <mi>max</mi>
     <mi>W</mi>
    </munder>
   </mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>v</mi>
      <mo>∈</mo>
      <mi>V</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <arg></arg>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>W</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <in></in>
       <ci>v</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \arg\max_{W}\prod_{v\in V}P(v)
  </annotation>
 </semantics>
</math>

</p>

<p>or equivalently, to maximize the <a href="Expected_value" title="wikilink">expected</a> <a href="log_probability" title="wikilink">log probability</a> of 

<math display="inline" id="Restricted_Boltzmann_machine:27">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

:<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>

<math display="block" id="Restricted_Boltzmann_machine:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>arg</mi>
    <mrow>
     <munder>
      <mi>max</mi>
      <mi>W</mi>
     </munder>
     <mi>𝔼</mi>
    </mrow>
   </mrow>
   <mrow>
    <mo>[</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>v</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
     </munder>
     <mrow>
      <mrow>
       <mi>log</mi>
       <mi>P</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <arg></arg>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <ci>W</ci>
      </apply>
      <ci>𝔼</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>v</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <log></log>
        <ci>P</ci>
       </apply>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \arg\max_{W}\mathbb{E}\left[\sum_{v\in V}\log P(v)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>The algorithm most often used to train RBMs, that is, to optimize the weight vector 

<math display="inline" id="Restricted_Boltzmann_machine:29">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

, is the contrastive divergence (CD) algorithm due to <a href="Geoffrey_Hinton" title="wikilink">Hinton</a>, originally developed to train PoE (<a href="product_of_experts" title="wikilink">product of experts</a>) models.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> <a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> The algorithm performs <a href="Gibbs_sampling" title="wikilink">Gibbs sampling</a> and is used inside a <a href="gradient_descent" title="wikilink">gradient descent</a> procedure (similar to the way backpropagation is used inside such a procedure when training feedforward neural nets) to compute weight update.</p>

<p>The basic, single-step contrastive divergence (CD-1) procedure for a single sample can be summarized as follows:</p>
<ol>
<li>Take a training sample 

<math display="inline" id="Restricted_Boltzmann_machine:30">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, compute the probabilities of the hidden units and sample a hidden activation vector 

<math display="inline" id="Restricted_Boltzmann_machine:31">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 from this probability distribution.</li>
<li>Compute the <a href="outer_product" title="wikilink">outer product</a> of 

<math display="inline" id="Restricted_Boltzmann_machine:32">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Restricted_Boltzmann_machine:33">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 and call this the <em>positive gradient</em>.</li>
<li>From 

<math display="inline" id="Restricted_Boltzmann_machine:34">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, sample a reconstruction 

<math display="inline" id="Restricted_Boltzmann_machine:35">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 of the visible units, then resample the hidden activations 

<math display="inline" id="Restricted_Boltzmann_machine:36">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 from this. (Gibbs sampling step)</li>
<li>Compute the <a href="outer_product" title="wikilink">outer product</a> of 

<math display="inline" id="Restricted_Boltzmann_machine:37">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Restricted_Boltzmann_machine:38">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 and call this the <em>negative gradient</em>.</li>
<li>Let the weight update to 

<math display="inline" id="Restricted_Boltzmann_machine:39">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <list>
     <ci>i</ci>
     <ci>j</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i,j}
  </annotation>
 </semantics>
</math>

 be the positive gradient minus the negative gradient, times some learning rate

<math display="block" id="Restricted_Boltzmann_machine:40">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ϵ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>v</mi>
       <msup>
        <mi>h</mi>
        <mi>𝖳</mi>
       </msup>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msup>
        <mi>v</mi>
        <mo>′</mo>
       </msup>
       <msup>
        <mi>h</mi>
        <mo>′</mo>
       </msup>
       <mi>T</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>ϵ</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <ci>𝖳</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>v</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta w_{i,j}=\epsilon(vh^{\mathsf{T}}-v^{\prime}h^{\prime\mathsf{}}{T})
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>The update rule for the biases 

<math display="inline" id="Restricted_Boltzmann_machine:41">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Restricted_Boltzmann_machine:42">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is defined analogously.</p>

<p>A Practical Guide to Training RBMs written by Hinton can be found in his homepage.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>A restricted/layered Boltzmann machine (RBM) has either bit or scalar node values, an array for each layer, and between those are scalar values potentially for every pair of nodes one from each layer and an adjacent layer. It is run and trained using "weighted coin flips" of a chance calculated at each individual node. Those chances are the <a href="Logistic_function" title="wikilink">logistic sigmoid</a> of the sum of scalar weights of whichever pairs of nodes are on at the time, divided by temperature which decreases in each round of <a href="Simulated_annealing" title="wikilink">Simulated annealing</a> as potentially all the data is trained in again. If either node in a pair is off, that weight is not counted. To run it, you go up and down the layers, updating the chances and weighted coin flips, until it converges to the coins in lowest layer (visible nodes) staying mostly a certain way. To train it, it is the same shape as running it except you observe the weights of the pairs that are on, the first time up you add the learning rate between those pairs, then go back down and up again and that time subtract the learning rate. As <a href="Geoffrey_Hinton" title="wikilink">Geoffrey Hinton</a> explained it, the first time up is to learn the data, and the second time up is to unlearn whatever its earlier reaction was to the data.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Autoencoder" title="wikilink">Autoencoder</a></li>
<li><a href="Deep_learning" title="wikilink">Deep learning</a></li>
<li><a href="Helmholtz_machine" title="wikilink">Helmholtz machine</a></li>
<li><a href="Hopfield_network" title="wikilink">Hopfield network</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://blog.echen.me/2011/07/18/introduction-to-restricted-boltzmann-machines/">Introduction to Restricted Boltzmann Machines</a>. Edwin Chen's blog, July 18, 2011.</li>
<li><a href="http://deeplearning4j.org/restrictedboltzmannmachine.html">A Beginner's Guide to Restricted Boltzmann Machines</a>. Deeplearning4j Documentation</li>
<li><a href="http://deeplearning4j.org/understandingRBMs.html">Understanding RBMs</a>. Deeplearning4j Documentation, August 4, 2015.</li>
</ul>

<p>"</p>

<p><a href="Category:Artificial_neural_networks" title="wikilink">Category:Artificial neural networks</a> <a href="Category:Stochastic_models" title="wikilink">Category:Stochastic models</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">Ruslan Salakhutdinov and Geoffrey Hinton (2010). <a href="http://books.nips.cc/papers/files/nips22/NIPS2009_0817.pdf">Replicated softmax: an undirected topic model</a>. <em><a href="Neural_Information_Processing_Systems" title="wikilink">Neural Information Processing Systems</a></em> <strong>23</strong>.<a href="#fnref6">↩</a></li>
<li id="fn7">Miguel Á. Carreira-Perpiñán and Geoffrey Hinton (2005). On contrastive divergence learning. <em>Artificial Intelligence and Statistics</em>.<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9">Geoffrey Hinton (2010). <em><a href="http://www.cs.toronto.edu/~hinton/absps/guideTR.pdf">A Practical Guide to Training Restricted Boltzmann Machines</a></em>. UTML TR 2010–003, University of Toronto.<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">Asja Fischer and Christian Igel. <a href="http://image.diku.dk/igel/paper/TRBMAI.pdf">Training Restricted Boltzmann Machines: An Introduction</a>. Pattern Recognition 47, pp. 25-39, 2014<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19">Geoffrey Hinton (1999). <a href="http://www.gatsby.ucl.ac.uk/publications/papers/06-1999.pdf">Products of Experts</a>. <em>ICANN 1999</em>.<a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"></li>
</ol>
</section>
</body>
</html>
