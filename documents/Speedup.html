<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="604">Speedup</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Speedup</h1>
<hr/>

<p>In the field of <a href="computer_architecture" title="wikilink">computer architecture</a>, <strong>speedup</strong> is a metric for relative performance improvement when executing a task. The notion of speedup was established by <a href="Amdahl's_law" title="wikilink">Amdahl's law</a>, which was particularly focused in the context of parallel processing. However, speedup can be used more generally to show the effect of any performance enhancement.</p>
<h2 id="definition">Definition</h2>

<p>Speedup can be defined for two different types of values: <a class="uri" href="throughput" title="wikilink">throughput</a> and <a href="Latency_(engineering)" title="wikilink">latency</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="uri" href="Throughput" title="wikilink">Throughput</a> will be given in the general form of completions per unit of time. In <a href="computer_architecture" title="wikilink">computer architecture</a> the common throughput metric is <a href="instructions_per_cycle" title="wikilink">instructions per cycle</a>, denoted <strong>IPC</strong>. The reciprocal of this is <a href="cycles_per_instruction" title="wikilink">cycles per instruction</a> or <strong>CPI</strong>; this is a <a href="Latency_(engineering)" title="wikilink">latency</a> quantity because it is the length of time between successive completions or occurrences. Speedup is defined differently for each type so that it is a consistent metric. One of the most common measurements in <a href="computer_architecture" title="wikilink">computer architecture</a> — the execution time of a program — can be seen as a <a href="Latency_(engineering)" title="wikilink">latency</a> quantity because it is in <em>seconds per program</em>.</p>

<p>For latency values, speedup is defined by the following formula:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>

<math display="block" id="Speedup:0">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>o</mi>
      <mi>l</mi>
      <mi>d</mi>
     </mrow>
    </msub>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>n</mi>
      <mi>e</mi>
      <mi>w</mi>
     </mrow>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>l</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>e</ci>
       <ci>w</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\frac{T_{old}}{T_{new}}
  </annotation>
 </semantics>
</math>

 <u>where:</u></p>
<ul>
<li>

<math display="inline" id="Speedup:1">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is the resultant speedup.</li>
<li>

<math display="inline" id="Speedup:2">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>o</mi>
    <mi>l</mi>
    <mi>d</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>l</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{old}
  </annotation>
 </semantics>
</math>

 is the old execution time, i.e., without the improvement.</li>
<li>

<math display="inline" id="Speedup:3">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>n</mi>
    <mi>e</mi>
    <mi>w</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>e</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{new}
  </annotation>
 </semantics>
</math>

 is the new execution time, i.e., with the improvement.</li>
</ul>

<p>For throughput values, which are also called performance quantities, the enhanced performance will be in the numerator and the original performance will be in the denominator.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Notice that speedup is a unit-less quantity (the units cancel). This is because it is a relative quantity, i.e., we are comparing two specific instances of execution. Speedup is only useful when the experimental data is run on the same system, just with the slight tweak for which the speedup test is being run.</p>

<p>

<math display="block" id="Speedup:4">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>P</mi>
     <mrow>
      <mi>n</mi>
      <mi>e</mi>
      <mi>w</mi>
     </mrow>
    </msub>
    <msub>
     <mi>P</mi>
     <mrow>
      <mi>o</mi>
      <mi>l</mi>
      <mi>d</mi>
     </mrow>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>e</ci>
       <ci>w</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>l</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\frac{P_{new}}{P_{old}}
  </annotation>
 </semantics>
</math>

 <u>where:</u></p>
<ul>
<li>

<math display="inline" id="Speedup:5">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is the resultant speedup.</li>
<li>

<math display="inline" id="Speedup:6">
 <semantics>
  <msub>
   <mi>P</mi>
   <mrow>
    <mi>o</mi>
    <mi>l</mi>
    <mi>d</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>l</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{old}
  </annotation>
 </semantics>
</math>

 is the old performance, i.e., without the improvement.</li>
<li>

<math display="inline" id="Speedup:7">
 <semantics>
  <msub>
   <mi>P</mi>
   <mrow>
    <mi>n</mi>
    <mi>e</mi>
    <mi>w</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>e</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{new}
  </annotation>
 </semantics>
</math>

 is the new performance, i.e., with the improvement.</li>
</ul>
<h3 id="speedup-in-parallel-contexts">Speedup in Parallel Contexts</h3>

<p>When applied in the parallel case, speedup can be predicted from <a href="Amdahl's_Law" title="wikilink">Amdahl's Law</a>.</p>
<h2 id="examples">Examples</h2>
<h3 id="using-execution-times">Using Execution Times</h3>

<p>We are testing the effectiveness of a branch predictor on the execution of a program. First, we execute the program with the standard branch predictor on the processor, which yields an execution time of 2.25 seconds. Next, we execute the program with our modified (and hopefully improved) branch predictor on the same processor, which produces an execution time of 1.50 seconds. Using our speedup formula, we know</p>

<p>

<math display="block" id="Speedup:8">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>o</mi>
      <mi>l</mi>
      <mi>d</mi>
     </mrow>
    </msub>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>n</mi>
      <mi>e</mi>
      <mi>w</mi>
     </mrow>
    </msub>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mpadded width="+5pt">
      <mn>2.25</mn>
     </mpadded>
     <mi mathvariant="normal">s</mi>
    </mrow>
    <mrow>
     <mpadded width="+5pt">
      <mn>1.50</mn>
     </mpadded>
     <mi mathvariant="normal">s</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>1.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>S</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>l</ci>
        <ci>d</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>e</ci>
        <ci>w</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="float">2.25</cn>
       <ci>normal-s</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="float">1.50</cn>
       <ci>normal-s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">1.5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\frac{T_{old}}{T_{new}}=\frac{2.25\ \mathrm{s}}{1.50\ \mathrm{s}}=1.5
  </annotation>
 </semantics>
</math>

 Our new branch predictor has provided a 1.5x speedup over the original.</p>
<h3 id="using-cycles-per-instruction">Using Cycles per Instruction</h3>

<p>We have the same circumstance as above, but we are measuring Cycles per Instruction (CPI) instead. First, we execute the program with the standard branch predictor, which yields a CPI of 3. Next, we execute the program with our modified branch predictor, which yields a CPI of 2. Using our speedup formula, we know</p>

<p>

<math display="block" id="Speedup:9">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>C</mi>
     <mi>P</mi>
     <msub>
      <mi>I</mi>
      <mrow>
       <mi>o</mi>
       <mi>l</mi>
       <mi>d</mi>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <mi>C</mi>
     <mi>P</mi>
     <msub>
      <mi>I</mi>
      <mrow>
       <mi>n</mi>
       <mi>e</mi>
       <mi>w</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mpadded width="+5pt">
      <mn>3</mn>
     </mpadded>
     <mi>CPI</mi>
    </mrow>
    <mrow>
     <mpadded width="+5pt">
      <mn>2</mn>
     </mpadded>
     <mi>CPI</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>1.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>S</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>l</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>e</ci>
         <ci>w</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>CPI</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>CPI</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">1.5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\frac{CPI_{old}}{CPI_{new}}=\frac{3\ \mathrm{CPI}}{2\ \mathrm{CPI}}=1.5
  </annotation>
 </semantics>
</math>

</p>

<p>We can also perform a calculation using the performance metric Instructions per Cycle (IPC), which is the inverse of CPI. To calculate speedup using IPC (performance) instead of CPI (latency), we know</p>

<p>

<math display="block" id="Speedup:10">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>I</mi>
     <mi>P</mi>
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>n</mi>
       <mi>e</mi>
       <mi>w</mi>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <mi>I</mi>
     <mi>P</mi>
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>o</mi>
       <mi>l</mi>
       <mi>d</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mpadded width="+5pt">
      <mn>0.5</mn>
     </mpadded>
     <mi>IPC</mi>
    </mrow>
    <mrow>
     <mpadded width="+5pt">
      <mn>0.333</mn>
     </mpadded>
     <mi>IPC</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>1.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>S</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>I</ci>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>e</ci>
         <ci>w</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>I</ci>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>l</ci>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="float">0.5</cn>
       <ci>IPC</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="float">0.333</cn>
       <ci>IPC</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">1.5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\frac{IPC_{new}}{IPC_{old}}=\frac{0.5\ \mathrm{IPC}}{0.333\ \mathrm{IPC}}=1.5
  </annotation>
 </semantics>
</math>

</p>

<p>We achieve the same 1.5x speedup, though we measured different quantities.</p>
<h2 id="additional-details">Additional Details</h2>

<p>Let 

<math display="inline" id="Speedup:11">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{p}
  </annotation>
 </semantics>
</math>

 be the speedup for 

<math display="inline" id="Speedup:12">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 processors. <strong>Linear speedup</strong> or <strong>ideal speedup</strong> is obtained when 

<math display="inline" id="Speedup:13">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>S</mi>
    </mpadded>
    <mi>p</mi>
   </msub>
   <mo>=</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>p</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,S_{p}=p
  </annotation>
 </semantics>
</math>

. When running an algorithm with linear speedup, doubling the number of processors doubles the speed. As this is ideal, it is considered very good <a class="uri" href="scalability" title="wikilink">scalability</a>.</p>

<p><strong>Efficiency</strong> is a performance metric defined as</p>

<p>

<math display="block" id="Speedup:14">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>p</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>S</mi>
     <mi>p</mi>
    </msub>
    <mi>p</mi>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>T</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mi>p</mi>
     <msub>
      <mi>T</mi>
      <mi>p</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>p</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{p}=\frac{S_{p}}{p}=\frac{T_{1}}{pT_{p}}
  </annotation>
 </semantics>
</math>

. It is a value, typically between zero and one, estimating how well-utilized the processors are in solving the problem, compared to how much effort is wasted in communication and synchronization. Algorithms with linear speedup and algorithms running on a single processor have an efficiency of 1, while many difficult-to-parallelize algorithms have efficiency such as 

<math display="inline" id="Speedup:15">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mrow>
    <mi>ln</mi>
    <mi>p</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <ln></ln>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\ln p}
  </annotation>
 </semantics>
</math>

  that approaches zero as the number of processors increases.</p>

<p>In engineering contexts, efficiency is more often used for graphs than speedup, since</p>
<ul>
<li>all of the area in the graph is useful (whereas in a speedup curve 1/2 of the space is wasted)</li>
<li>it is easy to see how well parallelization is working</li>
<li>there is no need to plot a "perfect speedup" line</li>
</ul>

<p>In marketing contexts, speedup curves are more often used, largely because they go up and to the right and thus appear better to the less-informed.</p>
<h2 id="super-linear-speedup">Super-linear speedup</h2>

<p>Sometimes a speedup of more than <em>p</em> when using <em>p</em> processors is observed in <a href="parallel_computing" title="wikilink">parallel computing</a>, which is called super-linear speedup. Super-linear speedup rarely happens and often confuses beginners, who believe the theoretical maximum speedup should be <em>p</em> when <em>p</em> processors are used.</p>

<p>One possible reason for super-linear speedup in low-level computations is the <strong><a href="CPU_cache" title="wikilink">cache</a> effect</strong> resulting from the different <a href="memory_hierarchy" title="wikilink">memory hierarchies</a> of a modern computer: In parallel computing, not only do the numbers of processors change, but so does the size of accumulated caches from different processors. With the larger accumulated cache size, more or even all of the <a href="working_set" title="wikilink">working set</a> can fit into caches and the memory access time reduces dramatically, which causes the extra speedup in addition to that from the actual computation.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>An analogous situation occurs when searching large datasets, such as the genomic data searched by <a class="uri" href="BLAST" title="wikilink">BLAST</a> implementations. There the accumulated RAM from each of the nodes in a cluster enables the dataset to move from disk into RAM thereby drastically reducing the time required by e.g. mpiBLAST to search it.</p>

<p>Super-linear speedups can also occur when performing <a class="uri" href="backtracking" title="wikilink">backtracking</a> in parallel: An exception in one thread can cause several other threads to backtrack early, before they reach the exception themselves.</p>

<p>Super-linear speedups can also occur in parallel implementations of branch-and-bound for optimization:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> the processing of one node by one processor may affect the work other processors need to do for the other nodes.</p>
<h2 id="references">References</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Amdahl's_law" title="wikilink">Amdahl's law</a></li>
<li><a href="Brooks's_law" title="wikilink">Brooks's law</a></li>
<li><a href="Gustafson's_law" title="wikilink">Gustafson's law</a></li>
<li><a href="Karp-Flatt_Metric" title="wikilink">Karp-Flatt Metric</a></li>
<li><a href="Parallel_slowdown" title="wikilink">Parallel slowdown</a></li>
<li><a class="uri" href="Scalability" title="wikilink">Scalability</a></li>
</ul>

<p>"</p>

<p><a href="Category:Analysis_of_parallel_algorithms" title="wikilink">Category:Analysis of parallel algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a class="uri" href="http://mat.tepper.cmu.edu/blog/?p=534#comment-3029">http://mat.tepper.cmu.edu/blog/?p=534#comment-3029</a><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
