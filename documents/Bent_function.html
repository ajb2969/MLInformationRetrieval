<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1040">Bent function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bent function</h1>
<hr/>

<p> </p>

<p>In the <a href="mathematics" title="wikilink">mathematical</a> field of <a class="uri" href="combinatorics" title="wikilink">combinatorics</a>, a <strong>bent function</strong> is a special type of <a href="Boolean_function" title="wikilink">Boolean function</a>. This means it takes several inputs and gives one output, each of which has two possible values (such as <em>0</em> and <em>1</em>, or <em>true</em> and <em>false</em>). The name is figurative. Bent functions are so called because they are as different as possible from all <a href="linear_map" title="wikilink">linear</a> and <a href="affine_function" title="wikilink">affine functions</a>, the simplest or "straight" functions. This makes the bent functions naturally hard to approximate. Bent functions were defined and named in the 1960s by <a href="Oscar_Rothaus" title="wikilink">Oscar Rothaus</a> in research not published until 1976.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> They have been extensively studied for their applications in <a class="uri" href="cryptography" title="wikilink">cryptography</a>, but have also been applied to <a href="spread_spectrum" title="wikilink">spread spectrum</a>, <a href="coding_theory" title="wikilink">coding theory</a>, and <a href="combinatorial_design" title="wikilink">combinatorial design</a>. The definition can be extended in several ways, leading to different classes of generalized bent functions that share many of the useful properties of the original.</p>
<h2 id="walsh-transform">Walsh transform</h2>

<p>Bent functions are defined in terms of the <a href="Walsh_transform" title="wikilink">Walsh transform</a>. The Walsh transform of a Boolean function <mtpl></mtpl> is the function 

<math display="inline" id="Bent_function:0">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>f</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>:</mo>
   <mrow>
    <msubsup>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Z</mtext>
     </merror>
     <mn>2</mn>
     <mi>n</mi>
    </msubsup>
    <mo>→</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\Z</mtext>
    </merror>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <ci>normal-^</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>\Z</mtext>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <mtext>\Z</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{f}:\Z_{2}^{n}\to\Z
  </annotation>
 </semantics>
</math>

 given by</p>

<p>

<math display="block" id="Bent_function:1">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <msubsup>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\Z</mtext>
       </merror>
       <mn>2</mn>
       <mi>n</mi>
      </msubsup>
     </mrow>
    </munder>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>a</mi>
       <mo>⋅</mo>
       <mi>x</mi>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>f</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <mtext>\Z</mtext>
         <cn type="integer">2</cn>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{f}(a)=\sum_{\scriptstyle{x\in\Z_{2}^{n}}}(-1)^{f(x)+a\cdot x}
  </annotation>
 </semantics>
</math>

 where <mtpl></mtpl> is the <a href="dot_product" title="wikilink">dot product</a> in <strong>Z</strong>

<math display="inline" id="Bent_function:2">
 <semantics>
  <mmultiscripts>
   <mi></mi>
   <mn>2</mn>
   <none></none>
   <mprescripts></mprescripts>
   <none></none>
   <mi>n</mi>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <ci>n</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}^{n}_{2}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Alternatively, let  and . Then <mtpl><em>S</em><sub>0</sub>(<em>a</em>){{!}} + {{!}}<em>S</em><sub>1</sub>(<em>a</em>){{!}} = 2<sup><em>n</em></sup>}}</mtpl> and hence</p>

<p>

<math display="block" id="Bent_function:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msub>
        <mi>S</mi>
        <mn>0</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msub>
        <mi>S</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <msub>
         <mi>S</mi>
         <mn>0</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>a</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>f</ci>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>a</ci>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <cn type="integer">0</cn>
         </apply>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{f}(a)=|S_{0}(a)|-|S_{1}(a)|=2|S_{0}(a)|-2^{n}.
  </annotation>
 </semantics>
</math>

 For any Boolean function <em>ƒ</em> and  the transform lies in the range</p>

<p>

<math display="block" id="Bent_function:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>-</mo>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <msup>
     <mn>2</mn>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>f</ci>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -2^{n}\leq\hat{f}(a)\leq 2^{n}.
  </annotation>
 </semantics>
</math>

 Moreover, the linear function <mtpl></mtpl> and the affine function <mtpl></mtpl> correspond to the two extreme cases, since</p>

<p>

<math display="block" id="Bent_function:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>f</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo rspace="5.8pt">,</mo>
    <mrow>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>f</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mo>-</mo>
      <msup>
       <mn>2</mn>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>f</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>f</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{f}_{0}(a)=2^{n},~{}\hat{f}_{1}(a)=-2^{n}.
  </annotation>
 </semantics>
</math>

 Thus, for each  the value of 

<math display="inline" id="Bent_function:6">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>f</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>f</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{f}(a)
  </annotation>
 </semantics>
</math>

 characterizes where the function <em>ƒ</em>(<em>x</em>) lies in the range from <em>ƒ</em><sub>0</sub>(<em>x</em>) to <em>ƒ</em><sub>1</sub>(<em>x</em>).</p>
<h2 id="definition-and-properties">Definition and properties</h2>

<p>Rothaus defined a <strong>bent function</strong> as a Boolean function <mtpl></mtpl> whose <a href="Walsh_transform" title="wikilink">Walsh transform</a> has constant <a href="absolute_value" title="wikilink">absolute value</a>. Bent functions are in a sense equidistant from all the affine functions, so they are equally hard to approximate with any affine function.</p>

<p>The simplest examples of bent functions, written in <a href="algebraic_normal_form" title="wikilink">algebraic normal form</a>, are <em>F</em>(<em>x</em><sub>1</sub>,<em>x</em><sub>2</sub>) = <em>x</em><sub>1</sub><em>x</em><sub>2</sub> and <em>G</em>(<em>x</em><sub>1</sub>,<em>x</em><sub>2</sub>,<em>x</em><sub>3</sub>,<em>x</em><sub>4</sub>) = <em>x</em><sub>1</sub><em>x</em><sub>2</sub> + <em>x</em><sub>3</sub><em>x</em><sub>4</sub>. This pattern continues: <em>x</em><sub>1</sub><em>x</em><sub>2</sub> + <em>x</em><sub>3</sub><em>x</em><sub>4</sub> + ... + <em>x</em><sub><em>n</em> − 1</sub><em>x</em><sub><em>n</em></sub> is a bent function <mtpl></mtpl> for every even <em>n</em>, but there is a wide variety of different types of bent functions as <em>n</em> increases.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The sequence of values (−1)<sup><em>ƒ</em>(<em>x</em>)</sup>, with  taken in <a href="lexicographical_order" title="wikilink">lexicographical order</a>, is called a <strong>bent sequence</strong>; bent functions and bent sequences have equivalent properties. In this ±1 form, the Walsh transform is easily computed as</p>

<p>

<math display="block" id="Bent_function:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mn>2</mn>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>f</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>W</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{f}(a)=W(2^{n})(-1)^{f(a)},
  </annotation>
 </semantics>
</math>

 where <em>W</em>(2<sup><em>n</em></sup>) is the natural-ordered <a href="Walsh_matrix" title="wikilink">Walsh matrix</a> and the sequence is treated as a <a href="column_vector" title="wikilink">column vector</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Rothaus proved that bent functions exist only for even <em>n</em>, and that for a bent function <em>ƒ</em>, 

<math display="inline" id="Bent_function:8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>n</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>f</ci>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\hat{f}(a)|=2^{n/2}
  </annotation>
 </semantics>
</math>

 for all .<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In fact, 

<math display="inline" id="Bent_function:9">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>f</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{f}(a)=2^{n/2}(-1)^{g(a)}
  </annotation>
 </semantics>
</math>

, where <em>g</em> is also bent. In this case, 

<math display="inline" id="Bent_function:10">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}(a)=2^{n/2}(-1)^{f(a)}
  </annotation>
 </semantics>
</math>

, so <em>ƒ</em> and <em>g</em> are considered <a href="duality_(mathematics)" title="wikilink">dual</a> functions.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Every bent function has a <a href="Hamming_weight" title="wikilink">Hamming weight</a> (number of times it takes the value 1) of <mtpl></mtpl>, and in fact agrees with any affine function at one of those two numbers of points. So the <em>nonlinearity</em> of <em>ƒ</em> (minimum number of times it equals any affine function) is <mtpl></mtpl>, the maximum possible. Conversely, any Boolean function with nonlinearity <mtpl></mtpl> is bent.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The <a href="Degree_of_a_polynomial" title="wikilink">degree</a> of <em>ƒ</em> in algebraic normal form (called the <em>nonlinear order</em> of <em>ƒ</em>) is at most <em>n</em>/2 (for <em>n</em> &gt; 2).<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Although bent functions are vanishingly rare among Boolean functions of many variables, they come in many different kinds. There has been detailed research into special classes of bent functions, such as the <a href="homogeneous_polynomial" title="wikilink">homogeneous</a> ones<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> or those arising from a <a class="uri" href="monomial" title="wikilink">monomial</a> over a <a href="finite_field" title="wikilink">finite field</a>,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> but so far the bent functions have defied all attempts at a complete enumeration or classification.</p>
<h2 id="applications">Applications</h2>

<p>As early as 1982 it was discovered that <a href="maximum_length_sequence" title="wikilink">maximum length sequences</a> based on bent functions have <a class="uri" href="cross-correlation" title="wikilink">cross-correlation</a> and <a class="uri" href="autocorrelation" title="wikilink">autocorrelation</a> properties rivalling those of the <a href="Gold_code" title="wikilink">Gold codes</a> and <a href="Kasami_code" title="wikilink">Kasami codes</a> for use in <a class="uri" href="CDMA" title="wikilink">CDMA</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> These sequences have several applications in <a href="spread_spectrum" title="wikilink">spread spectrum</a> techniques.</p>

<p>The properties of bent functions are naturally of interest in modern digital <a class="uri" href="cryptography" title="wikilink">cryptography</a>, which seeks to obscure relationships between input and output. By 1988 Forré recognized that the Walsh transform of a function can be used to show that it satisfies the <a href="Strict_Avalanche_Criterion" title="wikilink">Strict Avalanche Criterion</a> (SAC) and higher-order generalizations, and recommended this tool to select candidates for good <a href="S-box" title="wikilink">S-boxes</a> achieving near-perfect <a href="confusion_and_diffusion" title="wikilink">diffusion</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Indeed, the functions satisfying the SAC to the highest possible order are always bent.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Furthermore, the bent functions are as far as possible from having what are called <em>linear structures</em>, nonzero vectors a such that <em>ƒ</em>(<em>x</em>+<em>a</em>) + <em>ƒ</em>(<em>x</em>) is a constant. In the language of <a href="differential_cryptanalysis" title="wikilink">differential cryptanalysis</a> (introduced after this property was discovered) the <em>derivative</em> of a bent function <em>ƒ</em> at every nonzero point <em>a</em> (that is, <em>ƒ</em><sub><em>a</em></sub>(<em>x</em>) = <em>ƒ</em>(<em>x</em>+<em>a</em>) + <em>ƒ</em>(<em>x</em>)) is a <a href="balanced_boolean_function" title="wikilink"><em>balanced</em></a> Boolean function, taking on each value exactly half of the time. This property is called <em>perfect nonlinearity</em>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>Given such good diffusion properties, apparently perfect resistance to differential cryptanalysis, and resistance by definition to <a href="linear_cryptanalysis" title="wikilink">linear cryptanalysis</a>, bent functions might at first seem the ideal choice for secure cryptographic functions such as S-boxes. Their fatal flaw is that they fail to be balanced. In particular, an invertible S-box cannot be constructed directly from bent functions, and a <a href="stream_cipher" title="wikilink">stream cipher</a> using a bent combining function is vulnerable to a <a href="correlation_attack" title="wikilink">correlation attack</a>. Instead, one might start with a bent function and randomly complement appropriate values until the result is balanced. The modified function still has high nonlinearity, and as such functions are very rare the process should be much faster than a brute-force search.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> But functions produced in this way may lose other desirable properties, even failing to satisfy the SAC—so careful testing is necessary.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> A number of cryptographers have worked on techniques for generating balanced functions that preserve as many of the good cryptographic qualities of bent functions as possible.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Some of this theoretical research has been incorporated into real cryptographic algorithms. The <em>CAST</em> design procedure, used by <a href="Carlisle_Adams" title="wikilink">Carlisle Adams</a> and <a href="Stafford_Tavares" title="wikilink">Stafford Tavares</a> to construct the S-boxes for the <a href="block_ciphers" title="wikilink">block ciphers</a> <a class="uri" href="CAST-128" title="wikilink">CAST-128</a> and <a class="uri" href="CAST-256" title="wikilink">CAST-256</a>, makes use of bent functions.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> The <a href="cryptographic_hash_function" title="wikilink">cryptographic hash function</a> <a class="uri" href="HAVAL" title="wikilink">HAVAL</a> uses Boolean functions built from representatives of all four of the <a href="equivalence_class" title="wikilink">equivalence classes</a> of bent functions on six variables.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> The stream cipher <a href="Grain_(cipher)" title="wikilink">Grain</a> uses an <a class="uri" href="NLFSR" title="wikilink">NLFSR</a> whose nonlinear feedback polynomial is, by design, the sum of a bent function and a linear function.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h2 id="generalizations">Generalizations</h2>

<p>The most common class of <em>generalized bent functions</em> is the <a href="modular_arithmetic" title="wikilink">mod m</a> type, 

<math display="inline" id="Bent_function:11">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msubsup>
     <mi>ℤ</mi>
     <mi>m</mi>
     <mi>n</mi>
    </msubsup>
    <mo>→</mo>
    <msub>
     <mi>ℤ</mi>
     <mi>m</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℤ</ci>
       <ci>m</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{Z}_{m}^{n}\to\mathbb{Z}_{m}
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Bent_function:12">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <msubsup>
       <mi>ℤ</mi>
       <mi>m</mi>
       <mi>n</mi>
      </msubsup>
     </mrow>
    </munder>
    <msup>
     <mi>e</mi>
     <mrow>
      <mfrac>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>i</mi>
       </mrow>
       <mi>m</mi>
      </mfrac>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>a</mi>
         <mo>⋅</mo>
         <mi>x</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>f</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ℤ</ci>
         <ci>m</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>i</ci>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <ci>normal-⋅</ci>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{f}(a)=\sum_{x\in\mathbb{Z}_{m}^{n}}e^{\frac{2\pi i}{m}(f(x)-a\cdot x)}
  </annotation>
 </semantics>
</math>

 has constant absolute value <em>m</em><sup><em>n</em>/2</sup>. Perfect nonlinear functions 

<math display="inline" id="Bent_function:13">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msubsup>
     <mi>ℤ</mi>
     <mi>m</mi>
     <mi>n</mi>
    </msubsup>
    <mo>→</mo>
    <msub>
     <mi>ℤ</mi>
     <mi>m</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℤ</ci>
       <ci>m</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{Z}_{m}^{n}\to\mathbb{Z}_{m}
  </annotation>
 </semantics>
</math>

, those such that for all nonzero <em>a</em>, <em>ƒ</em>(<em>x</em>+<em>a</em>) − <em>ƒ</em>(<em>a</em>) takes on each value <mtpl></mtpl> times, are generalized bent. If <em>m</em> is <a href="prime_number" title="wikilink">prime</a>, the converse is true. In most cases only prime <em>m</em> are considered. For odd prime <em>m</em>, there are generalized bent functions for every positive <em>n</em>, even and odd. They have many of the same good cryptographic properties as the binary bent functions.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p><strong>Semi-bent functions</strong> are an odd-order counterpart to bent functions. A semi-bent function is 

<math display="inline" id="Bent_function:14">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msubsup>
     <mi>ℤ</mi>
     <mi>m</mi>
     <mi>n</mi>
    </msubsup>
    <mo>→</mo>
    <msub>
     <mi>ℤ</mi>
     <mi>m</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℤ</ci>
       <ci>m</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{Z}_{m}^{n}\to\mathbb{Z}_{m}
  </annotation>
 </semantics>
</math>

 with <em>n</em> odd, such that 

<math display="inline" id="Bent_function:15">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mover accent="true">
    <mi>f</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <ci>normal-^</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\hat{f}|
  </annotation>
 </semantics>
</math>

 takes only the values 0 and <em>m</em><sup>(<em>n</em>+1)/2</sup>. They also have good cryptographic characteristics, and some of them are balanced, taking on all possible values equally often.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>The <strong>partially bent functions</strong> form a large class defined by a condition on the Walsh transform and autocorrelation functions. All affine and bent functions are partially bent. This is in turn a proper subclass of the <em>plateaued functions</em>.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>

<p>The idea behind the <strong>hyper-bent functions</strong> is to maximize the minimum distance to <em>all</em> Boolean functions coming from <a href="bijection" title="wikilink">bijective</a> monomials on the finite field <em>GF</em>(2<sup><em>n</em></sup>), not just the affine functions. For these functions this distance is constant, which may make them resistant to an <a href="interpolation_attack" title="wikilink">interpolation attack</a>.</p>

<p>Other related names have been given to cryptographically important classes of functions , such as <strong>almost bent functions</strong> and <strong>crooked functions</strong>. While not bent functions themselves (these are not even Boolean functions), they are closely related to the bent functions and have good nonlinearity properties.</p>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Boolean_algebra" title="wikilink">Category:Boolean algebra</a> <a class="uri" href="Category:Combinatorics" title="wikilink">Category:Combinatorics</a> <a href="Category:Symmetric-key_cryptography" title="wikilink">Category:Symmetric-key cryptography</a> <a href="Category:Theory_of_cryptography" title="wikilink">Category:Theory of cryptography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
</ol>
</section>
</body>
</html>
