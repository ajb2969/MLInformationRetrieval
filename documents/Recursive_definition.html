<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1491">Recursive definition</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Recursive definition</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Four stages in the construction of a <a href="Koch_snowflake" title="wikilink">Koch snowflake</a>. As with many other <a href="fractal" title="wikilink">fractals</a>, the stages are obtained via a recursive definition.</figcaption>
</figure>

<p>A <strong>recursive definition</strong> (or <strong>inductive definition</strong>) in <a href="mathematical_logic" title="wikilink">mathematical logic</a> and <a href="computer_science" title="wikilink">computer science</a> is used to define the elements in a set in terms of other elements in the set (Aczel 1978:740ff).</p>

<p>A recursive definition of a function defines values of the functions for some inputs in terms of the values of the same function for other inputs. For example, the <a class="uri" href="factorial" title="wikilink">factorial</a> function <em>n</em>! is defined by the rules</p>
<dl>
<dd>0! = 1.
</dd>
<dd>(<em>n</em>+1)! = (<em>n</em>+1)·<em>n</em>!.
</dd>
</dl>

<p>This definition is valid for all <em>n</em>, because the recursion eventually reaches the <strong>base case</strong> of 0. The definition may also be thought of as giving a procedure describing how to construct the function <em>n</em>!, starting from n = 0 and proceeding onwards with n = 1, n = 2, n = 3 etc..</p>

<p>That such a definition indeed defines a function can be proved by induction.</p>

<p>An inductive definition of a set describes the elements in a set in terms of other elements in the set. For example, one definition of the set <strong>N</strong> of <a href="natural_number" title="wikilink">natural numbers</a> is:</p>
<ol>
<li>1 is in <strong>N</strong>.</li>
<li>If an element <em>n</em> is in <strong>N</strong> then <em>n</em>+1 is in <strong>N</strong>.</li>
<li><strong>N</strong> is the smallest set satisfying (1) and (2).</li>
</ol>

<p>There are many sets that satisfy (1) and (2) - for example, the set {1, 1.649, 2, 2.649, 3, 3.649, ...} satisfies the definition. However, condition (3) specifies the set of natural numbers by removing the sets with extraneous members.</p>

<p>Properties of recursively defined functions and sets can often be proved by an <a href="mathematical_induction" title="wikilink">induction</a> principle that follows the recursive definition. For example, the definition of the natural numbers presented here directly implies the <strong>principle of mathematical induction</strong> for natural numbers: if a property holds of the natural number 0, and the property holds of <em>n</em>+1 whenever it holds of <em>n</em>, then the property holds of all natural numbers (Aczel 1978:742).</p>
<h2 id="form-of-recursive-definitions">Form of recursive definitions</h2>

<p>Most recursive definitions have three foundations: a base case (basis), an inductive clause, and an extremal clause.</p>

<p>The difference between a <a href="circular_definition" title="wikilink">circular definition</a> and a recursive definition is that a recursive definition must always have <em>base cases</em>, cases that satisfy the definition <em>without</em> being defined in terms of the definition itself, and all other cases comprising the definition must be "smaller" (<em>closer</em> to those base cases that terminate the recursion) in some sense. In contrast, a circular definition may have no base case, and define the value of a function in terms of that value itself, rather than on other values of the function. Such a situation would lead to an <a href="infinite_regress" title="wikilink">infinite regress</a>.</p>
<h2 id="examples-of-recursive-definitions">Examples of recursive definitions</h2>
<h3 id="elementary-functions">Elementary functions</h3>

<p>Addition is defined recursively based on counting</p>

<p>

<math display="block" id="Recursive_definition:0">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>+</mo>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">0</cn>
     <ci>a</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0+a=a
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Recursive_definition:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1+n)+a=1+(n+a)
  </annotation>
 </semantics>
</math>

 Multiplication is defined recursively</p>

<p>

<math display="block" id="Recursive_definition:2">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">0</cn>
     <ci>a</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0a=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Recursive_definition:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <mi>a</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1+n)a=a+na
  </annotation>
 </semantics>
</math>

 Exponentiation is defined recursively</p>

<p>

<math display="block" id="Recursive_definition:4">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mn>0</mn>
   </msup>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{0}=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Recursive_definition:5">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mi>n</mi>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <msup>
     <mi>a</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{1+n}=aa^{n}
  </annotation>
 </semantics>
</math>

 Binomial coefficients are defined recursively</p>

<p>

<math display="block" id="Recursive_definition:6">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>a</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\left({{a}\atop{0}}\right)}=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Recursive_definition:7">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mi>a</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mi>n</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mstyle scriptlevel="+1">
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mi>a</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mi>n</mi>
         </mtd>
        </mtr>
       </mtable>
      </mstyle>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mi>n</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>a</ci>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\left({{1+a}\atop{1+n}}\right)}=\frac{(1+a){\left({{a}\atop{n}}\right)}}{1+n}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="prime-numbers">Prime numbers</h3>

<p>The set of <a href="prime_number" title="wikilink">prime numbers</a> can be defined as the unique set of positive integers satisfying</p>
<ul>
<li><a href="1_(number)" title="wikilink">1</a> is not a prime number</li>
<li>any other positive integer is a prime number if and only if it is not divisible by any prime number smaller than itself</li>
</ul>

<p>The primality of the integer 1 is the base case; checking the primality of any larger integer <em>X</em> by this definition requires knowing the primality of every integer between 1 and <em>X</em>, which is well defined by this definition. That last point can proved by induction on <em>X</em>, for which it is essential that the second clause says "if and only if"; if it had said just "if" the primality of for instance 4 would not be clear, and the further application of the second clause would be impossible.</p>
<h3 id="non-negative-even-numbers">Non-negative even numbers</h3>

<p>The <a href="even_number" title="wikilink">even numbers</a> can be defined as consisting of</p>
<ul>
<li>0 is in the set E of non-negative evens (basis clause)</li>
<li>For any element x in the set E, x+2 is in E (inductive clause)</li>
<li>Nothing is in E unless it is obtained from the basis and inductive clauses (extremal clause).</li>
</ul>
<h3 id="well-formed-formulas">Well formed formulas</h3>

<p>It is chiefly in logic or computer programming that recursive definitions are found. For example, a <a href="well_formed_formula" title="wikilink">well formed formula</a> (wff) can be defined as:</p>
<ol>
<li>a symbol which stands for a <a class="uri" href="proposition" title="wikilink">proposition</a> - like <strong>p</strong> means "Connor is a lawyer."</li>
<li>The negation symbol, followed by a wff - like <strong>Np</strong> means "It is not true that Connor is a lawyer."</li>
<li>Any of the four binary <a href="connective" title="wikilink">connectives</a> (C, A, K, or E) followed by two wffs. The symbol <strong>K</strong> means "both are true", so <strong>Kpq</strong> may mean "Connor is a lawyer and Mary likes music."</li>
</ol>

<p>The value of such a recursive definition is that it can be used to determine whether any particular string of symbols is "well formed".</p>
<ul>
<li><strong>Kpq</strong> is well formed, because it's <strong>K</strong> followed by the atomic wffs <strong>p</strong> and <strong>q</strong>.</li>
<li><strong>NKpq</strong> is well formed, because it's <strong>N</strong> followed by <strong>Kpq</strong>, which is in turn a wff.</li>
<li><strong>KNpNq</strong> is <strong>K</strong> followed by <strong>Np</strong> and <strong>Nq</strong>; and <strong>Np</strong> is a wff, etc.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Recursive_data_type" title="wikilink">Recursive data types</a></li>
<li><a class="uri" href="Recursion" title="wikilink">Recursion</a></li>
<li><a href="Mathematical_induction" title="wikilink">Mathematical induction</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="Paul_Halmos" title="wikilink">Paul Halmos</a>: <em>Naive set theory</em>, van Nostrand, 1960</li>
<li>P. Aczel (1977), "An introduction to inductive definitions", <em>Handbook of Mathematical Logic</em>, J. Barwise (ed.), ISBN 0-444-86388-5.</li>
<li>James L. Hein (2009), <em>Discrete Structures, Logic, and Computability</em>. ISBN 0-7637-7206-2.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Definition" title="wikilink">Category:Definition</a> <a href="Category:Mathematical_logic" title="wikilink">Category:Mathematical logic</a> <a href="Category:Theoretical_computer_science" title="wikilink">Category:Theoretical computer science</a> <a class="uri" href="Category:Recursion" title="wikilink">Category:Recursion</a></p>
</body>
</html>
