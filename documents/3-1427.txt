   Inverse iteration      Inverse iteration   In numerical analysis , inverse iteration is an iterative  eigenvalue algorithm . It allows one to find an approximate eigenvector when an approximation to a corresponding eigenvalue is already known. The method is conceptually similar to the power method and is also known as the inverse power method . It appears to have originally been developed to compute resonance frequencies in the field of structural mechanics. 1  The inverse power iteration algorithm starts with an approximation   μ   μ   \mu   for the eigenvalue corresponding to the desired eigenvector and a vector b 0 , either a randomly selected vector or an approximation to the eigenvector. The method is described by the iteration        b   k  +  1    =      (   A  -   μ  I    )    -  1     b  k     C  k     ,       subscript  b    k  1         superscript    A    μ  I      1     subscript  b  k     subscript  C  k      b_{k+1}=\frac{(A-\mu I)^{-1}b_{k}}{C_{k}},     where C k are some constants usually chosen as      C  k   =   ∥     (   A  -   μ  I    )    -  1     b  k    ∥    .       subscript  C  k    norm     superscript    A    μ  I      1     subscript  b  k       C_{k}=\|(A-\mu I)^{-1}b_{k}\|.   Since eigenvectors are defined up to multiplication by constant, the choice of C k can be arbitrary in theory; practical aspects of the choice of    C  k     subscript  C  k    C_{k}   are discussed below.  At every iteration, the vector b k is multiplied by the inverse of the matrix    (   A  -   μ  I    )      A    μ  I     (A-\mu I)   and normalized. It is exactly the same formula as in the power method , except replacing the matrix A by      (   A  -   μ  I    )    -  1    .     superscript    A    μ  I      1     (A-\mu I)^{-1}.   The closer the approximation   μ   μ   \mu   to the eigenvalue is chosen, the faster the algorithm converges; however, incorrect choice of   μ   μ   \mu   can lead to slow convergence or to the convergence to an eigenvector other than the one desired. In practice, the method is used when a good approximation for the eigenvalue is known, and hence one needs only few (quite often just one) iterations.  Theory and convergence  The basic idea of the power iteration is choosing an initial vector b (either an eigenvector approximation or a random vector) and iteratively calculating     A  b   ,    A  2   b   ,    A  3   b   ,  …       A  b      superscript  A  2   b      superscript  A  3   b   normal-…    Ab,A^{2}b,A^{3}b,...   . Except for a set of zero measure , for any initial vector, the result will converge to an eigenvector corresponding to the dominant eigenvalue .  The inverse iteration does the same for the matrix     (   A  -   μ  I    )    -  1      superscript    A    μ  I      1     (A-\mu I)^{-1}   , so it converges to eigenvector corresponding to the dominant eigenvalue of the matrix     (   A  -   μ  I    )    -  1      superscript    A    μ  I      1     (A-\mu I)^{-1}   . Eigenvalues of this matrix are       (    λ  1   -  μ   )    -  1    ,  …  ,    (    λ  n   -  μ   )    -  1     ,      superscript     subscript  λ  1   μ     1    normal-…   superscript     subscript  λ  n   μ     1      (\lambda_{1}-\mu)^{-1},...,(\lambda_{n}-\mu)^{-1},   where    λ  i     subscript  λ  i    \lambda_{i}   are eigenvalues of A . The largest of these numbers corresponds to the smallest of      (    λ  1   -  μ   )   ,  …  ,   (    λ  n   -  μ   )    .        subscript  λ  1   μ   normal-…     subscript  λ  n   μ     (\lambda_{1}-\mu),...,(\lambda_{n}-\mu).   It is obvious that the eigenvectors of A and of     (   A  -   μ  I    )    -  1      superscript    A    μ  I      1     (A-\mu I)^{-1}   are the same.  Conclusion : The method converges to the eigenvector of the matrix A corresponding to the closest eigenvalue to    μ  .    μ   \mu.     In particular taking    μ  =  0      μ  0    \mu=0   we see that      (  A  )    -  k    b       superscript  A    k    b    (A)^{-k}b   converges to the eigenvector corresponding to the eigenvalue of A with the smallest absolute value.  Speed of convergence  Let us analyze the rate of convergence of the method.  The power method is known to converge linearly to the limit, more precisely:        Distance   (   b  ideal   ,   b    Power   Method   k   )    =   O   (    |    λ  subdominant    λ  dominant    |   k   )     ,        Distance    superscript  b  ideal    subscript   superscript  b  k     Power  Method        O   superscript       subscript  λ  subdominant    subscript  λ  dominant     k      \mathrm{Distance}(b^{\mathrm{ideal}},b^{k}_{\mathrm{Power~{}Method}})=O\left(%
 \left|\frac{\lambda_{\mathrm{subdominant}}}{\lambda_{\mathrm{dominant}}}\right%
 |^{k}\right),     hence for the inverse iteration method similar result sounds as:        Distance   (   b  ideal   ,   b    Inverse   iteration   k   )    =   O   (    |    μ  -   λ    closest    to   μ      μ  -   λ    second    closest    to   μ      |   k   )     .        Distance    superscript  b  ideal    subscript   superscript  b  k     Inverse  iteration        O   superscript        μ   subscript  λ    closest  to  μ       μ   subscript  λ    second  closest  to  μ       k      \mathrm{Distance}(b^{\mathrm{ideal}},b^{k}_{\mathrm{Inverse~{}iteration}})=O%
 \left(\left|\frac{\mu-\lambda_{\mathrm{closest~{}to~{}}\mu}}{\mu-\lambda_{%
 \mathrm{second~{}closest~{}to~{}}\mu}}\right|^{k}\right).     This is a key formula for understanding the method's convergence. It shows that if   μ   μ   \mu   is chosen close enough to some eigenvalue   λ   λ   \lambda   , for example     μ  -  λ   =  ϵ        μ  λ   ϵ    \mu-\lambda=\epsilon   each iteration will improve the accuracy     |  ϵ  |   /   |    λ  +  ϵ   -   λ    closest    to   λ     |         ϵ         λ  ϵ    subscript  λ    closest  to  λ        |\epsilon|/|\lambda+\epsilon-\lambda_{\mathrm{closest~{}to~{}}\lambda}|   times. (We use that for small enough   ϵ   ϵ   \epsilon   "closest to   μ   μ   \mu   " and "closest to   λ   λ   \lambda   " is the same.) For small enough    |  ϵ  |      ϵ    |\epsilon|   it is approximately the same as     |  ϵ  |   /   |   λ  -   λ    closest    to   λ     |         ϵ       λ   subscript  λ    closest  to  λ        |\epsilon|/|\lambda-\lambda_{\mathrm{closest~{}to~{}}\lambda}|   . Hence if one is able to find   μ   μ   \mu   , such the   ϵ   ϵ   \epsilon   will be small enough, then very few iterations may be satisfactory.  Complexity  The inverse iteration algorithm requires solving a linear system or calculation of the inverse matrix. For non-structured matrices (not sparse, not Toeplitz,...) this requires    O   (   n  3   )       O   superscript  n  3     O(n^{3})   operations.  Implementation options  The method is defined by the formula:        b   k  +  1    =      (   A  -   μ  I    )    -  1     b  k     C  k     ,       subscript  b    k  1         superscript    A    μ  I      1     subscript  b  k     subscript  C  k      b_{k+1}=\frac{(A-\mu I)^{-1}b_{k}}{C_{k}},     There are, however, multiple options for its implementation.  Calculate inverse matrix or solve system of linear equations  We can rewrite the formula in the following way:         (   A  -   μ  I    )    b   k  +  1     =    b  k    C  k     ,          A    μ  I     subscript  b    k  1        subscript  b  k    subscript  C  k      (A-\mu I)b_{k+1}=\frac{b_{k}}{C_{k}},     emphasizing that to find the next approximation    b   k  +  1      subscript  b    k  1     b_{k+1}   we may solve a system of linear equations. There are two options: one may choose an algorithm that solves a linear system, or one may calculate the inverse     (   A  -   μ  I    )    -  1      superscript    A    μ  I      1     (A-\mu I)^{-1}   and then apply it to the vector. Both options have complexity O(n 3 ) , the exact number depends on the chosen method.  The choice depends also on the number of iterations. Naively, if at each iteration one solves a linear system, the complexity will be k*O(n 3 ) , where k is number of iterations; similarly, calculating the inverse matrix and applying it at each iteration is of complexity k*O(n 3 ) . Note, however, that if the eigenvalue estimate   μ   μ   \mu   remains constant, then we may reduce the complexity to O(n 3 ) + k*O(n 2 ) with either method. Calculating the inverse matrix once, and storing it to apply at each iteration is of complexity O(n 3 ) + k*O(n 2 ) . Storing an LU decomposition of    (   A  -   μ  I    )      A    μ  I     (A-\mu I)   and using forward and back substitution to solve the system of equations at each iteration is also of complexity O(n 3 ) + k*O(n 2 ) .  Inverting the matrix will typically have a greater initial cost, but lower cost at each iteration. Conversely, solving systems of linear equations will typically have a lesser initial cost, but require more operations for each iteration.  Tridiagonalization, Hessenberg form  If it is necessary to perform many iterations (or few iterations, but for many eigenvectors), then it might be wise to bring the matrix to the upper Hessenberg form first (for symmetric matrix this will be tridiagonal form ). Which costs         10  3       n  3    +   O   (   n  2   )              10  3      superscript  n  3      O   superscript  n  2      \begin{matrix}\frac{10}{3}\end{matrix}n^{3}+O(n^{2})   arithmetic operations using a technique based on Householder reduction ), with a finite sequence of orthogonal similarity transforms, somewhat like a two-sided QR decomposition. 2 3 (For QR decomposition, the Householder rotations are multiplied only on the left, but for the Hessenberg case they are multiplied on both left and right.) For symmetric matrices this procedure costs         4  3       n  3    +   O   (   n  2   )              4  3      superscript  n  3      O   superscript  n  2      \begin{matrix}\frac{4}{3}\end{matrix}n^{3}+O(n^{2})   arithmetic operations using a technique based on Householder reduction. 4 5  Solution of the system of linear equations for the tridiagonal matrix costs O(n) operations, so the complexity grows like O(n 3 )+k*O(n) , where k is the iteration number, which is better than for the direct inversion. However for few iterations such transformation may not be practical.  Also transformation to the Hessenberg form involves square roots and the division operation, which are not universally supported by hardware.  Choice of the normalization constant C k  On general purpose processors (e.g. produced by Intel) the execution time of addition, multiplication and division is approximately equal. But on embedded and/or low energy consuming hardware ( digital signal processors , FPGA , ASIC ) division may not be supported by hardware, and so should be avoided. Choosing C k =2 n k allows fast division without explicit hardware support, as division by a power of 2 may be implemented as either a bit shift (for fixed-point arithmetic ) or subtraction of k from the exponent (for floating-point arithmetic ).  When implementing the algorithm using fixed-point arithmetic , the choice of the constant C k is especially important. Small values will lead to fast growth of the norm of b k and to overflow ; large values of C k will cause the vector b k to tend toward zero.  Usage  The main application of the method is the situation when an approximation to an eigenvalue is found and one needs to find the corresponding approximate eigenvector. In such situation the inverse iteration is the main and probably the only method to use. So typically the method is used in combination with some other methods which allows to find approximate eigenvalues: the standard example is the bisection eigenvalue algorithm , another example is the Rayleigh quotient iteration which is actually the same inverse iteration with the choice of the approximate eigenvalue as the Rayleigh quotient corresponding to the vector obtained on the previous step of the iteration.  There are some situations where the method can be used by itself, however they are quite marginal.  Dominant eigenvector. The dominant eigenvalue can be easily estimated for any matrix. For any induced norm it is true that      ∥  A  ∥   ≥   |  λ  |    ,       norm  A     λ     \left\|A\right\|\geq|\lambda|,   for any eigenvalue   λ   λ   \lambda   . So taking the norm of the matrix as an approximate eigenvalue one can see that the method will converge to the dominant eigenvector.  Estimates based on statistics. In some real-time applications one needs to find eigenvectors for matrices with a speed may be millions matrices per second. In such applications typically the statistics of matrices is known in advance and one can take as approximate eigenvalue the average eigenvalue for some large matrix sample, or better one calculates the mean ratio of the eigenvalue to the trace or the norm of the matrix and eigenvalue is estimated as trace or norm multiplied on the average value the their ratio. Clearly such method can be used with much care and only in situations when the mistake in calculations is allowed. Actually such idea can be combined with other methods to avoid too big errors.  See also   Power iteration  Rayleigh quotient iteration  List of eigenvalue algorithms   References  External links   Inverse Iteration to find eigenvectors , physics.arizona.edu  The Power Method for Eigenvectors , math.fullerton.edu   "  Category:Numerical linear algebra     Ernst Pohlhausen, Berechnung der Eigenschwingungen statisch-bestimmter Fachwerke , ZAMM - Zeitschrift für Angewandte Mathematik und Mechanik 1, 28-42 (1921). ↩  . ↩  Lloyd N. Trefethen and David Bau, Numerical Linear Algebra (SIAM, 1997). ↩       