   Lambda calculus definition      Lambda calculus definition   Formal definitions of the Lambda calculus . Lambda calculus is a programming language based on lambda abstraction and function application. Two definitions of the language are given here.   Standard definition  Definition using mathematical formulas.   Standard definition  This formal definition was given by Alonzo Church .  Definition  Lambda expressions are composed of   variables v 1 , v 2 , ..., v n , ...  the abstraction symbols lambda 'λ' and dot '.'  parentheses ( )   The set of lambda expressions, Λ, can be defined inductively :   If x is a variable, then x ∈ Λ  If x is a variable and M ∈ Λ, then (λx.M) ∈ Λ  If M, N ∈ Λ, then (M N) ∈ Λ   Instances of rule 2 are known as abstractions and instances of rule 3 are known as applications. 1  Notation  To keep the notation of lambda expressions uncluttered, the following conventions are usually applied.   Outermost parentheses are dropped: M N instead of (M N)  Applications are assumed to be left associative: M N P may be written instead of ((M N) P) 2  The body of an abstraction extends as far right as possible : λx.M N means λx.(M N) and not (λx.M) N  A sequence of abstractions is contracted: λx.λy.λz.N is abbreviated as λxyz.N   3  Free and bound variables  The abstraction operator, λ, is said to bind its variable wherever it occurs in the body of the abstraction. Variables that fall within the scope of an abstraction are said to be bound . All other variables are called free . For example, in the following expression y is a bound variable and x is free: λ''y''.''x'' ''x'' ''y'' . Also note that a variable is bound by its "nearest" abstraction. In the following example the single occurrence of x in the expression is bound by the second lambda: λ''x''.''y''  (λ''x''.''z'' ''x'')  The set of free variables of a lambda expression, M, is denoted as FV(M) and is defined by recursion on the structure of the terms, as follows:   FV(x) = {x}, where x is a variable  FV(λx.M) = FV(M) \ {x}  FV(M N) = FV(M) ∪ FV(N) 4   An expression that contains no free variables is said to be closed . Closed lambda expressions are also known as combinators and are equivalent to terms in combinatory logic .  Reduction  The meaning of lambda expressions is defined by how expressions can be reduced. 5  There are three kinds of reduction:   α-conversion : changing bound variables ( alpha );  β-reduction : applying functions to their arguments ( beta );  η-conversion : which captures a notion of extensionality ( eta ).   We also speak of the resulting equivalences: two expressions are β-equivalent , if they can be β-converted into the same expression, and α/η-equivalence are defined similarly.  The term redex , short for reducible expression , refers to subterms that can be reduced by one of the reduction rules. For example, (λ''x''.M) N is a beta-redex in expressing the substitution of N for x in M; if ''x'' is not free in M , λ''x''.M ''x'' is an eta-redex. The expression to which a redex reduces is called its reduct; using the previous example, the reducts of these expressions are respectively M[''x'':=N] and M .  α-conversion  Alpha-conversion, sometimes known as alpha-renaming, 6 allows bound variable names to be changed. For example, alpha-conversion of λ''x''.''x'' might yield λ''y''.''y'' . Terms that differ only by alpha-conversion are called α-equivalent . Frequently in uses of lambda calculus, α-equivalent terms are considered to be equivalent.  The precise rules for alpha-conversion are not completely trivial. First, when alpha-converting an abstraction, the only variable occurrences that are renamed are those that are bound to the same abstraction. For example, an alpha-conversion of λ''x''.λ''x''.''x'' could result in λ''y''.λ''x''.''x'' , but it could not result in λ''y''.λ''x''.''y'' . The latter has a different meaning from the original.  Second, alpha-conversion is not possible if it would result in a variable getting captured by a different abstraction. For example, if we replace ''x'' with ''y'' in λ''x''.λ''y''.''x'' , we get λ''y''.λ''y''.''y'' , which is not at all the same.  In programming languages with static scope, alpha-conversion can be used to make name resolution simpler by ensuring that no variable name masks a name in a containing scope (see alpha renaming to make name resolution trivial ).  Substitution  Substitution, written ''E''[''V'' := ''R''] , is the process of replacing all free occurrences of the variable ''V'' in the expression ''E'' with expression ''R'' . Substitution on terms of the λ-calculus is defined by recursion on the structure of terms, as follows (note: x and y are only variables while M and N are any λ expression).   ''x''[''x'' := N]        ≡ N   ''y''[''x'' := N]        ≡ ''y'', if ''x'' ≠ ''y''   (M 1 M 2 )[''x'' := N]  ≡ (M 1 [''x'' := N]) (M 2 [''x'' := N])   (λ''x''.M)[''x'' := N]   ≡ λ''x''.M   (λ''y''.M)[''x'' := N]   ≡ λ''y''.(M[''x'' := N]), if ''x'' ≠ ''y'', ''provided'' ''y'' ∉ FV(N)    To substitute into a lambda abstraction, it is sometimes necessary to α-convert the expression. For example, it is not correct for (λ''x''.''y'')[''y'' := ''x''] to result in (λ''x''.''x'') , because the substituted ''x'' was supposed to be free but ended up being bound. The correct substitution in this case is (λ''z''.''x'') , up to α-equivalence. Notice that substitution is defined uniquely up to α-equivalence.  β-reduction  Beta-reduction captures the idea of function application. Beta-reduction is defined in terms of substitution: the beta-reduction of ((λ''V''.''E'') ''E′'') is ''E''[''V'' := ''E′''] .  For example, assuming some encoding of 2, 7, × , we have the following β-reduction: ((λ''n''.''n''×2) 7) → 7×2 .  η-conversion  Eta-conversion expresses the idea of extensionality , which in this context is that two functions are the same if and only if they give the same result for all arguments. Eta-conversion converts between λ''x''.(''f'' ''x'') and ''f'' whenever ''x'' does not appear free in ''f'' .  Normalization  The purpose of beta-reduction is to calculate a value. A value in Lambda Calculus is a function. So beta-reduction continues until the expression looks like a function abstraction.  An lambda expression that cannot be reduced further, by either beta-redex, or eta-redex is in normal form. Note that alpha-conversion may convert functions. All normal forms that can be converted into each other by alpha conversion are defined to be equal. See the main article on Beta normal form for details.      Normal Form Type   Definition.       Normal Form   No beta or eta reductions are possible.     Head Normal Form   In the form of a lambda abstraction whose body is not reducible.     Weak Head Normal Form   In the form of a lambda abstraction.     Evaluation strategy  Whether a term is normalising or not, and how much work needs to be done in normalising it if it is, depends to a large extent on the reduction strategy used. The distinction between reduction strategies relates to the distinction in functional programming languages between eager evaluation and lazy evaluation .   Full beta reductions: Any redex can be reduced at any time. This means essentially the lack of any particular reduction strategy—with regard to reducibility, "all bets are off". Applicative order: The leftmost, innermost redex is always reduced first. Intuitively this means a function's arguments are always reduced before the function itself. Applicative order always attempts to apply functions to normal forms, even when this is not possible.  Most programming languages (including Lisp, ML and imperative languages like C and Java ) are described as "strict", meaning that functions applied to non-normalising arguments are non-normalising. This is done essentially using applicative order, call by value reduction ( see below ), but usually called "eager evaluation".  Normal order: The leftmost, outermost redex is always reduced first. That is, whenever possible the arguments are substituted into the body of an abstraction before the arguments are reduced. Call by name: As normal order, but no reductions are performed inside abstractions. For example λ''x''.(λ''x''.''x'')''x'' is in normal form according to this strategy, although it contains the redex (λ''x''.''x'')''x'' . Call by value: Only the outermost redexes are reduced: a redex is reduced only when its right hand side has reduced to a value (variable or lambda abstraction). Call by need: As normal order, but function applications that would duplicate terms instead name the argument, which is then reduced only "when it is needed". Called in practical contexts "lazy evaluation". In implementations this "name" takes the form of a pointer, with the redex represented by a thunk .   Applicative order is not a normalising strategy. The usual counterexample is as follows: define '''Ω''' = ωω where '''ω''' = λ''x''.''xx'' . This entire expression contains only one redex, namely the whole expression; its reduct is again '''Ω''' . Since this is the only available reduction, '''Ω''' has no normal form (under any evaluation strategy). Using applicative order, the expression '''KIΩ''' = (λ''x''.λ''y''.''x'') (λ''x''.''x'')'''Ω''' is reduced by first reducing '''Ω''' to normal form (since it is the rightmost redex), but since '''Ω''' has no normal form, applicative order fails to find a normal form for '''KIΩ''' .  In contrast, normal order is so called because it always finds a normalising reduction, if one exists. In the above example, '''KIΩ''' reduces under normal order to I , a normal form. A drawback is that redexes in the arguments may be copied, resulting in duplicated computation (for example, (λ''x''.''xx'') ((λ''x''.''x'')''y'') reduces to ((λ''x''.''x'')''y'') ((λ''x''.''x'')''y'') using this strategy; now there are two redexes, so full evaluation needs two more steps, but if the argument had been reduced first, there would now be none).  The positive tradeoff of using applicative order is that it does not cause unnecessary computation, if all arguments are used, because it never substitutes arguments containing redexes and hence never needs to copy them (which would duplicate work). In the above example, in applicative order (λ''x''.''xx'') ((λ''x''.''x'')''y'') reduces first to (λ''x''.''xx'')''y'' and then to the normal order ''yy'' , taking two steps instead of three.  Most purely functional programming languages (notably Miranda and its descendents, including Haskell), and the proof languages of theorem provers , use lazy evaluation , which is essentially the same as call by need. This is like normal order reduction, but call by need manages to avoid the duplication of work inherent in normal order reduction using sharing . In the example given above, (λ''x''.''xx'') ((λ''x''.''x'')''y'') reduces to ((λ''x''.''x'')''y'') ((λ''x''.''x'')''y'') , which has two redexes, but in call by need they are represented using the same object rather than copied, so when one is reduced the other is too.  Syntax definition in BNF  Lambda Calculus has a simple syntax. A Lambda Calculus program has the syntax of an expression where,      Name   BNF   Description       Abstraction   ::= λ .   Anonymous function definition.     Application term   ::=      Application   ::=    A function call.     Item   ::=      Variable   ::=   E.g. x, y, fact, sum, ...     Grouping   ::= ( )   Bracketed expression.     The variable list is defined as,   := | ,    A variable as used by computer scientists has the syntax,   ::=    ::=  ::=    ::= | | _   Mathematicians will sometimes restrict a variable to be a single alphabetic character. When using this convention the comma is omitted from the variable list.  A lambda abstraction has a lower precedence than an application, so;       λ  x   .     y   z   =   λ  x    .   (    y   z   )      formulae-sequence    λ  x       y  z     λ  x      y  z     \lambda x.y\ z=\lambda x.(y\ z)     Applications are left associative;        x    y   z   =    (    x   y   )   z         x  y  z       x  y   z     x\ y\ z=(x\ y)\ z     An abstraction with multiple parameters is equivalent to multiple abstractions of one parameter.        λ  x   ,  y   .   z  =   λ  x    .   λ  y   .  z     formulae-sequence     λ  x   y     z    λ  x      λ  y   z    \lambda x,y.z=\lambda x.\lambda y.z   where,   x is a variable  y is a variable list  z is an expression   Definition as mathematical formulas  The problem of how variables may be renamed is difficult. This definition avoids the problem by substituting all names with canonical names, which are constructed based on the position of the definition of the name in the expression. The approach is analogous to what a compiler does, but has been adapted to work within the constraints of mathematics.  Semantics  The execution of a lambda expression proceeds using the following reductions and transformations,   alpha conversion -      alpha  -  con    (  a  )    →   canonym   [  A  ,  P  ]    =   canonym   [   a   [  A  ]    ,  P  ]         normal-→     alpha  con   a    canonym  A  P         canonym    a   delimited-[]  A    P      \operatorname{alpha-con}(a)\to\operatorname{canonym}[A,P]=\operatorname{%
 canonym}[a[A],P]     beta reduction -     beta  -  redex    [  λ  p  .   b   v  ]   =  b   [  p  :=  v  ]      fragments    beta  redex    fragments  normal-[  λ  p  normal-.  b  v  normal-]    b   fragments  normal-[  p  assign  v  normal-]     \operatorname{beta-redex}[\lambda p.b\ v]=b[p:=v]     eta reduction -    x  ∉  FV   (  f  )   →   eta  -  redex    [  λ  x  .   (   f   x  )   ]   =  f     fragments  x   FV   fragments  normal-(  f  normal-)   normal-→    eta  redex    fragments  normal-[  λ  x  normal-.   fragments  normal-(  f  x  normal-)   normal-]    f    x\not\in\operatorname{FV}(f)\to\operatorname{eta-redex}[\lambda x.(f\ x)]=f      where,   canonym is a renaming of a lambda expression to give the expression standard names, based on the position of the name in the expression.  Substitution Operator ,    b   [  p  :=  v  ]      fragments  b   fragments  normal-[  p  assign  v  normal-]     b[p:=v]   is the substitution of the name   p   p   p   by the lambda expression   v   v   v   in lambda expression   b   b   b   .  Free Variable Set     FV   (  f  )      FV  f    \operatorname{FV}(f)   is the set of variables that do not belong to a lambda abstraction in   f   f   f   .   Execution is performing beta reductions and eta reductions on sub expressions in the canonym of a lambda expression until the result is a lambda function (abstraction) in the normal form .  All alpha conversions of a lambda expression are considered to be equivalent.  Canonym - Canonical Names  Canonym is a function that takes a lambda expression and renames all names canonically, based on their positions in the expression. This might be implemented as,        canonym   [  L  ,  Q  ]    =   canonym   [  L  ,  O  ,  Q  ]         canonym  L  Q    canonym  L  O  Q     \operatorname{canonym}[L,Q]=\operatorname{canonym}[L,O,Q]         canonym   [  λ  p  .  b  ,  M  ,  Q  ]   =  λ  name   (  Q  )   .  canonym   [  b  ,  M   [  p  :=  Q  ]   ,  Q  +  N  ]      fragments  canonym   fragments  normal-[  λ  p  normal-.  b  normal-,  M  normal-,  Q  normal-]    λ  name   fragments  normal-(  Q  normal-)   normal-.  canonym   fragments  normal-[  b  normal-,  M   fragments  normal-[  p  assign  Q  normal-]   normal-,  Q   N  normal-]     \operatorname{canonym}[\lambda p.b,M,Q]=\lambda\operatorname{name}(Q).%
 \operatorname{canonym}[b,M[p:=Q],Q+N]          canonym   [    X   Y   ,  x  ,  Q  ]    =    canonym   [  X  ,  x  ,   Q  +  F   ]     canonym   [  Y  ,  x  ,   E  +  S   ]          canonym    X  Y   x  Q      canonym  X  x    Q  F     canonym  Y  x    E  S       \operatorname{canonym}[X\ Y,x,Q]=\operatorname{canonym}[X,x,Q+F]\ %
 \operatorname{canonym}[Y,x,E+S]          canonym   [  x  ,  M  ,  Q  ]    =   name   (   M   [  x  ]    )         canonym  x  M  Q    name    M   delimited-[]  x       \operatorname{canonym}[x,M,Q]=\operatorname{name}(M[x])      Where, N is the string "N", F is the string "F", S is the string "S", + is concatenation, and "name" converts a string into a name  Map Operators  Map from one value to another if the value is in the map. O is the empty map.        O   [  x  ]    =  x        O   delimited-[]  x    x    O[x]=x         M   [  x  :=  y  ]    [  x  ]   =  y     fragments  M   fragments  normal-[  x  assign  y  normal-]    fragments  normal-[  x  normal-]    y    M[x:=y][x]=y         x  ≠  z  →  M   [  x  :=  y  ]    [  z  ]   =  M   [  z  ]      fragments  x   z  normal-→  M   fragments  normal-[  x  assign  y  normal-]    fragments  normal-[  z  normal-]    M   fragments  normal-[  z  normal-]     x\neq z\to M[x:=y][z]=M[z]      Substitution Operator  If L is a lambda expression, x is a name, and y is a lambda expression;    L   [  x  :=  y  ]      fragments  L   fragments  normal-[  x  assign  y  normal-]     L[x:=y]   means substitute x by y in L. The rules are,        (  λ  p  .  b  )    [  x  :=  y  ]   =  λ  p  .  b   [  x  :=  y  ]      fragments   fragments  normal-(  λ  p  normal-.  b  normal-)    fragments  normal-[  x  assign  y  normal-]    λ  p  normal-.  b   fragments  normal-[  x  assign  y  normal-]     (\lambda p.b)[x:=y]=\lambda p.b[x:=y]          (   X   Y  )    [  x  :=  y  ]   =  X   [  x  :=  y  ]   Y   [  x  :=  y  ]      fragments   fragments  normal-(  X  Y  normal-)    fragments  normal-[  x  assign  y  normal-]    X   fragments  normal-[  x  assign  y  normal-]   Y   fragments  normal-[  x  assign  y  normal-]     (X\ Y)[x:=y]=X[x:=y]\ Y[x:=y]         z  =  x  →   (  z  )    [  x  :=  y  ]   =  y     fragments  z   x  normal-→   fragments  normal-(  z  normal-)    fragments  normal-[  x  assign  y  normal-]    y    z=x\to(z)[x:=y]=y         z  ≠  x  →   (  z  )    [  x  :=  y  ]   =  z     fragments  z   x  normal-→   fragments  normal-(  z  normal-)    fragments  normal-[  x  assign  y  normal-]    z    z\neq x\to(z)[x:=y]=z      Note that rule 1 must be modified if it is to be used on non canonically renamed lambda expressions. See Changes to the substitution operator .  Free and Bound Variable Sets  The set of free variables of a lambda expression, M, is denoted as FV(M). This is the set of variable names that have instances not bound (used) in a lambda abstraction, within the lambda expression. They are the variable names that may be bound to formal parameter variables from outside the lambda expression.  The set of bound variables of a lambda expression, M, is denoted as BV(M). This is the set of variable names that have instances bound (used) in a lambda abstraction, within the lambda expression.  The rules for the two sets are given below. 7          FV   (  M  )      FV  M    \operatorname{FV}(M)   - Free Variable Set   Comment       BV   (  M  )      BV  M    \operatorname{BV}(M)   - Bound Variable Set   Comment            FV   (  x  )    =   {  x  }        FV  x    x     \operatorname{FV}(x)=\{x\}      where x is a variable        BV   (  x  )    =   {  }        BV  x      \operatorname{BV}(x)=\{\}      where x is a variable         FV   (  λ  x  .  M  )   =  FV   (  M  )   ∩  ¬   {  x  }      fragments  FV   fragments  normal-(  λ  x  normal-.  M  normal-)    FV   fragments  normal-(  M  normal-)      fragments  normal-{  x  normal-}     \operatorname{FV}(\lambda x.M)=\operatorname{FV}(M)\cap\neg\{x\}      Free variables of M excluding x       BV   (  λ  x  .  M  )   =  BV   (  M  )   ∪   {  x  }      fragments  BV   fragments  normal-(  λ  x  normal-.  M  normal-)    BV   fragments  normal-(  M  normal-)     fragments  normal-{  x  normal-}     \operatorname{BV}(\lambda x.M)=\operatorname{BV}(M)\cup\{x\}      Bound variables of M plus x.          FV   (    M   N   )    =    FV   (  M  )    ∪   FV   (  N  )          FV    M  N       FV  M    FV  N      \operatorname{FV}(M\ N)=\operatorname{FV}(M)\cup\operatorname{FV}(N)      Combine the free variables from the function and the parameter        BV   (    M   N   )    =    BV   (  M  )    ∪   BV   (  N  )          BV    M  N       BV  M    BV  N      \operatorname{BV}(M\ N)=\operatorname{BV}(M)\cup\operatorname{BV}(N)      Combine the bound variables from the function and the parameter     Usage;   The Free Variable Set, FV is used above in the definition of the eta-reduction .  The Bound Variable Set, BV, is used in the rule for beta-redex of non canonical lambda expression.   Evaluation strategy  This mathematical definition is structured so that it represents the result, and not the way it gets calculated. However the result may be different between lazy and eager evaluation. This difference is described in the evaluation formulas.  The definitions given here assume that the first definition that matches the lambda expression will be used. This convention is used to make the definition more readable. Otherwise some if conditions would be required to make the definition precise.  Running or evaluating a lambda expression L is,      eval   [   canonym   [  L  ]    ,  Q  ]      eval   canonym  L   Q    \operatorname{eval}[\operatorname{canonym}[L],Q]     Where Q is a name prefix possibly an empty string.  where eval is defined by,        eval   [    x   y   ]    =   eval   [   apply   [    eval   [  x  ]     strategy   [  y  ]     ]    ]         eval    x  y     eval   apply     eval  x    strategy  y        \operatorname{eval}[x\ y]=\operatorname{eval}[\operatorname{apply}[%
 \operatorname{eval}[x]\ \operatorname{strategy}[y]]]         apply   [   (  λ  x  .  y  )   z  ]   =  canonym   [   beta  -  redex    [   (  λ  x  .  y  )   z  ]   ,  x  ]      fragments  apply   fragments  normal-[   fragments  normal-(  λ  x  normal-.  y  normal-)   z  normal-]    canonym   fragments  normal-[    beta  redex    fragments  normal-[   fragments  normal-(  λ  x  normal-.  y  normal-)   z  normal-]   normal-,  x  normal-]     \operatorname{apply}[(\lambda x.y)\ z]=\operatorname{canonym}[\operatorname{%
 beta-redex}[(\lambda x.y)\ z],x]          apply   [  x  ]    =  x       apply  x   x    \operatorname{apply}[x]=x   If x does match the above.      eval   [  λ  x  .   (   f   x  )   ]   =  eval   [   eta  -  redex    [  λ  x  .   (   f   x  )   ]   ]      fragments  eval   fragments  normal-[  λ  x  normal-.   fragments  normal-(  f  x  normal-)   normal-]    eval   fragments  normal-[    eta  redex    fragments  normal-[  λ  x  normal-.   fragments  normal-(  f  x  normal-)   normal-]   normal-]     \operatorname{eval}[\lambda x.(f\ x)]=\operatorname{eval}[\operatorname{eta-%
 redex}[\lambda x.(f\ x)]]          eval   [  L  ]    =  L       eval  L   L    \operatorname{eval}[L]=L          lazy   [  X  ]    =  X       lazy  X   X    \operatorname{lazy}[X]=X          eager   [  X  ]    =   eval   [  X  ]         eager  X    eval  X     \operatorname{eager}[X]=\operatorname{eval}[X]      Then the evaluation strategy may be chosen as either,       strategy  =  lazy      strategy  lazy    \operatorname{strategy}=\operatorname{lazy}         strategy  =  eager      strategy  eager    \operatorname{strategy}=\operatorname{eager}      The result may be different depending on the strategy used. Eager evaluation will apply all reductions possible, leaving the result in normal form, while lazy evaluation will omit some reductions in parameters, leaving the result in "weak head normal form".  Normal form  All reductions that can be applied have been applied. This is the result obtained from applying eager evaluation.       normal   [  λ  x  .  y  )   z  ]  =  false     fragments  normal   fragments  normal-[  λ  x  normal-.  y  normal-)   z  normal-]   false    \operatorname{normal}[\lambda x.y)\ z]=\operatorname{false}         normal   [  λ  x  .   (   f   x  )   ]   =  false     fragments  normal   fragments  normal-[  λ  x  normal-.   fragments  normal-(  f  x  normal-)   normal-]    false    \operatorname{normal}[\lambda x.(f\ x)]=\operatorname{false}          normal   [    x   y   ]    =     normal   [  x  ]    and    normal   [  y  ]          normal    x  y        normal  x   italic- and    normal  y      \operatorname{normal}[x\ y]=\operatorname{normal}[x]\and\operatorname{normal}[y]      In all other cases,        normal   [  x  ]    =  true       normal  x   true    \operatorname{normal}[x]=\operatorname{true}      Weak head normal form  Reductions to the function (the head) have been applied, but not all reductions to the parameter have been applied. This is the result obtained from applying eager evaluation.       whnf   [  λ  x  .  y  )   z  ]  =  false     fragments  whnf   fragments  normal-[  λ  x  normal-.  y  normal-)   z  normal-]   false    \operatorname{whnf}[\lambda x.y)\ z]=\operatorname{false}         whnf   [  λ  x  .   (   f   x  )   ]   =  false     fragments  whnf   fragments  normal-[  λ  x  normal-.   fragments  normal-(  f  x  normal-)   normal-]    false    \operatorname{whnf}[\lambda x.(f\ x)]=\operatorname{false}          whnf   [    x   y   ]    =   whnf   [  x  ]         whnf    x  y     whnf  x     \operatorname{whnf}[x\ y]=\operatorname{whnf}[x]      In all other cases,        whnf   [  x  ]    =  true       whnf  x   true    \operatorname{whnf}[x]=\operatorname{true}      Derivation of standard from the math definition  The standard definition of Lambda Calculus uses some definitions which may be considered as theorems, which can be proved based on the definition as mathematical formulas .  The canonical naming definition deals with the problem of variable identity by constructing a unique name for each variable based on the position of the lambda abstraction for the variable name in the expression.  This definition introduces the rules used in the standard definition and relates explains them in terms of the canonical renaming definition.  Free and bound variables  The lambda abstraction operator, λ, takes a formal parameter variable and a body expression. When evaluated the formal parameter variable is identified with the value of the actual parameter.  Variables in a lambda expression may either be "bound" or "free". Bound variables are variable names that are already attached to formal parameter variables in the expression.  The formal parameter variable is said to bind the variable name wherever it occurs free in the body. Variable (names) that have already been matched to formal parameter variable are said to be bound . All other variables in the expression are called free .  For example, in the following expression y is a bound variable and x is free     λ  y   .    x    x   y      formulae-sequence    λ  y     x  x  y     \lambda y.x\ x\ y   . Also note that a variable is bound by its "nearest" lambda abstraction. In the following example the single occurrence of x in the expression is bound by the second lambda    λ  x  .   y    (  λ  x  .   z   x  )      fragments  λ  x  normal-.  y   fragments  normal-(  λ  x  normal-.  z  x  normal-)     \lambda x.y\ (\lambda x.z\ x)     Changes to the substitution operator  In the definition of the Substitution Operator the rule,        (  λ  p  .  b  )    [  x  :=  y  ]   =  λ  p  .  b   [  x  :=  y  ]      fragments   fragments  normal-(  λ  p  normal-.  b  normal-)    fragments  normal-[  x  assign  y  normal-]    λ  p  normal-.  b   fragments  normal-[  x  assign  y  normal-]     (\lambda p.b)[x:=y]=\lambda p.b[x:=y]      must be replaced with,        (  λ  x  .  b  )    [  x  :=  y  ]   =  λ  x  .  b     fragments   fragments  normal-(  λ  x  normal-.  b  normal-)    fragments  normal-[  x  assign  y  normal-]    λ  x  normal-.  b    (\lambda x.b)[x:=y]=\lambda x.b         z  ≠   x   →   (  λ  z  .  b  )    [  x  :=  y  ]   =  λ  z  .  b   [  x  :=  y  ]      fragments  z   x  normal-→   fragments  normal-(  λ  z  normal-.  b  normal-)    fragments  normal-[  x  assign  y  normal-]    λ  z  normal-.  b   fragments  normal-[  x  assign  y  normal-]     z\neq x\ \to(\lambda z.b)[x:=y]=\lambda z.b[x:=y]      This is to stop bound variables with the same name being substituted. This would not have occurred in a canonically renamed lambda expression.  For example the previous rules would have wrongly translated,       (  λ  x  .   x   z  )    [  x  :=  y  ]   =   (  λ  x  .   y   z  )      fragments   fragments  normal-(  λ  x  normal-.  x  z  normal-)    fragments  normal-[  x  assign  y  normal-]     fragments  normal-(  λ  x  normal-.  y  z  normal-)     (\lambda x.x\ z)[x:=y]=(\lambda x.y\ z)     The new rules block this substitution so that it remains as,       (  λ  x  .   x   z  )    [  x  :=  y  ]   =   (  λ  x  .   x   z  )      fragments   fragments  normal-(  λ  x  normal-.  x  z  normal-)    fragments  normal-[  x  assign  y  normal-]     fragments  normal-(  λ  x  normal-.  x  z  normal-)     (\lambda x.x\ z)[x:=y]=(\lambda x.x\ z)     Transformation  The meaning of lambda expressions is defined by how expressions can be transformed or reduced. 8  There are three kinds of transformation:   α-conversion : changing bound variables ( alpha );  β-reduction : applying functions to their arguments ( beta ), calling functions;  η-conversion : which captures a notion of extensionality ( eta ).   We also speak of the resulting equivalences: two expressions are β-equivalent , if they can be β-converted into the same expression, and α/η-equivalence are defined similarly.  The term redex , short for reducible expression , refers to subterms that can be reduced by one of the reduction rules.  Alpha Conversion  Alpha-conversion, sometimes known as alpha-renaming, 9 allows bound variable names to be changed. For example, alpha-conversion of     λ  x   .  x     formulae-sequence    λ  x   x    \lambda x.x   might give     λ  y   .  y     formulae-sequence    λ  y   y    \lambda y.y   . Terms that differ only by alpha-conversion are called α-equivalent .  In an alpha conversion, names may be substituted for new names if the new name is not free in the body, as this would lead to the capture of free variables .       (  y  ∉  F  V   (  b  )   and  a   (  λ  x  .  b  )   =  λ  y  .  b   [  x  :=  y  ]   )   →   alpha  -  con    (  a  )      fragments   fragments  normal-(  y   F  V   fragments  normal-(  b  normal-)   and  a   fragments  normal-(  λ  x  normal-.  b  normal-)    λ  y  normal-.  b   fragments  normal-[  x  assign  y  normal-]   normal-)   normal-→    alpha  con    fragments  normal-(  a  normal-)     (y\not\in FV(b)\and a(\lambda x.b)=\lambda y.b[x:=y])\to\operatorname{alpha-%
 con}(a)     Note that the substitution will not recurse into the body of lambda expressions with formal parameter   x   x   x   because of the change to the substitution operator described above.  See example;      Alpha conversion   Lambda Expression   Canonically named   Comment             λ  z   .   λ  y   .   (    z   y   )      formulae-sequence    λ  z     λ  y     z  y     \lambda z.\lambda y.(z\ y)           λ  P   .   λ  PN   .   (   P  PN   )      formulae-sequence    λ  normal-P     λ  PN    normal-P  PN     \lambda\operatorname{P}.\lambda\operatorname{PN}.(\operatorname{P}%
 \operatorname{PN})      Original expressions.     correctly rename y to k, (because k is not used in the body)        λ  z   .   λ  k   .   (    z   k   )      formulae-sequence    λ  z     λ  k     z  k     \lambda z.\lambda k.(z\ k)           λ  P   .   λ  PN   .   (   P  PN   )      formulae-sequence    λ  normal-P     λ  PN    normal-P  PN     \lambda\operatorname{P}.\lambda\operatorname{PN}.(\operatorname{P}%
 \operatorname{PN})      No change to canonical renamed expression.     naively rename y to z, (wrong because z free in     λ  y   .   (    z   y   )      formulae-sequence    λ  y     z  y     \lambda y.(z\ y)   )        λ  z   .   λ  z   .   (    z   z   )      formulae-sequence    λ  z     λ  z     z  z     \lambda z.\lambda z.(z\ z)           λ  P   .   λ  PN   .   (    \color   R  e  d   PN  PN    )      formulae-sequence    λ  normal-P     λ  PN     \color  R  e  d   PN  PN      \lambda\operatorname{P}.\lambda\operatorname{PN}.({\color{Red}\operatorname{PN%
 }}\operatorname{PN})         z   z   z   is captured.     Beta reduction (capture avoiding)  Beta-reduction captures the idea of function application (also called a function call), and implements the substitution of the actual parameter expression for the formal parameter variable. Beta-reduction is defined in terms of substitution.  If no variable names are free in the actual parameter and bound in the body, beta reduction may be performed on the lambda abstraction without canonical renaming.       (  ∀  z  :  z  ∉  F  V   (  y  )   z  ∉  B  V   (  b  )   )   →   beta  -  redex    [  λ  x  .   b   y  ]   =  b   [  x  :=  y  ]      fragments   fragments  normal-(  for-all  z  normal-:  z   F  V   fragments  normal-(  y  normal-)   z   B  V   fragments  normal-(  b  normal-)   normal-)   normal-→    beta  redex    fragments  normal-[  λ  x  normal-.  b  y  normal-]    b   fragments  normal-[  x  assign  y  normal-]     (\forall z:z\not\in FV(y)z\not\in BV(b))\to\operatorname{beta-redex}[\lambda x%
 .b\ y]=b[x:=y]     Alpha renaming may be used on   b   b   b   to rename names that are free in   y   y   y   but bound in   b   b   b   , to meet the pre-condition for this transformation.  See example;      Beta Reduction   Lambda Expression   Canonically named   Comment            (  λ  x  .  λ  y  .   (  λ  z  .   (  λ  x  .   z   x  )    (  λ  y  .   z   y  )   )    (   x   y  )   )     fragments  normal-(  λ  x  normal-.  λ  y  normal-.   fragments  normal-(  λ  z  normal-.   fragments  normal-(  λ  x  normal-.  z  x  normal-)    fragments  normal-(  λ  y  normal-.  z  y  normal-)   normal-)    fragments  normal-(  x  y  normal-)   normal-)    (\lambda x.\lambda y.(\lambda z.(\lambda x.z\ x)(\lambda y.z\ y))(x\ y))          (  λ  P  .  λ  PN  .   (  λ  PNF  .   (  λ  PNFNF  .  PNF  PNFNF  )    (  λ  PNFNS  .  PNF  PNFNS  )   )    (  P  PN  )   )     fragments  normal-(  λ  normal-P  normal-.  λ  PN  normal-.   fragments  normal-(  λ  PNF  normal-.   fragments  normal-(  λ  PNFNF  normal-.  PNF  PNFNF  normal-)    fragments  normal-(  λ  PNFNS  normal-.  PNF  PNFNS  normal-)   normal-)    fragments  normal-(  normal-P  PN  normal-)   normal-)    (\lambda\operatorname{P}.\lambda\operatorname{PN}.(\lambda\operatorname{PNF}.(%
 \lambda\operatorname{PNFNF}.\operatorname{PNF}\operatorname{PNFNF})(\lambda%
 \operatorname{PNFNS}.\operatorname{PNF}\operatorname{PNFNS}))(\operatorname{P}%
 \operatorname{PN}))      Original expressions.     Naive beta 1,       (  λ  x  .  λ  y  .   (   (  λ  x  .   (   x   y  )   x  )    (  λ  y  .   (   x   y  )   y  )   )   )     fragments  normal-(  λ  x  normal-.  λ  y  normal-.   fragments  normal-(   fragments  normal-(  λ  x  normal-.   fragments  normal-(  x  y  normal-)   x  normal-)    fragments  normal-(  λ  y  normal-.   fragments  normal-(  x  y  normal-)   y  normal-)   normal-)   normal-)    (\lambda x.\lambda y.((\lambda x.(x\ y)x)(\lambda y.(x\ y)y)))         Canonical       (  λ  P  .  λ  PN  .   (   (  λ  PNF  .   (   \color   B  l  u  e  P  PN  )   PNF  )    (  λ  PNS  .   (  P   \color   B  l  u  e  PN  )   PNS  )   )   )     fragments  normal-(  λ  normal-P  normal-.  λ  PN  normal-.   fragments  normal-(   fragments  normal-(  λ  PNF  normal-.   fragments  normal-(  \color  B  l  u  e  normal-P  PN  normal-)   PNF  normal-)    fragments  normal-(  λ  PNS  normal-.   fragments  normal-(  normal-P  \color  B  l  u  e  PN  normal-)   PNS  normal-)   normal-)   normal-)    (\lambda\operatorname{P}.\lambda\operatorname{PN}.((\lambda\operatorname{PNF}.%
 ({\color{Blue}\operatorname{P}}\operatorname{PN})\operatorname{PNF})(\lambda%
 \operatorname{PNS}.(\operatorname{P}{\color{Blue}\operatorname{PN}})%
 \operatorname{PNS})))        Natural       (  λ  P  .  λ  PN  .   (   (  λ  PNF  .   (   \color   R  e  d  PNF  PN  )   PNF  )    (  λ  PNS  .   (  P   \color   R  e  d  PNS  )   PNS  )   )   )     fragments  normal-(  λ  normal-P  normal-.  λ  PN  normal-.   fragments  normal-(   fragments  normal-(  λ  PNF  normal-.   fragments  normal-(  \color  R  e  d  PNF  PN  normal-)   PNF  normal-)    fragments  normal-(  λ  PNS  normal-.   fragments  normal-(  normal-P  \color  R  e  d  PNS  normal-)   PNS  normal-)   normal-)   normal-)    (\lambda\operatorname{P}.\lambda\operatorname{PN}.((\lambda\operatorname{PNF}.%
 ({\color{Red}\operatorname{PNF}}\operatorname{PN})\operatorname{PNF})(\lambda%
 \operatorname{PNS}.(\operatorname{P}{\color{Red}\operatorname{PNS})}%
 \operatorname{PNS})))         x (P) and y (PN) have been captured in the substitution.     Alpha rename inner, x -> a, y -> b       (  λ  x  .  λ  y  .   (  λ  z  .   (  λ  x  .   z   a  )    (  λ  b  .   z   b  )   )    (   x   y  )   )     fragments  normal-(  λ  x  normal-.  λ  y  normal-.   fragments  normal-(  λ  z  normal-.   fragments  normal-(  λ  x  normal-.  z  a  normal-)    fragments  normal-(  λ  b  normal-.  z  b  normal-)   normal-)    fragments  normal-(  x  y  normal-)   normal-)    (\lambda x.\lambda y.(\lambda z.(\lambda x.z\ a)(\lambda b.z\ b))(x\ y))          (  λ  P  .  λ  PN  .   (  λ  PNF  .   (  λ  PNFNF  .  PNF  PNFNF  )    (  λ  PNFNS  .  PNF  PNFNS  )   )    (  P  PN  )   )     fragments  normal-(  λ  normal-P  normal-.  λ  PN  normal-.   fragments  normal-(  λ  PNF  normal-.   fragments  normal-(  λ  PNFNF  normal-.  PNF  PNFNF  normal-)    fragments  normal-(  λ  PNFNS  normal-.  PNF  PNFNS  normal-)   normal-)    fragments  normal-(  normal-P  PN  normal-)   normal-)    (\lambda\operatorname{P}.\lambda\operatorname{PN}.(\lambda\operatorname{PNF}.(%
 \lambda\operatorname{PNFNF}.\operatorname{PNF}\operatorname{PNFNF})(\lambda%
 \operatorname{PNFNS}.\operatorname{PNF}\operatorname{PNFNS}))(\operatorname{P}%
 \operatorname{PN}))         Beta 2,       (  λ  x  .  λ  y  .   (   (  λ  a  .   (   x   y  )   a  )    (  λ  b  .   (   x   y  )   b  )   )   )     fragments  normal-(  λ  x  normal-.  λ  y  normal-.   fragments  normal-(   fragments  normal-(  λ  a  normal-.   fragments  normal-(  x  y  normal-)   a  normal-)    fragments  normal-(  λ  b  normal-.   fragments  normal-(  x  y  normal-)   b  normal-)   normal-)   normal-)    (\lambda x.\lambda y.((\lambda a.(x\ y)a)(\lambda b.(x\ y)b)))         Canonical       (  λ  P  .  λ  PN  .   (   (  λ  PNF  .   (  P  PN  )   PNF  )    (  λ  PNS  .   (  P  PN  )   PNS  )   )   )     fragments  normal-(  λ  normal-P  normal-.  λ  PN  normal-.   fragments  normal-(   fragments  normal-(  λ  PNF  normal-.   fragments  normal-(  normal-P  PN  normal-)   PNF  normal-)    fragments  normal-(  λ  PNS  normal-.   fragments  normal-(  normal-P  PN  normal-)   PNS  normal-)   normal-)   normal-)    (\lambda\operatorname{P}.\lambda\operatorname{PN}.((\lambda\operatorname{PNF}.%
 (\operatorname{P}\operatorname{PN})\operatorname{PNF})(\lambda\operatorname{%
 PNS}.(\operatorname{P}\operatorname{PN})\operatorname{PNS})))        Natural       (  λ  P  .  λ  PN  .   (   (  λ  PNF  .   (  P  PN  )   PNF  )    (  λ  PNS  .   (  P  PN  )   PNS  )   )   )     fragments  normal-(  λ  normal-P  normal-.  λ  PN  normal-.   fragments  normal-(   fragments  normal-(  λ  PNF  normal-.   fragments  normal-(  normal-P  PN  normal-)   PNF  normal-)    fragments  normal-(  λ  PNS  normal-.   fragments  normal-(  normal-P  PN  normal-)   PNS  normal-)   normal-)   normal-)    (\lambda\operatorname{P}.\lambda\operatorname{PN}.((\lambda\operatorname{PNF}.%
 (\operatorname{P}\operatorname{PN})\operatorname{PNF})(\lambda\operatorname{%
 PNS}.(\operatorname{P}\operatorname{PN})\operatorname{PNS})))         x and y not captured.           (   (  λ  x  .   z   x  )    (  λ  y  .   z   y  )   )    [  z  :=   (   x   y  )   ]      fragments   fragments  normal-(   fragments  normal-(  λ  x  normal-.  z  x  normal-)    fragments  normal-(  λ  y  normal-.  z  y  normal-)   normal-)    fragments  normal-[  z  assign   fragments  normal-(  x  y  normal-)   normal-]     ((\lambda x.z\ x)(\lambda y.z\ y))[z:=(x\ y)]          (   (  λ  a  .   z   a  )    (  λ  b  .   z   b  )   )    [  z  :=   (   x   y  )   ]      fragments   fragments  normal-(   fragments  normal-(  λ  a  normal-.  z  a  normal-)    fragments  normal-(  λ  b  normal-.  z  b  normal-)   normal-)    fragments  normal-[  z  assign   fragments  normal-(  x  y  normal-)   normal-]     ((\lambda a.z\ a)(\lambda b.z\ b))[z:=(x\ y)]      In this example,   In the beta-redex,  The free variables are,     F  V   (    x   y   )    =   {  x  ,  y  }         F  V    x  y     x  y     FV(x\ y)=\{x,y\}     The bound variables are,    B  V   (   (  λ  x  .   z   x  )    (  λ  y  .   z   y  )   )   =   {  x  ,  y  }      fragments  B  V   fragments  normal-(   fragments  normal-(  λ  x  normal-.  z  x  normal-)    fragments  normal-(  λ  y  normal-.  z  y  normal-)   normal-)     fragments  normal-{  x  normal-,  y  normal-}     BV((\lambda x.z\ x)(\lambda y.z\ y))=\{x,y\}      The naive beta-redex changed the meaning of the expression because x and y from the actual parameter became captured when the expressions were substituted in the inner abstractions.  The alpha renaming removed the problem by changing the names of x and y in the inner abstraction so that they are distinct from the names of x and y in the actual parameter.  The free variables are,     FV   (    x   y   )    =   {  x  ,  y  }        FV    x  y     x  y     \operatorname{FV}(x\ y)=\{x,y\}     The bound variables are,    BV   (   (  λ  a  .   z   a  )    (  λ  b  .   z   b  )   )   =   {  a  ,  b  }      fragments  BV   fragments  normal-(   fragments  normal-(  λ  a  normal-.  z  a  normal-)    fragments  normal-(  λ  b  normal-.  z  b  normal-)   normal-)     fragments  normal-{  a  normal-,  b  normal-}     \operatorname{BV}((\lambda a.z\ a)(\lambda b.z\ b))=\{a,b\}      The beta-redex then proceeded with the intended meaning.   Eta reduction  Eta-conversion expresses the idea of extensionality , which in this context is that two functions are the same if and only if they give the same result for all arguments.  Eta reduction may be used without change on lambda expressions that are not canonically renamed.      x  ∉  FV   (  f  )   →   eta  -  redex    [  λ  x  .   (  f  x  )   ]   =  f     fragments  x   FV   fragments  normal-(  f  normal-)   normal-→    eta  redex    fragments  normal-[  λ  x  normal-.   fragments  normal-(  f  x  normal-)   normal-]    f    x\not\in\operatorname{FV}(f)\to\operatorname{eta-redex}[\lambda x.(fx)]=f     The problem with using an eta-redex when f has free variables is shown in this example,      Reduction   Lambda expression   Beta-reduction             (  λ  x  .   (  λ  y  .   y   x  )   x  )   a     fragments   fragments  normal-(  λ  x  normal-.   fragments  normal-(  λ  y  normal-.  y  x  normal-)   x  normal-)   a    (\lambda x.(\lambda y.y\ x)\ x)\ a           λ  a   .    a   a      formulae-sequence    λ  a     a  a     \lambda a.a\ a        Naive eta-reduction        (  λ  y  .   y   x  )   a     fragments   fragments  normal-(  λ  y  normal-.  y  x  normal-)   a    (\lambda y.y\ x)\ a           λ  a   .    a   x      formulae-sequence    λ  a     a  x     \lambda a.a\ x        This improper use of eta-reduction changes the meaning by leaving   x   x   x   in     λ  y   .    y   x      formulae-sequence    λ  y     y  x     \lambda y.y\ x   unsubstituted.  See also   Lambda Calculus   References  "  Category:Lambda calculus     ↩  ↩  ↩  ↩  de Queiroz, Ruy J.G.B. " A Proof-Theoretic Account of Programming and the Role of Reduction Rules. " Dialectica  42 (4), pages 265-282, 1988. ↩  ↩        