<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1069">Non-commutative cryptography</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Non-commutative cryptography</h1>
<hr/>

<p><strong>Non-commutative cryptography</strong> is the area of <a class="uri" href="cryptology" title="wikilink">cryptology</a> where the <a href="cryptographic_primitive" title="wikilink">cryptographic primitives</a>, methods and systems are based on <a href="algebraic_structure" title="wikilink">algebraic structures</a> like <a href="semigroup" title="wikilink">semigroups</a>, <a href="Group_(mathematics)" title="wikilink">groups</a> and <a href="Ring_(mathematics)" title="wikilink">rings</a> which are <a class="uri" href="non-commutative" title="wikilink">non-commutative</a>. One of the earliest applications of a non-commutative algebraic structure for cryptographic purposes was the use of <a href="braid_group" title="wikilink">braid groups</a> to develop cryptographic protocols. Later several other non-commutative structures like <a href="Thompson_groups" title="wikilink">Thompson groups</a>, <a href="polycyclic_group" title="wikilink">polycyclic groups</a>, <a href="Grigorchuk_group" title="wikilink">Grigorchuk groups</a>, and <a href="matrix_group" title="wikilink">matrix groups</a> have been identified as potential candidates for cryptographic applications. In contrast to non-commutative cryptography, the currently widely used <a href="public-key_cryptosystem" title="wikilink">public-key cryptosystems</a> like <a href="RSA_(cryptosystem)" title="wikilink">RSA cryptosystem</a>, <a href="Diffie-Hellman_key_exchange" title="wikilink">Diffie-Hellman key exchange</a> and <a href="elliptic_curve_cryptography" title="wikilink">elliptic curve cryptography</a> are based on number theory and hence depend on commutative algebraic structures.</p>

<p>Non-commutative cryptographic protocols have been developed for solving various cryptographic problems like <a href="key_exchange" title="wikilink">key exchange</a>, <a class="uri" href="encryption" title="wikilink">encryption</a>-decryption, and <a class="uri" href="authentication" title="wikilink">authentication</a>. These protocols are very similar to the corresponding protocols in the commutative case.</p>
<h2 id="some-non-commutative-cryptographic-protocols">Some non-commutative cryptographic protocols</h2>

<p>In these protocols it would be assumed that <em>G</em> is a <a href="non-abelian_group" title="wikilink">non-abelian</a> group. If <em>w</em> and <em>a</em> are elements of <em>G</em> the notation <em>w</em><sup><em>a</em></sup> would indicate the element <em>a<sup>−1</sup>wa</em>.</p>
<h3 id="protocols-for-key-exchange">Protocols for key exchange</h3>
<h4 id="protocol-due-to-ko-lee-et.-al.">Protocol due to Ko, Lee, et. al.</h4>

<p>The following protocol due to Ko, Lee, et al., establishes a common <a href="secret_key" title="wikilink">secret key</a> <em>K</em> for <a href="Alice_and_Bob" title="wikilink">Alice and Bob</a>.</p>
<ol>
<li>An element <em>w</em> of <em>G</em> is published.</li>
<li>Two <a href="subgroup" title="wikilink">subgroups</a> <em>A</em> and <em>B</em> of <em>G</em> such that <em>ab</em> = <em>ba</em> for all <em>a</em> in <em>A</em> and <em>b</em> in <em>B</em> are published.</li>
<li>Alice chooses an element <em>a</em> from <em>A</em> and sends <em>w<sup>a</sup></em> to Bob. Alice keeps <em>a</em> private.</li>
<li>Bob chooses an element <em>b</em> from <em>B</em> and sends <em>w<sup>b</sup></em> to Alice. Bob keeps <em>b</em> private.</li>
<li>Alice computes <em>K</em> = (<em>w</em><sup><em>b</em></sup>)<sup>a</sup> = <em>w</em><sup><em>ba</em></sup>.</li>
<li>Bob computes <em>K</em>' = (<em>w</em><sup><em>a</em></sup>)<sup><em>b</em></sup>=<em>w</em><sup><em>ab</em></sup>.</li>
<li>Since <em>ab</em> = <em>ba</em>, <em>K</em> = <em>K</em>'. Alice and Bob share the common secret key <em>K</em>.</li>
</ol>
<h4 id="anshel-anshel-goldfeld-protocol">Anshel-Anshel-Goldfeld protocol</h4>

<p>This a key exchange protocol using a non-abelian group <em>G</em>. It is significant because it does not require two commuting subgroups <em>A</em> and <em>B</em> of <em>G</em> as in the case of the protocol due to Ko, Lee, et al.</p>
<ol>
<li>Elements <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, . . . , <em>a</em><sub><em>k</em></sub>, <em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, . . . , <em>b</em><sub><em>m</em></sub> from <em>G</em> are selected and published.</li>
<li>Alice picks a private <em>x</em> in <em>G</em> as a <a href="Word_(group_theory)" title="wikilink">word</a> in <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, . . . , <em>a</em><sub><em>k</em></sub>; that is, <em>x</em> = <em>x</em>( <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, . . . , <em>a</em><sub><em>k</em></sub> ).</li>
<li>Alice sends <em>b</em><sub>1</sub><sup><em>x</em></sup>, <em>b</em><sub>2</sub><sup><em>x</em></sup>, . . . , <em>b</em><sub><em>m</em></sub><sup><em>x</em></sup> to Bob.</li>
<li>Bob picks a private <em>y</em> in <em>G</em> as a <a href="Word_(group_theory)" title="wikilink">word</a> in <em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, . . . , <em>b</em><sub><em>m</em></sub>; that is <em>y</em> = <em>y</em> ( <em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, . . . , <em>b</em><sub><em>m</em></sub> ).</li>
<li>Bob sends <em>a</em><sub>1</sub><sup><em>y</em></sup>, <em>a</em><sub>2</sub><sup><em>y</em></sup>, . . . , <em>a</em><sub><em>k</em></sub><sup><em>y</em></sup> to Alice.</li>
<li>Alice and Bob share the common secret key <em>K</em> = <em>x</em><sup>−1</sup><em>y</em><sup>−1</sup><em>xy</em>.</li>
<li>Alice computes <em>x</em> ( <em>a</em><sub>1</sub><sup><em>y</em></sup>, <em>a</em><sub>2</sub><sup><em>y</em></sup>, . . . , <em>a</em><sub><em>k</em></sub><sup><em>y</em></sup> ) = <em>y</em><sup>−1</sup> <em>xy</em>. Pre-multiplying it with <em>x</em><sup>−1</sup>, Alice gets <em>K</em>.</li>
<li>Bob computes <em>y</em> ( <em>b</em><sub>1</sub><sup><em>x</em></sup>, <em>b</em><sub>2</sub><sup><em>x</em></sup>, . . . , <em>b</em><sub><em>m</em></sub><sup><em>x</em></sup>) = <em>x</em><sup>−1</sup><em>yx</em>. Pre-multiplying it with <em>y</em><sup>−1</sup> and then taking the inverse, Bob gets <em>K</em>.</li>
</ol>
<h4 id="stickels-key-exchange-protocol">Stickel’s key exchange protocol</h4>

<p>In the original formulation of this protocol the group used was the group of <a href="Invertible_matrix" title="wikilink">invertible matrices</a> over a <a href="finite_field" title="wikilink">finite field</a>.</p>
<ol>
<li>Let <em>G</em> be a public non-abelian <a href="finite_group" title="wikilink">finite group</a>.</li>
<li>Let <em>a</em>, <em>b</em> be public elements of <em>G</em> such that <em>ab</em> ≠ <em>ba</em>. Let the orders of <em>a</em> and <em>b</em> be <em>N</em> and <em>M</em> respectively.</li>
<li>Alice chooses two random numbers <em>n</em> n<em>b</em><sup><em>m</em></sup> to Bob.</li>
<li>Bob picks two random numbers <em>r</em> <em>r</em><em>b</em><sup><em>s</em></sup> to Alice.</li>
<li>The common key shared by Alice and Bob is <em>K</em> = <em>a</em><sup><em>m</em> + <em>r</em></sup><em>b</em><sup><em>n</em> + <em>s</em></sup>.</li>
<li>Alice computes the key by <em>K</em> = a<sup><em>m</em></sup><em>vb</em><sup><em>n</em></sup>.</li>
<li>Bob computes the key by <em>K</em> = <em>a</em><sup><em>r</em></sup><em>ub</em><sup><em>s</em></sup>.</li>
</ol>
<h3 id="protocols-for-encryption-and-decryption">Protocols for encryption and decryption</h3>

<p>This protocol describes how to <a href="encryption" title="wikilink">encrypt</a> a secret message and then <a href="Decryption" title="wikilink">decrypt</a> using a non-commutative group. Let Alice want to send a secret message <em>m</em> to Bob.</p>
<ol>
<li>Let <em>G</em> be a non-commutative group. Let <em>A</em> and <em>B</em> be public subgroups of <em>G</em> such that <em>ab</em> = <em>ba</em> for all <em>a</em> in <em>A</em> and <em>b</em> in <em>B</em>.</li>
<li>An element <em>x</em> from <em>G</em> is chosen and published.</li>
<li>Alice chooses a secret key <em>a</em> from <em>A</em> and publishes <em>y</em> = <em>x</em><sup><em>a</em></sup> as her public key.</li>
<li>Bob chooses a secret key <em>b</em> from <em>A</em> and publishes <em>z</em> = <em>x</em><sup><em>b</em></sup> as his public key.</li>
<li>Alice chooses a random <em>r</em> from <em>B</em> and computes <em>t</em> = <em>z</em><sup><em>r</em></sup>.</li>
<li>The encrypted message is <em>C</em> = (<em>x</em><sup><em>r</em></sup>, <em>H</em>(<em>t</em>) 

<math display="inline" id="Non-commutative_cryptography:0">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 <em>m</em>), where <em>H</em> is some <a href="hash_function" title="wikilink">hash function</a> and 

<math display="inline" id="Non-commutative_cryptography:1">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 denotes the <a class="uri" href="XOR" title="wikilink">XOR</a> operation. Alice sends <em>C</em> to Bob.</li>
<li>To decrypt <em>C</em>, Bob recovers <em>t</em> as follows: (<em>x</em><sup><em>r</em></sup>)<sup><em>b</em></sup> = <em>x</em><sup><em>rb</em></sup> = <em>x</em><sup><em>br</em></sup> = (<em>x</em><sup><em>b</em></sup>)<sup><em>r</em></sup> = <em>z</em><sup><em>r</em></sup> = <em>t</em>. The plain text message send by Alice is <em>P</em> = ( <em>H</em>(<em>t</em>) 

<math display="inline" id="Non-commutative_cryptography:2">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 <em>m</em> ) 

<math display="inline" id="Non-commutative_cryptography:3">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 <em>H</em>(<em>t</em>) = <em>m</em>.</li>
</ol>
<h3 id="protocols-for-authentication">Protocols for authentication</h3>

<p>Let Bob want to check whether the sender of a message is really Alice.</p>
<ol>
<li>Let <em>G</em> be a non-commutative group and let <em>A</em> and <em>B</em> be subgroups of <em>G</em> such that <em>ab</em> = <em>ba</em> for all <em>a</em> in <em>A</em> and <em>b</em> in <em>B</em>.</li>
<li>An element <em>w</em> from <em>G</em> is selected and published.</li>
<li>Alice chooses a private <em>s</em> from <em>A</em> and publishes the pair ( <em>w</em>, <em>t</em> ) where <em>t</em> = <em>w</em> <sup><em>s</em></sup>.</li>
<li>Bob chooses an <em>r</em> from <em>B</em> and sends a challenge <em>w</em> ' = <em>w</em><sup><em>r</em></sup> to Alice.</li>
<li>Alice sends the response <em>w</em> ' ' = (<em>w</em> ')<sup><em>s</em></sup> to Bob.</li>
<li>Bob checks if <em>w</em> ' ' = <em>t</em><sup><em>r</em></sup>. If this true, then the identity of Alice is established.</li>
</ol>
<h2 id="security-basis-of-the-protocols">Security basis of the protocols</h2>

<p>The basis for the security and strength of the various protocols presented above is the difficulty of the following two problems:</p>
<ul>
<li>The <em><a href="conjugacy_problem" title="wikilink">conjugacy decision problem</a></em> (also called the <em>conjugacy problem</em>): Given two elements <em>u</em> and <em>v</em> in a group <em>G</em> determine whether there exists an element <em>x</em> in <em>G</em> such that <em>v</em> = <em>u</em><sup><em>x</em></sup>, that is, such that <em>v</em> = <em>x</em><sup>−1</sup> <em>ux</em>.</li>
<li>The <em>conjugacy search problem</em>: Given two elements <em>u</em> and <em>v</em> in a group <em>G</em> find an element <em>x</em> in <em>G</em> such that <em>v</em> = <em>u</em><sup><em>x</em></sup>, that is, such that <em>v</em> = <em>x</em><sup>−1</sup> <em>ux</em>.</li>
</ul>

<p>If no algorithm is known to solve the conjugacy search problem, then the function <em>x</em> → <em>u</em><sup><em>x</em></sup> can be considered as a <a href="one-way_function" title="wikilink">one-way function</a>.</p>
<h2 id="platform-groups">Platform groups</h2>

<p>A non-commutative group that is used in a particular cryptographic protocol is called the platform group of that protocol. Only groups having certain properties can be used as the platform groups for the implementation of non-commutative cryptographic protocols. Let <em>G</em> be a group suggested as a platform group for a certain non-commutative cryptographic system. The following is a list of the properties expected of <em>G</em>.</p>
<ol>
<li>The group <em>G</em> must be well-known and well-studied.</li>
<li>The <a href="Word_problem_for_groups" title="wikilink">word problem</a> in <em>G</em> should have a fast solution by a deterministic algorithm. There should be an efficiently computable "normal form" for elements of <em>G</em>.</li>
<li>It should be impossible to recover the factors <em>x</em> and <em>y</em> from the product <em>xy</em> in <em>G</em>.</li>
<li>The number of elements of length <em>n</em> in <em>G</em> should grow faster than any polynomial in <em>n</em>. (Here "length <em>n</em>" is the length of a word representing a group element.)</li>
</ol>
<h2 id="examples-of-platform-groups">Examples of platform groups</h2>
<h3 id="braid-groups">Braid groups</h3>

<p>Let <em>n</em> be a positive integer. The braid group <em>B</em><sub><em>n</em></sub> is a group generated by <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, . . . , <em>x</em><sub><em>n</em>-1</sub> having the following presentation:</p>

<p>

<math display="block" id="Non-commutative_cryptography:4">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>⟨</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo mathsize="120%" stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mtext>if</mtext>
    <mo stretchy="false">|</mo>
    <mi>i</mi>
    <mo>-</mo>
    <mi>j</mi>
    <mo stretchy="false">|</mo>
    <mo>></mo>
    <mn>1</mn>
    <mtext>and</mtext>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mtext>if</mtext>
    <mo stretchy="false">|</mo>
    <mi>i</mi>
    <mo>-</mo>
    <mi>j</mi>
    <mo stretchy="false">|</mo>
    <mo>=</mo>
    <mn>1</mn>
    <mo>⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>n</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <mtext>if</mtext>
     <ci>normal-|</ci>
     <csymbol cd="unknown">i</csymbol>
     <minus></minus>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-|</ci>
     <gt></gt>
     <cn type="integer">1</cn>
     <mtext>and</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <mtext>if</mtext>
     <ci>normal-|</ci>
     <csymbol cd="unknown">i</csymbol>
     <minus></minus>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-|</ci>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-⟩</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}=\left\langle x_{1},x_{2},\ldots,x_{n-1}\big|x_{i}x_{j}=x_{j}x_{i}\text{ %
if }|i-j|>1\text{ and }x_{i}x_{j}x_{i}=x_{j}x_{i}x_{j}\text{ if }|i-j|=1\right\rangle
  </annotation>
 </semantics>
</math>

</p>
<h3 id="thompsons-group">Thompson's group</h3>

<p>The Thompson's group is an infinite group <em>F</em> having the following infinite presentation:</p>

<p>

<math display="inline" id="Non-commutative_cryptography:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>b</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <msub>
          <mi>b</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>b</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <msub>
          <mi>b</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>b</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mrow>
         <mi>c</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>b</mi>
           <mn>2</mn>
          </msub>
          <mo>,</mo>
          <mi mathvariant="normal">…</mi>
          <mo>,</mo>
          <msub>
           <mi>b</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <msub>
          <mi>b</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>b</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </vector>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
     </interval>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(b_{1},b_{2},\ldots,b_{n})=\begin{cases}(b_{1},1-b_{2},\ldots,b_{n})&\text{ %
if }b_{1}=0\\
(b_{1},c(b_{2},\ldots,b_{n}))&\text{ if }b_{1}=1\end{cases}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>

<math display="inline" id="Non-commutative_cryptography:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>b</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <msub>
          <mi>b</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>b</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <msub>
          <mi>b</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>b</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mrow>
         <mi>d</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>b</mi>
           <mn>2</mn>
          </msub>
          <mo>,</mo>
          <mi mathvariant="normal">…</mi>
          <mo>,</mo>
          <msub>
           <mi>b</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <msub>
          <mi>b</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </vector>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
     </interval>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(b_{1},b_{2},\ldots,b_{n})=\begin{cases}(b_{1},1-b_{2},\ldots,b_{n})&\text{ %
if }b_{1}=0\\
(b_{1},d(b_{2},\ldots,b_{n}))&\text{ if }b_{1}=1\end{cases}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Non-commutative_cryptography:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>b</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <msub>
          <mi>b</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>b</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <msub>
          <mi>b</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>b</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mrow>
         <mi>b</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>b</mi>
           <mn>2</mn>
          </msub>
          <mo>,</mo>
          <mi mathvariant="normal">…</mi>
          <mo>,</mo>
          <msub>
           <mi>b</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <msub>
          <mi>b</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </vector>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
     </interval>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(b_{1},b_{2},\ldots,b_{n})=\begin{cases}(b_{1},1-b_{2},\ldots,b_{n})&\text{ %
if }b_{1}=0\\
(b_{1},b(b_{2},\ldots,b_{n}))&\text{ if }b_{1}=1\end{cases}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="block" id="Non-commutative_cryptography:8">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Γ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>⟨</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>j</mi>
      <mi>i</mi>
     </mrow>
    </msub>
    <mtext>for</mtext>
    <mn>1</mn>
    <mo>≤</mo>
    <mi>i</mi>
    <mo><</mo>
    <mi>j</mi>
    <mo>≤</mo>
    <mi>n</mi>
    <mo>⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Γ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <mtext>for</mtext>
     <cn type="integer">1</cn>
     <leq></leq>
     <csymbol cd="unknown">i</csymbol>
     <lt></lt>
     <csymbol cd="unknown">j</csymbol>
     <leq></leq>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(\Gamma)=\left\langle a_{1},a_{2},\ldots,a_{n}|\mu_{ij}=\mu_{ji}\text{ for }1%
\leq i<j\leq n\right\rangle
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h3 id="artin-group">Artin group</h3>

<p>An Artin group <em>A</em>(Γ) is a group with the following presentation:</p>

<p>

<math display="inline" id="Non-commutative_cryptography:9">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>a</mi>
     <mi>j</mi>
    </msub>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{ij}=a_{i}a_{j}a_{i}\ldots
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Non-commutative_cryptography:10">
 <semantics>
  <msub>
   <mi>m</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{ij}
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Non-commutative_cryptography:11">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>m</mi>
    <mrow>
     <mi>j</mi>
     <mi>i</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{ij}=m_{ji}
  </annotation>
 </semantics>
</math>

 factors) and <span class="LaTeX">$m_{ij} = m_{ji}$</span>.</p>
<h3 id="matrix-groups">Matrix groups</h3>

<p>Let <em>F</em> be a finite field. Groups of matrices over <em>F</em> have been used as the platform groups of certain non-commutative cryptographic protocols.</p>
<h2 id="further-reading">Further reading</h2>
<ol>
<li></li>
<li></li>
<li></li>
<li></li>
</ol>

<p>"</p>

<p><a class="uri" href="Category:Cryptography" title="wikilink">Category:Cryptography</a> <a href="Category:Public-key_cryptography" title="wikilink">Category:Public-key cryptography</a></p>
</body>
</html>
