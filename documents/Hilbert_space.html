<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1737">Hilbert space</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hilbert space</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The state of a <a href="vibrating_string" title="wikilink">vibrating string</a> can be modeled as a point in a Hilbert space. The decomposition of a vibrating string into its vibrations in distinct <a href="overtone" title="wikilink">overtones</a> is given by the projection of the point onto the coordinate axes in the space.</figcaption>
</figure>

<p>The <a href="mathematics" title="wikilink">mathematical</a> concept of a <strong>Hilbert space</strong>, named after <a href="David_Hilbert" title="wikilink">David Hilbert</a>, generalizes the notion of <a href="Euclidean_space" title="wikilink">Euclidean space</a>. It extends the methods of <a href="linear_algebra" title="wikilink">vector algebra</a> and <a class="uri" href="calculus" title="wikilink">calculus</a> from the two-dimensional <a href="plane_(geometry)" title="wikilink">Euclidean plane</a> and three-dimensional space to spaces with any finite or infinite number of dimensions. A Hilbert space is an abstract <a href="vector_space" title="wikilink">vector space</a> possessing the <a href="mathematical_structure" title="wikilink">structure</a> of an <a href="inner_product_space" title="wikilink">inner product</a> that allows length and angle to be measured. Furthermore, Hilbert spaces are <a href="Complete_metric_space" title="wikilink">complete</a>: there are enough <a href="limit_(mathematics)" title="wikilink">limits</a> in the space to allow the techniques of calculus to be used.</p>

<p>Hilbert spaces arise naturally and frequently in <a class="uri" href="mathematics" title="wikilink">mathematics</a> and <a class="uri" href="physics" title="wikilink">physics</a>, typically as infinite-dimensional <a href="function_space" title="wikilink">function spaces</a>. The earliest Hilbert spaces were studied from this point of view in the first decade of the 20th century by <a href="David_Hilbert" title="wikilink">David Hilbert</a>, <a href="Erhard_Schmidt" title="wikilink">Erhard Schmidt</a>, and <a href="Frigyes_Riesz" title="wikilink">Frigyes Riesz</a>. They are indispensable tools in the theories of <a href="partial_differential_equation" title="wikilink">partial differential equations</a>, <a href="mathematical_formulation_of_quantum_mechanics" title="wikilink">quantum mechanics</a>, <a href="Fourier_analysis" title="wikilink">Fourier analysis</a> (which includes applications to <a href="signal_processing" title="wikilink">signal processing</a> and heat transfer)—and <a href="ergodic_theory" title="wikilink">ergodic theory</a>, which forms the mathematical underpinning of <a class="uri" href="thermodynamics" title="wikilink">thermodynamics</a>. <a href="John_von_Neumann" title="wikilink">John von Neumann</a> coined the term <em>Hilbert space</em> for the abstract concept that underlies many of these diverse applications. The success of Hilbert space methods ushered in a very fruitful era for <a href="functional_analysis" title="wikilink">functional analysis</a>. Apart from the classical Euclidean spaces, examples of Hilbert spaces include <a href="Lp_space" title="wikilink">spaces of square-integrable functions</a>, <a href="Sequence_space" title="wikilink">spaces of sequences</a>, <a href="Sobolev_space" title="wikilink">Sobolev spaces</a> consisting of <a href="generalized_function" title="wikilink">generalized functions</a>, and <a href="Hardy_space" title="wikilink">Hardy spaces</a> of <a href="holomorphic_function" title="wikilink">holomorphic functions</a>.</p>

<p>Geometric intuition plays an important role in many aspects of Hilbert space theory. Exact analogs of the <a href="Pythagorean_theorem" title="wikilink">Pythagorean theorem</a> and <a href="parallelogram_law" title="wikilink">parallelogram law</a> hold in a Hilbert space. At a deeper level, perpendicular projection onto a subspace (the analog of "<a href="altitude_(triangle)" title="wikilink">dropping the altitude</a>" of a triangle) plays a significant role in optimization problems and other aspects of the theory. An element of a Hilbert space can be uniquely specified by its coordinates with respect to a set of <a href="coordinate_axes" title="wikilink">coordinate axes</a> (an <a href="orthonormal_basis" title="wikilink">orthonormal basis</a>), in analogy with Cartesian coordinates in the plane. When that set of axes is <a href="countably_infinite" title="wikilink">countably infinite</a>, this means that the Hilbert space can also usefully be thought of in terms of <a href="infinite_sequence" title="wikilink">infinite sequences</a> that are <a href="Lp_space#Lp_spaces" title="wikilink">square-summable</a>. <a href="Linear_operator" title="wikilink">Linear operators</a> on a Hilbert space are likewise fairly concrete objects: in good cases, they are simply transformations that stretch the space by different factors in mutually perpendicular directions in a sense that is made precise by the study of their <a href="spectral_theory" title="wikilink">spectrum</a>.</p>
<h2 id="definition-and-illustration">Definition and illustration</h2>
<h3 id="motivating-example-euclidean-space">Motivating example: Euclidean space</h3>

<p>One of the most familiar examples of a Hilbert space is the <a href="Euclidean_space" title="wikilink">Euclidean space</a> consisting of three-dimensional <a href="Euclidean_vector" title="wikilink">vectors</a>, denoted by <strong>R</strong><sup>3</sup>, and equipped with the <a href="dot_product" title="wikilink">dot product</a>. The dot product takes two vectors <strong>x</strong> and <strong>y</strong>, and produces a real number <strong>x</strong>·<strong>y</strong>. If <strong>x</strong> and <strong>y</strong> are represented in <a href="Cartesian_coordinates" title="wikilink">Cartesian coordinates</a>, then the dot product is defined by</p>

<p>

<math display="block" id="Hilbert_space:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>3</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>3</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>y</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>3</mn>
      </msub>
      <msub>
       <mi>y</mi>
       <mn>3</mn>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
     </vector>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">3</cn>
      </apply>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},x_{2},x_{3})\cdot(y_{1},y_{2},y_{3})=x_{1}y_{1}+x_{2}y_{2}+x_{3}y_{3}.
  </annotation>
 </semantics>
</math>

 The dot product satisfies the properties:</p>
<ol>
<li>It is symmetric in <strong>x</strong> and <strong>y</strong>: <strong>x</strong> · <strong>y</strong> = <strong>y</strong> · <strong>x</strong>.</li>
<li>It is <a href="linear_function" title="wikilink">linear</a> in its first argument: (<em>a<strong><em>x<strong><sub>1</sub> + ''b</strong></em>x</strong><sub>2</sub>) · <strong>y</strong> = </em>a<em><strong>x</strong><sub>1</sub> · <strong>y</strong> + </em>b'<strong>'x</strong><sub>2</sub> · <strong>y</strong> for any scalars <em>a</em>, <em>b</em>, and vectors <strong>x</strong><sub>1</sub>, <strong>x</strong><sub>2</sub>, and <strong>y</strong>.</li>
<li>It is <a href="Definite_bilinear_form" title="wikilink">positive definite</a>: for all vectors <strong>x</strong>, <strong>x</strong> · <strong>x</strong> ≥ 0, with equality <a href="if_and_only_if" title="wikilink">if and only if</a> <strong>x</strong> = 0.</li>
</ol>

<p>An operation on pairs of vectors that, like the dot product, satisfies these three properties is known as a (real) <a href="inner_product" title="wikilink">inner product</a>. A <a href="vector_space" title="wikilink">vector space</a> equipped with such an inner product is known as a (real) <a href="inner_product_space" title="wikilink">inner product space</a>. Every finite-dimensional inner product space is also a Hilbert space. The basic feature of the dot product that connects it with Euclidean geometry is that it is related to both the length (or <a href="norm_(mathematics)" title="wikilink">norm</a>) of a vector, denoted ||<strong>x</strong>||, and to the angle θ between two vectors <strong>x</strong> and <strong>y</strong> by means of the formula</p>

<p>

<math display="block" id="Hilbert_space:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐱</mi>
     <mo>⋅</mo>
     <mi>𝐲</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>∥</mo>
      <mi>𝐱</mi>
      <mo rspace="4.2pt">∥</mo>
     </mrow>
     <mrow>
      <mo>∥</mo>
      <mi>𝐲</mi>
      <mo rspace="4.2pt">∥</mo>
     </mrow>
     <mrow>
      <mi>cos</mi>
      <mi>θ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>𝐱</ci>
     <ci>𝐲</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>𝐱</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>𝐲</ci>
     </apply>
     <apply>
      <cos></cos>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}\cdot\mathbf{y}=\|\mathbf{x}\|\,\|\mathbf{y}\|\,\cos\theta.
  </annotation>
 </semantics>
</math>

</p>

<p> <a href="Multivariable_calculus" title="wikilink">Multivariable calculus</a> in Euclidean space relies on the ability to compute <a href="limit_(mathematics)" title="wikilink">limits</a>, and to have useful criteria for concluding that limits exist. A <a href="series_(mathematics)" title="wikilink">mathematical series</a></p>

<p>

<math display="block" id="Hilbert_space:2">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </munderover>
   <msub>
    <mi>𝐱</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{n=0}^{\infty}\mathbf{x}_{n}
  </annotation>
 </semantics>
</math>

 consisting of vectors in <strong>R</strong><sup>3</sup> is <a href="absolute_convergence" title="wikilink">absolutely convergent</a> provided that the sum of the lengths converges as an ordinary series of real numbers:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="block" id="Hilbert_space:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <mo>∥</mo>
      <msub>
       <mi>𝐱</mi>
       <mi>k</mi>
      </msub>
      <mo>∥</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=0}^{\infty}\|\mathbf{x}_{k}\|<\infty.
  </annotation>
 </semantics>
</math>

 Just as with a series of scalars, a series of vectors that converges absolutely also converges to some limit vector <strong>L</strong> in the Euclidean space, in the sense that</p>

<p>

<math display="block" id="Hilbert_space:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>𝐋</mi>
       <mo>-</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>k</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mi>N</mi>
        </munderover>
        <msub>
         <mi>𝐱</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mo>→</mo>
     <mn>0</mn>
    </mrow>
    <mrow>
     <mrow>
      <mtext>as</mtext>
      <mi>N</mi>
     </mrow>
     <mo>→</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>𝐋</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>k</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <ci>N</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐱</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <mtext>as</mtext>
      <ci>N</ci>
     </apply>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\|\mathbf{L}-\sum_{k=0}^{N}\mathbf{x}_{k}\right\|\to 0\quad\text{as }N\to\infty.
  </annotation>
 </semantics>
</math>

 This property expresses the <em>completeness</em> of Euclidean space: that a series that converges absolutely also converges in the ordinary sense.</p>
<h3 id="definition">Definition</h3>

<p>A <strong>Hilbert space</strong> <em>H</em> is a <a href="real_number" title="wikilink">real</a> or <a href="complex_number" title="wikilink">complex</a> <a href="inner_product_space" title="wikilink">inner product space</a> that is also a <a href="complete_metric_space" title="wikilink">complete metric space</a> with respect to the distance function induced by the inner product.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> To say that <em>H</em> is a complex inner product space means that <em>H</em> is a complex vector space on which there is an inner product 

<math display="inline" id="Hilbert_space:5">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,y\rangle
  </annotation>
 </semantics>
</math>

 associating a complex number to each pair of elements <em>x</em>,<em>y</em> of <em>H</em> that satisfies the following properties:</p>
<ul>
<li>The inner product of a pair of elements is equal to the <a href="complex_conjugate" title="wikilink">complex conjugate</a> of the inner product of the swapped elements:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hilbert_space:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mover accent="true">
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>¯</mo>
    </mover>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>y</ci>
     <ci>x</ci>
    </list>
    <apply>
     <ci>normal-¯</ci>
     <list>
      <ci>x</ci>
      <ci>y</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle y,x\rangle=\overline{\langle x,y\rangle}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>The inner product is <a href="linear_functional" title="wikilink">linear</a> in its first argument.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> For all complex numbers <em>a</em> and <em>b</em>,</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hilbert_space:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mrow>
       <mi>a</mi>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>b</mi>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>b</mi>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>y</ci>
    </list>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>y</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>y</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle ax_{1}+bx_{2},y\rangle=a\langle x_{1},y\rangle+b\langle x_{2},y\rangle.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>The inner product of an element with itself is <a href="Definite_bilinear_form" title="wikilink">positive definite</a>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hilbert_space:8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <list>
     <ci>x</ci>
     <ci>x</ci>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,x\rangle\geq 0
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
<dd>where the case of equality holds precisely when <em>x</em> = 0.
</dd>
</dl>

<p>It follows from properties 1 and 2 that a complex inner product is <a href="Antilinear_map" title="wikilink">antilinear</a> in its second argument, meaning that</p>

<p>

<math display="block" id="Hilbert_space:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>a</mi>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>b</mi>
       <msub>
        <mi>y</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mover accent="true">
       <mi>a</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mover accent="true">
       <mi>b</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </list>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
      <list>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <ci>b</ci>
      </apply>
      <list>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,ay_{1}+by_{2}\rangle=\bar{a}\langle x,y_{1}\rangle+\bar{b}\langle x,%
y_{2}\rangle.
  </annotation>
 </semantics>
</math>

 A real inner product space is defined in the same way, except that <em>H</em> is a real vector space and the inner product takes real values. Such an inner product will be bilinear: that is, linear in each argument.</p>

<p>The <a href="norm_(mathematics)" title="wikilink">norm</a> is the real-valued function</p>

<p>

<math display="block" id="Hilbert_space:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mi>x</mi>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </msqrt>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <root></root>
     <list>
      <ci>x</ci>
      <ci>x</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x\|=\sqrt{\langle x,x\rangle},
  </annotation>
 </semantics>
</math>

 and the distance <em>d</em> between two points <em>x</em>,<em>y</em> in <em>H</em> is defined in terms of the norm by</p>

<p>

<math display="block" id="Hilbert_space:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </msqrt>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <root></root>
      <list>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(x,y)=\|x-y\|=\sqrt{\langle x-y,x-y\rangle}.
  </annotation>
 </semantics>
</math>

 That this function is a distance function means (1) that it is symmetric in <em>x</em> and <em>y</em>, (2) that the distance between <em>x</em> and itself is zero, and otherwise the distance between <em>x</em> and <em>y</em> must be positive, and (3) that the <a href="triangle_inequality" title="wikilink">triangle inequality</a> holds, meaning that the length of one leg of a triangle <em>xyz</em> cannot exceed the sum of the lengths of the other two legs:</p>

<p>

<math display="block" id="Hilbert_space:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <mi>d</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>d</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>z</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <ci>y</ci>
       <ci>z</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(x,z)\leq d(x,y)+d(y,z).
  </annotation>
 </semantics>
</math>

 </p>

<p>This last property is ultimately a consequence of the more fundamental <a href="Cauchy–Schwarz_inequality" title="wikilink">Cauchy–Schwarz inequality</a>, which asserts</p>

<p>

<math display="block" id="Hilbert_space:13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mi>x</mi>
     <mo rspace="4.2pt">∥</mo>
    </mrow>
    <mrow>
     <mo>∥</mo>
     <mi>y</mi>
     <mo>∥</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <list>
      <ci>x</ci>
      <ci>y</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\langle x,y\rangle|\leq\|x\|\,\|y\|
  </annotation>
 </semantics>
</math>

 with equality if and only if <em>x</em> and <em>y</em> are <a href="Linear_independence" title="wikilink">linearly dependent</a>.</p>

<p>Relative to a distance function defined in this way, any inner product space is a <a href="metric_space" title="wikilink">metric space</a>, and sometimes is known as a <strong>pre-Hilbert space</strong>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Any pre-Hilbert space that is additionally also a <a href="complete_space" title="wikilink">complete</a> space is a Hilbert space. Completeness is expressed using a form of the <a href="Cauchy_criterion" title="wikilink">Cauchy criterion</a> for sequences in <em>H</em>: a pre-Hilbert space <em>H</em> is complete if every <a href="Cauchy_sequence" title="wikilink">Cauchy sequence</a> <a href="limit_(mathematics)" title="wikilink">converges with respect to this norm</a> to an element in the space. Completeness can be characterized by the following equivalent condition: if a series of vectors 

<math display="inline" id="Hilbert_space:14">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>k</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <msub>
    <mi>u</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>k</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle{\sum_{k=0}^{\infty}u_{k}}
  </annotation>
 </semantics>
</math>

 <a href="absolute_convergence" title="wikilink">converges absolutely</a> in the sense that</p>

<p>

<math display="block" id="Hilbert_space:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <mo>∥</mo>
      <msub>
       <mi>u</mi>
       <mi>k</mi>
      </msub>
      <mo>∥</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=0}^{\infty}\|u_{k}\|<\infty,
  </annotation>
 </semantics>
</math>

 then the series converges in <em>H</em>, in the sense that the partial sums converge to an element of <em>H</em>.</p>

<p>As a complete normed space, Hilbert spaces are by definition also <a href="Banach_space" title="wikilink">Banach spaces</a>. As such they are <a href="topological_vector_space" title="wikilink">topological vector spaces</a>, in which <a href="topology" title="wikilink">topological</a> notions like the <a href="open_set" title="wikilink">openness</a> and <a href="closed_set" title="wikilink">closedness</a> of subsets are well-defined. Of special importance is the notion of a closed <a href="linear_subspace" title="wikilink">linear subspace</a> of a Hilbert space that, with the inner product induced by restriction, is also complete (being a closed set in a complete metric space) and therefore a Hilbert space in its own right.</p>
<h3 id="second-example-sequence-spaces">Second example: sequence spaces</h3>

<p>The <a href="sequence_space" title="wikilink">sequence space</a> <em>ℓ</em><sup>2</sup> consists of all <a href="sequence_(mathematics)" title="wikilink">infinite sequences</a> <strong>z</strong> = (<em>z</em><sub><em>1</em></sub>,<em>z</em><sub>2</sub>,...) of complex numbers such that the <a href="series_(mathematics)" title="wikilink">series</a></p>

<p>

<math display="block" id="Hilbert_space:16">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </munderover>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>z</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{n=1}^{\infty}|z_{n}|^{2}
  </annotation>
 </semantics>
</math>

 <a href="convergent_series" title="wikilink">converges</a>. The inner product on <em>ℓ</em><sup>2</sup> is defined by</p>

<p>

<math display="block" id="Hilbert_space:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>𝐳</mi>
     <mo>,</mo>
     <mi>𝐰</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>z</mi>
       <mi>n</mi>
      </msub>
      <mover accent="true">
       <msub>
        <mi>w</mi>
        <mi>n</mi>
       </msub>
       <mo>¯</mo>
      </mover>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>𝐳</ci>
     <ci>𝐰</ci>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\mathbf{z},\mathbf{w}\rangle=\sum_{n=1}^{\infty}z_{n}\overline{w_{n}},
  </annotation>
 </semantics>
</math>

 with the latter series converging as a consequence of the Cauchy–Schwarz inequality.</p>

<p>Completeness of the space holds provided that whenever a series of elements from <em>ℓ</em><sup>2</sup> converges absolutely (in norm), then it converges to an element of <em>ℓ</em><sup>2</sup>. The proof is basic in <a href="mathematical_analysis" title="wikilink">mathematical analysis</a>, and permits mathematical series of elements of the space to be manipulated with the same ease as series of complex numbers (or vectors in a finite-dimensional Euclidean space).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="history">History</h2>

<p> Prior to the development of Hilbert spaces, other generalizations of Euclidean spaces were known to <a href="mathematician" title="wikilink">mathematicians</a> and physicists. In particular, the idea of an <a href="vector_space" title="wikilink">abstract linear space</a> had gained some traction towards the end of the 19th century:<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> this is a space whose elements can be added together and multiplied by scalars (such as <a href="real_numbers" title="wikilink">real</a> or <a href="complex_numbers" title="wikilink">complex numbers</a>) without necessarily identifying these elements with <a href="vector_(geometric)" title="wikilink">"geometric" vectors</a>, such as position and momentum vectors in physical systems. Other objects studied by mathematicians at the turn of the 20th century, in particular spaces of <a href="sequence_(mathematics)" title="wikilink">sequences</a> (including <a href="series_(mathematics)" title="wikilink">series</a>) and spaces of functions,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> can naturally be thought of as linear spaces. Functions, for instance, can be added together or multiplied by constant scalars, and these operations obey the algebraic laws satisfied by addition and scalar multiplication of spatial vectors.</p>

<p>In the first decade of the 20th century, parallel developments led to the introduction of Hilbert spaces. The first of these was the observation, which arose during <a href="David_Hilbert" title="wikilink">David Hilbert</a> and <a href="Erhard_Schmidt" title="wikilink">Erhard Schmidt</a>'s study of <a href="integral_equations" title="wikilink">integral equations</a>,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> that two <a class="uri" href="square-integrable" title="wikilink">square-integrable</a> real-valued functions <em>f</em> and <em>g</em> on an interval [<em>a</em>,<em>b</em>] have an <em>inner product</em></p>

<p>

<math display="block" id="Hilbert_space:18">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>g</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>a</mi>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>f</ci>
     <ci>g</ci>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <ci>g</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f,g\rangle=\int_{a}^{b}f(x)g(x)\,dx
  </annotation>
 </semantics>
</math>

</p>

<p>which has many of the familiar properties of the Euclidean dot product. In particular, the idea of an <a href="orthogonality" title="wikilink">orthogonal</a> family of functions has meaning. Schmidt exploited the similarity of this inner product with the usual dot product to prove an analog of the <a href="spectral_decomposition" title="wikilink">spectral decomposition</a> for an operator of the form</p>

<p>

<math display="block" id="Hilbert_space:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>a</mi>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>y</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <ci>f</ci>
      <ci>y</ci>
      <ci>d</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)\mapsto\int_{a}^{b}K(x,y)f(y)\,dy
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>K</em> is a continuous function symmetric in <em>x</em> and <em>y</em>. The resulting <a href="eigenfunction_expansion" title="wikilink">eigenfunction expansion</a> expresses the function <em>K</em> as a series of the form</p>

<p>

<math display="block" id="Hilbert_space:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>n</mi>
    </munder>
    <mrow>
     <msub>
      <mi>λ</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>φ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>φ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <ci>n</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=\sum_{n}\lambda_{n}\varphi_{n}(x)\varphi_{n}(y)\,
  </annotation>
 </semantics>
</math>

</p>

<p>where the functions <em>φ</em><sub><em>n</em></sub> are orthogonal in the sense that <mtpl> 0}}</mtpl> for all . The individual terms in this series are sometimes referred to as elementary product solutions. However, there are eigenfunction expansions that fail to converge in a suitable sense to a square-integrable function: the missing ingredient, which ensures convergence, is completeness.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>The second development was the <a href="Lebesgue_integral" title="wikilink">Lebesgue integral</a>, an alternative to the <a href="Riemann_integral" title="wikilink">Riemann integral</a> introduced by <a href="Henri_Lebesgue" title="wikilink">Henri Lebesgue</a> in 1904.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The Lebesgue integral made it possible to integrate a much broader class of functions. In 1907, <a href="Frigyes_Riesz" title="wikilink">Frigyes Riesz</a> and <a href="Ernst_Sigismund_Fischer" title="wikilink">Ernst Sigismund Fischer</a> independently proved that the space <em>L</em><sup>2</sup> of square Lebesgue-integrable functions is a <a href="complete_metric_space" title="wikilink">complete metric space</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> As a consequence of the interplay between geometry and completeness, the 19th century results of <a href="Joseph_Fourier" title="wikilink">Joseph Fourier</a>, <a href="Friedrich_Bessel" title="wikilink">Friedrich Bessel</a> and <a href="Marc-Antoine_Parseval" title="wikilink">Marc-Antoine Parseval</a> on <a href="trigonometric_series" title="wikilink">trigonometric series</a> easily carried over to these more general spaces, resulting in a geometrical and analytical apparatus now usually known as the <a href="Riesz–Fischer_theorem" title="wikilink">Riesz–Fischer theorem</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>Further basic results were proved in the early 20th century. For example, the <a href="Riesz_representation_theorem" title="wikilink">Riesz representation theorem</a> was independently established by <a href="Maurice_Fréchet" title="wikilink">Maurice Fréchet</a> and <a href="Frigyes_Riesz" title="wikilink">Frigyes Riesz</a> in 1907.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a href="John_von_Neumann" title="wikilink">John von Neumann</a> coined the term <em>abstract Hilbert space</em> in his work on unbounded <a href="Self-adjoint_operator" title="wikilink">Hermitian operators</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Although other mathematicians such as <a href="Hermann_Weyl" title="wikilink">Hermann Weyl</a> and <a href="Norbert_Wiener" title="wikilink">Norbert Wiener</a> had already studied particular Hilbert spaces in great detail, often from a physically motivated point of view, von Neumann gave the first complete and axiomatic treatment of them.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Von Neumann later used them in his seminal work on the foundations of quantum mechanics,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> and in his continued work with <a href="Eugene_Wigner" title="wikilink">Eugene Wigner</a>. The name "Hilbert space" was soon adopted by others, for example by Hermann Weyl in his book on quantum mechanics and the theory of groups.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>The significance of the concept of a Hilbert space was underlined with the realization that it offers one of the best <a href="mathematical_formulation_of_quantum_mechanics" title="wikilink">mathematical formulations of quantum mechanics</a>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> In short, the states of a quantum mechanical system are vectors in a certain Hilbert space, the observables are <a href="hermitian_operator" title="wikilink">hermitian operators</a> on that space, the <a href="symmetry" title="wikilink">symmetries</a> of the system are <a href="unitary_operator" title="wikilink">unitary operators</a>, and <a href="quantum_measurement" title="wikilink">measurements</a> are <a href="orthogonal_projection" title="wikilink">orthogonal projections</a>. The relation between quantum mechanical symmetries and unitary operators provided an impetus for the development of the <a href="unitary_representation" title="wikilink">unitary</a> <a href="representation_theory" title="wikilink">representation theory</a> of <a href="group_(mathematics)" title="wikilink">groups</a>, initiated in the 1928 work of Hermann Weyl.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> On the other hand, in the early 1930s it became clear that classical mechanics can be described in terms of Hilbert space (<a href="Koopman–von_Neumann_classical_mechanics" title="wikilink">Koopman–von Neumann classical mechanics</a>) and that certain properties of classical <a href="dynamical_systems" title="wikilink">dynamical systems</a> can be analyzed using Hilbert space techniques in the framework of <a href="ergodic_theory" title="wikilink">ergodic theory</a>.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>The algebra of <a href="observable" title="wikilink">observables</a> in quantum mechanics is naturally an algebra of operators defined on a Hilbert space, according to <a href="Werner_Heisenberg" title="wikilink">Werner Heisenberg</a>'s <a href="matrix_mechanics" title="wikilink">matrix mechanics</a> formulation of quantum theory. Von Neumann began investigating <a href="operator_algebra" title="wikilink">operator algebras</a> in the 1930s, as <a href="ring_(mathematics)" title="wikilink">rings</a> of operators on a Hilbert space. The kind of algebras studied by von Neumann and his contemporaries are now known as <a href="von_Neumann_algebra" title="wikilink">von Neumann algebras</a>. In the 1940s, <a href="Israel_Gelfand" title="wikilink">Israel Gelfand</a>, <a href="Mark_Naimark" title="wikilink">Mark Naimark</a> and <a href="Irving_Segal" title="wikilink">Irving Segal</a> gave a definition of a kind of operator algebras called <a href="C*-algebra" title="wikilink">C*-algebras</a> that on the one hand made no reference to an underlying Hilbert space, and on the other extrapolated many of the useful features of the operator algebras that had previously been studied. The spectral theorem for self-adjoint operators in particular that underlies much of the existing Hilbert space theory was generalized to C*-algebras. These techniques are now basic in abstract harmonic analysis and representation theory.</p>
<h2 id="examples">Examples</h2>
<h3 id="lebesgue-spaces">Lebesgue spaces</h3>

<p><mtpl></mtpl></p>

<p>Lebesgue spaces are <a href="function_space" title="wikilink">function spaces</a> associated to <a href="measure_(mathematics)" title="wikilink">measure spaces</a> (<em>X</em>, <em>M</em>, <em>μ</em>), where <em>X</em> is a set, <em>M</em> is a <a href="Sigma-algebra" title="wikilink">σ-algebra</a> of subsets of <em>X</em>, and <em>μ</em> is a <a href="countably_additive_measure" title="wikilink">countably additive measure</a> on <em>M</em>. Let <em>L</em><sup>2</sup>(<em>X</em>, μ) be the space of those complex-valued measurable functions on <em>X</em> for which the <a href="Lebesgue_integration" title="wikilink">Lebesgue integral</a> of the square of the <a href="absolute_value" title="wikilink">absolute value</a> of the function is finite, i.e., for a function <em>f</em> in <em>L</em><sup>2</sup>(<em>X</em>,μ),</p>

<p>

<math display="block" id="Hilbert_space:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>X</mi>
     </msub>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>f</mi>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mi>d</mi>
      <mi>μ</mi>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <ci>f</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>d</ci>
      <ci>μ</ci>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{X}|f|^{2}d\mu<\infty,
  </annotation>
 </semantics>
</math>

</p>

<p>and where functions are identified if and only if they differ only on a <a href="null_set" title="wikilink">set of measure zero</a>.</p>

<p>The inner product of functions <em>f</em> and <em>g</em> in <em>L</em><sup>2</sup>(<em>X</em>, μ) is then defined as</p>

<p>

<math display="block" id="Hilbert_space:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mi>g</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>X</mi>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+5pt">
       <mover accent="true">
        <mrow>
         <mi>g</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>¯</mo>
       </mover>
      </mpadded>
      <mi>d</mi>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>f</ci>
     <ci>g</ci>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>t</ci>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>μ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f,g\rangle=\int_{X}f(t)\overline{g(t)}\ d\mu(t).
  </annotation>
 </semantics>
</math>

</p>

<p>For <em>f</em> and <em>g</em> in <em>L</em><sup>2</sup>, this integral exists because of the Cauchy–Schwarz inequality, and defines an inner product on the space. Equipped with this inner product, <em>L</em><sup>2</sup> is in fact complete.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> The Lebesgue integral is essential to ensure completeness: on domains of real numbers, for instance, not enough functions are <a href="Riemann_integral" title="wikilink">Riemann integrable</a>.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>The Lebesgue spaces appear in many natural settings. The spaces <em>L</em><sup>2</sup>(<strong>R</strong>) and <em>L</em><sup>2</sup>([0,1]) of square-integrable functions with respect to the <a href="Lebesgue_measure" title="wikilink">Lebesgue measure</a> on the real line and unit interval, respectively, are natural domains on which to define the Fourier transform and Fourier series. In other situations, the measure may be something other than the ordinary Lebesgue measure on the real line. For instance, if <em>w</em> is any positive measurable function, the space of all measurable functions <em>f</em> on the interval [0, 1] satisfying</p>

<p>

<math display="block" id="Hilbert_space:23">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mn>1</mn>
    </msubsup>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
   <mo><</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>w</ci>
      <ci>t</ci>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{0}^{1}|f(t)|^{2}w(t)\,dt<\infty
  </annotation>
 </semantics>
</math>

 is called the <a href="Lp_space#Weighted_Lp_spaces" title="wikilink">weighted <em>L</em><sup>2</sup> space</a> <em>L</em>([0,1]), and <em>w</em> is called the weight function. The inner product is defined by</p>

<p>

<math display="block" id="Hilbert_space:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mi>g</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mn>1</mn>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mover accent="true">
       <mrow>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>¯</mo>
      </mover>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>f</ci>
     <ci>g</ci>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>t</ci>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>w</ci>
      <ci>t</ci>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f,g\rangle=\int_{0}^{1}f(t)\overline{g(t)}w(t)\,dt.
  </annotation>
 </semantics>
</math>

 The weighted space <em>L</em>([0,1]) is identical with the Hilbert space <em>L</em><sup>2</sup>([0,1],μ) where the measure μ of a Lebesgue-measurable set <em>A</em> is defined by</p>

<p>

<math display="block" id="Hilbert_space:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>μ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>A</mi>
     </msub>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>μ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>t</ci>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu(A)=\int_{A}w(t)\,dt.
  </annotation>
 </semantics>
</math>

 Weighted <em>L</em><sup>2</sup> spaces like this are frequently used to study orthogonal polynomials, because different families of orthogonal polynomials are orthogonal with respect to different weighting functions.</p>
<h3 id="sobolev-spaces">Sobolev spaces</h3>

<p><a href="Sobolev_space" title="wikilink">Sobolev spaces</a>, denoted by <em>H</em><sup><em>s</em></sup> or <mtpl></mtpl>, are Hilbert spaces. These are a special kind of <a href="function_space" title="wikilink">function space</a> in which <a href="derivative" title="wikilink">differentiation</a> may be performed, but that (unlike other <a href="Banach_spaces" title="wikilink">Banach spaces</a> such as the <a href="Hölder_space" title="wikilink">Hölder spaces</a>) support the structure of an inner product. Because differentiation is permitted, Sobolev spaces are a convenient setting for the theory of <a href="partial_differential_equations" title="wikilink">partial differential equations</a>.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> They also form the basis of the theory of <a href="Direct_method_in_calculus_of_variations" title="wikilink">direct methods in the calculus of variations</a>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>For <em>s</em> a non-negative integer and <mtpl></mtpl>, the Sobolev space <em>H</em><sup><em>s</em></sup>(Ω) contains L<sup>2</sup> functions whose <a href="weak_derivative" title="wikilink">weak derivatives</a> of order up to <em>s</em> are also L<sup>2</sup>. The inner product in <em>H</em><sup>s</sup>(Ω) is</p>

<p>

<math display="block" id="Hilbert_space:26">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>g</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mover accent="true">
       <mi>g</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mrow>
       <mrow>
        <mi>D</mi>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <mi>D</mi>
      </mrow>
      <mover accent="true">
       <mi>g</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mrow>
       <mrow>
        <msup>
         <mi>D</mi>
         <mi>s</mi>
        </msup>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <msup>
        <mi>D</mi>
        <mi>s</mi>
       </msup>
      </mrow>
      <mover accent="true">
       <mi>g</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>f</ci>
     <ci>g</ci>
    </list>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Ω</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
       <apply>
        <ci>normal-¯</ci>
        <ci>g</ci>
       </apply>
       <ci>x</ci>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Ω</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <times></times>
         <ci>D</ci>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
        <ci>D</ci>
       </apply>
       <apply>
        <ci>normal-¯</ci>
        <ci>g</ci>
       </apply>
       <ci>x</ci>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Ω</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>D</ci>
          <ci>s</ci>
         </apply>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>D</ci>
         <ci>s</ci>
        </apply>
       </apply>
       <apply>
        <ci>normal-¯</ci>
        <ci>g</ci>
       </apply>
       <ci>x</ci>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f,g\rangle=\int_{\Omega}f(x)\bar{g}(x)\,dx+\int_{\Omega}Df(x)\cdot D%
\bar{g}(x)\,dx+\cdots+\int_{\Omega}D^{s}f(x)\cdot D^{s}\bar{g}(x)\,dx
  </annotation>
 </semantics>
</math>

</p>

<p>where the dot indicates the dot product in the Euclidean space of partial derivatives of each order. Sobolev spaces can also be defined when <em>s</em> is not an integer.</p>

<p>Sobolev spaces are also studied from the point of view of spectral theory, relying more specifically on the Hilbert space structure. If Ω is a suitable domain, then one can define the Sobolev space <em>H</em><sup><em>s</em></sup>(Ω) as the space of <a href="Bessel_potential" title="wikilink">Bessel potentials</a>;<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> roughly,</p>

<p>

<math display="block" id="Hilbert_space:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>s</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi mathvariant="normal">Δ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>s</mi>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </mrow>
      </msup>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>f</mi>
      <mo>∈</mo>
      <mrow>
       <msup>
        <mi>L</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">Ω</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-Ω</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>normal-Δ</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <ci>s</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>f</ci>
     </apply>
     <apply>
      <in></in>
      <ci>f</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-Ω</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{s}(\Omega)=\{(1-\Delta)^{-s/2}f|f\in L^{2}(\Omega)\}.
  </annotation>
 </semantics>
</math>

 Here Δ is the Laplacian and (1 − Δ)<sup>−<em>s</em>/2</sup> is understood in terms of the <a href="spectral_mapping_theorem" title="wikilink">spectral mapping theorem</a>. Apart from providing a workable definition of Sobolev spaces for non-integer <em>s</em>, this definition also has particularly desirable properties under the <a href="Fourier_transform" title="wikilink">Fourier transform</a> that make it ideal for the study of <a href="pseudodifferential_operator" title="wikilink">pseudodifferential operators</a>. Using these methods on a <a href="compact_space" title="wikilink">compact</a> <a href="Riemannian_manifold" title="wikilink">Riemannian manifold</a>, one can obtain for instance the <a href="Hodge_decomposition" title="wikilink">Hodge decomposition</a>, which is the basis of <a href="Hodge_theory" title="wikilink">Hodge theory</a>.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<h3 id="spaces-of-holomorphic-functions">Spaces of holomorphic functions</h3>
<dl>
<dt>Hardy spaces</dt>
</dl>

<p>The <a href="Hardy_space" title="wikilink">Hardy spaces</a> are function spaces, arising in <a href="complex_analysis" title="wikilink">complex analysis</a> and <a href="harmonic_analysis" title="wikilink">harmonic analysis</a>, whose elements are certain <a href="holomorphic_function" title="wikilink">holomorphic functions</a> in a complex domain.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> Let <em>U</em> denote the <a href="unit_disc" title="wikilink">unit disc</a> in the complex plane. Then the Hardy space <em>H</em><sup>2</sup>(<em>U</em>) is defined as the space of holomorphic functions <em>f</em> on <em>U</em> such that the means</p>

<p>

<math display="block" id="Hilbert_space:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>M</mi>
     <mi>r</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
     </msubsup>
     <mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>r</mi>
            <msup>
             <mi>e</mi>
             <mrow>
              <mi>i</mi>
              <mi>θ</mi>
             </mrow>
            </msup>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mpadded>
      <mi>d</mi>
      <mi>θ</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>r</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <ci>f</ci>
          <apply>
           <times></times>
           <ci>r</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>e</ci>
            <apply>
             <times></times>
             <ci>i</ci>
             <ci>θ</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>d</ci>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{r}(f)=\frac{1}{2\pi}\int_{0}^{2\pi}|f(re^{i\theta})|^{2}\,d\theta
  </annotation>
 </semantics>
</math>

</p>

<p>remain bounded for . The norm on this Hardy space is defined by</p>

<p>

<math display="block" id="Hilbert_space:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo>∥</mo>
      <mi>f</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">lim</mo>
      <mrow>
       <mi>r</mi>
       <mo>→</mo>
       <mn>1</mn>
      </mrow>
     </munder>
     <msqrt>
      <mrow>
       <msub>
        <mi>M</mi>
        <mi>r</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msqrt>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>f</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>r</ci>
       </apply>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|f\|_{2}=\lim_{r\to 1}\sqrt{M_{r}(f)}.
  </annotation>
 </semantics>
</math>

</p>

<p>Hardy spaces in the disc are related to Fourier series. A function <em>f</em> is in <em>H</em><sup>2</sup>(<em>U</em>) if and only if</p>

<p>

<math display="block" id="Hilbert_space:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <msup>
      <mi>z</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(z)=\sum_{n=0}^{\infty}a_{n}z^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Hilbert_space:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </munderover>
     </mpadded>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>a</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{n=0}^{\infty}\,|a_{n}|^{2}<\infty.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus <em>H</em><sup>2</sup>(<em>U</em>) consists of those functions that are L<sup>2</sup> on the circle, and whose negative frequency Fourier coefficients vanish.</p>
<dl>
<dt>Bergman spaces</dt>
</dl>

<p>The <a href="Bergman_space" title="wikilink">Bergman spaces</a> are another family of Hilbert spaces of holomorphic functions.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> Let <em>D</em> be a bounded open set in the <a href="complex_plane" title="wikilink">complex plane</a> (or a higher-dimensional complex space) and let <em>L</em><sup>2,<em>h</em></sup>(<em>D</em>) be the space of holomorphic functions <em>f</em> in <em>D</em> that are also in <em>L</em><sup>2</sup>(<em>D</em>) in the sense that</p>

<p>

<math display="block" id="Hilbert_space:32">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mi>f</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>D</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>z</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mpadded>
      <mi>d</mi>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>f</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>D</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>z</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>d</ci>
       <ci>μ</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|f\|^{2}=\int_{D}|f(z)|^{2}\,d\mu(z)<\infty,
  </annotation>
 </semantics>
</math>

 where the integral is taken with respect to the Lebesgue measure in <em>D</em>. Clearly <em>L</em><sup>2, <em>h</em></sup>(<em>D</em>) is a subspace of <em>L</em><sup>2</sup>(<em>D</em>); in fact, it is a <a href="closed_set" title="wikilink">closed</a> subspace, and so a Hilbert space in its own right. This is a consequence of the estimate, valid on <a href="compact_space" title="wikilink">compact</a> subsets <em>K</em> of <em>D</em>, that</p>

<p>

<math display="block" id="Hilbert_space:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo movablelimits="false">sup</mo>
      <mrow>
       <mi>z</mi>
       <mo>∈</mo>
       <mi>K</mi>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>K</mi>
     </msub>
     <msub>
      <mrow>
       <mo>∥</mo>
       <mi>f</mi>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <in></in>
       <ci>z</ci>
       <ci>K</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>f</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sup_{z\in K}|f(z)|\leq C_{K}\|f\|_{2},
  </annotation>
 </semantics>
</math>

 which in turn follows from <a href="Cauchy's_integral_formula" title="wikilink">Cauchy's integral formula</a>. Thus convergence of a sequence of holomorphic functions in <em>L</em><sup>2</sup>(<em>D</em>) implies also <a href="compact_convergence" title="wikilink">compact convergence</a>, and so the limit function is also holomorphic. Another consequence of this inequality is that the linear functional that evaluates a function <em>f</em> at a point of <em>D</em> is actually continuous on <em>L</em><sup>2,<em>h</em></sup>(<em>D</em>). The Riesz representation theorem implies that the evaluation functional can be represented as an element of <em>L</em><sup>2,<em>h</em></sup>(<em>D</em>). Thus, for every <em>z</em> ∈ <em>D</em>, there is a function η<sub><em>z</em></sub> ∈ <em>L</em><sup>2,<em>h</em></sup>(<em>D</em>) such that</p>

<p>

<math display="block" id="Hilbert_space:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>D</mi>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ζ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mpadded width="+1.7pt">
      <mover accent="true">
       <mrow>
        <msub>
         <mi>η</mi>
         <mi>z</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ζ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>¯</mo>
      </mover>
     </mpadded>
     <mi>d</mi>
     <mi>μ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ζ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>D</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>ζ</ci>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>η</ci>
         <ci>z</ci>
        </apply>
        <ci>ζ</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>μ</ci>
      <ci>ζ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(z)=\int_{D}f(\zeta)\overline{\eta_{z}(\zeta)}\,d\mu(\zeta)
  </annotation>
 </semantics>
</math>

 for all <em>f</em> ∈ <em>L</em><sup>2,<em>h</em></sup>(<em>D</em>). The integrand</p>

<p>

<math display="block" id="Hilbert_space:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ζ</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mover accent="true">
    <mrow>
     <msub>
      <mi>η</mi>
      <mi>z</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ζ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>ζ</ci>
      <ci>z</ci>
     </interval>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>η</ci>
       <ci>z</ci>
      </apply>
      <ci>ζ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(\zeta,z)=\overline{\eta_{z}(\zeta)}
  </annotation>
 </semantics>
</math>

 is known as the <a href="Bergman_kernel" title="wikilink">Bergman kernel</a> of <em>D</em>. This <a href="integral_kernel" title="wikilink">integral kernel</a> satisfies a reproducing property</p>

<p>

<math display="block" id="Hilbert_space:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>D</mi>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ζ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ζ</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ζ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>D</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>ζ</ci>
      <ci>K</ci>
      <interval closure="open">
       <ci>ζ</ci>
       <ci>z</ci>
      </interval>
      <ci>d</ci>
      <ci>μ</ci>
      <ci>ζ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(z)=\int_{D}f(\zeta)K(\zeta,z)\,d\mu(\zeta).
  </annotation>
 </semantics>
</math>

</p>

<p>A Bergman space is an example of a <a href="reproducing_kernel_Hilbert_space" title="wikilink">reproducing kernel Hilbert space</a>, which is a Hilbert space of functions along with a kernel <em>K</em>(ζ,<em>z</em>) that verifies a reproducing property analogous to this one. The Hardy space <em>H</em><sup>2</sup>(<em>D</em>) also admits a reproducing kernel, known as the <a href="Szegő_kernel" title="wikilink">Szegő kernel</a>.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> Reproducing kernels are common in other areas of mathematics as well. For instance, in <a href="harmonic_analysis" title="wikilink">harmonic analysis</a> the <a href="Poisson_kernel" title="wikilink">Poisson kernel</a> is a reproducing kernel for the Hilbert space of square-integrable <a href="harmonic_function" title="wikilink">harmonic functions</a> in the <a href="unit_ball" title="wikilink">unit ball</a>. That the latter is a Hilbert space at all is a consequence of the mean value theorem for harmonic functions.</p>
<h2 id="applications">Applications</h2>

<p>Many of the applications of Hilbert spaces exploit the fact that Hilbert spaces support generalizations of simple geometric concepts like <a href="projection_operator" title="wikilink">projection</a> and <a href="change_of_basis" title="wikilink">change of basis</a> from their usual finite dimensional setting. In particular, the <a href="spectral_theory" title="wikilink">spectral theory</a> of <a href="continuous_function" title="wikilink">continuous</a> <a href="self-adjoint_operator" title="wikilink">self-adjoint</a> <a href="linear_operator" title="wikilink">linear operators</a> on a Hilbert space generalizes the usual <a href="spectral_decomposition" title="wikilink">spectral decomposition</a> of a <a href="matrix_(mathematics)" title="wikilink">matrix</a>, and this often plays a major role in applications of the theory to other areas of mathematics and physics.</p>
<h3 id="sturmliouville-theory">Sturm–Liouville theory</h3>

<p> In the theory of <a href="ordinary_differential_equation" title="wikilink">ordinary differential equations</a>, spectral methods on a suitable Hilbert space are used to study the behavior of eigenvalues and eigenfunctions of differential equations. For example, the <a href="Sturm–Liouville_theory" title="wikilink">Sturm–Liouville problem</a> arises in the study of the harmonics of waves in a violin string or a drum, and is a central problem in <a href="ordinary_differential_equations" title="wikilink">ordinary differential equations</a>.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> The problem is a differential equation of the form</p>

<p>

<math display="block" id="Hilbert_space:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mi>d</mi>
       <mrow>
        <mi>d</mi>
        <mi>x</mi>
       </mrow>
      </mfrac>
      <mrow>
       <mo>[</mo>
       <mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mfrac>
         <mrow>
          <mi>d</mi>
          <mi>y</mi>
         </mrow>
         <mrow>
          <mi>d</mi>
          <mi>x</mi>
         </mrow>
        </mfrac>
       </mrow>
       <mo>]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>y</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>d</ci>
        <apply>
         <times></times>
         <ci>d</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>x</ci>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <ci>d</ci>
           <ci>y</ci>
          </apply>
          <apply>
           <times></times>
           <ci>d</ci>
           <ci>x</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>q</ci>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>w</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\frac{d}{dx}\left[p(x)\frac{dy}{dx}\right]+q(x)y=\lambda w(x)y
  </annotation>
 </semantics>
</math>

 for an unknown function <em>y</em> on an interval [<em>a</em>,<em>b</em>], satisfying general homogeneous <a href="Robin_boundary_conditions" title="wikilink">Robin boundary conditions</a></p>

<p>

<math display="block" id="Hilbert_space:38">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mrow>
         <mi>α</mi>
         <mi>y</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msup>
          <mi>α</mi>
          <mo>′</mo>
         </msup>
         <msup>
          <mi>y</mi>
          <mo>′</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mrow>
         <mi>β</mi>
         <mi>y</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>b</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msup>
          <mi>β</mi>
          <mo>′</mo>
         </msup>
         <msup>
          <mi>y</mi>
          <mo>′</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>b</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0.</mn>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>y</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>a</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>y</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>β</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>b</ci>
      </apply>
     </apply>
     <cn type="float">0.</cn>
    </apply>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}\alpha y(a)+\alpha^{\prime}y^{\prime}(a)=0\\
\beta y(b)+\beta^{\prime}y^{\prime}(b)=0.\end{cases}
  </annotation>
 </semantics>
</math>

 The functions <em>p</em>, <em>q</em>, and <em>w</em> are given in advance, and the problem is to find the function <em>y</em> and constants λ for which the equation has a solution. The problem only has solutions for certain values of λ, called eigenvalues of the system, and this is a consequence of the spectral theorem for <a href="compact_operator" title="wikilink">compact operators</a> applied to the <a href="integral_operator" title="wikilink">integral operator</a> defined by the <a href="Green's_function" title="wikilink">Green's function</a> for the system. Furthermore, another consequence of this general result is that the eigenvalues λ of the system can be arranged in an increasing sequence tending to infinity.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<h3 id="partial-differential-equations">Partial differential equations</h3>

<p>Hilbert spaces form a basic tool in the study of <a href="partial_differential_equations" title="wikilink">partial differential equations</a>.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> For many classes of partial differential equations, such as linear <a href="elliptic_partial_differential_equation" title="wikilink">elliptic equations</a>, it is possible to consider a generalized solution (known as a <a href="weak_derivative" title="wikilink">weak</a> solution) by enlarging the class of functions. Many weak formulations involve the class of <a href="Sobolev_space" title="wikilink">Sobolev functions</a>, which is a Hilbert space. A suitable weak formulation reduces to a geometrical problem the analytic problem of finding a solution or, often what is more important, showing that a solution exists and is unique for given boundary data. For linear elliptic equations, one geometrical result that ensures unique solvability for a large class of problems is the <a href="Lax–Milgram_theorem" title="wikilink">Lax–Milgram theorem</a>. This strategy forms the rudiment of the <a href="Galerkin_method" title="wikilink">Galerkin method</a> (a <a href="finite_element_method" title="wikilink">finite element method</a>) for numerical solution of partial differential equations.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>

<p>A typical example is the <a href="Poisson_equation" title="wikilink">Poisson equation</a>  with <a href="Dirichlet_boundary_conditions" title="wikilink">Dirichlet boundary conditions</a> in a bounded domain Ω in <strong>R</strong><sup>2</sup>. The weak formulation consists of finding a function <em>u</em> such that, for all continuously differentiable functions <em>v</em> in Ω vanishing on the boundary:</p>

<p>

<math display="block" id="Hilbert_space:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>u</mi>
      </mrow>
      <mo>⋅</mo>
      <mrow>
       <mo>∇</mo>
       <mi>v</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mi>g</mi>
      <mi>v</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <ci>normal-∇</ci>
       <ci>u</ci>
      </apply>
      <apply>
       <ci>normal-∇</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\Omega}\nabla u\cdot\nabla v=\int_{\Omega}gv.
  </annotation>
 </semantics>
</math>

</p>

<p>This can be recast in terms of the Hilbert space <em>H</em>(Ω) consisting of functions <em>u</em> such that <em>u</em>, along with its weak partial derivatives, are square integrable on Ω, and vanish on the boundary. The question then reduces to finding <em>u</em> in this space such that for all <em>v</em> in this space</p>

<p>

<math display="block" id="Hilbert_space:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>a</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(u,v)=b(v)
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>a</em> is a continuous <a href="bilinear_form" title="wikilink">bilinear form</a>, and <em>b</em> is a continuous <a href="linear_functional" title="wikilink">linear functional</a>, given respectively by</p>

<p>

<math display="block" id="Hilbert_space:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi mathvariant="normal">Ω</mi>
      </msub>
      <mrow>
       <mrow>
        <mo>∇</mo>
        <mi>u</mi>
       </mrow>
       <mo>⋅</mo>
       <mrow>
        <mo>∇</mo>
        <mi>v</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>b</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi mathvariant="normal">Ω</mi>
      </msub>
      <mrow>
       <mi>g</mi>
       <mi>v</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>a</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Ω</ci>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <ci>normal-∇</ci>
        <ci>u</ci>
       </apply>
       <apply>
        <ci>normal-∇</ci>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Ω</ci>
      </apply>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(u,v)=\int_{\Omega}\nabla u\cdot\nabla v,\quad b(v)=\int_{\Omega}gv.
  </annotation>
 </semantics>
</math>

</p>

<p>Since the Poisson equation is <a href="elliptic_partial_differential_equation" title="wikilink">elliptic</a>, it follows from Poincaré's inequality that the bilinear form <em>a</em> is <a href="coercive_function" title="wikilink">coercive</a>. The Lax–Milgram theorem then ensures the existence and uniqueness of solutions of this equation.</p>

<p>Hilbert spaces allow for many elliptic partial differential equations to be formulated in a similar way, and the Lax–Milgram theorem is then a basic tool in their analysis. With suitable modifications, similar techniques can be applied to <a href="parabolic_partial_differential_equation" title="wikilink">parabolic partial differential equations</a> and certain <a href="hyperbolic_partial_differential_equation" title="wikilink">hyperbolic partial differential equations</a>.</p>
<h3 id="ergodic-theory">Ergodic theory</h3>

<p> The field of <a href="ergodic_theory" title="wikilink">ergodic theory</a> is the study of the long-term behavior of <a href="chaos_theory" title="wikilink">chaotic</a> <a href="dynamical_system" title="wikilink">dynamical systems</a>. The protypical case of a field that ergodic theory applies to is <a class="uri" href="thermodynamics" title="wikilink">thermodynamics</a>, in which—though the microscopic state of a system is extremely complicated (it is impossible to understand the ensemble of individual collisions between particles of matter)—the average behavior over sufficiently long time intervals is tractable. The <a href="laws_of_thermodynamics" title="wikilink">laws of thermodynamics</a> are assertions about such average behavior. In particular, one formulation of the <a href="zeroth_law_of_thermodynamics" title="wikilink">zeroth law of thermodynamics</a> asserts that over sufficiently long timescales, the only functionally independent measurement that one can make of a thermodynamic system in equilibrium is its total energy, in the form of <a class="uri" href="temperature" title="wikilink">temperature</a>.</p>

<p>An ergodic dynamical system is one for which, apart from the energy—measured by the <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonian</a>—there are no other functionally independent <a href="conserved_quantities" title="wikilink">conserved quantities</a> on the <a href="phase_space" title="wikilink">phase space</a>. More explicitly, suppose that the energy <em>E</em> is fixed, and let Ω<sub><em>E</em></sub> be the subset of the phase space consisting of all states of energy <em>E</em> (an energy surface), and let <em>T</em><sub><em>t</em></sub> denote the evolution operator on the phase space. The dynamical system is ergodic if there are no continuous non-constant functions on Ω<sub><em>E</em></sub> such that</p>

<p>

<math display="block" id="Hilbert_space:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>T</mi>
       <mi>t</mi>
      </msub>
      <mi>w</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>t</ci>
      </apply>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(T_{t}w)=f(w)\,
  </annotation>
 </semantics>
</math>

 for all <em>w</em> on Ω<sub><em>E</em></sub> and all time <em>t</em>. <a href="Liouville's_theorem_(Hamiltonian)" title="wikilink">Liouville's theorem</a> implies that there exists a <a href="measure_theory" title="wikilink">measure</a> μ on the energy surface that is invariant under the time translation. As a result, time translation is a <a href="unitary_transformation" title="wikilink">unitary transformation</a> of the Hilbert space <em>L</em><sup>2</sup>(Ω<sub><em>E</em></sub>,μ) consisting of square-integrable functions on the energy surface Ω<sub><em>E</em></sub> with respect to the inner product</p>

<p>

<math display="block" id="Hilbert_space:43">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>f</mi>
      <mo>,</mo>
      <mi>g</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <msup>
       <mi>L</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi mathvariant="normal">Ω</mi>
        <mi>E</mi>
       </msub>
       <mo>,</mo>
       <mi>μ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>E</mi>
     </msub>
     <mrow>
      <mi>f</mi>
      <mpadded width="+1.7pt">
       <mover accent="true">
        <mi>g</mi>
        <mo stretchy="false">¯</mo>
       </mover>
      </mpadded>
      <mi>d</mi>
      <mi>μ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <ci>f</ci>
      <ci>g</ci>
     </list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ω</ci>
        <ci>E</ci>
       </apply>
       <ci>μ</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>E</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>g</ci>
      </apply>
      <ci>d</ci>
      <ci>μ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f,g\rangle_{L^{2}(\Omega_{E},\mu)}=\int_{E}f\bar{g}\,d\mu.
  </annotation>
 </semantics>
</math>

</p>

<p>The von Neumann mean ergodic theorem<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> states the following:</p>
<ul>
<li>If <em>U</em><sub><em>t</em></sub> is a (strongly continuous) one-parameter semigroup of unitary operators on a Hilbert space <em>H</em>, and <em>P</em> is the orthogonal projection onto the space of common fixed points of <em>U</em><sub><em>t</em></sub>, {<em>x</em>∈<em>H</em> | <em>U</em><sub><em>t</em></sub><em>x</em> = <em>x</em> for all <em>t</em> &gt; 0}, then</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hilbert_space:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo>lim</mo>
      <mrow>
       <mi>T</mi>
       <mo>→</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </msub>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mi>T</mi>
      </mfrac>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∫</mo>
        <mn>0</mn>
        <mi>T</mi>
       </msubsup>
       <mrow>
        <msub>
         <mi>U</mi>
         <mi>t</mi>
        </msub>
        <mpadded width="+1.7pt">
         <mi>x</mi>
        </mpadded>
        <mi>d</mi>
        <mi>t</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>T</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>T</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <cn type="integer">0</cn>
        </apply>
        <ci>T</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <ci>t</ci>
        </apply>
        <ci>x</ci>
        <ci>d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Px=\lim_{T\to\infty}\frac{1}{T}\int_{0}^{T}U_{t}x\,dt.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>For an ergodic system, the fixed set of the time evolution consists only of the constant functions, so the ergodic theorem implies the following:<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> for any function <em>f</em> ∈ <em>L</em><sup>2</sup>(Ω<sub><em>E</em></sub>,μ),</p>

<p>

<math display="block" id="Hilbert_space:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder accentunder="true">
      <mrow>
       <mpadded width="-1.7pt">
        <msup>
         <mi>L</mi>
         <mn>2</mn>
        </msup>
       </mpadded>
       <mo rspace="0.8pt">-</mo>
       <mo movablelimits="false">lim</mo>
      </mrow>
      <mrow>
       <mi>T</mi>
       <mo>→</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </munder>
     <mfrac>
      <mn>1</mn>
      <mi>T</mi>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mn>0</mn>
       <mi>T</mi>
      </msubsup>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>T</mi>
          <mi>t</mi>
         </msub>
         <mi>w</mi>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <msub>
       <mi mathvariant="normal">Ω</mi>
       <mi>E</mi>
      </msub>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <ci>normal-→</ci>
       <ci>T</ci>
       <infinity></infinity>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
       <limit></limit>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>T</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <ci>t</ci>
        </apply>
        <ci>w</ci>
       </apply>
       <ci>d</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Ω</ci>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>y</ci>
      <ci>d</ci>
      <ci>μ</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underset{T\to\infty}{L^{2}\!-\!\lim}\frac{1}{T}\int_{0}^{T}f(T_{t}w)\,dt=\int%
_{\Omega_{E}}f(y)\,d\mu(y).
  </annotation>
 </semantics>
</math>

 That is, the long time average of an observable <em>f</em> is equal to its expectation value over an energy surface.</p>
<h3 id="fourier-analysis">Fourier analysis</h3>

<p>  One of the basic goals of <a href="Fourier_analysis" title="wikilink">Fourier analysis</a> is to decompose a function into a (possibly infinite) <a href="linear_combination" title="wikilink">linear combination</a> of given basis functions: the associated <a href="Fourier_series" title="wikilink">Fourier series</a>. The classical Fourier series associated to a function <em>f</em> defined on the interval [0, 1] is a series of the form</p>

<p>

<math display="block" id="Hilbert_space:46">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </munderover>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <msup>
     <mi>e</mi>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
      <mi>n</mi>
      <mi>θ</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
       <ci>n</ci>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{n=-\infty}^{\infty}a_{n}e^{2\pi in\theta}
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Hilbert_space:47">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mn>1</mn>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mn>2</mn>
          <mi>π</mi>
          <mi>i</mi>
          <mi>n</mi>
          <mi>θ</mi>
         </mrow>
        </mrow>
       </msup>
      </mpadded>
      <mi>d</mi>
      <mi>θ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>θ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>i</ci>
         <ci>n</ci>
         <ci>θ</ci>
        </apply>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{n}=\int_{0}^{1}f(\theta)e^{-2\pi in\theta}\,d\theta.
  </annotation>
 </semantics>
</math>

</p>

<p>The example of adding up the first few terms in a Fourier series for a sawtooth function is shown in the figure. The basis functions are sine waves with wavelengths λ/<em>n</em> (<em>n</em>=integer) shorter than the wavelength λ of the sawtooth itself (except for <em>n</em>=1, the <em>fundamental</em> wave). All basis functions have nodes at the nodes of the sawtooth, but all but the fundamental have additional nodes. The oscillation of the summed terms about the sawtooth is called the <a href="Gibbs_phenomenon" title="wikilink">Gibbs phenomenon</a>.</p>

<p>A significant problem in classical Fourier series asks in what sense the Fourier series converges, if at all, to the function <em>f</em>. Hilbert space methods provide one possible answer to this question.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> The functions <em>e<sub>n</sub></em>(θ) = e<sup>2πi<em>n</em>θ</sup> form an orthogonal basis of the Hilbert space <em>L</em><sup>2</sup>([0,1]). Consequently, any square-integrable function can be expressed as a series</p>

<p>

<math display="block" id="Hilbert_space:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>n</mi>
     </munder>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>e</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>f</mi>
     <mo>,</mo>
     <msub>
      <mi>e</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>θ</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>n</ci>
       </apply>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <list>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\theta)=\sum_{n}a_{n}e_{n}(\theta),\quad a_{n}=\langle f,e_{n}\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>and, moreover, this series converges in the Hilbert space sense (that is, in the <a href="mean_convergence" title="wikilink"><em>L</em><sup>2</sup> mean</a>).</p>

<p>The problem can also be studied from the abstract point of view: every Hilbert space has an <a href="orthonormal_basis" title="wikilink">orthonormal basis</a>, and every element of the Hilbert space can be written in a unique way as a sum of multiples of these basis elements. The coefficients appearing on these basis elements are sometimes known abstractly as the Fourier coefficients of the element of the space.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> The abstraction is especially useful when it is more natural to use different basis functions for a space such as <em>L</em><sup>2</sup>([0,1]). In many circumstances, it is desirable not to decompose a function into trigonometric functions, but rather into <a href="orthogonal_polynomials" title="wikilink">orthogonal polynomials</a> or <a href="wavelet" title="wikilink">wavelets</a> for instance,<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> and in higher dimensions into <a href="spherical_harmonics" title="wikilink">spherical harmonics</a>.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>

<p>For instance, if <em>e</em><sub><em>n</em></sub> are any orthonormal basis functions of <em>L</em><sup>2</sup>[0,1], then a given function in <em>L</em><sup>2</sup>[0,1] can be approximated as a finite linear combination<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>

<p>

<math display="block" id="Hilbert_space:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>e</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>e</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>e</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>x</ci>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>n</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)\approx f_{n}(x)=a_{1}e_{1}(x)+a_{2}e_{2}(x)+\cdots+a_{n}e_{n}(x).
  </annotation>
 </semantics>
</math>

 The coefficients {<em>a</em><sub><em>j</em></sub>} are selected to make the magnitude of the difference ||<mtpl></mtpl>||<sup>2</sup> as small as possible. Geometrically, the <a href="#Best_approximation" title="wikilink">best approximation</a> is the <a href="#Orthogonal_complements_and_projections" title="wikilink">orthogonal projection</a> of <em>ƒ</em> onto the subspace consisting of all linear combinations of the {<em>e</em><sub><em>j</em></sub>}, and can be calculated by<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a></p>

<p>

<math display="block" id="Hilbert_space:50">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>j</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mn>1</mn>
     </msubsup>
     <mrow>
      <mover accent="true">
       <mrow>
        <msub>
         <mi>e</mi>
         <mi>j</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>¯</mo>
      </mover>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <ci>j</ci>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>f</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{j}=\int_{0}^{1}\overline{e_{j}(x)}f(x)\,dx.
  </annotation>
 </semantics>
</math>

 That this formula minimizes the difference ||<mtpl></mtpl>||<sup>2</sup> is a consequence of <a href="#Bessel's_inequality_and_Parseval's_formula" title="wikilink">Bessel's inequality and Parseval's formula</a>.</p>

<p>In various applications to physical problems, a function can be decomposed into physically meaningful <a href="eigenfunction" title="wikilink">eigenfunctions</a> of a <a href="differential_operator" title="wikilink">differential operator</a> (typically the <a href="Laplace_operator" title="wikilink">Laplace operator</a>): this forms the foundation for the spectral study of functions, in reference to the <a href="spectral_theorem" title="wikilink">spectrum</a> of the differential operator.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> A concrete physical application involves the problem of <a href="hearing_the_shape_of_a_drum" title="wikilink">hearing the shape of a drum</a>: given the fundamental modes of vibration that a drumhead is capable of producing, can one infer the shape of the drum itself?<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> The mathematical formulation of this question involves the <a href="Dirichlet_eigenvalue" title="wikilink">Dirichlet eigenvalues</a> of the Laplace equation in the plane, that represent the fundamental modes of vibration in direct analogy with the integers that represent the fundamental modes of vibration of the violin string.</p>

<p><a href="Spectral_theory" title="wikilink">Spectral theory</a> also underlies certain aspects of the <a href="Fourier_transform" title="wikilink">Fourier transform</a> of a function. Whereas Fourier analysis decomposes a function defined on a <a href="compact_set" title="wikilink">compact set</a> into the discrete spectrum of the Laplacian (which corresponds to the vibrations of a violin string or drum), the Fourier transform of a function is the decomposition of a function defined on all of Euclidean space into its components in the <a href="continuous_spectrum" title="wikilink">continuous spectrum</a> of the Laplacian. The Fourier transformation is also geometrical, in a sense made precise by the <a href="Plancherel_theorem" title="wikilink">Plancherel theorem</a>, that asserts that it is an <a class="uri" href="isometry" title="wikilink">isometry</a> of one Hilbert space (the "time domain") with another (the "frequency domain"). This isometry property of the Fourier transformation is a recurring theme in abstract <a href="harmonic_analysis" title="wikilink">harmonic analysis</a>, as evidenced for instance by the <a href="Plancherel_theorem_for_spherical_functions" title="wikilink">Plancherel theorem for spherical functions</a> occurring in <a href="noncommutative_harmonic_analysis" title="wikilink">noncommutative harmonic analysis</a>.</p>
<h3 id="quantum-mechanics">Quantum mechanics</h3>

<p> In the mathematically rigorous formulation of <a href="quantum_mechanics" title="wikilink">quantum mechanics</a>, developed by <a href="John_von_Neumann" title="wikilink">John von Neumann</a>,<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> the possible states (more precisely, the <a href="pure_state" title="wikilink">pure states</a>) of a quantum mechanical system are represented by <a href="unit_vector" title="wikilink">unit vectors</a> (called <em>state vectors</em>) residing in a complex separable Hilbert space, known as the <a href="State_space_(physics)" title="wikilink">state space</a>, well defined up to a complex number of norm 1 (the phase factor). In other words, the possible states are points in the <a href="projective_space" title="wikilink">projectivization</a> of a Hilbert space, usually called the <a href="complex_projective_space" title="wikilink">complex projective space</a>. The exact nature of this Hilbert space is dependent on the system; for example, the position and momentum states for a single non-relativistic spin zero particle is the space of all <a class="uri" href="square-integrable" title="wikilink">square-integrable</a> functions, while the states for the spin of a single proton are unit elements of the two-dimensional complex Hilbert space of <a href="spinors_in_three_dimensions" title="wikilink">spinors</a>. Each observable is represented by a <a href="self-adjoint_operator" title="wikilink">self-adjoint</a> <a href="linear_operator" title="wikilink">linear operator</a> acting on the state space. Each eigenstate of an observable corresponds to an <a class="uri" href="eigenvector" title="wikilink">eigenvector</a> of the operator, and the associated <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> corresponds to the value of the observable in that eigenstate.</p>

<p>The inner product between two state vectors is a complex number known as a <a href="probability_amplitude" title="wikilink">probability amplitude</a>. During an ideal measurement of a quantum mechanical system, the probability that a system collapses from a given initial state to a particular eigenstate is given by the square of the <a href="absolute_value" title="wikilink">absolute value</a> of the probability amplitudes between the initial and final states. The possible results of a measurement are the eigenvalues of the operator—which explains the choice of self-adjoint operators, for all the eigenvalues must be real. The probability distribution of an observable in a given state can be found by computing the spectral decomposition of the corresponding operator.</p>

<p>For a general system, states are typically not pure, but instead are represented as statistical mixtures of pure states, or mixed states, given by <a href="density_matrix" title="wikilink">density matrices</a>: self-adjoint operators of <a href="trace_of_a_matrix" title="wikilink">trace</a> one on a Hilbert space. Moreover, for general quantum mechanical systems, the effects of a single measurement can influence other parts of a system in a manner that is described instead by a <a href="positive_operator_valued_measure" title="wikilink">positive operator valued measure</a>. Thus the structure both of the states and observables in the general theory is considerably more complicated than the idealization for pure states.</p>
<h2 id="properties">Properties</h2>
<h3 id="pythagorean-identity">Pythagorean identity</h3>

<p>Two vectors <em>u</em> and <em>v</em> in a Hilbert space <em>H</em> are orthogonal when 

<math display="inline" id="Hilbert_space:51">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>u</ci>
    <ci>v</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle u,v\rangle
  </annotation>
 </semantics>
</math>

 = 0. The notation for this is . More generally, when <em>S</em> is a subset in <em>H</em>, the notation  means that <em>u</em> is orthogonal to every element from <em>S</em>.<br/>
When <em>u</em> and <em>v</em> are orthogonal, one has</p>

<p>

<math display="block" id="Hilbert_space:52">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>u</mi>
       <mo>+</mo>
       <mi>v</mi>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>u</mi>
      <mo>+</mo>
      <mi>v</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>u</mi>
      <mo>+</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mn>2</mn>
      </mpadded>
      <mi>Re</mi>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mi>u</mi>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mi>v</mi>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <plus></plus>
        <ci>u</ci>
        <ci>v</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <list>
      <apply>
       <plus></plus>
       <ci>u</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>u</ci>
       <ci>v</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <list>
       <ci>u</ci>
       <ci>u</ci>
      </list>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>Re</ci>
       <list>
        <ci>u</ci>
        <ci>v</ci>
       </list>
      </apply>
      <list>
       <ci>v</ci>
       <ci>v</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>u</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>v</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|u+v\|^{2}=\langle u+v,u+v\rangle=\langle u,u\rangle+2\,\mathrm{Re}\langle u,%
v\rangle+\langle v,v\rangle=\|u\|^{2}+\|v\|^{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>By induction on <em>n</em>, this is extended to any family <em>u</em><sub>1</sub>,...,<em>u<sub>n</sub></em> of <em>n</em> orthogonal vectors,</p>

<p>

<math display="block" id="Hilbert_space:53">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <msub>
        <mi>u</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>+</mo>
       <msub>
        <mi>u</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>∥</mo>
       <msub>
        <mi>u</mi>
        <mn>1</mn>
       </msub>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo>∥</mo>
       <msub>
        <mi>u</mi>
        <mi>n</mi>
       </msub>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|u_{1}+\cdots+u_{n}\|^{2}=\|u_{1}\|^{2}+\cdots+\|u_{n}\|^{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>Whereas the Pythagorean identity as stated is valid in any inner product space, completeness is required for the extension of the Pythagorean identity to series. A series Σ <em>u<sub>k</sub></em> of <em>orthogonal</em> vectors converges in <em>H</em>  if and only if the series of squares of norms converges, and</p>

<p>

<math display="block" id="Hilbert_space:54">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo fence="true" maxsize="120%" minsize="120%">∥</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>k</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi mathvariant="normal">∞</mi>
       </munderover>
       <msub>
        <mi>u</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mo fence="true" maxsize="120%" minsize="120%">∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <msup>
      <mrow>
       <mo>∥</mo>
       <msub>
        <mi>u</mi>
        <mi>k</mi>
       </msub>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigl\|\sum_{k=0}^{\infty}u_{k}\bigr\|^{2}=\sum_{k=0}^{\infty}\|u_{k}\|^{2}.
  </annotation>
 </semantics>
</math>

 Furthermore, the sum of a series of orthogonal vectors is independent of the order in which it is taken.</p>
<h3 id="parallelogram-identity-and-polarization">Parallelogram identity and polarization</h3>

<p> By definition, every Hilbert space is also a <a href="Banach_space" title="wikilink">Banach space</a>. Furthermore, in every Hilbert space the following <a href="parallelogram_identity" title="wikilink">parallelogram identity</a> holds:</p>

<p>

<math display="block" id="Hilbert_space:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mi>u</mi>
        <mo>+</mo>
        <mi>v</mi>
       </mrow>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mi>u</mi>
        <mo>-</mo>
        <mi>v</mi>
       </mrow>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo>∥</mo>
         <mi>u</mi>
         <mo>∥</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo>+</mo>
       <msup>
        <mrow>
         <mo>∥</mo>
         <mi>v</mi>
         <mo>∥</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <plus></plus>
        <ci>u</ci>
        <ci>v</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>u</ci>
        <ci>v</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>u</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>v</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|u+v\|^{2}+\|u-v\|^{2}=2(\|u\|^{2}+\|v\|^{2}).
  </annotation>
 </semantics>
</math>

 Conversely, every Banach space in which the parallelogram identity holds is a Hilbert space, and the inner product is uniquely determined by the norm by the <a href="polarization_identity" title="wikilink">polarization identity</a>.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> For real Hilbert spaces, the polarization identity is</p>

<p>

<math display="block" id="Hilbert_space:56">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>4</mn>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo>∥</mo>
         <mrow>
          <mi>u</mi>
          <mo>+</mo>
          <mi>v</mi>
         </mrow>
         <mo>∥</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo>-</mo>
       <msup>
        <mrow>
         <mo>∥</mo>
         <mrow>
          <mi>u</mi>
          <mo>-</mo>
          <mi>v</mi>
         </mrow>
         <mo>∥</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>u</ci>
     <ci>v</ci>
    </list>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <plus></plus>
         <ci>u</ci>
         <ci>v</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <ci>u</ci>
         <ci>v</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle u,v\rangle=\frac{1}{4}\left(\|u+v\|^{2}-\|u-v\|^{2}\right).
  </annotation>
 </semantics>
</math>

 For complex Hilbert spaces, it is</p>

<p>

<math display="block" id="Hilbert_space:57">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>4</mn>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mrow>
         <msup>
          <mrow>
           <mo>∥</mo>
           <mrow>
            <mi>u</mi>
            <mo>+</mo>
            <mi>v</mi>
           </mrow>
           <mo>∥</mo>
          </mrow>
          <mn>2</mn>
         </msup>
         <mo>-</mo>
         <msup>
          <mrow>
           <mo>∥</mo>
           <mrow>
            <mi>u</mi>
            <mo>-</mo>
            <mi>v</mi>
           </mrow>
           <mo>∥</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>i</mi>
         <msup>
          <mrow>
           <mo>∥</mo>
           <mrow>
            <mi>u</mi>
            <mo>+</mo>
            <mrow>
             <mi>i</mi>
             <mi>v</mi>
            </mrow>
           </mrow>
           <mo>∥</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>i</mi>
        <msup>
         <mrow>
          <mo>∥</mo>
          <mrow>
           <mi>u</mi>
           <mo>-</mo>
           <mrow>
            <mi>i</mi>
            <mi>v</mi>
           </mrow>
          </mrow>
          <mo>∥</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>u</ci>
     <ci>v</ci>
    </list>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">norm</csymbol>
          <apply>
           <plus></plus>
           <ci>u</ci>
           <ci>v</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">norm</csymbol>
          <apply>
           <minus></minus>
           <ci>u</ci>
           <ci>v</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>i</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">norm</csymbol>
          <apply>
           <plus></plus>
           <ci>u</ci>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>v</ci>
           </apply>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <ci>u</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>v</ci>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle u,v\rangle=\frac{1}{4}\left(\|u+v\|^{2}-\|u-v\|^{2}+i\|u+iv\|^{2}-i\|u%
-iv\|^{2}\right).
  </annotation>
 </semantics>
</math>

 The parallelogram law implies that any Hilbert space is a <a href="uniformly_convex_Banach_space" title="wikilink">uniformly convex Banach space</a>.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></p>
<h3 id="best-approximation">Best approximation</h3>

<p>This subsection employs the <a href="Hilbert_projection_theorem" title="wikilink">Hilbert projection theorem</a>. If <em>C</em> is a non-empty closed convex subset of a Hilbert space <em>H</em> and <em>x</em> a point in <em>H</em>, there exists a unique point <em>y</em> ∈ <em>C</em> that minimizes the distance between <em>x</em> and points in <em>C</em>,<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a></p>

<p>

<math display="block" id="Hilbert_space:58">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mo>∈</mo>
     <mi>C</mi>
    </mrow>
    <mo rspace="17.5pt">,</mo>
    <mrow>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>dist</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>min</mi>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mrow>
         <mo>∥</mo>
         <mrow>
          <mi>x</mi>
          <mo>-</mo>
          <mi>z</mi>
         </mrow>
         <mo>∥</mo>
        </mrow>
        <mo>:</mo>
        <mrow>
         <mi>z</mi>
         <mo>∈</mo>
         <mi>C</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>y</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>dist</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>C</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <min></min>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <ci>x</ci>
          <ci>z</ci>
         </apply>
        </apply>
        <apply>
         <in></in>
         <ci>z</ci>
         <ci>C</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in C,\ \ \ \|x-y\|=\mathrm{dist}(x,C)=\min\{\|x-z\|:z\in C\}.
  </annotation>
 </semantics>
</math>

</p>

<p>This is equivalent to saying that there is a point with minimal norm in the translated convex set <em>D</em> = . The proof consists in showing that every minimizing sequence (<em>d<sub>n</sub></em>) ⊂ <em>D</em> is Cauchy (using the parallelogram identity) hence converges (using completeness) to a point in <em>D</em> that has minimal norm. More generally, this holds in any uniformly convex Banach space.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a></p>

<p>When this result is applied to a closed subspace <em>F</em> of <em>H</em>, it can be shown that the point <em>y</em> ∈ <em>F</em> closest to <em>x</em> is characterized by<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a></p>

<p>

<math display="block" id="Hilbert_space:59">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mo>∈</mo>
     <mi>F</mi>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo>⟂</mo>
     <mi>F</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>y</ci>
     <ci>F</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">perpendicular-to</csymbol>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in F,\ \ x-y\perp F.
  </annotation>
 </semantics>
</math>

</p>

<p>This point <em>y</em> is the <em>orthogonal projection</em> of <em>x</em> onto <em>F</em>, and the mapping <em>P<sub>F</sub></em> :  is linear (see <a href="#Orthogonal_complements_and_projections" title="wikilink">Orthogonal complements and projections</a>). This result is especially significant in <a href="applied_mathematics" title="wikilink">applied mathematics</a>, especially <a href="numerical_analysis" title="wikilink">numerical analysis</a>, where it forms the basis of <a href="least_squares" title="wikilink">least squares</a> methods.<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a></p>

<p>In particular, when <em>F</em> is not equal to <em>H</em>, one can find a non-zero vector <em>v</em> orthogonal to <em>F</em> (select <em>x</em> not in <em>F</em> and <em>v</em> = . A very useful criterion is obtained by applying this observation to the closed subspace <em>F</em> generated by a subset <em>S</em> of <em>H</em>.</p>
<dl>
<dd>A subset <em>S</em> of <em>H</em> spans a dense vector subspace if (and only if) the vector 0 is the sole vector <em>v</em> ∈ <em>H</em> orthogonal to <em>S</em>.
</dd>
</dl>
<h3 id="duality">Duality</h3>

<p>The <a href="continuous_dual_space" title="wikilink">dual space</a> <em>H*</em> is the space of all <a href="continuous_function_(topology)" title="wikilink">continuous</a> linear functions from the space <em>H</em> into the base field. It carries a natural norm, defined by</p>

<p>

<math display="block" id="Hilbert_space:60">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mi>φ</mi>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">sup</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo>∥</mo>
         <mi>x</mi>
         <mo>∥</mo>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>x</mi>
        <mo>∈</mo>
        <mi>H</mi>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>φ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>x</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <in></in>
        <ci>x</ci>
        <ci>H</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>φ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\varphi\|=\sup_{\|x\|=1,x\in H}|\varphi(x)|.
  </annotation>
 </semantics>
</math>

 This norm satisfies the parallelogram law, and so the dual space is also an inner product space. The dual space is also complete, and so it is a Hilbert space in its own right.</p>

<p>The <a href="Riesz_representation_theorem" title="wikilink">Riesz representation theorem</a> affords a convenient description of the dual. To every element <em>u</em> of <em>H</em>, there is a unique element φ<sub><em>u</em></sub> of <em>H*</em>, defined by</p>

<p>

<math display="block" id="Hilbert_space:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>φ</mi>
      <mi>u</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>u</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <list>
     <ci>x</ci>
     <ci>u</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{u}(x)=\langle x,u\rangle.
  </annotation>
 </semantics>
</math>

 The mapping 

<math display="inline" id="Hilbert_space:62">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>↦</mo>
   <msub>
    <mi>φ</mi>
    <mi>u</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>u</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\mapsto\varphi_{u}
  </annotation>
 </semantics>
</math>

 is an <a href="antilinear_map" title="wikilink">antilinear mapping</a> from <em>H</em> to <em>H*</em>. The Riesz representation theorem states that this mapping is an antilinear isomorphism.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a> Thus to every element <em>φ</em> of the dual <em>H*</em> there exists one and only one <em>u</em><sub>φ</sub> in <em>H</em> such that</p>

<p>

<math display="block" id="Hilbert_space:63">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <msub>
     <mi>u</mi>
     <mi>φ</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>φ</ci>
     </apply>
    </list>
    <apply>
     <times></times>
     <ci>φ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,u_{\varphi}\rangle=\varphi(x)
  </annotation>
 </semantics>
</math>

 for all <em>x</em> ∈ <em>H</em>. The inner product on the dual space <em>H*</em> satisfies</p>

<p>

<math display="block" id="Hilbert_space:64">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>φ</mi>
     <mo>,</mo>
     <mi>ψ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>u</mi>
      <mi>ψ</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>u</mi>
      <mi>φ</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>φ</ci>
     <ci>ψ</ci>
    </list>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>ψ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>φ</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\varphi,\psi\rangle=\langle u_{\psi},u_{\varphi}\rangle.
  </annotation>
 </semantics>
</math>

 The reversal of order on the right-hand side restores linearity in φ from the antilinearity of <em>u</em><sub>φ</sub>. In the real case, the antilinear isomorphism from <em>H</em> to its dual is actually an isomorphism, and so real Hilbert spaces are naturally isomorphic to their own duals.</p>

<p>The representing vector <em>u</em><sub>φ</sub> is obtained in the following way. When <em>φ</em> ≠ 0, the <a href="Kernel_(algebra)" title="wikilink">kernel</a> <em>F</em> = Ker(φ) is a closed vector subspace of <em>H</em>, not equal to <em>H</em>, hence there exists a non-zero vector <em>v</em> orthogonal to <em>F</em>. The vector <em>u</em> is a suitable scalar multiple <em>λv</em> of <em>v</em>. The requirement that φ(<em>v</em>) = ⟨<em>v</em>, <em>u</em>⟩ yields</p>

<p>

<math display="block" id="Hilbert_space:65">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mi>v</mi>
        <mo>,</mo>
        <mi>v</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mpadded>
     <mpadded width="+1.7pt">
      <mover accent="true">
       <mrow>
        <mi>φ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>v</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>¯</mo>
      </mover>
     </mpadded>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <list>
       <ci>v</ci>
       <ci>v</ci>
      </list>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <times></times>
       <ci>φ</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=\langle v,v\rangle^{-1}\,\overline{\varphi(v)}\,v.
  </annotation>
 </semantics>
</math>

</p>

<p>This correspondence <em>φ</em> ↔ <em>u</em> is exploited by the <a href="bra–ket_notation" title="wikilink">bra–ket notation</a> popular in <a class="uri" href="physics" title="wikilink">physics</a>. It is common in physics to assume that the inner product, denoted by ⟨<em>x</em>|<em>y</em>⟩, is linear on the right,</p>

<p>

<math display="block" id="Hilbert_space:66">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">inner-product</csymbol>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <list>
     <ci>y</ci>
     <ci>x</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x|y\rangle=\langle y,x\rangle.
  </annotation>
 </semantics>
</math>

 The result ⟨<em>x</em>|<em>y</em>⟩ can be seen as the action of the linear functional ⟨<em>x</em>| (the <em>bra</em>) on the vector  |<em>y</em>⟩ (the <em>ket</em>).</p>

<p>The Riesz representation theorem relies fundamentally not just on the presence of an inner product, but also on the completeness of the space. In fact, the theorem implies that the <a href="Banach_space" title="wikilink">topological dual</a> of any inner product space can be identified with its completion. An immediate consequence of the Riesz representation theorem is also that a Hilbert space <em>H</em> is <a href="reflexive_space" title="wikilink">reflexive</a>, meaning that the natural map from <em>H</em> into its <a href="dual_space" title="wikilink">double dual space</a> is an isomorphism.</p>
<h3 id="weakly-convergent-sequences">Weakly convergent sequences</h3>

<p>In a Hilbert space <em>H</em>, a sequence {<em>x</em><sub><em>n</em></sub>} is <a href="Weak_topology#Weak_convergence" title="wikilink">weakly convergent</a> to a vector <em>x</em> ∈ <em>H</em> when</p>

<p>

<math display="block" id="Hilbert_space:67">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mi>n</mi>
    </munder>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <ci>n</ci>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>v</ci>
     </list>
    </apply>
    <list>
     <ci>x</ci>
     <ci>v</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{n}\langle x_{n},v\rangle=\langle x,v\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>for every .</p>

<p>For example, any orthonormal sequence {<em>f</em><sub><em>n</em></sub>} converges weakly to 0, as a consequence of <a href="#Bessel's_inequality" title="wikilink">Bessel's inequality</a>. Every weakly convergent sequence {<em>x</em><sub><em>n</em></sub>} is bounded, by the <a href="uniform_boundedness_principle" title="wikilink">uniform boundedness principle</a>.</p>

<p>Conversely, every bounded sequence in a Hilbert space admits weakly convergent subsequences (<a href="Alaoglu's_theorem" title="wikilink">Alaoglu's theorem</a>).<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> This fact may be used to prove minimization results for continuous <a href="convex_function" title="wikilink">convex functionals</a>, in the same way that the <a href="Bolzano–Weierstrass_theorem" title="wikilink">Bolzano–Weierstrass theorem</a> is used for continuous functions on <strong>R</strong><sup><em>d</em></sup>. Among several variants, one simple statement is as follows:<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a></p>
<dl>
<dd>If <em>f</em>:  is a convex continuous function such that <em>f</em>(<em>x</em>) tends to +∞ when ||<em>x</em>|| tends to ∞, then <em>f</em> admits a minimum at some point <mtpl></mtpl>.
</dd>
</dl>

<p>This fact (and its various generalizations) are fundamental for <a href="direct_method_in_the_calculus_of_variations" title="wikilink">direct methods</a> in the <a href="calculus_of_variations" title="wikilink">calculus of variations</a>. Minimization results for convex functionals are also a direct consequence of the slightly more abstract fact that closed bounded convex subsets in a Hilbert space <em>H</em> are <a href="Weak_topology" title="wikilink">weakly compact</a>, since <em>H</em> is reflexive. The existence of weakly convergent subsequences is a special case of the <a href="Eberlein–Šmulian_theorem" title="wikilink">Eberlein–Šmulian theorem</a>.</p>
<h3 id="banach-space-properties">Banach space properties</h3>

<p>Any general property of <a href="Banach_space" title="wikilink">Banach spaces</a> continues to hold for Hilbert spaces. The <a href="open_mapping_theorem_(functional_analysis)" title="wikilink">open mapping theorem</a> states that a <a href="continuous_function" title="wikilink">continuous</a> <a class="uri" href="surjective" title="wikilink">surjective</a> linear transformation from one Banach space to another is an <a href="open_mapping" title="wikilink">open mapping</a> meaning that it sends open sets to open sets. A corollary is the <a href="bounded_inverse_theorem" title="wikilink">bounded inverse theorem</a>, that a continuous and <a class="uri" href="bijective" title="wikilink">bijective</a> linear function from one Banach space to another is an isomorphism (that is, a continuous linear map whose inverse is also continuous). This theorem is considerably simpler to prove in the case of Hilbert spaces than in general Banach spaces.<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> The open mapping theorem is equivalent to the <a href="closed_graph_theorem" title="wikilink">closed graph theorem</a>, which asserts that a function from one Banach space to another is continuous if and only if its graph is a <a href="closed_set" title="wikilink">closed set</a>.<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a> In the case of Hilbert spaces, this is basic in the study of <a href="unbounded_operator" title="wikilink">unbounded operators</a> (see <a href="closed_operator" title="wikilink">closed operator</a>).</p>

<p>The (geometrical) <a href="Hahn–Banach_theorem" title="wikilink">Hahn–Banach theorem</a> asserts that a closed convex set can be separated from any point outside it by means of a <a class="uri" href="hyperplane" title="wikilink">hyperplane</a> of the Hilbert space. This is an immediate consequence of the <a href="#Best_approximation" title="wikilink">best approximation</a> property: if <em>y</em> is the element of a closed convex set <em>F</em> closest to <em>x</em>, then the separating hyperplane is the plane perpendicular to the segment <em>xy</em> passing through its midpoint.<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a></p>
<h2 id="operators-on-hilbert-spaces">Operators on Hilbert spaces</h2>
<h3 id="bounded-operators">Bounded operators</h3>

<p>The <a href="continuous_function_(topology)" title="wikilink">continuous</a> <a href="linear_operator" title="wikilink">linear operators</a> <em>A</em> : <em>H</em><sub>1</sub> → <em>H</em><sub>2</sub> from a Hilbert space <em>H</em><sub>1</sub> to a second Hilbert space <em>H</em><sub>2</sub> are <em>bounded</em> in the sense that they map <a href="bounded_set" title="wikilink">bounded sets</a> to bounded sets. Conversely, if an operator is bounded, then it is continuous. The space of such <a href="bounded_linear_operator" title="wikilink">bounded linear operators</a> has a <a href="norm_(mathematics)" title="wikilink">norm</a>, the <a href="operator_norm" title="wikilink">operator norm</a> given by</p>

<p>

<math display="block" id="Hilbert_space:68">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true">∥</mo>
     <mi>A</mi>
     <mo fence="true">∥</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo movablelimits="false">sup</mo>
     <mrow>
      <mo rspace="4.2pt">{</mo>
      <mrow>
       <mo fence="true">∥</mo>
       <mrow>
        <mi>A</mi>
        <mi>x</mi>
       </mrow>
       <mo fence="true">∥</mo>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mo fence="true">∥</mo>
        <mi>x</mi>
        <mo fence="true">∥</mo>
       </mrow>
       <mo>≤</mo>
       <mpadded width="+1.7pt">
        <mn>1</mn>
       </mpadded>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <leq></leq>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>x</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lVert A\rVert=\sup\left\{\,\lVert Ax\rVert:\lVert x\rVert\leq 1\,\right\}.
  </annotation>
 </semantics>
</math>

</p>

<p>The sum and the composite of two bounded linear operators is again bounded and linear. For <em>y</em> in <em>H</em><sub>2</sub>, the map that sends <em>x</em> ∈ <em>H</em><sub>1</sub> to ⟨<em>Ax</em>, <em>y</em>⟩ is linear and continuous, and according to the <a href="Riesz_representation_theorem" title="wikilink">Riesz representation theorem</a> can therefore be represented in the form</p>

<p>

<math display="block" id="Hilbert_space:69">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>A</mi>
      <mo>*</mo>
     </msup>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>x</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <times></times>
      </apply>
      <ci>y</ci>
     </apply>
    </list>
    <list>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,A^{*}y\rangle=\langle Ax,y\rangle
  </annotation>
 </semantics>
</math>

 for some vector <em>A*</em> <em>y</em> in <em>H</em><sub>1</sub>. This defines another bounded linear operator <em>A*</em>: <em>H</em><sub>2</sub> → <em>H</em><sub>1</sub>, the <a href="Hermitian_adjoint" title="wikilink">adjoint</a> of <em>A</em>. One can see that .</p>

<p>The set B(<em>H</em>) of all bounded linear operators on <em>H</em>, together with the addition and composition operations, the norm and the adjoint operation, is a <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a>, which is a type of <a href="operator_algebra" title="wikilink">operator algebra</a>.</p>

<p>An element <em>A</em>  of B(<em>H</em>) is called <em>self-adjoint</em> or <em>Hermitian</em> if <em>A*</em>= <em>A</em>. If <em>A</em>  is Hermitian and  0 for every <em>x</em>, then <em>A</em>  is called <em>non-negative</em>, written <em>A</em> ≥ 0; if equality holds only when <em>x</em> = 0, then <em>A</em>  is called <em>positive</em>. The set of self adjoint operators admits a <a href="partial_order" title="wikilink">partial order</a>, in which <em>A</em> ≥ <em>B</em> if <em>A</em> − <em>B</em> ≥ 0. If <em>A</em>  has the form <em>B*</em> <em>B</em>  for some <em>B</em>, then <em>A</em> is non-negative; if <em>B</em> is invertible, then <em>A</em>  is positive. A converse is also true in the sense that, for a non-negative operator <em>A</em>, there exists a unique non-negative <a href="Square_root_of_a_matrix" title="wikilink">square root</a> <em>B</em> such that</p>

<p>

<math display="block" id="Hilbert_space:70">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <msup>
     <mi>B</mi>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>B</mi>
      <mo>*</mo>
     </msup>
     <mi>B</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <times></times>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=B^{2}=B^{*}B.\,
  </annotation>
 </semantics>
</math>

</p>

<p>In a sense made precise by the <a href="#Spectral_theorem" title="wikilink">spectral theorem</a>, self-adjoint operators can usefully be thought of as operators that are "real". An element <em>A</em> of B(<em>H</em>) is called <em>normal</em> if <em>A*</em> <em>A</em> = <em>A</em> <em>A*</em>. Normal operators decompose into the sum of a self-adjoint operators and an imaginary multiple of a self adjoint operator</p>

<p>

<math display="block" id="Hilbert_space:71">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <msup>
       <mi>A</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mn>2</mn>
    </mfrac>
    <mo>+</mo>
    <mrow>
     <mi>i</mi>
     <mfrac>
      <mrow>
       <mi>A</mi>
       <mo>-</mo>
       <msup>
        <mi>A</mi>
        <mo>*</mo>
       </msup>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>i</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <times></times>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <ci>A</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <times></times>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\frac{A+A^{*}}{2}+i\frac{A-A^{*}}{2i}
  </annotation>
 </semantics>
</math>

 that commute with each other. Normal operators can also usefully be thought of in terms of their real and imaginary parts.</p>

<p>An element <em>U</em>  of B(<em>H</em>) is called <a href="unitary_operator" title="wikilink">unitary</a> if <em>U</em>  is invertible and its inverse is given by <em>U*</em>. This can also be expressed by requiring that <em>U</em>  be onto  for all <em>x</em> and <em>y</em> in <em>H</em>. The unitary operators form a <a href="group_(mathematics)" title="wikilink">group</a> under composition, which is the <a href="isometry_group" title="wikilink">isometry group</a> of <em>H</em>.</p>

<p>An element of B(<em>H</em>) is <a href="compact_operator" title="wikilink">compact</a> if it sends bounded sets to <a href="relatively_compact" title="wikilink">relatively compact</a> sets. Equivalently, a bounded operator <em>T</em> is compact if, for any bounded sequence {<em>x<sub>k</sub></em>}, the sequence {<em>Tx<sub>k</sub></em>} has a convergent subsequence. Many <a href="integral_operator" title="wikilink">integral operators</a> are compact, and in fact define a special class of operators known as <a href="Hilbert–Schmidt_operator" title="wikilink">Hilbert–Schmidt operators</a> that are especially important in the study of <a href="integral_equation" title="wikilink">integral equations</a>. <a href="Fredholm_operator" title="wikilink">Fredholm operators</a> differ from a compact operator by a multiple of the identity, and are equivalently characterized as operators with a finite dimensional <a href="kernel_(linear_operator)" title="wikilink">kernel</a> and <a class="uri" href="cokernel" title="wikilink">cokernel</a>. The index of a Fredholm operator <em>T</em> is defined by</p>

<p>

<math display="block" id="Hilbert_space:72">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo rspace="4.2pt">index</mo>
     <mi>T</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>dim</mo>
      <mrow>
       <mi>ker</mi>
       <mi>T</mi>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mo>dim</mo>
      <mrow>
       <mo rspace="4.2pt">coker</mo>
       <mi>T</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>index</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="latexml">dimension</csymbol>
      <apply>
       <csymbol cd="latexml">kernel</csymbol>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">dimension</csymbol>
      <apply>
       <ci>coker</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{index}\,T=\dim\ker T-\dim\operatorname{coker}\,T.
  </annotation>
 </semantics>
</math>

 The index is <a class="uri" href="homotopy" title="wikilink">homotopy</a> invariant, and plays a deep role in <a href="differential_geometry" title="wikilink">differential geometry</a> via the <a href="Atiyah–Singer_index_theorem" title="wikilink">Atiyah–Singer index theorem</a>.</p>
<h3 id="unbounded-operators">Unbounded operators</h3>

<p><a href="Unbounded_operator" title="wikilink">Unbounded operators</a> are also tractable in Hilbert spaces, and have important applications to <a href="quantum_mechanics" title="wikilink">quantum mechanics</a>.<a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> An unbounded operator <em>T</em> on a Hilbert space <em>H</em> is defined as a linear operator whose domain <em>D</em>(<em>T</em>) is a linear subspace of <em>H</em>. Often the domain <em>D</em>(<em>T</em>) is a dense subspace of <em>H</em>, in which case <em>T</em> is known as a <a href="densely_defined_operator" title="wikilink">densely defined operator</a>.</p>

<p>The adjoint of a densely defined unbounded operator is defined in essentially the same manner as for bounded operators. <a href="Self-adjoint_operator" title="wikilink">Self-adjoint unbounded operators</a> play the role of the <em>observables</em> in the mathematical formulation of quantum mechanics. Examples of self-adjoint unbounded operators on the Hilbert space <em>L</em><sup>2</sup>(<strong>R</strong>) are:<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a></p>
<ul>
<li>A suitable extension of the differential operator</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hilbert_space:73">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>i</mi>
      <mfrac>
       <mi>d</mi>
       <mrow>
        <mi>d</mi>
        <mi>x</mi>
       </mrow>
      </mfrac>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>i</ci>
      <apply>
       <divide></divide>
       <ci>d</ci>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Af)(x)=-i\frac{d}{dx}f(x),\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>where <em>i</em> is the imaginary unit and <em>f</em> is a differentiable function of compact support.
</dd>
</dl>
<ul>
<li>The multiplication-by-<em>x</em> operator:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hilbert_space:74">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Bf)(x)=xf(x).\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>These correspond to the <a class="uri" href="momentum" title="wikilink">momentum</a> and <a href="position_operator" title="wikilink">position</a> observables, respectively. Note that neither <em>A</em> nor <em>B</em> is defined on all of <em>H</em>, since in the case of <em>A</em> the derivative need not exist, and in the case of <em>B</em> the product function need not be square integrable. In both cases, the set of possible arguments form dense subspaces of <em>L</em><sup>2</sup>(<strong>R</strong>).</p>
<h2 id="constructions">Constructions</h2>
<h3 id="direct-sums">Direct sums</h3>

<p>Two Hilbert spaces <em>H</em><sub>1</sub> and <em>H</em><sub>2</sub> can be combined into another Hilbert space, called the <a href="direct_sum_of_modules#Direct_sum_of_Hilbert_spaces" title="wikilink">(orthogonal) direct sum</a>,<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a> and denoted</p>

<p>

<math display="block" id="Hilbert_space:75">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>1</mn>
    </msub>
    <mo>⊕</mo>
    <msub>
     <mi>H</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}\oplus H_{2},
  </annotation>
 </semantics>
</math>

 consisting of the set of all <a href="ordered_pair" title="wikilink">ordered pairs</a> (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>) where <mtpl></mtpl>, , and inner product defined by</p>

<p>

<math display="block" id="Hilbert_space:76">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <msub>
       <mi>H</mi>
       <mn>1</mn>
      </msub>
      <mo>⊕</mo>
      <msub>
       <mi>H</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msub>
       <mi>H</mi>
       <mn>1</mn>
      </msub>
     </msub>
     <mo>+</mo>
     <msub>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msub>
       <mi>H</mi>
       <mn>2</mn>
      </msub>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </list>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
      </list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle(x_{1},x_{2}),(y_{1},y_{2})\rangle_{H_{1}\oplus H_{2}}=\langle x_{1},y_%
{1}\rangle_{H_{1}}+\langle x_{2},y_{2}\rangle_{H_{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>More generally, if <em>H</em><sub><em>i</em></sub> is a family of Hilbert spaces indexed by , then the direct sum of the <em>H</em><sub><em>i</em></sub>, denoted</p>

<p>

<math display="block" id="Hilbert_space:77">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
   </munder>
   <msub>
    <mi>H</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigoplus_{i\in I}H_{i}
  </annotation>
 </semantics>
</math>

 consists of the set of all indexed families</p>

<p>

<math display="block" id="Hilbert_space:78">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>∈</mo>
    <msub>
     <mi>H</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <mi>i</mi>
    <mo>∈</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
   </munder>
   <msub>
    <mi>H</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">i</csymbol>
     <in></in>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>i</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=(x_{i}\in H_{i}|i\in I)\in\prod_{i\in I}H_{i}
  </annotation>
 </semantics>
</math>

 in the <a href="Cartesian_product" title="wikilink">Cartesian product</a> of the <em>H</em><sub><em>i</em></sub> such that</p>

<p>

<math display="block" id="Hilbert_space:79">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>I</mi>
      </mrow>
     </munder>
     <msup>
      <mrow>
       <mo>∥</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i\in I}\|x_{i}\|^{2}<\infty.
  </annotation>
 </semantics>
</math>

 The inner product is defined by</p>

<p>

<math display="block" id="Hilbert_space:80">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>I</mi>
      </mrow>
     </munder>
     <msub>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msub>
       <mi>H</mi>
       <mi>i</mi>
      </msub>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>x</ci>
     <ci>y</ci>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,y\rangle=\sum_{i\in I}\langle x_{i},y_{i}\rangle_{H_{i}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Each of the <em>H</em><sub><em>i</em></sub> is included as a closed subspace in the direct sum of all of the <em>H</em><sub><em>i</em></sub>. Moreover, the <em>H</em><sub><em>i</em></sub> are pairwise orthogonal. Conversely, if there is a system of closed subspaces, <em>V</em><sub><em>i</em></sub>, , in a Hilbert space <em>H</em>, that are pairwise orthogonal and whose union is dense in <em>H</em>, then <em>H</em> is canonically isomorphic to the direct sum of <em>V</em><sub><em>i</em></sub>. In this case, <em>H</em> is called the internal direct sum of the <em>V</em><sub><em>i</em></sub>. A direct sum (internal or external) is also equipped with a family of orthogonal projections <em>E</em><sub><em>i</em></sub> onto the <em>i</em>th direct summand <em>H</em><sub>i</sub>. These projections are bounded, self-adjoint, <a class="uri" href="idempotent" title="wikilink">idempotent</a> operators that satisfy the orthogonality condition</p>

<p>

<math display="block" id="Hilbert_space:81">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>E</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>E</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>i</mi>
     <mo>≠</mo>
     <mi>j</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <neq></neq>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{i}E_{j}=0,\quad i\not=j.
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="spectral_theorem" title="wikilink">spectral theorem</a> for <a href="compact_operator" title="wikilink">compact</a> self-adjoint operators on a Hilbert space <em>H</em> states that <em>H</em> splits into an orthogonal direct sum of the eigenspaces of an operator, and also gives an explicit decomposition of the operator as a sum of projections onto the eigenspaces. The direct sum of Hilbert spaces also appears in quantum mechanics as the <a href="Fock_space" title="wikilink">Fock space</a> of a system containing a variable number of particles, where each Hilbert space in the direct sum corresponds to an additional <a href="degrees_of_freedom_(mechanics)" title="wikilink">degree of freedom</a> for the quantum mechanical system. In <a href="representation_theory" title="wikilink">representation theory</a>, the <a href="Peter–Weyl_theorem" title="wikilink">Peter–Weyl theorem</a> guarantees that any <a href="unitary_representation" title="wikilink">unitary representation</a> of a <a href="compact_group" title="wikilink">compact group</a> on a Hilbert space splits as the direct sum of finite-dimensional representations.</p>
<h3 id="tensor-products">Tensor products</h3>
<dl>
<dd>
</dd>
</dl>

<p>If <em>H</em><sub>1</sub> and <em>H</em><sub>2</sub>, then one defines an inner product on the (ordinary) <a href="tensor_product" title="wikilink">tensor product</a> as follows. On <a href="simple_tensor" title="wikilink">simple tensors</a>, let</p>

<p>

<math display="block" id="Hilbert_space:82">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo rspace="4.2pt">,</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>y</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo rspace="4.2pt" stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </list>
    <apply>
     <times></times>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x_{1}\otimes x_{2},\,y_{1}\otimes y_{2}\rangle=\langle x_{1},y_{1}%
\rangle\,\langle x_{2},y_{2}\rangle.
  </annotation>
 </semantics>
</math>

 This formula then extends by <a href="Sesquilinear_form" title="wikilink">sesquilinearity</a> to an inner product on <em>H</em><sub>1</sub> ⊗ <em>H</em><sub>2</sub>. The Hilbertian tensor product of <em>H</em><sub>1</sub> and <em>H</em><sub>2</sub>, sometimes denoted by 

<math display="inline" id="Hilbert_space:83">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>1</mn>
   </msub>
   <mover accent="true">
    <mo>⊗</mo>
    <mo>^</mo>
   </mover>
   <msub>
    <mi>H</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <ci>normal-^</ci>
     <csymbol cd="latexml">tensor-product</csymbol>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}\widehat{\otimes}H_{2}
  </annotation>
 </semantics>
</math>

, is the Hilbert space obtained by completing <em>H</em><sub>1</sub> ⊗ <em>H</em><sub>2</sub> for the metric associated to this inner product.<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a></p>

<p>An example is provided by the Hilbert space <em>L</em><sup>2</sup>([0, 1]). The Hilbertian tensor product of two copies of <em>L</em><sup>2</sup>([0, 1]) is isometrically and linearly isomorphic to the space <em>L</em><sup>2</sup>([0, 1]<sup>2</sup>) of square-integrable functions on the square [0, 1]<sup>2</sup>. This isomorphism sends a simple tensor 

<math display="inline" id="Hilbert_space:84">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mo>⊗</mo>
   <msub>
    <mi>f</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}\otimes f_{2}
  </annotation>
 </semantics>
</math>

 to the function</p>

<p>

<math display="block" id="Hilbert_space:85">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>f</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <interval closure="open">
     <ci>s</ci>
     <ci>t</ci>
    </interval>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,t)\mapsto f_{1}(s)\,f_{2}(t)
  </annotation>
 </semantics>
</math>

 on the square.</p>

<p>This example is typical in the following sense.<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a> Associated to every simple tensor product <em>x</em><sub>1</sub> ⊗ <em>x</em><sub>2</sub> is the rank one operator from <em>H</em><sub>1</sub><sup>∗</sup> to <em>H</em><sub>2</sub> that maps a given 

<math display="inline" id="Hilbert_space:86">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mo>*</mo>
   </msup>
   <mo>∈</mo>
   <msubsup>
    <mi>H</mi>
    <mn>1</mn>
    <mo>*</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <times></times>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}\in H^{*}_{1}
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Hilbert_space:87">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mo>*</mo>
    </msup>
    <mo>↦</mo>
    <mrow>
     <msup>
      <mi>x</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}\mapsto x^{*}(x_{1})\,x_{2}.
  </annotation>
 </semantics>
</math>

 This mapping defined on simple tensors extends to a linear identification between <em>H</em><sub>1</sub> ⊗ <em>H</em><sub>2</sub> and the space of finite rank operators from <em>H*</em><sub>1</sub> to <em>H</em><sub>2</sub>. This extends to a linear isometry of the Hilbertian tensor product 

<math display="inline" id="Hilbert_space:88">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>1</mn>
   </msub>
   <mover accent="true">
    <mo>⊗</mo>
    <mo>^</mo>
   </mover>
   <msub>
    <mi>H</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <ci>normal-^</ci>
     <csymbol cd="latexml">tensor-product</csymbol>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}\widehat{\otimes}H_{2}
  </annotation>
 </semantics>
</math>

 with the Hilbert space <em>HS</em>(<em>H*</em><sub>1</sub>, <em>H</em><sub>2</sub>) of <a href="Hilbert–Schmidt_operator" title="wikilink">Hilbert–Schmidt operators</a> from <em>H*</em><sub>1</sub> to <em>H</em><sub>2</sub>.</p>
<h2 id="orthonormal-bases">Orthonormal bases</h2>

<p>The notion of an <a href="orthonormal_basis" title="wikilink">orthonormal basis</a> from linear algebra generalizes over to the case of Hilbert spaces.<a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a> In a Hilbert space <em>H</em>, an orthonormal basis is a family {<em>e</em><sub><em>k</em></sub>}<mtpl></mtpl> of elements of <em>H</em> satisfying the conditions:</p>
<ol>
<li><em>Orthogonality</em>: Every two different elements of <em>B</em> are orthogonal

<math display="block" id="Hilbert_space:89">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>e</mi>
     <mi>k</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>e</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>j</ci>
     </apply>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle e_{k},e_{j}\rangle=0
  </annotation>
 </semantics>
</math>

 for all <em>k</em>, <em>j</em> in <em>B</em> with .</li>
<li><em>Normalization</em>: Every element of the family has norm 1:||<em>e</em><sub><em>k</em></sub>|| = 1 for all <em>k</em> in <em>B</em>.</li>
<li><em>Completeness</em>: The <a href="linear_span" title="wikilink">linear span</a> of the family <em>e</em><sub><em>k</em></sub>, , is <a href="dense_set" title="wikilink">dense</a> in <em>H</em>.</li>
</ol>

<p>A system of vectors satisfying the first two conditions basis is called an orthonormal system or an orthonormal set (or an orthonormal sequence if <em>B</em> is <a href="countable_set" title="wikilink">countable</a>). Such a system is always <a href="linearly_independent" title="wikilink">linearly independent</a>. Completeness of an orthonormal system of vectors of a Hilbert space can be equivalently restated as:</p>
<dl>
<dd>if <mtpl> 0}}</mtpl> for all  and some  then .
</dd>
</dl>

<p>This is related to the fact that the only vector orthogonal to a dense linear subspace is the zero vector, for if <em>S</em> is any orthonormal set and <em>v</em> is orthogonal to <em>S</em>, then <em>v</em> is orthogonal to the closure of the linear span of <em>S</em>, which is the whole space.</p>

<p>Examples of orthonormal bases include:</p>
<ul>
<li>the set {(1,0,0), (0,1,0), (0,0,1)} forms an orthonormal basis of <strong>R</strong><sup>3</sup> with the dot product;</li>
<li>the sequence {<em>f</em><sub><em>n</em></sub> : <em>n</em> ∈ <strong>Z</strong>} with <em>f</em><sub><em>n</em></sub>(<em>x</em>) = <a href="exponential_function" title="wikilink">exp</a>(2π<em>inx</em>) forms an orthonormal basis of the complex space L<sup>2</sup>([0,1]);</li>
</ul>

<p>In the infinite-dimensional case, an orthonormal basis will not be a basis in the sense of <a href="linear_algebra" title="wikilink">linear algebra</a>; to distinguish the two, the latter basis is also called a <a href="Hamel_basis" title="wikilink">Hamel basis</a>. That the span of the basis vectors is dense implies that every vector in the space can be written as the sum of an infinite series, and the orthogonality implies that this decomposition is unique.</p>
<h3 id="sequence-spaces">Sequence spaces</h3>

<p>The space <em>ℓ</em><sup> 2</sup> of square-summable sequences of complex numbers is the set of infinite sequences</p>

<p>

<math display="block" id="Hilbert_space:90">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-…</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (c_{1},c_{2},c_{3},\dots)\,
  </annotation>
 </semantics>
</math>

</p>

<p>of complex numbers such that</p>

<p>

<math display="block" id="Hilbert_space:91">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>c</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>c</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>c</mi>
        <mn>3</mn>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |c_{1}|^{2}+|c_{2}|^{2}+|c_{3}|^{2}+\cdots<\infty.\,
  </annotation>
 </semantics>
</math>

</p>

<p>This space has an orthonormal basis:</p>

<p>

<math display="inline" id="Hilbert_space:92">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle e_{1}
  </annotation>
 </semantics>
</math>


</p>

<p>More generally, if <em>B</em> is any set, then one can form a Hilbert space of sequences with index set <em>B</em>, defined by</p>

<p>

<math display="block" id="Hilbert_space:93">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">ℓ</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo maxsize="120%" minsize="120%">{</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mi>B</mi>
    <mover accent="true">
     <mo>→</mo>
     <mo>𝑥</mo>
    </mover>
    <mi>ℂ</mi>
    <mo>∣</mo>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>b</mi>
      <mo>∈</mo>
      <mi>B</mi>
     </mrow>
    </munder>
    <mo>|</mo>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mo>|</mo>
     <mn>2</mn>
    </msup>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
    <mo maxsize="120%" minsize="120%">}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-ℓ</ci>
     <cn type="integer">2</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">B</csymbol>
     <apply>
      <ci>x</ci>
      <ci>normal-→</ci>
     </apply>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>b</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-|</ci>
      <cn type="integer">2</cn>
     </apply>
     <lt></lt>
     <infinity></infinity>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell^{2}(B)=\big\{x:B\xrightarrow{x}\mathbb{C}\mid\sum_{b\in B}\left|x(b)%
\right|^{2}<\infty\big\}.
  </annotation>
 </semantics>
</math>

</p>

<p>The summation over <em>B</em> is here defined by</p>

<p>

<math display="block" id="Hilbert_space:94">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>b</mi>
      <mo>∈</mo>
      <mi>B</mi>
     </mrow>
    </munder>
    <msup>
     <mrow>
      <mo>|</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo movablelimits="false">sup</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>b</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>b</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{b\in B}\left|x(b)\right|^{2}=\sup\sum_{n=1}^{N}|x(b_{n})|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>the <a class="uri" href="supremum" title="wikilink">supremum</a> being taken over all finite subsets of <em>B</em>. It follows that, for this sum to be finite, every element of <em>ℓ</em><sup> 2</sup>(<em>B</em>) has only countably many nonzero terms. This space becomes a Hilbert space with the inner product</p>

<p>

<math display="block" id="Hilbert_space:95">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>b</mi>
      <mo>∈</mo>
      <mi>B</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mover accent="true">
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>¯</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>x</ci>
     <ci>y</ci>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>b</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>b</ci>
      <apply>
       <ci>normal-¯</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,y\rangle=\sum_{b\in B}x(b)\overline{y(b)}
  </annotation>
 </semantics>
</math>

 for all <em>x</em> and <em>y</em> in <em>ℓ</em><sup> 2</sup>(<em>B</em>). Here the sum also has only countably many nonzero terms, and is unconditionally convergent by the Cauchy–Schwarz inequality.</p>

<p>An orthonormal basis of <em>ℓ</em><sup> 2</sup>(<em>B</em>) is indexed by the set <em>B</em>, given by</p>

<p>

<math display="block" id="Hilbert_space:96">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>e</mi>
     <mi>b</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>b</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>b</mi>
        </mrow>
        <mo>=</mo>
        <msup>
         <mi>b</mi>
         <mo>′</mo>
        </msup>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise.</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>b</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise.</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{b}(b^{\prime})=\begin{cases}1&\text{if }b=b^{\prime}\\
0&\text{otherwise.}\end{cases}
  </annotation>
 </semantics>
</math>

 </p>
<h3 id="bessels-inequality-and-parsevals-formula">Bessel's inequality and Parseval's formula</h3>

<p>Let <mtpl></mtpl> be a finite orthonormal system in <em>H</em>. For an arbitrary vector <em>x</em> in <em>H</em>, let</p>

<p>

<math display="block" id="Hilbert_space:97">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
     </mpadded>
     <mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo>,</mo>
       <msub>
        <mi>f</mi>
        <mi>j</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">⟩</mo>
      </mrow>
      <msub>
       <mi>f</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <list>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>j</ci>
       </apply>
      </list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\sum_{j=1}^{n}\,\langle x,f_{j}\rangle\,f_{j}.
  </annotation>
 </semantics>
</math>

</p>

<p>Then <mtpl></mtpl> = <mtpl></mtpl> for every <em>k</em> = . It follows that  is orthogonal to each <em>f</em><sub><em>k</em></sub>, hence  is orthogonal to <em>y</em>. Using the Pythagorean identity twice, it follows that</p>

<p>

<math display="block" id="Hilbert_space:98">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mi>x</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>y</mi>
       </mrow>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mi>y</mi>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>≥</mo>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mi>y</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mi>x</mi>
        <mo>,</mo>
        <msub>
         <mi>f</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>x</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <ci>y</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>y</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>y</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <list>
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>j</ci>
         </apply>
        </list>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x\|^{2}=\|x-y\|^{2}+\|y\|^{2}\geq\|y\|^{2}=\sum_{j=1}^{n}|\langle x,f_{j}%
\rangle|^{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>Let , be an arbitrary orthonormal system in <em>H</em>. Applying the preceding inequality to every finite subset <em>J</em> of <em>I</em> gives the <em>Bessel inequality</em><a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a></p>

<p>

<math display="block" id="Hilbert_space:99">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>I</mi>
      </mrow>
     </munder>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mi>x</mi>
        <mo>,</mo>
        <msub>
         <mi>f</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>≤</mo>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mi>x</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>H</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <list>
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>i</ci>
         </apply>
        </list>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>x</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i\in I}|\langle x,f_{i}\rangle|^{2}\leq\|x\|^{2},\quad x\in H
  </annotation>
 </semantics>
</math>

</p>

<p>(according to the definition of the <a href="Series_(mathematics)#Summations_over_arbitrary_index_sets" title="wikilink">sum of an arbitrary family</a> of non-negative real numbers).</p>

<p>Geometrically, Bessel's inequality implies that the orthogonal projection of <em>x</em> onto the linear subspace spanned by the <em>f</em><sub><em>i</em></sub> has norm that does not exceed that of <em>x</em>. In two dimensions, this is the assertion that the length of the leg of a right triangle may not exceed the length of the hypotenuse.</p>

<p>Bessel's inequality is a stepping stone to the more powerful <a href="Parseval_identity" title="wikilink">Parseval identity</a>, which governs the case when Bessel's inequality is actually an equality. If {<em>e</em><sub><em>k</em></sub>}<sub><em>k</em> ∈ <em>B</em></sub> is an orthonormal basis of <em>H</em>, then every element <em>x</em> of <em>H</em> may be written as</p>

<p>

<math display="block" id="Hilbert_space:100">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>∈</mo>
        <mi>B</mi>
       </mrow>
      </munder>
     </mpadded>
     <mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo>,</mo>
       <msub>
        <mi>e</mi>
        <mi>k</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">⟩</mo>
      </mrow>
      <msub>
       <mi>e</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>k</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <list>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>k</ci>
       </apply>
      </list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\sum_{k\in B}\,\langle x,e_{k}\rangle\,e_{k}.
  </annotation>
 </semantics>
</math>

</p>

<p>Even if <em>B</em> is uncountable, Bessel's inequality guarantees that the expression is well-defined and consists only of countably many nonzero terms. This sum is called the <em>Fourier expansion</em> of <em>x</em>, and the individual coefficients ⟨<em>x</em>,<em>e</em><sub><em>k</em></sub>⟩ are the <em>Fourier coefficients</em> of <em>x</em>. Parseval's formula is then</p>

<p>

<math display="block" id="Hilbert_space:101">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mi>x</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>∈</mo>
       <mi>B</mi>
      </mrow>
     </munder>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mi>x</mi>
        <mo>,</mo>
        <msub>
         <mi>e</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>x</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>k</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <list>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <ci>k</ci>
        </apply>
       </list>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x\|^{2}=\sum_{k\in B}|\langle x,e_{k}\rangle|^{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>Conversely, if {<em>e</em><sub><em>k</em></sub>} is an orthonormal set such that Parseval's identity holds for every <em>x</em>, then {<em>e</em><sub><em>k</em></sub>} is an orthonormal basis.</p>
<h3 id="hilbert-dimension">Hilbert dimension</h3>

<p>As a consequence of <a href="Zorn's_lemma" title="wikilink">Zorn's lemma</a>, <em>every</em> Hilbert space admits an orthonormal basis; furthermore, any two orthonormal bases of the same space have the same <a href="cardinal_number" title="wikilink">cardinality</a>, called the Hilbert dimension of the space.<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a> For instance, since <em>ℓ</em><sup>2</sup>(<em>B</em>) has an orthonormal basis indexed by <em>B</em>, its Hilbert dimension is the cardinality of <em>B</em> (which may be a finite integer, or a countable or uncountable <a href="cardinal_number" title="wikilink">cardinal number</a>).</p>

<p>As a consequence of Parseval's identity, if {<em>e</em><sub><em>k</em></sub>}<sub><em>k</em> ∈ <em>B</em></sub> is an orthonormal basis of <em>H</em>, then the map   ℓ<sup>2</sup>(<em>B</em>) defined by <mtpl> (⟨x,<em>e</em><sub><em>k</em></sub>⟩)<sub><em>k</em>∈<em>B</em></sub>}}</mtpl> is an isometric isomorphism of Hilbert spaces: it is a bijective linear mapping such that</p>

<p>

<math display="block" id="Hilbert_space:102">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo>(</mo>
       <mi>x</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo>(</mo>
       <mi>y</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <msup>
      <mi mathvariant="normal">ℓ</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>H</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <ci>y</ci>
      </apply>
     </list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-ℓ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <ci>x</ci>
      <ci>y</ci>
     </list>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\Phi\left(x\right),\Phi\left(y\right)\rangle_{\ell^{2}(B)}=\langle x,y%
\rangle_{H}
  </annotation>
 </semantics>
</math>

 for all <em>x</em> and <em>y</em> in <em>H</em>. The <a href="cardinal_number" title="wikilink">cardinal number</a> of <em>B</em> is the Hilbert dimension of <em>H</em>. Thus every Hilbert space is isometrically isomorphic to a sequence space  ℓ<sup>2</sup>(<em>B</em>) for some set <em>B</em>.</p>
<h3 id="separable-spaces">Separable spaces</h3>

<p>A Hilbert space is <a href="separable_space" title="wikilink">separable</a> if and only if it admits a <a class="uri" href="countable" title="wikilink">countable</a> orthonormal basis. All infinite-dimensional separable Hilbert spaces are therefore isometrically isomorphic to <em>ℓ</em><sup>2</sup>.</p>

<p>In the past, Hilbert spaces were often required to be separable as part of the definition.<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a> Most spaces used in physics are separable, and since these are all isomorphic to each other, one often refers to any infinite-dimensional separable Hilbert space as "<em>the</em> Hilbert space" or just "Hilbert space".<a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a> Even in <a href="quantum_field_theory" title="wikilink">quantum field theory</a>, most of the Hilbert spaces are in fact separable, as stipulated by the <a href="Wightman_axioms" title="wikilink">Wightman axioms</a>. However, it is sometimes argued that non-separable Hilbert spaces are also important in quantum field theory, roughly because the systems in the theory possess an infinite number of <a href="degrees_of_freedom_(mechanics)" title="wikilink">degrees of freedom</a> and any infinite <a href="Hilbert_tensor_product" title="wikilink">Hilbert tensor product</a> (of spaces of dimension greater than one) is non-separable.<a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a> For instance, a <a href="bosonic_field" title="wikilink">bosonic field</a> can be naturally thought of as an element of a tensor product whose factors represent harmonic oscillators at each point of space. From this perspective, the natural state space of a boson might seem to be a non-separable space.<a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a> However, it is only a small separable subspace of the full tensor product that can contain physically meaningful fields (on which the observables can be defined). Another non-separable Hilbert space models the state of an infinite collection of particles in an unbounded region of space. An orthonormal basis of the space is indexed by the density of the particles, a continuous parameter, and since the set of possible densities is uncountable, the basis is not countable.<a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a></p>
<h2 id="orthogonal-complements-and-projections">Orthogonal complements and projections</h2>

<p>If <em>S</em> is a subset of a Hilbert space <em>H</em>, the set of vectors orthogonal to <em>S</em> is defined by</p>

<p>

<math display="block" id="Hilbert_space:103">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>S</mi>
     <mo>⟂</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <mi>H</mi>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mpadded width="+5pt">
        <mn>0</mn>
       </mpadded>
       <mrow>
        <mo>∀</mo>
        <mi>s</mi>
       </mrow>
      </mrow>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <csymbol cd="latexml">perpendicular-to</csymbol>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>H</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <list>
        <ci>x</ci>
        <ci>s</ci>
       </list>
       <apply>
        <times></times>
        <cn type="integer">0</cn>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <in></in>
       <share href="#.cmml">
       </share>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\perp}=\left\{x\in H:\langle x,s\rangle=0\ \forall s\in S\right\}.
  </annotation>
 </semantics>
</math>

 <em>S</em><sup>⊥</sup> is a <a href="closed_set" title="wikilink">closed</a> subspace of <em>H</em> (can be proved easily using the linearity and continuity of the inner product) and so forms itself a Hilbert space. If <em>V</em> is a closed subspace of <em>H</em>, then <em>V</em><sup>⊥</sup> is called the <em>orthogonal complement</em> of <em>V</em>. In fact, every <em>x</em> in <em>H</em> can then be written uniquely as <em>x</em> = <em>v</em> + <em>w</em>, with <em>v</em> in <em>V</em> and <em>w</em> in <em>V</em><sup>⊥</sup>. Therefore, <em>H</em> is the internal Hilbert direct sum of <em>V</em> and <em>V</em><sup>⊥</sup>.</p>

<p>The linear operator P<sub><em>V</em></sub> : <em>H</em> → <em>H</em> that maps <em>x</em> to <em>v</em> is called the <em>orthogonal projection</em> onto <em>V</em>. There is a <a href="natural_transformation" title="wikilink">natural</a> one-to-one correspondence between the set of all closed subspaces of <em>H</em> and the set of all bounded self-adjoint operators <em>P</em> such that <em>P</em><sup>2</sup> = <em>P</em>. Specifically,</p>
<dl>
<dd><strong>Theorem</strong>. The orthogonal projection P<sub><em>V</em></sub> is a self-adjoint linear operator on <em>H</em> of norm ≤ 1 with the property P<sup>2</sup><sub><em>V</em></sub> = P<sub><em>V</em></sub>. Moreover, any self-adjoint linear operator <em>E</em> such that <em>E</em><sup>2</sup> = <em>E</em> is of the form P<sub><em>V</em></sub>, where <em>V</em> is the range of <em>E</em>. For every <em>x</em> in <em>H</em>, P<sub><em>V</em></sub>(<em>x</em>) is the unique element <em>v</em> of <em>V</em>, which minimizes the distance ||<em>x</em> − <em>v</em>||.
</dd>
</dl>

<p>This provides the geometrical interpretation of <em>P<sub>V</sub></em>(<em>x</em>): it is the best approximation to <em>x</em> by elements of <em>V</em>.<a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a></p>

<p>Projections <em>P<sub>U</sub></em> and <em>P<sub>V</sub></em> are called mutually orthogonal if <em>P</em><sub><em>U</em></sub><em>P</em><sub><em>V</em></sub> = 0. This is equivalent to <em>U</em> and <em>V</em> being orthogonal as subspaces of <em>H</em>. The sum of the two projections <em>P</em><sub><em>U</em></sub> and <em>P</em><sub><em>V</em></sub> is a projection only if <em>U</em> and <em>V</em> are orthogonal to each other, and in that case <em>P</em><sub><em>U</em></sub> + <em>P</em><sub><em>V</em></sub> = <em>P</em><sub><em>U</em>+<em>V</em></sub>. The composite <em>P</em><sub><em>U</em></sub><em>P</em><sub><em>V</em></sub> is generally not a projection; in fact, the composite is a projection if and only if the two projections commute, and in that case <em>P</em><sub><em>U</em></sub><em>P</em><sub><em>V</em></sub> = <em>P</em><sub><em>U</em>∩<em>V</em></sub>.</p>

<p>By restricting the codomain to the Hilbert space <em>V</em>, the orthogonal projection <em>P</em><sub><em>V</em></sub> gives rise to a projection mapping π: <em>H</em> → <em>V</em>; it is the adjoint of the <a href="inclusion_mapping" title="wikilink">inclusion mapping</a></p>

<p>

<math display="block" id="Hilbert_space:104">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>:</mo>
    <mrow>
     <mi>V</mi>
     <mo>→</mo>
     <mi>H</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>i</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>V</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i:V\to H,
  </annotation>
 </semantics>
</math>

</p>

<p>meaning that</p>

<p>

<math display="block" id="Hilbert_space:105">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>i</mi>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>H</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>π</mi>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>V</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </list>
     <ci>H</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>π</ci>
       <ci>y</ci>
      </apply>
     </list>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle ix,y\rangle_{H}=\langle x,\pi y\rangle_{V}
  </annotation>
 </semantics>
</math>

</p>

<p>for all <em>x</em> ∈ <em>V</em> and <em>y</em> ∈ <em>H</em>.</p>

<p>The operator norm of the orthogonal projection <em>P</em><sub><em>V</em></sub> onto a non-zero closed subspace <em>V</em> is equal to one:</p>

<p>

<math display="block" id="Hilbert_space:106">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <msub>
     <mi>P</mi>
     <mi>V</mi>
    </msub>
    <mo>∥</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">sup</mo>
     <mrow>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <mi>H</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>x</mi>
       <mo>≠</mo>
       <mn>0</mn>
      </mrow>
     </mrow>
    </munder>
    <mfrac>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <msub>
        <mi>P</mi>
        <mi>V</mi>
       </msub>
       <mi>x</mi>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mrow>
      <mo>∥</mo>
      <mi>x</mi>
      <mo>∥</mo>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <in></in>
         <ci>x</ci>
         <ci>H</ci>
        </apply>
        <apply>
         <neq></neq>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>P</ci>
          <ci>V</ci>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|P_{V}\|=\sup_{x\in H,x\not=0}\frac{\|P_{V}x\|}{\|x\|}=1.
  </annotation>
 </semantics>
</math>

 Every closed subspace <em>V</em> of a Hilbert space is therefore the image of an operator <em>P</em> of norm one such that <em>P</em><sup>2</sup> = <em>P</em>. The property of possessing appropriate projection operators characterizes Hilbert spaces:<a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a></p>
<ul>
<li>A Banach space of dimension higher than 2 is (isometrically) a Hilbert space if and only if, for every closed subspace <em>V</em>, there is an operator <em>P</em><sub><em>V</em></sub> of norm one whose image is <em>V</em> such that 

<math display="inline" id="Hilbert_space:107">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>P</mi>
     <mi>V</mi>
     <mn>2</mn>
    </msubsup>
    <mo>=</mo>
    <msub>
     <mi>P</mi>
     <mi>V</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>V</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{V}^{2}=P_{V}.
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>While this result characterizes the metric structure of a Hilbert space, the structure of a Hilbert space as a <a href="topological_vector_space" title="wikilink">topological vector space</a> can itself be characterized in terms of the presence of complementary subspaces:<a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a></p>
<ul>
<li>A Banach space <em>X</em> is topologically and linearly isomorphic to a Hilbert space if and only if, to every closed subspace <em>V</em>, there is a closed subspace <em>W</em> such that <em>X</em> is equal to the internal direct sum <em>V</em> ⊕ <em>W</em>.</li>
</ul>

<p>The orthogonal complement satisfies some more elementary results. It is a <a href="monotone_function" title="wikilink">monotone function</a> in the sense that if <em>U</em> ⊂ <em>V</em>, then 

<math display="inline" id="Hilbert_space:108">
 <semantics>
  <mrow>
   <msup>
    <mi>V</mi>
    <mo>⟂</mo>
   </msup>
   <mo>⊆</mo>
   <msup>
    <mi>U</mi>
    <mo>⟂</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <csymbol cd="latexml">perpendicular-to</csymbol>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>U</ci>
     <csymbol cd="latexml">perpendicular-to</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\perp}\subseteq U^{\perp}
  </annotation>
 </semantics>
</math>

 with equality holding if and only if <em>V</em> is contained in the <a href="closure_(topology)" title="wikilink">closure</a> of <em>U</em>. This result is a special case of the <a href="Hahn–Banach_theorem" title="wikilink">Hahn–Banach theorem</a>. The closure of a subspace can be completely characterized in terms of the orthogonal complement: If <em>V</em> is a subspace of <em>H</em>, then the closure of <em>V</em> is equal to 

<math display="inline" id="Hilbert_space:109">
 <semantics>
  <msup>
   <mi>V</mi>
   <mrow>
    <mi></mi>
    <mo>⊥</mo>
    <mo>⊥</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>V</ci>
    <apply>
     <csymbol cd="latexml">bottom</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <csymbol cd="latexml">bottom</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\bot\bot}
  </annotation>
 </semantics>
</math>

. The orthogonal complement is thus a <a href="Galois_connection" title="wikilink">Galois connection</a> on the <a href="partial_order" title="wikilink">partial order</a> of subspaces of a Hilbert space. In general, the orthogonal complement of a sum of subspaces is the intersection of the orthogonal complements:<a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a> 

<math display="inline" id="Hilbert_space:110">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>V</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>⟂</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
     <mi>i</mi>
    </msub>
    <msubsup>
     <mi>V</mi>
     <mi>i</mi>
     <mo>⟂</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <csymbol cd="latexml">perpendicular-to</csymbol>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <intersect></intersect>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>i</ci>
      </apply>
      <csymbol cd="latexml">perpendicular-to</csymbol>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle{\left(\sum_{i}V_{i}\right)^{\perp}=\bigcap_{i}V_{i}^{\perp}}
  </annotation>
 </semantics>
</math>

. If the <em>V</em><sub><em>i</em></sub> are in addition closed, then 

<math display="inline" id="Hilbert_space:111">
 <semantics>
  <mrow>
   <mover accent="true">
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>i</mi>
     </msub>
     <msubsup>
      <mi>V</mi>
      <mi>i</mi>
      <mo>⟂</mo>
     </msubsup>
    </mrow>
    <mo>¯</mo>
   </mover>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>V</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>⟂</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <ci>i</ci>
       </apply>
       <csymbol cd="latexml">perpendicular-to</csymbol>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <intersect></intersect>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <csymbol cd="latexml">perpendicular-to</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle{\overline{\sum_{i}V_{i}^{\perp}}=\left(\bigcap_{i}V_{i}\right)^{%
\perp}}
  </annotation>
 </semantics>
</math>


.</p>
<h2 id="spectral-theory">Spectral theory</h2>

<p>There is a well-developed <a href="spectral_theory" title="wikilink">spectral theory</a> for self-adjoint operators in a Hilbert space, that is roughly analogous to the study of <a href="symmetric_matrix" title="wikilink">symmetric matrices</a> over the reals or self-adjoint matrices over the complex numbers.<a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a> In the same sense, one can obtain a "diagonalization" of a self-adjoint operator as a suitable sum (actually an integral) of orthogonal projection operators.</p>

<p>The <a href="spectrum_of_an_operator" title="wikilink">spectrum of an operator</a> <em>T</em>, denoted σ(<em>T</em>) is the set of complex numbers λ such that <em>T</em> − λ lacks a continuous inverse. If <em>T</em> is bounded, then the spectrum is always a <a href="compact_set" title="wikilink">compact set</a> in the complex plane, and lies inside the disc 

<math display="inline" id="Hilbert_space:112">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>z</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mo>∥</mo>
     <mi>T</mi>
     <mo>∥</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{|z|\leq\|T\|.}
  </annotation>
 </semantics>
</math>

 If <em>T</em> is self-adjoint, then the spectrum is real. In fact, it is contained in the interval [<em>m</em>,<em>M</em>] where</p>

<p>

<math display="block" id="Hilbert_space:113">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mo>=</mo>
     <mrow>
      <munder>
       <mo movablelimits="false">inf</mo>
       <mrow>
        <mrow>
         <mo>∥</mo>
         <mi>x</mi>
         <mo>∥</mo>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </munder>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mrow>
        <mi>T</mi>
        <mi>x</mi>
       </mrow>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>M</mi>
     <mo>=</mo>
     <mrow>
      <munder>
       <mo movablelimits="false">sup</mo>
       <mrow>
        <mrow>
         <mo>∥</mo>
         <mi>x</mi>
         <mo>∥</mo>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </munder>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mrow>
        <mi>T</mi>
        <mi>x</mi>
       </mrow>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>m</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">infimum</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>x</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <list>
       <apply>
        <times></times>
        <ci>T</ci>
        <ci>x</ci>
       </apply>
       <ci>x</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>M</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>x</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <list>
       <apply>
        <times></times>
        <ci>T</ci>
        <ci>x</ci>
       </apply>
       <ci>x</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=\inf_{\|x\|=1}\langle Tx,x\rangle,\quad M=\sup_{\|x\|=1}\langle Tx,x\rangle.
  </annotation>
 </semantics>
</math>

 Moreover, <em>m</em> and <em>M</em> are both actually contained within the spectrum.</p>

<p>The eigenspaces of an operator <em>T</em> are given by</p>

<p>

<math display="block" id="Hilbert_space:114">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>λ</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>ker</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mo>-</mo>
       <mi>λ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>λ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">kernel</csymbol>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <ci>λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\lambda}=\ker(T-\lambda).
  </annotation>
 </semantics>
</math>

 Unlike with finite matrices, not every element of the spectrum of <em>T</em> must be an eigenvalue: the linear operator <em>T</em> − λ may only lack an inverse because it is not surjective. Elements of the spectrum of an operator in the general sense are known as <em>spectral values</em>. Since spectral values need not be eigenvalues, the spectral decomposition is often more subtle than in finite dimensions.</p>

<p>However, the <a href="spectral_theorem" title="wikilink">spectral theorem</a> of a self-adjoint operator <em>T</em> takes a particularly simple form if, in addition, <em>T</em> is assumed to be a <a href="compact_operator" title="wikilink">compact operator</a>. The <a href="Compact_operator_on_Hilbert_space#Spectral_theorem" title="wikilink">spectral theorem for compact self-adjoint operators</a> states:<a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a></p>
<ul>
<li>A compact self-adjoint operator <em>T</em> has only countably (or finitely) many spectral values. The spectrum of <em>T</em> has no <a href="limit_point" title="wikilink">limit point</a> in the complex plane except possibly zero. The eigenspaces of <em>T</em> decompose <em>H</em> into an orthogonal direct sum:

<p>

<math display="block" id="Hilbert_space:115">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
      <mrow>
       <mi>λ</mi>
       <mo>∈</mo>
       <mrow>
        <mi>σ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>T</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <msub>
      <mi>H</mi>
      <mi>λ</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <in></in>
       <ci>λ</ci>
       <apply>
        <times></times>
        <ci>σ</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=\bigoplus_{\lambda\in\sigma(T)}H_{\lambda}.
  </annotation>
 </semantics>
</math>

</p></li>
</ul>
<dl>
<dd>Moreover, if <em>E</em><sub>λ</sub> denotes the orthogonal projection onto the eigenspace <em>H</em><sub>λ</sub>, then

<p>

<math display="block" id="Hilbert_space:116">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>λ</mi>
       <mo>∈</mo>
       <mrow>
        <mi>σ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>T</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mi>λ</mi>
      <msub>
       <mi>E</mi>
       <mi>λ</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>λ</ci>
       <apply>
        <times></times>
        <ci>σ</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\sum_{\lambda\in\sigma(T)}\lambda E_{\lambda},
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>where the sum converges with respect to the norm on B(<em>H</em>).
</dd>
</dl>

<p>This theorem plays a fundamental role in the theory of <a href="integral_equation" title="wikilink">integral equations</a>, as many integral operators are compact, in particular those that arise from <a href="Hilbert–Schmidt_operator" title="wikilink">Hilbert–Schmidt operators</a>.</p>

<p>The general spectral theorem for self-adjoint operators involves a kind of operator-valued <a href="Riemann–Stieltjes_integral" title="wikilink">Riemann–Stieltjes integral</a>, rather than an infinite summation.<a class="footnoteRef" href="#fn76" id="fnref76"><sup>76</sup></a> The <em>spectral family</em> associated to <em>T</em> associates to each real number λ an operator <em>E</em><sub>λ</sub>, which is the projection onto the nullspace of the operator (<em>T</em> − λ)<sup>+</sup>, where the positive part of a self-adjoint operator is defined by</p>

<p>

<math display="block" id="Hilbert_space:117">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>A</mi>
     <mo>+</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msqrt>
        <msup>
         <mi>A</mi>
         <mn>2</mn>
        </msup>
       </msqrt>
       <mo>+</mo>
       <mi>A</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <plus></plus>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <root></root>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{+}=\frac{1}{2}\left(\sqrt{A^{2}}+A\right).
  </annotation>
 </semantics>
</math>

 The operators <em>E</em><sub>λ</sub> are monotone increasing relative to the partial order defined on self-adjoint operators; the eigenvalues correspond precisely to the jump discontinuities. One has the spectral theorem, which asserts</p>

<p>

<math display="block" id="Hilbert_space:118">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>ℝ</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>λ</mi>
      </mpadded>
      <mi>d</mi>
      <msub>
       <mi>E</mi>
       <mi>λ</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>ℝ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\int_{\mathbb{R}}\lambda\,dE_{\lambda}.
  </annotation>
 </semantics>
</math>

 The integral is understood as a Riemann–Stieltjes integral, convergent with respect to the norm on B(<em>H</em>). In particular, one has the ordinary scalar-valued integral representation</p>

<p>

<math display="block" id="Hilbert_space:119">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>T</mi>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>ℝ</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>λ</mi>
      </mpadded>
      <mi>d</mi>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mrow>
        <msub>
         <mi>E</mi>
         <mi>λ</mi>
        </msub>
        <mi>x</mi>
       </mrow>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>ℝ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>d</ci>
      <list>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>λ</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <ci>y</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Tx,y\rangle=\int_{\mathbb{R}}\lambda\,d\langle E_{\lambda}x,y\rangle.
  </annotation>
 </semantics>
</math>

 A somewhat similar spectral decomposition holds for normal operators, although because the spectrum may now contain non-real complex numbers, the operator-valued Stieltjes measure <em>dE</em><sub>λ</sub> must instead be replaced by a <a href="resolution_of_the_identity" title="wikilink">resolution of the identity</a>.</p>

<p>A major application of spectral methods is the <a href="spectral_mapping_theorem" title="wikilink">spectral mapping theorem</a>, which allows one to apply to a self-adjoint operator <em>T</em> any continuous complex function <em>f</em> defined on the spectrum of <em>T</em> by forming the integral</p>

<p>

<math display="block" id="Hilbert_space:120">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mi>σ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>T</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <msub>
       <mi>E</mi>
       <mi>λ</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>λ</ci>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(T)=\int_{\sigma(T)}f(\lambda)\,dE_{\lambda}.
  </annotation>
 </semantics>
</math>

 The resulting <a href="continuous_functional_calculus" title="wikilink">continuous functional calculus</a> has applications in particular to <a href="pseudodifferential_operators" title="wikilink">pseudodifferential operators</a>.<a class="footnoteRef" href="#fn77" id="fnref77"><sup>77</sup></a></p>

<p>The spectral theory of <em>unbounded</em> self-adjoint operators is only marginally more difficult than for bounded operators. The spectrum of an unbounded operator is defined in precisely the same way as for bounded operators: λ is a spectral value if the <a href="resolvent_operator" title="wikilink">resolvent operator</a></p>

<p>

<math display="block" id="Hilbert_space:121">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>λ</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mi>λ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>λ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <ci>λ</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\lambda}=(T-\lambda)^{-1}
  </annotation>
 </semantics>
</math>

 fails to be a well-defined continuous operator. The self-adjointness of <em>T</em> still guarantees that the spectrum is real. Thus the essential idea of working with unbounded operators is to look instead at the resolvent <em>R</em><sub>λ</sub> where λ is non-real. This is a <em>bounded</em> normal operator, which admits a spectral representation that can then be transferred to a spectral representation of <em>T</em> itself. A similar strategy is used, for instance, to study the spectrum of the Laplace operator: rather than address the operator directly, one instead looks as an associated resolvent such as a <a href="Riesz_potential" title="wikilink">Riesz potential</a> or <a href="Bessel_potential" title="wikilink">Bessel potential</a>.</p>

<p>A precise version of the spectral theorem in this case is:<a class="footnoteRef" href="#fn78" id="fnref78"><sup>78</sup></a></p>
<dl>
<dd>Given a densely defined self-adjoint operator <em>T</em> on a Hilbert space <em>H</em>, there corresponds a unique <a href="resolution_of_the_identity" title="wikilink">resolution of the identity</a> <em>E</em> on the Borel sets of <strong>R</strong>, such that

<p>

<math display="block" id="Hilbert_space:122">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>T</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>ℝ</mi>
    </msub>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>λ</mi>
     </mpadded>
     <mi>d</mi>
     <msub>
      <mi>E</mi>
      <mrow>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>ℝ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <list>
        <ci>x</ci>
        <ci>y</ci>
       </list>
      </apply>
      <ci>λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Tx,y\rangle=\int_{\mathbb{R}}\lambda\,dE_{x,y}(\lambda)
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>for all <em>x</em> ∈ <em>D</em>(<em>T</em>) and <em>y</em> ∈ <em>H</em>. The spectral measure <em>E</em> is concentrated on the spectrum of <em>T</em>.
</dd>
</dl>

<p>There is also a version of the spectral theorem that applies to unbounded normal operators.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Hadamard_space" title="wikilink">Hadamard space</a></li>
<li><a href="Hilbert_algebra_(disambiguation)" title="wikilink">Hilbert algebra</a></li>
<li><a href="Hilbert_C*-module" title="wikilink">Hilbert C*-module</a></li>
<li><a href="Hilbert_manifold" title="wikilink">Hilbert manifold</a></li>
<li><a href="Operator_theory" title="wikilink">Operator theory</a></li>
<li><a href="Operator_topologies" title="wikilink">Operator topologies</a></li>
<li><a href="Rigged_Hilbert_space" title="wikilink">Rigged Hilbert space</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li><mtpl></mtpl>.</li>
</ul>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>
<dl>
<dt>originally published <em>Monografje Matematyczne</em>, vol. 7, Warszawa, 1937.</dt>
</dl></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://mathworld.wolfram.com/HilbertSpace.html">Hilbert space at Mathworld</a></li>
<li><a href="http://terrytao.wordpress.com/2009/01/17/254a-notes-5-hilbert-spaces/">245B, notes 5: Hilbert spaces</a> by <a href="Terence_Tao" title="wikilink">Terence Tao</a></li>
</ul>

<p>"</p>

<p><a href="Category:Concepts_in_physics" title="wikilink">Category:Concepts in physics</a> <a href="Category:Hilbert_space" title="wikilink">*</a> <a href="Category:Linear_algebra" title="wikilink">Category:Linear algebra</a> <a href="Category:Operator_theory" title="wikilink">Category:Operator theory</a> <a href="Category:Quantum_mechanics" title="wikilink">Category:Quantum mechanics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">The mathematical material in this section can be found in any good textbook on functional analysis, such as , ,  or .<a href="#fnref2">↩</a></li>
<li id="fn3">In some conventions, inner products are linear in their second arguments instead.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">Largely from the work of <a href="Hermann_Grassmann" title="wikilink">Hermann Grassmann</a>, at the urging of <a href="August_Ferdinand_Möbius" title="wikilink">August Ferdinand Möbius</a> . The first modern axiomatic account of abstract vector spaces ultimately appeared in <a href="Giuseppe_Peano" title="wikilink">Giuseppe Peano</a>'s 1888 account (; ).<a href="#fnref6">↩</a></li>
<li id="fn7">A detailed account of the history of Hilbert spaces can be found in .<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">. Further details on the history of integration theory can be found in  and .<a href="#fnref10">↩</a></li>
<li id="fn11">.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13">In , the result that every linear functional on L<sup>2</sup>[0,1] is represented by integration is jointly attributed to  and . The general result, that the dual of a Hilbert space is identified with the Hilbert space itself, can be found in .<a href="#fnref13">↩</a></li>
<li id="fn14">.<a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16">.<a href="#fnref16">↩</a></li>
<li id="fn17">.<a href="#fnref17">↩</a></li>
<li id="fn18">.<a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21">.<a href="#fnref21">↩</a></li>
<li id="fn22">.<a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24">.<a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26">Details can be found in .<a href="#fnref26">↩</a></li>
<li id="fn27">A general reference on Hardy spaces is the book .<a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30">.<a href="#fnref30">↩</a></li>
<li id="fn31">The eigenvalues of the Fredholm kernel are 1/λ, which tend to zero.<a href="#fnref31">↩</a></li>
<li id="fn32">.<a href="#fnref32">↩</a></li>
<li id="fn33">More detail on finite element methods from this point of view can be found in .<a href="#fnref33">↩</a></li>
<li id="fn34"></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36">A treatment of Fourier series from this point of view is available, for instance, in  or .<a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39">.<a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42">The classic reference for spectral methods is . A more up-to-date account is .<a href="#fnref42">↩</a></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45">.<a href="#fnref45">↩</a></li>
<li id="fn46">.<a href="#fnref46">↩</a></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48"><a href="#fnref48">↩</a></li>
<li id="fn49"><a href="#fnref49">↩</a></li>
<li id="fn50"><a href="#fnref50">↩</a></li>
<li id="fn51"><a href="#fnref51">↩</a></li>
<li id="fn52"><a href="#fnref52">↩</a></li>
<li id="fn53"><a href="#fnref53">↩</a></li>
<li id="fn54"><a href="#fnref54">↩</a></li>
<li id="fn55"><a href="#fnref55">↩</a></li>
<li id="fn56"><a href="#fnref56">↩</a></li>
<li id="fn57">See ,  and .<a href="#fnref57">↩</a></li>
<li id="fn58"><a href="#fnref58">↩</a></li>
<li id="fn59"><a href="#fnref59">↩</a></li>
<li id="fn60"><a href="#fnref60">↩</a></li>
<li id="fn61"><a href="#fnref61">↩</a></li>
<li id="fn62">.<a href="#fnref62">↩</a></li>
<li id="fn63">For the case of finite index sets, see, for instance, . For infinite index sets, see .<a href="#fnref63">↩</a></li>
<li id="fn64">. Many authors, such as , refer to this just as the dimension. Unless the Hilbert space is finite dimensional, this is not the same thing as its dimension as a linear space (the cardinality of a Hamel basis).<a href="#fnref64">↩</a></li>
<li id="fn65"><a href="#fnref65">↩</a></li>
<li id="fn66"> defines a Hilbert space via a countable Hilbert basis, which amounts to an isometric isomorphism with <em>ℓ</em><sup>2</sup>. The convention still persists in most rigorous treatments of quantum mechanics; see for instance .<a href="#fnref66">↩</a></li>
<li id="fn67"><a href="#fnref67">↩</a></li>
<li id="fn68"></li>
<li id="fn69"></li>
<li id="fn70"><a href="#fnref70">↩</a></li>
<li id="fn71"><a href="#fnref71">↩</a></li>
<li id="fn72"><a href="#fnref72">↩</a></li>
<li id="fn73"><a href="#fnref73">↩</a></li>
<li id="fn74">A general account of spectral theory in Hilbert spaces can be found in . A more sophisticated account in the language of C<sup>∗</sup>-algebras is in  or <a href="#fnref74">↩</a></li>
<li id="fn75">See, for instance,  or . This result was already known to  in the case of operators arising from integral kernels.<a href="#fnref75">↩</a></li>
<li id="fn76"><a href="#fnref76">↩</a></li>
<li id="fn77"><a href="#fnref77">↩</a></li>
<li id="fn78">.<a href="#fnref78">↩</a></li>
</ol>
</section>
</body>
</html>
