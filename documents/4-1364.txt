   Solovay–Strassen primality test      Solovay–Strassen primality test   The Solovay–Strassen primality test , developed by Robert M. Solovay and Volker Strassen , is a probabilistic test to determine if a number is composite or probably prime . It has been largely superseded by the Baillie-PSW primality test and the Miller–Rabin primality test , but has great historical importance in showing the practical feasibility of the RSA  cryptosystem .  Concepts  Euler proved 1 that for any prime number  p and any integer a ,       a    (   p  -  1   )   /  2    ≡    (   a  p   )      (   mod  p   )         superscript  a      p  1   2     annotated    a  p    pmod  p      a^{(p-1)/2}\equiv\left(\frac{a}{p}\right)\;\;(\mathop{{\rm mod}}p)     where    (   a  p   )      a  p    \left(\tfrac{a}{p}\right)   is the Legendre symbol . The Jacobi symbol is a generalisation of the Legendre symbol to    (   a  n   )      a  n    \left(\tfrac{a}{n}\right)   , where n can be any odd integer. The Jacobi symbol can be computed in time O ((log n )²) using Jacobi's generalization of law of quadratic reciprocity .  Given an odd number n we can contemplate whether or not the congruence       a    (   n  -  1   )   /  2    ≡    (   a  n   )      (   mod  n   )         superscript  a      n  1   2     annotated    a  n    pmod  n      a^{(n-1)/2}\equiv\left(\frac{a}{n}\right)\;\;(\mathop{{\rm mod}}n)     holds for various values of the "base" a , given that a is relatively prime to n . If n is prime then this congruence is true for all a . So if we pick values of a at random and test the congruence, then as soon as we find an a which doesn't fit the congruence we know that n is not prime (but this does not tell us a nontrivial factorization of n ). This base a is called an Euler witness for n ; it is a witness for the compositeness of n . The base a is called an Euler liar for n if the congruence is true while n is composite.  For every composite odd n at least half of all bases      a  ∈    (    ℤ  /  n   ℤ   )   *       a   superscript      ℤ  n   ℤ       a\in(\mathbb{Z}/n\mathbb{Z})^{*}     are (Euler) witnesses: 2 this contrasts with the Fermat primality test , for which the proportion of witnesses may be much smaller. Therefore, there are no (odd) composite n without lots of witnesses, unlike the case of Carmichael numbers for Fermat's test.  Example  Suppose we wish to determine if n = 221 is prime. We write ( n −1)/2=110.  We randomly select an a = 47 ( n −1)/2 mod n =  47 110 mod 221  =  −1 mod 221       (   a  n   )      a  n    (\tfrac{a}{n})   mod n =    (   47  221   )      47  221    (\tfrac{47}{221})   mod 221  =  −1 mod 221.   This gives that, either 221 is prime, or 47 is an Euler liar for 221. We try another random a , this time choosing a = 2:   a ( n −1)/2 mod n =  2 110 mod 221  =  30 mod 221      (   a  n   )      a  n    (\tfrac{a}{n})   mod n =    (   2  221   )      2  221    (\tfrac{2}{221})   mod 221  =  −1 mod 221.   Hence 2 is an Euler witness for the compositeness of 221, and 47 was in fact an Euler liar. Note that this tells us nothing about the factors of 221 (which are 13 and 17).  Algorithm and running time  The algorithm can be written in pseudocode as follows:  Inputs : n , a value to test for primality; k , a parameter that determines the accuracy of the test  Output : composite if n is composite, otherwise probably  prime  repeat k times:  choose a randomly in the range [2, n − 1]   x ←     (   a  n   )      a  n    \left(\tfrac{a}{n}\right)     if x = 0 or      a    (   n  -  1   )   /  2    ≢   x     (   mod  n   )       not-equivalent-to   superscript  a      n  1   2     annotated  x   pmod  n      a^{(n-1)/2}\not\equiv x\;\;(\mathop{{\rm mod}}n)    then return composite  return probably  prime  Using fast algorithms for modular exponentiation , the running time of this algorithm is O( k ·log 3  n ), where k is the number of different values of a we test.  Accuracy of the test  It is possible for the algorithm to return an incorrect answer. If the input n is indeed prime, then the output will always correctly be probably prime . However, if the input n is composite then it is possible for the output to be incorrectly probably prime . The number n is then called a Euler-Jacobi pseudoprime .  When n is odd and composite, at least half of all a with gcd( a , n ) = 1 are Euler witnesses. We can prove this as follows: let { a 1 , a 2 , ..., a m } be the Euler liars and a an Euler witness. Then, for i = 1,2,..., m :         (   a  ⋅   a  i    )     (   n  -  1   )   /  2    =    a    (   n  -  1   )   /  2    ⋅   a  i    (   n  -  1   )   /  2     =    a    (   n  -  1   )   /  2    ⋅   (    a  i   n   )    ≢     (   a  n   )    (    a  i   n   )       (   mod  n   )     .         superscript   normal-⋅  a   subscript  a  i        n  1   2     normal-⋅   superscript  a      n  1   2     superscript   subscript  a  i       n  1   2           normal-⋅   superscript  a      n  1   2       subscript  a  i   n      not-equivalent-to     annotated      a  n      subscript  a  i   n     pmod  n       (a\cdot a_{i})^{(n-1)/2}=a^{(n-1)/2}\cdot a_{i}^{(n-1)/2}=a^{(n-1)/2}\cdot%
 \left(\frac{a_{i}}{n}\right)\not\equiv\left(\frac{a}{n}\right)\left(\frac{a_{i%
 }}{n}\right)\;\;(\mathop{{\rm mod}}n).     Because the following holds:         (   a  n   )    (    a  i   n   )    =   (    a  ⋅   a  i    n   )    ,          a  n      subscript  a  i   n       normal-⋅  a   subscript  a  i    n     \left(\frac{a}{n}\right)\left(\frac{a_{i}}{n}\right)=\left(\frac{a\cdot a_{i}}%
 {n}\right),     now we know that         (   a  ⋅   a  i    )     (   n  -  1   )   /  2    ≢    (    a  ⋅   a  i    n   )      (   mod  n   )     .     not-equivalent-to   superscript   normal-⋅  a   subscript  a  i        n  1   2     annotated     normal-⋅  a   subscript  a  i    n    pmod  n      (a\cdot a_{i})^{(n-1)/2}\not\equiv\left(\frac{a\cdot a_{i}}{n}\right)\;\;(%
 \mathop{{\rm mod}}n).     This gives that each a i gives a number a · a i , which is also an Euler witness. So each Euler liar gives an Euler witness and so the number of Euler witnesses is larger or equal to the number of Euler liars. Therefore, when n is composite, at least half of all a with gcd( a , n ) = 1 is an Euler witness.  Hence, the probability of failure is at most 2 − k (compare this with the probability of failure for the Miller-Rabin primality test , which is at most 4 − k ).  For purposes of cryptography the more bases a we test, i.e. if we pick a sufficiently large value of k , the better the accuracy of test. Hence the chance of the algorithm failing in this way is so small that the (pseudo) prime is used in practice in cryptographic applications, but for applications for which it is important to have a prime, a test like ECPP or Pocklington 3 should be used which proves primality.  Average-case behaviour  The bound 1/2 on the error probability of a single round of the Solovay–Strassen test holds for any input n , but those numbers n for which the bound is (approximately) attained are extremely rare. On the average, the error probability of the algorithm is significantly smaller: it is less than       2   -  k     exp   (   -    (   1  +   o   (  1  )     )     log    x    log   log   log  x        log   log  x       )         superscript  2    k            1    o  1          x        x           x          2^{-k}\exp\left(-(1+o(1))\frac{\log x\,\log\log\log x}{\log\log x}\right)     for k rounds of the test, applied to uniformly random . 4 5 The same bound also applies to the related problem of what is the conditional probability of n being composite for a random number  which has been declared prime in k rounds of the test.  Complexity  The Solovay–Strassen algorithm shows that the decision problem  COMPOSITE is in the complexity class  RP . 6  References  Further reading    See also    External links   Solovay-Strassen Implementation of the Solovay–Strassen primality test in Maple   "  Category:Primality tests  Category:Modular arithmetic  Category:Probabilistic complexity theory     Euler's criterion ↩  PlanetMath ↩  Pocklington test on Mathworld ↩  ↩  ↩  ↩     