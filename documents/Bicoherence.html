<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="779">Bicoherence</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bicoherence</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, in the area of <a href="statistical_analysis" title="wikilink">statistical analysis</a>, <strong>bicoherence</strong> is a squared normalised version of the <a class="uri" href="bispectrum" title="wikilink">bispectrum</a>. The bicoherence takes values bounded between 0 and 1, which make it a convenient measure for quantifying the extent of phase coupling in a signal. It is also known as <strong>bispectral coherency</strong>. The prefix <em>bi-</em> in <em>bispectrum</em> and <em>bicoherence</em> refers not to two time series <em>x</em><sub><em>t</em></sub>, <em>y</em><sub><em>t</em></sub> but rather to two frequencies of a single signal.</p>

<p>The <em>bispectrum</em> is a statistic used to search for nonlinear interactions. The <a href="Fourier_transform" title="wikilink">Fourier transform</a> of the second-order <a class="uri" href="cumulant" title="wikilink">cumulant</a>, i.e., the <a class="uri" href="autocorrelation" title="wikilink">autocorrelation</a> function, is the traditional <a href="power_spectrum" title="wikilink">power spectrum</a>. The Fourier transform of C<sub>3</sub>(t<sub>1</sub>,t<sub>2</sub>) (third-order <a class="uri" href="cumulant" title="wikilink">cumulant</a>) is called bispectrum or <strong>bispectral density</strong>. They fall in the category of <em>Higher Order Spectra</em>, or <em>Polyspectra</em> and provide supplementary information to the power spectrum. The third order polyspectrum (bispectrum) is the easiest to compute, and hence the most popular.</p>

<p>The difference with measuring <em>coherence</em> (coherence analysis is an extensively used method to study the correlations in frequency domain, between two simultaneously measured signals) is the need for both input and output measurements by estimating two auto-spectra and one cross spectrum. On the other hand, bicoherence is an auto-quantity, i.e. it can be computed from a single signal. The coherence function provides a quantification of deviations from linearity in the system which lies between the input and output measurement sensors. The bicoherence measures the proportion of the signal energy at any bifrequency that is quadratically phase coupled. It is usually normalized in the range similar to correlation coefficient and classical (second order) coherence. It was also used for depth of anasthesia assesement and widely in plasma physics (nonlinear energy transfer) and also for detection of gravitation waves.</p>

<p>Bispectrum and bicoherence may be applied to the case of non-linear interactions of a continuous spectrum of propagating waves in one dimension <a href="http://www.iop.org/EJ/abstract/0741-3335/30/5/005">1</a>.</p>

<p>Bicoherence measurements have been carried out for <a href="Electroencephalography" title="wikilink">EEG</a> <a href="signals_(biology)" title="wikilink">signals</a> monitoring in <a class="uri" href="sleep" title="wikilink">sleep</a>, <a href="Awake" title="wikilink">wakefulness</a> and <a class="uri" href="seizures" title="wikilink">seizures</a>.</p>
<h2 id="definition">Definition</h2>

<p>The bispectrum is defined as the triple product</p>

<p>

<math display="block" id="Bicoherence:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>F</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>f</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>f</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <times></times>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(f_{1},f_{2})=F(f_{1})F(f_{2})F^{*}(f_{1}+f_{2})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Bicoherence:1">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is the bispectrum evaluated at frequencies 

<math display="inline" id="Bicoherence:2">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bicoherence:3">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Bicoherence:4">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is the Fourier transform of the signal, and 

<math display="inline" id="Bicoherence:5">
 <semantics>
  <msup>
   <mi></mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}^{*}
  </annotation>
 </semantics>
</math>

 denotes the complex conjugate. The Fourier transform is a complex quantity, and so is the bispectrum. From complex multiplication, the magnitude of the bispectrum is equal to the product of the magnitudes of each of the frequency components, and the phase of the bispectrum is the sum of the phases of each of the frequency components.</p>

<p>Suppose that the three Fourier components 

<math display="inline" id="Bicoherence:6">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>f</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(f_{1})
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Bicoherence:7">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>f</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(f_{2})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bicoherence:8">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(f_{1}+f_{2})
  </annotation>
 </semantics>
</math>

 were perfectly phase locked. Then if the Fourier transform was calculated several times from different parts of the time series, the bispectrum will always have the same value. If we add together all of the bispectra, they will sum without cancelling. On the other hand, suppose that the phases of each of these frequencies was random. Then, the bispectrum will have the same magnitude (assuming that the magnitude of the frequency components is the same) but the phase will be randomly oriented. Adding together all of the bispectra will result in cancellation, because of the random phase orientation, and so the sum of the bispectra will have a small magnitude. Detecting phase coupling requires summation over a number of independent samples- this is the first motivation for defining the bicoherence. Secondly, the bispectrum is not normalized, because it still depends on the magnitudes of each of the frequency components. The bicoherence includes a normalization factor that removes the magnitude dependence.</p>

<p>There is some inconsistency with the definition of the bicoherence normalization constant. Some of the definitions that have been used are</p>

<p>

<math display="block" id="Bicoherence:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>|</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>n</mi>
      </munder>
      <mrow>
       <msub>
        <mi>F</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>f</mi>
         <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>F</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>f</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <msubsup>
        <mi>F</mi>
        <mi>n</mi>
        <mo>*</mo>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>f</mi>
          <mn>1</mn>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>f</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>|</mo>
    </mrow>
    <msqrt>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>n</mi>
      </munder>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <msub>
           <mi>F</mi>
           <mi>n</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>f</mi>
            <mn>1</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <msup>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <msub>
           <mi>F</mi>
           <mi>n</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>f</mi>
            <mn>2</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <msup>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <msubsup>
           <mi>F</mi>
           <mi>n</mi>
           <mo>*</mo>
          </msubsup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>f</mi>
             <mn>1</mn>
            </msub>
            <mo>+</mo>
            <msub>
             <mi>f</mi>
             <mn>2</mn>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>b</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <ci>n</ci>
         </apply>
         <times></times>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <abs></abs>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>F</ci>
            <ci>n</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <abs></abs>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>F</ci>
            <ci>n</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <abs></abs>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>F</ci>
             <ci>n</ci>
            </apply>
            <times></times>
           </apply>
           <apply>
            <plus></plus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>f</ci>
             <cn type="integer">1</cn>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>f</ci>
             <cn type="integer">2</cn>
            </apply>
           </apply>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(f_{1},f_{2})=\frac{\left|\sum\limits_{n}F_{n}(f_{1})F_{n}(f_{2})F_{n}^{*}(f_%
{1}+f_{2})\right|}{\sqrt{\sum\limits_{n}|F_{n}(f_{1})|^{2}|F_{n}(f_{2})|^{2}|F%
_{n}^{*}(f_{1}+f_{2})|^{2}}}
  </annotation>
 </semantics>
</math>

 which was provided in Sigl &amp; Chamoun 1994, but does not appear to be correctly normalized. Alternatively, plasma physics typically uses</p>

<p>

<math display="block" id="Bicoherence:10">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>b</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <msub>
       <mi>F</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>f</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>F</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>f</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msubsup>
       <mi>F</mi>
       <mi>n</mi>
       <mo>*</mo>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>f</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <msub>
          <mi>F</mi>
          <mi>n</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>f</mi>
           <mn>1</mn>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>F</mi>
          <mi>n</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>f</mi>
           <mn>2</mn>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <msubsup>
          <mi>F</mi>
          <mi>n</mi>
          <mo>*</mo>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>f</mi>
            <mn>1</mn>
           </msub>
           <mo>+</mo>
           <msub>
            <mi>f</mi>
            <mn>2</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>n</ci>
        </apply>
        <times></times>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>F</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>F</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>F</ci>
            <ci>n</ci>
           </apply>
           <times></times>
          </apply>
          <apply>
           <plus></plus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{2}(f_{1},f_{2})=\frac{\langle F_{n}(f_{1})F_{n}(f_{2})F_{n}^{*}(f_{1}+f_{2}%
)\rangle}{\langle|F_{n}(f_{1})F_{n}(f_{2})|^{2}\rangle\langle|F_{n}^{*}(f_{1}+%
f_{2})|^{2}\rangle}
  </annotation>
 </semantics>
</math>

 where the angle brackets denote averaging. Note that this is the same as using a sum, because 

<math display="inline" id="Bicoherence:11">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the same in the numerator and the denominator. This definition is directly from Nagashima 2006, and is also referred to in He 2009 and Maccarone 2005.</p>

<p>Finally, one of the most intuitive definitions comes from Hagihira 2001 and Hayashi 2007, which is</p>

<p>

<math display="block" id="Bicoherence:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>|</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>n</mi>
      </munder>
      <mrow>
       <msub>
        <mi>F</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>f</mi>
         <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>F</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>f</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <msubsup>
        <mi>F</mi>
        <mi>n</mi>
        <mo>*</mo>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>f</mi>
          <mn>1</mn>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>f</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>|</mo>
    </mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>n</mi>
     </munder>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msub>
        <mi>F</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>f</mi>
         <mn>1</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>F</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>f</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <msubsup>
        <mi>F</mi>
        <mi>n</mi>
        <mo>*</mo>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>f</mi>
          <mn>1</mn>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>f</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>b</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <ci>n</ci>
         </apply>
         <times></times>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>n</ci>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <ci>n</ci>
         </apply>
         <times></times>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(f_{1},f_{2})=\frac{\left|\sum\limits_{n}F_{n}(f_{1})F_{n}(f_{2})F_{n}^{*}(f_%
{1}+f_{2})\right|}{\sum\limits_{n}|F_{n}(f_{1})F_{n}(f_{2})F_{n}^{*}(f_{1}+f_{%
2})|}
  </annotation>
 </semantics>
</math>

</p>

<p>The numerator contains the magnitude of the bispectrum summed over all of the time series segments. This quantity is large if there is phase coupling, and approaches 0 in the limit of random phases. The denominator, which normalizes the bispectrum, is given by calculating the bispectrum after setting all of the phases to 0. This corresponds to the case where there is perfect phase coupling, because all of the samples have zero phase. Therefore, the bicoherence has a value between 0 (random phases) and 1 (total phase coupling).</p>
<h2 id="references">References</h2>
<ul>
<li>Hagihira, S., Takashina, M., Mori, T., Mashimo, T., &amp; Yoshiya, I. (2001). Practical Issues in Bispectral Analysis of Electroencephalographic Signals. Anesthesia &amp; Analgesia, 93(4), 966-970. Retrieved from <a class="uri" href="http://www.anesthesia-analgesia.org/content/93/4/966.abstract">http://www.anesthesia-analgesia.org/content/93/4/966.abstract</a></li>
<li>Hayashi, K., Tsuda, N., Sawa, T., &amp; Hagihira, S. (2007). Ketamine increases the frequency of electroencephalographic bicoherence peak on the alpha spindle area induced with propofol. British journal of anaesthesia, 99(3), 389-95. <a class="uri" href="doi:10.1093/bja/aem175">doi:10.1093/bja/aem175</a></li>
<li>Nagashima, Y., Itoh, K., Itoh, S.-I., Hoshino, K., Fujisawa, A., Ejiri, A., Takase, Y., et al. (2006). Observation of coherent bicoherence and biphase in potential fluctuations around geodesic acoustic mode frequency on JFT-2M. Plasma Physics and Controlled Fusion, 48(5A), A377-A386. <a class="uri" href="doi:10.1088/0741-3335/48/5A/S38">doi:10.1088/0741-3335/48/5A/S38</a></li>
<li>He, H. (2009). The Canonical Bicoherence - Part I : Definition, Multitaper Estimation, and Statistics. Signal Processing, IEEE Transactions, 57(4), 1273-1284. Retrieved from <a class="uri" href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4749274">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4749274</a></li>
<li>Maccarone, T. J., &amp; Schnittman, J. D. (2004). The bicoherence as a diagnostic for models of high-frequency quasi-periodic oscillations. <a href="Monthly_Notices_of_the_Royal_Astronomical_Society" title="wikilink">Monthly Notices of the Royal Astronomical Society</a>, 357(1), 12-16. <a class="uri" href="doi:10.1111/j.1365-2966.2004.08615.x">doi:10.1111/j.1365-2966.2004.08615.x</a></li>
<li>Mendel JM. "Tutorial on higher-order statistics (spectra) in signal processing and system theory: theoretical results and some applications." <em>Proceedings of the IEEE</em>, <strong>79</strong>, 3, 278-305</li>
<li>M J Hinich, "Testing for Gaussianity and linearity of a stationary time series", <em>Journal of Time Series Analysis</em> <strong>3</strong>(3), 1982 pp 169–176.</li>
<li>[<a class="uri" href="http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=3013&amp;objectType">http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=3013&amp;objectType;</a>;=file HOSA - Higher Order Spectral Analysis Toolbox]. <em>(shareware for Microsoft Windows-type personal computers.)</em></li>
<li>T.H. Bullock, J.Z. Achimowicz <em>et al.</em>, "Bicoherence of intracranial EEG in awake, sleep and seizures", Journal of Clinical Neurophysiology and EEG, 1997,vol.231,pp. 130–142.</li>
</ul>

<p>"</p>

<p><a href="Category:Complex_analysis" title="wikilink">Category:Complex analysis</a> <a href="Category:Integral_transforms" title="wikilink">Category:Integral transforms</a> <a href="Category:Fourier_analysis" title="wikilink">Category:Fourier analysis</a></p>
</body>
</html>
