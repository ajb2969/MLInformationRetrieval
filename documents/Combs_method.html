<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1419">Combs method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Combs method</h1>
<hr/>

<p>The <strong>Combs method</strong> is a method of writing <a href="fuzzy_logic" title="wikilink">fuzzy logic</a> rules described by <a href="William_E._Combs" title="wikilink">William E. Combs</a> in 1997. It is designed to prevent <a href="combinatorial_explosion" title="wikilink">combinatorial explosion</a> in fuzzy logic rules.</p>

<p>The Combs method takes advantage of the <a href="propositional_logic" title="wikilink">logical</a> equality 

<math display="inline" id="Combs_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>∧</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⇒</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>⇒</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo>⇒</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <and></and>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-⇒</ci>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <or></or>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-⇒</ci>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((p\land q)\Rightarrow r)\iff((p\Rightarrow r)\lor(q\Rightarrow r))
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="equality-proof">Equality proof</h2>

<p>The simplest proof of given equality involves usage of truth tables:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Combs_method:1">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Combs_method:2">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Combs_method:3">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Combs_method:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>∧</mo>
    <mi>q</mi>
   </mrow>
   <mo>⇒</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <apply>
     <and></and>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\land q\Rightarrow r
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Combs_method:5">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>⇒</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <ci>p</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\Rightarrow r
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Combs_method:6">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>⇒</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <ci>q</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\Rightarrow r
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Combs_method:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>⇒</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>⇒</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\Rightarrow r)\lor(q\Rightarrow r)
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>F</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
</tr>
</tbody>
</table>
<h2 id="combinatorial-explosion">Combinatorial explosion</h2>

<p>Suppose we have a fuzzy system that considers N variables at a time, each of which can fit into at least one of S sets. The number of rules necessary to cover all the cases in a traditional fuzzy system is 

<math display="inline" id="Combs_method:8">
 <semantics>
  <msup>
   <mi>S</mi>
   <mi>N</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{N}
  </annotation>
 </semantics>
</math>

, whereas the Combs method would need only 

<math display="inline" id="Combs_method:9">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\times N
  </annotation>
 </semantics>
</math>

 rules. For example, if we have five sets and five variables to consider to produce one output, covering all the cases would require 3125 rules in a traditional system, while the Combs method would require only 25 rules, taming the <a href="combinatorial_explosion" title="wikilink">combinatorial explosion</a> that occurs when more inputs or more sets are added to the system.</p>

<p>This article will focus on the Combs method itself. To learn more about the way rules are traditionally formed, see <a href="fuzzy_logic" title="wikilink">fuzzy logic</a> and <a href="fuzzy_associative_matrix" title="wikilink">fuzzy associative matrix</a>.</p>
<h2 id="example">Example</h2>

<p>Suppose we were designing an <a href="artificial_personality" title="wikilink">artificial personality</a> system that determined how friendly the personality is supposed to be towards a person in a strategic video game. The personality would consider its own fear, trust, and love in the other person. A set of rules in the Combs system might look like this:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Fear</p></th>
<th style="text-align: left;">
<p>Unafraid THEN Enemies</p></th>
<th style="text-align: left;">
<p>Moderate Fear THEN Neutral</p></th>
<th style="text-align: left;">
<p>Afraid THEN Good Friends</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Trust</p></td>
<td style="text-align: left;">
<p>Distrusting THEN Enemies</p></td>
<td style="text-align: left;">
<p>Moderate Trust THEN Neutral</p></td>
<td style="text-align: left;">
<p>Trusting THEN Good Friends</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Love</p></td>
<td style="text-align: left;">
<p>Unloving THEN Enemies</p></td>
<td style="text-align: left;">
<p>Moderate Love THEN Neutral</p></td>
<td style="text-align: left;">
<p>Loving THEN Good Friends</p></td>
</tr>
</tbody>
</table>

<p>The table translates to:</p>

<p><code>[IF Fear IS Unafraid THEN Friendship IS Enemies OR</code><br/>
<code> IF Fear IS ModerateFear THEN Friendship IS Neutral OR</code><br/>
<code> IF Fear IS Afraid THEN Friendship IS GoodFriends ]</code><br/>
<code>OR</code><br/>
<code>[IF Trust IS Distrusting THEN Friendship IS Enemies OR</code><br/>
<code> IF Trust IS ModerateTrust THEN Friendship IS Neutral OR</code><br/>
<code> IF Trust IS Trusting THEN Friendship IS GoodFriends]</code><br/>
<code>OR</code><br/>
<code>[IF Love IS Unloving THEN Friendship IS Enemies OR</code><br/>
<code> IF Love IS ModerateLove THEN Friendship IS Neutral OR</code><br/>
<code> IF Love IS Loving THEN Friendship IS GoodFriends]</code></p>

<p>In this case, because the table follows a straightforward pattern in the output, it could be rewritten as:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Fear</p></th>
<th style="text-align: left;">
<p>Unafraid</p></th>
<th style="text-align: left;">
<p>Moderate Fear</p></th>
<th style="text-align: left;">
<p>Afraid</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Trust</p></td>
<td style="text-align: left;">
<p>Distrusting</p></td>
<td style="text-align: left;">
<p>Moderate Trust</p></td>
<td style="text-align: left;">
<p>Trusting</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Love</p></td>
<td style="text-align: left;">
<p>Unloving</p></td>
<td style="text-align: left;">
<p>Moderate Love</p></td>
<td style="text-align: left;">
<p>Loving</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Friendship</p></td>
<td style="text-align: left;">
<p><em>Enemies</em></p></td>
<td style="text-align: left;">
<p><em>Neutral</em></p></td>
<td style="text-align: left;">
<p><em>Good Friends</em></p></td>
</tr>
</tbody>
</table>

<p>Each column of the table maps to the output provided in the last row. To obtain the output of the system, we just average the outputs of each rule for that output. For example, to calculate how much the computer is Enemies with the player, we take the average of how much the computer is Unafraid, Distrusting, and Unloving of the player. When all three averages are obtained, the result can then be <a href="defuzzification" title="wikilink">defuzzified</a> by any of the traditional means.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://gaia.ecs.csus.edu/~hellerm/EEE222/Atricles/Combs_Fuzzy_Logic/Combs_Rapid_Inference.htm">The Combs Method for Rapid Inference</a> (the original paper by William E. Combs)</li>
</ul>

<p>"</p>

<p><a href="Category:Fuzzy_logic" title="wikilink"> </a> <a href="Category:Artificial_intelligence" title="wikilink">Category:Artificial intelligence</a> <a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a> <a href="Category:Non-classical_logic" title="wikilink">Category:Non-classical logic</a></p>
</body>
</html>
