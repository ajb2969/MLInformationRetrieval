<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1665">Lattice sieving</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lattice sieving</h1>
<hr/>

<p><strong>Lattice sieving</strong> is a technique for finding <a href="smooth_number" title="wikilink">smooth</a> values of a bivariate polynomial 

<math display="inline" id="Lattice_sieving:0">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>b</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a,b)
  </annotation>
 </semantics>
</math>

 over a large region. It is almost exclusively used in conjunction with the <a href="number_field_sieve" title="wikilink">number field sieve</a>. The original idea of the lattice sieve came from <a href="John_Pollard_(mathematician)" title="wikilink">John Pollard</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The algorithm implicitly involves the <a href="ideal_(ring_theory)" title="wikilink">ideal</a> structure of the <a href="number_field" title="wikilink">number field</a> of the polynomial; it takes advantage of the theorem that any <a href="prime_ideal" title="wikilink">prime ideal</a> above some rational prime <em>p</em> can be written as 

<math display="inline" id="Lattice_sieving:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi>ℤ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>α</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>u</mi>
      <mo>+</mo>
      <mrow>
       <mi>v</mi>
       <mi>α</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ℤ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>α</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>ℤ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>u</ci>
      <apply>
       <times></times>
       <ci>v</ci>
       <ci>α</ci>
      </apply>
     </apply>
     <ci>ℤ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mathbb{Z}[\alpha]+(u+v\alpha)\mathbb{Z}[\alpha]
  </annotation>
 </semantics>
</math>

. One then picks many prime numbers <em>q</em> of an appropriate size, usually just above the <a href="factor_base" title="wikilink">factor base</a> limit, and proceeds by</p>
<dl>
<dd><dl>
<dd>For each <em>q</em>, list the prime ideals above <em>q</em> by factorising the polynomial f(a,b) over 

<math display="inline" id="Lattice_sieving:2">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>F</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GF(q)
  </annotation>
 </semantics>
</math>


<dl>
<dd>For each of these prime ideals, which are called 'special 

<math display="inline" id="Lattice_sieving:3">
 <semantics>
  <mi>𝔮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{q}
  </annotation>
 </semantics>
</math>

's, construct a <a href="lattice_reduction" title="wikilink">reduced basis</a> 

<math display="inline" id="Lattice_sieving:4">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mo>,</mo>
   <mi>𝐲</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>𝐱</ci>
    <ci>𝐲</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x},\mathbf{y}
  </annotation>
 </semantics>
</math>

 for the lattice L generated by 

<math display="inline" id="Lattice_sieving:5">
 <semantics>
  <mi>𝔮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{q}
  </annotation>
 </semantics>
</math>

; set a two-dimensional array called the <a href="sieve_region" title="wikilink">sieve region</a> to zero.
<dl>
<dd>For each prime ideal 

<math display="inline" id="Lattice_sieving:6">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

 in the factor base, construct a reduced basis 

<math display="inline" id="Lattice_sieving:7">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mi>𝔭</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>𝐲</mi>
    <mi>𝔭</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <ci>𝔭</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐲</ci>
     <ci>𝔭</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{\mathfrak{p}},\mathbf{y}_{\mathfrak{p}}
  </annotation>
 </semantics>
</math>

 for the sublattice of L generated by

<math display="inline" id="Lattice_sieving:8">
 <semantics>
  <mrow>
   <mi>𝔭</mi>
   <mi>𝔮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝔭</ci>
    <ci>𝔮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{pq}
  </annotation>
 </semantics>
</math>


<dl>
<dd>For each element of that sublattice lying within a sufficiently large sieve region, add 

<math display="inline" id="Lattice_sieving:9">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>𝔭</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <apply>
     <abs></abs>
     <ci>𝔭</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log|\mathfrak{p}|
  </annotation>
 </semantics>
</math>

 to that entry.
</dd>
</dl>
</dd>
</dl>
</dd>
<dd>Read out all the entries in the sieve region with a large enough value
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p>For the number field sieve application, it is necessary for two polynomials both to have smooth values; this is handled by running the inner loop over both polynomials, whilst the special-q can be taken from either side.</p>
<h2 id="treatments-of-the-inmost-loop">Treatments of the inmost loop</h2>

<p>There are a number of clever approaches to implementing the inmost loop, since listing the elements of a lattice within a rectangular region efficiently is itself a non-trivial problem, and efficiently batching together updates to a sieve region in order to take advantage of cache structures is another non-trivial problem. The normal solution to the first is to have an ordering of the lattice points defined by couple of generators picked so that the decision rule which takes you from one lattice point to the next is straightforward; the normal solution to the second is to collect a series of lists of updates to sub-regions of the array smaller than the size of the level-2 cache, with the number of lists being roughly the number of lines in the L1 cache so that adding an entry to a list is generally a cache hit, and then applying the lists of updates one at a time, where each application will be a level-2 cache hit. For this to be efficient you need to be able to store a number of updates at least comparable to the size of the sieve array, so this can be quite profligate in memory usage.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Integer_factorization_algorithms" title="wikilink">Category:Integer factorization algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Arjen K. Lenstra and H. W. Lenstra, Jr. (eds.). "The development of the number field sieve". Lecture Notes in Math. (1993) 1554. Springer-Verlag.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
