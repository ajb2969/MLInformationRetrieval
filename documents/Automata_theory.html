<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="248">Automata theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Automata theory</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The study of the mathematical properties of such automata is automata theory. The picture is a visualization of an automaton that recognizes strings containing an even number of <em>0</em>s. The automaton starts in state <em>S1</em>, and transitions to the non-accepting state <em>S2</em> upon reading the symbol <em>0</em>. Reading another <em>0</em> causes the automaton to transition back to the accepting state <em>S1</em>. In both states the symbol <em>1</em> is ignored by making a transition to the current state.</figcaption>
</figure>

<p><strong>Automata theory</strong> is the study of <em><a href="abstract_machine" title="wikilink">abstract machines</a></em> and <em><a href="automaton" title="wikilink">automata</a></em>, as well as the computational problems that can be solved using them. It is a theory in <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>, under <a href="discrete_mathematics" title="wikilink">discrete mathematics</a> (a section of <a class="uri" href="Mathematics" title="wikilink">Mathematics</a> and also of <a href="Computer_Science" title="wikilink">Computer Science</a>). <em>Automata</em> comes from the Greek word αὐτόματα meaning "self-acting".</p>

<p>The figure at right illustrates a <a href="finite_state_machine" title="wikilink">finite state machine</a>, which belongs to one well-known variety of automaton. This automaton consists of <a href="State_(computer_science)" title="wikilink">states</a> (represented in the figure by circles), and transitions (represented by arrows). As the automaton sees a symbol of input, it makes a <em>transition</em> (or <em>jump</em>) to another state, according to its <em>transition function</em> (which takes the current state and the recent symbol as its inputs).</p>

<p>Automata theory is also closely related to <a href="formal_language_theory" title="wikilink">formal language theory</a>. An automaton is a finite representation of a formal language that may be an infinite set. Automata are often classified by the class of <a href="formal_language" title="wikilink">formal languages</a> they are able to recognize.</p>

<p>Automata play a major role in <a href="theory_of_computation" title="wikilink">theory of computation</a>, <a href="compiler_design" title="wikilink">compiler design</a>, <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>, <a class="uri" href="parsing" title="wikilink">parsing</a> and <a href="formal_verification" title="wikilink">formal verification</a>.</p>
<h2 id="automata">Automata</h2>

<p>Following is an introductory definition of one type of automaton, which attempts to help one grasp the essential concepts involved in automata theory(s).</p>
<h3 id="informal-description">Informal description</h3>

<p>An automaton is supposed to <em>run</em> on some given sequence of <em>inputs</em> in discrete time steps. An automaton gets one input every time step that is picked up from a set of <em><a href="Symbol_(formal)" title="wikilink">symbols</a></em> or <em>letters</em>, which is called an <em><a href="alphabet_(computer_science)" title="wikilink">alphabet</a></em>. At any time, the symbols so far fed to the automaton as input form a finite sequence of symbols, which is called a <em>word</em>. An automaton contains a finite set of <em>states</em>. At each instance in time of some run, the automaton is <em>in</em> one of its states. At each time step when the automaton reads a symbol, it jumps or transitions to another state that is decided by a function that takes the current state and symbol as parameters. This function is called the <em>transition function</em>. The automaton reads the symbols of the input word one after another and transitions from state to state according to the transition function, until the word is read completely. Once the input word has been read, the automaton is said to have stopped and the state at which automaton has stopped is called the final state. Depending on the final state, it's said that the automaton either <em>accepts</em> or <em>rejects</em> an input word. There is a subset of states of the automaton, which is defined as the set of <em>accepting states</em>. If the final state is an accepting state, then the automaton <em>accepts</em> the word. Otherwise, the word is <em>rejected</em>. The set of all the words accepted by an automaton is called the <em><a href="formal_language" title="wikilink">language</a> recognized by the automaton</em>.</p>

<p>In short, an automaton is a <a href="mathematical_object" title="wikilink">mathematical object</a> that takes a word as input and decides either to accept it or reject it. Since all computational problems are reducible into the accept/reject question on words (all problem instances can be represented in a finite length of symbols), automata theory plays a crucial role in <a href="computational_theory" title="wikilink">computational theory</a>.</p>
<h3 id="formal-definition">Formal definition</h3>
<dl>
<dt>Automaton</dt>
<dd>A deterministic finite <strong>automaton</strong> is represented formally by a <a href="N-tuple" title="wikilink">5-tuple</a> <strong>(Q,Σ,δ,q<sub>0</sub>,F)</strong>, where:
<ul>
<li>Q is a finite set of <em>states</em>.</li>
<li>Σ is a finite set of <em><a href="symbol" title="wikilink">symbols</a></em>, called the <em><a href="alphabet_(computer_science)" title="wikilink">alphabet</a></em> of the automaton.</li>
<li>δ is the <strong>transition function</strong>, that is, δ: Q × Σ → Q.</li>
<li>q<sub>0</sub> is the <em>start state</em>, that is, the state of the automaton before any input has been processed, where q<sub>0</sub>∈ Q.</li>
<li>F is a set of states of Q (i.e. F⊆Q) called <strong>accept states</strong>.</li>
</ul>
</dd>
</dl>
<dl>
<dt>Input word</dt>
<dd>An automaton reads a finite <a href="Word_(mathematics)" title="wikilink">string</a> of symbols a<sub>1</sub>,a<sub>2</sub>,...., a<sub>n</sub> , where a<sub>i</sub> ∈ Σ, which is called an <em>input word</em>. The set of all words is denoted by Σ*.
</dd>
<dt>Run</dt>
<dd>A sequence of states q<sub>0</sub>,q<sub>1</sub>,q<sub>2</sub>,...., q<sub>n</sub>, where q<sub>i</sub> ∈ Q such that q<sub>0</sub> is the start state and q<sub>i</sub> = δ(q<sub>i-1</sub>,a<sub>i</sub>) for 0 1,a<sub>2</sub>,...., a<sub>n</sub> ∈ Σ*. In other words, at first the automaton is at the start state q<sub>0</sub>, and then the automaton reads symbols of the input word in sequence. When the automaton reads symbol a<sub>i</sub> it jumps to state q<sub>i</sub> = δ(q<sub>i-1</sub>,a<sub>i</sub>). q<sub>n</sub> is said to be the <em>final state</em> of the run.
</dd>
</dl>
<dl>
<dt>Accepting word</dt>
<dd>A word w ∈ Σ* is accepted by the automaton if q<sub>n</sub> ∈ F.
</dd>
</dl>
<dl>
<dt>Recognized language</dt>
<dd>An automaton can recognize a <a href="formal_language" title="wikilink">formal language</a>. The language L ⊆ Σ* recognized by an automaton is the set of all the words that are accepted by the automaton.
</dd>
</dl>
<dl>
<dt>Recognizable languages</dt>
<dd>The <a href="recognizable_language" title="wikilink">recognizable languages</a> are the set of languages that are recognized by some automaton. For the above definition of automata the recognizable languages are <a href="regular_language" title="wikilink">regular languages</a>. For different definitions of automata, the recognizable languages are different.
</dd>
</dl>
<h2 id="variant-definitions-of-automata">Variant definitions of automata</h2>

<p>Automata are defined to study useful machines under mathematical formalism. So, the definition of an automaton is open to variations according to the "real world machine", which we want to model using the automaton. People have studied many variations of automata. The most standard variant, which is described above, is called a <a href="deterministic_finite_automaton" title="wikilink">deterministic finite automaton</a>. The following are some popular variations in the definition of different components of automata.</p>
<dl>
<dt>Input</dt>
</dl>
<ul>
<li><em>Finite input</em>: An automaton that accepts only finite sequence of symbols. The above introductory definition only encompasses finite words.</li>
<li><em>Infinite input</em>: An automaton that accepts infinite words (<a href="Omega_language" title="wikilink">ω-words</a>). Such automata are called <em><a href="omega_automaton" title="wikilink">ω-automata</a></em>.</li>
<li><em>Tree word input</em>: The input may be a <em><a href="tree_(automata_theory)" title="wikilink">tree of symbols</a></em> instead of sequence of symbols. In this case after reading each symbol, the automaton <em>reads</em> all the successor symbols in the input tree. It is said that the automaton <em>makes one copy</em> of itself for each successor and each such copy starts running on one of the successor symbol from the state according to the transition relation of the automaton. Such an automaton is called a <a href="tree_automaton" title="wikilink">tree automaton</a>.</li>
<li><em>Infinite tree input</em> : The two extensions above can be combined, so the automaton reads a tree structure with (in)finite branches. Such an automaton is called an <a href="infinite_tree_automaton" title="wikilink">infinite tree automaton</a></li>
</ul>
<dl>
<dt>States</dt>
</dl>
<ul>
<li><em>Finite states</em>: An automaton that contains only a finite number of states. The above introductory definition describes automata with finite numbers of states.</li>
<li><em>Infinite states</em>: An automaton that may not have a finite number of states, or even a <a class="uri" href="countable" title="wikilink">countable</a> number of states. For example, the <a href="quantum_finite_automaton" title="wikilink">quantum finite automaton</a> or <a href="topological_automaton" title="wikilink">topological automaton</a> has <a href="uncountable_infinity" title="wikilink">uncountable infinity</a> of states.</li>
<li><em>Stack memory</em>: An automaton may also contain some extra memory in the form of a <a href="Stack_(abstract_data_type)" title="wikilink">stack</a> in which symbols can be pushed and popped. This kind of automaton is called a <em><a href="pushdown_automaton" title="wikilink">pushdown automaton</a></em></li>
</ul>
<dl>
<dt>Transition function</dt>
</dl>
<ul>
<li><em>Deterministic</em>: For a given current state and an input symbol, if an automaton can only jump to one and only one state then it is a <em><a href="deterministic_automaton" title="wikilink">deterministic automaton</a></em>.</li>
<li><em>Nondeterministic</em>: An automaton that, after reading an input symbol, may jump into any of a number of states, as licensed by its transition relation. Notice that the term transition function is replaced by transition relation: The automaton <em>non-deterministically</em> decides to jump into one of the allowed choices. Such automata are called <em>nondeterministic automata</em>.</li>
<li><em>Alternation</em>: This idea is quite similar to tree automaton, but orthogonal. The automaton may run its <em>multiple copies</em> on the <em>same</em> next read symbol. Such automata are called <em><a href="alternating_automaton" title="wikilink">alternating automata</a></em>. Acceptance condition must satisfy all runs of such <em>copies</em> to accept the input.</li>
</ul>
<dl>
<dt>Acceptance condition</dt>
</dl>
<ul>
<li><em>Acceptance of finite words</em>: Same as described in the informal definition above.</li>
<li><em>Acceptance of infinite words</em>: an <em>omega automaton</em> cannot have final states, as infinite words never terminate. Rather, acceptance of the word is decided by looking at the infinite sequence of visited states during the run.</li>
<li><em>Probabilistic acceptance</em>: An automaton need not strictly accept or reject an input. It may accept the input with some <a class="uri" href="probability" title="wikilink">probability</a> between zero and one. For example, quantum finite automaton, <a href="geometric_automaton" title="wikilink">geometric automaton</a> and <em>metric automaton</em> have probabilistic acceptance.</li>
</ul>

<p>Different combinations of the above variations produce many classes of automaton.</p>

<p>Automata theory is a subject matter that studies properties of various types of automata. For example, the following questions are studied about a given type of automata.</p>
<ul>
<li>Which class of formal languages is recognizable by some type of automata? (Recognizable languages)</li>
<li>Are certain automata <em>closed</em> under union, intersection, or complementation of formal languages? (Closure properties)</li>
<li>How much is a type of automata expressive in terms of recognizing a class of formal languages? And, their relative expressive power? (Language Hierarchy)</li>
</ul>

<p>Automata theory also studies if there exist any <a href="effective_method" title="wikilink">effective algorithm</a> or not to solve problems similar to the following list.</p>
<ul>
<li>Does an automaton accept any input word? (emptiness checking)</li>
<li>Is it possible to transform a given non-deterministic automaton into deterministic automaton without changing the recognizable language? (Determinization)</li>
<li>For a given formal language, what is the smallest automaton that recognizes it? (<a href="DFA_minimization" title="wikilink">Minimization</a>).</li>
</ul>
<h2 id="classes-of-automata">Classes of automata</h2>

<p>The following is an incomplete list of types of [<a class="uri" href="http://en.wikipedia.org/w/index.php?title=Automata_theory&amp;action">http://en.wikipedia.org/w/index.php?title=Automata_theory&amp;action;</a>;=edit&amp;section;=5 automata].</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Automaton</p></th>
<th style="text-align: left;">
<p>Recognizable language</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Finite_state_machine" title="wikilink">Nondeterministic/Deterministic Finite state machine</a> (FSM)</p></td>
<td style="text-align: left;">
<p><a href="regular_language" title="wikilink">regular languages</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Deterministic_pushdown_automaton" title="wikilink">Deterministic pushdown automaton</a> (DPDA)</p></td>
<td style="text-align: left;">
<p><a href="deterministic_context-free_languages" title="wikilink">deterministic context-free languages</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Pushdown_automaton" title="wikilink">Pushdown automaton</a> (PDA)</p></td>
<td style="text-align: left;">
<p><a href="context-free_languages" title="wikilink">context-free languages</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Linear_bounded_automaton" title="wikilink">Linear bounded automaton</a> (LBA)</p></td>
<td style="text-align: left;">
<p><a href="context-sensitive_languages" title="wikilink">context-sensitive languages</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Turing_machine" title="wikilink">Turing machine</a></p></td>
<td style="text-align: left;">
<p><a href="recursively_enumerable_languages" title="wikilink">recursively enumerable languages</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Deterministic <a href="Büchi_automaton" title="wikilink">Büchi automaton</a></p></td>
<td style="text-align: left;">
<p><a href="Omega_language#Operations" title="wikilink">ω-limit languages</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Nondeterministic Büchi automaton</p></td>
<td style="text-align: left;">
<p><a href="Omega-regular_language" title="wikilink">ω-regular languages</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Rabin_automaton" title="wikilink">Rabin automaton</a>, <a href="Streett_automaton" title="wikilink">Streett automaton</a>, <a href="Parity_automaton" title="wikilink">Parity automaton</a>, <a href="Muller_automaton" title="wikilink">Muller automaton</a></p></td>
<td style="text-align: left;">
<p>ω-regular languages</p></td>
</tr>
</tbody>
</table>
<h3 id="discrete-continuous-and-hybrid-automata">Discrete, continuous, and hybrid automata</h3>

<p>Normally automata theory describes the states of abstract machines but there are analog automata or continuous automata or <a href="Hybrid_automaton" title="wikilink">hybrid discrete-continuous automata</a>, which use analog data, continuous time, or both.</p>
<h2 id="hierarchy-in-terms-of-powers">Hierarchy in terms of powers</h2>

<p>The following is an incomplete hierarchy in terms of powers of different types of virtual machines.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Automaton</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Deterministic_Finite_Automaton" title="wikilink">Deterministic Finite Automaton</a> (DFA) -- Lowest Power<br/>
(same power)    

<math display="inline" id="Automata_theory:0">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <ci>normal-|</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||
  </annotation>
 </semantics>
</math>

   (same power)<br/>
</p></td>
</tr>
</tbody>
</table>
<h2 id="applications">Applications</h2>

<p>Each model in automata theory plays important roles in several applied areas. <a href="Finite_automata" title="wikilink">Finite automata</a> are used in text processing, compilers, and hardware design. <a href="Context-free_grammar" title="wikilink">Context-free grammar</a> (CFGs) are used in programming languages and artificial intelligence. Originally, CFGs were used in the study of the human languages. <a href="Cellular_automata" title="wikilink">Cellular automata</a> are used in the field of biology, the most common example being <a href="John_Horton_Conway" title="wikilink">John Conway</a>'s <a href="Conway's_Game_of_Life" title="wikilink">Game of Life</a>. Some other examples which could be explained using automata theory in biology include mollusk and pine cones growth and pigmentation patterns. Going further, a theory suggesting that the whole universe is computed by some sort of a discrete automaton, is advocated by some scientists. The idea originated in the work of <a href="Konrad_Zuse" title="wikilink">Konrad Zuse</a>, and was popularized in America by <a href="Edward_Fredkin" title="wikilink">Edward Fredkin</a>.</p>
<h2 id="automata-simulators">Automata simulators</h2>

<p>Automata simulators are pedagogical tools used to teach, learn and research automata theory. An automata simulator takes as input the description of an automaton and then simulates its working for an arbitrary input string. The description of the automaton can be entered in several ways. An automaton can be defined in a symbolic language or its specification may be entered in a predesigned form or its transition diagram may be drawn by clicking and dragging the mouse. Well known automata simulators include Turing’s World, JFLAP, VAS, TAGS and SimStudio.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="connection-to-category-theory">Connection to category theory</h2>

<p>One can define several distinct <a href="category_(mathematics)" title="wikilink">categories</a> of automata<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> following the automata classification into different types described in the previous section. The mathematical category of deterministic automata, <a href="sequential_machine" title="wikilink">sequential machines</a> or <em>sequential automata</em>, and Turing machines with automata homomorphisms defining the arrows between automata is a <a href="Cartesian_closed_category" title="wikilink">Cartesian closed category</a>,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> it has both categorical limits and colimits. An automata homomorphism maps a quintuple of an automaton <em>A</em><sub>i</sub> onto the quintuple of another automaton '' A''<sub>j</sub>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Automata homomorphisms can also be considered as <em>automata transformations</em> or as semigroup homomorphisms, when the state space,<strong><em>S</em></strong>, of the automaton is defined as a semigroup <strong>S</strong><sub>g</sub>. <a href="Monoid" title="wikilink">Monoids</a> are also considered as a suitable setting for automata in <a href="monoidal_category" title="wikilink">monoidal categories</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<dl>
<dt>Categories of variable automata</dt>
</dl>

<p>One could also define a <em>variable automaton</em>, in the sense of Norbert Wiener in his book on <em>"Human Use of Human Beings"</em> <em>via</em> the endomorphisms 

<math display="inline" id="Automata_theory:1">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}\to A_{i}
  </annotation>
 </semantics>
</math>

. Then, one can show that such variable automata homomorphisms form a mathematical group. In the case of non-deterministic, or other complex kinds of automata, the latter set of endomorphisms may become, however, a <em>variable automaton <a class="uri" href="groupoid" title="wikilink">groupoid</a></em>. Therefore, in the most general case, categories of variable automata of any kind are <a href="categories_of_groupoids" title="wikilink">categories of groupoids</a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> or <a href="groupoid_category" title="wikilink">groupoid categories</a>. Moreover, the category of reversible automata is then a <a class="uri" href="2-category" title="wikilink">2-category</a>, and also a subcategory of the 2-category of groupoids, or the groupoid category.</p>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li>

<p>Part One: Automata and Languages, chapters 1–2, pp. 29–122. Section 4.1: Decidable Languages, pp. 152–159. Section 5.1: Undecidable Problems from Language Theory, pp. 172–183.</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.usfca.edu/~jbovet/vas.html">Visual Automata Simulator</a>, A tool for simulating, visualizing and transforming finite state automata and Turing Machines, by Jean Bovet</li>
<li><a href="http://www.jflap.org">JFLAP</a></li>
<li><a href="http://www.brics.dk/automaton">dk.brics.automaton</a></li>
<li><a href="http://www.augeas.net/libfa/index.html">libfa</a></li>
<li>

<p>Theory of Automata</p></li>
</ul>

<p>"</p>

<p><a href="Category:Automata_theory" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Chakraborty, P., Saxena, P. C., Katti, C. P. 2011. Fifty Years of Automata Simulation: A Review. <em>ACM Inroads</em>, <strong>2</strong>(4):59–70. <a class="uri" href="http://dl.acm.org/citation.cfm?id=2038893&amp;dl">http://dl.acm.org/citation.cfm?id=2038893&amp;dl;</a>;=ACM&amp;coll;=DL&amp;CFID;=65021406&amp;CFTOKEN;=86634854<a href="#fnref2">↩</a></li>
<li id="fn3">Jirí Adámek and Vera Trnková. 1990. <em>Automata and Algebras in Categories</em>. Kluwer Academic Publishers:Dordrecht and Prague<a href="#fnref3">↩</a></li>
<li id="fn4">S. Mac Lane, Categories for the Working Mathematician, Springer, New York (1971)<a href="#fnref4">↩</a></li>
<li id="fn5"><a class="uri" href="http://planetmath.org/encyclopedia/CartesianClosedCategory.html">http://planetmath.org/encyclopedia/CartesianClosedCategory.html</a> Cartesian closed category<a href="#fnref5">↩</a></li>
<li id="fn6"><a class="uri" href="http://planetmath.org/encyclopedia/SequentialMachine3.html">http://planetmath.org/encyclopedia/SequentialMachine3.html</a> The Category of Automata<a href="#fnref6">↩</a></li>
<li id="fn7"><a class="uri" href="http://www.csee.wvu.edu/~jworthing/asl2010.pdf">http://www.csee.wvu.edu/~jworthing/asl2010.pdf</a> James Worthington.2010.Determinizing, Forgetting, and Automata in Monoidal Categories. ASL North American Annual Meeting,March 17, 2010<a href="#fnref7">↩</a></li>
<li id="fn8">Aguiar, M. and Mahajan, S.2010. <em>"Monoidal Functors, Species, and Hopf Algebras"</em>.<a href="#fnref8">↩</a></li>
<li id="fn9">Meseguer, J., Montanari, U.: 1990 Petri nets are monoids. <em>Information and Computation</em> <strong>88</strong>:105–155<a href="#fnref9">↩</a></li>
<li id="fn10"><a class="uri" href="http://en.wikipedia.org/wiki/Groupoid#Category_of_groupoids">http://en.wikipedia.org/wiki/Groupoid#Category_of_groupoids</a> Category of groupoids<a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
