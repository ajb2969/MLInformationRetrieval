   Bailey–Borwein–Plouffe formula      Bailey–Borwein–Plouffe formula   The Bailey–Borwein–Plouffe formula ( BBP formula ) is a spigot algorithm for computing the n th binary digit of pi (symbol:   π   π   \pi   ) using math. The formula can directly calculate the value of any given digit of   π   π   \pi   without calculating the preceding digits. The BBP is a summation -style formula that was discovered in 1995 by Simon Plouffe and was named after the authors of the paper in which the formula was published, David H. Bailey , Peter Borwein , and Simon Plouffe . 1 Before that paper, it had been published by Plouffe on his own site. 2 The formula is      π  =    ∑   k  =  0   ∞    [    1   16  k     (    4    8  k   +  1    -   2    8  k   +  4    -   1    8  k   +  5    -   1    8  k   +  6     )    ]        π    superscript   subscript     k  0       delimited-[]      1   superscript  16  k        4      8  k   1      2      8  k   4      1      8  k   5      1      8  k   6          \pi=\sum_{k=0}^{\infty}\left[\frac{1}{16^{k}}\left(\frac{4}{8k+1}-\frac{2}{8k+%
 4}-\frac{1}{8k+5}-\frac{1}{8k+6}\right)\right]   .  The discovery of this formula came as a surprise. For centuries it had been assumed that there was no way to compute the n th digit of   π   π   \pi   without calculating all of the preceding n − 1 digits.  Since this discovery, many formulas for other irrational constants have been discovered of the general form      α  =    ∑   k  =  0   ∞    [    1   b  k      p   (  k  )     q   (  k  )      ]        α    superscript   subscript     k  0       delimited-[]      1   superscript  b  k        p  k     q  k         \alpha=\sum_{k=0}^{\infty}\left[\frac{1}{b^{k}}\frac{p(k)}{q(k)}\right]   where α is the constant and p and q are polynomials in integer coefficients and b ≥ 2 is an integer base .  Formulas in this form are known as BBP-type formulas . 3 Certain combinations of specific p , q and b result in well-known constants, but there is no systematic algorithm for finding the appropriate combinations; known formulas are discovered through experimental mathematics .  Specializations  A specialization of the general formula that has produced many results is       P   (  s  ,  b  ,  m  ,  A  )    =    ∑   k  =  0   ∞    [    1   b  k      ∑   j  =  1   m     a  j     (    m  k   +  j   )   s      ]          P   s  b  m  A      superscript   subscript     k  0       delimited-[]      1   superscript  b  k      superscript   subscript     j  1    m      subscript  a  j    superscript      m  k   j   s          P(s,b,m,A)=\sum_{k=0}^{\infty}\left[\frac{1}{b^{k}}\sum_{j=1}^{m}\frac{a_{j}}{%
 (mk+j)^{s}}\right]   where s , b and m are integers and    A  =   (   a  1   ,   a  2   ,  …  ,   a  m   )       A    subscript  a  1    subscript  a  2   normal-…   subscript  a  m      A=(a_{1},a_{2},\dots,a_{m})   is a vector of integers. The P function leads to a compact notation for some solutions.  Previously known BBP-type formulae  Some of the simplest formulae of this type that were well known before BBP, and that the P function leads to a compact notation, are      ln    10  9          10  9     \displaystyle\ln\frac{10}{9}         ln  2      2    \displaystyle\ln 2     Plouffe was also inspired by the arctan power series of the form (the P notation can be also generalized to the case where b is not an integer) :      arctan    1  b          1  b     \displaystyle\arctan\frac{1}{b}     The search for new equalities  Using the P function mentioned above, the simplest known formula for   π   π   \pi   is for s = 1 but m > 1 . Many now-discovered formulae are known for b as an exponent of 2 or 3 and m is an exponent of 2 or it is some other factor-rich value, but where several of the terms of vector A are zero. The discovery of these formulae involves a computer search for such linear combinations after computing the individual sums. The search procedure consists of choosing a range of parameter values for s, b, and m, evaluating the sums out to many digits, and then using an integer relation finding algorithm (typically Helaman Ferguson 's PSLQ algorithm) to find a vector A that adds up those intermediate sums to a well-known constant or perhaps to zero.  The BBP formula for   π   π   \pi     The original BBP   π   π   \pi   summation formula was found in 1995 by Plouffe using PSLQ . It is also representable using the P function above:     π   π   \displaystyle\pi   which also reduces to this equivalent ratio of two polynomials:       π  =    ∑   k  =  0   ∞    [    1   16  k     (     120   k  2    +   151  k   +  47     512   k  4    +   1024   k  3    +   712   k  2    +   194  k   +  15    )    ]     .      π    superscript   subscript     k  0       delimited-[]      1   superscript  16  k          120   superscript  k  2      151  k   47       512   superscript  k  4      1024   superscript  k  3      712   superscript  k  2      194  k   15         \pi=\sum_{k=0}^{\infty}\left[\frac{1}{16^{k}}\left(\frac{120k^{2}+151k+47}{512%
 k^{4}+1024k^{3}+712k^{2}+194k+15}\right)\right].     This formula has been shown through a rigorous and fairly simple proof to equal   π   π   \pi   . 4  BBP digit-extraction algorithm for   π   π   \pi     We would like to define a formula that returns the hexadecimal digit n of   π   π   \pi   . A few manipulations are required to implement a spigot algorithm using this formula.  We must first rewrite the formula as       π  =    4    ∑   k  =  0   ∞    1    (   16  k   )    (    8  k   +  1   )       -   2    ∑   k  =  0   ∞    1    (   16  k   )    (    8  k   +  4   )       -    ∑   k  =  0   ∞    1    (   16  k   )    (    8  k   +  5   )      -    ∑   k  =  0   ∞    1    (   16  k   )    (    8  k   +  6   )        .      π      4    superscript   subscript     k  0        1     superscript  16  k       8  k   1         2    superscript   subscript     k  0        1     superscript  16  k       8  k   4         superscript   subscript     k  0        1     superscript  16  k       8  k   5        superscript   subscript     k  0        1     superscript  16  k       8  k   6         \pi=4\sum_{k=0}^{\infty}\frac{1}{(16^{k})(8k+1)}-2\sum_{k=0}^{\infty}\frac{1}{%
 (16^{k})(8k+4)}-\sum_{k=0}^{\infty}\frac{1}{(16^{k})(8k+5)}-\sum_{k=0}^{\infty%
 }\frac{1}{(16^{k})(8k+6)}.\!     Now, for a particular value of n and taking the first sum, we split the sum to infinity across the n th term         ∑   k  =  0   ∞    1    (   16  k   )    (    8  k   +  1   )      =     ∑   k  =  0   n    1    (   16  k   )    (    8  k   +  1   )      +    ∑   k  =   n  +  1    ∞    1    (   16  k   )    (    8  k   +  1   )        .        superscript   subscript     k  0        1     superscript  16  k       8  k   1          superscript   subscript     k  0    n     1     superscript  16  k       8  k   1        superscript   subscript     k    n  1         1     superscript  16  k       8  k   1         \sum_{k=0}^{\infty}\frac{1}{(16^{k})(8k+1)}=\sum_{k=0}^{n}\frac{1}{(16^{k})(8k%
 +1)}+\sum_{k=n+1}^{\infty}\frac{1}{(16^{k})(8k+1)}.\!     We now multiply by 16  n so that the hexadecimal point (the divide between fractional and integer parts of the number) is in the n th place.         ∑   k  =  0   ∞     16   n  -  k      8  k   +  1     =     ∑   k  =  0   n     16   n  -  k      8  k   +  1     +    ∑   k  =   n  +  1    ∞     16   n  -  k      8  k   +  1       .        superscript   subscript     k  0         superscript  16    n  k        8  k   1         superscript   subscript     k  0    n      superscript  16    n  k        8  k   1       superscript   subscript     k    n  1          superscript  16    n  k        8  k   1        \sum_{k=0}^{\infty}\frac{16^{n-k}}{8k+1}=\sum_{k=0}^{n}\frac{16^{n-k}}{8k+1}+%
 \sum_{k=n+1}^{\infty}\frac{16^{n-k}}{8k+1}.\!     Since we only care about the fractional part of the sum, we look at our two terms and realise that only the first sum is able to produce whole numbers; conversely, the second sum cannot produce whole numbers since the numerator can never be larger than the denominator for k > n . Therefore, we need a trick to remove the whole numbers for the first sum. That trick is mod 8 k + 1. Our sum for the first fractional part then becomes:         ∑   k  =  0   n      16   n  -  k    mod   (    8  k   +  1   )      8  k   +  1     +    ∑   k  =   n  +  1    ∞     16   n  -  k      8  k   +  1      .        superscript   subscript     k  0    n      modulo   superscript  16    n  k        8  k   1        8  k   1       superscript   subscript     k    n  1          superscript  16    n  k        8  k   1       \sum_{k=0}^{n}\frac{16^{n-k}\bmod(8k+1)}{8k+1}+\sum_{k=n+1}^{\infty}\frac{16^{%
 n-k}}{8k+1}.\!     Notice how the modulo operator always guarantees that only the fractional sum will be kept. To calculate 16  n − k mod (8 k + 1) quickly and efficiently, use the modular exponentiation algorithm. When the running product becomes greater than one, take the modulo just as you do for the running total in each sum.  Now to complete the calculation you must apply this to each of the four sums in turn. Once this is done, take the four summations and put them back into the sum to   π   π   \pi   .        4   Σ  1    -   2   Σ  2    -   Σ  3   -   Σ  4    .        4   subscript  normal-Σ  1      2   subscript  normal-Σ  2     subscript  normal-Σ  3    subscript  normal-Σ  4     4\Sigma_{1}-2\Sigma_{2}-\Sigma_{3}-\Sigma_{4}.\,\!     Since only the fractional part is accurate, extracting the wanted digit requires that one removes the integer part of the final sum and multiplies by 16 to "skim off" the hexadecimal digit at this position (in theory, the next few digits up to the accuracy of the calculations used would also be accurate).  This process is similar to performing long multiplication , but only having to perform the summation of some middle columns. While there are some carries that are not counted, computers usually perform arithmetic for many bits (32 or 64) and they round and we are only interested in the most significant digit(s). There is a possibility that a particular computation will be akin to failing to add a small number (e.g. 1) to the number 999999999999999, and that the error will propagate to the most significant digit.  BBP compared to other methods of computing   π   π   \pi     This algorithm computes   π   π   \pi   without requiring custom data types having thousands or even millions of digits. The method calculates the n th digit without calculating the first n − 1 digits, and can use small, efficient data types.  The algorithm is the fastest way to compute the n th digit (or a few digits in a neighborhood of the n th); because of this, by using multiple machines, it is the fastest way to compute all the digits from 1 to n .  Though the BBP formula can directly calculate the value of any given digit of   π   π   \pi   with less computational effort than formulas that must calculate all intervening digits, BBP remains linearithmic whereby successively larger values of n require increasingly more time to calculate; that is, the "further out" a digit is, the longer it takes BBP to calculate it, just like the standard   π   π   \pi   -computing algorithms. 5  Generalizations  D.J. Broadhurst provides a generalization of the BBP algorithm that may be used to compute a number of other constants in nearly linear time and logarithmic space. 6 Explicit results are given for Catalan's constant ,    π  3     superscript  π  3    \pi^{3}   ,     log  3   2      superscript   3   2    \log^{3}2   , Apéry's constant     ζ   (  3  )       ζ  3    \zeta(3)   (where    ζ   (  x  )       ζ  x    \zeta(x)   is the Riemann zeta function ),    π  4     superscript  π  4    \pi^{4}   ,     log  4   2      superscript   4   2    \log^{4}2   ,     log  5   2      superscript   5   2    \log^{5}2   ,    ζ   (  5  )       ζ  5    \zeta(5)   , and various products of powers of   π   π   \pi   and    log  2      2    \log 2   . These results are obtained primarily by the use of polylogarithm ladders .  See also   Computing   π   π   \pi     Experimental mathematics  Bellard's formula  Feynman point   References  Further reading   D.J. Broadhurst, " Polylogarithmic ladders, hypergeometric series and the ten millionth digits of ζ(3) and ζ(5) ", (1998) arXiv math.CA/9803067   External links   Richard J. Lipton , " Making An Algorithm An Algorithm — BBP ", weblog post, July 14, 2010.  Richard J. Lipton , " Cook’s Class Contains Pi ", weblog post, March 15, 2009.   David H. Bailey , " BBP Code Directory ", web page with links to Beiley's code implementing the BBP algorithm, September 8, 2006.   "  Category:Pi algorithms     ↩  Plouffe's website ↩  ↩  ↩  ↩  D.J. Broadhurst, " Polylogarithmic ladders, hypergeometric series and the ten millionth digits of ζ(3) and ζ(5) ", (1998) arXiv math.CA/9803067 ↩     