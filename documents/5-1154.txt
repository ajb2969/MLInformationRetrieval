   AdaBoost      AdaBoost  '''AdaBoost''', short for "Adaptive [[Boosting (meta-algorithm)|Boosting]]", i s a machine learning  meta-algorithm formulated by Yoav Freund and Robert Schapire who won the prestigious " Gödel Prize " in 2003 for their work. It can be used in conjunction with many other types of learning algorithms to improve their performance. The output of the other learning algorithms ('weak learners') is combined into a weighted sum that represents the final output of the boosted classifier. AdaBoost is adaptive in the sense that subsequent weak learners are tweaked in favor of those instances misclassified by previous classifiers. AdaBoost is sensitive to noisy data and outliers . In some problems, however, it can be less susceptible to the overfitting problem than other learning algorithms. The individual learners can be weak, but as long as the performance of each one is slightly better than random guessing (i.e., their error rate is smaller than 0.5 for binary classification), the final model can be proven to converge to a strong learner.  While every learning algorithm will tend to suit some problem types better than others, and will typically have many different parameters and configurations to be adjusted before achieving optimal performance on a dataset, AdaBoost (with decision trees as the weak learners) is often referred to as the best out-of-the-box classifier. When used with decision tree learning, information gathered at each stage of the AdaBoost algorithm about the relative 'hardness' of each training sample is fed into the tree growing algorithm such that later trees tend to focus on harder to classify examples.  Overview  Problems in machine learning often suffer from the curse of dimensionality — each sample may consist of a huge number of potential features (for instance, there can be 162,336 Haar features , as used by the Viola–Jones object detection framework , in a 24×24 pixel image window), and evaluating every feature can reduce not only the speed of classifier training and execution, but in fact reduce predictive power, per the Hughes Effect . Unlike neural networks and SVMs , the AdaBoost training process selects only those features known to improve the predictive power of the model, reducing dimensionality and potentially improving execution time as irrelevant features do not need to be computed.  Training  AdaBoost refers to a particular method of training a boosted classifier. A boost classifier is a classifier in the form        F  T    (  x  )    =    ∑   t  =  1   T     f  t    (  x  )            subscript  F  T   x     superscript   subscript     t  1    T      subscript  f  t   x      F_{T}(x)=\sum_{t=1}^{T}f_{t}(x)\,\!     where each    f  t     subscript  f  t    f_{t}   is a weak learner that takes an object   x   x   x   as input and returns a real valued result indicating the class of the object. The sign of the weak learner output identifies the predicted object class and the absolute value gives the confidence in that classification. Similarly, the   T   T   T   -layer classifier will be positive if the sample is believed to be in the positive class and negative otherwise.  Each weak learner produces an output, hypothesis    h   (   x  i   )       h   subscript  x  i     h(x_{i})   , for each sample in the training set. At each iteration   t   t   t   , a weak learner is selected and assigned a coefficient    α  t     subscript  α  t    \alpha_{t}   such that the sum training error    E  t     subscript  E  t    E_{t}   of the resulting   t   t   t   -stage boost classifier is minimized.       E  t   =    ∑  i    E   [     F   t  -  1     (   x  i   )    +    α  t   h   (   x  i   )     ]          subscript  E  t     subscript   i     E   delimited-[]       subscript  F    t  1     subscript  x  i       subscript  α  t   h   subscript  x  i          E_{t}=\sum_{i}E[F_{t-1}(x_{i})+\alpha_{t}h(x_{i})]     Here     F   t  -  1     (  x  )        subscript  F    t  1    x    F_{t-1}(x)   is the boosted classifier that has been built up to the previous stage of training,    E   (  F  )       E  F    E(F)   is some error function and      f  t    (  x  )    =    α  t   h   (  x  )           subscript  f  t   x      subscript  α  t   h  x     f_{t}(x)=\alpha_{t}h(x)   is the weak learner that is being considered for addition to the final classifier.  Weighting  At each iteration of the training process, a weight is assigned to each sample in the training set equal to the current error    E   (    F   t  -  1     (   x  i   )    )       E     subscript  F    t  1     subscript  x  i      E(F_{t-1}(x_{i}))   on that sample. These weights can be used to inform the training of the weak learner, for instance, decision trees can be grown that favor splitting sets of samples with high weights.  Derivation  This derivation follows Rojas (2009): 1  Suppose we have a data set    {   (   x  1   ,   y  1   )   ,  …  ,   (   x  N   ,   y  N   )   }       subscript  x  1    subscript  y  1    normal-…    subscript  x  N    subscript  y  N      \{(x_{1},y_{1}),\ldots,(x_{N},y_{N})\}   where each item    x  i     subscript  x  i    x_{i}   has an associated class     y  i   ∈   {   -  1   ,  1  }        subscript  y  i      1   1     y_{i}\in\{-1,1\}   , and a set of weak classifiers    {   k  1   ,  …  ,   k  L   }      subscript  k  1   normal-…   subscript  k  L     \{k_{1},\ldots,k_{L}\}   each of which outputs a classification      k  j    (   x  i   )    ∈   {   -  1   ,  1  }          subscript  k  j    subscript  x  i       1   1     k_{j}(x_{i})\in\{-1,1\}   for each item. After the    m  -  1      m  1    m-1   -th iteration our boosted classifier is a linear combination of the weak classifiers of the form:        C   (   m  -  1   )     (   x  i   )    =     α  1    k  1    (   x  i   )    +  ⋯  +    α   m  -  1     k   m  -  1     (   x  i   )            subscript  C    m  1     subscript  x  i         subscript  α  1    subscript  k  1    subscript  x  i    normal-⋯     subscript  α    m  1     subscript  k    m  1     subscript  x  i       C_{(m-1)}(x_{i})=\alpha_{1}k_{1}(x_{i})+\cdots+\alpha_{m-1}k_{m-1}(x_{i})     At the   m   m   m   -th iteration we want to extend this to a better boosted classifier by adding a multiple of one of the weak classifiers:        C  m    (   x  i   )    =     C   (   m  -  1   )     (   x  i   )    +    α  m    k  m    (   x  i   )            subscript  C  m    subscript  x  i         subscript  C    m  1     subscript  x  i       subscript  α  m    subscript  k  m    subscript  x  i       C_{m}(x_{i})=C_{(m-1)}(x_{i})+\alpha_{m}k_{m}(x_{i})     So it remains to determine which weak classifier is the best choice for    k  m     subscript  k  m    k_{m}   , and what its weight    α  m     subscript  α  m    \alpha_{m}   should be. We define the total error   E   E   E   of    C  m     subscript  C  m    C_{m}   to be the sum of its exponential loss on each data point, given as follows:      E  =    ∑   i  =  1   N    e   -    y  i    C  m    (   x  i   )           E    superscript   subscript     i  1    N    superscript  e       subscript  y  i    subscript  C  m    subscript  x  i         E=\sum_{i=1}^{N}e^{-y_{i}C_{m}(x_{i})}     Letting     w  i   (  1  )    =  1       superscript   subscript  w  i   1   1    w_{i}^{(1)}=1   and     w  i   (  m  )    =   e   -    y  i    C   m  -  1     (   x  i   )           superscript   subscript  w  i   m    superscript  e       subscript  y  i    subscript  C    m  1     subscript  x  i        w_{i}^{(m)}=e^{-y_{i}C_{m-1}(x_{i})}   for    m  >  1      m  1    m>1   , we have:      E  =    ∑   i  =  1   N     w  i   (  m  )     e   -    y  i    α  m    k  m    (   x  i   )            E    superscript   subscript     i  1    N      superscript   subscript  w  i   m    superscript  e       subscript  y  i    subscript  α  m    subscript  k  m    subscript  x  i          E=\sum_{i=1}^{N}w_{i}^{(m)}e^{-y_{i}\alpha_{m}k_{m}(x_{i})}     We can split this summation between those data points that are correctly classified by    k  m     subscript  k  m    k_{m}   (so      y  i    k  m    (   x  i   )    =  1         subscript  y  i    subscript  k  m    subscript  x  i    1    y_{i}k_{m}(x_{i})=1   ) and those which are misclassified (so      y  i    k  m    (   x  i   )    =   -  1          subscript  y  i    subscript  k  m    subscript  x  i      1     y_{i}k_{m}(x_{i})=-1   ):      E  =     ∑    y  i   =    k  m    (   x  i   )        w  i   (  m  )     e   -   α  m       +    ∑    y  i   ≠    k  m    (   x  i   )        w  i   (  m  )     e   α  m       =     ∑   i  =  1   N     w  i   (  m  )     e   -   α  m       +    ∑    y  i   ≠    k  m    (   x  i   )        w  i   (  m  )     (    e   α  m    -   e   -   α  m      )            E      subscript      subscript  y  i      subscript  k  m    subscript  x  i         superscript   subscript  w  i   m    superscript  e     subscript  α  m         subscript      subscript  y  i      subscript  k  m    subscript  x  i         superscript   subscript  w  i   m    superscript  e   subscript  α  m                superscript   subscript     i  1    N      superscript   subscript  w  i   m    superscript  e     subscript  α  m         subscript      subscript  y  i      subscript  k  m    subscript  x  i         superscript   subscript  w  i   m      superscript  e   subscript  α  m     superscript  e     subscript  α  m            E=\sum_{y_{i}=k_{m}(x_{i})}w_{i}^{(m)}e^{-\alpha_{m}}+\sum_{y_{i}\neq k_{m}(x_%
 {i})}w_{i}^{(m)}e^{\alpha_{m}}=\sum_{i=1}^{N}w_{i}^{(m)}e^{-\alpha_{m}}+\sum_{%
 y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}(e^{\alpha_{m}}-e^{-\alpha_{m}})     Since the only part of the right-hand side of this equation that depends on    k  m     subscript  k  m    k_{m}   is     ∑    y  i   ≠    k  m    (   x  i   )       w  i   (  m  )        subscript      subscript  y  i      subscript  k  m    subscript  x  i       superscript   subscript  w  i   m     \sum_{y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}   , we see that the    k  m     subscript  k  m    k_{m}   that minimizes   E   E   E   is the one that minimizes     ∑    y  i   ≠    k  m    (   x  i   )       w  i   (  m  )        subscript      subscript  y  i      subscript  k  m    subscript  x  i       superscript   subscript  w  i   m     \sum_{y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}   , i.e. the weak classifier with the lowest weighted error (with weights     w  i   (  m  )    =   e   -    y  i    C   m  -  1     (   x  i   )           superscript   subscript  w  i   m    superscript  e       subscript  y  i    subscript  C    m  1     subscript  x  i        w_{i}^{(m)}=e^{-y_{i}C_{m-1}(x_{i})}   ).  In order to determine the desired weight    α  m     subscript  α  m    \alpha_{m}   that minimizes   E   E   E   with the    k  m     subscript  k  m    k_{m}   that we just determined, we differentiate:        d  E    d   α  m     =     ∑    y  i   ≠    k  m    (   x  i   )        w  i   (  m  )     e   α  m      -    ∑    y  i   =    k  m    (   x  i   )        w  i   (  m  )     e   -   α  m                d  E     d   subscript  α  m         subscript      subscript  y  i      subscript  k  m    subscript  x  i         superscript   subscript  w  i   m    superscript  e   subscript  α  m        subscript      subscript  y  i      subscript  k  m    subscript  x  i         superscript   subscript  w  i   m    superscript  e     subscript  α  m          \frac{dE}{d\alpha_{m}}=\sum_{y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}e^{\alpha_{m}}-%
 \sum_{y_{i}=k_{m}(x_{i})}w_{i}^{(m)}e^{-\alpha_{m}}     Setting this to zero and solving for    α  m     subscript  α  m    \alpha_{m}   yields:       α  m   =    1  2    ln   (     ∑    y  i   =    k  m    (   x  i   )       w  i   (  m  )       ∑    y  i   ≠    k  m    (   x  i   )       w  i   (  m  )      )          subscript  α  m       1  2         subscript      subscript  y  i      subscript  k  m    subscript  x  i       superscript   subscript  w  i   m      subscript      subscript  y  i      subscript  k  m    subscript  x  i       superscript   subscript  w  i   m         \alpha_{m}=\frac{1}{2}\ln(\frac{\sum_{y_{i}=k_{m}(x_{i})}w_{i}^{(m)}}{\sum_{y_%
 {i}\neq k_{m}(x_{i})}w_{i}^{(m)}})     We calculate the weighted error rate of the weak classifier to be     ϵ  m   =    ∑    y  i   ≠    k  m    (   x  i   )        w  i   (  m  )    /    ∑   i  =  1   N    w  i   (  m  )            subscript  ϵ  m     subscript      subscript  y  i      subscript  k  m    subscript  x  i         superscript   subscript  w  i   m     superscript   subscript     i  1    N    superscript   subscript  w  i   m        \epsilon_{m}=\sum_{y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}/\sum_{i=1}^{N}w_{i}^{(m)}   , so it follows that:       α  m   =    1  2    ln   (    1  -   ϵ  m     ϵ  m    )          subscript  α  m       1  2         1   subscript  ϵ  m     subscript  ϵ  m        \alpha_{m}=\frac{1}{2}\ln(\frac{1-\epsilon_{m}}{\epsilon_{m}})     Thus we have derived the AdaBoost algorithm: At each iteration, choose the classifier    k  m     subscript  k  m    k_{m}   which minimizes the total weighted error     ∑    y  i   ≠    k  m    (   x  i   )       w  i   (  m  )        subscript      subscript  y  i      subscript  k  m    subscript  x  i       superscript   subscript  w  i   m     \sum_{y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}   , use this to calculate the error rate     ϵ  m   =    ∑    y  i   ≠    k  m    (   x  i   )        w  i   (  m  )    /    ∑   i  =  1   N    w  i   (  m  )            subscript  ϵ  m     subscript      subscript  y  i      subscript  k  m    subscript  x  i         superscript   subscript  w  i   m     superscript   subscript     i  1    N    superscript   subscript  w  i   m        \epsilon_{m}=\sum_{y_{i}\neq k_{m}(x_{i})}w_{i}^{(m)}/\sum_{i=1}^{N}w_{i}^{(m)}   , use this to calculate the weight     α  m   =    1  2    ln   (    1  -   ϵ  m     ϵ  m    )          subscript  α  m       1  2         1   subscript  ϵ  m     subscript  ϵ  m        \alpha_{m}=\frac{1}{2}\ln(\frac{1-\epsilon_{m}}{\epsilon_{m}})   , and finally use this to improve the boosted classifier    C   m  -  1      subscript  C    m  1     C_{m-1}   to     C  m   =    C   (   m  -  1   )    +    α  m    k  m          subscript  C  m      subscript  C    m  1       subscript  α  m    subscript  k  m       C_{m}=C_{(m-1)}+\alpha_{m}k_{m}   .  Statistical understanding of boosting  Boosting is a form of linear regression in which the features of each sample    x  i     subscript  x  i    x_{i}   are the outputs of some weak learner   h   h   h   applied to    x  i     subscript  x  i    x_{i}   . Specifically, in the case where all weak learners are known a priori, AdaBoost corresponds to a single iteration of the backfitting algorithm in which the smoothing splines are the minimizers of      ∑   i  =  1   n    e   -    Y  i    μ  ^    (   x  i   )       +   ∞    ∫   x  1    x  n       μ  ^   ′′      (  x  )   2    d  x           superscript   subscript     i  1    n    superscript  e       subscript  Y  i    normal-^  μ    subscript  x  i            superscript   subscript    subscript  x  1     subscript  x  n       superscript   normal-^  μ   ′′    superscript  x  2   d  x       \sum_{i=1}^{n}e^{-Y_{i}\hat{\mu}(x_{i})}+\infty\int_{x_{1}}^{x_{n}}\hat{\mu}^{%
 \prime\prime}(x)^{2}\,dx   , that is     μ  ^   i     subscript   normal-^  μ   i    \hat{\mu}_{i}   fits an exponential cost function and is linear with respect to the observation. Thus, boosting is seen to be a specific type of linear regression.  While regression tries to fit    F   (  x  )       F  x    F(x)   to    y   (  x  )       y  x    y(x)   as precisely as possible without loss of generalization, typically using least square error     E   (  f  )    =    (    y   (  x  )    -   f   (  x  )     )   2         E  f    superscript      y  x     f  x    2     E(f)=(y(x)-f(x))^{2}   , the AdaBoost error function     E   (  f  )    =   e   -   y   (  x  )   f   (  x  )            E  f    superscript  e      y  x  f  x       E(f)=e^{-y(x)f(x)}   takes into account the fact that only the sign of the final result will be used, thus    |   F   (  x  )    |        F  x     |F(x)|   can be far larger than 1 without increasing error. However, the exponential increase in the error for sample    x  i     subscript  x  i    x_{i}   as    -   y   (   x  i   )   f   (   x  i   )          y   subscript  x  i   f   subscript  x  i      -y(x_{i})f(x_{i})   increases results in excessive weight being assigned to outliers.  One feature of the choice of exponential error function is that the error of the final additive model is the product of the error of each stage, that is,     e     ∑  i    -    y  i   f   (   x  i   )      =    ∏  i    e   -    y  i   f   (   x  i   )            superscript  e     subscript   i      subscript  y  i   f   subscript  x  i        subscript  product  i    superscript  e       subscript  y  i   f   subscript  x  i         e^{\sum_{i}-y_{i}f(x_{i})}=\prod_{i}e^{-y_{i}f(x_{i})}   . Thus it can be seen that the weight update in the AdaBoost algorithm is equivalent to recalculating the error on     F  t    (  x  )        subscript  F  t   x    F_{t}(x)   after each stage.  There is a lot of flexibility allowed in the choice of loss function. As long as the loss function is monotonic and continuously differentiable , the classifier will always be driven toward purer solutions. 2 Zhang (2004) provides a loss function based on least squares, a modified Huber loss function :       ϕ   (  y  ,   f   (  x  )    )    =   {      -   4  y  f   (  x  )          if  y  f   (  x  )    <   -  1    ,         (    y  f   (  x  )    -  1   )   2        if  -  1   ≤   y  f   (  x  )    ≤  1   ,       0      if  y  f   (  x  )    >  1             ϕ   y    f  x      cases      4  y  f  x        if  y  f  x     1     superscript      y  f  x   1   2         if  1     y  f  x        1    0      if  y  f  x   1      \phi(y,f(x))=\begin{cases}-4yf(x)&\mbox{if }yf(x)<-1,\\
 (yf(x)-1)^{2}&\mbox{if }-1\leq yf(x)\leq 1,\\
 0&\mbox{if }yf(x)>1\end{cases}     This function is more well-behaved than LogitBoost for    f   (  x  )       f  x    f(x)   close to 1 or -1, does not penalise ‘overconfident’ predictions (     y  f   (  x  )    >  1        y  f  x   1    yf(x)>1   ), unlike unmodified least squares, and only penalises samples misclassified with confidence greater than 1 linearly, as opposed to quadratically or exponentially, and is thus less susceptible to the effects of outliers.  Boosting as Gradient Descent  Boosting can be seen as minimization of a convex loss function over a convex set of functions. 3 Specifically, the loss being minimized by AdaBoost is the exponential loss      ∑  i    ϕ   (  i  ,  y  ,  f  )     =    ∑  i    e   -    y  i   f   (   x  i   )             subscript   i     ϕ   i  y  f       subscript   i    superscript  e       subscript  y  i   f   subscript  x  i         \sum_{i}\phi(i,y,f)=\sum_{i}e^{-y_{i}f(x_{i})}   , whereas LogitBoost performs logistic regression, minimizing      ∑  i    ϕ   (  i  ,  y  ,  f  )     =    ∑  i    ln   (   1  +   e   -    y  i   f   (   x  i   )       )           subscript   i     ϕ   i  y  f       subscript   i       1   superscript  e       subscript  y  i   f   subscript  x  i           \sum_{i}\phi(i,y,f)=\sum_{i}\ln\left(1+e^{-y_{i}f(x_{i})}\right)   .  In the gradient descent analogy, the output of the classifier for each training point is considered to be a point    (    F  t    (   x  1   )    ,  …  ,    F  t    (   x  n   )    )        subscript  F  t    subscript  x  1    normal-…     subscript  F  t    subscript  x  n      \left(F_{t}(x_{1}),\dots,F_{t}(x_{n})\right)   in n-dimensional space, where each axis corresponds to a training sample, each weak learner    h   (  x  )       h  x    h(x)   corresponds to a vector of fixed orientation and length, and the goal is to reach the target point    (   y  1   ,  …  ,   y  n   )      subscript  y  1   normal-…   subscript  y  n     (y_{1},\dots,y_{n})   (or any region where the value of loss function     E  T    (   x  1   ,  …  ,   x  n   )        subscript  E  T     subscript  x  1   normal-…   subscript  x  n      E_{T}(x_{1},\dots,x_{n})   is less than the value at that point), in the least number of steps. Thus AdaBoost algorithms perform either Cauchy (find    h   (  x  )       h  x    h(x)   with the steepest gradient, choose   α   α   \alpha   to minimize test error) or Newton (choose some target point, find    α  h   (  x  )       α  h  x    \alpha h(x)   that will bring    F  t     subscript  F  t    F_{t}   closest to that point) optimization of training error.  Example Algorithm (Discrete AdaBoost)  With:   Samples     x  1   …   x  n        subscript  x  1   normal-…   subscript  x  n     x_{1}\dots x_{n}     Desired outputs       y  1   …   y  n    ,  y   ∈   {   -  1   ,  1  }           subscript  y  1   normal-…   subscript  y  n    y      1   1     y_{1}\dots y_{n},y\in\{-1,1\}     Initial weights     w   1  ,  1    …   w   n  ,  1         subscript  w   1  1    normal-…   subscript  w   n  1      w_{1,1}\dots w_{n,1}   set to    1  n      1  n    \frac{1}{n}     Error function     E   (   f   (  x  )    ,  y  ,  i  )    =   e   -    y  i   f   (   x  i   )            E     f  x   y  i     superscript  e       subscript  y  i   f   subscript  x  i        E(f(x),y,i)=e^{-y_{i}f(x_{i})}     Weak learners    h  :   x  →   [   -  1   ,  1  ]       normal-:  h   normal-→  x     1   1      h\colon x\rightarrow[-1,1]      For   t   t   t   in    1  …  T      1  normal-…  T    1\dots T   :   Choose     f  t    (  x  )        subscript  f  t   x    f_{t}(x)   :  Find weak learner     h  t    (  x  )        subscript  h  t   x    h_{t}(x)   that minimizes    ϵ  t     subscript  ϵ  t    \epsilon_{t}   , the weighted sum error for misclassified points     ϵ  t   =    ∑  i     w   i  ,  t    E   (    h  t    (  x  )    ,  y  ,  i  )          subscript  ϵ  t     subscript   i      subscript  w   i  t    E      subscript  h  t   x   y  i       \epsilon_{t}=\sum_{i}w_{i,t}E(h_{t}(x),y,i)     Choose     α  t   =    1  2    ln   (    1  -   ϵ  t     ϵ  t    )          subscript  α  t       1  2         1   subscript  ϵ  t     subscript  ϵ  t        \alpha_{t}=\frac{1}{2}\ln\left(\frac{1-\epsilon_{t}}{\epsilon_{t}}\right)      Add to ensemble:        F  t    (  x  )    =     F   t  -  1     (  x  )    +    α  t    h  t    (  x  )            subscript  F  t   x        subscript  F    t  1    x      subscript  α  t    subscript  h  t   x      F_{t}(x)=F_{t-1}(x)+\alpha_{t}h_{t}(x)      Update weights:       w   i  ,   t  +  1     =    w   i  ,  t     e   -    y  i    α  t    h  t    (   x  i   )            subscript  w   i    t  1        subscript  w   i  t     superscript  e       subscript  y  i    subscript  α  t    subscript  h  t    subscript  x  i         w_{i,t+1}=w_{i,t}e^{-y_{i}\alpha_{t}h_{t}(x_{i})}   for all i  Renormalize    w   i  ,   t  +  1       subscript  w   i    t  1      w_{i,t+1}   such that      ∑  i    w   i  ,   t  +  1      =  1        subscript   i    subscript  w   i    t  1      1    \sum_{i}w_{i,t+1}=1     (Note: It can be shown that        ∑     h   t  +  1     (   x  i   )    =   y  i       w   i  ,   t  +  1         ∑     h   t  +  1     (   x  i   )    ≠   y  i       w   i  ,   t  +  1       =      ∑     h  t    (   x  i   )    =   y  i       w   i  ,  t        ∑     h  t    (   x  i   )    ≠   y  i       w   i  ,  t              subscript        subscript  h    t  1     subscript  x  i     subscript  y  i      subscript  w   i    t  1        subscript        subscript  h    t  1     subscript  x  i     subscript  y  i      subscript  w   i    t  1           subscript        subscript  h  t    subscript  x  i     subscript  y  i      subscript  w   i  t       subscript        subscript  h  t    subscript  x  i     subscript  y  i      subscript  w   i  t        \frac{\sum_{h_{t+1}(x_{i})=y_{i}}w_{i,t+1}}{\sum_{h_{t+1}(x_{i})\neq y_{i}}w_{%
 i,t+1}}=\frac{\sum_{h_{t}(x_{i})=y_{i}}w_{i,t}}{\sum_{h_{t}(x_{i})\neq y_{i}}w%
 _{i,t}}   at every step, which can simplify the calculation of the new weights.)    Choosing    α  t     subscript  α  t    \alpha_{t}         α  t     subscript  α  t    \alpha_{t}   is chosen as it can be analytically shown to be the minimizer of the exponential error function for Discrete AdaBoost. 4  Minimize:       ∑  i     w  i    e   -    y  i    h  i    α  t           subscript   i      subscript  w  i    superscript  e       subscript  y  i    subscript  h  i    subscript  α  t         \sum_{i}w_{i}e^{-y_{i}h_{i}\alpha_{t}}     Using the convexity of the exponential function, and assuming that      ∀  i   ,   h  i    ∈   [   -  1   ,  1  ]         for-all  i    subscript  h  i       1   1     \forall i,h_{i}\in[-1,1]   we have:           ∑  i      w  i    e   -    y  i    h  i    α  t            ≤      ∑  i      (     1  -    y  i    h  i     2    )    w  i    e   α  t      +     ∑  i      (     1  +    y  i    h  i     2    )    w  i    e   -   α  t                =     (     1  +   ϵ  t    2    )    e   α  t     +    (     1  -   ϵ  t    2    )    e   -   α  t                subscript   i      subscript  w  i    superscript  e       subscript  y  i    subscript  h  i    subscript  α  t          absent      subscript   i         1     subscript  y  i    subscript  h  i     2    subscript  w  i    superscript  e   subscript  α  t        subscript   i         1     subscript  y  i    subscript  h  i     2    subscript  w  i    superscript  e     subscript  α  t            missing-subexpression     absent          1   subscript  ϵ  t    2    superscript  e   subscript  α  t           1   subscript  ϵ  t    2    superscript  e     subscript  α  t           \begin{aligned}\displaystyle\sum_{i}w_{i}e^{-y_{i}h_{i}\alpha_{t}}&%
 \displaystyle\leq\sum_{i}\left(\frac{1-y_{i}h_{i}}{2}\right)w_{i}e^{\alpha_{t}%
 }+\sum_{i}\left(\frac{1+y_{i}h_{i}}{2}\right)w_{i}e^{-\alpha_{t}}\\
 &\displaystyle=\left(\frac{1+\epsilon_{t}}{2}\right)e^{\alpha_{t}}+\left(\frac%
 {1-\epsilon_{t}}{2}\right)e^{-\alpha_{t}}\end{aligned}     We then differentiate that expression with respect to    α  t     subscript  α  t    \alpha_{t}   and set it to zero to find the minimum of the upper bound:           (     1  +   ϵ  t    2    )    e   α  t     -    (     1  -   ϵ  t    2    )    e   -   α  t           =  0        α  t       =     1  2     ln   (     1  -   ϵ  t     1  +   ϵ  t      )                    1   subscript  ϵ  t    2    superscript  e   subscript  α  t           1   subscript  ϵ  t    2    superscript  e     subscript  α  t         absent  0      subscript  α  t     absent      1  2         1   subscript  ϵ  t      1   subscript  ϵ  t           \begin{aligned}\displaystyle\left(\frac{1+\epsilon_{t}}{2}\right)e^{\alpha_{t}%
 }-\left(\frac{1-\epsilon_{t}}{2}\right)e^{-\alpha_{t}}&\displaystyle=0\\
 \displaystyle\alpha_{t}&\displaystyle=\frac{1}{2}\ln\left(\frac{1-\epsilon_{t}%
 }{1+\epsilon_{t}}\right)\end{aligned}     Note that this only applies when     h  i   ∈   {   -  1   ,  1  }        subscript  h  i      1   1     h_{i}\in\{-1,1\}   , though it can be a good starting guess in other cases, such as when the weak learner is biased (      h   (  x  )    ∈   {  a  ,  b  }    ,   a  ≠   -  b       formulae-sequence      h  x    a  b      a    b      h(x)\in\{a,b\},a\neq-b   ), has multiple leaves (     h   (  x  )    ∈   {  a  ,  b  ,  …  ,  n  }         h  x    a  b  normal-…  n     h(x)\in\{a,b,\dots,n\}   ) or is some other function     h   (  x  )    ∈  ℝ        h  x   ℝ    h(x)\in\mathbb{R}   . In such cases the choice of weak learner and coefficient can be condensed to a single step in which     f  t   =    α  t    h  t    (  x  )         subscript  f  t      subscript  α  t    subscript  h  t   x     f_{t}=\alpha_{t}h_{t}(x)   is chosen from all possible    α  ,  h     α  h    \alpha,h   as the minimizer of     ∑  i     w   i  ,  t     e   -    y  i    f  t    (   x  i   )           subscript   i      subscript  w   i  t     superscript  e       subscript  y  i    subscript  f  t    subscript  x  i         \sum_{i}w_{i,t}e^{-y_{i}f_{t}(x_{i})}   by some numerical searching routine.  Variants  Real AdaBoost  The output of decision trees is a class probability estimate    p   (  x  )   =  P   (  y  =  1  |  x  )      fragments  p   fragments  normal-(  x  normal-)    P   fragments  normal-(  y   1  normal-|  x  normal-)     p(x)=P(y=1|x)   , the probability that   x   x   x   is in the positive class. 5 Friedman, Hastie and Tibshirani derive an analytical minimizer for    e   -   y   (     F   t  -  1     (  x  )    +    f  t    (   p   (  x  )    )     )        superscript  e      y       subscript  F    t  1    x      subscript  f  t     p  x         e^{-y\left(F_{t-1}(x)+f_{t}(p(x))\right)}   for some fixed    p   (  x  )       p  x    p(x)   (typically chosen using weighted least squares error):        f  t    (  x  )    =    1  2    ln   (   x   1  -  x    )            subscript  f  t   x       1  2       x    1  x        f_{t}(x)=\frac{1}{2}\ln\left(\frac{x}{1-x}\right)   . Thus, rather than multiplying the output of the entire tree by some fixed value, each leaf node is changed to output half the logit transform of its previous value.  LogitBoost  LogitBoost represents an application of established logistic regression techniques to the AdaBoost method. Rather than minimizing error with respect to y, weak learners are chosen to minimize the (weighted least-squares) error of     f  t    (  x  )        subscript  f  t   x    f_{t}(x)   with respect to       z  t   =     y  *   -    p  t    (  x  )      2   p  t    (  x  )    (   1  -    p  t    (  x  )     )          subscript  z  t        superscript  y       subscript  p  t   x      2   subscript  p  t   x    1     subscript  p  t   x        z_{t}=\frac{y^{*}-p_{t}(x)}{2p_{t}(x)(1-p_{t}(x))}   , where      p  t    (  x  )    =    e    F   t  -  1     (  x  )       e    F   t  -  1     (  x  )     +   e   -    F   t  -  1     (  x  )               subscript  p  t   x      superscript  e     subscript  F    t  1    x       superscript  e     subscript  F    t  1    x     superscript  e       subscript  F    t  1    x         p_{t}(x)=\frac{e^{F_{t-1}(x)}}{e^{F_{t-1}(x)}+e^{-F_{t-1}(x)}}   ,     w  t   =    p  t    (  x  )    (   1  -    p  t    (  x  )     )         subscript  w  t      subscript  p  t   x    1     subscript  p  t   x       w_{t}=p_{t}(x)(1-p_{t}(x))   and     y  *   =    y  +  1   2        superscript  y        y  1   2     y^{*}=\frac{y+1}{2}   .  That is    z  t     subscript  z  t    z_{t}   is the Newton-Raphson approximation of the minimizer of the log-likelihood error at stage   t   t   t   , and the weak learner    f  t     subscript  f  t    f_{t}   is chosen as the learner that best approximates    z  t     subscript  z  t    z_{t}   by weighted least squares.  As p approaches either 1 or 0, the value of     p  t    (   x  i   )    (   1  -    p  t    (   x  i   )     )        subscript  p  t    subscript  x  i     1     subscript  p  t    subscript  x  i       p_{t}(x_{i})(1-p_{t}(x_{i}))   becomes very small and the z term, which will be large for misclassified samples, can become numerically unstable , due to machine precision rounding errors. This can be overcome by enforcing some limit on the absolute value of z and the minimum value of w.  Gentle AdaBoost  While previous boosting algorithms choose    f  t     subscript  f  t    f_{t}   greedily, minimizing the overall test error as much as possible at each step GentleBoost features a bounded step size.    f  t     subscript  f  t    f_{t}   is chosen to minimize     ∑  i     w   t  ,  i      (    y  i   -    f  t    (   x  i   )     )   2        subscript   i      subscript  w   t  i     superscript     subscript  y  i      subscript  f  t    subscript  x  i     2      \sum_{i}w_{t,i}(y_{i}-f_{t}(x_{i}))^{2}   , and no further coefficient is applied. Thus, in the case where a weak learner exhibits perfect classification performance, GentleBoost will choose      f  t    (  x  )    =    α  t    h  t    (  x  )           subscript  f  t   x      subscript  α  t    subscript  h  t   x     f_{t}(x)=\alpha_{t}h_{t}(x)   exactly equal to   y   y   y   , while steepest descent algorithms will try to set     α  t   =  ∞       subscript  α  t      \alpha_{t}=\infty   . Empirical observations about the good performance of GentleBoost appear to back up Schapire and Singer's remark that allowing excessively large values of   α   α   \alpha   can lead to poor generalization performance. 6 7  Early Termination  A technique for speeding up processing of boosted classifiers, early termination refers to only testing each potential object with as many layers of the final classifier necessary to meet some confidence threshold, speeding up computation for cases where the class of the object can easily be determined. One such scheme is the object detection framework introduced by Viola and Jones: 8 in an application with significantly more negative samples than positive, a cascade of separate boost classifiers is trained, the output of each stage biased such that some acceptably small fraction of positive samples is mislabeled as negative, and all samples marked as negative after each stage are discarded. If 50% of negative samples are filtered out by each stage, only a very small number of objects would pass through the entire classifier, reducing computation effort. This method has since been generalized, with a formula provided for choosing optimal thresholds at each stage to achieve some desired false positive and false negative rate. 9  In the field of statistics, where AdaBoost is more commonly applied to problems of moderate dimensionality, early stopping is used as a strategy to reduce overfitting . 10 A validation set of samples is separated from the training set, performance of the classifier on the samples used for training is compared to performance on the validation samples, and training is terminated if performance on the validation sample is seen to decrease even as performance on the training set continues to improve.  Totally Corrective Algorithms  For steepest descent versions of AdaBoost, where    α  t     subscript  α  t    \alpha_{t}   is chosen at each layer t to minimize test error, the next layer added is said to be maximally independent of layer t : 11 it is unlikely that a weak learner t+1 will be chosen that is similar to learner t . However, there remains the possibility that t+1 produces similar information to some other earlier layer. Totally corrective algorithms, such as LPBoost , optimize the value of every coefficient after each step, such that new layers added are always maximally independent of every previous layer. This can be accomplished by backfitting, linear programming or some other method.  Pruning  Pruning refers to the process of removing poorly performing weak classifiers, in order to improve the memory and execution-time cost of the boosted classifier. The simplest methods, which can be particularly effective in conjunction with totally corrective training, are weight- or margin-trimming: when the coefficient, or the contribution to the total test error, of some weak classifier falls below a certain threshold, that classifier is dropped. Margineantu & Dietterich 12 suggest an alternative criteria for trimming: weak classifiers should be selected such that the diversity of the ensemble is maximized. If two weak learners produce very similar outputs, efficiency can be improved by removing one of them and increasing the coefficient of the remaining weak learner. 13  See also   Bootstrap aggregating  CoBoosting  BrownBoost  Gradient boosting   References  Implementations   AdaBoost and the Super Bowl of Classifiers - A Tutorial on AdaBoost.  AdaBoost in C++ , an implementation of AdaBoost in C++ and boost by Antonio Gulli  icsiboost , an open source implementation of Boostexter  JBoost , a site offering a classification and visualization package, implementing AdaBoost among other boosting algorithms.  MATLAB AdaBoost toolbox. Includes Real AdaBoost, Gentle AdaBoost and Modest AdaBoost implementations.  [ http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=21317&objectType; ;=file A Matlab Implementation of AdaBoost]  Multi-threaded MATLAB-compatible implementation of Boosted Trees  milk for Python implements AdaBoost .  MPBoost++ , a C++ implementation of the original AdaBoost.MH algorithm and of an improved variant, the MPBoost algorithm.  multiboost , a fast C++ implementation of multi-class/multi-label/multi-task boosting algorithms. It is based on AdaBoost.MH but also implements popular cascade classifiers and FilterBoost along with a batch of common multi-class base learners (stumps, trees, products, Haar filters).  NPatternRecognizer , a fast machine learning algorithm library written in C#. It contains support vector machine, neural networks, bayes, boost, k-nearest neighbor, decision tree, ..., etc.  OpenCV implementation of several boosting variants  Into contains open source implementations of many AdaBoost and FloatBoost variants in C++.  Mallet Java implementation.  adabag adabag: An R package for binary and multiclass Boosting and Bagging.  Scikit-learn Python implementation.  fertilized forests A general purpose, platform independent, easy to extend decision forest library that supports boosted training based on multiclass AdaBoost.M2, Samme and Samme.R   External links    original paper of Yoav Freund and Robert E.Schapire where AdaBoost is first introduced.   a site on boosting and related ensemble learning methods   presentation summarizing AdaBoost (see page 4 for an illustrated example of performance).   presentation showing an AdaBoost example.   introduction to AdaBoost    a tutorial article on ensemble systems including pseudocode, block diagrams and implementation issues for AdaBoost and other ensemble learning algorithms.   "  Category:Classification algorithms  Category:Ensemble learning     Rojas, R. (2009). AdaBoost and the super bowl of classifiers a tutorial introduction to adaptive boosting. Freie University, Berlin, Tech. Rep. ↩   T. Zhang, "Statistical behavior and consistency of classification methods based on convex risk minimization", Annals of Statistics 32 (1), pp. 56-85, 2004. ↩  ↩  ↩   ↩  ↩  ↩  ↩  ↩  ↩  ↩     