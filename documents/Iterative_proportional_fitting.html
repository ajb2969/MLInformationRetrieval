<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="697">Iterative proportional fitting</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Iterative proportional fitting</h1>
<hr/>

<p>The <strong>iterative proportional fitting procedure</strong> (<strong>IPFP</strong>, also known as <strong>biproportional fitting</strong> in statistics, <strong>RAS algorithm</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in economics and <strong>matrix raking</strong> or <strong>matrix scaling</strong> in computer science) is an <a href="iterative_algorithm" title="wikilink">iterative algorithm</a> for estimating cell values of a <a href="contingency_table" title="wikilink">contingency table</a> such that the marginal totals remain fixed and the estimated table decomposes into an <a href="outer_product" title="wikilink">outer product</a>.</p>

<p>First introduced by <a href="W._Edwards_Deming" title="wikilink">Deming</a> and Stephan in 1940<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> (they proposed IPFP as an algorithm leading to a minimizer of the <a href="Pearson_X-squared_statistic" title="wikilink">Pearson X-squared statistic</a>, which it <em>does not</em>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and even failed to prove convergence), it has seen various extensions and related research. A rigorous proof of convergence by means of <a href="differential_geometry" title="wikilink">differential geometry</a> is due to <a href="Stephen_Fienberg" title="wikilink">Fienberg</a> (1970).<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> He interpreted the family of contingency tables of constant crossproduct ratios as a particular (<em>IJ</em> − 1)-dimensional manifold of constant interaction and showed that the IPFP is a fixed-point iteration on that manifold. Nevertheless, he assumed strictly positive observations. Generalization to tables with zero entries is still considered a hard and only partly solved problem.</p>

<p>An exhaustive treatment of the algorithm and its mathematical foundations can be found in the book of Bishop et al. (1975).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The first general proof of convergence, built on non-trivial measure theoretic theorems and entropy minimization, is due to Csiszár (1975).<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Relatively new results on convergence and error behavior have been published by Pukelsheim and Simeone (2009) .<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> They proved simple necessary and sufficient conditions for the convergence of the IPFP for arbitrary two-way tables (i.e. tables with zero entries) by analysing an 

<math display="inline" id="Iterative_proportional_fitting:0">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}
  </annotation>
 </semantics>
</math>

-error function.</p>

<p>Other general algorithms can be modified to yield the same limit as the IPFP, for instance the <a href="Newton–Raphson_method" title="wikilink">Newton–Raphson method</a> and the <a href="EM_algorithm" title="wikilink">EM algorithm</a>. In most cases, IPFP is preferred due to its computational speed, numerical stability and algebraic simplicity.</p>
<h2 id="algorithm-1-classical-ipfp">Algorithm 1 (classical IPFP)</h2>

<p>Given a two-way (<em>I</em> × <em>J</em>)-table of counts 

<math display="inline" id="Iterative_proportional_fitting:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{ij})
  </annotation>
 </semantics>
</math>

, where the cell values are assumed to be Poisson or multinomially distributed, we wish to estimate a decomposition 

<math display="inline" id="Iterative_proportional_fitting:2">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>b</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{m}_{ij}=a_{i}b_{j}
  </annotation>
 </semantics>
</math>

 for all <em>i</em> and <em>j</em> such that 

<math display="inline" id="Iterative_proportional_fitting:3">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\hat{m}_{ij})
  </annotation>
 </semantics>
</math>


 is the <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> estimate (MLE) of the expected values 

<math display="inline" id="Iterative_proportional_fitting:4">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>m</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m_{ij})
  </annotation>
 </semantics>
</math>

 leaving the marginals 

<math display="inline" id="Iterative_proportional_fitting:5">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>j</mi>
    </msub>
    <mpadded width="+1.7pt">
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <ci>i</ci>
      <plus></plus>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x_{i+}=\sum_{j}x_{ij}\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Iterative_proportional_fitting:6">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mo>+</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mpadded width="+1.7pt">
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x_{+j}=\sum_{i}x_{ij}\,
  </annotation>
 </semantics>
</math>

 fixed. The assumption that the table factorizes in such a manner is known as the <em>model of independence</em> (I-model). Written in terms of a <a href="log-linear_model" title="wikilink">log-linear model</a>, we can write this assumption as 

<math display="inline" id="Iterative_proportional_fitting:7">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>log</mi>
    </mpadded>
    <msub>
     <mi>m</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>u</mi>
    <mo>+</mo>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>w</mi>
     <mi>j</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>z</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <log></log>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log\ m_{ij}=u+v_{i}+w_{j}+z_{ij}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Iterative_proportional_fitting:8">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mi>𝔼</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>𝔼</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{ij}:=\mathbb{E}(x_{ij})
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Iterative_proportional_fitting:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>j</mi>
    </msub>
    <msub>
     <mi>w</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}v_{i}=\sum_{j}w_{j}=0
  </annotation>
 </semantics>
</math>

 and the interaction term vanishes, that is 

<math display="inline" id="Iterative_proportional_fitting:10">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{ij}=0
  </annotation>
 </semantics>
</math>

 for all <em>i</em> and <em>j</em>.</p>

<p>Choose initial values 

<math display="inline" id="Iterative_proportional_fitting:11">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>:=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{m}_{ij}^{(0)}:=1
  </annotation>
 </semantics>
</math>

 (different choices of initial values may lead to changes in convergence behavior), and for 

<math display="inline" id="Iterative_proportional_fitting:12">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>η</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta\geq 1
  </annotation>
 </semantics>
</math>

 set</p>

<p>

<math display="block" id="Iterative_proportional_fitting:13">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>η</mi>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mover accent="true">
       <mi>m</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>η</mi>
        </mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>J</mi>
     </msubsup>
     <msubsup>
      <mover accent="true">
       <mi>m</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mrow>
       <mi>i</mi>
       <mi>k</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>η</mi>
        </mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>η</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>η</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <csymbol cd="latexml">limit-from</csymbol>
        <ci>i</ci>
        <plus></plus>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>J</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>η</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{m}_{ij}^{(2\eta-1)}=\frac{\hat{m}_{ij}^{(2\eta-2)}x_{i+}}{\sum_{k=1}^{J}%
\hat{m}_{ik}^{(2\eta-2)}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Iterative_proportional_fitting:14">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mover accent="true">
      <mi>m</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>η</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msubsup>
       <mover accent="true">
        <mi>m</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mn>2</mn>
          <mi>η</mi>
         </mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <msub>
       <mi>x</mi>
       <mrow>
        <mo>+</mo>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>I</mi>
      </msubsup>
      <msubsup>
       <mover accent="true">
        <mi>m</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mrow>
        <mi>k</mi>
        <mi>j</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mn>2</mn>
          <mi>η</mi>
         </mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>η</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>η</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>I</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>η</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{m}_{ij}^{(2\eta)}=\frac{\hat{m}_{ij}^{(2\eta-1)}x_{+j}}{\sum_{k=1}^{I}%
\hat{m}_{kj}^{(2\eta-1)}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Notes:</p>
<ul>
<li>Convergence does not depend on the actual distribution. Distributional assumptions are necessary for inferring that the limit 

<math display="inline" id="Iterative_proportional_fitting:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mover accent="true">
      <mi>m</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>η</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mover accent="true">
       <mi>m</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>η</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>η</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>m</ci>
       </apply>
       <ci>η</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\hat{m}_{ij}):=\lim_{\eta\rightarrow\infty}(\hat{m}^{(\eta)}_{ij})
  </annotation>
 </semantics>
</math>

 is an MLE indeed.</li>
</ul>
<ul>
<li>IPFP can be manipulated to generate any positive marginals be replacing 

<math display="inline" id="Iterative_proportional_fitting:16">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">limit-from</csymbol>
     <ci>i</ci>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i+}
  </annotation>
 </semantics>
</math>

 by the desired row marginal 

<math display="inline" id="Iterative_proportional_fitting:17">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}
  </annotation>
 </semantics>
</math>

 (analogously for the column marginals).</li>
</ul>
<ul>
<li>IPFP can be extended to fit the <em>model of quasi-independence</em> (Q-model), where 

<math display="inline" id="Iterative_proportional_fitting:18">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{ij}=0
  </annotation>
 </semantics>
</math>


 is known a priori for 

<math display="inline" id="Iterative_proportional_fitting:19">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,j)\in S
  </annotation>
 </semantics>
</math>

. Only the initial values have to be changed: Set 

<math display="inline" id="Iterative_proportional_fitting:20">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{m}_{ij}^{(0)}=0
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Iterative_proportional_fitting:21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,j)\in S
  </annotation>
 </semantics>
</math>

 and 1 otherwise.</li>
</ul>
<h2 id="algorithm-2-factor-estimation">Algorithm 2 (factor estimation)</h2>

<p>Assume the same setting as in the classical IPFP. Alternatively, we can estimate the row and column factors separately: Choose initial values 

<math display="inline" id="Iterative_proportional_fitting:22">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>b</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>j</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>:=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>b</ci>
      </apply>
      <ci>j</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{b}_{j}^{(0)}:=1
  </annotation>
 </semantics>
</math>

, and for 

<math display="inline" id="Iterative_proportional_fitting:23">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>η</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta\geq 1
  </annotation>
 </semantics>
</math>


 set</p>

<p>

<math display="block" id="Iterative_proportional_fitting:24">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>i</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>η</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mfrac>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
      </mrow>
     </msub>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>j</mi>
      </msub>
      <msubsup>
       <mover accent="true">
        <mi>b</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>j</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>η</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>a</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>η</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">limit-from</csymbol>
       <ci>i</ci>
       <plus></plus>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>b</ci>
        </apply>
        <ci>j</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>η</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{a}_{i}^{(\eta)}=\frac{x_{i+}}{\sum_{j}\hat{b}_{j}^{(\eta-1)}},
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Iterative_proportional_fitting:25">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>b</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>j</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>η</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>x</mi>
     <mrow>
      <mo>+</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>i</mi>
     </msub>
     <msubsup>
      <mover accent="true">
       <mi>a</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>i</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>η</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>b</ci>
      </apply>
      <ci>j</ci>
     </apply>
     <ci>η</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>a</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <ci>η</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{b}_{j}^{(\eta)}=\frac{x_{+j}}{\sum_{i}\hat{a}_{i}^{(\eta)}}
  </annotation>
 </semantics>
</math>

</p>

<p>Setting 

<math display="inline" id="Iterative_proportional_fitting:26">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mi>η</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>i</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>η</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <msubsup>
     <mover accent="true">
      <mi>b</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>j</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>η</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>η</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>a</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>η</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>b</ci>
       </apply>
       <ci>j</ci>
      </apply>
      <ci>η</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{m}_{ij}^{(2\eta)}=\hat{a}_{i}^{(\eta)}\hat{b}_{j}^{(\eta)}
  </annotation>
 </semantics>
</math>

, the two variants of the algorithm are mathematically equivalent (can be seen by formal induction).</p>

<p>Notes:</p>
<ul>
<li>In matrix notation, we can write 

<math display="inline" id="Iterative_proportional_fitting:27">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mover accent="true">
      <mi>m</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>a</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <msup>
     <mover accent="true">
      <mi>b</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>b</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\hat{m}_{ij})=\hat{a}\hat{b}^{T}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Iterative_proportional_fitting:28">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>a</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mover accent="true">
       <mi>a</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mi>a</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>I</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>T</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>η</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <msup>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>η</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-^</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>a</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>a</ci>
        </apply>
        <ci>I</ci>
       </apply>
      </vector>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <limit></limit>
       <apply>
        <ci>normal-→</ci>
        <ci>η</ci>
        <infinity></infinity>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>a</ci>
       </apply>
       <ci>η</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{a}=(\hat{a}_{1},\ldots,\hat{a}_{I})^{T}=\lim_{\eta\rightarrow\infty}\hat{%
a}^{(\eta)}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Iterative_proportional_fitting:29">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>b</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mover accent="true">
       <mi>b</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mi>b</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>J</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>T</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>η</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <msup>
     <mover accent="true">
      <mi>b</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>η</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-^</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>b</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>b</ci>
        </apply>
        <ci>J</ci>
       </apply>
      </vector>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <limit></limit>
       <apply>
        <ci>normal-→</ci>
        <ci>η</ci>
        <infinity></infinity>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>b</ci>
       </apply>
       <ci>η</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{b}=(\hat{b}_{1},\ldots,\hat{b}_{J})^{T}=\lim_{\eta\rightarrow\infty}\hat{%
b}^{(\eta)}
  </annotation>
 </semantics>
</math>

.</li>
<li>The factorization is not unique, since it is 

<math display="inline" id="Iterative_proportional_fitting:30">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>b</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>γ</mi>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mi>γ</mi>
      </mfrac>
      <msub>
       <mi>b</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>γ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>γ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{ij}=a_{i}b_{j}=(\gamma a_{i})(\frac{1}{\gamma}b_{j})
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Iterative_proportional_fitting:31">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>γ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma>0
  </annotation>
 </semantics>
</math>

.</li>
<li>The factor totals remain constant, i.e. 

<math display="inline" id="Iterative_proportional_fitting:32">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <msubsup>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>i</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>η</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <msubsup>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>i</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>a</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>η</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>a</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}\hat{a}_{i}^{(\eta)}=\sum_{i}\hat{a}_{i}^{(1)}
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Iterative_proportional_fitting:33">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>η</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta\geq 1
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Iterative_proportional_fitting:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>j</mi>
    </msub>
    <msubsup>
     <mover accent="true">
      <mi>b</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>j</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>η</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>j</mi>
    </msub>
    <msubsup>
     <mover accent="true">
      <mi>b</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>j</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>b</ci>
       </apply>
       <ci>j</ci>
      </apply>
      <ci>η</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>b</ci>
       </apply>
       <ci>j</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j}\hat{b}_{j}^{(\eta)}=\sum_{j}\hat{b}_{j}^{(0)}
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Iterative_proportional_fitting:35">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>η</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta\geq 0
  </annotation>
 </semantics>
</math>

.</li>
<li>To fit the Q-model, where 

<math display="inline" id="Iterative_proportional_fitting:36">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{ij}=0
  </annotation>
 </semantics>
</math>

 a priori for 

<math display="inline" id="Iterative_proportional_fitting:37">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,j)\in S
  </annotation>
 </semantics>
</math>

, set 

<math display="inline" id="Iterative_proportional_fitting:38">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{ij}=0
  </annotation>
 </semantics>
</math>


 if (

<math display="inline" id="Iterative_proportional_fitting:39">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
   <mo stretchy="false">)</mo>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">j</csymbol>
    <ci>normal-)</ci>
    <in></in>
    <csymbol cd="unknown">S</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j)\in S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Iterative_proportional_fitting:40">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{ij}=1
  </annotation>
 </semantics>
</math>

 otherwise. Then</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Iterative_proportional_fitting:41">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>i</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>η</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mfrac>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
      </mrow>
     </msub>
     <mrow>
      <mstyle displaystyle="false">
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mi>j</mi>
       </msub>
      </mstyle>
      <mrow>
       <msub>
        <mi>δ</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <msubsup>
        <mover accent="true">
         <mi>b</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mi>j</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>η</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </msubsup>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>a</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>η</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">limit-from</csymbol>
       <ci>i</ci>
       <plus></plus>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>δ</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>b</ci>
         </apply>
         <ci>j</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>η</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{a}_{i}^{(\eta)}=\frac{x_{i+}}{\sum_{j}\delta_{ij}\hat{b}_{j}^{(\eta-1)}},
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Iterative_proportional_fitting:42">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>b</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>j</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>η</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>x</mi>
     <mrow>
      <mo>+</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>i</mi>
      </msub>
     </mstyle>
     <mrow>
      <msub>
       <mi>δ</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <msubsup>
       <mover accent="true">
        <mi>a</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>i</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>η</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>b</ci>
      </apply>
      <ci>j</ci>
     </apply>
     <ci>η</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>δ</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>a</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <ci>η</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{b}_{j}^{(\eta)}=\frac{x_{+j}}{\sum_{i}\delta_{ij}\hat{a}_{i}^{(\eta)}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Iterative_proportional_fitting:43">
 <semantics>
  <mrow>
   <msubsup>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mi>η</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>δ</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <msubsup>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>i</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>η</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <msubsup>
     <mover accent="true">
      <mi>b</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>j</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>η</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>η</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>a</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>η</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>b</ci>
       </apply>
       <ci>j</ci>
      </apply>
      <ci>η</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{m}_{ij}^{(2\eta)}=\delta_{ij}\hat{a}_{i}^{(\eta)}\hat{b}_{j}^{(\eta)}
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>

<p>Obviously, the I-model is a particular case of the Q-model.</p>
<h2 id="algorithm-3-ras">Algorithm 3 (RAS)</h2>

<p>The Problem: Let 

<math display="inline" id="Iterative_proportional_fitting:44">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>m</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mi>I</mi>
     <mo>×</mo>
     <mi>J</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <ci>M</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <times></times>
       <ci>I</ci>
       <ci>J</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M:=(m^{(0)}_{ij})\in\mathbb{R}^{I\times J}
  </annotation>
 </semantics>
</math>

 be the initial matrix with nonnegative entries, 

<math display="inline" id="Iterative_proportional_fitting:45">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>I</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>u</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\in\mathbb{R}^{I}
  </annotation>
 </semantics>
</math>

 a vector of specified row marginals (e.i. row sums) and 

<math display="inline" id="Iterative_proportional_fitting:46">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>J</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>J</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in\mathbb{R}^{J}
  </annotation>
 </semantics>
</math>

 a vector of column marginals. We wish to compute a matrix 

<math display="inline" id="Iterative_proportional_fitting:47">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>M</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mover accent="true">
      <mi>m</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mi>I</mi>
     <mo>×</mo>
     <mi>J</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-^</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <times></times>
       <ci>I</ci>
       <ci>J</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{M}=(\hat{m}_{ij})\in\mathbb{R}^{I\times J}
  </annotation>
 </semantics>
</math>

 similar to <em>M</em> and consistent with the predefined marginals, meaning</p>

<p>

<math display="block" id="Iterative_proportional_fitting:48">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <msub>
     <mover accent="true">
      <mi>m</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">limit-from</csymbol>
       <ci>i</ci>
       <plus></plus>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{m}_{i+}=\sum_{j=1}^{n}\hat{m}_{ij}=u_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Iterative_proportional_fitting:49">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo>+</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </munderover>
    <msub>
     <mover accent="true">
      <mi>m</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>v</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{m}_{+j}=\sum_{i=1}^{m}\hat{m}_{ij}=v_{j}
  </annotation>
 </semantics>
</math>

</p>

<p>Define the diagonalization operator 

<math display="inline" id="Iterative_proportional_fitting:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>i</mi>
    <mi>a</mi>
    <mi>g</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>k</mi>
    </msup>
    <mo>⟶</mo>
    <msup>
     <mi>ℝ</mi>
     <mrow>
      <mi>k</mi>
      <mo>×</mo>
      <mi>k</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>i</ci>
     <ci>a</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <ci>normal-⟶</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   diag:\mathbb{R}^{k}\longrightarrow\mathbb{R}^{k\times k}
  </annotation>
 </semantics>
</math>

, which produces a (diagonal) matrix with its input vector on the main diagonal and zero elsewhere. Then, for 

<math display="inline" id="Iterative_proportional_fitting:51">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>η</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta\geq 0
  </annotation>
 </semantics>
</math>

, set</p>

<p>

<math display="block" id="Iterative_proportional_fitting:52">
 <semantics>
  <mrow>
   <msup>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>η</mi>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mtext>diag</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>r</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>η</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>M</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>η</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>η</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>diag</mtext>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <apply>
       <plus></plus>
       <ci>η</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>η</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{(2\eta+1)}=\text{diag}(r^{(\eta+1)})M^{(2\eta)}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Iterative_proportional_fitting:53">
 <semantics>
  <mrow>
   <msup>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>η</mi>
      </mrow>
      <mo>+</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>M</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mi>η</mi>
       </mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mtext>diag</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>s</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>η</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>η</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>η</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <mtext>diag</mtext>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <apply>
       <plus></plus>
       <ci>η</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{(2\eta+2)}=M^{(2\eta+1)}\text{diag}(s^{(\eta+1)})
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Iterative_proportional_fitting:54">
 <semantics>
  <mrow>
   <msubsup>
    <mi>r</mi>
    <mi>i</mi>
    <mrow>
     <mi>η</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>u</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>j</mi>
     </msub>
     <msubsup>
      <mi>m</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>η</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>η</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>η</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}^{\eta+1}=\frac{u_{i}}{\sum_{j}m_{ij}^{(2\eta)}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Iterative_proportional_fitting:55">
 <semantics>
  <mrow>
   <msubsup>
    <mi>s</mi>
    <mi>j</mi>
    <mrow>
     <mi>η</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>v</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>i</mi>
     </msub>
     <msubsup>
      <mi>m</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>η</mi>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>η</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>η</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{j}^{\eta+1}=\frac{v_{j}}{\sum_{i}m_{ij}^{(2\eta+1)}}
  </annotation>
 </semantics>
</math>

</p>

<p>Finally, we obtain 

<math display="inline" id="Iterative_proportional_fitting:56">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>M</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo>lim</mo>
      <mrow>
       <mi>η</mi>
       <mo>→</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </msub>
     <msup>
      <mi>M</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>η</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>η</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>η</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{M}=\lim_{\eta\rightarrow\infty}M^{(\eta)}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="discussion-and-comparison-of-the-algorithms">Discussion and comparison of the algorithms</h2>

<p>Although RAS seems to be the solution of an entirely different problem, it is indeed identical to the classical IPFP. In practice, one would not implement actual matrix multiplication, since diagonal matrices are involved. Reducing the operations to the necessary ones, it can easily be seen that RAS does the same as IPFP. The vaguely demanded 'similarity' can be explained as follows: IPFP (and thus RAS) maintains the crossproduct ratios, e.i.</p>

<p>

<math display="block" id="Iterative_proportional_fitting:57">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <msubsup>
       <mi>m</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <msubsup>
       <mi>m</mi>
       <mrow>
        <mi>h</mi>
        <mi>k</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
     <mrow>
      <msubsup>
       <mi>m</mi>
       <mrow>
        <mi>i</mi>
        <mi>k</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
      <msubsup>
       <mi>m</mi>
       <mrow>
        <mi>h</mi>
        <mi>j</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mpadded width="+5pt">
      <mfrac>
       <mrow>
        <msubsup>
         <mi>m</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>η</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
        <msubsup>
         <mi>m</mi>
         <mrow>
          <mi>h</mi>
          <mi>k</mi>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>η</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
       </mrow>
       <mrow>
        <msubsup>
         <mi>m</mi>
         <mrow>
          <mi>i</mi>
          <mi>k</mi>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>η</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
        <msubsup>
         <mi>m</mi>
         <mrow>
          <mi>h</mi>
          <mi>j</mi>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>η</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </msubsup>
       </mrow>
      </mfrac>
     </mpadded>
     <mrow>
      <mo rspace="7.5pt">∀</mo>
      <mi>η</mi>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mn>0</mn>
     <mtext>and</mtext>
     <mi>i</mi>
    </mrow>
    <mo>≠</mo>
    <mi>h</mi>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>j</mi>
    <mo>≠</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>m</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>m</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <times></times>
          <ci>h</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>m</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>m</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <times></times>
          <ci>h</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>m</ci>
           <ci>η</ci>
          </apply>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>m</ci>
           <ci>η</ci>
          </apply>
          <apply>
           <times></times>
           <ci>h</ci>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>m</ci>
           <ci>η</ci>
          </apply>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>m</ci>
           <ci>η</ci>
          </apply>
          <apply>
           <times></times>
           <ci>h</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>η</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <cn type="integer">0</cn>
       <mtext>and</mtext>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <share href="#.cmml">
      </share>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <neq></neq>
     <ci>j</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{m^{(0)}_{ij}m^{(0)}_{hk}}{m^{(0)}_{ik}m^{(0)}_{hj}}=\frac{m^{(\eta)}_{ij%
}m^{(\eta)}_{hk}}{m^{(\eta)}_{ik}m^{(\eta)}_{hj}}\ \forall\ \eta\geq 0\text{ %
and }i\neq h,\quad j\neq k
  </annotation>
 </semantics>
</math>

</p>

<p>since 

<math display="inline" id="Iterative_proportional_fitting:58">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>m</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>η</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>a</mi>
      <mi>i</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>η</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <msubsup>
      <mi>b</mi>
      <mi>j</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>η</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <ci>η</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <ci>η</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>j</ci>
      </apply>
      <ci>η</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{(\eta)}_{ij}=a_{i}^{(\eta)}b_{j}^{(\eta)}.
  </annotation>
 </semantics>
</math>


</p>

<p>This property is sometimes called <strong>structure conservation</strong> and directly leads to the geometrical interpretation of contingency tables and the proof of convergence in the seminal paper of Fienberg (1970).</p>

<p>Nevertheless, direct factor estimation (algorithm 2) is under all circumstances the best way to deal with IPF: Whereas classical IPFP needs</p>

<p>

<math display="block" id="Iterative_proportional_fitting:59">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mi>J</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mo>+</mo>
       <mi>J</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>I</mi>
     <mi>J</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mo>+</mo>
       <mi>I</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>I</mi>
      <mn>2</mn>
     </msup>
     <mi>J</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>I</mi>
     <msup>
      <mi>J</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>4</mn>
     <mi>I</mi>
     <mpadded width="+1.7pt">
      <mi>J</mi>
     </mpadded>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>J</ci>
      <apply>
       <plus></plus>
       <cn type="integer">2</cn>
       <ci>J</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>J</ci>
      <apply>
       <plus></plus>
       <cn type="integer">2</cn>
       <ci>I</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>I</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>J</ci>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>J</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <ci>I</ci>
      <ci>J</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IJ(2+J)+IJ(2+I)=I^{2}J+IJ^{2}+4IJ\,
  </annotation>
 </semantics>
</math>

</p>

<p>elementary operations in each iteration step (including a row and a column fitting step), factor estimation needs only</p>

<p>

<math display="block" id="Iterative_proportional_fitting:60">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mi>J</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>J</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mi>I</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>I</mi>
     <mi>J</mi>
    </mrow>
    <mo>+</mo>
    <mi>I</mi>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mi>J</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>J</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>J</ci>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>I</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>I</ci>
      <ci>J</ci>
     </apply>
     <ci>I</ci>
     <ci>J</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(1+J)+J(1+I)=2IJ+I+J\,
  </annotation>
 </semantics>
</math>

</p>

<p>operations being at least one order in magnitude faster than classical IPFP.</p>
<h2 id="existence-and-uniqueness-of-mles">Existence and uniqueness of MLEs</h2>

<p>Necessary and sufficient conditions for the existence and uniqueness of MLEs are complicated in the general case (see<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a>), but sufficient conditions for 2-dimensional tables are simple:</p>
<ul>
<li>the marginals of the observed table do not vanish (that is, 

<math display="inline" id="Iterative_proportional_fitting:61">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
     </mrow>
    </msub>
    <mo>></mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mo>+</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>></mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <gt></gt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">limit-from</csymbol>
       <ci>i</ci>
       <plus></plus>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <gt></gt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i+}>0,\ x_{+j}>0
  </annotation>
 </semantics>
</math>

) and</li>
<li>the observed table is inseparable (e.i. the table does not permute to a block-diagonal shape).</li>
</ul>

<p>If unique MLEs exist, IPFP exhibits linear convergence in the worst case (Fienberg 1970), but exponential convergence has also been observed (Pukelsheim and Simeone 2009). If a direct estimator (i.e. a closed form of 

<math display="inline" id="Iterative_proportional_fitting:62">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mover accent="true">
     <mi>m</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\hat{m}_{ij})
  </annotation>
 </semantics>
</math>

) exists, IPFP converges after 2 iterations. If unique MLEs do not exist, IPFP converges toward the so-called <em>extended MLEs</em> by design (Haberman 1974), but convergence may be arbitrarily slow and often computationally infeasible.</p>

<p>If all observed values are strictly positive, existence and uniqueness of MLEs and therefore convergence is ensured.</p>
<h2 id="goodness-of-fit">Goodness of fit</h2>

<p>Checking if the assumption of independence is adequate, one uses the <a href="Pearson_X-squared_statistic" title="wikilink">Pearson X-squared statistic</a></p>

<p>

<math display="block" id="Iterative_proportional_fitting:63">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
    </munder>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msub>
        <mo>-</mo>
        <mover accent="true">
         <msub>
          <mi>m</mi>
          <mrow>
           <mi>i</mi>
           <mi>j</mi>
          </mrow>
         </msub>
         <mo stretchy="false">^</mo>
        </mover>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mover accent="true">
      <msub>
       <mi>m</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mo stretchy="false">^</mo>
     </mover>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <ci>normal-^</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{2}=\sum_{i,j}\frac{(x_{ij}-\hat{m_{ij}})^{2}}{\hat{m_{ij}}}
  </annotation>
 </semantics>
</math>

</p>

<p>or alternatively the <a href="likelihood-ratio_test" title="wikilink">likelihood-ratio test</a> (<a class="uri" href="G-test" title="wikilink">G-test</a>) statistic</p>

<p>

<math display="block" id="Iterative_proportional_fitting:64">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mpadded width="+5pt">
        <mi>log</mi>
       </mpadded>
       <mfrac>
        <msub>
         <mi>x</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msub>
        <msub>
         <mover accent="true">
          <mi>m</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msub>
       </mfrac>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <list>
        <ci>i</ci>
        <ci>j</ci>
       </list>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <log></log>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>m</ci>
          </apply>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=2\sum_{i,j}x_{ij}\log\ \frac{x_{ij}}{\hat{m}_{ij}}
  </annotation>
 </semantics>
</math>

.</p>

<p>Both statistics are asymptotically 

<math display="inline" id="Iterative_proportional_fitting:65">
 <semantics>
  <msubsup>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\Chi</mtext>
   </merror>
   <mi>r</mi>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\Chi</mtext>
     <cn type="integer">2</cn>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Chi^{2}_{r}
  </annotation>
 </semantics>
</math>

-distributed, where 

<math display="inline" id="Iterative_proportional_fitting:66">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>I</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>J</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>I</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>J</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=(I-1)(J-1)
  </annotation>
 </semantics>
</math>

 is the number of degrees of freedom. That is, if the <a href="p-value" title="wikilink">p-values</a> 

<math display="inline" id="Iterative_proportional_fitting:67">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mrow>
    <msubsup>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Chi</mtext>
     </merror>
     <mi>r</mi>
     <mn>2</mn>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>X</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <mtext>\Chi</mtext>
       <cn type="integer">2</cn>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\Chi^{2}_{r}(X^{2})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Iterative_proportional_fitting:68">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mrow>
    <msubsup>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Chi</mtext>
     </merror>
     <mi>r</mi>
     <mn>2</mn>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <mtext>\Chi</mtext>
       <cn type="integer">2</cn>
      </apply>
      <ci>r</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\Chi^{2}_{r}(G)
  </annotation>
 </semantics>
</math>


 are not too small (&gt; 0.05 for instance), there is no indication to discard the hypothesis of independence.</p>
<h2 id="interpretation">Interpretation</h2>

<p>If the rows correspond to different values of property A, and the columns correspond to different values of property B, and the hypothesis of independence is not discarded, the properties A and B are considered independent.</p>
<h2 id="example">Example</h2>

<p>Consider a table of observations (taken from the entry on <a href="contingency_table" title="wikilink">contingency tables</a>):</p>
<center>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>| right-handed</p></td>
<td style="text-align: left;">
<p>left-handed</p></td>
<td style="text-align: left;">
<p>TOTAL</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>male</p></td>
<td style="text-align: left;">
<p>43</p></td>
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>52</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>female</p></td>
<td style="text-align: left;">
<p>44</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>48</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>TOTAL</p></td>
<td style="text-align: left;">
<p>87</p></td>
<td style="text-align: left;">
<p>13</p></td>
<td style="text-align: left;">
<p>100</p></td>
</tr>
</tbody>
</table>
</center>

<p>For executing the classical IPFP, we first initialize the matrix with ones, leaving the marginals untouched:</p>
<center>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>| right-handed</p></td>
<td style="text-align: left;">
<p>left-handed</p></td>
<td style="text-align: left;">
<p>TOTAL</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>male</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>52</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>female</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>48</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>TOTAL</p></td>
<td style="text-align: left;">
<p>87</p></td>
<td style="text-align: left;">
<p>13</p></td>
<td style="text-align: left;">
<p>100</p></td>
</tr>
</tbody>
</table>
</center>

<p>Of course, the marginal sums do not correspond to the matrix anymore, but this is fixed in the next two iterations of IPFP. The first iteration deals with the row sums:</p>
<center>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>| right-handed</p></td>
<td style="text-align: left;">
<p>left-handed</p></td>
<td style="text-align: left;">
<p>TOTAL</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>male</p></td>
<td style="text-align: left;">
<p>26</p></td>
<td style="text-align: left;">
<p>26</p></td>
<td style="text-align: left;">
<p>52</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>female</p></td>
<td style="text-align: left;">
<p>24</p></td>
<td style="text-align: left;">
<p>24</p></td>
<td style="text-align: left;">
<p>48</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>TOTAL</p></td>
<td style="text-align: left;">
<p>87</p></td>
<td style="text-align: left;">
<p>13</p></td>
<td style="text-align: left;">
<p>100</p></td>
</tr>
</tbody>
</table>
</center>

<p>Note that, by definition, the row sums always constitute a perfect match after odd iterations, as do the column sums for even ones. The subsequent iteration updates the matrix column-wise:</p>
<center>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>| right-handed</p></td>
<td style="text-align: left;">
<p>left-handed</p></td>
<td style="text-align: left;">
<p>TOTAL</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>male</p></td>
<td style="text-align: left;">
<p>45.24</p></td>
<td style="text-align: left;">
<p>6.76</p></td>
<td style="text-align: left;">
<p>52</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>female</p></td>
<td style="text-align: left;">
<p>41.76</p></td>
<td style="text-align: left;">
<p>6.24</p></td>
<td style="text-align: left;">
<p>48</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>TOTAL</p></td>
<td style="text-align: left;">
<p>87</p></td>
<td style="text-align: left;">
<p>13</p></td>
<td style="text-align: left;">
<p>100</p></td>
</tr>
</tbody>
</table>
</center>

<p>Now, both row and column sums of the matrix match the given marginals again.</p>

<p>The <a class="uri" href="p-value" title="wikilink">p-value</a> of this matrix approximates to 

<math display="inline" id="Iterative_proportional_fitting:69">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>X</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mn>0.1824671</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="float">0.1824671</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X^{2})\approx 0.1824671
  </annotation>
 </semantics>
</math>

, meaning: gender and left-handedness/right-handedness can be considered independent.</p>
<h2 id="implementation">Implementation</h2>

<p>The R package <strong>mipfp</strong> (currently in version 2.0) provides a multi-dimensional implementation of the traditional iterative proportional fitting procedure.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The package allows the updating of a <em>N</em>-dimensional array with respect to given target marginal distributions (which, in turn can be multi-dimensional).</p>
<h2 id="notes">Notes</h2>

<p>"</p>

<p><a href="Category:Categorical_data" title="wikilink">Category:Categorical data</a> <a href="Category:Statistical_algorithms" title="wikilink">Category:Statistical algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
