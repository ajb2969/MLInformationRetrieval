<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="323">Hilbert–Huang transform</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hilbert–Huang transform</h1>
<hr/>

<p>The <strong>Hilbert–Huang transform</strong> (<strong>HHT</strong>) is a way to decompose a <a href="Signal_processing" title="wikilink">signal</a> into so-called intrinsic mode functions (IMF) along with a trend, and obtain <a href="instantaneous_frequency" title="wikilink">instantaneous frequency</a> data. It is designed to work well for data that is <a href="Stationary_process" title="wikilink">nonstationary</a> and <a class="uri" href="nonlinear" title="wikilink">nonlinear</a>. In contrast to other common transforms like the <a href="Fourier_transform" title="wikilink">Fourier transform</a>, the HHT is more like an algorithm (an empirical approach) that can be applied to a data set, rather than a theoretical tool.</p>
<h2 id="introduction">Introduction</h2>

<p>The <strong>Hilbert–Huang transform</strong> (<strong>HHT</strong>), a <a class="uri" href="NASA" title="wikilink">NASA</a> designated name, was proposed by Huang et al. (1996, 1998, 1999, 2003, 2012). It is the result of the empirical mode decomposition (EMD) and the <a href="Hilbert_spectral_analysis" title="wikilink">Hilbert spectral analysis</a> (HSA). The HHT uses the EMD method to decompose a <a href="Signal_processing" title="wikilink">signal</a> into so-called <strong>intrinsic mode functions</strong> (<strong>IMF</strong>) with a trend, and applies the HSA method to the IMFs to obtain <a href="instantaneous_frequency" title="wikilink">instantaneous frequency</a> data. Since the signal is decomposed in time domain and the length of the IMFs is the same as the original signal, HHT preserves the characteristics of the varying frequency. This is an important advantage of HHT since real-world signal usually has multiple causes happening in different time intervals. The HHT provides a new method of analyzing <a href="Stationary_process" title="wikilink">nonstationary</a> and <a class="uri" href="nonlinear" title="wikilink">nonlinear</a> time series data.</p>
<h2 id="definition">Definition</h2>
<h3 id="empirical-mode-decomposition-emd">Empirical Mode Decomposition (EMD)</h3>

<p>The fundamental part of the HHT is the <strong>empirical mode decomposition</strong> (<strong>EMD</strong>) method. Breaking down signals into various components, EMD can be compared with other analysis methods such as <a href="Fourier_transform" title="wikilink">Fourier transform</a> and <a href="Wavelet_transform" title="wikilink">Wavelet transform</a>. Using the EMD method, any complicated data set can be decomposed into a finite and often small number of components. These components form a complete and nearly orthogonal basis for the original signal. In addition, they can be described as <strong>intrinsic mode functions</strong> (<strong>IMF</strong>).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Without leaving the time domain, EMD is <a href="adaptive_algorithm" title="wikilink">adaptive</a> and highly efficient. Since the decomposition is based on the local characteristic time scale of the data, it can be applied to <a class="uri" href="nonlinear" title="wikilink">nonlinear</a> and <a href="Stationary_process" title="wikilink">nonstationary</a> processes.</p>
<h3 id="intrinsic-mode-functions-imf">Intrinsic Mode Functions (IMF)</h3>

<p>An IMF is defined as a function that satisfies the following requirements:</p>
<ol>
<li>In the whole data set, the number of <a href="maxima_and_minima" title="wikilink">extrema</a> and the number of zero-crossings must either be equal or differ at most by one.</li>
<li>At any point, the mean value of the envelope defined by the local <a href="maxima_and_minima" title="wikilink">maxima</a> and the envelope defined by the local <a href="maxima_and_minima" title="wikilink">minima</a> is zero.</li>
</ol>

<p>It represents a generally simple <a href="Oscillation" title="wikilink">oscillatory</a> mode as a counterpart to the simple <a class="uri" href="harmonic" title="wikilink">harmonic</a> function. By definition, an IMF is any function with the same number of <a href="Maxima_and_minima" title="wikilink">extrema</a> and zero crossings, whose envelopes are symmetric with respect to zero. This definition guarantees a well-behaved <a href="Hilbert_transform" title="wikilink">Hilbert transform</a> of the IMF.</p>
<h3 id="hilbert-spectral-analysis">Hilbert Spectral Analysis</h3>

<p><a href="Hilbert_spectral_analysis" title="wikilink">Hilbert spectral analysis</a> (HSA) is a method for examining each IMF's <a href="instantaneous_frequency" title="wikilink">instantaneous frequency</a> as functions of time. The final result is a frequency-time distribution of signal amplitude (or energy), designated as the <a href="Hilbert_spectrum" title="wikilink">Hilbert spectrum</a>, which permits the identification of localized features.</p>
<h2 id="techniques">Techniques</h2>
<h3 id="empirical-mode-decomposition-emd-1">Empirical Mode Decomposition (EMD)</h3>

<p>The EMD method is a necessary step to reduce any given data into a collection of intrinsic mode functions (IMF) to which the <a href="Hilbert_spectrum" title="wikilink">Hilbert spectral</a> analysis can be applied.</p>

<p>IMF represents a <a href="Simple_harmonic_motion" title="wikilink">simple oscillatory mode</a> as a counterpart to the simple <a class="uri" href="harmonic" title="wikilink">harmonic</a> function, but it is much more general: instead of constant amplitude and frequency in a simple <a class="uri" href="harmonic" title="wikilink">harmonic</a> component, an IMF can have variable amplitude and frequency along the time axis.<br/>
The procedure of extracting an IMF is called sifting. The sifting process is as follows:</p>
<ol>
<li>Identify all the local <a href="maximum_and_minimum" title="wikilink">extrema</a> in the test data.</li>
<li>Connect all the local <a href="maxima_and_minima" title="wikilink">maxima</a> by a <a href="Spline_(mathematics)" title="wikilink">cubic spline line</a> as the upper envelope.</li>
<li>Repeat the procedure for the local <a href="maxima_and_minima" title="wikilink">minima</a> to produce the lower envelope.</li>
</ol>

<p>The upper and lower envelopes should cover all the data between them. Their <a class="uri" href="mean" title="wikilink">mean</a> is m<sub>1</sub>. The difference between the data and m<sub>1</sub> is the first component h<sub>1</sub>:<br/>


<math display="block" id="Hilbert–Huang_transform:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <msub>
      <mi>m</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>h</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(t)-m_{1}=h_{1}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Ideally, h<sub>1</sub> should satisfy the definition of an IMF, since the construction of h<sub>1</sub> described above should have made it <a href="symmetry" title="wikilink">symmetric</a> and having all <a href="maxima_and_minima" title="wikilink">maxima</a> positive and all <a href="maxima_and_minima" title="wikilink">minima</a> negative. After the first round of sifting, a crest may become a local <a href="maxima_and_minima" title="wikilink">maximum</a>. New <a href="maxima_and_minima" title="wikilink">extrema</a> generated in this way actually reveal the proper modes lost in the initial examination. In the subsequent sifting process, h<sub>1</sub> can only be treated as a proto-IMF. In the next step, h<sub>1</sub> is treated as data:<br/>


<math display="inline" id="Hilbert–Huang_transform:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>h</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>m</mi>
      <mn>11</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>h</mi>
     <mn>11</mn>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">11</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">11</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}-m_{11}=h_{11}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>After repeated sifting up to k times, h<sub>1</sub> becomes an IMF, that is<br/>


<math display="block" id="Hilbert–Huang_transform:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>h</mi>
      <mrow>
       <mn>1</mn>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>k</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>m</mi>
      <mrow>
       <mn>1</mn>
       <mi>k</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>h</mi>
     <mrow>
      <mn>1</mn>
      <mi>k</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <apply>
       <times></times>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <apply>
       <times></times>
       <cn type="integer">1</cn>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1(k-1)}-m_{1k}=h_{1k}.\,
  </annotation>
 </semantics>
</math>

 Then, h<sub>1k</sub> is designated as the first IMF component of the data:</p>

<p>

<math display="block" id="Hilbert–Huang_transform:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>h</mi>
     <mrow>
      <mn>1</mn>
      <mi>k</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}=h_{1k}.\,
  </annotation>
 </semantics>
</math>

</p>
<h3 id="stoppage-criteria-of-the-sifting-process">Stoppage Criteria of the Sifting Process</h3>

<p>The stoppage criterion determines the number of sifting steps to produce an IMF. Following are the four existing stoppage criterion:</p>
<ul>
<li>Standard Deviation</li>
</ul>

<p>This criterion is proposed by Huang et al. (1998). It similar to the <a href="Cauchy_convergence_test" title="wikilink">Cauchy convergence test</a>, and we define a sum of the difference, SD, as</p>

<p>

<math display="block" id="Hilbert–Huang_transform:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <msub>
      <mi>D</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>t</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>T</mi>
     </munderover>
     <mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mrow>
          <msub>
           <mi>h</mi>
           <mrow>
            <mi>k</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>h</mi>
           <mi>k</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mrow>
       <msubsup>
        <mi>h</mi>
        <mrow>
         <mi>k</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mn>2</mn>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>h</ci>
           <apply>
            <minus></minus>
            <ci>k</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>t</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>h</ci>
           <ci>k</ci>
          </apply>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <apply>
          <minus></minus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SD_{k}=\sum_{t=0}^{T}\frac{|h_{k-1}(t)-h_{k}(t)|^{2}}{h_{k-1}^{2}(t)}.\,
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>Then the sifting process stops when SD is smaller than a pre-given value.
</dd>
</dl>
<ul>
<li>S Number Criterion</li>
</ul>

<p>This criterion is based on the so-called S-number, which is defined as the number of consecutive siftings for which the number of zero-crossings and <a href="minima_and_maxima" title="wikilink">extrema</a> are equal or at most differing by one. Specifically, an S-number is pre-selected. The sifting process will stop only if, for S consecutive siftings, the numbers of zero-crossings and extrema stay the same, and are equal or at most differ by one.</p>
<ul>
<li>Threshold Method</li>
</ul>

<p>Proposed by Rilling, Flandrin and Gonçalvés, threshold method set two threshold values to guaranteeing globally small fluctuations in the mean while taking into account locally large excursions.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<ul>
<li>Energy Different Tracking</li>
</ul>

<p>Proposed by Cheng, Yu and Yang, energy different tracking method utilized the assumption that the original signal is a composition of orthogonal signals, and calculate the energy based on the assumption. If the result of EMD is not an orthogonal basis of the original signal, the amount of energy will be different from the original energy.</p>

<p>Once a stoppage criterion is selected, the first IMF, c<sub>1</sub>, can be obtained. Overall, c<sub>1</sub> should contain the finest scale or the shortest period component of the <a href="Signal_(electronics)" title="wikilink">signal</a>. We can, then, separate c<sub>1</sub> from the rest of the data by 

<math display="inline" id="Hilbert–Huang_transform:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <msub>
      <mi>c</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(t)-c_{1}=r_{1}.\,
  </annotation>
 </semantics>
</math>

 Since the residue, r<sub>1</sub>, still contains longer period variations in the data, it is treated as the new data and subjected to the same sifting process as described above.</p>

<p>This procedure can be repeated for all the subsequent r<sub>j</sub>'s, and the result is</p>

<p>

<math display="block" id="Hilbert–Huang_transform:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>r</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>c</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>r</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{n-1}-c_{n}=r_{n}.\,
  </annotation>
 </semantics>
</math>

 The sifting process finally stops when the <a href="residue_(complex_analysis)" title="wikilink">residue</a>, r<sub>n</sub>, becomes a <a href="monotonic_function" title="wikilink">monotonic function</a> from which no more IMF can be extracted. From the above equations, we can induce that</p>

<p>

<math display="block" id="Hilbert–Huang_transform:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <msub>
       <mi>c</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>r</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(t)=\sum_{j=1}^{n}c_{j}+r_{n}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, a decomposition of the data into n-empirical modes is achieved. The components of the EMD are usually physically meaningful, for the characteristic scales are defined by the physical data. Flandrin et al. (2003) and Wu and Huang (2004) have shown that the EMD is equivalent to a dyadic filter bank.</p>
<h3 id="hilbert-spectral-analysis-1">Hilbert Spectral Analysis</h3>

<p>Having obtained the intrinsic mode function components, the <a href="instantaneous_frequency" title="wikilink">instantaneous frequency</a> can be computed using the <a href="Hilbert_Transform" title="wikilink">Hilbert Transform</a>. After performing the <a href="Hilbert_transform" title="wikilink">Hilbert transform</a> on each IMF component, the original data can be expressed as the real part, Real, in the following form:</p>

<p>

<math display="block" id="Hilbert–Huang_transform:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mtext>Real</mtext>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>a</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mi>e</mi>
        <mrow>
         <mi>i</mi>
         <mstyle scriptlevel="-1">
          <mrow>
           <mo largeop="true" symmetric="true">∫</mo>
           <mrow>
            <msub>
             <mi>ω</mi>
             <mi>j</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>t</mi>
             <mo stretchy="false">)</mo>
            </mrow>
            <mi>d</mi>
            <mi>t</mi>
           </mrow>
          </mrow>
         </mstyle>
        </mrow>
       </msup>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>Real</mtext>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>j</ci>
       </apply>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <apply>
          <int></int>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ω</ci>
            <ci>j</ci>
           </apply>
           <ci>t</ci>
           <ci>d</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(t)=\text{Real}{\sum_{j=1}^{n}a_{j}(t)e^{i\int\omega_{j}(t)dt}}.\,
  </annotation>
 </semantics>
</math>

</p>
<h2 id="current-applications">Current Applications</h2>
<ul>
<li><strong>Biomedical applications</strong>: Huang et al. [1999b] analyzed the <a href="blood_pressure" title="wikilink">pulmonary arterial pressure</a> on conscious and unrestrained <a href="rat" title="wikilink">rats</a>. Pachori (2008) has used EMD for discrimination of seizure and seizure-free EEG signals.</li>
<li><strong>Neuroscience</strong>: Pigorini et al. [2011] analyzed Human EEG response to Transcranial Magnetic Stimulation; Liang et al. [2005] analyzed the visual evoked potentials of macaque performing visual spatial attention task.</li>
<li><strong>Epidemiology</strong>: Cummings et al. [2004] applied the EMD method to extract a 3-year-periodic mode embedded in Dengue Fever outbreak time series recorded in Thailand and assessed the travelling speed of Dengue Fever outbreaks. Yang et al. [2010] applied the EMD method to delineate sub-components of a variety of neuropsychiatric epidemiological time series, including the association between seasonal effect of Google search for depression [2010], association between suicide and air pollution in Taipei City [2011], and association between cold front and incidence of migraine in Taipei city [2011].</li>
<li><strong>Chemistry and chemical engineering</strong>: Phillips et al. [2003] investigated a conformational change in <a href="Brownian_dynamics" title="wikilink">Brownian dynamics</a>(BD) and <a href="molecular_dynamics" title="wikilink">molecular dynamics</a>(MD) simulations using a <a href="Comparative_bullet-lead_analysis" title="wikilink">comparative analysis</a> of HHT and <a class="uri" href="wavelet" title="wikilink">wavelet</a> methods. Wiley et al. [2004] used HHT to investigate the effect of reversible digitally filtered molecular dynamics(RDFMD) which can enhance or suppress specific frequencies of motion. Montesinos et al. [2002] applied HHT to signals obtained from BWR <a class="uri" href="neuron" title="wikilink">neuron</a> stability.</li>
<li><strong>Financial applications</strong>: Huang et al. [2003b] applied HHT to nonstationary financial time series and used a weekly mortgage rate data.</li>
<li><strong>Image processing</strong>: Hariharan et al. [2006] applied EMD to image fusion and enhancement. Chang et al. [2009] applied an improved EMD to iris recognition, which reported a 100% faster in computational speed without losing accuracy than the original EMD.</li>
<li><strong>Atmospheric Turbulence</strong>: Hong et al. [2010] applied HHT to turbulence data observed in the stable boundary layer to separate turbulent and non-turbulent motions.</li>
<li><strong>Meteorological and atmospheric applications</strong>: Salisbury and Wimbush [2002], using Southern Oscillation Index(SOI) data, applied the HHT technique to determine whether the <a href="Sphere_of_influence" title="wikilink">SOI</a> data are sufficiently noise free that useful predictions can be made and whether future <a href="El_Niño-Southern_Oscillation" title="wikilink">El Nino southern oscillation</a>(ENSO) events can be predicted from SOI data. Pan et al. [2002] used HHT to analyze <a class="uri" href="satellite" title="wikilink">satellite</a> <a class="uri" href="scatterometer" title="wikilink">scatterometer</a> wind data over the northwestern Pacific and compared the results to vector <a href="empirical_orthogonal_function" title="wikilink">empirical orthogonal function</a>(VEOF) results.</li>
<li><strong>Ocean engineering</strong>:Schlurmann [2002] introduced the application of HHT to characterize <a class="uri" href="nonlinear" title="wikilink">nonlinear</a> <a href="water_waves" title="wikilink">water waves</a> from two different perspectives, using laboratory experiments. Veltcheva [2002] applied HHT to wave data from nearshore sea. Larsen et al. [2004] used HHT to characterize the <a class="uri" href="underwater" title="wikilink">underwater</a> <a href="electromagnetic_environment" title="wikilink">electromagnetic environment</a> and identify transient manmade electromagnetic disturbances.</li>
<li><strong>Seismic studies</strong>: Huang et al. [2001] used HHT to develop a spectral representation of <a class="uri" href="earthquake" title="wikilink">earthquake</a> data. Chen et al. [2002a] used HHT to determined the <a href="Dispersion_relation" title="wikilink">dispersion</a> curves of <a href="Earthquake_engineering" title="wikilink">seismic surface</a> waves and compared their results to <a href="Fourier_analysis" title="wikilink">Fourier-based</a> <a href="time-frequency_analysis" title="wikilink">time-frequency analysis</a>. Shen et al. [2003] applied HHT to ground motion and compared the HHT result with the <a href="Fourier_analysis" title="wikilink">Fourier spectrum</a>.</li>
<li><strong>Solar physics</strong>: Nakariakov et al. [2010] used EMD to demonstrate the triangular shape of quasi-periodic pulsations detected in the hard X-ray and microwave emission generated in <a href="solar_flares" title="wikilink">solar flares</a>. Barnhart and Eichinger [2010] used HHT to extract the periodic components within <a href="Sunspots" title="wikilink">sunspot</a> data, including the 11-year Schwabe, 22-year Hale, and ~100-year Gleissberg cycles. They compared their results with traditional <a href="Fourier_analysis" title="wikilink">Fourier analysis</a>.</li>
<li><strong>Structural applications</strong>: Quek et al. [2003] illustrate the feasibility of the HHT as a signal processing tool for locating an anomaly in the form of a <a href="Fracture" title="wikilink">crack</a>, <a class="uri" href="delamination" title="wikilink">delamination</a>, or stiffness loss in beams and plates based on physically acquired propagating wave signals. Using HHT, Li et al. [2003] analyzed the results of a pseudodynamic test of two rectangular reinforced <a class="uri" href="concrete" title="wikilink">concrete</a> bridge columns.</li>
<li><strong>Health monitoring</strong>: Pines and Salvino [2002] applied HHT in structural health monitoring. Yang et al. [2004] used HHT for damage detection, applying EMD to extract damage spikes due to sudden changes in <a href="Structural_engineering" title="wikilink">structural stiffness</a>. Yu et al. [2003] used HHT for fault diagnosis of roller bearings. Parey and Pachori (2012) have applied EMD for gear fault diagnosis.</li>
<li><strong>System identification</strong>: Chen and Xu [2002] explored the possibility of using HHT to identify the <a href="Modal_analysis" title="wikilink">modal</a> <a href="damping_ratio" title="wikilink">damping ratios</a> of a structure with closely spaced modal frequencies and compared their results to <a href="Fast_Fourier_transform" title="wikilink">FFT</a>. Xu et al. [2003] compared the modal frequencies and <a href="damping_ratio" title="wikilink">damping ratios</a> in various time increments and different winds for one of the tallest composite buildings in the world.</li>
<li><strong>Speech recognition</strong>: Huang and Pan [2006] have used the HHT for speech pitch determination.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li>''' Astroparticle Physics ''': Bellini et al. [2014] (Borexino collaboration), <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Measureme of the seasonal modulation of the solar neutrino fluxes with Borexino experiment, Phys. Rev. D 89, 112007 2014</li>
</ul>
<h2 id="limitations">Limitations</h2>

<p>Chen and Feng [2003] proposed a technique to improve the HHT procedure.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The authors noted that the EMD is limited in distinguishing different components in <a href="narrowband" title="wikilink">narrow-band</a> signals. The narrow band may contain either (a) components that have adjacent frequencies or (b) components that are not adjacent in frequency but for which one of the components has a much higher <a class="uri" href="energy" title="wikilink">energy</a> <a href="intensity_(physics)" title="wikilink">intensity</a> than the other components. The improved technique is based on beating-phenomenon waves.</p>

<p>Datig and Schlurmann [2004] <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> conducted a comprehensive study on the performance and limitations of HHT with particular applications to <a class="uri" href="irregular" title="wikilink">irregular</a> waves. The authors did extensive investigation into the <a href="spline_interpolation" title="wikilink">spline interpolation</a>. The authors discussed using additional points, both forward and backward, to determine better envelopes. They also performed a <a href="parametric_model" title="wikilink">parametric study</a> on the proposed improvement and showed significant improvement in the overall EMD computations. The authors noted that HHT is capable of differentiating between time-variant components from any given data. Their study also showed that HHT was able to distinguish between riding and carrier waves.</p>

<p>Huang and Zu [2008] <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> reviewed applications of the Hilbert–Huang transformation emphasizing that the HHT theoretical basis is purely empirical, and noting that "one of the main drawbacks of EMD is mode mixing". They also outline outstanding open problems with HHT, which include: End effects of the EMD, Spline problems, Best IMF selection and uniqueness. Although the ensemble EMD (EEMD) may help mitigate the latter.</p>

<p>In the US, where patents on algorithms are permitted, the HHT is heavily encumbered by patents in almost all of its domains of possible application .</p>
<h3 id="end-effect">End Effect</h3>

<p>End effect occurs at the beginning and end of the signal because there is no point before the first data point and after the last data point to be considered together. In most cases, these end points are not the extreme value of the signal. While doing the EMD process of the HHT, the extreme envelope will diverge at the end points and cause significant error. This error distorts the IMF waveform at its endpoints. Furthermore, the error in the decomposition result accumulates through each repetition of the sifting process.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Various methods are proposed to solve the end effect in HHT:</p>
<ul>
<li>Characteristic Wave Extending Method</li>
<li>Mirror Extending Method</li>
<li>Data Extending Method</li>
<li>Similarity Searching Method</li>
</ul>
<h3 id="mode-mixing-problem">Mode Mixing Problem</h3>

<p>Mode mixing problem happens during the EMD process. Straightforward implementation of sifting procedure produces mode mixing due to IMF mode rectification. Specific signal may not be separated into the same IMFs every time. This problem makes it hard to implement feature extraction, model training and pattern recognition since the feature is no longer fixed in one labeling index. Mode mixing problem can be avoided by including an intermittence test during the HHT process.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<ul>
<li>Masking Method</li>
<li>Ensemble Empirical Mode Decomposition</li>
</ul>
<h4 id="ensemble-empirical-mode-decompositioneemd">Ensemble Empirical Mode Decomposition(EEMD)</h4>

<p>The proposed Ensemble Empirical Mode Decomposition is developed as follows:</p>
<ol>
<li>add a white noise series to the targeted data;</li>
<li>decompose the data with added white noise into IMFs;</li>
<li>repeat step 1 and step 2 again and again, but with different white noise series each time;and</li>
<li>obtain the (ensemble) means of corresponding IMFs of the decompositions as the final result.</li>
</ol>

<p>The effects of the decomposition using the EEMD are that the added white noise series cancel each other, and the mean IMFs stays within the natural dyadic filter windows, significantly reducing the chance of mode mixing and preserving the dyadic property.</p>
<h2 id="comparison-with-other-transform">Comparison with Other Transform</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Transform</p></th>
<th style="text-align: left;">
<p>Fourier</p></th>
<th style="text-align: left;">
<p>Wavelet</p></th>
<th style="text-align: left;">
<p>Hilbert</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Basis</p></td>
<td style="text-align: left;">
<p>a priori</p></td>
<td style="text-align: left;">
<p>a priori</p></td>
<td style="text-align: left;">
<p>adaptive</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Frequency</p></td>
<td style="text-align: left;">
<p>convolution: global, uncertainty</p></td>
<td style="text-align: left;">
<p>convolution: regional, uncertainty</p></td>
<td style="text-align: left;">
<p>differentiation: local, certainty</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Presentation</p></td>
<td style="text-align: left;">
<p>energy-frequency</p></td>
<td style="text-align: left;">
<p>energy-time-frequency</p></td>
<td style="text-align: left;">
<p>energy-time-frequency</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Nonlinear</p></td>
<td style="text-align: left;">
<p>no</p></td>
<td style="text-align: left;">
<p>no</p></td>
<td style="text-align: left;">
<p>yes</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Non-stationary</p></td>
<td style="text-align: left;">
<p>no</p></td>
<td style="text-align: left;">
<p>yes</p></td>
<td style="text-align: left;">
<p>yes</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Feature Extraction</p></td>
<td style="text-align: left;">
<p>no</p></td>
<td style="text-align: left;">
<p>discrete: no, continuous: yes</p></td>
<td style="text-align: left;">
<p>yes</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Theoretical Base</p></td>
<td style="text-align: left;">
<p>theory complete</p></td>
<td style="text-align: left;">
<p>theory complete</p></td>
<td style="text-align: left;">
<p>empirical</p></td>
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Hilbert_transform" title="wikilink">Hilbert transform</a></li>
<li><a href="Hilbert_spectral_analysis" title="wikilink">Hilbert spectral analysis</a></li>
<li><a href="Hilbert_spectrum" title="wikilink">Hilbert spectrum</a></li>
<li><a href="Instantaneous_frequency" title="wikilink">Instantaneous frequency</a></li>
<li><a class="uri" href="Nonlinear" title="wikilink">Nonlinear</a></li>
<li><a href="Wavelet_transform" title="wikilink">Wavelet transform</a></li>
<li><a href="Fourier_transform" title="wikilink">Fourier transform</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>{{ cite journal | author = Parey, A.; Pachori, R.B. | title = Variable cosine windowing of intrinsic mode functions:</li>
</ul>

<p>Application to gear fault diagnosis | journal = Measurement | year = 2012 | volume = 45 | issue = 3 | pages = 415–426 | doi =10.1016/j.measurement.2011.11.001 }}</p>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a href="Category:Telecommunication_theory" title="wikilink">Category:Telecommunication theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9">Hilbert-Huang Transform and Its Applications<a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
