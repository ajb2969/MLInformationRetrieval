<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1138">Last diminisher</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Last diminisher</h1>
<hr/>

<p>The <strong>last diminisher</strong> procedure is a procedure for <a href="fair_cake-cutting" title="wikilink">fair cake-cutting</a>. It involves a certain heterogenous and divisible resource, such as a birthday cake, and <em>n</em> partners with different preferences over different parts of the cake. It allows the <em>n</em> people to achieve a <a href="proportional_division" title="wikilink">proportional division</a>, i.e., divide the cake among them such that person receives a piece with a value of at least 1/<em>n</em> of the total value according to his own subjective valuation. For example, if Alice values the entire cake as $100 and there are 5 partners then Alice can receive a piece that she values as at least $20, regardless of what the other partners think or do.</p>
<h2 id="history">History</h2>

<p>During <a href="world_war_II" title="wikilink">world war II</a>, the Polish-Jewish mathematician <a href="Hugo_Steinhaus" title="wikilink">Hugo Steinhaus</a>, who was hiding from the Nazis, occupied himself with the question of how to divide resources fairly. Inspired by the <a href="Divide_and_choose" title="wikilink">Divide and choose</a> procedure for dividing a cake between two brothers, he asked his students, <a href="Stefan_Banach" title="wikilink">Stefan Banach</a> and <a href="Bronisław_Knaster" title="wikilink">Bronisław Knaster</a>, to find a procedure that can work for any number of people, and published their solution.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>This publication has initiated a new research topic which is now studied by many researchers in different disciplines; see <a href="fair_division" title="wikilink">fair division</a>.</p>
<h2 id="description">Description</h2>

<p>This is the description of the division protocol in the words of the author:</p>
<dl>
<dd>"The partners being ranged A, B, C,.. N, A cuts from the cake an arbitrary part. B has now the right, but is not obliged, to diminish the slice cut off. Whatever he does, C has the right (without obligation) to diminish still the already diminished (or not diminished) slice, and so on up to N. The rule obliges the "last diminisher" to take as his part the slice he was the last to touch. This partner being thus disposed of, the remaining n-1 persons start the same game with the remainder of the cake. After the number of participants has been reduced to two, they apply the classical rule for halving the remainder."
</dd>
</dl>

<p>Each partner has a method that guarantees that he receives a slice with a value of at least 1/<em>n</em>. The method is: always cut the current slice such that the remainder has a value of 1/<em>n</em> for you. There are two options: either you receive the slice that you have cut, or another person receives a smaller slice, whose value for you is less than 1/<em>n</em>. In the latter case, there are <em>n</em>-1 partners remaining and the value of the remaining cake is more than (<em>n</em>-1)/<em>n</em>. Hence by induction it is possible to prove that the received value is at least 1/<em>n</em>.</p>
<h2 id="analysis">Analysis</h2>

<p>The last-diminisher protocol is discrete and can be played in turns. In the worst case, 

<math display="inline" id="Last_diminisher:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times(n-1)/2=O(n^{2})
  </annotation>
 </semantics>
</math>

 actions are needed: one action per player per turn.</p>

<p>However, most of these O(<em>n</em>^2) actions are not actual cuts, i.e. Alice can mark her desired slice on a paper and have the other players diminish them on the same paper etc.; only the "last diminisher" has to actually cut the cake. So, only <em>n</em>-1 cuts are needed.</p>

<p>The procedure is very liberal regarding the cuts. the cuts made by the partners can have any shape; they can even be disconnected. On the other hand, it is possible to restrict the cuts in order to guarantee that the pieces have a nice shape. In particular:</p>
<ul>
<li>If the original cake is connected, then it is possible to guarantee that each piece is connected (contiguous).</li>
<li>If the original cake is a <a href="convex_set" title="wikilink">convex set</a>, then it is possible to guarantee that each piece is convex.</li>
<li>If the original cake is a <a class="uri" href="rectangle" title="wikilink">rectangle</a>, then it is possible to guarantee that each piece is a rectangle.</li>
<li>If the original cake is a <a class="uri" href="triangle" title="wikilink">triangle</a>, then it is possible to guarantee that each piece is a triangle.</li>
</ul>
<h2 id="continuous-version">Continuous version</h2>

<p>A continuous-time version of this protocol can be executed using the Dubins-Spanier <a href="Moving-knife_procedure" title="wikilink">Moving-knife procedure</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It was the first example of a continuous procedure in fair division. The knife is passed over the cake from one end to the other. A player says stop when they think 

<math display="inline" id="Last_diminisher:1">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/n
  </annotation>
 </semantics>
</math>

 of the cake is to the left of the knife, the cake is cut and they get that piece. Repeat with the remaining cake and players, the last player gets the remainder of the cake. Similar to the last diminisher procedure, it can be used to cut the cake into contiguous parts for each player.</p>
<h2 id="approximate-envy-free-version">Approximate-envy-free version</h2>

<p>When there are 3 or more partners, the division obtained by the last-diminisher protocol is not always <a class="uri" href="envy-free" title="wikilink">envy-free</a>. For example, suppose the first partner Alice receives a piece (which she values as 1/3 of the total). Then, the other two partners Bob and Charlie divide the remainder in such a way that is fair in their opinion, but in Alice's opinion Bob's share is worth 2/3 while Charlie's share is worth 0. Then Alice envies Bob.</p>

<p>A simple solution<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> is to allow <em>re-entrance</em>. I.e, a partner that won a piece by being the last diminisher, does not have to leave the game, but may rather stay and participate in further steps. If he wins again, he must release his current piece and it is returned to the cake. In order to make sure that the protocol terminates, we select a certain constant 

<math display="inline" id="Last_diminisher:2">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 and add a rule that allows each partner to re-enter at most 

<math display="inline" id="Last_diminisher:3">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/\epsilon
  </annotation>
 </semantics>
</math>

 times.</p>

<p>In the reentrant version, each partner has a method that guarantees that he receives a slice with a value of at least the largest value minus 

<math display="inline" id="Last_diminisher:4">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

. The method is: always cut the current slice such that the remainder has a value of 

<math display="inline" id="Last_diminisher:5">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 plus your current value. This guarantees that your value grows by 

<math display="inline" id="Last_diminisher:6">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 each time you win, and if you don't win - the value of the winner is at most 

<math display="inline" id="Last_diminisher:7">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 more than your own value. Thus, the level of envy is at most 

<math display="inline" id="Last_diminisher:8">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 (an additive constant).</p>

<p>The run-time is at most 

<math display="inline" id="Last_diminisher:9">
 <semantics>
  <mrow>
   <msup>
    <mi>n</mi>
    <mn>2</mn>
   </msup>
   <mo>/</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}/\epsilon
  </annotation>
 </semantics>
</math>

, since there are at most 

<math display="inline" id="Last_diminisher:10">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/\epsilon
  </annotation>
 </semantics>
</math>

 steps and at each step we query each of the 

<math display="inline" id="Last_diminisher:11">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 partners.</p>

<p>A disadvantage of the approximate-envy-free variant is that the pieces are not necessarily connected, since pieces are constantly returned to the cake and re-divided. See <a href="envy-free#Connected_pieces" title="wikilink">envy-free#Connected pieces</a> for other solutions to this problem.</p>
<h2 id="improvements">Improvements</h2>

<p>The last diminisher procedure has been improved later in many ways. For details, see <a href="proportional_division" title="wikilink">proportional division</a>.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Fair_division_protocols" title="wikilink">Category:Fair division protocols</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
