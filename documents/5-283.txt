


Secure Remote Password protocol




Secure Remote Password protocol

 table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
   margin: 0; padding: 0; vertical-align: baseline; border: none; }
 <style>
 table.sourceCode { width: 100%; line-height: 100%; }
 td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
 td.sourceCode { padding-left: 5px; }
 code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
 code > span.dt { color: #902000; } /* DataType */
 code > span.dv { color: #40a070; } /* DecVal */
 code > span.bn { color: #40a070; } /* BaseN */
 code > span.fl { color: #40a070; } /* Float */
 code > span.ch { color: #4070a0; } /* Char */
 code > span.st { color: #4070a0; } /* String */
 code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
 code > span.ot { color: #007020; } /* Other */
 code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
 code > span.fu { color: #06287e; } /* Function */
 code > span.er { color: #ff0000; font-weight: bold; } /* Error */
 code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
 code > span.cn { color: #880000; } /* Constant */
 code > span.sc { color: #4070a0; } /* SpecialChar */
 code > span.vs { color: #4070a0; } /* VerbatimString */
 code > span.ss { color: #bb6688; } /* SpecialString */
 code > span.im { } /* Import */
 code > span.va { color: #19177c; } /* Variable */
 code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
 code > span.op { color: #666666; } /* Operator */
 code > span.bu { } /* BuiltIn */
 code > span.ex { } /* Extension */
 code > span.pp { color: #bc7a00; } /* Preprocessor */
 code > span.at { color: #7d9029; } /* Attribute */
 code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
 code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
 code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
 code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
   



The Secure Remote Password protocol (SRP) is an augmented password-authenticated key agreement (PAKE) protocol, specifically designed to work around expired patents.1
Like all PAKE protocols, an eavesdropper or man in the middle cannot obtain enough information to be able to brute force guess a password without further interactions with the parties for each guess. This means that strong security can be obtained using weak passwords. Furthermore, being an augmented PAKE protocol, the server does not store password-equivalent data. This means that an attacker who steals the server data cannot masquerade as the client unless they first perform a brute force search for the password.
Overview
The SRP protocol has a number of desirable properties: it allows a user to authenticate themselves to a server, it is resistant to dictionary attacks mounted by an eavesdropper, and it does not require a trusted third party. It effectively conveys a zero-knowledge password proof from the user to the server. In revision 6 of the protocol only one password can be guessed per connection attempt. One of the interesting properties of the protocol is that even if one or two of the cryptographic primitives it uses are attacked, it is still secure. The SRP protocol has been revised several times, and is currently at revision 6a.
The SRP protocol creates a large private key shared between the two parties in a manner similar to Diffie–Hellman key exchange based on the client side having the user password and the server side having a cryptographic verifier derived from the password. The shared public key is derived from two random numbers, one generated by the client, and the other generated by the server, which are unique to the login attempt. In cases where encrypted communications as well as authentication are required, the SRP protocol is more secure than the alternative SSH protocol and faster than using Diffie–Hellman key exchange with signed messages. It is also independent of third parties, unlike Kerberos. The SRP protocol, version 3 is described in RFC 2945. SRP version 6 is also used for strong password authentication in SSL/TLS2 (in TLS-SRP) and other standards such as EAP3 and SAML, and is being standardized in IEEE P1363 and ISO/IEC 11770-4.
Protocol
The following notation is used in this description of the protocol, version 6:

q and N = 2q + 1 are chosen such that both are prime (which makes q a Sophie Germain prime and N a safe prime). N must be large enough so that computing discrete logarithms modulo N is infeasible.
All arithmetic is performed in the ring of integers modulo N, 
 
 
 
 . This means that below gx should be read as gxmod N
g is a generator of the multiplicative group.
H() is a hash function; e.g., SHA-256.
k is a parameter derived by both sides; in SRP-6, k = 3, while in SRP-6a it is derived from N and g : k = H(N, g). It is used to prevent a 2-for-1 guess when an active attacker impersonates the server.45
s is a small salt.
I is an identifying username.
p is the user's password.
v is the host's password verifier, v = gx where at a minimum x = H(s, p). As x is only computed on the client it is free to choose a stronger algorithm. Usage of key derivation functions like PBKDF2 instead of simple hash functions for password hashing is highly recommended [citation needed]. An implementation could choose to use x = H(s | I | p) without effecting any steps required of the host. The standard RFC2945 defines x = H(s | H ( I | ":" | p) ). Use of I within x avoids a malicious server from being able to learn if two users share the same password.
a and b are random one time ephemeral keys of the user and host respectively.
| (pipe) denotes concatenation.

All other variables are defined in terms of these.
First, to establish a password p with server Steve, client Carol picks a small random salt s, and computes x = H(s, p), v = gx. Steve stores v and s, indexed by I, as Carol's password verifier and salt. x is discarded because it is equivalent to the plaintext password p. This step is completed before the system is used as part of the user registration with Steve. Note that the salt "s" is shared and exchanged to negotiate a session key later so the value could be chosen by either side but is done by Carol so that she can register "I", "s" and "v" in a single registration request. (Note server Steve should enforce a uniqueness constraint on all "v" to protect against someone stealing his database observing which users have identical passwords.)
Then to perform a proof of password at a later date the following exchange protocol occurs:

Carol → Steve: I and A = ga
Steve → Carol: s and B = kv + gb
Both: u = H(A, B)
Carol: SCarol = (B − kgx)(a + ux) = (kv + gb − kgx)(a + ux) = (kgx − kgx + gb)(a + ux) = (gb)(a + ux)
Carol: KCarol = H(SCarol)
Steve: SSteve = (Avu)b = (gavu)b = [ga(gx)u]b = (ga + ux)b = (gb)(a + ux)
Steve: KSteve = H(SSteve) = KCarol

Now the two parties have a shared, strong session key K. To complete authentication, they need to prove to each other that their keys match. One possible way is as follows:

Carol → Steve: M1 = H[H(N) XOR H(g) | H(I) | s | A | B | KCarol]. Steve verifies M1.
Steve → Carol: M2 = H(A | M1 | KSteve). Carol verifies M2.

This method requires guessing more of the shared state to be successful in impersonation than just the key. While most of the additional state is public, private information could safely be added to the inputs to the hash function, like the server private key.
Alternately in a password only proof the calculation of "K" can be skipped and the shared "S" proven with:

Carol → Steve: M1 = H(A | B | SCarol). Steve verifies M1.
Steve → Carol: M2 = H(A | M1 | SSteve). Carol verifies M2.

When using SRP to negotiate a shared key "K" which will be immediately used after the negotiation the verification steps of "M"1 and "M"2 may be skipped. The server will reject the very first request from the client which it cannot decrypt.
The two parties also employ the following safeguards:

Carol will abort if she receives B == 0 (mod N) or u == 0.
Steve will abort if he receives A (mod N) == 0.
Carol must show her proof of K (or "S") first. If Steve detects that Carol's proof is incorrect, he must abort without showing his own proof of K (or "S")

Implementation example in Python
# An example SRP authentication
 # WARNING: Do not use for real cryptographic purposes beyond testing.
 # based on http://srp.stanford.edu/design.html
 import hashlib
 import random
 
 def global_print(*names):
     x = lambda s: ["{}", "0x{:x}"][hasattr(s, 'real')].format(s)
     print("".join("{} = {}\n".format(name, x(globals()[name])) for name in names))
 
 # note: str converts as is, str( [1,2,3,4] ) will convert to "[1,2,3,4]" 
 def H(*a):  # a one-way hash function
     a = ':'.join([str(a) for a in a])
     return int(hashlib.sha256(a.encode('ascii')).hexdigest(), 16)
 
 def cryptrand(n=1024):
     return random.SystemRandom().getrandbits(n) % N
 
 # A large safe prime (N = 2q+1, where q is prime)
 # All arithmetic is done modulo N
 # (generated using "openssl dhparam -text 1024")
 N = '''00:c0:37:c3:75:88:b4:32:98:87:e6:1c:2d:a3:32:
        4b:1b:a4:b8:1a:63:f9:74:8f:ed:2d:8a:41:0c:2f:
        c2:1b:12:32:f0:d3:bf:a0:24:27:6c:fd:88:44:81:
        97:aa:e4:86:a6:3b:fc:a7:b8:bf:77:54:df:b3:27:
        c7:20:1f:6f:d1:7f:d7:fd:74:15:8b:d3:1c:e7:72:
        c9:f5:f8:ab:58:45:48:a9:9a:75:9b:5a:2c:05:32:
        16:2b:7b:62:18:e8:f1:42:bc:e2:c3:0d:77:84:68:
        9a:48:3e:09:5e:70:16:18:43:79:13:a8:c3:9c:3d:
        d0:d4:ca:3c:50:0b:88:5f:e3'''
 N = int(''.join(N.split()).replace(':', ''), 16)
 g = 2        # A generator modulo N
 
 k = H(N, g)  # Multiplier parameter (k=3 in legacy SRP-6)
 
 print("#. H, N, g, and k are known beforehand to both client and server:")
 global_print("H", "N", "g", "k")
 
 print("0. server stores (I, s, v) in its password database")
 
 # the server must first generate the password verifier
 I = "person"         # Username
 p = "password1234"   # Password
 s = cryptrand(64)    # Salt for the user
 x = H(s, I, p)       # Private key
 v = pow(g, x, N)     # Password verifier
 global_print("I", "p", "s", "x", "v")
 
 print("1. client sends username I and public ephemeral value A to the server")
 a = cryptrand()
 A = pow(g, a, N)
 global_print("I", "A")  # client->server (I, A)
 
 print("2. server sends user's salt s and public ephemeral value B to client")
 b = cryptrand()
 B = (k * v + pow(g, b, N)) % N
 global_print("s", "B")  # server->client (s, B)
 
 print("3. client and server calculate the random scrambling parameter")
 u = H(A, B)  # Random scrambling parameter
 global_print("u")
 
 print("4. client computes session key")
 x = H(s, I, p)
 S_c = pow(B - k * pow(g, x, N), a + u * x, N)
 K_c = H(S_c)
 global_print("S_c", "K_c")
 
 print("5. server computes session key")
 S_s = pow(A * pow(v, u, N), b, N)
 K_s = H(S_s)
 global_print("S_s", "K_s")
 
 print("6. client sends proof of session key to server")
 M_c = H(H(N) ^ H(g), H(I), s, A, B, K_c)
 global_print("M_c")
 # client->server (M_c) ; server verifies M_c
 
 print("7. server sends proof of session key to client")
 M_s = H(A, M_c, K_s)
 global_print("M_s")
 # server->client (M_s) ;  client verifies M_s
Implementations

OpenSSL version 1.0.1 or later.
TLS-SRP is a set of ciphersuites for transport layer security that uses SRP.
srp-client SRP-6a implementation in Javascript (compatible with RFC 5054), open source, MPL licensed.
The JavaScript Crypto Library includes a JavaScript implementation of the SRP protocol, open source, BSD licensed.
Gnu Crypto provide a Java implementation licensed under the GNU General Public License with the "library exception", which permits its use as a library in conjunction with non-Free software.
The Legion of the Bouncy Castle provides Java and C# implementations under the MIT License.
Nimbus SRP is a Java library providing a verifier generator, client and server-side sessions. Includes interfaces for custom password key, client and server evidence message routines. No external dependencies. Released under the Apache 2.0 license.
srplibcpp is a C++ implement base on MIRACL.
DragonSRP is a C++ modular implementation currently works with OpenSSL
Json2Ldap provides SRP-6a authentication to LDAP directory servers.
csrp SRP-6a implementation in C.
Crypt-SRP SRP-6a implementation in Perl.
pysrp SRP-6a implementation in Python (compatible with csrp).
Meteor web framework's Accounts system implements SRP for password authentication.
srp-rb SRP-6a implementation in Ruby
srp-6a-demo SRP-6a implementation in PHP and JavaScript
thinbus-srp-js SRP-6a implementation in JavaScript. Comes with compatible Java classes which use Nimbus SRP a demonstration app using Spring Security. There is also a demonstration application performing authentication to a PHP server. Released under the Apache License.

References


External links


SRP License—BSD like open source.
US6539479 - SRP Patent (expires July 2018)

Manual pages

pppd(8): Point-to-Point Protocol Daemon


RFCs

RFC 2944 - Telnet Authentication: SRP
RFC 2945 - The SRP Authentication and Key Exchange System
RFC 3720 - Internet Small Computer Systems Interface (iSCSI)
RFC 3723 - Securing Block Storage Protocols over IP
RFC 3669 - Guidelines for Working Groups on Intellectual Property Issues
RFC 5054 - Using the Secure Remote Password (SRP) Protocol for TLS Authentication

Other links

IEEE 1363
SRP Intellectual Property Slides (Dec 2001 - possible deprecated) The EKE patents mentioned expired in 2011 and 2013.

"
Category:Key-agreement protocols Category:Password authentication




 RFC 5054
 Draft.





