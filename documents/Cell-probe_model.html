<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1053">Cell-probe model</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cell-probe model</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, the <strong>cell-probe model</strong> is a model of computation similar to the <a href="Random-access_machine" title="wikilink">Random-access machine</a>, except that all operations are free except memory access. This model is useful for proving lower bounds of algorithms for data structure problems.</p>
<h2 id="overview">Overview</h2>

<p>The cell-probe model is a minor modification of the <a href="Random-access_machine" title="wikilink">Random-access machine</a> model, itself a minor modification of the <a href="Counter_machine" title="wikilink">Counter machine</a> <a href="Counter-machine_model" title="wikilink">model</a>, in which computational cost is only assigned to accessing units of memory called cells.</p>

<p>In this model, computation is framed as a problem of querying a set of memory cells. The problem has two phases: the preprocessing phase and the query phase. The input to the first phase, the preprocessing phase, is a set of data from which to build some structure from memory cells. The input to the second phase, the query phase, is a query datum. The problem is to determine if the query datum was included in the original input data set. Operations are free except to access memory cells.</p>

<p>This model is useful in the analysis of data structures. In particular, the model clearly shows a minimum number of memory accesses to solve a problem in which there is stored data on which we would like to run some query. An example of such a problem is the dynamic <a href="partial_sum" title="wikilink">partial sum</a> problem.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="history">History</h2>

<p>In <a href="Andrew_Yao" title="wikilink">Andrew Yao</a>'s 1981 paper "Should Tables Be Sorted?",<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Andrew described the cell-probe model and used it to give a minimum number of memory cell "probes" or accesses necessary to determine whether a given query datum exists within a table stored in memory.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Given a set of data 

<math display="inline" id="Cell-probe_model:0">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 construct a structure consisting of 

<math display="inline" id="Cell-probe_model:1">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 memory cells, each able to store 

<math display="inline" id="Cell-probe_model:2">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 bits. Then when given a query element 

<math display="inline" id="Cell-probe_model:3">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 determine whether 

<math display="inline" id="Cell-probe_model:4">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in S
  </annotation>
 </semantics>
</math>

 with correctness 

<math display="inline" id="Cell-probe_model:5">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>ε</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\varepsilon
  </annotation>
 </semantics>
</math>

 by accessing 

<math display="inline" id="Cell-probe_model:6">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 memory cells. Such an algorithm is called an 

<math display="inline" id="Cell-probe_model:7">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

-error 

<math display="inline" id="Cell-probe_model:8">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

-probe algorithm using 

<math display="inline" id="Cell-probe_model:9">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 cells with word size 

<math display="inline" id="Cell-probe_model:10">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="notable-results">Notable results</h2>
<h3 id="dynamic-partial-sums">Dynamic Partial Sums</h3>

<p>The dynamic partial sum problem defines two operations 

<math display="inline" id="Cell-probe_model:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>k</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>k</ci>
    <ci>v</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (k,v)
  </annotation>
 </semantics>
</math>

 which conceptually operation sets the value in an array 

<math display="inline" id="Cell-probe_model:12">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 at index 

<math display="inline" id="Cell-probe_model:13">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 to be 

<math display="inline" id="Cell-probe_model:14">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Cell-probe_model:15">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (k)
  </annotation>
 </semantics>
</math>

 which returns the sum of the values in 

<math display="inline" id="Cell-probe_model:16">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 at indices 

<math display="inline" id="Cell-probe_model:17">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 through 

<math display="inline" id="Cell-probe_model:18">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. Such an implementation would take 

<math display="inline" id="Cell-probe_model:19">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

 time for  and 

<math display="inline" id="Cell-probe_model:20">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 time for .<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Instead, if the values are stored as leaves in a tree whose inner nodes store the values of the subtree rooted at that node. In this structure  requires 

<math display="inline" id="Cell-probe_model:21">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log n)
  </annotation>
 </semantics>
</math>

 time to update each node in the leaf to root path, and  similarly requires 

<math display="inline" id="Cell-probe_model:22">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log n)
  </annotation>
 </semantics>
</math>

 time to traverse the tree from leaf to root summing the values of all subtrees left of the query index.</p>

<p><a href="Mihai_Pătraşcu" title="wikilink">Mihai Pătraşcu</a> used the cell-probe model and an information transfer argument to show that the partial sums problem requires 

<math display="inline" id="Cell-probe_model:23">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega\left(\log n\right)
  </annotation>
 </semantics>
</math>

 time per operation.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="approximate-nearest-neighbor-searching">Approximate Nearest Neighbor Searching</h3>

<p>The exact <a href="Nearest_neighbor_search" title="wikilink">Nearest neighbor search</a> problem is to determine the closest in a set of input points to a given query point. An approximate version of this problem is often considered since many applications of this problem are in very high dimension spaces and solving the problem in high dimensions requires exponential time or space with respect to the dimension.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Chakrabarti and Regev proved that the approximate nearest neighbor search problem on the <a href="Hamming_distance#Special_properties" title="wikilink">Hamming cube</a> using polynomial storage and 

<math display="inline" id="Cell-probe_model:24">
 <semantics>
  <msup>
   <mi>d</mi>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d^{O(1)}
  </annotation>
 </semantics>
</math>

 word size requires a worst-case query time of 

<math display="inline" id="Cell-probe_model:25">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mi>log</mi>
       <mi>d</mi>
      </mrow>
     </mrow>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mi>log</mi>
        <mi>d</mi>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <divide></divide>
     <apply>
      <log></log>
      <apply>
       <log></log>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <log></log>
      <apply>
       <log></log>
       <apply>
        <log></log>
        <ci>d</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega\left(\frac{\log\log d}{\log\log\log d}\right)
  </annotation>
 </semantics>
</math>

. This proof used the cell-probe model and information theoretic techniques for communication complexity.</p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://xlinux.nist.gov/dads//HTML/cellProbeModel.html">NIST's Dictionary of Algorithms and Data Structures entry on the cell-probe model</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Register_machines" title="wikilink">Category:Register machines</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
</ol>
</section>
</body>
</html>
