<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1290">N-gram</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>N-gram</h1>
<hr/>

<p>In the fields of <a href="computational_linguistics" title="wikilink">computational linguistics</a> and <a class="uri" href="probability" title="wikilink">probability</a>, an <strong><em>n</em>-gram</strong> is a contiguous sequence of <em>n</em> items from a given <a class="uri" href="sequence" title="wikilink">sequence</a> of text or speech. The items can be <a href="phoneme" title="wikilink">phonemes</a>, <a href="syllable" title="wikilink">syllables</a>, <a href="letter_(alphabet)" title="wikilink">letters</a>, <a href="word" title="wikilink">words</a> or <a href="base_pairs" title="wikilink">base pairs</a> according to the application. The <em>n</em>-grams typically are collected from a <a href="text_corpus" title="wikilink">text</a> or <a href="speech_corpus" title="wikilink">speech corpus</a>. When the items are words, 

<math display="inline" id="N-gram:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-grams may also be called <strong>shingles</strong>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>An <em>n</em>-gram of size 1 is referred to as a "unigram"; size 2 is a "<a class="uri" href="bigram" title="wikilink">bigram</a>" (or, less commonly, a "digram"); size 3 is a "<a class="uri" href="trigram" title="wikilink">trigram</a>". Larger sizes are sometimes referred to by the value of <em>n</em>, e.g., "four-gram", "five-gram", and so on.</p>
<h2 id="applications">Applications</h2>

<p>An <strong><em>n</em>-gram model</strong> is a type of probabilistic <a href="language_model" title="wikilink">language model</a> for predicting the next item in such a sequence in the form of a (<em>n</em> − 1)–order <a href="Markov_chain" title="wikilink">Markov model</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <em>n</em>-gram models are now widely used in <a class="uri" href="probability" title="wikilink">probability</a>, <a href="communication_theory" title="wikilink">communication theory</a>, <a href="computational_linguistics" title="wikilink">computational linguistics</a> (for instance, statistical <a href="natural_language_processing" title="wikilink">natural language processing</a>), <a href="computational_biology" title="wikilink">computational biology</a> (for instance, biological <a href="sequence_analysis" title="wikilink">sequence analysis</a>), and <a href="data_compression" title="wikilink">data compression</a>. The two core advantages of <em>n</em>-gram models (and algorithms that use them) are relative simplicity and the ability to scale up – by simply increasing <em>n</em> a model can be used to store more context with a well-understood <a href="space–time_tradeoff" title="wikilink">space–time tradeoff</a>, enabling small experiments to scale up very efficiently.</p>
<h2 id="examples">Examples</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Figure 1 <em>n</em>-gram examples from various disciplines</p></td>
<td style="text-align: left;">
<p>Field</p></td>
<td style="text-align: left;">
<p>Unit</p></td>
<td style="text-align: left;">
<p>Sample sequence</p></td>
<td style="text-align: left;">
<p>1-gram sequence</p></td>
<td style="text-align: left;">
<p>2-gram sequence</p></td>
<td style="text-align: left;">
<p>3-gram sequence</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Vernacular name</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>unigram</p></td>
<td style="text-align: left;">
<p>bigram</p></td>
<td style="text-align: left;">
<p>trigram</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Order of resulting <a href="Markov_model" title="wikilink">Markov model</a></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Protein_sequencing" title="wikilink">Protein sequencing</a></p></td>
<td style="text-align: left;">
<p><a href="amino_acid" title="wikilink">amino acid</a></p></td>
<td style="text-align: left;">
<p>… Cys-Gly-Leu-Ser-Trp …</p></td>
<td style="text-align: left;">
<p>…, Cys, Gly, Leu, Ser, Trp, …</p></td>
<td style="text-align: left;">
<p>…, Cys-Gly, Gly-Leu, Leu-Ser, Ser-Trp, …</p></td>
<td style="text-align: left;">
<p>…, Cys-Gly-Leu, Gly-Leu-Ser, Leu-Ser-Trp, …</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="DNA_sequencing" title="wikilink">DNA sequencing</a></p></td>
<td style="text-align: left;">
<p><a href="base_pair" title="wikilink">base pair</a></p></td>
<td style="text-align: left;">
<p>…AGCTTCGA…</p></td>
<td style="text-align: left;">
<p>…, A, G, C, T, T, C, G, A, …</p></td>
<td style="text-align: left;">
<p>…, AG, GC, CT, TT, TC, CG, GA, …</p></td>
<td style="text-align: left;">
<p>…, AGC, GCT, CTT, TTC, TCG, CGA, …</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Computational_linguistics" title="wikilink">Computational linguistics</a></p></td>
<td style="text-align: left;">
<p><a href="Character_(computing)" title="wikilink">character</a></p></td>
<td style="text-align: left;">
<p>…to_be_or_not_to_be…</p></td>
<td style="text-align: left;">
<p>…, t, o, _, b, e, _, o, r, _, n, o, t, _, t, o, _, b, e, …</p></td>
<td style="text-align: left;">
<p>…, to, o_, _b, be, e_, _o, or, r_, _n, no, ot, t_, _t, to, o_, _b, be, …</p></td>
<td style="text-align: left;">
<p>…, to_, o_b, _be, be_, e_o, _or, or_, r_n, _no, not, ot_, t_t, _to, to_, o_b, _be, …</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Computational_linguistics" title="wikilink">Computational linguistics</a></p></td>
<td style="text-align: left;">
<p><a class="uri" href="word" title="wikilink">word</a></p></td>
<td style="text-align: left;">
<p>… to be or not to be …</p></td>
<td style="text-align: left;">
<p>…, to, be, or, not, to, be, …</p></td>
<td style="text-align: left;">
<p>…, to be, be or, or not, not to, to be, …</p></td>
<td style="text-align: left;">
<p>…, to be or, be or not, or not to, not to be, …</p></td>
</tr>
</tbody>
</table>

<p>Figure 1 shows several example sequences and the corresponding 1-gram, 2-gram and 3-gram sequences.</p>

<p>Here are further examples; these are word-level 3-grams and 4-grams (and counts of the number of times they appeared) from the Google <em>n</em>-gram corpus.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ul>
<li>ceramics collectables collectibles (55)</li>
<li>ceramics collectables fine (130)</li>
<li>ceramics collected by (52)</li>
<li>ceramics collectible pottery (50)</li>
<li>ceramics collectibles cooking (45)</li>
</ul>

<p>4-grams</p>
<ul>
<li>serve as the incoming (92)</li>
<li>serve as the incubator (99)</li>
<li>serve as the independent (794)</li>
<li>serve as the index (223)</li>
<li>serve as the indication (72)</li>
<li>serve as the indicator (120)</li>
</ul>
<h2 id="n-gram-models"><em>n</em>-gram models</h2>

<p>An <strong><em>n</em>-gram model</strong> models sequences, notably natural languages, using the statistical properties of <em>n</em>-grams.</p>

<p>This idea can be traced to an experiment by <a href="Claude_Shannon" title="wikilink">Claude Shannon</a>'s work in <a href="information_theory" title="wikilink">information theory</a>. Shannon posed the question: given a sequence of letters (for example, the sequence "for ex"), what is the <a class="uri" href="likelihood" title="wikilink">likelihood</a> of the next letter? From training data, one can derive a <a href="probability_distribution" title="wikilink">probability distribution</a> for the next letter given a history of size 

<math display="inline" id="N-gram:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

: <em>a</em> = 0.4, <em>b</em> = 0.00001, <em>c</em> = 0, ....; where the probabilities of all possible "next-letters" sum to 1.0...</p>

<p>More concisely, an <em>n</em>-gram model predicts 

<math display="inline" id="N-gram:2">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 based on 

<math display="inline" id="N-gram:3">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i-(n-1)},\dots,x_{i-1}
  </annotation>
 </semantics>
</math>

. In probability terms, this is 

<math display="inline" id="N-gram:4">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{i}\mid x_{i-(n-1)},\dots,x_{i-1})
  </annotation>
 </semantics>
</math>

. When used for <a href="language_model" title="wikilink">language modeling</a>, independence assumptions are made so that each word depends only on the last <em>n</em> − 1 words. This <a href="Markov_model" title="wikilink">Markov model</a> is used as an approximation of the true underlying language. This assumption is important because it massively simplifies the problem of learning the language model from data. In addition, because of the open nature of language, it is common to group words unknown to the language model together.</p>

<p>Note that in a simple <em>n</em>-gram language model, the probability of a word, conditioned on some number of previous words (one word in a bigram model, two words in a trigram model, etc.) can be described as following a <a href="categorical_distribution" title="wikilink">categorical distribution</a> (often imprecisely called a "<a href="multinomial_distribution" title="wikilink">multinomial distribution</a>").</p>

<p>In practice, the probability distributions are smoothed by assigning non-zero probabilities to unseen words or <em>n</em>-grams; see <a href="N-gram#Smoothing_techniques" title="wikilink">smoothing techniques</a>.</p>
<h2 id="applications-and-considerations">Applications and considerations</h2>

<p><em>n</em>-gram models are widely used in statistical <a href="natural_language_processing" title="wikilink">natural language processing</a>. In <a href="speech_recognition" title="wikilink">speech recognition</a>, <a class="uri" href="phonemes" title="wikilink">phonemes</a> and sequences of phonemes are modeled using a <em>n</em>-gram distribution. For parsing, words are modeled such that each <em>n</em>-gram is composed of <em>n</em> words. For <a href="language_identification" title="wikilink">language identification</a>, sequences of <a href="Character_(symbol)" title="wikilink">characters</a>/<a href="grapheme" title="wikilink">graphemes</a> (<em>e.g.</em>, <a href="Letter_(alphabet)" title="wikilink">letters of the alphabet</a>) are modeled for different languages.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> For sequences of characters, the 3-grams (sometimes referred to as "trigrams") that can be generated from "good morning" are "goo", "ood", "od ", "d m", " mo", "mor" and so forth (sometimes the beginning and end of a text are modeled explicitly, adding "__g", "_go", "ng_", and "g__"). For sequences of words, the trigrams that can be generated from "the dog smelled like a skunk" are "# the dog", "the dog smelled", "dog smelled like", "smelled like a", "like a skunk" and "a skunk #". Some  practitioners preprocess strings to remove spaces, most  simply collapse <a href="Whitespace_character" title="wikilink">whitespace</a> to a single space while preserving paragraph marks. Punctuation is also commonly reduced or removed by preprocessing. <em>n</em>-grams can also be used for sequences of words or almost any type of data. For example, they have been used for extracting features for clustering large sets of satellite earth images and for determining what part of the Earth a particular image came from.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> They have also been very successful as the first pass in genetic sequence search and in the identification of the species from which short sequences of DNA originated.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p><em>n</em>-gram models are often criticized because they lack any explicit representation of long range dependency. (In fact, it was <a href="Noam_Chomsky" title="wikilink">Chomsky</a>'s critique of <a href="Markov_model" title="wikilink">Markov models</a> in the late 1950s that caused their virtual disappearance from <a href="natural_language_processing" title="wikilink">natural language processing</a>, along with statistical methods in general, until well into the 1980s.) This is because the only explicit dependency range is (<em>n</em> − 1) tokens for an <em>n</em>-gram model, and since natural languages incorporate many cases of unbounded dependencies (such as <a class="uri" href="wh-movement" title="wikilink">wh-movement</a>), this means that an <em>n</em>-gram model cannot in principle distinguish unbounded dependencies from noise (since long range correlations drop exponentially with distance for any Markov model). For this reason, <em>n</em>-gram models have not made much impact on linguistic theory, where part of the explicit goal is to model such dependencies.</p>

<p>Another criticism that has been made is that Markov models of language, including <em>n</em>-gram models, do not explicitly capture the performance/competence distinction discussed by Chomsky. This is because <em>n</em>-gram models are not designed to model linguistic knowledge as such, and make no claims to being (even potentially) complete models of linguistic knowledge; instead, they are used in practical applications.</p>

<p>In practice, <em>n</em>-gram models have been shown to be extremely effective in modeling language data, which is a core component in modern statistical <a href="natural_language_processing" title="wikilink">language</a> applications. Most modern applications that rely on <em>n</em>-gram based models, such as <a href="machine_translation" title="wikilink">machine translation</a> applications, do not rely exclusively on such models; instead, they typically also incorporate <a href="Bayesian_inference" title="wikilink">Bayesian inference</a>. Modern statistical models are typically made up of two parts, a <a href="prior_distribution" title="wikilink">prior distribution</a> describing the inherent likelihood of a possible result and a <a href="likelihood_function" title="wikilink">likelihood function</a> used to assess the compatibility of a possible result with observed data. When a language model is used, it is used as part of the prior distribution (e.g. to gauge the inherent "goodness" of a possible translation), and even then it is often not the only component in this distribution. Handcrafted features of various sorts are also used, for example variables that represent the position of a word in a sentence or the general topic of discourse. In addition, features based on the structure of the potential result, such as syntactic considerations, are often used. Such features are also used as part of the likelihood function, which makes use of the observed data. Conventional linguistic theory can be incorporated in these features (although in practice, it is rare that features specific to generative or other particular theories of grammar are incorporated, as <a href="computational_linguistics" title="wikilink">computational linguists</a> tend to be "agnostic" towards individual theories of grammar).</p>
<h2 id="n-grams-for-approximate-matching"><em>n</em>-grams for approximate matching</h2>

<p><em>n</em>-grams can also be used for efficient approximate matching. By converting a sequence of items to a set of <em>n</em>-grams, it can be embedded in a <a href="vector_space" title="wikilink">vector space</a>, thus allowing the sequence to be compared to other sequences in an efficient manner. For example, if we convert strings with only letters in the English alphabet into single character 3-grams, we get a 

<math display="inline" id="N-gram:5">
 <semantics>
  <msup>
   <mn>26</mn>
   <mn>3</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">26</cn>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   26^{3}
  </annotation>
 </semantics>
</math>

-dimensional space (the first dimension measures the number of occurrences of "aaa", the second "aab", and so forth for all possible combinations of three letters). Using this representation, we lose information about the string. For example, both the strings "abc" and "bca" give rise to exactly the same 2-gram "bc" (although {"ab", "bc"} is clearly not the same as {"bc", "ca"}). However, we know empirically that if two strings of real text have a similar vector representation (as measured by <a href="cosine_similarity" title="wikilink">cosine distance</a>) then they are likely to be similar. Other metrics have also been applied to vectors of <em>n</em>-grams with varying, sometimes better, results. For example <a href="z-score" title="wikilink">z-scores</a> have been used to compare documents by examining how many standard deviations each <em>n</em>-gram differs from its mean occurrence in a large collection, or <a href="text_corpus" title="wikilink">text corpus</a>, of documents (which form the "background" vector). In the event of small counts, the <a class="uri" href="g-score" title="wikilink">g-score</a> may give better results for comparing alternative models.</p>

<p>It is also possible to take a more principled approach to the statistics of <em>n</em>-grams, modeling similarity as the likelihood that two strings came from the same source directly in terms of a problem in <a href="Bayesian_inference" title="wikilink">Bayesian inference</a>.</p>

<p><em>n</em>-gram-based searching can also be used for <a href="plagiarism_detection" title="wikilink">plagiarism detection</a>.</p>
<h2 id="other-applications">Other applications</h2>

<p><em>n</em>-grams find use in several areas of computer science, <a href="computational_linguistics" title="wikilink">computational linguistics</a>, and applied mathematics.</p>

<p>They have been used to:</p>
<ul>
<li>design <a href="kernel_trick" title="wikilink">kernels</a> that allow <a href="machine_learning" title="wikilink">machine learning</a> algorithms such as <a href="support_vector_machine" title="wikilink">support vector machines</a> to learn from string data</li>
<li>find likely candidates for the correct spelling of a misspelled word</li>
<li>improve compression in <a href="data_compression" title="wikilink">compression algorithms</a> where a small area of data requires <em>n</em>-grams of greater length</li>
<li>assess the probability of a given word sequence appearing in text of a language of interest in pattern recognition systems, <a href="speech_recognition" title="wikilink">speech recognition</a>, OCR (<a href="optical_character_recognition" title="wikilink">optical character recognition</a>), <a href="Intelligent_Character_Recognition" title="wikilink">Intelligent Character Recognition</a> (<a href="Intelligent_character_recognition" title="wikilink">ICR</a>), <a href="machine_translation" title="wikilink">machine translation</a> and similar applications</li>
<li>improve retrieval in <a href="information_retrieval" title="wikilink">information retrieval</a> systems when it is hoped to find similar "documents" (a term for which the conventional meaning is sometimes stretched, depending on the data set) given a single query document and a database of reference documents</li>
<li>improve retrieval performance in genetic sequence analysis as in the <a class="uri" href="BLAST" title="wikilink">BLAST</a> family of programs</li>
<li>identify the language a text is in or the species a small sequence of DNA was taken from</li>
<li>predict letters or words at random in order to create text, as in the <a href="dissociated_press" title="wikilink">dissociated press</a> algorithm.</li>
</ul>
<h2 id="bias-versus-variance-trade-off">Bias-versus-variance trade-off</h2>

<p>What goes into picking the <em>n</em> for the <em>n</em>-gram?</p>

<p>With <em>n</em>-gram models it is necessary to find the right trade off between the stability of the estimate against its appropriateness. This means that trigram (i.e. triplets of words) is a common choice with large training corpora (millions of words), whereas a bigram is often used with smaller ones.</p>
<h3 id="smoothing-techniques">Smoothing techniques</h3>

<p>There are problems of balance weight between <em>infrequent grams</em> (for example, if a proper name appeared in the training data) and <em>frequent grams</em>. Also, items not seen in the training data will be given a <a class="uri" href="probability" title="wikilink">probability</a> of 0.0 without <a class="uri" href="smoothing" title="wikilink">smoothing</a>. For unseen but plausible data from a sample, one can introduce <a href="pseudocount" title="wikilink">pseudocounts</a>. Pseudocounts are generally motivated on Bayesian grounds.</p>

<p>In practice it is necessary to <em>smooth</em> the probability distributions by also assigning non-zero probabilities to unseen words or <em>n</em>-grams. The reason is that models derived directly from the <em>n</em>-gram frequency counts have severe problems when confronted with any <em>n</em>-grams that have not explicitly been seen before -- <a href="PPM_compression_algorithm" title="wikilink">the zero-frequency problem</a>. Various smoothing methods are used, from simple "add-one" (Laplace) smoothing (assign a count of 1 to unseen <em>n</em>-grams; see <a href="Rule_of_succession" title="wikilink">Rule of succession</a>) to more sophisticated models, such as <a href="Good–Turing_discounting" title="wikilink">Good–Turing discounting</a> or <a href="Katz's_back-off_model" title="wikilink">back-off models</a>. Some of these methods are equivalent to assigning a <a href="prior_distribution" title="wikilink">prior distribution</a> to the probabilities of the <em>n</em>-grams and using <a href="Bayesian_inference" title="wikilink">Bayesian inference</a> to compute the resulting <a href="posterior_distribution" title="wikilink">posterior</a> <em>n</em>-gram probabilities. However, the more sophisticated smoothing models were typically not derived in this fashion, but instead through independent considerations.</p>
<ul>
<li><a href="Linear_interpolation" title="wikilink">Linear interpolation</a> (e.g., taking the <a href="weighted_mean" title="wikilink">weighted mean</a> of the unigram, bigram, and trigram)</li>
<li><a href="Good–Turing_frequency_estimation" title="wikilink">Good–Turing</a> discounting</li>
<li><a href="Witten–Bell_discounting" title="wikilink">Witten–Bell discounting</a></li>
<li><a href="Additive_smoothing" title="wikilink">Lidstone's smoothing</a></li>
<li><a href="Katz's_back-off_model" title="wikilink">Katz's back-off model</a> (trigram)</li>
<li><a href="Kneser–Ney_smoothing" title="wikilink">Kneser–Ney smoothing</a></li>
</ul>
<h3 id="skip-gram">Skip-gram</h3>

<p>In the field of <a href="computational_linguistics" title="wikilink">computational linguistics</a>, in particular <a href="language_model" title="wikilink">language modeling</a>, <strong>skip-grams</strong><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> are a generalization of <em>n</em>-grams in which the components (typically words) need not be consecutive in the text under consideration, but may leave gaps that are <em>skipped</em> over.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> They provide one way of overcoming the <a href="data_sparsity_problem" title="wikilink">data sparsity problem</a> found with conventional <em>n</em>-gram analysis.</p>

<p>Formally, an 

<math display="inline" id="N-gram:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-gram is a consecutive subsequence of length 

<math display="inline" id="N-gram:7">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 of some sequence of tokens 

<math display="inline" id="N-gram:8">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi mathvariant="normal">₁</mi>
   <mi mathvariant="normal">…</mi>
   <mi>w</mi>
   <mi>ₙ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>normal-₁</ci>
    <ci>normal-…</ci>
    <ci>w</ci>
    <ci>ₙ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w₁…wₙ
  </annotation>
 </semantics>
</math>

. A 

<math display="inline" id="N-gram:9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-skip-

<math display="inline" id="N-gram:10">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-gram is a length-

<math display="inline" id="N-gram:11">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 subsequence where the components occur at distance at most 

<math display="inline" id="N-gram:12">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 from each other.</p>

<p>For example, in the input text:</p>
<dl>
<dd><em>the rain in Spain falls mainly on the plain</em>
</dd>
</dl>

<p>the set of 1-skip-2-grams includes all the bigrams (2-grams), and in addition the subsequences</p>
<dl>
<dd><em>the in</em>, <em>rain Spain</em>, <em>in falls</em>, <em>Spain mainly</em>, <em>falls on</em>, <em>mainly the</em>, and <em>on plain</em>.
</dd>
</dl>

<p>Recently, Mikolov et al. (2013) have demonstrated that skip-gram language models can be trained so that it is possible to do ″word arithmetic". In their model, for example the <em>n</em>-gram vector expression</p>
<dl>
<dd><em>vector("king") − vector("man") + vector("woman")</em>
</dd>
</dl>

<p>evaluates very close to vector(<em>"queen"</em>).<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="syntactic-n-grams">Syntactic <em>n</em>-grams</h2>

<p>Syntactic <em>n</em>-grams are <em>n</em>-grams defined by paths in syntactic dependency or constituent trees rather than the linear structure of the text.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> For example, the sentence "economic news has little effect on financial markets" can be transformed to syntactic <em>n</em>-grams following the tree structure of its <a href="Dependency_grammar" title="wikilink">dependency relations</a>: news-economic, effect-little, effect-on-markets-financial.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Syntactic <em>n</em>-grams are intended to reflect syntactic structure more faithfully than linear <em>n</em>-grams, and have many of the same applications, especially as features in a Vector Space Model. Syntactic <em>n</em>-grams for certain tasks gives better results than the use of standard <em>n</em>-grams, for example, for authorship attribution.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Collocation" title="wikilink">Collocation</a></li>
<li><a href="Hidden_Markov_model" title="wikilink">Hidden Markov model</a></li>
<li><a class="uri" href="n-tuple" title="wikilink">n-tuple</a></li>
<li><a class="uri" href="k-mer" title="wikilink">k-mer</a></li>
<li><a href="String_kernel" title="wikilink">String kernel</a></li>
<li><a class="uri" href="MinHash" title="wikilink">MinHash</a></li>
<li><a href="Feature_extraction" title="wikilink">Feature extraction</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Christopher D. Manning, Hinrich Schütze, <em>Foundations of Statistical Natural Language Processing</em>, MIT Press: 1999. ISBN 0-262-13360-1.</li>
<li></li>
<li>Frederick J. Damerau, <em>Markov Models and Linguistic Theory</em>. Mouton. The Hague, 1971.</li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://ngrams.googlelabs.com/">Google's Google Book <em>n</em>-gram viewer</a> and <a href="http://googleresearch.blogspot.com/2006/08/all-our-n-gram-are-belong-to-you.html">Web <em>n</em>-grams database</a> (September 2006)</li>
<li><a href="http://research.microsoft.com/web-ngram">Microsoft's web <em>n</em>-grams service</a></li>
<li><a href="http://www.ngrams.info/">1,000,000 most frequent 2,3,4,5-grams from the 425 million word </a><a href="Corpus_of_Contemporary_American_English" title="wikilink">Corpus of Contemporary American English</a></li>
<li><a href="http://www.peachnote.com/">Peachnote's music ngram viewer</a></li>
<li><a href="http://www.w3.org/TR/ngram-spec/">Stochastic Language Models (<em>n</em>-Gram) Specification</a> (W3C)</li>
<li><a href="http://www.cs.columbia.edu/~mcollins/courses/nlp2011/notes/lm.pdf">Michael Collin's notes on <em>n</em>-Gram Language Models</a></li>
</ul>

<p>"</p>

<p><a href="Category:Natural_language_processing" title="wikilink">Category:Natural language processing</a> <a href="Category:Computational_linguistics" title="wikilink">Category:Computational linguistics</a> <a href="Category:Language_modeling" title="wikilink">Category:Language modeling</a> <a href="Category:Speech_recognition" title="wikilink">Category:Speech recognition</a> <a href="Category:Corpus_linguistics" title="wikilink">Category:Corpus linguistics</a> <a href="Category:Probabilistic_models" title="wikilink">Category:Probabilistic models</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="https://class.coursera.org/nlp/lecture/17">https://class.coursera.org/nlp/lecture/17</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"> Technical Report MCCS 94-273<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a class="uri" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.1629">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.1629</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
</ol>
</section>
</body>
</html>
