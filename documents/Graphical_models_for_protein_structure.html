<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1949">Graphical models for protein structure</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Graphical models for protein structure</h1>
<hr/>

<p><a href="Graphical_model" title="wikilink">Graphical models</a> have become powerful frameworks for <a href="protein_structure_prediction" title="wikilink">protein structure prediction</a>, <a href="protein–protein_interaction" title="wikilink">protein–protein interaction</a> and <a href="Thermodynamic_free_energy" title="wikilink">free energy</a> calculations for protein structures. Using a graphical model to represent the protein structure allows the solution of many problems including secondary structure prediction, protein protein interactions, protein-drug interaction, and free energy calculations.</p>

<p>There are two main approaches to use graphical models in protein structure modeling. The first approach uses <a href="Discrete_mathematics" title="wikilink">discrete</a> variables for representing coordinates or <a href="dihedral_angle" title="wikilink">dihedral angles</a> of the protein structure. The variables are originally all continuous values and, to transform them into discrete values, a discretization process is typically applied. The second approach uses continuous variables for the coordinates or dihedral angles.</p>
<h2 id="discrete-graphical-models-for-protein-structure">Discrete graphical models for protein structure</h2>

<p><a href="Markov_random_field" title="wikilink">Markov random fields</a>, also known as undirected graphical models are common representations for this problem. Given an <a href="undirected_graph" title="wikilink">undirected graph</a> <em>G</em> = (<em>V</em>, <em>E</em>), a set of <a href="random_variable" title="wikilink">random variables</a> <em>X</em> = (<em>X</em><sub><em>v</em></sub>)<sub><em>v</em> ∈ <em>V</em></sub> indexed by <em>V</em>, form a Markov random field with respect to <em>G</em> if they satisfy the pairwise Markov property:</p>
<ul>
<li>any two non-adjacent variables are <a href="conditional_independence" title="wikilink">conditionally independent</a> given all other variables:</li>
</ul>

<p>

<math display="block" id="Graphical_models_for_protein_structure:0">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>u</mi>
   </msub>
   <mo rspace="0pt">⟂</mo>
   <mo>⟂</mo>
   <msub>
    <mi>X</mi>
    <mi>v</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>V</mi>
     <mo>∖</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </msub>
   <mtext>if</mtext>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>∉</mo>
   <mi>E</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>u</ci>
    </apply>
    <csymbol cd="latexml">perpendicular-to</csymbol>
    <csymbol cd="latexml">perpendicular-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>v</ci>
    </apply>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <setdiff></setdiff>
      <ci>V</ci>
      <set>
       <ci>u</ci>
       <ci>v</ci>
      </set>
     </apply>
    </apply>
    <ci></ci>
    <mtext>if</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <notin></notin>
    <csymbol cd="unknown">E</csymbol>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{u}\perp\!\!\!\perp X_{v}|X_{V\setminus\{u,v\}}\quad\text{if }\{u,v\}\notin E.
  </annotation>
 </semantics>
</math>

</p>

<p>In the discrete model, the continuous variables are discretized into a set of favorable discrete values. If the variables of choice are <a href="dihedral_angle" title="wikilink">dihedral angles</a>, the discretization is typically done by mapping each value to the corresponding <a class="uri" href="rotamer" title="wikilink">rotamer</a> conformation.</p>
<h3 id="model">Model</h3>

<p>Let <em>X</em> = {<em>X</em><sub><em>b</em></sub>, <em>X</em><sub><em>s</em></sub>} be the random variables representing the entire protein structure. <em>X</em><sub><em>b</em></sub> can be represented by a set of 3-d coordinates of the <a href="Backbone_chain" title="wikilink">backbone</a> atoms, or equivalently, by a sequence of <a href="bond_length" title="wikilink">bond lengths</a> and <a href="dihedral_angle" title="wikilink">dihedral angles</a>. The probability of a particular <a href="Protein_structure" title="wikilink">conformation</a> <em>x</em> can then be written as:</p>

<p>

<math display="block" id="Graphical_models_for_protein_structure:1">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>=</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi mathvariant="normal">Θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>b</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>b</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>s</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mi>b</mi>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">Θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="4.2pt">,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">Θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>b</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>b</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>s</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>b</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X=x|\Theta)=p(X_{b}=x_{b})p(X_{s}=x_{s}|X_{b},\Theta),\,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Graphical_models_for_protein_structure:2">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

 represents any parameters used to describe this model, including sequence information, temperature etc. Frequently the backbone is assumed to be rigid with a known conformation, and the problem is then transformed to a side-chain placement problem. The structure of the graph is also encoded in 

<math display="inline" id="Graphical_models_for_protein_structure:3">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>


. This structure shows which two variables are conditionally independent. As an example, side chain angles of two residues far apart can be independent given all other angles in the protein. To extract this structure, researchers use a distance threshold, and only pair of residues which are within that threshold are considered connected (i.e. have an edge between them).</p>

<p>Given this representation, the probability of a particular side chain conformation <em>x</em><sub><em>s</em></sub> given the backbone conformation <em>x</em><sub><em>b</em></sub> can be expressed as</p>

<p>

<math display="block" id="Graphical_models_for_protein_structure:4">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>s</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>X</mi>
     <mi>b</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>b</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>Z</mi>
   </mfrac>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi>c</mi>
     <mo>∈</mo>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>G</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </munder>
   <msub>
    <mi mathvariant="normal">Φ</mi>
    <mi>c</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>x</mi>
     <mi>s</mi>
     <mi>c</mi>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>x</mi>
     <mi>b</mi>
     <mi>c</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>s</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>b</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>b</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>Z</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <in></in>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>G</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Φ</ci>
     <ci>c</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>s</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>b</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X_{s}=x_{s}|X_{b}=x_{b})=\frac{1}{Z}\prod_{c\in C(G)}\Phi_{c}(x_{s}^{c},x_{b%
}^{c})
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>C</em>(<em>G</em>) is the set of all cliques in <em>G</em>, 

<math display="inline" id="Graphical_models_for_protein_structure:5">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is a <a href="function_(mathematics)" title="wikilink">potential function</a> defined over the variables, and <em>Z</em> is the <a href="partition_function_(mathematics)" title="wikilink">partition function</a>.</p>

<p>To completely characterize the MRF, it is necessary to define the potential function 

<math display="inline" id="Graphical_models_for_protein_structure:6">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

. To simplify, the cliques of a graph are usually restricted to only the cliques of size 2, which means the potential function is only defined over pairs of variables. In <a href="Goblin_System" title="wikilink">Goblin System</a>, this pairwise functions are defined as</p>

<p>

<math display="block" id="Graphical_models_for_protein_structure:7">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>x</mi>
      <mi>s</mi>
      <msub>
       <mi>i</mi>
       <mi>p</mi>
      </msub>
     </msubsup>
     <mo>,</mo>
     <msubsup>
      <mi>x</mi>
      <mi>b</mi>
      <msub>
       <mi>j</mi>
       <mi>q</mi>
      </msub>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mrow>
        <mrow>
         <mi>E</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msubsup>
           <mi>x</mi>
           <mi>s</mi>
           <msub>
            <mi>i</mi>
            <mi>p</mi>
           </msub>
          </msubsup>
          <mo>,</mo>
          <msubsup>
           <mi>x</mi>
           <mi>b</mi>
           <msub>
            <mi>j</mi>
            <mi>q</mi>
           </msub>
          </msubsup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>/</mo>
        <msub>
         <mi>K</mi>
         <mi>B</mi>
        </msub>
       </mrow>
       <mi>T</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <ci>q</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>E</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>s</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>i</ci>
            <ci>p</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>b</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>j</ci>
            <ci>q</ci>
           </apply>
          </apply>
         </interval>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>B</ci>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x_{s}^{i_{p}},x_{b}^{j_{q}})=\exp(-E(x_{s}^{i_{p}},x_{b}^{j_{q}})/K_{B}T)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Graphical_models_for_protein_structure:8">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>x</mi>
     <mi>s</mi>
     <msub>
      <mi>i</mi>
      <mi>p</mi>
     </msub>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>x</mi>
     <mi>b</mi>
     <msub>
      <mi>j</mi>
      <mi>q</mi>
     </msub>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(x_{s}^{i_{p}},x_{b}^{j_{q}})
  </annotation>
 </semantics>
</math>


 is the energy of interaction between rotamer state p of residue 

<math display="inline" id="Graphical_models_for_protein_structure:9">
 <semantics>
  <msubsup>
   <mi>X</mi>
   <mi>i</mi>
   <mi>s</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>i</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}^{s}
  </annotation>
 </semantics>
</math>

 and rotamer state q of residue 

<math display="inline" id="Graphical_models_for_protein_structure:10">
 <semantics>
  <msubsup>
   <mi>X</mi>
   <mi>j</mi>
   <mi>s</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>j</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{j}^{s}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Graphical_models_for_protein_structure:11">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{B}
  </annotation>
 </semantics>
</math>

 is the <a href="Boltzmann_constant" title="wikilink">Boltzmann constant</a>.</p>

<p>Using a PDB file, this model can be built over the protein structure. From this model free energy can be calculated.</p>
<h3 id="free-energy-calculation-belief-propagation">Free energy calculation: belief propagation</h3>

<p>It has been shown that the free energy of a system is calculated as</p>

<p>

<math display="block" id="Graphical_models_for_protein_structure:12">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mo>-</mo>
    <mrow>
     <mi>T</mi>
     <mi>S</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <minus></minus>
     <ci>E</ci>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=E-TS
  </annotation>
 </semantics>
</math>

</p>

<p>where E is the enthalpy of the system, T the temperature and S, the entropy. Now if we associate a probability with each state of the system, (p(x) for each conformation value, x), G can be rewritten as</p>

<p>

<math display="block" id="Graphical_models_for_protein_structure:13">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>x</mi>
     </munder>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>T</mi>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>x</mi>
      </munder>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>ln</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>x</ci>
       <ci>E</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>x</ci>
        <apply>
         <ln></ln>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\sum_{x}p(x)E(x)-T\sum_{x}p(x)\ln(p(x))\,
  </annotation>
 </semantics>
</math>

</p>

<p>Calculating p(x) on discrete graphs is done by the <a href="generalized_belief_propagation" title="wikilink">generalized belief propagation</a> algorithm. This algorithm calculates an <a class="uri" href="approximation" title="wikilink">approximation</a> to the probabilities, and it is not guaranteed to converge to a final value set. However, in practice, it has been shown to converge successfully in many cases.</p>
<h2 id="continuous-graphical-models-for-protein-structures">Continuous graphical models for protein structures</h2>

<p>Graphical models can still be used when the variables of choice are continuous. In these cases, the probability distribution is represented as a <a href="multivariate_probability_distribution" title="wikilink">multivariate probability distribution</a> over continuous variables. Each family of distribution will then impose certain properties on the graphical model. <a href="Multivariate_Gaussian_distribution" title="wikilink">Multivariate Gaussian distribution</a> is one of the most convenient distributions in this problem. The simple form of the probability, and the direct relation with the corresponding graphical model makes it a popular choice among researchers.</p>
<h3 id="gaussian-graphical-models-of-protein-structures">Gaussian graphical models of protein structures</h3>

<p>Gaussian graphical models are multivariate probability distributions encoding a network of dependencies among variables. Let 

<math display="inline" id="Graphical_models_for_protein_structure:14">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>θ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>θ</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>θ</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Θ</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>n</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta=[\theta_{1},\theta_{2},\dots,\theta_{n}]
  </annotation>
 </semantics>
</math>

 be a set of 

<math display="inline" id="Graphical_models_for_protein_structure:15">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 variables, such as 

<math display="inline" id="Graphical_models_for_protein_structure:16">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 <a href="dihedral_angles" title="wikilink">dihedral angles</a>, and let 

<math display="inline" id="Graphical_models_for_protein_structure:17">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Θ</mi>
    <mo>=</mo>
    <mi>D</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Θ</csymbol>
     <eq></eq>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\Theta=D)
  </annotation>
 </semantics>
</math>

 be the value of the <a href="probability_density_function" title="wikilink">probability density function</a> at a particular value <em>D</em>. A multivariate Gaussian graphical model defines this probability as follows:</p>

<p>

<math display="block" id="Graphical_models_for_protein_structure:18">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Θ</mi>
    <mo>=</mo>
    <mi>D</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>Z</mi>
   </mfrac>
   <mi>exp</mi>
   <mrow>
    <mo>{</mo>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>D</mi>
      <mo>-</mo>
      <mi>μ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>D</mi>
     <mo>-</mo>
     <mi>μ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Θ</csymbol>
     <eq></eq>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>Z</ci>
    </apply>
    <exp></exp>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <minus></minus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">D</csymbol>
       <minus></minus>
       <csymbol cd="unknown">μ</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">D</csymbol>
      <minus></minus>
      <csymbol cd="unknown">μ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\Theta=D)=\frac{1}{Z}\exp\left\{-\frac{1}{2}(D-\mu)^{T}\Sigma^{-1}(D-\mu)\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Graphical_models_for_protein_structure:19">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi mathvariant="normal">Σ</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <ci>normal-Σ</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=(2\pi)^{n/2}|\Sigma|^{1/2}
  </annotation>
 </semantics>
</math>

 is the closed form for the <a href="Partition_function_(mathematics)" title="wikilink">partition function</a>. The parameters of this distribution are 

<math display="inline" id="Graphical_models_for_protein_structure:20">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Graphical_models_for_protein_structure:21">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Graphical_models_for_protein_structure:22">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 is the vector of <a href="mean_values" title="wikilink">mean values</a> of each variable, and 

<math display="inline" id="Graphical_models_for_protein_structure:23">
 <semantics>
  <msup>
   <mi mathvariant="normal">Σ</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Σ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{-1}
  </annotation>
 </semantics>
</math>


, the inverse of the <a href="covariance_matrix" title="wikilink">covariance matrix</a>, also known as the <a href="precision_matrix" title="wikilink">precision matrix</a>. Precision matrix contains the pairwise dependencies between the variables. A zero value in 

<math display="inline" id="Graphical_models_for_protein_structure:24">
 <semantics>
  <msup>
   <mi mathvariant="normal">Σ</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Σ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{-1}
  </annotation>
 </semantics>
</math>

 means that conditioned on the values of the other variables, the two corresponding variable are independent of each other.</p>

<p>To learn the graph structure as a multivariate Gaussian graphical model, we can use either <a href="L-1_regularization" title="wikilink">L-1 regularization</a>, or <a href="neighborhood_selection" title="wikilink">neighborhood selection</a> algorithms. These algorithms simultaneously learn a graph structure and the edge strength of the connected nodes. An edge strength corresponds to the potential function defined on the corresponding two-node <a class="uri" href="clique" title="wikilink">clique</a>. We use a training set of a number of PDB structures to learn the 

<math display="inline" id="Graphical_models_for_protein_structure:25">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Graphical_models_for_protein_structure:26">
 <semantics>
  <msup>
   <mi mathvariant="normal">Σ</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Σ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{-1}
  </annotation>
 </semantics>
</math>

.</p>

<p>Once the model is learned, we can repeat the same step as in the discrete case, to get the density functions at each node, and use analytical form to calculate the free energy. Here, the <a href="Partition_function_(mathematics)" title="wikilink">partition function</a> already has a <a href="Closed-form_expression" title="wikilink">closed form</a>, so the <a class="uri" href="inference" title="wikilink">inference</a>, at least for the Gaussian graphical models is trivial. If the analytical form of the partition function is not available, <a href="particle_filtering" title="wikilink">particle filtering</a> or <a href="expectation_propagation" title="wikilink">expectation propagation</a> can be used to approximate <em>Z</em>, and then perform the inference and calculate free energy.</p>
<h2 id="references">References</h2>
<ul>
<li>Time Varying Undirected Graphs, Shuheng Zhou and John D. Lafferty and Larry A. Wasserman, COLT 2008</li>
<li>Free Energy Estimates of All-atom Protein Structures Using Generalized Belief Propagation, Hetunandan Kamisetty Eric P. Xing Christopher J. Langmead, RECOMB 2008</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a class="uri" href="http://www.liebertonline.com/doi/pdf/10.1089/cmb.2007.0131">http://www.liebertonline.com/doi/pdf/10.1089/cmb.2007.0131</a></li>
<li><a class="uri" href="http://www.learningtheory.org/colt2008/81-Zhou.pdf">http://www.learningtheory.org/colt2008/81-Zhou.pdf</a></li>
<li></li>
<li><a href="http://www.cs.cmu.edu/~jgc/publication/Predicting_Protein_Folds_ICML_2005.pdf">Predicting Protein Folds with Structural Repeats Using a Chain Graph Model</a></li>
</ul>

<p>"</p>

<p><a href="Category:Graphical_models" title="wikilink">Category:Graphical models</a> <a href="Category:Protein_methods" title="wikilink">Category:Protein methods</a> <a href="Category:Computational_chemistry" title="wikilink">Category:Computational chemistry</a></p>
</body>
</html>
