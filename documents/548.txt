   Weighted matroid      Weighted matroid   In combinatorics , a branch of mathematics , a weighted matroid is a matroid endowed with function with respect to which one can perform a greedy algorithm .  A weight function  w : E → R + for a matroid M =( E , I ) assigns a strictly positive weight to each element of E . We extend the function to subsets of E by summation; w ( A ) is the sum of w ( x ) over x in A . A matroid with an associated weight function is called a weighted matroid.  Spanning forest algorithms  As a simple example, say we wish to find the maximum spanning forest of a graph. That is, given a graph and a weight for each edge, find a forest containing every vertex and maximizing the total weight of the edges in the tree. This problem arises in some clustering applications. If we look at the definition of the forest matroid above, we see that the maximum spanning forest is simply the independent set with largest total weight — such a set must span the graph, for otherwise we can add edges without creating cycles. But how do we find it?  Finding a basis  There is a simple algorithm for finding a basis:   Initially let A be the empty set.  For each x in E   if A U {x} is independent, then set A to A U {x}.    The result is clearly an independent set. It is a maximal independent set because if B U {x} is not independent for some subset B of A, then A U {x} is not independent either (the contrapositive follows from the hereditary property ). Thus if we pass up an element, we'll never have an opportunity to use it later. We will generalize this algorithm to solve a harder problem.  Extension to optimal  An independent set of largest total weight is called an optimal set. Optimal sets are always bases, because if an edge can be added, it should be; this only increases the total weight. As it turns out, there is a trivial greedy algorithm for computing an optimal set of a weighted matroid. It works as follows:   Initially let A be the empty set.  For each x in E , taken in (monotonically) decreasing order by weight  if A U {x} is independent, then set A to A U {x}.    This algorithm finds a basis, since it is a special case of the above algorithm. It always chooses the element of largest weight that it can while preserving independence (thus the term "greedy"). This always produces an optimal set: suppose that it produces    A  =   {   e  1   ,   e  2   ,  …  ,   e  r   }       A    subscript  e  1    subscript  e  2   normal-…   subscript  e  r      A=\{e_{1},e_{2},\ldots,e_{r}\}   and that    B  =   {   f  1   ,   f  2   ,  …  ,   f  r   }       B    subscript  f  1    subscript  f  2   normal-…   subscript  f  r      B=\{f_{1},f_{2},\ldots,f_{r}\}   . Now for any   k   k   k   with    1  ≤  k  ≤  r        1  k       r     1\leq k\leq r   , consider open sets     O  1   =   {   e  1   ,  …  ,   e   k  -  1    }        subscript  O  1     subscript  e  1   normal-…   subscript  e    k  1       O_{1}=\{e_{1},\ldots,e_{k-1}\}   and     O  2   =   {   f  1   ,  …  ,   f  k   }        subscript  O  2     subscript  f  1   normal-…   subscript  f  k      O_{2}=\{f_{1},\ldots,f_{k}\}   . Since    O  1     subscript  O  1    O_{1}   is smaller than    O  2     subscript  O  2    O_{2}   , there is some element of    O  2     subscript  O  2    O_{2}   which can be put into    O  1     subscript  O  1    O_{1}   with the result still being independent. However    e  k     subscript  e  k    e_{k}   is an element of maximal weight that can be added to    O  1     subscript  O  1    O_{1}   to maintain independence. Thus    e  k     subscript  e  k    e_{k}   is of no smaller weight than some element of    O  2     subscript  O  2    O_{2}   , and hence    e  k     subscript  e  k    e_{k}   is of at least a large a weight as    f  k     subscript  f  k    f_{k}   . As this is true for all   k   k   k   ,   A   A   A   is weightier than   B   B   B   .  Complexity analysis  The easiest way to traverse the members of E in the desired order is to sort them. This requires O(|E|log|E|) time using a comparison sorting algorithm . We also need to test for each x whether A U {x} is independent; assuming independence tests require O(f(|E|)) time, the total time for the algorithm is O(|E|log|E| + |E|f(|E|)).  If we want to find a minimum spanning tree instead, we simply "invert" the weight function by subtracting it from a large constant. More specifically, let w min ( x ) = W - w ( x ), where W exceeds the total weight over all graph edges. Many more optimization problems about all sorts of matroids and weight functions can be solved in this trivial way, although in many cases more efficient algorithms can be found that exploit more specialized properties.  Matroid requirement  Note also that if we take a set   I   I   I   of "independent" sets which is a down-set but not a matroid, then the greedy algorithm will not always work. For then there are independent sets    I  1     subscript  I  1    I_{1}   and    I  2     subscript  I  2    I_{2}   with     |   I  1   |   <   |   I  2   |          subscript  I  1       subscript  I  2      |I_{1}|<|I_{2}|   , but such that for no    e  ∈    I  2   ∖   I  1        e     subscript  I  2    subscript  I  1      e\in I_{2}\setminus I_{1}   is     I  1   ∪  e       subscript  I  1   e    I_{1}\cup e   independent.  Pick an    ϵ  >  0      ϵ  0    \epsilon>0   and    τ  >  0      τ  0    \tau>0   such that       (   1  +   2  ϵ    )    |   I  1   |    +   τ   |  E  |     <   |   I  2   |             1    2  ϵ       subscript  I  1       τ    E        subscript  I  2      (1+2\epsilon)|I_{1}|+\tau|E|<|I_{2}|   . Weight the elements of     I  1   ∪   I  2        subscript  I  1    subscript  I  2     I_{1}\cup I_{2}   in the range   2   2   2   to    2  +   2  ϵ       2    2  ϵ     2+2\epsilon   , the elements of     I  1   ∖   I  2        subscript  I  1    subscript  I  2     I_{1}\setminus I_{2}   in the range    1  +  ϵ      1  ϵ    1+\epsilon   to    1  +   2  ϵ       1    2  ϵ     1+2\epsilon   , the elements of     I  2   ∖   I  1        subscript  I  2    subscript  I  1     I_{2}\setminus I_{1}   in the range   1   1   1   to    1  +  ϵ      1  ϵ    1+\epsilon   , and the rest in the range   0   0    to   τ   τ   \tau   . The greedy algorithm will select the elements of    I  1     subscript  I  1    I_{1}   , and then cannot pick any elements of     I  2   ∖   I  1        subscript  I  2    subscript  I  1     I_{2}\setminus I_{1}   . Therefore the independent set it constructs will be of weight at most      (   1  +   2  ϵ    )    |   I  1   |    +   τ   |  E  |    +   |    I  1   ∪   I  2    |           1    2  ϵ       subscript  I  1       τ    E         subscript  I  1    subscript  I  2       (1+2\epsilon)|I_{1}|+\tau|E|+|I_{1}\cup I_{2}|   , which is smaller than the weight of    I  2     subscript  I  2    I_{2}   .  History  It was not until 1971 that Jack Edmonds connected weighted matroids to greedy algorithms in his paper "Matroids and the greedy algorithm". Korte and Lovász would generalize these ideas to objects called greedoids , which allow even larger classes of problems to be solved by greedy algorithms.  References   Jack Edmonds. Matroids and the Greedy Algorithm. Mathematical Programming, volume 1, p. 125–136. 1971.   "  Category:Matroid theory   