


Draft:Алгоритъм на Белман-Форд




Draft:Алгоритъм на Белман-Форд

Алгоритъмът на Белман-Форд е алгоритъм, който пресмята най - късите пътища от един връх към всички останали върхове в един граф. По - бавен е от алгоритъма на Дейкстра, но много по - гъвкав, когато се обхождат графи, на които ръбовете им са отрицателни числа. Алгоритъмът е именуван на двама от създателите си, Ричард Белман и Лестър Форд Младши, които публикуват алгоритъма през 1958 и 1956, съответно; обаче, Едуард Ф. Мур също публикува същия алгоритъм през 1957 и поради тази причина понякога се среща като Алгоритъм на Белман-Форд-Мур.
Този алгоритъм е полезен за намирането на отрицателни стойности в обхождането на различни графи. Ако един граф съдържа в себе си "отрицателен цикъл" (т.е. цикъл, на който сумата на върховете има отрицателна стойност), който може да се срещне още от самото начало, после няма намерен по - евтин път: всеки път може да се нарече евтин при още едно обхождане на отрицателните цикли. В такъв случай алгоритъмът на Белман-Форд може да намери отрицателните цикли и да каже за тяхното наличие.
Algorithm
(Figure)
 В този примерен граф, допускаме, че A е началния връх и ребрата са в най-неблагоприятна поредност, отдясно наляво, изискващ пълни |V|−1 или 4 итерации, за да се пресметне разстоянието. Обратно, ако ребрата са в най-благоприятна поредност, отляво надясно, алогритъма клони към една итерация.

Също както Алгоритъм на Дейкстра, Белман-Форд е базиран на принципа на relaxation, в който приблизителното правилно разстояние постепенно се заменя от по-точни стойности, докато се достигне до оптимално решение. И в двата алгоритъма, приблизителното разстояние до всеки връх е винаги надценено спрямо действителното разстояние и се заменя минимума на неговата стара стойност с дължината на новото намерено разстояние. Обаче, Алгоритъм на Дейкстра избира върхът с най-минимално тегло, който още не е бил обработен и извършва релакционния процес на всички ребра, излизащи от него. В противоположност, Алгоритъмът на Белман-Форд просто релаксира всички ребра, и прави това 
 
 
 
  пъти, където 
 
 
 
  е броят на върховете в графа. Във всяко от тези повторения, броят на върховете с точно пресметнати разстояния расте, от което следва че всички върхове ще имат точни разстояния. Този метод позволява на Алгоритъма на Белман-Форд да бъде приложен на по-широк клас от входни данни, отклокото Алгоритъм на Дейкстра. Белман-Форд протича 
 
 
 
  пъти, където 
 
 
 
  и 
 
 
 
  са броят на върховете и ребрата респективно.
function BellmanFord(list vertices, list edges, vertex source)
   ::distance[],predecessor[]

   // This implementation takes in a graph, represented as
   // lists of vertices and edges, and fills two arrays
   // (distance and predecessor) with shortest-path
   // (less cost/distance/metric) information

   // Step 1: initialize graph
   for each vertex v in vertices:
       if v is source then distance[v] := 0
       else distance[v] := inf
       predecessor[v] := null

   // Step 2: relax edges repeatedly
   
   for i from 1 to size(vertices)-1:
       for each edge (u, v) with weight w in edges:
           if distance[u] + w i, за която ребрата са сканирани алгоритъмът намира всички най-къси пътища в най-дългите 

 ребра. Докато най-дългият възможен път без цикъл може да бъде 

 ребра, ребрата трябва да бъдат сканирани 

 пъти за да е сигурно, че е намерен най-късия път за всички върхове. Последното сканиране на всички върхове се изпълнява и ако някое разстояние се обнови, тогава път с дължина 

 ребра е намерен. Това може да се случи само ако съществува един отрицателен цикъл в графа.
Доказателство за коректност
Правилността на алгоритъма може да се докаже чрез математическа индукция. Твърдението доказано чрез индукцията е:
Лема. След i повторения на for цикъл:

Ако разстоянието(u) не е безкрайност, то е равно на някой от пътищата между връх s и връх u;
Ако има път от връх s до връх u с не повече от i ребра, то тогава разстоянието(u) е не по-голямо от дължината на най-късия път от връх s до връх u с не повече от i ребра.

Доказателство. Основният случай на индукция се разглежда за i=0 и момента преди for цикъла да е изпълнен за първи път.Тогава за началния връх source.distance = 0, което е вярно. За другите върхове u, u.distance = '''infinity''', което също е вярно,защото няма път от началния връх до връх u с 0 ребра.
За индуктивния случай първо се доказва първата част.Разглежда се момента, когато разстоянието на върха се обнови чрез v.distance := u.distance + uv.weight. Чрез индуктивно предположение, u.distanceе дължината на път от началния връх до връх u. Тогава u.distance + uv.weight е дължината на пътя от s до v, който минава през u и отива в v.
За втората част се разглежда най-късият път от началния връх до u с не повече от i ребра. Нека последният връх преди връх u от този път да бъде v. Тогава частта от пътя от s до v е най-късият път между s и v с не повече от i-1 ребра. Чрез индуктивно предположение, v.distance след i−1 итерации е най-голямата дължина на този път. Следователно, uv.weight + v.distance е най-голямата дължина на пътя от s до u. На iтата итерация, u.distance се сравнява с uv.weight + v.distanceи ако стойността му е по-малка му се присвоява тази на uv.weight + v.distance.Затова след i итерации, u.distance e не по-голямо от най-краткия път от s до u който минава през не повече от i ребра.
Ако няма цикли с отрицателни тегла всеки най-кратък път преминава през всеки връх поне по веднъж, поради тази причина в стъпка 3 не могат да се направят оптимизации. Обратното, нека предположим, че подобрения не могат да бъдат направени. Тогава за всеки цикъл с върхове v[0], ..., v[k−1],
v[i].distance <= v[(i-1) mod k].distance + v[(i-1) mod k]v[i].weight
Сумирайки през цикъла, условията за разстоянията v[i] и v[i−1 (mod k)] анулират
0 <= sum from 1 to k of v[i-1 (mod k)]v[i].weight
т.е. всеки цикъл има положителни тегла.
Намиране на отрицателни цикли
Когато алгоритъмът се използва за да намери най-кратките пътища, наличието на отрицателни цикли е проблем, попречва на алгоритъма да намери правилен отговор. Тъй като той прекратява изпълнението си при намиране на отрицателен цикъл, Белман-Форд алгоритъмът може да бъде използван за приложения в които това е търсената цел - например в техники за анулиране на цикъл при анализи на мрежови поток.1
Приложения в маршрутизация
Разпространен вариант на алгоритъма на Белман-Форд се използва в дистанционно векторни протоколи за маршрутизация, например Маршрутизиращият Информационен Протокол (RIP). Алгоритъмът се разпределя, тъй като включва редица възли (рутери) в автономна система, колекция от IP мрежи, обикновено собственост на един доставчик на интернет услуги (ISP). Той се състой от следните стъпки:

Всеки възел изчислява разстоянията между себе си и всички други възли в автономната система и съхранява тази информация във вид на таблица.
Всеки възел изпраща своята таблица до всички съседни възли.
Когато един възел получава таблица от своите съседни възли, изчислява най-кратките маршрути до всички други възли и актуализира своята собствена таблица за да отрази промените.

Основните недостатъци на Белман-Форд алгоритъма в тази настройка, са както следва:

Той не мащабира добре.
Промените в мрежовата топология не са отразени бързо, тъй като актуализациите са разделени възел по възел.
Count to infinit if link or node failures render a node unreachable from some set of other nodes, those nodes may spend forever gradually increasing their estimates of the distance to it, and in the meantime there may be routing loops.

Подобрения
Алгоритъмът на Белман-Форд може да бъде подобрен на практика (въпреки че не в най-лошия случай) както виждаме в случай, че ако една итерация от основният цикъл на алгоритъма завърши без да са направени никакви промени, то тогава алгоритъмът може незабавно да бъде прекратен, като последващите итерации няма да направят никакви промени. При това условие с преждевременно прекратяване, основният цикъл в някои случаи може да използва много по-малко итерации от колкото |V| − 1, въпреки, че в най-лошият случай на алгоритъма, остава непроменен.
е описал още две подобрения на Белман-Форд алгоритъма за графика без негативни цикли; отново, докато на практика правят алгоритъма по-бърз, те не променят неговото O(|V|*|E|) в най-лошия случай обвързан с времето. Неговото първо подобрение намалява броя на стъпките за релаксация, които трябва да се извършат в рамките на всяка итерация на алгоритъма. If a vertex v has a distance value that has not changed since the last time the edges out of v were relaxed, then there is no need to relax the edges out of v a second time. In this way, as the number of vertices with correct distance values grows, the number whose outgoing edges need to be relaxed in each iteration shrinks, leading to a constant-factor savings in time for dense graphs.
Второто подобрение на Yen първо присвоява някакъв произволен линеен ред на всички върхове и след това разделя множеството от всички ръбове на две подгрупи. Първата група, Ef, съдържа всички ръбове (vi, vj) така, че i b, съдържа ръбове (vi'', vj) така, че i > j. Всеки връх се посещава в ред v1, v2, ..., v|V|, релаксирайки всеки изходящ ръб от този връх в Eb.Всяка итерация от основният цикъл на алгоритъма, след първата, добавя най-малко два ръба към множеството от ръбове, чиито релаксирани разстояния намират най-кратките разстояния на пътищата: един от Ef и един от Eb. Тази модификация намалява броя на итерациите, в най-лошия случай, на основният цикъл на алгоритъма от |V| − 1 до |V|/2.23
Друго подобрение, от , замества произволният линеен ред използван във второто подобрение на Yen, с произволна пермутация. Поради тази промянa, става много малка вероятността, най-лошият случай от подобрението на Yen (в който ръбовете, на най-краткият път, стриктно се редуват между двете подгрупи Ef and Eb) да се случи. С произволно разместена върхова подредба, очакваният брой итерации, необходими в основният цикъл, е най-много |V|/3.4
Notes
References
Original sources







Secondary sources



, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 24.1: The Bellman–Ford algorithm, pp. 588–592. Problem 24-1, pp. 614–615. Third Edition. MIT Press, 2009. ISBN 978-0-262-53305-8. Section 24.1: The Bellman–Ford algorithm, pp. 651–655.




External links

C++ code example
Open Source Java Graph package with Bellman-Ford Algorithms

:Category:Graph algorithms :Category:Polynomial-time problems :Category:Articles with example C code :Category:Articles with example pseudocode :Category:Dynamic programming"




Cormen et al., 2nd ed., Problem 24-1, pp. 614–615.

See Sedgewick's web exercises for Algorithms, 4th ed., exercises 5 and 11 (retrieved 2013-01-30).




