<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1902">Simply typed lambda calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Simply typed lambda calculus</h1>
<hr/>

<p>The <strong>simply typed lambda calculus</strong> (

<math display="inline" id="Simply_typed_lambda_calculus:0">
 <semantics>
  <msup>
   <mi>λ</mi>
   <mo>→</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>λ</ci>
    <ci>normal-→</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda^{\to}
  </annotation>
 </semantics>
</math>

), a form of <a href="type_theory" title="wikilink">type theory</a>, is a <a href="typed_lambda_calculus" title="wikilink">typed interpretation</a> of the <a href="lambda_calculus" title="wikilink">lambda calculus</a> with only one <a href="type_constructor" title="wikilink">type constructor</a>

<math display="block" id="Simply_typed_lambda_calculus:1">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 that builds <a href="function_type" title="wikilink">function types</a>. It is the canonical and simplest example of a typed lambda calculus. The simply typed lambda calculus was originally introduced by <a href="Alonzo_Church" title="wikilink">Alonzo Church</a> in 1940 as an attempt to avoid paradoxical uses of the <a href="untyped_lambda_calculus" title="wikilink">untyped lambda calculus</a>, and it exhibits many desirable and interesting properties.</p>

<p>The term <em>simple type</em> is also used to refer to extensions of the simply typed lambda calculus such as <a href="cartesian_product" title="wikilink">products</a>, <a href="coproduct" title="wikilink">coproducts</a> or <a href="natural_number" title="wikilink">natural numbers</a> (<a href="Dialectica_interpretation" title="wikilink">System T</a>) or even full <a class="uri" href="recursion" title="wikilink">recursion</a> (like <a href="Programming_language_for_Computable_Functions" title="wikilink">PCF</a>). In contrast, systems which introduce polymorphic types (like <a href="System_F" title="wikilink">System F</a>) or <a href="dependent_type" title="wikilink">dependent types</a> (like the <a href="LF_(logical_framework)" title="wikilink">Logical Framework</a>) are not considered <em>simply typed</em>. The former are still considered <em>simple</em> because the <a href="Church_encoding" title="wikilink">Church encodings</a> of such structures can be done using only 

<math display="inline" id="Simply_typed_lambda_calculus:2">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 and suitable type variables, while polymorphism and dependency cannot.</p>
<h2 id="syntax">Syntax</h2>

<p>In this article, we use 

<math display="inline" id="Simply_typed_lambda_calculus:3">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Simply_typed_lambda_calculus:4">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 to range over types. Informally, the <em>function type</em> 

<math display="inline" id="Simply_typed_lambda_calculus:5">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>→</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>σ</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\to\tau
  </annotation>
 </semantics>
</math>

 refers to the type of functions that, given an input of type 

<math display="inline" id="Simply_typed_lambda_calculus:6">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, produce an output of type 

<math display="inline" id="Simply_typed_lambda_calculus:7">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

. By convention, 

<math display="inline" id="Simply_typed_lambda_calculus:8">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 associates to the right: we read 

<math display="inline" id="Simply_typed_lambda_calculus:9">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>→</mo>
   <mi>τ</mi>
   <mo>→</mo>
   <mi>ρ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>σ</ci>
     <ci>τ</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>ρ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\to\tau\to\rho
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Simply_typed_lambda_calculus:10">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo>→</mo>
    <mi>ρ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">σ</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">τ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ρ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\to(\tau\to\rho)
  </annotation>
 </semantics>
</math>

.</p>

<p>To define the types, we begin by fixing a set of <em>base types</em>, 

<math display="inline" id="Simply_typed_lambda_calculus:11">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. These are sometimes called <em>atomic types</em> or <em>type constants</em>. With this fixed, the syntax of types is:</p>

<p>

<math display="block" id="Simply_typed_lambda_calculus:12">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>:</mo>
   <mo>:=</mo>
   <mi>τ</mi>
   <mo>→</mo>
   <mi>τ</mi>
   <mo>∣</mo>
   <mi>T</mi>
   <mi>where</mi>
   <mi>T</mi>
   <mo>∈</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">τ</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">τ</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">τ</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">T</csymbol>
    <ci></ci>
    <csymbol cd="unknown">where</csymbol>
    <ci></ci>
    <csymbol cd="unknown">T</csymbol>
    <in></in>
    <csymbol cd="unknown">B</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau::=\tau\to\tau\mid T\quad\mathrm{where}\quad T\in B
  </annotation>
 </semantics>
</math>

.</p>

<p>For example, if 

<math display="inline" id="Simply_typed_lambda_calculus:13">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <set>
     <ci>a</ci>
     <ci>b</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=\{a,b\}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Simply_typed_lambda_calculus:14">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Simply_typed_lambda_calculus:15">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Simply_typed_lambda_calculus:16">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>→</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>a</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\to a
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Simply_typed_lambda_calculus:17">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>→</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\to b
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Simply_typed_lambda_calculus:18">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>→</mo>
   <mi>b</mi>
   <mo>→</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\to b\to a
  </annotation>
 </semantics>
</math>

 are all valid types (among others).</p>

<p>We also fix a set of <em>term constants</em> for the base types. For example, we might assume a base type <code>nat</code>, and the term constants could be the natural numbers. In the original presentation, Church used only two base types

<math display="block" id="Simply_typed_lambda_calculus:19">
 <semantics>
  <mi>o</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>o</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o
  </annotation>
 </semantics>
</math>

 for "the type of propositions" and 

<math display="inline" id="Simply_typed_lambda_calculus:20">
 <semantics>
  <mi>ι</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ι</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iota
  </annotation>
 </semantics>
</math>

 for "the type of individuals". The type 

<math display="inline" id="Simply_typed_lambda_calculus:21">
 <semantics>
  <mi>o</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>o</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o
  </annotation>
 </semantics>
</math>

 has no term constants, whereas 

<math display="inline" id="Simply_typed_lambda_calculus:22">
 <semantics>
  <mi>ι</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ι</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iota
  </annotation>
 </semantics>
</math>

 has one term constant. Frequently the calculus with only one base type, usually 

<math display="inline" id="Simply_typed_lambda_calculus:23">
 <semantics>
  <mi>o</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>o</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o
  </annotation>
 </semantics>
</math>

, is considered.</p>

<p>The syntax of the simply typed lambda calculus is essentially that of the lambda calculus itself. We write 

<math display="inline" id="Simply_typed_lambda_calculus:24">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mi>x</mi>
    <mo separator="true">,</mo>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>x</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mathbin{:}\tau
  </annotation>
 </semantics>
</math>

 to denote that the variable 

<math display="inline" id="Simply_typed_lambda_calculus:25">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is of type 

<math display="inline" id="Simply_typed_lambda_calculus:26">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

. The term syntax is then:</p>

<p>

<math display="block" id="Simply_typed_lambda_calculus:27">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>:</mo>
   <mo>:=</mo>
   <mi>x</mi>
   <mo>∣</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mi mathvariant="normal">:</mi>
   <mi>τ</mi>
   <mo>.</mo>
   <mi>e</mi>
   <mo>∣</mo>
   <mpadded width="+1.7pt">
    <mi>e</mi>
   </mpadded>
   <mi>e</mi>
   <mo>∣</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">τ</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">c</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e::=x\mid\lambda x\mathbin{:}\tau.e\mid e\,e\mid c
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Simply_typed_lambda_calculus:28">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is a term constant.</p>

<p>That is, <em>variable reference</em>, <em>abstractions</em>, <em>application</em>, and <em>constant</em>. A variable reference 

<math display="inline" id="Simply_typed_lambda_calculus:29">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is <em>bound</em> if it is inside of an abstraction binding 

<math display="inline" id="Simply_typed_lambda_calculus:30">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. A term is <em>closed</em> if there are no unbound variables.</p>

<p>Compare this to the syntax of untyped lambda calculus:</p>

<p>

<math display="block" id="Simply_typed_lambda_calculus:31">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>:</mo>
   <mo>:=</mo>
   <mi>x</mi>
   <mo>∣</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>e</mi>
   <mo>∣</mo>
   <mpadded width="+1.7pt">
    <mi>e</mi>
   </mpadded>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-∣</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">e</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e::=x\mid\lambda x.e\mid e\,e
  </annotation>
 </semantics>
</math>

</p>

<p>We see that in typed lambda calculus every function (<em>abstraction</em>) must specify the type of its argument.</p>
<h2 id="typing-rules">Typing rules</h2>

<p>To define the set of well typed lambda terms of a given type, we will define a typing relation between terms and types. First, we introduce <em>typing contexts</em> or <em><a href="typing_environment" title="wikilink">typing environments</a></em> 

<math display="inline" id="Simply_typed_lambda_calculus:32">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Δ</mi>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-Γ</ci>
    <ci>normal-Δ</ci>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma,\Delta,\dots
  </annotation>
 </semantics>
</math>

, which are sets of typing assumptions. A <em>typing assumption</em> has the form 

<math display="inline" id="Simply_typed_lambda_calculus:33">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mi>x</mi>
    <mo separator="true">,</mo>
    <mi>σ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>x</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mathbin{:}\sigma
  </annotation>
 </semantics>
</math>

, meaning 

<math display="inline" id="Simply_typed_lambda_calculus:34">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Simply_typed_lambda_calculus:35">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

.</p>

<p>The <em>typing relation</em> 

<math display="inline" id="Simply_typed_lambda_calculus:36">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mi>e</mi>
     <mo separator="true">,</mo>
     <mi>σ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <ci>normal-:</ci>
     <ci>e</ci>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash e\mathbin{:}\sigma
  </annotation>
 </semantics>
</math>

 indicates that 

<math display="inline" id="Simply_typed_lambda_calculus:37">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is a term of type 

<math display="inline" id="Simply_typed_lambda_calculus:38">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 in context 

<math display="inline" id="Simply_typed_lambda_calculus:39">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

. In this case 

<math display="inline" id="Simply_typed_lambda_calculus:40">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is said to be <em>well-typed</em> (having type 

<math display="inline" id="Simply_typed_lambda_calculus:41">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

). Instances of the typing relation are called <em>typing judgements</em>. The validity of a typing judgement is shown by providing a <em>typing derivation</em>, constructed using <a href="type_rules" title="wikilink">typing rules</a> (wherein the premises above the line allow us to derive the conclusion below the line). Simply-typed lambda calculus uses these rules:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Simply_typed_lambda_calculus:42">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>x</mi>
      <mo separator="true">,</mo>
      <mi>σ</mi>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi mathvariant="normal">Γ</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>x</mi>
      <mo separator="true">,</mo>
      <mi>σ</mi>
     </mrow>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <in></in>
     <apply>
      <ci>normal-:</ci>
      <ci>x</ci>
      <ci>σ</ci>
     </apply>
     <ci>normal-Γ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <ci>normal-:</ci>
      <ci>x</ci>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\frac{x\mathbin{:}\sigma\in\Gamma}{\Gamma\vdash x\mathbin{:}\sigma}}
  </annotation>
 </semantics>
</math>

 (1)</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Simply_typed_lambda_calculus:43">
 <semantics>
  <mfrac>
   <mrow>
    <mi>c</mi>
    <mtext>is a constant of type</mtext>
    <mi>T</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>c</mi>
      <mo separator="true">,</mo>
      <mi>T</mi>
     </mrow>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>c</ci>
     <mtext>is a constant of type</mtext>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <ci>normal-:</ci>
      <ci>c</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\frac{c\text{ is a constant of type }T}{\Gamma\vdash c\mathbin{:}T}}
  </annotation>
 </semantics>
</math>

 (2)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Simply_typed_lambda_calculus:44">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">:</mi>
      <mrow>
       <mi>x</mi>
       <mo separator="true">,</mo>
       <mi>σ</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>⊢</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>e</mi>
      <mo separator="true">,</mo>
      <mi>τ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mi mathvariant="normal">:</mi>
     <mi>σ</mi>
     <mo rspace="5.8pt">.</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo>→</mo>
     <mi>τ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <list>
      <ci>normal-Γ</ci>
      <apply>
       <ci>normal-:</ci>
       <ci>x</ci>
       <ci>σ</ci>
      </apply>
     </list>
     <apply>
      <ci>normal-:</ci>
      <ci>e</ci>
      <ci>τ</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Γ</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">σ</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">e</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-:</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">σ</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">τ</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\frac{\Gamma,x\mathbin{:}\sigma\vdash e\mathbin{:}\tau}{\Gamma\vdash(\lambda x%
\mathbin{:}\sigma.~{}e)\mathbin{:}(\sigma\to\tau)}}
  </annotation>
 </semantics>
</math>

 (3)</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Simply_typed_lambda_calculus:45">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mrow>
      <mi mathvariant="normal">:</mi>
      <mrow>
       <msub>
        <mi>e</mi>
        <mn>1</mn>
       </msub>
       <mo separator="true">,</mo>
       <mi>σ</mi>
      </mrow>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mi>τ</mi>
      <mi mathvariant="normal">Γ</mi>
     </mrow>
    </mrow>
    <mo>⊢</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <msub>
       <mi>e</mi>
       <mn>2</mn>
      </msub>
      <mo separator="true">,</mo>
      <mi>σ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mrow>
       <mpadded width="+3.3pt">
        <msub>
         <mi>e</mi>
         <mn>1</mn>
        </msub>
       </mpadded>
       <msub>
        <mi>e</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo separator="true">,</mo>
      <mi>τ</mi>
     </mrow>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <apply>
       <ci>normal-→</ci>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>σ</ci>
       </apply>
       <list>
        <ci>τ</ci>
        <ci>normal-Γ</ci>
       </list>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <ci>normal-:</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>σ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\frac{\Gamma\vdash e_{1}\mathbin{:}\sigma\to\tau\quad\Gamma\vdash e_{2}%
\mathbin{:}\sigma}{\Gamma\vdash e_{1}~{}e_{2}\mathbin{:}\tau}}
  </annotation>
 </semantics>
</math>

 (4)</p></td>
</tr>
</tbody>
</table>

<p>In other words,</p>
<ol>
<li>If 

<math display="inline" id="Simply_typed_lambda_calculus:46">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Simply_typed_lambda_calculus:47">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 in the context, we know that 

<math display="inline" id="Simply_typed_lambda_calculus:48">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Simply_typed_lambda_calculus:49">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

.</li>
<li>Term constants have the appropriate base types.</li>
<li>If, in a certain context with 

<math display="inline" id="Simply_typed_lambda_calculus:50">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 having type 

<math display="inline" id="Simply_typed_lambda_calculus:51">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Simply_typed_lambda_calculus:52">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Simply_typed_lambda_calculus:53">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

, then, in the same context without 

<math display="inline" id="Simply_typed_lambda_calculus:54">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Simply_typed_lambda_calculus:55">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mi>x</mi>
     </mrow>
     <mo separator="true">,</mo>
     <mi>σ</mi>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">.</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
     <ci>σ</ci>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x\mathbin{:}\sigma.~{}e
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Simply_typed_lambda_calculus:56">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>→</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>σ</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\to\tau
  </annotation>
 </semantics>
</math>

.</li>
<li>If, in a certain context, 

<math display="inline" id="Simply_typed_lambda_calculus:57">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Simply_typed_lambda_calculus:58">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>→</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>σ</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\to\tau
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Simply_typed_lambda_calculus:59">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{2}
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Simply_typed_lambda_calculus:60">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Simply_typed_lambda_calculus:61">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
   </mpadded>
   <msub>
    <mi>e</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}~{}e_{2}
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Simply_typed_lambda_calculus:62">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Examples of closed terms, <em>i.e.</em> terms typable in the empty context, are:</p>
<ul>
<li>For every type 

<math display="inline" id="Simply_typed_lambda_calculus:63">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

, a term 

<math display="inline" id="Simply_typed_lambda_calculus:64">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mi>x</mi>
     </mrow>
     <mo separator="true">,</mo>
     <mi>τ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>x</mi>
      <mo separator="true">,</mo>
      <mi>τ</mi>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
     <ci>τ</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <ci>normal-:</ci>
      <ci>x</ci>
      <ci>τ</ci>
     </apply>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x\mathbin{:}\tau.x\mathbin{:}\tau\to\tau
  </annotation>
 </semantics>
</math>

 (identity function/I-combinator),</li>
<li>For types 

<math display="inline" id="Simply_typed_lambda_calculus:65">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>,</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>σ</ci>
    <ci>τ</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma,\tau
  </annotation>
 </semantics>
</math>

, a term 

<math display="inline" id="Simply_typed_lambda_calculus:66">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mi>x</mi>
     </mrow>
     <mo separator="true">,</mo>
     <mi>σ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mi>y</mi>
     </mrow>
     <mo separator="true">,</mo>
     <mi>τ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>x</mi>
      <mo separator="true">,</mo>
      <mi>σ</mi>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mi>τ</mi>
    <mo>→</mo>
    <mi>σ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
     <ci>σ</ci>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>y</ci>
     </apply>
     <ci>τ</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <ci>normal-:</ci>
       <ci>x</ci>
       <ci>σ</ci>
      </apply>
      <ci>τ</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x\mathbin{:}\sigma.\lambda y\mathbin{:}\tau.x\mathbin{:}\sigma\to\tau\to\sigma
  </annotation>
 </semantics>
</math>

 (the K-combinator), and</li>
<li>For types 

<math display="inline" id="Simply_typed_lambda_calculus:67">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>,</mo>
   <msup>
    <mi>τ</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>τ</mi>
    <mi>′′</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>τ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>τ</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>τ</ci>
     <ci>′′</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau,\tau^{\prime},\tau^{\prime\prime}
  </annotation>
 </semantics>
</math>

, a term 

<math display="inline" id="Simply_typed_lambda_calculus:68">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>x</mi>
   <mi mathvariant="normal">:</mi>
   <mi>τ</mi>
   <mo>→</mo>
   <msup>
    <mi>τ</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <msup>
    <mi>τ</mi>
    <mi>′′</mi>
   </msup>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>y</mi>
   <mi mathvariant="normal">:</mi>
   <mi>τ</mi>
   <mo>→</mo>
   <msup>
    <mi>τ</mi>
    <mo>′</mo>
   </msup>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>z</mi>
   <mi mathvariant="normal">:</mi>
   <mi>τ</mi>
   <mo>.</mo>
   <mi>x</mi>
   <mi>z</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo>→</mo>
    <msup>
     <mi>τ</mi>
     <mo>′</mo>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>τ</mi>
     <mi>′′</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo>→</mo>
    <msup>
     <mi>τ</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>τ</mi>
   <mo>→</mo>
   <msup>
    <mi>τ</mi>
    <mi>′′</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">τ</csymbol>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>τ</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>τ</ci>
     <ci>′′</ci>
    </apply>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">τ</csymbol>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>τ</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">τ</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">τ</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>τ</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>τ</ci>
      <ci>′′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">τ</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>τ</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">τ</csymbol>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>τ</ci>
     <ci>′′</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x\mathbin{:}\tau\to\tau^{\prime}\to\tau^{\prime\prime}.\lambda y%
\mathbin{:}\tau\to\tau^{\prime}.\lambda z\mathbin{:}\tau.xz(yz):(\tau\to\tau^{%
\prime}\to\tau^{\prime\prime})\to(\tau\to\tau^{\prime})\to\tau\to\tau^{\prime\prime}
  </annotation>
 </semantics>
</math>

 (the S-combinator).</li>
</ul>

<p>These are the typed lambda calculus representations of the basic combinators of <a href="combinatory_logic" title="wikilink">combinatory logic</a>.</p>

<p>Each type 

<math display="inline" id="Simply_typed_lambda_calculus:69">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 is assigned an order, a number 

<math display="inline" id="Simply_typed_lambda_calculus:70">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(\tau)
  </annotation>
 </semantics>
</math>

. For base types, 

<math display="inline" id="Simply_typed_lambda_calculus:71">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>T</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(T)=0
  </annotation>
 </semantics>
</math>

; for function types, 

<math display="inline" id="Simply_typed_lambda_calculus:72">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo>→</mo>
    <mi>τ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mtext>max</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>τ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">τ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <mtext>max</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">o</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">σ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">o</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">τ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(\sigma\to\tau)=\mbox{max}(o(\sigma)+1,o(\tau))
  </annotation>
 </semantics>
</math>

. That is, the order of a type measures the depth of the most left-nested arrow. Hence:</p>

<p>

<math display="block" id="Simply_typed_lambda_calculus:73">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ι</mi>
    <mo>→</mo>
    <mi>ι</mi>
    <mo>→</mo>
    <mi>ι</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ι</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ι</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ι</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(\iota\to\iota\to\iota)=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Simply_typed_lambda_calculus:74">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ι</mi>
     <mo>→</mo>
     <mi>ι</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>ι</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">ι</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">ι</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ι</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">2</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o((\iota\to\iota)\to\iota)=2
  </annotation>
 </semantics>
</math>

</p>
<h2 id="semantics">Semantics</h2>
<h3 id="intrinsic-vs.-extrinsic-interpretations">Intrinsic vs. extrinsic interpretations</h3>

<p>Broadly speaking, there are two different ways of assigning meaning to the simply typed lambda calculus, as to typed languages more generally, sometimes called <em>intrinsic</em> vs. <em>extrinsic</em>, or <em><a href="Alonzo_Church" title="wikilink">Church</a>-style</em> vs. <em><a href="Haskell_Curry" title="wikilink">Curry</a>-style</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> An intrinsic/Church-style semantics only assigns meaning to well-typed terms, or more precisely, assigns meaning directly to typing derivations. This has the effect that terms differing only by type annotations can nonetheless be assigned different meanings. For example, the identity term 

<math display="inline" id="Simply_typed_lambda_calculus:75">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mi>x</mi>
     </mrow>
     <mo separator="true">,</mo>
     <mi>𝚒𝚗𝚝</mi>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
     <ci>𝚒𝚗𝚝</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x\mathbin{:}\mathtt{int}.~{}x
  </annotation>
 </semantics>
</math>

 on integers and the identity term 

<math display="inline" id="Simply_typed_lambda_calculus:76">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mi>x</mi>
     </mrow>
     <mo separator="true">,</mo>
     <mi>𝚋𝚘𝚘𝚕</mi>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
     <ci>𝚋𝚘𝚘𝚕</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x\mathbin{:}\mathtt{bool}.~{}x
  </annotation>
 </semantics>
</math>

 on booleans may mean different things. (The classic intended interpretations are the identity function on integers and the identity function on boolean values.) In contrast, an extrinsic/Curry-style semantics assigns meaning to terms regardless of typing, as they would be interpreted in an untyped language. In this view, 

<math display="inline" id="Simply_typed_lambda_calculus:77">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mi>x</mi>
     </mrow>
     <mo separator="true">,</mo>
     <mi>𝚒𝚗𝚝</mi>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
     <ci>𝚒𝚗𝚝</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x\mathbin{:}\mathtt{int}.~{}x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Simply_typed_lambda_calculus:78">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mi>x</mi>
     </mrow>
     <mo separator="true">,</mo>
     <mi>𝚋𝚘𝚘𝚕</mi>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
     <ci>𝚋𝚘𝚘𝚕</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x\mathbin{:}\mathtt{bool}.~{}x
  </annotation>
 </semantics>
</math>

 mean the same thing (<em>i.e.</em>, the same thing as 

<math display="inline" id="Simply_typed_lambda_calculus:79">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo rspace="5.8pt">.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.~{}x
  </annotation>
 </semantics>
</math>

).</p>

<p>The distinction between intrinsic and extrinsic semantics is sometimes associated with the presence or absence of annotations on lambda abstractions, but strictly speaking this usage is imprecise. It is possible to define a Curry-style semantics on annotated terms simply by ignoring the types (<em>i.e.</em>, through <a href="type_erasure" title="wikilink">type erasure</a>), as it is possible to give a Church-style semantics on unannotated terms when the types can be deduced from context (<em>i.e.</em>, through <a href="type_inference" title="wikilink">type inference</a>). The essential difference between intrinsic and extrinsic approaches is just whether the typing rules are viewed as defining the language, or as a formalism for verifying properties of a more primitive underlying language. Most of the different semantic interpretations discussed below can be seen through either a Church or Curry perspective.</p>
<h3 id="equational-theory">Equational theory</h3>

<p>The simply typed lambda calculus has the same <a href="equational_theory" title="wikilink">equational theory</a> of βη-equivalence as <a href="Untyped_lambda_calculus#Reduction" title="wikilink">untyped lambda calculus</a>, but subject to type restrictions. The equation for <a href="beta_reduction" title="wikilink">beta reduction</a></p>

<p>

<math display="block" id="Simply_typed_lambda_calculus:80">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mi mathvariant="normal">:</mi>
    <mi>σ</mi>
    <mo rspace="5.8pt">.</mo>
    <mi>t</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mi>u</mi>
   <msub>
    <mo>=</mo>
    <mi>β</mi>
   </msub>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>u</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">u</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <ci>β</ci>
    </apply>
    <csymbol cd="unknown">t</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x\mathbin{:}\sigma.~{}t)\,u=_{\beta}t[x:=u]
  </annotation>
 </semantics>
</math>

 holds in context 

<math display="inline" id="Simply_typed_lambda_calculus:81">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 whenever 

<math display="inline" id="Simply_typed_lambda_calculus:82">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>x</mi>
      <mo separator="true">,</mo>
      <mi>σ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mi>t</mi>
     <mo separator="true">,</mo>
     <mi>τ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <ci>normal-Γ</ci>
     <apply>
      <ci>normal-:</ci>
      <ci>x</ci>
      <ci>σ</ci>
     </apply>
    </list>
    <apply>
     <ci>normal-:</ci>
     <ci>t</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma,x\mathbin{:}\sigma\vdash t\mathbin{:}\tau
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Simply_typed_lambda_calculus:83">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mi>u</mi>
     <mo separator="true">,</mo>
     <mi>σ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <ci>normal-:</ci>
     <ci>u</ci>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash u\mathbin{:}\sigma
  </annotation>
 </semantics>
</math>

, while the equation for <a href="eta_reduction" title="wikilink">eta reduction</a></p>

<p>

<math display="block" id="Simply_typed_lambda_calculus:84">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mi>x</mi>
     </mrow>
     <mo separator="true">,</mo>
     <mi>σ</mi>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">.</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>t</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
    <msub>
     <mo>=</mo>
     <mi>η</mi>
    </msub>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
     <ci>σ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <eq></eq>
      <ci>η</ci>
     </apply>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>x</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x\mathbin{:}\sigma.~{}t\,x=_{\eta}t
  </annotation>
 </semantics>
</math>

 holds whenever 

<math display="inline" id="Simply_typed_lambda_calculus:85">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mpadded width="-1.7pt">
    <mi>t</mi>
   </mpadded>
   <mo>:</mo>
   <mrow>
    <mi>σ</mi>
    <mo>→</mo>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-→</ci>
      <ci>σ</ci>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash t\!:\sigma\to\tau
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Simply_typed_lambda_calculus:86">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 does not appear free in 

<math display="inline" id="Simply_typed_lambda_calculus:87">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="operational-semantics">Operational semantics</h3>

<p>Likewise, the <a href="operational_semantics" title="wikilink">operational semantics</a> of simply typed lambda calculus can be fixed as for the untyped lambda calculus, using <a href="call_by_name" title="wikilink">call by name</a>, <a href="call_by_value" title="wikilink">call by value</a>, or other <a href="evaluation_strategy" title="wikilink">evaluation strategies</a>. As for any typed language, <a href="type_safety" title="wikilink">type safety</a> is a fundamental property of all of these evaluation strategies. Additionally, the <a href="strong_normalization" title="wikilink">strong normalization</a> property <a href="Simply_typed_lambda_calculus#Important_results" title="wikilink">described below</a> implies that any evaluation strategy will terminate on all simply typed terms.</p>
<h3 id="categorical-semantics">Categorical semantics</h3>

<p>The simply typed lambda calculus (with 

<math display="inline" id="Simply_typed_lambda_calculus:88">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mi>η</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>β</ci>
    <ci>η</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\eta
  </annotation>
 </semantics>
</math>

-equivalence) is the <a href="internal_language" title="wikilink">internal language</a> of <a href="Cartesian_closed_categories" title="wikilink">Cartesian closed categories</a> (CCCs), as was first observed by <a href="Joachim_Lambek" title="wikilink">Lambek</a>. Given any specific CCC, the basic types of the corresponding lambda calculus are just the <a href="object_(category_theory)" title="wikilink">objects</a>, and the terms are the <a href="morphism" title="wikilink">morphisms</a>. Conversely, every simply typed lambda calculus gives a CCC whose objects are the types, and morphisms are equivalence classes of terms.</p>

<p>To make the correspondence clear, a <a href="type_constructor" title="wikilink">type constructor</a> for the <a href="Cartesian_product" title="wikilink">Cartesian product</a> is typically added to the above. To preserve the <a href="product_(category_theory)" title="wikilink">categoricity of the Cartesian product</a>, one adds <a href="type_rule" title="wikilink">type rules</a> for <em>pairing</em>, <em>projection</em>, and a <em>unit term</em>. Given two terms 

<math display="inline" id="Simply_typed_lambda_calculus:89">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mi>s</mi>
    <mo separator="true">,</mo>
    <mi>σ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>s</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\mathbin{:}\sigma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Simply_typed_lambda_calculus:90">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mi>t</mi>
    <mo separator="true">,</mo>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>t</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\mathbin{:}\tau
  </annotation>
 </semantics>
</math>

, the term 

<math display="inline" id="Simply_typed_lambda_calculus:91">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>s</ci>
    <ci>t</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,t)
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Simply_typed_lambda_calculus:92">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>×</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>σ</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\times\tau
  </annotation>
 </semantics>
</math>

. Likewise, if one has a term 

<math display="inline" id="Simply_typed_lambda_calculus:93">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mi>u</mi>
     <mo separator="true">,</mo>
     <msub>
      <mi>τ</mi>
      <mn>1</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>×</mo>
   <msub>
    <mi>τ</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-:</ci>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\mathbin{:}\tau_{1}\times\tau_{2}
  </annotation>
 </semantics>
</math>

, then there are terms 

<math display="inline" id="Simply_typed_lambda_calculus:94">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mrow>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo separator="true">,</mo>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>u</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}(u)\mathbin{:}\tau_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Simply_typed_lambda_calculus:95">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mrow>
     <msub>
      <mi>π</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo separator="true">,</mo>
    <msub>
     <mi>τ</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>u</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{2}(u)\mathbin{:}\tau_{2}
  </annotation>
 </semantics>
</math>

 where the 

<math display="inline" id="Simply_typed_lambda_calculus:96">
 <semantics>
  <msub>
   <mi>π</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{i}
  </annotation>
 </semantics>
</math>

 correspond to the projections of the Cartesian product. The <em>unit term</em>, of type 1, is written as 

<math display="inline" id="Simply_typed_lambda_calculus:97">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list></list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ()
  </annotation>
 </semantics>
</math>

 and vocalized as 'nil', is the <a href="final_object" title="wikilink">final object</a>. The equational theory is extended likewise, so that one has</p>

<p>

<math display="block" id="Simply_typed_lambda_calculus:98">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">:</mi>
      <mrow>
       <mi>s</mi>
       <mo separator="true">,</mo>
       <mi>σ</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">:</mi>
      <mrow>
       <mi>t</mi>
       <mo separator="true">,</mo>
       <mi>τ</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mi>s</mi>
     <mo separator="true">,</mo>
     <mi>σ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
     <interval closure="open">
      <apply>
       <ci>normal-:</ci>
       <ci>s</ci>
       <ci>σ</ci>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <ci>t</ci>
       <ci>τ</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <ci>s</ci>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}(s\mathbin{:}\sigma,t\mathbin{:}\tau)=s\mathbin{:}\sigma
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Simply_typed_lambda_calculus:99">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>π</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">:</mi>
      <mrow>
       <mi>s</mi>
       <mo separator="true">,</mo>
       <mi>σ</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">:</mi>
      <mrow>
       <mi>t</mi>
       <mo separator="true">,</mo>
       <mi>τ</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mi>t</mi>
     <mo separator="true">,</mo>
     <mi>τ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">2</cn>
     </apply>
     <interval closure="open">
      <apply>
       <ci>normal-:</ci>
       <ci>s</ci>
       <ci>σ</ci>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <ci>t</ci>
       <ci>τ</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <ci>t</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{2}(s\mathbin{:}\sigma,t\mathbin{:}\tau)=t\mathbin{:}\tau
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Simply_typed_lambda_calculus:100">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi mathvariant="normal">:</mi>
        <mrow>
         <mi>u</mi>
         <mo separator="true">,</mo>
         <mi>σ</mi>
        </mrow>
       </mrow>
       <mo>×</mo>
       <mi>τ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>π</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi mathvariant="normal">:</mi>
        <mrow>
         <mi>u</mi>
         <mo separator="true">,</mo>
         <mi>σ</mi>
        </mrow>
       </mrow>
       <mo>×</mo>
       <mi>τ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>u</mi>
      <mo separator="true">,</mo>
      <mi>σ</mi>
     </mrow>
    </mrow>
    <mo>×</mo>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-:</ci>
        <ci>u</ci>
        <ci>σ</ci>
       </apply>
       <ci>τ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-:</ci>
        <ci>u</ci>
        <ci>σ</ci>
       </apply>
       <ci>τ</ci>
      </apply>
     </apply>
    </interval>
    <apply>
     <times></times>
     <apply>
      <ci>normal-:</ci>
      <ci>u</ci>
      <ci>σ</ci>
     </apply>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\pi_{1}(u\mathbin{:}\sigma\times\tau),\pi_{2}(u\mathbin{:}\sigma\times\tau))=%
u\mathbin{:}\sigma\times\tau
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Simply_typed_lambda_calculus:101">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mi>t</mi>
     <mo separator="true">,</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-:</ci>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\mathbin{:}1=()
  </annotation>
 </semantics>
</math>

 This last is read as "<em>if t has type 1, then it reduces to nil</em>".</p>

<p>The above can then be turned into a category by taking the types as the <a href="object_(category_theory)" title="wikilink">objects</a>. The <a href="morphism" title="wikilink">morphisms</a> 

<math display="inline" id="Simply_typed_lambda_calculus:102">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>→</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>σ</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\to\tau
  </annotation>
 </semantics>
</math>

 are <a href="equivalence_class" title="wikilink">equivalence classes</a> of pairs 

<math display="inline" id="Simply_typed_lambda_calculus:103">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mi>x</mi>
     <mo separator="true">,</mo>
     <mi>σ</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mi>t</mi>
     <mo separator="true">,</mo>
     <mi>τ</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <ci>normal-:</ci>
     <ci>x</ci>
     <ci>σ</ci>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <ci>t</ci>
     <ci>τ</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x\mathbin{:}\sigma,t\mathbin{:}\tau)
  </annotation>
 </semantics>
</math>

 where <em>x</em> is a variable (of type 

<math display="inline" id="Simply_typed_lambda_calculus:104">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

) and <em>t</em> is a term (of type 

<math display="inline" id="Simply_typed_lambda_calculus:105">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

), having no free variables in it, except for (optionally) <em>x</em>. Closure is obtained from <a class="uri" href="currying" title="wikilink">currying</a> and <a href="apply" title="wikilink">application</a>, as usual.</p>

<p>More precisely, there exist <a href="functor" title="wikilink">functors</a> between the category of Cartesian closed categories, and the category of simply-typed lambda theories.</p>

<p>It is common to extend this case to <a href="closed_monoidal_category" title="wikilink">closed symmetric monoidal categories</a> by using a <a href="linear_type_system" title="wikilink">linear type system</a>. The reason for this is that the CCC is a special case of the closed symmetric monoidal category, which is typically taken to be the <a href="category_of_sets" title="wikilink">category of sets</a>. This is fine for laying the foundations of <a href="set_theory" title="wikilink">set theory</a>, but the more general <a class="uri" href="topos" title="wikilink">topos</a> seems to provide a superior foundation.</p>
<h3 id="proof-theoretic-semantics">Proof-theoretic semantics</h3>

<p>The simply typed lambda calculus is closely related to the implicational fragment of propositional <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a>, i.e., <a href="minimal_logic" title="wikilink">minimal logic</a>, via the <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a>: terms correspond precisely to proofs in <a href="natural_deduction" title="wikilink">natural deduction</a>, and <a href="Type_inhabitation" title="wikilink">inhabited types</a> are exactly the <a href="tautology_(logic)" title="wikilink">tautologies</a> of minimal logic.</p>
<h2 id="alternative-syntaxes">Alternative syntaxes</h2>

<p>The presentation given above is not the only way of defining the syntax of the simply typed lambda calculus. One alternative is to remove type annotations entirely (so that the syntax is identical to the untyped lambda calculus), while ensuring that terms are well-typed via <a href="Type_inference" title="wikilink">Hindley-Milner type inference</a>. The inference algorithm is terminating, sound, and complete: whenever a term is typable, the algorithm computes its type. More precisely, it computes the term's <a href="principal_type" title="wikilink">principal type</a>, since often an unannotated term (such as 

<math display="inline" id="Simply_typed_lambda_calculus:106">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo rspace="5.8pt">.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.~{}x
  </annotation>
 </semantics>
</math>

) may have more than one type (

<math display="inline" id="Simply_typed_lambda_calculus:107">
 <semantics>
  <mrow>
   <mi>𝚒𝚗𝚝</mi>
   <mo>→</mo>
   <mi>𝚒𝚗𝚝</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>𝚒𝚗𝚝</ci>
    <ci>𝚒𝚗𝚝</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{int}\to\mathtt{int}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Simply_typed_lambda_calculus:108">
 <semantics>
  <mrow>
   <mi>𝚋𝚘𝚘𝚕</mi>
   <mo>→</mo>
   <mi>𝚋𝚘𝚘𝚕</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>𝚋𝚘𝚘𝚕</ci>
    <ci>𝚋𝚘𝚘𝚕</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{bool}\to\mathtt{bool}
  </annotation>
 </semantics>
</math>

, etc., which are all instances of the principal type 

<math display="inline" id="Simply_typed_lambda_calculus:109">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>α</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\to\alpha
  </annotation>
 </semantics>
</math>

).</p>

<p>Another alternative presentation of simply typed lambda calculus is based on <strong>bidirectional type checking</strong>, which requires more type annotations than Hindley-Milner inference but is easier to describe. The <a href="type_system" title="wikilink">type system</a> is divided into two judgments, representing both <em>checking</em> and <em>synthesis</em>, written 

<math display="inline" id="Simply_typed_lambda_calculus:110">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi>e</mi>
    <mo>⇐</mo>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <ci>normal-⇐</ci>
     <ci>e</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash e\Leftarrow\tau
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Simply_typed_lambda_calculus:111">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi>e</mi>
    <mo>⇒</mo>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <ci>normal-⇒</ci>
     <ci>e</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash e\Rightarrow\tau
  </annotation>
 </semantics>
</math>

 respectively. Operationally, the three components 

<math display="inline" id="Simply_typed_lambda_calculus:112">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Simply_typed_lambda_calculus:113">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Simply_typed_lambda_calculus:114">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 are all <em>inputs</em> to the checking judgment 

<math display="inline" id="Simply_typed_lambda_calculus:115">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi>e</mi>
    <mo>⇐</mo>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <ci>normal-⇐</ci>
     <ci>e</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash e\Leftarrow\tau
  </annotation>
 </semantics>
</math>

, whereas the synthesis judgment 

<math display="inline" id="Simply_typed_lambda_calculus:116">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mrow>
    <mi>e</mi>
    <mo>⇒</mo>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <apply>
     <ci>normal-⇒</ci>
     <ci>e</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash e\Rightarrow\tau
  </annotation>
 </semantics>
</math>

 only takes 

<math display="inline" id="Simply_typed_lambda_calculus:117">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Simply_typed_lambda_calculus:118">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 as inputs, producing the type 

<math display="inline" id="Simply_typed_lambda_calculus:119">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 as output. These judgments are derived via the following rules:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Simply_typed_lambda_calculus:120">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mi mathvariant="normal">:</mi>
     <mrow>
      <mi>x</mi>
      <mo separator="true">,</mo>
      <mi>σ</mi>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi mathvariant="normal">Γ</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mi>x</mi>
     <mo>⇒</mo>
     <mi>σ</mi>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <in></in>
     <apply>
      <ci>normal-:</ci>
      <ci>x</ci>
      <ci>σ</ci>
     </apply>
     <ci>normal-Γ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <ci>normal-⇒</ci>
      <ci>x</ci>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\frac{x\mathbin{:}\sigma\in\Gamma}{\Gamma\vdash x\Rightarrow\sigma}}
  </annotation>
 </semantics>
</math>

 [1]</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Simply_typed_lambda_calculus:121">
 <semantics>
  <mfrac>
   <mrow>
    <mi>c</mi>
    <mtext>is a constant of type</mtext>
    <mi>T</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mi>c</mi>
     <mo>⇒</mo>
     <mi>T</mi>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>c</ci>
     <mtext>is a constant of type</mtext>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <ci>normal-⇒</ci>
      <ci>c</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\frac{c\text{ is a constant of type }T}{\Gamma\vdash c\Rightarrow T}}
  </annotation>
 </semantics>
</math>

 [2]</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Simply_typed_lambda_calculus:122">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">:</mi>
      <mrow>
       <mi>x</mi>
       <mo separator="true">,</mo>
       <mi>σ</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>⊢</mo>
    <mrow>
     <mi>e</mi>
     <mo>⇐</mo>
     <mi>τ</mi>
    </mrow>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo rspace="5.8pt">.</mo>
    <mi>e</mi>
    <mo>⇐</mo>
    <mi>σ</mi>
    <mo>→</mo>
    <mi>τ</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <list>
      <ci>normal-Γ</ci>
      <apply>
       <ci>normal-:</ci>
       <ci>x</ci>
       <ci>σ</ci>
      </apply>
     </list>
     <apply>
      <ci>normal-⇐</ci>
      <ci>e</ci>
      <ci>τ</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Γ</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">e</csymbol>
     <ci>normal-⇐</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">τ</csymbol>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\frac{\Gamma,x\mathbin{:}\sigma\vdash e\Leftarrow\tau}{\Gamma\vdash\lambda x.%
~{}e\Leftarrow\sigma\to\tau}}
  </annotation>
 </semantics>
</math>

 [3]</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Simply_typed_lambda_calculus:123">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
    <mo>⇒</mo>
    <mi>σ</mi>
    <mo>→</mo>
    <mi>τ</mi>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <msub>
     <mi>e</mi>
     <mn>2</mn>
    </msub>
    <mo>⇐</mo>
    <mi>σ</mi>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mrow>
      <mpadded width="+3.3pt">
       <msub>
        <mi>e</mi>
        <mn>1</mn>
       </msub>
      </mpadded>
      <msub>
       <mi>e</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>⇒</mo>
     <mi>τ</mi>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Γ</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">τ</csymbol>
     <ci></ci>
     <csymbol cd="unknown">Γ</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⇐</ci>
     <csymbol cd="unknown">σ</csymbol>
    </cerror>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <ci>normal-⇒</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\frac{\Gamma\vdash e_{1}\Rightarrow\sigma\to\tau\quad\Gamma\vdash e_{2}%
\Leftarrow\sigma}{\Gamma\vdash e_{1}~{}e_{2}\Rightarrow\tau}}
  </annotation>
 </semantics>
</math>

 [4]</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Simply_typed_lambda_calculus:124">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mi>e</mi>
     <mo>⇒</mo>
     <mi>τ</mi>
    </mrow>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mi>e</mi>
     <mo>⇐</mo>
     <mi>τ</mi>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <ci>normal-⇒</ci>
      <ci>e</ci>
      <ci>τ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <ci>normal-⇐</ci>
      <ci>e</ci>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\frac{\Gamma\vdash e\Rightarrow\tau}{\Gamma\vdash e\Leftarrow\tau}}
  </annotation>
 </semantics>
</math>

 [5]</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Simply_typed_lambda_calculus:125">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mi>e</mi>
     <mo>⇐</mo>
     <mi>τ</mi>
    </mrow>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">:</mi>
       <mrow>
        <mi>e</mi>
        <mo separator="true">,</mo>
        <mi>τ</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⇒</mo>
     <mi>τ</mi>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <ci>normal-⇐</ci>
      <ci>e</ci>
      <ci>τ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-Γ</ci>
     <apply>
      <ci>normal-⇒</ci>
      <apply>
       <ci>normal-:</ci>
       <ci>e</ci>
       <ci>τ</ci>
      </apply>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\frac{\Gamma\vdash e\Leftarrow\tau}{\Gamma\vdash(e\mathbin{:}\tau)\Rightarrow%
\tau}}
  </annotation>
 </semantics>
</math>

 [6]</p></td>
</tr>
</tbody>
</table>

<p>Observe that rules [1]–[4] are nearly identical to rules (1)–(4) above, except for the careful choice of checking or synthesis judgments. These choices can be explained like so:</p>
<ol>
<li>If 

<math display="inline" id="Simply_typed_lambda_calculus:126">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mi>x</mi>
    <mo separator="true">,</mo>
    <mi>σ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>x</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mathbin{:}\sigma
  </annotation>
 </semantics>
</math>

 is in the context, we can synthesize type 

<math display="inline" id="Simply_typed_lambda_calculus:127">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Simply_typed_lambda_calculus:128">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

.</li>
<li>The types of term constants are fixed and can be synthesized.</li>
<li>To check that 

<math display="inline" id="Simply_typed_lambda_calculus:129">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo rspace="5.8pt">.</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.~{}e
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Simply_typed_lambda_calculus:130">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>→</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>σ</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\to\tau
  </annotation>
 </semantics>
</math>

 in some context, we extend the context with 

<math display="inline" id="Simply_typed_lambda_calculus:131">
 <semantics>
  <mrow>
   <mi mathvariant="normal">:</mi>
   <mrow>
    <mi>x</mi>
    <mo separator="true">,</mo>
    <mi>σ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>x</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mathbin{:}\sigma
  </annotation>
 </semantics>
</math>

 and check that 

<math display="inline" id="Simply_typed_lambda_calculus:132">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Simply_typed_lambda_calculus:133">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

.</li>
<li>If 

<math display="inline" id="Simply_typed_lambda_calculus:134">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}
  </annotation>
 </semantics>
</math>

 synthesizes type 

<math display="inline" id="Simply_typed_lambda_calculus:135">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>→</mo>
   <mi>τ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>σ</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\to\tau
  </annotation>
 </semantics>
</math>

 (in some context), and 

<math display="inline" id="Simply_typed_lambda_calculus:136">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{2}
  </annotation>
 </semantics>
</math>

 checks against type 

<math display="inline" id="Simply_typed_lambda_calculus:137">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 (in the same context), then 

<math display="inline" id="Simply_typed_lambda_calculus:138">
 <semantics>
  <mrow>
   <mpadded width="+3.3pt">
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
   </mpadded>
   <msub>
    <mi>e</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}~{}e_{2}
  </annotation>
 </semantics>
</math>

 synthesizes type 

<math display="inline" id="Simply_typed_lambda_calculus:139">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Observe that the rules for synthesis are read top-to-bottom, whereas the rules for checking are read bottom-to-top. Note in particular that we do <strong>not</strong> need any annotation on the lambda abstraction in rule [3], because the type of the bound variable can be deduced from the type at which we check the function. Finally, we explain rules [5] and [6] as follows:</p>
<ol start="5">
<li>To check that 

<math display="inline" id="Simply_typed_lambda_calculus:140">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Simply_typed_lambda_calculus:141">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

, it suffices to synthesize type 

<math display="inline" id="Simply_typed_lambda_calculus:142">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

.</li>
<li>If 

<math display="inline" id="Simply_typed_lambda_calculus:143">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 checks against type 

<math display="inline" id="Simply_typed_lambda_calculus:144">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

, then the explicitly annotated term 

<math display="inline" id="Simply_typed_lambda_calculus:145">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">:</mi>
    <mrow>
     <mi>e</mi>
     <mo separator="true">,</mo>
     <mi>τ</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>e</ci>
    <ci>τ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (e\mathbin{:}\tau)
  </annotation>
 </semantics>
</math>

 synthesizes 

<math display="inline" id="Simply_typed_lambda_calculus:146">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Because of these last two rules coercing between synthesis and checking, it is easy to see that any well-typed but unannotated term can be checked in the bidirectional system, so long as we insert "enough" type annotations. And in fact, annotations are needed only at β-redexes.</p>
<h2 id="general-observations">General observations</h2>

<p>Given the standard semantics, the simply typed lambda calculus is <a href="Normalization_property_(lambda-calculus)" title="wikilink">strongly normalizing</a>: that is, well-typed terms always reduce to a value, i.e., a 

<math display="inline" id="Simply_typed_lambda_calculus:147">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 abstraction. This is because recursion is not allowed by the typing rules: it is impossible to find types for <a href="fixed-point_combinator" title="wikilink">fixed-point combinators</a> and the looping term 

<math display="inline" id="Simply_typed_lambda_calculus:148">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo rspace="5.8pt">.</mo>
    <mpadded width="+3.3pt">
     <mi>x</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo rspace="5.8pt">.</mo>
    <mpadded width="+3.3pt">
     <mi>x</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Ω</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=(\lambda x.~{}x~{}x)(\lambda x.~{}x~{}x)
  </annotation>
 </semantics>
</math>

. Recursion can be added to the language by either having a special operator 

<math display="inline" id="Simply_typed_lambda_calculus:149">
 <semantics>
  <msub>
   <mi>𝚏𝚒𝚡</mi>
   <mi>α</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝚏𝚒𝚡</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathtt{fix}_{\alpha}
  </annotation>
 </semantics>
</math>

of type 

<math display="inline" id="Simply_typed_lambda_calculus:150">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha\to\alpha)\to\alpha
  </annotation>
 </semantics>
</math>

 or adding general <a href="recursive_type" title="wikilink">recursive types</a>, though both eliminate strong normalization.</p>

<p>Since it is strongly normalising, it is <a href="decidability_(logic)" title="wikilink">decidable</a> whether or not a simply typed lambda calculus program halts: in fact, it <em>always</em> halts. We can therefore conclude that the language is <em>not</em> <a href="Turing_complete" title="wikilink">Turing complete</a>.</p>
<h2 id="important-results">Important results</h2>
<ul>
<li>Tait showed in 1967 that 

<math display="inline" id="Simply_typed_lambda_calculus:151">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

-reduction is <a href="Normalization_property_(lambda-calculus)" title="wikilink">strongly normalizing</a>. As a corollary 

<math display="inline" id="Simply_typed_lambda_calculus:152">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mi>η</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>β</ci>
    <ci>η</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\eta
  </annotation>
 </semantics>
</math>

-equivalence is <a href="decidability_(logic)" title="wikilink">decidable</a>. Statman showed in 1977 that the normalisation problem is not <a href="elementary_recursive" title="wikilink">elementary recursive</a>. A purely semantic normalisation proof (see <a href="normalisation_by_evaluation" title="wikilink">normalisation by evaluation</a>) was given by Berger and Schwichtenberg in 1991.</li>
<li>The <a href="unification_(computing)" title="wikilink">unification</a> problem for 

<math display="inline" id="Simply_typed_lambda_calculus:153">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mi>η</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>β</ci>
    <ci>η</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\eta
  </annotation>
 </semantics>
</math>

-equivalence is undecidable. Huet showed in 1973 that 3rd order unification is undecidable and this was improved upon by Baxter in 1978 then by Goldfarb in 1981 by showing that 2nd order unification is already undecidable. Whether higher order matching (unification where only one term contains existential variables) is decidable is still open. [2006: Colin Stirling, Edinburgh, has published a proof-sketch in which he claims that the problem is decidable; however, the complete version of the proof is still unpublished]</li>
<li>We can encode <a href="natural_number" title="wikilink">natural numbers</a> by terms of the type 

<math display="inline" id="Simply_typed_lambda_calculus:154">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>o</mi>
    <mo>→</mo>
    <mi>o</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>o</mi>
    <mo>→</mo>
    <mi>o</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">o</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (o\to o)\to(o\to o)
  </annotation>
 </semantics>
</math>

 (<a href="Church_numeral" title="wikilink">Church numerals</a>). Schwichtenberg showed in 1976 that in 

<math display="inline" id="Simply_typed_lambda_calculus:155">
 <semantics>
  <msup>
   <mi>λ</mi>
   <mo>→</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>λ</ci>
    <ci>normal-→</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda^{\to}
  </annotation>
 </semantics>
</math>

 exactly the extended <a href="polynomial" title="wikilink">polynomials</a> are representable as functions over Church numerals; these are roughly the polynomials closed up under a conditional operator.</li>
<li>A <em>full model</em> of 

<math display="inline" id="Simply_typed_lambda_calculus:156">
 <semantics>
  <msup>
   <mi>λ</mi>
   <mo>→</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>λ</ci>
    <ci>normal-→</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda^{\to}
  </annotation>
 </semantics>
</math>

 is given by interpreting base types as <a href="Set_(mathematics)" title="wikilink">sets</a> and function types by the set-theoretic <a href="function_space" title="wikilink">function space</a>. Friedman showed in 1975 that this interpretation is <a href="Completeness_(logic)" title="wikilink">complete</a> for 

<math display="inline" id="Simply_typed_lambda_calculus:157">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mi>η</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>β</ci>
    <ci>η</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\eta
  </annotation>
 </semantics>
</math>

-equivalence, if the base types are interpreted by infinite sets. Statman showed in 1983 that 

<math display="inline" id="Simply_typed_lambda_calculus:158">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mi>η</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>β</ci>
    <ci>η</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\eta
  </annotation>
 </semantics>
</math>

-equivalence is the maximal equivalence which is <em>typically ambiguous</em>, i.e. closed under type substitutions (<em>Statman's Typical Ambiguity Theorem</em>). A corollary of this is that the <em>finite model property</em> holds, i.e. finite sets are sufficient to distinguish terms which are not identified by 

<math display="inline" id="Simply_typed_lambda_calculus:159">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mi>η</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>β</ci>
    <ci>η</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\eta
  </annotation>
 </semantics>
</math>

-equivalence.</li>
<li>Plotkin introduced logical relations in 1973 to characterize the elements of a model which are definable by lambda terms. In 1993 Jung and Tiuryn showed that a general form of logical relation (Kripke logical relations with varying arity) exactly characterizes lambda definability. Plotkin and Statman conjectured that it is decidable whether a given element of a model generated from finite sets is definable by a lambda term (<em>Plotkin-Statman-conjecture</em>). The conjecture was shown to be false by Loader in 1993.</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="see-also">See also</h2>
<ul>
<li>Article <a href="http://plato.stanford.edu/entries/type-theory-church/">Church's Type Theory</a> in the Stanford Encyclopedia of Philosophy.</li>
<li><a href="Type_inference#Hindley–Milner_type_inference_algorithm" title="wikilink">Hindley-Milner type inference algorithm</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>A. Church: A Formulation of the Simple Theory of Types, JSL 5, 1940</li>
<li><a href="William_W._Tait" title="wikilink">W.W.Tait</a>: Intensional Interpretations of Functionals of Finite Type I, JSL 32(2), 1967</li>
<li>G.D. Plotkin: Lambda-definability and logical relations, Technical report, 1973</li>
<li>G.P. Huet: The Undecidability of Unification in Third Order Logic Information and Control 22(3): 257-267 (1973)</li>
<li>H. Friedman: Equality between functionals. LogicColl. '73, pages 22-37, LNM 453, 1975.</li>
<li>H. Schwichtenberg: Functions definable in the simply-typed lambda calculus, Arch. Math Logik 17 (1976) 113-114.</li>
<li>R. Statman: The Typed lambda-Calculus Is not Elementary Recursive FOCS 1977: 90-94</li>
<li>W. D. Goldfarb: The undecidability of the 2nd order unification problem, TCS (1981), no. 13, 225- 230.</li>
<li>R. Statman. 

<math display="inline" id="Simply_typed_lambda_calculus:160">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

-definable functionals and 

<math display="inline" id="Simply_typed_lambda_calculus:161">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mi>η</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>β</ci>
    <ci>η</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\eta
  </annotation>
 </semantics>
</math>

 conversion. Arch. Math. Logik, 23:21–26, 1983.</li>
<li>J. Lambek: Cartesian Closed Categories and Typed Lambda-calculi. Combinators and Functional Programming Languages 1985: 136-175</li>
<li>U. Berger, H. Schwichtenberg: An Inverse of the Evaluation Functional for Typed lambda-calculus LICS 1991: 203-211</li>
<li>Jung, A.,Tiuryn, J.:A New Characterization of Lambda Definability, TLCA 1993</li>
<li>R. Loader: <a href="http://homepages.ihug.co.nz/~suckfish/papers/Church.pdf">The Undecidability of λ-definability</a>, appeared in the Church Festschrift, 2001</li>
<li>H. Barendregt, <a href="ftp://ftp.cs.ru.nl/pub/CompMath.Found/HBK.ps">Lambda Calculi with Types</a>, Handbook of Logic in Computer Science, Volume II, Oxford University Press, 1993. ISBN 0-19-853761-1.</li>
<li>L. Baxter: The undecidability of the third order dyadic unification problem, Information and Control 38(2), 170-178 (1978)</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
