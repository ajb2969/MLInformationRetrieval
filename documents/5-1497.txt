   Josephus problem      Josephus problem   In computer science and mathematics , the Josephus Problem (or Josephus permutation ) is a theoretical problem related to a certain counting-out game .  There are people standing in a circle waiting to be executed. The counting out begins at some point in the circle and proceeds around the circle in a fixed direction. In each step, a certain number of people are skipped and the next person is executed. The elimination proceeds around the circle (which is becoming smaller and smaller as the executed people are removed), until only the last person remains, who is given freedom.  The task is to choose the place in the initial circle so that you are the last one remaining and so survive.  History  The problem is named after Flavius Josephus , a Jewish historian living in the 1st century. According to Josephus' account of the siege of Yodfat , he and his 40 soldiers were trapped in a cave, the exit of which was blocked by Romans . They chose suicide over capture and decided that they would form a circle and start killing themselves using a step of three. Josephus states that by luck or possibly by the hand of God, he and another man remained the last and gave up to the Romans.  The reference comes from Book 3, Chapter 8, par 7 of Josephus' The Jewish War (writing of himself in the third person):   Solution  In the following,   n   n   n   denotes the number of people in the initial circle, and   k   k   k   denotes the count for each step, that is,    k  -  1      k  1    k-1   people are skipped and the   k   k   k   -th is executed. The people in the circle are numbered from   1   1   1   to   n   n   n   .  ===k=2=== We explicitly solve the problem when every 2nd person will be killed, i.e.    k  =  2      k  2    k=2   . (For the more general case    k  ≠  2      k  2    k\neq 2   , we outline a solution below.) We express the solution recursively. Let    f   (  n  )       f  n    f(n)   denote the position of the survivor when there are initially   n   n   n   people (and    k  =  2      k  2    k=2   ). The first time around the circle, all of the even-numbered people die. The second time around the circle, the new 2nd person dies, then the new 4th person, etc.; it's as though there were no first time around the circle.  If the initial number of people was even, then the person in position   x   x   x   during the second time around the circle was originally in position     2  x   -  1        2  x   1    2x-1   (for every choice of   x   x   x   ). Let    n  =   2  j       n    2  j     n=2j   . The person at    f   (  j  )       f  j    f(j)   who will now survive was originally in position     2  f   (  j  )    -  1        2  f  j   1    2f(j)-1   . This gives us the recurrence       f   (   2  j   )    =    2  f   (  j  )    -  1 .         f    2  j        2  f  j   1 .     f(2j)=2f(j)-1\;.     If the initial number of people was odd, then we think of person 1 as dying at the end of the first time around the circle. Again, during the second time around the circle, the new 2nd person dies, then the new 4th person, etc. In this case, the person in position   x   x   x   was originally in position     2  x   +  1        2  x   1    2x+1   . This gives us the recurrence       f   (    2  j   +  1   )    =    2  f   (  j  )    +  1 .         f      2  j   1        2  f  j   1 .     f(2j+1)=2f(j)+1\;.     When we tabulate the values of   n   n   n   and    f   (  n  )       f  n    f(n)   we see a pattern:         n   n   n      1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16         f   (  n  )       f  n    f(n)      1   1   3   1   3   5   7   1   3   5   7   9   11   13   15   1     This suggests that    f   (  n  )       f  n    f(n)   is an increasing odd sequence that restarts with     f   (  n  )    =  1        f  n   1    f(n)=1   whenever the index n is a power of 2. Therefore, if we choose m and l so that    n  =    2  m   +  l       n     superscript  2  m   l     n=2^{m}+l   and    0  ≤  l  <   2  m         0  l        superscript  2  m      0\leq l<2^{m}   , then     f   (  n  )    =    2  ⋅  l   +  1         f  n      normal-⋅  2  l   1     f(n)=2\cdot l+1   . It is clear that values in the table satisfy this equation. Or we can think that after   l   l   l   people are dead there are only    2  m     superscript  2  m    2^{m}   people and we go to the     2  l   +  1        2  l   1    2l+1   th person. He must be the survivor. So     f   (  n  )    =    2  l   +  1         f  n       2  l   1     f(n)=2l+1   . Below, we give a proof by induction.  Theorem: If    n  =    2  m   +  l       n     superscript  2  m   l     n=2^{m}+l   and    0  ≤  l  <   2  m         0  l        superscript  2  m      0\leq l<2^{m}   , then     f   (  n  )    =    2  l   +  1         f  n       2  l   1     f(n)=2l+1   .  Proof: We use strong induction on   n   n   n   . The base case    n  =  1      n  1    n=1   is true. We consider separately the cases when   n   n   n   is even and when   n   n   n   is odd.  If   n   n   n   is even, then choose    l  1     subscript  l  1    l_{1}   and    m  1     subscript  m  1    m_{1}   such that     n  /  2   =    2   m  1    +   l  1          n  2      superscript  2   subscript  m  1     subscript  l  1      n/2=2^{m_{1}}+l_{1}   and    0  ≤   l  1   <   2   m  1          0   subscript  l  1         superscript  2   subscript  m  1       0\leq l_{1}<2^{m_{1}}   . Note that     l  1   =   l  /  2        subscript  l  1     l  2     l_{1}=l/2   . We have     f   (  n  )    =    2  f   (   n  /  2   )    -  1   =    2   (    (   2   l  1    )   +  1   )    -  1   =    2  l   +  1           f  n       2  f    n  2    1            2      2   subscript  l  1    1    1            2  l   1      f(n)=2f(n/2)-1=2((2l_{1})+1)-1=2l+1   , where the second equality follows from the induction hypothesis.  If   n   n   n   is odd, then choose    l  1     subscript  l  1    l_{1}   and    m  1     subscript  m  1    m_{1}   such that      (   n  -  1   )   /  2   =    2   m  1    +   l  1            n  1   2      superscript  2   subscript  m  1     subscript  l  1      (n-1)/2=2^{m_{1}}+l_{1}   and    0  ≤   l  1   <   2   m  1          0   subscript  l  1         superscript  2   subscript  m  1       0\leq l_{1}<2^{m_{1}}   . Note that     l  1   =    (   l  -  1   )   /  2        subscript  l  1       l  1   2     l_{1}=(l-1)/2   . We have     f   (  n  )    =    2  f   (    (   n  -  1   )   /  2   )    +  1   =    2   (    (   2   l  1    )   +  1   )    +  1   =    2  l   +  1           f  n       2  f      n  1   2    1            2      2   subscript  l  1    1    1            2  l   1      f(n)=2f((n-1)/2)+1=2((2l_{1})+1)+1=2l+1   , where the second equality follows from the induction hypothesis. This completes the proof.  We can solve for   l   l   l   to get an explicit expression for    f   (  n  )       f  n    f(n)   :       f   (  n  )    =    2   (   n  -   2   ⌊    log  2    (  n  )    ⌋     )    +  1         f  n       2    n   superscript  2      subscript   2   n       1     f(n)=2(n-2^{\lfloor\log_{2}(n)\rfloor})+1     The most elegant form of the answer involves the binary representation of size   n   n   n       f   (  n  )       f  n    f(n)   can be obtained by a one-bit left cyclic shift of   n   n   n   itself. If we represent   n   n   n   in binary as    n  =   1   b  1    b  2    b  3   …   b  m        n    1   subscript  b  1    subscript  b  2    subscript  b  3   normal-…   subscript  b  m      n=1b_{1}b_{2}b_{3}\dots b_{m}   , then the solution is given by     f   (  n  )    =    b  1    b  2    b  3   …   b  m   1         f  n      subscript  b  1    subscript  b  2    subscript  b  3   normal-…   subscript  b  m   1     f(n)=b_{1}b_{2}b_{3}\dots b_{m}1   . The proof of this follows from the representation of   n   n   n   as     2  m   +  l       superscript  2  m   l    2^{m}+l   or from the above expression for    f   (  n  )       f  n    f(n)   .  The general case  The easiest way to solve this problem in the general case is to use dynamic programming by performing the first step and then using the solution of the remaining problem. When the index starts from one, then the person at   s   s   s   shifts from the first person is in position     (    (   s  -  1   )   mod  n   )   +  1       modulo    s  1   n   1    ((s-1)\bmod n)+1   , where n is the total number of persons. Let    f   (  n  ,  k  )       f   n  k     f(n,k)   denote the position of the survivor. After the   k   k   k   -th person is killed, we're left with a circle of    n  -  1      n  1    n-1   , and we start the next count with the person whose number in the original problem was     (   k  mod  n   )   +  1       modulo  k  n   1    (k\bmod n)+1   . The position of the survivor in the remaining circle would be    f   (   n  -  1   ,  k  )       f     n  1   k     f(n-1,k)   if we start counting at   1   1   1   ; shifting this to account for the fact that we're starting at     (   k  mod  n   )   +  1       modulo  k  n   1    (k\bmod n)+1   yields the recurrence         f   (  n  ,  k  )    =    (    (     f   (   n  -  1   ,  k  )    +  k   -  1   )   mod  n   )   +  1    ,    with  f   (  1  ,  k  )    =   1     ,     formulae-sequence      f   n  k       modulo        f     n  1   k    k   1   n   1        with  f   1  k    1     f(n,k)=((f(n-1,k)+k-1)\bmod n)+1,\text{ with }f(1,k)=1\,,     which takes the simpler form        g   (  n  ,  k  )    =    (    g   (   n  -  1   ,  k  )    +  k   )   mod  n    ,    with  g   (  1  ,  k  )    =  0      formulae-sequence      g   n  k     modulo      g     n  1   k    k   n        with  g   1  k    0     g(n,k)=(g(n-1,k)+k)\bmod n,\text{ with }g(1,k)=0     if we number the positions from   0   0    to    n  -  1      n  1    n-1   instead.  This approach has running time     O   (  n  )       O  n    O(n)   , but for small   k   k   k   and large   n   n   n   there is another approach. The second approach also uses dynamic programming but has running time    O   (   k   log  n    )       O    k    n      O(k\log n)   . It is based on considering killing k -th, 2 k -th, ...,    (    ⌊   n  /  k   ⌋   k   )          n  k    k    (\lfloor n/k\rfloor k)   -th people as one step, then changing the numbering.  Variants and generalizations  Josephus had an accomplice; the problem was then to find the places of the two last remaining survivors (whose conspiracy would ensure their survival). It is alleged that he placed himself and the other man in the 31st and 16th place respectively. 1 A generalization of this process is as follows. We suppose that every   m   m   m   th person will be executed from a group of size   n   n   n   , in which the   p   p   p   th person is the survivor. If there is an addition of   x   x   x   people to the circle, then the survivor is in the    p  +   m  x       p    m  x     p+mx   th position if there is less than or equal to    n  +  x      n  x    n+x   . If   x   x   x   is the lowest value in which     (   p  +   m  x    )   >   (   n  +  x   )         p    m  x      n  x     (p+mx)>(n+x)   , then the survivor is in position     (   p  +   m  x    )   -   (   n  +  x   )         p    m  x      n  x     (p+mx)-(n+x)   . 2  Extended Josephus problem  Problem definition: There are n persons, numbered 1 to n , around a circle. We eliminate second of every two remaining persons until one person remains. Given the n , determine the number of x th person who is eliminated. 3  Notes  References     External links   Josephus Flavius game (Java Applet) at cut-the-knot allowing selection of every n th out of 50 (maximum).  Josephus Problem at the MathWorld encyclopedia   "  Category:Combinatorics  Category:Permutations  Category:Mathematical problems  Category:Computational problems     ↩  ↩  Armin Shams-Baragh Formulating The Extended Josephus Problem . ↩     