   Cycles per instruction      Cycles per instruction   In computer architecture , cycles per instruction (aka clock cycles per instruction , clocks per instruction , or CPI ) is one aspect of a processor's performance: the average number of clock cycles per instruction for a program or program fragment. 1 It is the multiplicative inverse of instructions per cycle .  Definition  Cycles Per Instruction is defined by the following:       C  P  I   =    Σ   (   I  I  C   )    (   C  C  I   )     I  C          C  P  I       normal-Σ    I  I  C     C  C  I      I  C      CPI=\frac{\Sigma(IIC)(CCI)}{IC}     Where IIC is the number of instructions for a given instruction type, CCI is the clock-cycles for a given instruction type, IC is the total instruction count. The summation sums over all instruction types for a given benchmarking process.  Explanation  Let us assume a classic RISC pipeline , with the following 5 stages:   Instruction fetch cycle (IF)  Instruction decode/Register fetch cycle (ID)  Execution/Effective address cycle (EX)  Memory access (MEM)  Write-back cycle (WB)   Each stage requires one clock cycle and an instruction passes through the stages sequentially. Without pipelining , a new instruction is fetched in stage 1 only after the previous instruction finishes at stage 5. Therefore without pipelining the number of cycles it takes to execute an instruction is 5. This is the definition of CPI.  With pipelining we can improve the CPI by exploiting instruction level parallelism . For example, what if an instruction is fetched every cycle? We could theoretically have 5 instructions in the 5 pipeline stages at once (one instruction per stage). In this case, a different instruction would complete stage 5 in every clock cycle, and therefore on average we have one clock cycle per instruction (CPI = 1).  With a single-issue processor, the best CPI attainable is 1. However with multiple-issue processors, we may achieve even better CPI values. For example a processor that issues two instructions per clock cycle (see Superscalar ) can achieve a CPI of 0.5 when two instructions are completing every clock cycle.  Examples  Example 1  For the multi-cycle MIPS , there are 5 types of instructions:   Load (5 cycles)  Store (4 cycles)  R-type (4 cycles)  Branch (3 cycles)  Jump (3 cycles)   If a program has:   50% R-type instructions  15% load instructions  25% store instructions  8% branch instructions  2% jump instructions   then, the CPI is:      CPI  =     5  ×  50   +   4  ×  15   +   4  ×  25   +   3  ×  8   +   3  ×  2    100   =  4.05        CPI        5  50     4  15     4  25     3  8     3  2    100        4.05     \text{CPI}=\frac{5\times 50+4\times 15+4\times 25+3\times 8+3\times 2}{100}=4.05     Example 2  2 A 400- MHz processor was used to execute a benchmark program with the following instruction mix and clock cycle count:      Instruction type   Instruction count   Clock cycle count       Integer arithmetic   45000   1     Data transfer   32000   2     Floating point   15000   2     Control transfer   8000   2     Determine the effective CPI, MIPS rate, and execution time for this program.   Total instruction count = 100000       CPI  =     45000  ×  1   +   32000  ×  2   +   15000  ×  2   +   8000  ×  2    100000   =   155000  100000   =  1.55        CPI        45000  1     32000  2     15000  2     8000  2    100000          155000  100000        1.55     \text{CPI}=\frac{45000\times 1+32000\times 2+15000\times 2+8000\times 2}{10000%
 0}=\frac{155000}{100000}=1.55       Effective processor performance  =  MIPS  =   clock frequency   CPI  ×  1000000    =    400  ×  1000000    1.55  ×  1000000    =    258   MIPS         Effective processor performance  MIPS         clock frequency    CPI  1000000             400  1000000     1.55  1000000           258  MIPS      \text{Effective processor performance}=\text{MIPS}=\frac{\text{clock frequency%
 }}{\text{CPI}\times 1000000}=\frac{400\times 1000000}{1.55\times 1000000}=258%
 \,\text{MIPS}     Therefore:       Execution time   (  T  )    =   CPI  ×  Instruction count  ×  clock time   =    CPI  ×  Instruction Count   frequency   =    1.55  ×  100000    400  ×  1000000    =   1.55  4000   =    0.387   ms           Execution time  T     CPI  Instruction count  clock time            CPI  Instruction Count   frequency            1.55  100000     400  1000000           1.55  4000          0.387  ms      \text{Execution time}(T)=\text{CPI}\times\text{Instruction count}\times\text{%
 clock time}=\frac{\text{CPI}\times\text{Instruction Count}}{\text{frequency}}=%
 \frac{1.55\times 100000}{400\times 1000000}=\frac{1.55}{4000}=0.387\,\text{ms}     See also   MIPS  Instructions per cycle (IPC)  Instructions per second (IPS)  Cycle per second ( Hz )  Megahertz myth  The benchmark article provides a useful introduction to computer performance measurement for those readers interested in the topic.   References  "  Category:Instruction processing  Category:Clock signal  Category:Rates     ↩  Advanced Computer Architecture by Kai Hwang, Chapter 1, Exercise Problem 1.1 ↩     