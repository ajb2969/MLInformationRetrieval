<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="402">Group method of data handling</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Group method of data handling</h1>
<hr/>

<p><strong>Group method of data handling (GMDH)</strong> is a family of inductive algorithms for computer-based mathematical modeling of multi-parametric datasets that features fully automatic structural and parametric optimization of models.</p>

<p>GMDH is used in such fields as <a href="data_mining" title="wikilink">data mining</a>, <a href="knowledge_discovery" title="wikilink">knowledge discovery</a>, <a href="forecasting" title="wikilink">prediction</a>, <a href="complex_systems" title="wikilink">complex systems</a> modeling, <a href="Optimization_(mathematics)" title="wikilink">optimization</a> and <a href="pattern_recognition" title="wikilink">pattern recognition</a>.</p>

<p>GMDH algorithms are characterized by inductive procedure that performs sorting-out of gradually complicated polynomial models and selecting the best solution by means of the so-called <em>external criterion</em>.</p>

<p>A GMDH model with multiple inputs and one output is a subset of components of the <em>base function</em> (1):</p>

<p>

<math display="block" id="Group_method_of_data_handling:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>f</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Y</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(x_{1},\dots,x_{n})=a_{0}+\sum\limits_{i=1}^{m}a_{i}f_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>f</em> are elementary functions dependent on different sets of inputs, <em>a</em> are coefficients and <em>m</em> is the number of the base function components.</p>

<p>In order to find the best solution GMDH algorithms consider various component subsets of the base function (1) called <em>partial models</em>. Coefficients of these models are estimated by the <a href="least_squares" title="wikilink">least squares</a> method. GMDH algorithms gradually increase the number of partial model components and find a model structure with optimal complexity indicated by the minimum value of an <em>external criterion</em>. This process is called self-organization of models.</p>

<p>The most popular base function used in GMDH is the gradually complicated Kolmogorov-Gabor polynomial (2):</p>

<p>

<math display="block" id="Group_method_of_data_handling:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mi>i</mi>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>a</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>x</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mi>i</mi>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>k</mi>
         <mo>=</mo>
         <mi>j</mi>
        </mrow>
        <mi>n</mi>
       </munderover>
       <mrow>
        <msub>
         <mi>a</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
          <mi>k</mi>
         </mrow>
        </msub>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <msub>
         <mi>x</mi>
         <mi>j</mi>
        </msub>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Y</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>k</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(x_{1},\dots,x_{n})=a_{0}+\sum\limits_{i=1}^{n}{a_{i}}x_{i}+\sum\limits_{i=1}%
^{n}{\sum\limits_{j=i}^{n}{a_{ij}}}x_{i}x_{j}+\sum\limits_{i=1}^{n}{\sum%
\limits_{j=i}^{n}{\sum\limits_{k=j}^{n}{a_{ijk}}}}x_{i}x_{j}x_{k}+\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>The resulting models are also known as <strong>polynomial neural networks</strong>. <a href="Jürgen_Schmidhuber" title="wikilink">Jürgen Schmidhuber</a> cites GDMH as one of the earliest <a href="deep_learning" title="wikilink">deep learning</a> methods, remarking that it was used to train eight-layer neural nets as early as 1971.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="history">History</h2>

<p> The method was originated in 1968 by Prof. <a href="Alexey_Grigorevich_Ivakhnenko" title="wikilink">Alexey G. Ivakhnenko</a> in the Institute of Cybernetics in <a class="uri" href="Kiev" title="wikilink">Kiev</a> (Ukraine). This approach from the very beginning was a computer-based method so, a set of computer programs and algorithms were the primary practical results achieved at the base of the new theoretical principles. Thanks to the author's policy of open code sharing the method was quickly settled in the large number of scientific laboratories world wide. At that time code sharing was quite a physical action since the Internet is at least 5 years younger than GMDH. Despite this fact the first investigation of GMDH outside the Soviet Union had been made soon by R.Shankar in 1972. Later on different GMDH variants were published by Japanese and Polish scientists.</p>

<p><strong>Period 1968-1971</strong> is characterized by application of only regularity criterion for solving of the problems of identification, pattern recognition and short-term forecasting. As reference functions polynomials, logical nets, fuzzy Zadeh sets and Bayes probability formulas were used. Authors were stimulated by very high accuracy of forecasting with the new approach. Noiseimmunity was not investigated.</p>

<p><strong>Period 1972-1975</strong>. The problem of modeling of noised data and incomplete information basis was solved. Multicriteria selection and utilization of additional priory information for noiseimmunity increasing were proposed. Best experiments showed that with extended definition of the optimal model by additional criterion noise level can be ten times more than signal. Then it was improved using <a href="Shannon's_Theorem" title="wikilink">Shannon's Theorem</a> of General Communication theory.</p>

<p><strong>Period 1976-1979</strong>. The convergence of multilayered GMDH algorithms was investigated. It was shown that some multilayered algorithms have "multilayerness error" - analogous to static error of control systems. In 1977 a solution of objective systems analysis problems by multilayered GMDH algorithms was proposed. It turned out that sorting-out by criteria ensemble finds the only optimal system of equations and therefore to show complex object elements, their main input and output variables.</p>

<p><strong>Period 1980-1988</strong>. Many important theoretical results were received. It became clear that full physical models cannot be used for long-term forecasting. It was proved, that non-physical models of GMDH are more accurate for approximation and forecast than physical models of regression analysis. Two-level algorithms which use two different time scales for modeling were developed.</p>

<p><strong>Since 1989</strong> the new algorithms (AC, OCC, PF) for non-parametric modeling of fuzzy objects and SLP for expert systems were developed and investigated. Present stage of GMDH development can be described as blossom out of twice-multilayered neuronets and parallel combinatorial algorithms for multiprocessor computers.</p>
<h2 id="external-criteria">External criteria</h2>

<p>External criterion is one of the key features of GMDH. Criterion describes requirements to the model, for example minimization of <a href="Least_squares" title="wikilink">Least squares</a>. It is always calculated with a separate part of data sample that have not been used for estimation of coefficients. There are several popular criteria:</p>
<ul>
<li>Criterion of Regularity (CR) - <a href="Least_squares" title="wikilink">Least squares</a> of a model at the sample B.</li>
<li>Criterion of Unbiasedness - Sum of CR value and special CR for which A is B and B is A. Ratio of sample lengthes must be 1:1 i.e. size of A must be the same as size of B.</li>
</ul>

<p>If a criterion does not define the number of observations for external dataset then the problem of data dividing ratio appears because the forecasting abilities of identified model are very dependent on the dividing ratio.</p>
<h2 id="gmdh-type-neural-networks">GMDH-type neural networks</h2>

<p>There are many different ways to choose an order for partial models consideration. The very first consideration order used in GMDH and originally called multilayered inductive procedure is the most popular one. It is a sorting-out of gradually complicated models generated from Kolmogorov-Gabor polinomial. The best model is indicated by the minimum of the external criterion characteristic. Multilayered procedure is equivalent to the <a href="Artificial_Neural_Network" title="wikilink">Artificial Neural Network</a> with polynomial activation function of neurons. Therefore the algorithm with such an approach usually referred as GMDH-type Neural Network or Polynomial Neural Network.</p>
<h2 id="combinatorial-gmdh">Combinatorial GMDH</h2>
<figure><b>(Figure)</b>
<figcaption>Fig.1. A typical distribution of minimal values of criterion of regularity for Combinatorial GMDH models with different complexity.</figcaption>
</figure>

<p>Another important approach to partial models consideration that becomes more and more popular is a brute force combinatorial search that is either limited or full. This approach has some advantages against Polynomial Neural Networks but requires considerable computational power and thus is not effective for objects with more than 30 inputs in case of full search. An important achievement of Combinatorial GMDH is that it fully outperforms linear regression approach if noise level in the input data is greater than zero.</p>

<p>Basic combinatorial algorithm makes the following steps:</p>
<ul>
<li>Divides data sample onto parts A and B.</li>
<li>Generates structures for partial models.</li>
<li>Estimates coefficients of partial models using <a href="Least_squares" title="wikilink">Least squares</a> method and sample A.</li>
<li>Calculates value of external criterion for partial models using sample B.</li>
<li>Chooses the best model (set of models) indicated by minimal value of the criterion.</li>
</ul>

<p>In contrast to GMDH-type neural networks Combinatorial algorithm can't be stopped at the certain level of complexity because a point of increase of criterion value can be simply a local minimum, see Fig.1.</p>
<h2 id="algorithms">Algorithms</h2>
<ul>
<li>Combinatorial (COMBI)</li>
<li>Multilayered Iterative (MIA)</li>
<li>GN</li>
<li>Objective System Analysis (OSA)</li>
<li>Harmonical</li>
<li>Two-level (ARIMAD)</li>
<li>Multiplicative-Additive (MAA)</li>
<li>Objective Computer Clusterization (OCC);</li>
<li>Pointing Finger (PF) clusterization algorithm;</li>
<li>Analogues Complexing (AC)</li>
<li>Harmonical Rediscretization</li>
<li>Algorithm on the base of Multilayered Theory of Statistical Decisions (MTSD)</li>
<li>Group of Adaptive Models Evolution (GAME)</li>
</ul>
<h2 id="list-of-software">List of software</h2>
<ul>
<li><a href="http://neuron.felk.cvut.cz/game/project.html">FAKE GAME Project</a> — Open source. Cross-platform.</li>
<li><a href="http://research.guilan.ac.ir/gevom/">GEvom</a> — Free upon request for academic use. Windows-only.</li>
<li><a href="http://www.gmdhshell.com">GMDH Shell</a> — forecasting software for business. Commercial product with free trial. Windows-only. Learning algorithms: combinatorial GMDH and GMDH-type neural networks.</li>
<li><a href="http://www.knowledgeminer.eu/about.html">KnowledgeMiner</a> — Commercial product. Mac OS X-only. Free Demo version available.</li>
<li><a href="http://pnn.pnnsoft.com/index.html">PNN Discovery client</a> — Commercial product.</li>
<li><a href="http://sourceforge.net/projects/sciengyrpf/">Sciengy RPF!</a> — Freeware, Open source.</li>
<li><a href="http://wgmdh.irb.hr/en/project/">wGMDH</a> — <a href="Weka_(machine_learning)" title="wikilink">Weka</a> plugin, Open source.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.gmdh.net">www.gmdh.net</a> — Articles, books and software.</li>
<li><a href="http://www.opengmdh.org">www.opengmdh.org</a> — GMDH wiki and code development</li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>A.G. Ivakhnenko. <em>Heuristic Self-Organization in Problems of Engineering Cybernetics</em>. Automatica 6: pp. 207–219, 1970.</li>
<li>A.G. Ivakhnenkofrf. <em>Polynomial Theory of Complex System</em>. IEEE Trans. on Systems, Man and Cybernetics, Vol. SMC-1, No. 4, Oct. 1971, pp. 364–378.</li>
<li>S.J. Farlow. <em>Self-Organizing Methods in Modelling: GMDH Type Algorithms</em>. New-York, Bazel: Marcel Decker Inc., 1984, 350 p.</li>
<li>H.R. Madala, A.G. Ivakhnenko. <em>Inductive Learning Algorithms for Complex Systems Modeling</em>. CRC Press, Boca Raton, 1994.</li>
</ul>

<p>"</p>

<p><a href="Category:Computational_statistics" title="wikilink">Category:Computational statistics</a> <a href="Category:Artificial_neural_networks" title="wikilink">Category:Artificial neural networks</a> <a href="Category:Classification_algorithms" title="wikilink">Category:Classification algorithms</a> <a href="Category:Regression_variable_selection" title="wikilink">Category:Regression variable selection</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
