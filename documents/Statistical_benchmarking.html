<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1796">Statistical benchmarking</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Statistical benchmarking</h1>
<hr/>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a>, <strong>benchmarking</strong> is a method of using auxiliary information to adjust the <a href="weight_function" title="wikilink">sampling weights</a> used in an <a class="uri" href="estimation" title="wikilink">estimation</a> process, in order to yield more accurate estimates of totals.</p>

<p>Suppose we have a <a href="population_(statistics)" title="wikilink">population</a> where each unit 

<math display="inline" id="Statistical_benchmarking:0">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 has a "value" 

<math display="inline" id="Statistical_benchmarking:1">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(k)
  </annotation>
 </semantics>
</math>

 associated with it. For example, 

<math display="inline" id="Statistical_benchmarking:2">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(k)
  </annotation>
 </semantics>
</math>

 could be a wage of an employee 

<math display="inline" id="Statistical_benchmarking:3">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


, or the cost of an item 

<math display="inline" id="Statistical_benchmarking:4">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. Suppose we want to estimate the sum 

<math display="inline" id="Statistical_benchmarking:5">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 of all the 

<math display="inline" id="Statistical_benchmarking:6">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(k)
  </annotation>
 </semantics>
</math>

. So we take a <a href="sample_(statistics)" title="wikilink">sample</a> of the 

<math display="inline" id="Statistical_benchmarking:7">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, get a sampling weight W(k) for all sampled 

<math display="inline" id="Statistical_benchmarking:8">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


, and then sum up 

<math display="inline" id="Statistical_benchmarking:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⋅</mo>
    <mi>Y</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <ci>W</ci>
      <ci>k</ci>
     </apply>
     <ci>Y</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(k)\cdot Y(k)
  </annotation>
 </semantics>
</math>

 for all sampled 

<math display="inline" id="Statistical_benchmarking:10">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.</p>

<p>One property usually common to the weights 

<math display="inline" id="Statistical_benchmarking:11">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(k)
  </annotation>
 </semantics>
</math>

 described here is that if we <a href="summation" title="wikilink">sum</a> them over all sampled 

<math display="inline" id="Statistical_benchmarking:12">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, then this sum is an estimate of the total number of units 

<math display="inline" id="Statistical_benchmarking:13">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 in the population (for example, the total employment, or the total number of items). Because we have a sample, this estimate of the total number of units in the population will differ from the true population total. Similarly, the estimate of total 

<math display="inline" id="Statistical_benchmarking:14">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 (where we sum 

<math display="inline" id="Statistical_benchmarking:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⋅</mo>
    <mi>Y</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <ci>W</ci>
      <ci>k</ci>
     </apply>
     <ci>Y</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(k)\cdot Y(k)
  </annotation>
 </semantics>
</math>

 for all sampled 

<math display="inline" id="Statistical_benchmarking:16">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

) will also differ from true population total.</p>

<p>We do not know what the true population total 

<math display="inline" id="Statistical_benchmarking:17">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 value is (if we did, there would be no point in sampling!). Yet often we do know what the sum of the 

<math display="inline" id="Statistical_benchmarking:18">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(k)
  </annotation>
 </semantics>
</math>


 are over all units in the population. For example, we may not know the total earnings of the population or the total cost of the population, but often we know the total employment or total volume of sales. And even if we don't know these exactly, there often are surveys done by other organizations or at earlier times, with very accurate estimates of these auxiliary quantities. One important function of a population <a class="uri" href="census" title="wikilink">census</a> is to provide data that can be used for benchmarking smaller surveys.</p>

<p>The benchmarking procedure begins by first breaking the population into benchmarking cells. Cells are formed by grouping units together that share common characteristics, for example, similar 

<math display="inline" id="Statistical_benchmarking:19">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(k)
  </annotation>
 </semantics>
</math>

, yet anything can be used that enhances the accuracy of the final estimates. For each cell 

<math display="inline" id="Statistical_benchmarking:20">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, we let 

<math display="inline" id="Statistical_benchmarking:21">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(C)
  </annotation>
 </semantics>
</math>

 be the sum of all 

<math display="inline" id="Statistical_benchmarking:22">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(k)
  </annotation>
 </semantics>
</math>

, where the sum is taken over all sampled 

<math display="inline" id="Statistical_benchmarking:23">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 in the cell 

<math display="inline" id="Statistical_benchmarking:24">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. For each cell 

<math display="inline" id="Statistical_benchmarking:25">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, we let 

<math display="inline" id="Statistical_benchmarking:26">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(C)
  </annotation>
 </semantics>
</math>

 be the auxiliary value for cell 

<math display="inline" id="Statistical_benchmarking:27">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, which is commonly called the "benchmark target" for cell 

<math display="inline" id="Statistical_benchmarking:28">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>


. Next, we compute a benchmark factor 

<math display="inline" id="Statistical_benchmarking:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <mi>W</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>C</ci>
      </apply>
      <ci>W</ci>
     </apply>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(C)=T(C)/W(C)
  </annotation>
 </semantics>
</math>

. Then, we adjust all weights 

<math display="inline" id="Statistical_benchmarking:30">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(k)
  </annotation>
 </semantics>
</math>

 by multiplying it by its benchmark factor 

<math display="inline" id="Statistical_benchmarking:31">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(C)
  </annotation>
 </semantics>
</math>

, for its cell 

<math display="inline" id="Statistical_benchmarking:32">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. The net result is that the estimated 

<math display="inline" id="Statistical_benchmarking:33">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>


 [formed by summing 

<math display="inline" id="Statistical_benchmarking:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⋅</mo>
    <mi>W</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>C</ci>
     </apply>
     <ci>W</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(C)\cdot W(k)
  </annotation>
 </semantics>
</math>

] will now equal the benchmark target total 

<math display="inline" id="Statistical_benchmarking:35">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. But the more important benefit is that the estimate of the total of 

<math display="inline" id="Statistical_benchmarking:36">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 [formed by summing 

<math display="inline" id="Statistical_benchmarking:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <mi>F</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⋅</mo>
    <mi>Y</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>F</ci>
        <ci>C</ci>
       </apply>
       <ci>F</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <ci>Y</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(C)\cdot F(k)\cdot Y(k)
  </annotation>
 </semantics>
</math>

] will tend to be more accurate.</p>
<h2 id="relationship-to-stratified-sampling">Relationship to stratified sampling</h2>

<p>Benchmarking is sometimes referred to as 'post-stratification' because of its similarities to <a href="stratified_sampling" title="wikilink">stratified sampling</a>. The difference between the two is that in stratified sampling, we decide <em>in advance</em> how many units will be sampled from each stratum (equivalent to benchmarking cells); in benchmarking, we select units from the broader population, and the number chosen from each cell is a matter of chance.</p>

<p>The advantage of stratified sampling is that the sample numbers in each stratum can be controlled for desired accuracy outcomes. Without this control, we may end up with too much sample in one stratum and not enough in another - indeed, it's possible that a sample will contain <em>no</em> members from a certain cell, in which case benchmarking fails because 

<math display="inline" id="Statistical_benchmarking:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>W</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>W</ci>
     <ci>C</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(C)=0
  </annotation>
 </semantics>
</math>


, leading to a divide-by-zero problem. In such cases, it is necessary to 'collapse' cells together so that each remaining cell has an adequate sample size.</p>

<p>For this reason, benchmarking is generally used in situations where stratified sampling is impractical. For instance, when selecting people from a telephone directory, we can't tell what age they are so we can't easily stratify the sample by age. However, we can collect this information from the people sampled, allowing us to benchmark against demographic information.</p>

<p>"</p>

<p><a href="Category:Sampling_(statistics)" title="wikilink">Category:Sampling (statistics)</a></p>
</body>
</html>
