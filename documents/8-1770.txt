   Quasi-Newton method      Quasi-Newton method   Quasi-Newton methods are methods used to either find zeroes or local maxima and minima of functions, as an alternative to Newton's method. They can be used if the Jacobian or Hessian is unavailable or is too expensive to compute at every iteration. The "full" Newton's method requires the Jacobian in order to search for zeros, or the Hessian for finding extrema.  Description of the method  Search for zeroes  Newton's method to find zeroes of a function   g   g   g   of multiple variables is given by     x   n  +  1    =    x  n   -     [    J  g    (   x  n   )    ]    -  1    g   (   x  n   )          subscript  x    n  1       subscript  x  n      superscript   delimited-[]     subscript  J  g    subscript  x  n       1    g   subscript  x  n       x_{n+1}=x_{n}-[J_{g}(x_{n})]^{-1}g(x_{n})\,\!   where     [    J  g    (   x  n   )    ]    -  1      superscript   delimited-[]     subscript  J  g    subscript  x  n       1     [J_{g}(x_{n})]^{-1}   is the left inverse of the Jacobian matrix      J  g    (   x  n   )        subscript  J  g    subscript  x  n     J_{g}(x_{n})   of   g   g   g   evaluated for    x  n     subscript  x  n    x_{n}   .  Strictly, any method that replaces the exact Jacobian     J  g    (   x  n   )        subscript  J  g    subscript  x  n     J_{g}(x_{n})   with an approximation is a quasi-Newton method. The chord method (where     J  g    (   x  n   )        subscript  J  g    subscript  x  n     J_{g}(x_{n})   is replaced by     J  g    (   x  o   )        subscript  J  g    subscript  x  o     J_{g}(x_{o})   for all iterations) for instance is a simple example. The methods given below for optimisation are other examples. Using methods developed to find extrema in order to find zeroes is not always a good idea as the majority of the methods used to find extrema require that the matrix that is used is symmetrical. While this holds in the context of the search for extrema, it rarely holds when searching for zeroes. Broyden's "good" method and Broyden's "bad" method are two methods commonly used to find extrema that can also be applied to find zeroes. Other methods that can be used are the Column Updating Method , the Inverse Column Updating Method , the Quasi-Newton Least Squares Method and the Quasi-Newton Inverse Least Squares Method .  More recently quasi-Newton methods have been applied to find the solution of multiple coupled systems of equations (e.g. fluid-structure interaction problems or interaction problems in physics). They allow the solution to be found by solving each constituent system separately (which is simpler than the global system) in a cyclic, iterative fashion until the solution of the global system is found. 1 2  Search for extrema  Noting that the search for a minimum or maximum of a single-valued function is nothing else than the search for the zeroes of the gradient of that function, quasi-Newton methods can be readily applied to find extrema of a function. In other words, if   g   g   g   is the gradient of   f   f   f   then searching for the zeroes of the multi-valued function   g   g   g   corresponds to the search for the extrema of the single-valued function   f   f   f   ; the Jacobian of   g   g   g   now becomes the Hessian of   f   f   f   . The main difference is that the Hessian matrix now is a symmetrical matrix, unlike the Jacobian when searching for zeroes . Most quasi-Newton methods used in optimisation exploit this property.  In optimization , quasi-Newton methods (a special case of variable metric methods ) are algorithms for finding local maxima and minima of functions . Quasi-Newton methods are based on Newton's method to find the stationary point of a function, where the gradient is 0. Newton's method assumes that the function can be locally approximated as a quadratic in the region around the optimum, and uses the first and second derivatives to find the stationary point. In higher dimensions, Newton's method uses the gradient and the Hessian matrix of second derivatives of the function to be minimized.  In quasi-Newton methods the Hessian matrix does not need to be computed. The Hessian is updated by analyzing successive gradient vectors instead. Quasi-Newton methods are a generalization of the secant method to find the root of the first derivative for multidimensional problems. In multiple dimensions the secant equation is under-determined, and quasi-Newton methods differ in how they constrain the solution, typically by adding a simple low-rank update to the current estimate of the Hessian.  The first quasi-Newton algorithm was proposed by William C. Davidon , a physicist working at Argonne National Laboratory . He developed the first quasi-Newton algorithm in 1959: the DFP updating formula , which was later popularized by Fletcher and Powell in 1963, but is rarely used today. The most common quasi-Newton algorithms are currently the SR1 formula (for symmetric rank one), the BHHH method, the widespread BFGS method (suggested independently by Broyden, Fletcher, Goldfarb, and Shanno, in 1970), and its low-memory extension, L-BFGS . The Broyden's class is a linear combination of the DFP and BFGS methods.  The SR1 formula does not guarantee the update matrix to maintain positive-definiteness and can be used for indefinite problems. The Broyden's method does not require the update matrix to be symmetric and it is used to find the root of a general system of equations (rather than the gradient) by updating the Jacobian (rather than the Hessian).  One of the chief advantages of quasi-Newton methods over Newton's method is that the Hessian matrix (or, in the case of quasi-Newton methods, its approximation)   B   B   B   does not need to be inverted. Newton's method, and its derivatives such as interior point methods , require the Hessian to be inverted, which is typically implemented by solving a system of linear equations and is often quite costly. In contrast, quasi-Newton methods usually generate an estimate of    B   -  1      superscript  B    1     B^{-1}   directly.  As in Newton's method , one uses a second order approximation to find the minimum of a function    f   (  x  )       f  x    f(x)   . The Taylor series of    f   (  x  )       f  x    f(x)   around an iterate is:          f   (    x  k   +   Δ  x    )    ≈    f   (   x  k   )    +    ∇  f     (   x  k   )   T   Δ  x   +    1  2   Δ   x  T    B   Δ  x     ,        f     subscript  x  k     normal-Δ  x         f   subscript  x  k       normal-∇  f    superscript   subscript  x  k   T   normal-Δ  x       1  2   normal-Δ   superscript  x  T   B  normal-Δ  x      f(x_{k}+\Delta x)\approx f(x_{k})+\nabla f(x_{k})^{T}\Delta x+\frac{1}{2}%
 \Delta x^{T}{B}\,\Delta x,        where (    ∇  f     normal-∇  f    \nabla f   ) is the gradient and   B   B   B   an approximation to the Hessian matrix . The gradient of this approximation (with respect to    Δ  x      normal-Δ  x    \Delta x   ) is          ∇  f    (    x  k   +   Δ  x    )    ≈     ∇  f    (   x  k   )    +    B   Δ  x           normal-∇  f      subscript  x  k     normal-Δ  x          normal-∇  f    subscript  x  k      B  normal-Δ  x      \nabla f(x_{k}+\Delta x)\approx\nabla f(x_{k})+B\,\Delta x        and setting this gradient to zero (which is the objective of optimisation) provides the Newton step:          Δ  x   =   -    B   -  1     ∇  f    (   x  k   )      ,        normal-Δ  x        superscript  B    1     normal-∇  f    subscript  x  k       \Delta x=-B^{-1}\nabla f(x_{k}),\,        The Hessian approximation   B   B   B   is chosen to satisfy           ∇  f    (    x  k   +   Δ  x    )    =     ∇  f    (   x  k   )    +    B   Δ  x     ,         normal-∇  f      subscript  x  k     normal-Δ  x          normal-∇  f    subscript  x  k      B  normal-Δ  x      \nabla f(x_{k}+\Delta x)=\nabla f(x_{k})+B\,\Delta x,        which is called the secant equation (the Taylor series of the gradient itself). In more than one dimension   B   B   B   is underdetermined . In one dimension, solving for   B   B   B   and applying the Newton's step with the updated value is equivalent to the secant method . The various quasi-Newton methods differ in their choice of the solution to the secant equation (in one dimension, all the variants are equivalent). Most methods (but with exceptions, such as Broyden's method ) seek a symmetric solution (     B  T   =  B       superscript  B  T   B    B^{T}=B   ); furthermore, the variants listed below can be motivated by finding an update    B   k  +  1      subscript  B    k  1     B_{k+1}   that is as close as possible to    B  k     subscript  B  k    B_{k}   in some norm ; that is,     B   k  +  1    =    argmin  B     ∥   B  -   B  k    ∥   V         subscript  B    k  1       subscript  argmin  B    subscript   norm    B   subscript  B  k     V      B_{k+1}=\textrm{argmin}_{B}\|B-B_{k}\|_{V}   where   V   V   V   is some positive definite matrix that defines the norm. An approximate initial value of     B  0   =   I  *  x        subscript  B  0     I  x     B_{0}=I*x   is often sufficient to achieve rapid convergence. Note that    B  0     subscript  B  0    B_{0}   should be positive definite. The unknown    x  k     subscript  x  k    x_{k}   is updated applying the Newton's step calculated using the current approximate Hessian matrix    B  k     subscript  B  k    B_{k}           Δ   x  k    =   -    α  k    B  k   -  1     ∇  f    (   x  k   )           normal-Δ   subscript  x  k         subscript  α  k    superscript   subscript  B  k     1     normal-∇  f    subscript  x  k       \Delta x_{k}=-\alpha_{k}B_{k}^{-1}\nabla f(x_{k})   , with   α   α   \alpha   chosen to satisfy the Wolfe conditions ;       x   k  +  1    =    x  k   +   Δ   x  k          subscript  x    k  1       subscript  x  k     normal-Δ   subscript  x  k       x_{k+1}=x_{k}+\Delta x_{k}   ;  The gradient computed at the new point     ∇  f    (   x   k  +  1    )        normal-∇  f    subscript  x    k  1      \nabla f(x_{k+1})   , and         y  k   =     ∇  f    (   x   k  +  1    )    -    ∇  f    (   x  k   )      ,       subscript  y  k        normal-∇  f    subscript  x    k  1        normal-∇  f    subscript  x  k       y_{k}=\nabla f(x_{k+1})-\nabla f(x_{k}),   is used to update the approximate Hessian    B   k  +  1      subscript  B    k  1     \displaystyle B_{k+1}   , or directly its inverse     H   k  +  1    =   B   k  +  1    -  1         subscript  H    k  1     superscript   subscript  B    k  1      1      \displaystyle H_{k+1}=B_{k+1}^{-1}   using the Sherman-Morrison formula .   A key property of the BFGS and DFP updates is that if    B  k     subscript  B  k    B_{k}   is positive definite and    α  k     subscript  α  k    \alpha_{k}   is chosen to satisfy the Wolfe conditions then    B   k  +  1      subscript  B    k  1     \displaystyle B_{k+1}   is also positive definite.   The most popular update formulas are:      Method        B   k  +  1    =        subscript  B    k  1    absent    \displaystyle B_{k+1}=           H   k  +  1    =   B   k  +  1    -  1    =          subscript  H    k  1     superscript   subscript  B    k  1      1         absent     H_{k+1}=B_{k+1}^{-1}=          DFP         (   I  -      y  k    Δ   x  k  T       y  k  T    Δ   x  k      )    B  k    (   I  -    Δ   x  k    y  k  T       y  k  T    Δ   x  k      )    +     y  k    y  k  T       y  k  T    Δ   x  k             I       subscript  y  k   normal-Δ   superscript   subscript  x  k   T       superscript   subscript  y  k   T   normal-Δ   subscript  x  k       subscript  B  k     I      normal-Δ   subscript  x  k    superscript   subscript  y  k   T       superscript   subscript  y  k   T   normal-Δ   subscript  x  k            subscript  y  k    superscript   subscript  y  k   T       superscript   subscript  y  k   T   normal-Δ   subscript  x  k       \left(I-\frac{y_{k}\,\Delta x_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}\right)B_{k}%
 \left(I-\frac{\Delta x_{k}y_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}\right)+\frac{y_{%
 k}y_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}            H  k   +    Δ   x  k   Δ   x  k  T       y  k  T    Δ   x  k      -     H  k    y  k    y  k  T    H  k  T      y  k  T    H  k    y  k            subscript  H  k       normal-Δ   subscript  x  k   normal-Δ   superscript   subscript  x  k   T       superscript   subscript  y  k   T   normal-Δ   subscript  x  k           subscript  H  k    subscript  y  k    superscript   subscript  y  k   T    superscript   subscript  H  k   T       superscript   subscript  y  k   T    subscript  H  k    subscript  y  k       H_{k}+\frac{\Delta x_{k}\Delta x_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}-\frac{H_{k}%
 y_{k}y_{k}^{T}H_{k}^{T}}{y_{k}^{T}H_{k}y_{k}}        BFGS         B  k   +     y  k    y  k  T      y  k  T   Δ   x  k      -     B  k   Δ   x  k     (    B  k   Δ   x  k    )   T     Δ   x  k  T     B  k    Δ   x  k            subscript  B  k        subscript  y  k    superscript   subscript  y  k   T       superscript   subscript  y  k   T   normal-Δ   subscript  x  k           subscript  B  k   normal-Δ   subscript  x  k    superscript     subscript  B  k   normal-Δ   subscript  x  k    T      normal-Δ   superscript   subscript  x  k   T    subscript  B  k   normal-Δ   subscript  x  k       B_{k}+\frac{y_{k}y_{k}^{T}}{y_{k}^{T}\Delta x_{k}}-\frac{B_{k}\Delta x_{k}(B_{%
 k}\Delta x_{k})^{T}}{\Delta x_{k}^{T}B_{k}\,\Delta x_{k}}             (   I  -    Δ   x  k    y  k  T      y  k  T   Δ   x  k      )   T    H  k    (   I  -     y  k   Δ   x  k  T      y  k  T   Δ   x  k      )    +    Δ   x  k   Δ   x  k  T       y  k  T    Δ   x  k            superscript    I      normal-Δ   subscript  x  k    superscript   subscript  y  k   T       superscript   subscript  y  k   T   normal-Δ   subscript  x  k      T    subscript  H  k     I       subscript  y  k   normal-Δ   superscript   subscript  x  k   T       superscript   subscript  y  k   T   normal-Δ   subscript  x  k           normal-Δ   subscript  x  k   normal-Δ   superscript   subscript  x  k   T       superscript   subscript  y  k   T   normal-Δ   subscript  x  k       \left(I-\frac{\Delta x_{k}y_{k}^{T}}{y_{k}^{T}\Delta x_{k}}\right)^{T}H_{k}%
 \left(I-\frac{y_{k}\Delta x_{k}^{T}}{y_{k}^{T}\Delta x_{k}}\right)+\frac{%
 \Delta x_{k}\Delta x_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}        Broyden        B  k   +       y  k   -    B  k   Δ   x  k      Δ    x  k  T    Δ   x  k      Δ   x  k  T         subscript  B  k          subscript  y  k      subscript  B  k   normal-Δ   subscript  x  k       normal-Δ   superscript   subscript  x  k   T   normal-Δ   subscript  x  k     normal-Δ   superscript   subscript  x  k   T      B_{k}+\frac{y_{k}-B_{k}\Delta x_{k}}{\Delta x_{k}^{T}\,\Delta x_{k}}\,\Delta x%
 _{k}^{T}           H  k   +     (    Δ   x  k    -    H  k    y  k     )   Δ   x  k  T    H  k     Δ   x  k  T     H  k     y  k          subscript  H  k           normal-Δ   subscript  x  k       subscript  H  k    subscript  y  k     normal-Δ   superscript   subscript  x  k   T    subscript  H  k      normal-Δ   superscript   subscript  x  k   T    subscript  H  k    subscript  y  k       H_{k}+\frac{(\Delta x_{k}-H_{k}y_{k})\Delta x_{k}^{T}H_{k}}{\Delta x_{k}^{T}H_%
 {k}\,y_{k}}        Broyden family           (   1  -   φ  k    )    B   k  +  1    B  F  G  S     +    φ  k    B   k  +  1    D  F  P      ,  φ   ∈   [  0  ,  1  ]              1   subscript  φ  k     superscript   subscript  B    k  1      B  F  G  S        subscript  φ  k    superscript   subscript  B    k  1      D  F  P      φ    0  1     (1-\varphi_{k})B_{k+1}^{BFGS}+\varphi_{k}B_{k+1}^{DFP},\qquad\varphi\in[0,1]         SR1        B  k   +     (    y  k   -     B  k    Δ   x  k     )     (    y  k   -     B  k    Δ   x  k     )   T        (    y  k   -     B  k    Δ   x  k     )   T    Δ   x  k          subscript  B  k          subscript  y  k      subscript  B  k   normal-Δ   subscript  x  k      superscript     subscript  y  k      subscript  B  k   normal-Δ   subscript  x  k     T       superscript     subscript  y  k      subscript  B  k   normal-Δ   subscript  x  k     T   normal-Δ   subscript  x  k       B_{k}+\frac{(y_{k}-B_{k}\,\Delta x_{k})(y_{k}-B_{k}\,\Delta x_{k})^{T}}{(y_{k}%
 -B_{k}\,\Delta x_{k})^{T}\,\Delta x_{k}}           H  k   +     (    Δ   x  k    -    H  k    y  k     )     (    Δ   x  k    -    H  k    y  k     )   T       (    Δ   x  k    -    H  k    y  k     )   T    y  k          subscript  H  k           normal-Δ   subscript  x  k       subscript  H  k    subscript  y  k      superscript      normal-Δ   subscript  x  k       subscript  H  k    subscript  y  k     T       superscript      normal-Δ   subscript  x  k       subscript  H  k    subscript  y  k     T    subscript  y  k       H_{k}+\frac{(\Delta x_{k}-H_{k}y_{k})(\Delta x_{k}-H_{k}y_{k})^{T}}{(\Delta x_%
 {k}-H_{k}y_{k})^{T}y_{k}}        Other methods are Pearson's method, McCormick's Method, the Powell symmetric Broyden (PSB) method and Greenstadt's method. 3  Implementations  Owing to their success, there are implementations of quasi-Newton methods in almost all programming languages. The NAG Library contains several routines 4 for minimizing or maximizing a function 5 which use quasi-Newton algorithms.  Scipy .optimize has fmin_bfgs.  GNU Octave uses a form of BFGS in its 'fsolve' function, with trust region extensions.  In MATLAB's Optimization Toolbox , the [http://www.mathworks.com/help/toolbox/optim/ug/fminunc.html fminunc] function uses (among other methods) the BFGS Quasi-Newton method. Many of the constrained methods of the Optimization toolbox use BFGS and the variant L-BFGS . Many user-contributed quasi-Newton routines are available on MATLAB's file exchange .  Mathematica includes quasi-Newton solvers . R 's optim general-purpose optimizer routine uses the BFGS method by using method="BFGS" 1 . In the SciPy extension to Python , the scipy.optimize.minimize function includes, among other methods, a BFGS implementation.  See also   Newton's method in optimization  Newton's method  DFP updating formula  BFGS method   :* L-BFGS  :* OWL-QN   SR1 formula  Broyden's Method  Quasi-Newton Least Squares Method   References  Further reading   Bonnans, J. F., Gilbert, J.Ch., Lemaréchal, C. and Sagastizábal, C.A. (2006), Numerical optimization, theoretical and numerical aspects. Second edition. Springer. ISBN 978-3-540-35445-1.  William C. Davidon, VARIABLE METRIC METHOD FOR MINIMIZATION , SIOPT Volume 1 Issue 1, Pages 1–17, 1991.   .  Nocedal, Jorge & Wright, Stephen J. (1999). Numerical Optimization. Springer-Verlag. ISBN 0-387-98793-2.    "  Category:Optimization algorithms and methods     ↩  ↩   ↩  ↩     