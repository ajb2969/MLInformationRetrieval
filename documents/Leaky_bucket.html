<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1524">Leaky bucket</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Leaky bucket</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Figure 1: The leaky bucket analogy</figcaption>
</figure>

<p>The <strong>leaky bucket</strong> is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> used in <a href="packet-switching" title="wikilink">packet switched</a> <a href="computer_network" title="wikilink">computer networks</a> and <a href="telecommunication" title="wikilink"> telecommunications networks</a>. It can be used to check that <a href="data_transmission" title="wikilink">data transmissions</a>, in the form of <a href="Network_packet" title="wikilink">packets</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> conform to defined limits on <a href="Bandwidth_(computing)" title="wikilink">bandwidth</a> and <a href="burst_transmission" title="wikilink">burstiness</a> (a measure of the unevenness or variations in the <a href="Network_traffic_measurement" title="wikilink">traffic</a> flow). It can also be used as a <a href="scheduling_algorithm" title="wikilink">scheduling algorithm</a> to determine the timing of transmissions that will comply with the limits set for the bandwidth and burstiness: see <a href="network_scheduler" title="wikilink">network scheduler</a>. The leaky bucket algorithm is also used in leaky bucket counters, e.g. to detect when the average or peak rate of <a class="uri" href="random" title="wikilink">random</a> or <a class="uri" href="stochastic" title="wikilink">stochastic</a> events or <a href="stochastic_processes" title="wikilink">stochastic processes</a> exceed defined limits.</p>

<p>A version of the leaky bucket, the <a href="Generic_Cell_Rate_Algorithm" title="wikilink">Generic Cell Rate Algorithm</a>, is recommended for <a href="Asynchronous_Transfer_Mode" title="wikilink">Asynchronous Transfer Mode</a> (ATM) networks<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> in <a href="UPC_and_NPC" title="wikilink">Usage/Network Parameter Control</a> at <a href="User–network_interface" title="wikilink">User–Network Interfaces</a> or <a href="Network-to-network_interface" title="wikilink">Inter-Network Interfaces or Network-Network Interfaces</a> to <a href="Traffic_policing_(communications)" title="wikilink">protect</a> a network from excessive traffic levels on connections routed through it. The Generic Cell Rate Algorithm, or an equivalent, may also be used to <a href="traffic_shaping" title="wikilink">shape</a> transmissions by a <a href="Network_Interface_Card" title="wikilink">Network Interface Card</a> onto an ATM network (i.e. on the user side of the User-Network Interface), e.g. to levels below the levels set for Usage/Network Parameter Control in the network to prevent it taking action to further limit that connection.</p>
<h2 id="overview">Overview</h2>

<p>The Leaky Bucket Algorithm is based on, and gets it name from, an <a class="uri" href="analogy" title="wikilink">analogy</a> of a <a class="uri" href="bucket" title="wikilink">bucket</a> (figure 1) that has a hole in the bottom through which any water it contains will leak away at a constant rate, until or unless it is empty. Water can be added intermittently, i.e. in bursts, but if too much is added at once, or it is added at too high an average rate, the water will exceed the <a href="Volume" title="wikilink">capacity</a> of the bucket, which will overflow. Hence, this leaky bucket determines whether adding some amount of water would exceed or conform to a limit on the average rate at which water can be added, set by the leak rate, and a limit on how much water can be added in a burst, set by the depth of the bucket.</p>

<p>Two different methods of applying this leaky bucket analogy are described in the literature.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> These give what appear to be two different algorithms, both of which are referred to as the leaky bucket algorithm and generally without reference to the other method. This has resulted in confusion about what the leaky bucket algorithm is and what its properties are.</p>

<p>In one version of applying the analogy, the analogue of the bucket is a counter or variable, separate from the flow of traffic or scheduling of events.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> This counter is used only to check that the traffic or events conform to the limits: The counter is incremented as each packet arrives at the point where the check is being made or an event occurs, which is equivalent to the way water is added intermittently to the bucket. The counter is also decremented at a fixed rate, equivalent to the way the water leaks out of the bucket. As a result, the value in the counter when a packet arrives indicates its conformance to the bandwidth and burstiness limits or when an event occurs, its conformance to the average and peak rate limits. So in this version, the analogue of the water is carried by the packets or the events, added to the bucket on their arriving or occurring, and then leaks away. This version is referred to here as the leaky bucket as a meter.</p>

<p>In the second version, the analogue of the bucket is a queue in the flow of traffic.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> This queue is used to directly control that flow: Packets are entered into the queue as they arrive, equivalent to the water being added to the bucket. These packet are then removed from the queue (<a href="FIFO_(computing_and_electronics)" title="wikilink">first come, first served</a>), usually at a fixed rate, e.g. for onward transmission, equivalent to water leaking from the bucket. As a result, the rate at which the queue is serviced directly controls the onward transmission rate of the traffic. Thus it imposes conformance rather than checking it, and where the queue is serviced at a fixed rate (and where the packets are all the same length), the resulting traffic stream is necessarily devoid of burstiness or jitter. So in this version, the traffic itself is the analogue of the water passing through the bucket. It is not clear how this version of applying the analogy might be used to the check the rates of discrete events. This version is referred to here as the leaky bucket as a queue.</p>

<p>The leaky bucket as a meter is exactly equivalent to (a mirror image of) the <a href="token_bucket" title="wikilink">token bucket</a> algorithm, i.e. the process of adding water to the leaky bucket exactly mirrors that of removing tokens from the token bucket when a conforming packet arrives, the process of leaking of water from the leaky bucket exactly mirrors that of regularly adding tokens to the token bucket, and the test that the leaky bucket will not overflow is a mirror of the test that the token bucket contains enough tokens and will not 'underflow'. Thus, given equivalent parameters, the two algorithms will see the same traffic as conforming or nonconforming. The leaky bucket as a queue can be seen as a special case of the leaky bucket as a meter.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="the-leaky-bucket-algorithm-as-a-meter">The Leaky Bucket Algorithm as a Meter</h2>

<p><a href="Jonathan_S._Turner" title="wikilink">Jonathan S. Turner</a> is credited<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> with the original description of the leaky bucket algorithm and describes it as follows: “A counter associated with each user transmitting on a connection is incremented whenever the user sends a packet and is decremented periodically. If the counter exceeds a threshold upon being incremented, the network discards the packet. The user specifies the rate at which the counter is decremented (this determines the average bandwidth) and the value of the threshold (a measure of burstiness)”.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The bucket (analogous to the counter) is in this case used as a meter to test the conformance of packets, rather than as a queue to directly control them.</p>

<p>Another version of what is essentially the same meter version of the algorithm, the <a href="Generic_Cell_Rate_Algorithm" title="wikilink">Generic Cell Rate Algorithm</a>, is described by the <a class="uri" href="ITU-T" title="wikilink">ITU-T</a> in recommendation I.371 and in the <a href="ATM_Forum" title="wikilink">ATM Forum</a>’s UNI Specification.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> The description, in which the term <em>cell</em> is equivalent to <em>packet</em> in Turner's description<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> is given by the ITU-T as follows: “The continuous-state leaky bucket can be viewed as a finite capacity bucket whose real-valued content drains out at a continuous rate of 1 unit of content per time unit and whose content is increased by the increment <em>T</em> for each conforming cell... If at a cell arrival the content of the bucket is less than or equal to the limit value <em>τ</em>, then the cell is conforming; otherwise, the cell is non-conforming. The capacity of the bucket (the upper bound of the counter) is (<em>T</em> + <em>τ</em>).”.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> These specifications also state that, due to its finite capacity, if the contents of the bucket at the time the conformance is tested is greater than the limit value, and hence the cell is non-conforming, then the bucket is left unchanged; that is, the water is simply not added if it would make the bucket overflow. </p>

<p>David E. McDysan and Darrel L. Spohn provide a commentary on the description given by the ITU-T/ATM Forum. In this they state “In the leaky bucket analogy, the [ATM] cells do not actually flow through the bucket; only the check for conforming admission does”.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> However, uncommonly in the descriptions in the literature, McDysan and Spohn also refer to the leaky bucket algorithm as a queue, going on “Note that one implementation of traffic shaping is to actually have the cells flow through the bucket”.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>In describing the operation of the ITU-T's version of the algorithm, McDysan and Spohn invoke a “notion commonly employed in <a href="queueing_theory" title="wikilink">queueing theory</a> of a fictional ‘gremlin’”.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> This gremlin inspects the level in the bucket and takes action if the level is above the limit value <em>τ</em> : in policing (figure 2), it pulls open a trap door, which causes the arriving packet to be dropped and stops its water from entering the bucket; in shaping (figure 3), it pushes up a flap, which delays the arriving packet and prevents it from delivering its water, until the water level in the bucket falls below <em>τ</em>.</p>

<p>The difference between the descriptions given by Turner and the ITU-T/ATM Forum is that Turner's is specific to <a href="Traffic_policing_(communications)" title="wikilink">traffic policing</a>, whereas the ITU-T/ATM Forum's is applicable to both traffic policing and traffic shaping. Also, Turner does not state that the contents of the counter should only be affected by conforming packets, and should only be incremented when this would not cause it to exceed a limit, i.e. Turner does not explicitly state that the bucket’s capacity or counter's maximum value is finite. To make Turner’s description clearly aligned with ITU-T, the statement “If the counter exceeds a threshold upon being incremented, the network discards the packet” would have to be changed to something like “If the counter would exceed a threshold [equivalent to the bucket depth, T + <em>τ</em>, in the ITU-T description] upon being incremented, the network discards the packet and the counter is not incremented", i.e. it is only incremented when it is less than or equal to the limit value, <em>τ</em>, or at least T less than the bucket depth in the ITU-T description.</p>
<figure><b>(Figure)</b>
<figcaption><code>Figure</code> <code>3:</code> <code>Traffic</code> <code>shaping</code> <code>with</code> <code>a</code> <code>leaky</code> <code>bucket</code> <code>as</code> <code>a</code> <code>meter</code></figcaption>
</figure>

<p>In fairness, the description given by Turner is in terms of a traffic policing function, where overzealousness in limiting a connection containing nonconforming packets may not be an issue. Indeed, in some contexts, such as <a href="Variable_bitrate" title="wikilink">Variable bitrate</a> (VBR) transmissions, the loss of any one packet may corrupt the entirety of a higher layer message, e.g. an OSI Network Layer PDU. In which case, discarding all the following packets of that corrupted PDU sheds an unnecessary network load. However, it would be entirely unacceptable in traffic shaping for a packet that fails the conformance test to affect how long before conformance can next occur, i.e. if the act of testing a subsequent packet for conformance would change how long a packet currently waiting to conform has to wait. This is exactly what would happen were the bucket not finite, as any subsequent nonconforming packets would raise the water level, and thus make a packet waiting to conform wait longer.</p>

<p>Neither Turner nor the ITU-T addresses the issue of variable length packets. To be fair again, the description according to the ITU-T is for ATM cells, which are fixed length packets, and Turner does not specifically exclude variable length packets. In both cases, if the amount by which the bucket content or counter is incremented for a conforming packet is proportional to the packet length, they will both account for the length and allow the algorithm to limit the bandwidth of the traffic explicitly rather than limiting the packet rate. For example, shorter packets would add less to the bucket, and could thus arrive at smaller intervals; whereas, longer packets would add more and thus have to be separated by proportionally larger intervals to conform.</p>
<h3 id="concept-of-operation">Concept of Operation</h3>

<p>A description of the concept of operation of the Leaky Bucket Algorithm as a meter that can be used in either traffic policing or traffic shaping, may be stated as follows:</p>

<p>:*A fixed capacity bucket, associated with each virtual connection or user, leaks at a fixed rate.</p>

<p>:* If the bucket is empty, it stops leaking.</p>

<p>:*For a packet to conform, it has to be possible to add a specific amount of water to the bucket: The specific amount added by a conforming packet can be the same for all packets, or can be proportional to the length of the packet.</p>

<p>:*If this amount of water would cause the bucket to exceed its capacity then the packet does not conform and the water in the bucket is left unchanged.</p>
<h3 id="uses">Uses</h3>

<p>The leaky bucket as a meter can be used in either <a href="traffic_shaping" title="wikilink">traffic shaping</a> or <a href="traffic_policing_(communications)" title="wikilink">traffic policing</a>. For example, in ATM networks, in the form of the Generic Cell Rate Algorithm, it is used to compare the bandwidth and burstiness of traffic on a Virtual Channel (VC) or Virtual Path (VP) against the specified limits on the rate at which cells may arrive and the maximum jitter, or variation in inter-arrival intervals, for the VC or VP. In traffic policing, cells that do not conform to these limits (nonconforming cells) may be discarded (dropped) or may be reduced in priority (for downstream traffic management functions to drop if there is congestion). In traffic shaping, cells are delayed until they conform. Traffic policing and traffic shaping are commonly used in UPC/NPC to protect the network against excess or excessively bursty traffic, see <a href="bandwidth_management" title="wikilink">bandwidth management</a> and <a href="congestion_avoidance" title="wikilink">congestion avoidance</a>. Traffic shaping is commonly used in the network interfaces in hosts to prevent transmissions being discarded by traffic management functions in the network, see <a href="Scheduling_(computing)" title="wikilink">network scheduling</a> and <a href="network_scheduler" title="wikilink">network scheduler</a>.</p>

<p>The leaky bucket algorithm as a meter can also be used in a leaky bucket counter to measure the rate of random or <a href="stochastic_processes" title="wikilink">stochastic processes</a>. A Leaky bucket counter can be used to detect when the average or peak rate of events increases above some, acceptable, background level, i.e. when the bucket overflows.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> However, events that do not cause an overflow, i.e. have sufficiently low rates and are well distributed over time, can be ignored. For example, such a leaky bucket counter can be used to detect when there is a sudden burst of correctable memory errors or when there has been a gradual, but significant, increase in the average rate, which may indicate an impending failure,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> etc.</p>

<p>The use of the leaky bucket algorithm in a leaky bucket counter is similar to that in traffic management, in that it is used as a meter. Essentially, the events replace the packets in the description, with each event causing a quantity of water to be added to the bucket. If the bucket would overflow, as a result of the event, then the event should trigger the action associated with an out of limits event. Some implementations<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> seem to parallel Turner's description,<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> in that there is no explicit limit on the maximum value that the counter may take, implying that once the counter has exceeded the threshold, it may not return to its previous state until a period significantly greater than the equivalent of the emission interval has passed, which may be increased by what would otherwise be conforming events. Other implementations may, however, not increment the counter while it is overflowed, allowing it to correctly determine whether following events conform or not.</p>
<h3 id="parameters">Parameters</h3>

<p>In the case of the leaky bucket algorithm as a meter, the limits on the traffic can be a bandwidth and a burstiness of the output.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>The bandwidth limit and burstiness limit for the connection may be specified in a <a href="traffic_contract" title="wikilink">traffic contract</a>. A bandwidth limit may be specified as a packet or frame rate, a byte or <a href="bit_rate" title="wikilink">bit rate</a>, or as an <a href="#Emission_Interval" title="wikilink">emission interval</a> between the packets. A limit on burstiness may be specified as a <a class="uri" href="jitter" title="wikilink">jitter</a> or <a href="#Delay_Variation_Tolerance" title="wikilink">delay variation</a> tolerance, or as a <a href="#Maximum_Burst_Size" title="wikilink">maximum burst size</a> (MBS).</p>

<p>Multiple sets of contract parameters can be applied concurrently to a connection using multiple instances of the leaky bucket algorithm, each of which may take a bandwidth and a burstiness limit: see <a href="GCRA#Dual_Leaky_Bucket_Controller" title="wikilink">Dual Leaky Bucket Controller</a>.</p>
<h4 id="emission-interval">Emission Interval</h4>

<p>The rate at which the bucket leaks will determine the bandwidth limit, which is referred to as the average rate by Turner<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> and the inverse of which is referred to as the emission interval by the ITU-T. It is easiest to explain what this interval is where packets have a fixed length. Hence, the first part of this description assumes this, and the implications of variable packet lengths are considered separately.</p>

<p>Consider a bucket that is exactly filled to the top by preceding traffic, i.e. when the maximum permitted burstiness has already occurred, i.e. the maximum number of packets or cells have just arrived in the minimum amount of time for them to still conform to the bandwidth and jitter limits. The minimum interval before the next packet can conform is then the time it takes for the bucket to leak exactly the amount of water delivered by a packet, and if a packet is tested and conforms at that time, this will exactly fill the bucket once more. Thus, once the bucket is filled, the maximum rate that packets can conform is with this interval between each packet.</p>

<p>Turner<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> refers to this rate as the average, implying that its inverse is the average interval. There is, however, some ambiguity in what the average rate and interval are. Since, packets can arrive at any lower rate, this is an upper bound, rather than a fixed value, so it could at best be called the maximum for the average rate. Also, during the time the maximum burstiness occurs, packets can arrive with smaller intervals and thus a higher rate than this. So, for any period less than infinity, the actual average rate can be (but isn’t necessarily) greater than this and the average interval can be (but isn’t necessarily) less than the emission interval. Hence, because of this ambiguity, the term emission interval is used hereafter. However, it is still true that the minimum value that the long term average interval can take tends to be the emission interval.</p>

<p>For variable length packets, where the amount added to the bucket is proportional to the packet length, the maximum rate at which they can conform varies according to their length: the amount that the bucket must have leaked from full for a packet to conform is the amount the packet will add, and if this is proportional to the packet length, so is the interval between it and the preceding packet that filled the bucket. Hence, it is not possible to specify a specific emission interval for variable length packets, and the bandwidth limit has to be specified explicitly, in bits or bytes per second.</p>
<h4 id="delay-variation-tolerance">Delay Variation Tolerance</h4>

<p>It is easiest to explain what this tolerance is where packets have a fixed length. Hence, the first part of this description assumes this, and the implications of variable packet lengths are considered separately.</p>

<p>The ITU-T define a limit value, <em>τ</em>, that is less than the capacity of the bucket by <em>T</em> (the amount by which the bucket contents is incremented for each conforming cell), so that the capacity of the bucket is <em>T</em> + <em>τ</em>. This limit value specifies how much earlier a packet can arrive than it would normally be expected if the packets were arriving with exactly the emission interval between them.</p>

<p>Imagine the following situation: A bucket leaks at 1 unit of water per second, so the limit value, <em>τ</em> and the amount of water added by a packet, <em>T</em>, are effectively in units of seconds. This bucket starts off empty, so when a packet arrives at the bucket, it does not quite fill the bucket by adding its water <em>T</em>, and the bucket is now <em>τ</em> below its capacity. So when the next packet arrives the bucket only has to have drained by <em>T</em> – <em>τ</em> for this to conform. So the interval between these two packets can be as much as <em>τ</em> less than <em>T</em>.</p>

<p>This extends to multiple packets in a sequence: Imagine the following: The bucket again starts off empty, so the first packet to arrive must conform. The bucket then becomes exactly full after a number of conforming packets, <em>N</em>, have arrived in the minimum possible time for them to conform. For the last (the <em>N</em>th) packet to conform, the bucket must have leaked enough of the water from the preceding <em>N</em> – 1 packets ((<em>N</em> – 1) * <em>T</em> seconds worth) for it to be exactly at the limit value <em>τ</em> at this time. Hence, the water leaked is (<em>N</em>– 1)<em>T</em> – <em>τ</em>, which because the leak is one unit per second, took exactly (<em>N</em>– 1)<em>T</em> – <em>τ</em> seconds to leak. Thus the shortest time in which all <em>N</em> packets can arrive and conform is (<em>N</em>– 1)<em>T</em> – <em>τ</em> seconds, which is exactly <em>τ</em> less than the time it would have taken if the packets had been arriving at exactly the emission interval.</p>

<p>However, packets can only arrive with intervals less than <em>T</em> where the bucket is not filled by the previous packet. If it is, then the bucket must have drained by the full amount <em>T</em> before the next packet conforms. So once this tolerance has been used up by packets arriving at less than <em>T</em>, subsequent frames must arrive at intervals no less than <em>T</em>. They may, however, arrive at greater intervals, when the bucket will not be filled by them. When this has happened, packets may, again, arrive with intervals less than <em>T</em> until the tolerance is again used up. However, since the bucket stops leaking when it is empty, there is always a limit (<em>τ</em>) to how much tolerance can be accrued by these intervals greater than <em>T</em>, however much greater than <em>T</em> they may be or however many of them there are.</p>

<p>Since the limit value <em>τ</em> defines how much earlier a packet can arrive than would be expected, it is the limit on the difference between the maximum and minimum delays from the source to the point where the conformance test is being made (assuming the packets are generated with no jitter). Hence, the use of the term Cell Delay Variation tolerance (CDVt) for this parameter in ATM.</p>

<p>As an example, a possible source of delay variation is where a number of connections (streams of packets) are multiplexed together at the output of a switch. Assuming that the sum of the bandwidths of these connections is less than that of the output, all of the packets that arrive can be transmitted, eventually. However, if their arrivals are independent, e.g. because they arrive at different inputs of the switch, then several may arrive at or nearly at the same time. Since the output can only transmit one packet at a time, the others must be queued in a buffer until it is their turn to be transmitted. This buffer then introduces an additional delay between a packet arriving at an input and being transmitted by the output, and this delay varies, depending on how many other packets are already queued in the buffer. A similar situation can occur at the output of a host (in the NIC) when multiple packets have the same or similar release times, and this delay can usually be modelled as a delay in a virtual output buffer.</p>

<p>For variable length packets, where the amount of water added by a given packet is proportional to its length, <em>τ</em> can’t be seen as a limit on how full the bucket can be when a packet arrives, as this varies depending on the packet size. However, the time it takes to drain from this level to empty is still how much earlier a packet can arrive than is expected, when packets are transmitted at the bandwidth limit. Thus, it is still the maximum variation in transfer delay to the point where the conformance test is being applied that can be tolerated, and thus the tolerance on maximum delay variation.</p>
<h4 id="maximum-burst-size">Maximum Burst Size</h4>

<p>The limit value or delay variation tolerance also controls how many packets can arrive in a burst, determined by the excess depth of the bucket over the capacity required for a single packet. Hence MBS is also a measure of burstiness or jitter, and it is possible to specify the burstiness as an MBS and derive the limit value <em>τ</em> from this or to specify it as a jitter/delay variation tolerance/limit value, and derive the MBS from this.</p>

<p>A burst or clump of packets can arrive at a higher rate than determined by the emission interval <em>T</em>. This may be the line rate of the physical layer connection when the packets in the burst will arrive back-to-back. However, as in ATM, the tolerance may be applied to a lower rate, in that case the <a href="Traffic_contract#Traffic_Parameters" title="wikilink">Sustainable Cell Rate</a> (SCR), and the burst of packets (cells) can arrive at a higher rate, but less than the line rate of the physical layer, in that case the <a href="Traffic_contract#Traffic_Parameters" title="wikilink">Peak Cell Rate</a> (PCR). The MBS may then be the number of cells needed to transport a higher layer packet (see <a href="Segmentation_and_Reassembly" title="wikilink">segmentation and reassembly</a>), where the packets are transmitted with a maximum bandwidth determined by the SCR and cells within the packets are transmitted at the PCR; thus allowing the last cell of the packet, and the packet itself, to arrive significantly earlier than it would if the cells were sent at the SCR: transmission duration = (MBS-1)/PCR rather than (MBS-1)/SCR. This bursting at the PCR puts a significantly higher load on shared resources, e.g. switch output buffers, than does transmission at the SCR, and is thus more likely to result in buffer overflows and network congestion. However, it puts a lesser load on these resources than would transmitting at the SCR with a limit value, <em>τ<sub>SCR</sub></em>, that allows MBS cells to be transmitted and arrive back-to-back at the line rate.</p>

<p>If the limit value is large enough, then several packets can arrive in a burst and still conform: if the bucket starts from empty, the first packet to arrive will add <em>T</em>, but if, by the time the next packet arrives, the contents is below <em>τ</em>, this will also conform. Assuming that each packet takes <em>δ</em> to arrive, then if <em>τ</em> (expressed as the time it takes the bucket to empty from the limit value) is equal to or greater than the emission interval less the minimum interarrival time, <em>T</em> – <em>δ</em>, the second packet will conform even if it arrives as a burst with the first. Similarly, if <em>τ</em> is equal to or greater than (<em>T</em> – <em>δ</em>) × 2, then 3 packets can arrive in a burst, etc.</p>

<p>The maximum size of this burst, <em>M</em>, can be calculated from the emission interval, <em>T</em>; the maximum jitter tolerance, <em>τ</em>; and the time taken to transmit/receive a packet, <em>δ</em>, as follows:<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Leaky_bucket:0">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mo>⌊</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mfrac>
      <mi>τ</mi>
      <mrow>
       <mi>T</mi>
       <mo>-</mo>
       <mi>δ</mi>
      </mrow>
     </mfrac>
    </mrow>
    <mo>⌋</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <floor></floor>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <ci>τ</ci>
       <apply>
        <minus></minus>
        <ci>T</ci>
        <ci>δ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\left\lfloor 1+\frac{\tau}{T-\delta}\right\rfloor
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Equally, the minimum value of jitter tolerance <em>τ</em> that gives a specific MBS can be calculated from the MBS as follows:<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Leaky_bucket:1">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>M</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>T</mi>
      <mo>-</mo>
      <mi>δ</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>τ</ci>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>T</ci>
      <ci>δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau=\left(M-1\right)\left(T-\delta\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>In the case of ATM, where technically MBS only relates to the SCR tolerance, in the above equation the time it takes each packet to arrive, <em>δ</em>, is the emission interval for cells at the PCR <em>T<sub>PCR</sub></em>, and the emission interval, <em>T</em>, is the emission interval for the SCR '' T<sub>SCR</sub>''. Where MBS is to be the number of cells required to transport a segmented packet, the limit value in the above, <em>τ</em>, should be that for the SCR <em>τ<sub>SCR</sub></em>. However, at the UNI or an NNI, where cells at the PCR will have been subjected to delay variation, it should be the limit value for the SCR plus that for the PCR <em>τ<sub>SCR</sub></em> + <em>τ<sub>PCR</sub></em>.</p>

<p>For variable length packets, the maximum burst size will depend on the lengths of the packets in the burst and there is no single value for the maximum burst size. However, it is possible to specify the total burst length in bytes, from the byte rate of the input stream, the equivalent byte rate of the leak, and the bucket depth.</p>
<h3 id="comparison-with-the-token-bucket-algorithm">Comparison with the Token Bucket Algorithm</h3>

<p>The leaky bucket algorithm is sometimes contrasted with the <a href="token_bucket" title="wikilink">token bucket</a> algorithm. However, the above <a href="#Concept_of_Operation" title="wikilink">concept of operation</a> for the leaky bucket as a meter may be directly compared with the <a href="token_bucket" title="wikilink"> token bucket algorithm</a>, the description of which is given in that article as the following:</p>

<p>:*A token is added to the bucket every 1/<em>r</em> seconds.</p>

<p>:*The bucket can hold at the most <em>b</em> tokens. If a token arrives when the bucket is full, it is discarded.</p>

<p>:*When a packet (network layer <a href="protocol_data_unit" title="wikilink">PDU</a>) <a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> of "n" bytes arrives, ''n '' tokens are removed from the bucket, and the packet is sent to the network.</p>

<p>:*If fewer than <em>n</em> tokens are available, no tokens are removed from the bucket, and the packet is considered to be non-conformant.</p>

<p>This can be compared with the concept of operation, repeated from above:</p>

<p>:*A fixed capacity bucket, associated with each virtual connection or user, leaks at a fixed rate.</p>

<p>:* If the bucket is empty, it stops leaking.</p>

<p>:*For a packet to conform, it has to be possible to add a specific amount of water to the bucket: The specific amount added by a conforming packet can be the same for all packets, or can be proportional to the length of the packet.</p>

<p>:*If this amount of water would cause the bucket to exceed its capacity then the packet does not conform and the water in the bucket is left unchanged.</p>

<p>As can be seen, these two descriptions are essentially mirror images of one another: one adds something to the bucket on a regular basis and takes something away for conforming packets down to a limit of zero; the other takes away regularly and adds for conforming packets up to a limit of the bucket's capacity. So, is an implementation that adds tokens for a conforming packet and removes them at a fixed rate an implementation of the leaky bucket or of the token bucket? Similarly, which algorithm is used in an implementation that removes water for a conforming packet and adds water at a fixed rate? In fact both are effectively the same, i.e. implementations of both the leaky bucket and token bucket, as these are the same basic algorithm described differently. This explains why, given equivalent parameters, the two algorithms will see exactly the same packets as conforming or nonconforming. The differences in the properties and performance of implementations of the leaky and token bucket algorithms thus result entirely from the differences in the implementations, i.e. they do not stem from differences in the underlying algorithms.</p>

<p>The points to note are that the leaky bucket algorithm, when used as a meter, can allow a conforming output packet stream with jitter or burstiness, can be used in traffic policing as well as shaping, and can be implemented for variable length packets.</p>
<h2 id="the-leaky-bucket-algorithm-as-a-queue">The Leaky Bucket Algorithm as a Queue</h2>

<p>A seminal description of the leaky bucket as a queue is given by <a href="Andrew_S._Tanenbaum" title="wikilink">Andrew S. Tanenbaum</a>, in his book <em>Computer Networks</em> as “The leaky bucket consists of a finite queue. When a packet arrives, if there is room on the queue it is appended to the queue; otherwise it is discarded. At every clock tick one packet is transmitted (unless the queue is empty)”.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> An implementation of the leaky bucket as a queue is therefore always a form of traffic shaping function.</p>
<figure><b>(Figure)</b>
<figcaption>Figure 4: The leaky bucket as a queue</figcaption>
</figure>

<p>As can be seen this implementation is restricted in that the packets are only ever transmitted at a fixed rate. To underline this, Tanenbaum also states that “The leaky bucket algorithm enforces a rigid output pattern at the average rate, no matter how bursty the [input] traffic is”.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> However, this assertion is only strictly true as long as the queue does not become empty: if the average arrival rate is less than the rate of clock ticks, or if the input is sufficiently bursty that the losses bring the rate of the remainder below the clock tick rate (i.e. gaps in the input stream are long enough and the queue is small enough that it can become empty), there will be gaps in the output stream.</p>

<p>A further restriction is that the leaky bucket as a queue traffic shaping function only transmits packets on the ticks; hence, if it is used within a network, equivalent to <a href="UPC_and_NPC" title="wikilink">UPC and NPC</a>, it also imposes a fixed phase on the onward transmission of packets. Perversely, in the context of the transfer delay, this imposition of a fixed phase that may, over time, differ from that of an otherwise conforming input packet stream, constitutes a delay variation and hence a jitter. However, jitter caused in this particular way could only be observed when making a 2-point delay variation measurement,<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> where the delay is measured as the transit time between two separate measurement points, one either side of the leaky bucket as a queue shaping function. It would not be observable to a downstream traffic management function using, e.g., a token or leaky bucket algorithm, where the delay variation is made as a 1-point measurement.</p>

<p>Limiting variable length packets using the leaky bucket algorithm as a queue is significantly more complicated than it is for fixed length packets. Tanenbaum gives a description of a “byte-counting” leaky bucket for variable length packets as follows: “At each tick, a counter is initialized to n. If the first packet on the queue has fewer bytes than the current value of the counter, it is transmitted, and the counter is decremented by that number of bytes. Additional packets may also be sent, as long as the counter is high enough. When the counter drops below the length of the next packet on the queue, transmission stops until the next tick, at which time the residual byte count is reset [to n] and the flow can continue”.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>
<h3 id="uses-1">Uses</h3>

<p>The leaky bucket as a queue can only be used in <a href="traffic_shaping" title="wikilink">shaping</a> traffic to a specified bandwidth with no jitter in the output.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> It may be used within the network, e.g. as part of bandwidth management, but is more appropriate to traffic shaping in the network interfaces of hosts.</p>
<h3 id="parameters-1">Parameters</h3>

<p>In the case of the leaky bucket algorithm as a queue, the only defined limit for this algorithm is the bandwidth of its output.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>

<p>The bandwidth limit for the connection may be specified in a <a href="traffic_contract" title="wikilink">traffic contract</a>. A bandwidth limit may be specified as a packet or frame rate, a byte or <a href="bit_rate" title="wikilink">bit rate</a>, or as an <a href="#Emission_Interval" title="wikilink">emission interval</a> between the packets.</p>
<h3 id="inefficiency-of-the-leaky-bucket-as-a-queue-implementation">Inefficiency of the leaky-bucket as a queue implementation</h3>

<p>The implementation of the leaky-bucket as a queue does not use available network resources efficiently. Because it transmits packets only at fixed intervals, there will be many instances when the traffic volume is very low and large portions of network resources (bandwidth in particular) are not being used. Therefore no mechanism exists in the leaky-bucket implementation as a queue to allow individual flows to burst up to port speed, effectively consuming network resources at times when there would not be resource contention in the network. Implementations of the token bucket and leaky bucket as a meter do, however, allow output traffic flows to have bursty characteristics.</p>
<h2 id="comparison-between-the-two-versions-of-the-leaky-bucket-algorithm">Comparison Between the two Versions of the Leaky Bucket Algorithm</h2>

<p>Analysis of the two versions of the leaky bucket algorithm shows that the version as a queue is a special case of the version as a meter.</p>

<p>Imagine a traffic shaping function for fixed length packets that is implemented using a fixed length queue, forming a delay element, which is serviced using a leaky bucket as a meter. Imagine also that the bucket in this meter has a depth equal to the amount added by a packet, i.e. has a limit value, <em>τ</em>, of zero. However, the conformance test is only performed at intervals of the emission interval, when the packet at the head of the queue is transmitted and its water is added. This water then leaks away during the next emission interval (or is removed just prior to performing the next conformance test), allowing the next packet to conform then or at some subsequent emission interval. The service function can also be viewed in terms of a token bucket with the same depth, where enough tokens for one packet are added (if the bucket is not full) at the emission intervals. This implementation will then receive packets with a bursty arrival pattern (limited by the queue depth) and transmit them on at intervals that are always exact (integral) multiples of the emission interval.</p>

<p>However, the implementation of the leaky bucket as a meter (or token bucket) in a traffic shaping function described above is an exact equivalent to the description of the leaky bucket as a queue:<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> the delay element of the meter version is the bucket of the queue version; the bucket of the meter version is the process that services the queue, and the leak is such that the emission interval is the same as the tick interval. Therefore for fixed length packets, the implementation of the leaky bucket as a queue is of a special case of a traffic shaping function using a leaky bucket (or token bucket) as a meter in which the limit value, <em>τ</em>, is zero and the process of testing conformance is performed at the lowest possible rate.</p>

<p>The leaky bucket as a queue for variable packet lengths can also be described as equivalent to a special case of the leaky bucket as a meter. The suggested implementation<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> can, like the fixed length implementation, be seen as traffic shaping function in which the queue is a delay element, rather than the bucket, and the function that services the queue is, in this case, explicitly given as a token bucket: it is decremented for conforming packets and incremented at a fixed rate. Hence, as the leaky bucket as a meter and token bucket are equivalent, the leaky bucket as a queue for variable packet lengths is also a special case of a traffic shaping function using a leaky bucket (or token bucket) as a meter.</p>

<p>There is an interesting consequence of seeing the leaky bucket as a queue for variable packet lengths as a specific implementation of the token bucket or leaky bucket as a meter in traffic shaping. This is that the bucket of the meter has a depth, n, and, as is always the case with the token bucket, this depth determines the burstiness of the output traffic (perhaps in relation to the average or minimum number of tokens required by the packets). Hence, it is possible to quantify the burstiness of the output of this "byte counting" leaky bucket as a meter, unless all packets are of the maximum length when it becomes pointless. However, this ability to define a burstiness for the output is in direct contradiction to the statement that the leaky bucket (as a queue) necessarily gives an output with a rigid rate, no matter how bursty the input.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Generic_Cell_Rate_Algorithm" title="wikilink">Generic Cell Rate Algorithm</a></li>
<li><a href="UPC_and_NPC" title="wikilink">UPC and NPC</a></li>
<li><a href="Traffic_contract" title="wikilink">Traffic contract</a></li>
<li><a href="Token_bucket" title="wikilink">Token bucket</a></li>
<li><a href="Fluid_queue" title="wikilink">Fluid queue</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Network_scheduling_algorithms" title="wikilink">Category:Network scheduling algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39"></li>
<li id="fn40"></li>
<li id="fn41"></li>
</ol>
</section>
</body>
</html>
